// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
ChecksCreate performs requests for "checks/create"

Create a check run.

  POST /repos/{owner}/{repo}/check-runs

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
func ChecksCreate(ctx context.Context, req *ChecksCreateReq, opt ...options.Option) (*ChecksCreateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ChecksCreateReq)
	}
	resp := &ChecksCreateResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CheckRun{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksCreate performs requests for "checks/create"

Create a check run.

  POST /repos/{owner}/{repo}/check-runs

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
func (c Client) ChecksCreate(ctx context.Context, req *ChecksCreateReq, opt ...options.Option) (*ChecksCreateResponse, error) {
	return ChecksCreate(ctx, req, append(c, opt...)...)
}

/*
ChecksCreateReq is request data for Client.ChecksCreate

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
type ChecksCreateReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ChecksCreateReqBody

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ChecksCreateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ChecksCreateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"antiope"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "checks/create",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-runs", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksCreateReq) Rel(link RelName, resp *ChecksCreateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ChecksCreateReqBodyActions is a value for ChecksCreateReqBody's Actions field
type ChecksCreateReqBodyActions struct {

	// A short explanation of what this action would do. The maximum size is 40 characters.
	Description *string `json:"description"`

	// A reference for the action on the integrator's system. The maximum size is 20 characters.
	Identifier *string `json:"identifier"`

	// The text to be displayed on a button in the web UI. The maximum size is 20 characters.
	Label *string `json:"label"`
}

// ChecksCreateReqBodyOutput is a value for ChecksCreateReqBody's Output field
type ChecksCreateReqBodyOutput struct {

	/*
	Adds information from your analysis to specific lines of code. Annotations are
	visible on GitHub in the **Checks** and **Files changed** tab of the pull
	request. The Checks API limits the number of annotations to a maximum of 50 per
	API request. To create more than 50 annotations, you have to make multiple
	requests to the [Update a check
	run](https://developer.github.com/v3/checks/runs/#update-a-check-run) endpoint.
	Each time you update the check run, annotations are appended to the list of
	annotations that already exist for the check run. For details about how you can
	view annotations on GitHub, see "[About status
	checks](https://help.github.com/articles/about-status-checks#checks)". See the
	[`annotations`
	object](https://developer.github.com/v3/checks/runs/#annotations-object)
	description for details about how to use this parameter.
	*/
	Annotations []ChecksCreateReqBodyOutputAnnotations `json:"annotations,omitempty"`

	/*
	Adds images to the output displayed in the GitHub pull request UI. See the
	[`images` object](https://developer.github.com/v3/checks/runs/#images-object)
	description for details.
	*/
	Images []ChecksCreateReqBodyOutputImages `json:"images,omitempty"`

	// The summary of the check run. This parameter supports Markdown.
	Summary *string `json:"summary"`

	// The details of the check run. This parameter supports Markdown.
	Text *string `json:"text,omitempty"`

	// The title of the check run.
	Title *string `json:"title"`
}

// ChecksCreateReqBodyOutputAnnotations is a value for ChecksCreateReqBodyOutput's Annotations field
type ChecksCreateReqBodyOutputAnnotations struct {

	// The level of the annotation. Can be one of `notice`, `warning`, or `failure`.
	AnnotationLevel *string `json:"annotation_level"`

	/*
	The end column of the annotation. Annotations only support `start_column` and
	`end_column` on the same line. Omit this parameter if `start_line` and
	`end_line` have different values.
	*/
	EndColumn *int64 `json:"end_column,omitempty"`

	// The end line of the annotation.
	EndLine *int64 `json:"end_line"`

	// A short description of the feedback for these lines of code. The maximum size is 64 KB.
	Message *string `json:"message"`

	// The path of the file to add an annotation to. For example, `assets/css/main.css`.
	Path *string `json:"path"`

	// Details about this annotation. The maximum size is 64 KB.
	RawDetails *string `json:"raw_details,omitempty"`

	/*
	The start column of the annotation. Annotations only support `start_column` and
	`end_column` on the same line. Omit this parameter if `start_line` and
	`end_line` have different values.
	*/
	StartColumn *int64 `json:"start_column,omitempty"`

	// The start line of the annotation.
	StartLine *int64 `json:"start_line"`

	// The title that represents the annotation. The maximum size is 255 characters.
	Title *string `json:"title,omitempty"`
}

// ChecksCreateReqBodyOutputImages is a value for ChecksCreateReqBodyOutput's Images field
type ChecksCreateReqBodyOutputImages struct {

	// The alternative text for the image.
	Alt *string `json:"alt"`

	// A short image description.
	Caption *string `json:"caption,omitempty"`

	// The full URL of the image.
	ImageUrl *string `json:"image_url"`
}

/*
ChecksCreateReqBody is a request body for checks/create

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
type ChecksCreateReqBody struct {

	/*
	Displays a button on GitHub that can be clicked to alert your app to do
	additional tasks. For example, a code linting app can display a button that
	automatically fixes detected errors. The button created in this object is
	displayed after the check run completes. When a user clicks the button, GitHub
	sends the [`check_run.requested_action`
	webhook](https://developer.github.com/webhooks/event-payloads/#check_run) to
	your app. Each action includes a `label`, `identifier` and `description`. A
	maximum of three actions are accepted. See the [`actions`
	object](https://developer.github.com/v3/checks/runs/#actions-object)
	description. To learn more about check runs and requested actions, see "[Check
	runs and requested
	actions](https://developer.github.com/v3/checks/runs/#check-runs-and-requested-actions)."
	To learn more about check runs and requested actions, see "[Check runs and
	requested
	actions](https://developer.github.com/v3/checks/runs/#check-runs-and-requested-actions)."
	*/
	Actions []ChecksCreateReqBodyActions `json:"actions,omitempty"`

	/*
	The time the check completed. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	CompletedAt *string `json:"completed_at,omitempty"`

	/*
	**Required if you provide `completed_at` or a `status` of `completed`**. The
	final conclusion of the check. Can be one of `success`, `failure`, `neutral`,
	`cancelled`, `skipped`, `timed_out`, or `action_required`. When the conclusion
	is `action_required`, additional details should be provided on the site
	specified by `details_url`.
	**Note:** Providing `conclusion` will automatically set the `status` parameter
	to `completed`. Only GitHub can change a check run conclusion to `stale`.
	*/
	Conclusion *string `json:"conclusion,omitempty"`

	/*
	The URL of the integrator's site that has the full details of the check. If the
	integrator does not provide this, then the homepage of the GitHub app is used.
	*/
	DetailsUrl *string `json:"details_url,omitempty"`

	// A reference for the run on the integrator's system.
	ExternalId *string `json:"external_id,omitempty"`

	// The SHA of the commit.
	HeadSha *string `json:"head_sha"`

	// The name of the check. For example, "code-coverage".
	Name *string `json:"name"`

	/*
	Check runs can accept a variety of data in the `output` object, including a
	`title` and `summary` and can optionally provide descriptive details about the
	run. See the [`output`
	object](https://developer.github.com/v3/checks/runs/#output-object) description.
	*/
	Output *ChecksCreateReqBodyOutput `json:"output,omitempty"`

	/*
	The time that the check run began. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	StartedAt *string `json:"started_at,omitempty"`

	// The current status. Can be one of `queued`, `in_progress`, or `completed`.
	Status *string `json:"status,omitempty"`
}

/*
ChecksCreateResponse is a response for ChecksCreate

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
type ChecksCreateResponse struct {
	internal.Response
	request *ChecksCreateReq
	Data    components.CheckRun
}

/*
ChecksCreateSuite performs requests for "checks/create-suite"

Create a check suite.

  POST /repos/{owner}/{repo}/check-suites

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
func ChecksCreateSuite(ctx context.Context, req *ChecksCreateSuiteReq, opt ...options.Option) (*ChecksCreateSuiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ChecksCreateSuiteReq)
	}
	resp := &ChecksCreateSuiteResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CheckSuite{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksCreateSuite performs requests for "checks/create-suite"

Create a check suite.

  POST /repos/{owner}/{repo}/check-suites

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
func (c Client) ChecksCreateSuite(ctx context.Context, req *ChecksCreateSuiteReq, opt ...options.Option) (*ChecksCreateSuiteResponse, error) {
	return ChecksCreateSuite(ctx, req, append(c, opt...)...)
}

/*
ChecksCreateSuiteReq is request data for Client.ChecksCreateSuite

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
type ChecksCreateSuiteReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ChecksCreateSuiteReqBody

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ChecksCreateSuiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ChecksCreateSuiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"antiope"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "checks/create-suite",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-suites", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksCreateSuiteReq) Rel(link RelName, resp *ChecksCreateSuiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ChecksCreateSuiteReqBody is a request body for checks/create-suite

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
type ChecksCreateSuiteReqBody struct {

	// The sha of the head commit.
	HeadSha *string `json:"head_sha"`
}

/*
ChecksCreateSuiteResponse is a response for ChecksCreateSuite

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
type ChecksCreateSuiteResponse struct {
	internal.Response
	request *ChecksCreateSuiteReq
	Data    components.CheckSuite
}

/*
ChecksGet performs requests for "checks/get"

Get a check run.

  GET /repos/{owner}/{repo}/check-runs/{check_run_id}

https://developer.github.com/v3/checks/runs/#get-a-check-run
*/
func ChecksGet(ctx context.Context, req *ChecksGetReq, opt ...options.Option) (*ChecksGetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ChecksGetReq)
	}
	resp := &ChecksGetResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CheckRun{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksGet performs requests for "checks/get"

Get a check run.

  GET /repos/{owner}/{repo}/check-runs/{check_run_id}

https://developer.github.com/v3/checks/runs/#get-a-check-run
*/
func (c Client) ChecksGet(ctx context.Context, req *ChecksGetReq, opt ...options.Option) (*ChecksGetResponse, error) {
	return ChecksGet(ctx, req, append(c, opt...)...)
}

/*
ChecksGetReq is request data for Client.ChecksGet

https://developer.github.com/v3/checks/runs/#get-a-check-run
*/
type ChecksGetReq struct {
	_url  string
	Owner string
	Repo  string

	// check_run_id parameter
	CheckRunId int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ChecksGetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ChecksGetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "checks/get",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-runs/%v", r.Owner, r.Repo, r.CheckRunId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksGetReq) Rel(link RelName, resp *ChecksGetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ChecksGetResponse is a response for ChecksGet

https://developer.github.com/v3/checks/runs/#get-a-check-run
*/
type ChecksGetResponse struct {
	internal.Response
	request *ChecksGetReq
	Data    components.CheckRun
}

/*
ChecksGetSuite performs requests for "checks/get-suite"

Get a check suite.

  GET /repos/{owner}/{repo}/check-suites/{check_suite_id}

https://developer.github.com/v3/checks/suites/#get-a-check-suite
*/
func ChecksGetSuite(ctx context.Context, req *ChecksGetSuiteReq, opt ...options.Option) (*ChecksGetSuiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ChecksGetSuiteReq)
	}
	resp := &ChecksGetSuiteResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CheckSuite{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksGetSuite performs requests for "checks/get-suite"

Get a check suite.

  GET /repos/{owner}/{repo}/check-suites/{check_suite_id}

https://developer.github.com/v3/checks/suites/#get-a-check-suite
*/
func (c Client) ChecksGetSuite(ctx context.Context, req *ChecksGetSuiteReq, opt ...options.Option) (*ChecksGetSuiteResponse, error) {
	return ChecksGetSuite(ctx, req, append(c, opt...)...)
}

/*
ChecksGetSuiteReq is request data for Client.ChecksGetSuite

https://developer.github.com/v3/checks/suites/#get-a-check-suite
*/
type ChecksGetSuiteReq struct {
	_url  string
	Owner string
	Repo  string

	// check_suite_id parameter
	CheckSuiteId int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ChecksGetSuiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ChecksGetSuiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "checks/get-suite",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-suites/%v", r.Owner, r.Repo, r.CheckSuiteId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksGetSuiteReq) Rel(link RelName, resp *ChecksGetSuiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ChecksGetSuiteResponse is a response for ChecksGetSuite

https://developer.github.com/v3/checks/suites/#get-a-check-suite
*/
type ChecksGetSuiteResponse struct {
	internal.Response
	request *ChecksGetSuiteReq
	Data    components.CheckSuite
}

/*
ChecksListAnnotations performs requests for "checks/list-annotations"

List check run annotations.

  GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations

https://developer.github.com/v3/checks/runs/#list-check-run-annotations
*/
func ChecksListAnnotations(ctx context.Context, req *ChecksListAnnotationsReq, opt ...options.Option) (*ChecksListAnnotationsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ChecksListAnnotationsReq)
	}
	resp := &ChecksListAnnotationsResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CheckAnnotation{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksListAnnotations performs requests for "checks/list-annotations"

List check run annotations.

  GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations

https://developer.github.com/v3/checks/runs/#list-check-run-annotations
*/
func (c Client) ChecksListAnnotations(ctx context.Context, req *ChecksListAnnotationsReq, opt ...options.Option) (*ChecksListAnnotationsResponse, error) {
	return ChecksListAnnotations(ctx, req, append(c, opt...)...)
}

/*
ChecksListAnnotationsReq is request data for Client.ChecksListAnnotations

https://developer.github.com/v3/checks/runs/#list-check-run-annotations
*/
type ChecksListAnnotationsReq struct {
	_url  string
	Owner string
	Repo  string

	// check_run_id parameter
	CheckRunId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ChecksListAnnotationsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ChecksListAnnotationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "checks/list-annotations",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-runs/%v/annotations", r.Owner, r.Repo, r.CheckRunId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksListAnnotationsReq) Rel(link RelName, resp *ChecksListAnnotationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ChecksListAnnotationsResponse is a response for ChecksListAnnotations

https://developer.github.com/v3/checks/runs/#list-check-run-annotations
*/
type ChecksListAnnotationsResponse struct {
	internal.Response
	request *ChecksListAnnotationsReq
	Data    []components.CheckAnnotation
}

/*
ChecksListForRef performs requests for "checks/list-for-ref"

List check runs for a Git reference.

  GET /repos/{owner}/{repo}/commits/{ref}/check-runs

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
func ChecksListForRef(ctx context.Context, req *ChecksListForRefReq, opt ...options.Option) (*ChecksListForRefResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ChecksListForRefReq)
	}
	resp := &ChecksListForRefResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ChecksListForRefResponseBody{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksListForRef performs requests for "checks/list-for-ref"

List check runs for a Git reference.

  GET /repos/{owner}/{repo}/commits/{ref}/check-runs

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
func (c Client) ChecksListForRef(ctx context.Context, req *ChecksListForRefReq, opt ...options.Option) (*ChecksListForRefResponse, error) {
	return ChecksListForRef(ctx, req, append(c, opt...)...)
}

/*
ChecksListForRefReq is request data for Client.ChecksListForRef

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
type ChecksListForRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string

	// Returns check runs with the specified `name`.
	CheckName *string

	/*
	Returns check runs with the specified `status`. Can be one of `queued`,
	`in_progress`, or `completed`.
	*/
	Status *string

	/*
	Filters check runs by their `completed_at` timestamp. Can be one of `latest`
	(returning the most recent check runs) or `all`.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ChecksListForRefReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ChecksListForRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.CheckName != nil {
		query.Set("check_name", *r.CheckName)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "checks/list-for-ref",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/check-runs", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksListForRefReq) Rel(link RelName, resp *ChecksListForRefResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ChecksListForRefResponseBody is a response body for ChecksListForRef

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
type ChecksListForRefResponseBody struct {
	CheckRuns  []components.CheckRun `json:"check_runs,omitempty"`
	TotalCount int64                 `json:"total_count,omitempty"`
}

/*
ChecksListForRefResponse is a response for ChecksListForRef

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
type ChecksListForRefResponse struct {
	internal.Response
	request *ChecksListForRefReq
	Data    ChecksListForRefResponseBody
}

/*
ChecksListForSuite performs requests for "checks/list-for-suite"

List check runs in a check suite.

  GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
func ChecksListForSuite(ctx context.Context, req *ChecksListForSuiteReq, opt ...options.Option) (*ChecksListForSuiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ChecksListForSuiteReq)
	}
	resp := &ChecksListForSuiteResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ChecksListForSuiteResponseBody{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksListForSuite performs requests for "checks/list-for-suite"

List check runs in a check suite.

  GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
func (c Client) ChecksListForSuite(ctx context.Context, req *ChecksListForSuiteReq, opt ...options.Option) (*ChecksListForSuiteResponse, error) {
	return ChecksListForSuite(ctx, req, append(c, opt...)...)
}

/*
ChecksListForSuiteReq is request data for Client.ChecksListForSuite

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
type ChecksListForSuiteReq struct {
	_url  string
	Owner string
	Repo  string

	// check_suite_id parameter
	CheckSuiteId int64

	// Returns check runs with the specified `name`.
	CheckName *string

	/*
	Returns check runs with the specified `status`. Can be one of `queued`,
	`in_progress`, or `completed`.
	*/
	Status *string

	/*
	Filters check runs by their `completed_at` timestamp. Can be one of `latest`
	(returning the most recent check runs) or `all`.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ChecksListForSuiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ChecksListForSuiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.CheckName != nil {
		query.Set("check_name", *r.CheckName)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "checks/list-for-suite",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-suites/%v/check-runs", r.Owner, r.Repo, r.CheckSuiteId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksListForSuiteReq) Rel(link RelName, resp *ChecksListForSuiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ChecksListForSuiteResponseBody is a response body for ChecksListForSuite

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
type ChecksListForSuiteResponseBody struct {
	CheckRuns  []components.CheckRun `json:"check_runs,omitempty"`
	TotalCount int64                 `json:"total_count,omitempty"`
}

/*
ChecksListForSuiteResponse is a response for ChecksListForSuite

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
type ChecksListForSuiteResponse struct {
	internal.Response
	request *ChecksListForSuiteReq
	Data    ChecksListForSuiteResponseBody
}

/*
ChecksListSuitesForRef performs requests for "checks/list-suites-for-ref"

List check suites for a Git reference.

  GET /repos/{owner}/{repo}/commits/{ref}/check-suites

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
func ChecksListSuitesForRef(ctx context.Context, req *ChecksListSuitesForRefReq, opt ...options.Option) (*ChecksListSuitesForRefResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ChecksListSuitesForRefReq)
	}
	resp := &ChecksListSuitesForRefResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ChecksListSuitesForRefResponseBody{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksListSuitesForRef performs requests for "checks/list-suites-for-ref"

List check suites for a Git reference.

  GET /repos/{owner}/{repo}/commits/{ref}/check-suites

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
func (c Client) ChecksListSuitesForRef(ctx context.Context, req *ChecksListSuitesForRefReq, opt ...options.Option) (*ChecksListSuitesForRefResponse, error) {
	return ChecksListSuitesForRef(ctx, req, append(c, opt...)...)
}

/*
ChecksListSuitesForRefReq is request data for Client.ChecksListSuitesForRef

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
type ChecksListSuitesForRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string

	// Filters check suites by GitHub App `id`.
	AppId *int64

	// Returns check runs with the specified `name`.
	CheckName *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ChecksListSuitesForRefReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ChecksListSuitesForRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.AppId != nil {
		query.Set("app_id", strconv.FormatInt(*r.AppId, 10))
	}
	if r.CheckName != nil {
		query.Set("check_name", *r.CheckName)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "checks/list-suites-for-ref",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/check-suites", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksListSuitesForRefReq) Rel(link RelName, resp *ChecksListSuitesForRefResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ChecksListSuitesForRefResponseBody is a response body for ChecksListSuitesForRef

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
type ChecksListSuitesForRefResponseBody struct {
	CheckSuites []components.CheckSuite `json:"check_suites,omitempty"`
	TotalCount  int64                   `json:"total_count,omitempty"`
}

/*
ChecksListSuitesForRefResponse is a response for ChecksListSuitesForRef

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
type ChecksListSuitesForRefResponse struct {
	internal.Response
	request *ChecksListSuitesForRefReq
	Data    ChecksListSuitesForRefResponseBody
}

/*
ChecksRerequestSuite performs requests for "checks/rerequest-suite"

Rerequest a check suite.

  POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest

https://developer.github.com/v3/checks/suites/#rerequest-a-check-suite
*/
func ChecksRerequestSuite(ctx context.Context, req *ChecksRerequestSuiteReq, opt ...options.Option) (*ChecksRerequestSuiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ChecksRerequestSuiteReq)
	}
	resp := &ChecksRerequestSuiteResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksRerequestSuite performs requests for "checks/rerequest-suite"

Rerequest a check suite.

  POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest

https://developer.github.com/v3/checks/suites/#rerequest-a-check-suite
*/
func (c Client) ChecksRerequestSuite(ctx context.Context, req *ChecksRerequestSuiteReq, opt ...options.Option) (*ChecksRerequestSuiteResponse, error) {
	return ChecksRerequestSuite(ctx, req, append(c, opt...)...)
}

/*
ChecksRerequestSuiteReq is request data for Client.ChecksRerequestSuite

https://developer.github.com/v3/checks/suites/#rerequest-a-check-suite
*/
type ChecksRerequestSuiteReq struct {
	_url  string
	Owner string
	Repo  string

	// check_suite_id parameter
	CheckSuiteId int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ChecksRerequestSuiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ChecksRerequestSuiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "POST",
		OperationID:      "checks/rerequest-suite",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-suites/%v/rerequest", r.Owner, r.Repo, r.CheckSuiteId),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksRerequestSuiteReq) Rel(link RelName, resp *ChecksRerequestSuiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ChecksRerequestSuiteResponse is a response for ChecksRerequestSuite

https://developer.github.com/v3/checks/suites/#rerequest-a-check-suite
*/
type ChecksRerequestSuiteResponse struct {
	internal.Response
	request *ChecksRerequestSuiteReq
}

/*
ChecksSetSuitesPreferences performs requests for "checks/set-suites-preferences"

Update repository preferences for check suites.

  PATCH /repos/{owner}/{repo}/check-suites/preferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
func ChecksSetSuitesPreferences(ctx context.Context, req *ChecksSetSuitesPreferencesReq, opt ...options.Option) (*ChecksSetSuitesPreferencesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ChecksSetSuitesPreferencesReq)
	}
	resp := &ChecksSetSuitesPreferencesResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CheckSuitePreference{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksSetSuitesPreferences performs requests for "checks/set-suites-preferences"

Update repository preferences for check suites.

  PATCH /repos/{owner}/{repo}/check-suites/preferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
func (c Client) ChecksSetSuitesPreferences(ctx context.Context, req *ChecksSetSuitesPreferencesReq, opt ...options.Option) (*ChecksSetSuitesPreferencesResponse, error) {
	return ChecksSetSuitesPreferences(ctx, req, append(c, opt...)...)
}

/*
ChecksSetSuitesPreferencesReq is request data for Client.ChecksSetSuitesPreferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
type ChecksSetSuitesPreferencesReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ChecksSetSuitesPreferencesReqBody

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ChecksSetSuitesPreferencesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ChecksSetSuitesPreferencesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"antiope"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "checks/set-suites-preferences",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-suites/preferences", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksSetSuitesPreferencesReq) Rel(link RelName, resp *ChecksSetSuitesPreferencesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ChecksSetSuitesPreferencesReqBodyAutoTriggerChecks is a value for ChecksSetSuitesPreferencesReqBody's AutoTriggerChecks field
type ChecksSetSuitesPreferencesReqBodyAutoTriggerChecks struct {

	// The `id` of the GitHub App.
	AppId *int64 `json:"app_id"`

	/*
	Set to `true` to enable automatic creation of CheckSuite events upon pushes to
	the repository, or `false` to disable them.
	*/
	Setting *bool `json:"setting"`
}

/*
ChecksSetSuitesPreferencesReqBody is a request body for checks/set-suites-preferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
type ChecksSetSuitesPreferencesReqBody struct {

	/*
	Enables or disables automatic creation of CheckSuite events upon pushes to the
	repository. Enabled by default. See the [`auto_trigger_checks`
	object](https://developer.github.com/v3/checks/suites/#auto_trigger_checks-object)
	description for details.
	*/
	AutoTriggerChecks []ChecksSetSuitesPreferencesReqBodyAutoTriggerChecks `json:"auto_trigger_checks,omitempty"`
}

/*
ChecksSetSuitesPreferencesResponse is a response for ChecksSetSuitesPreferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
type ChecksSetSuitesPreferencesResponse struct {
	internal.Response
	request *ChecksSetSuitesPreferencesReq
	Data    components.CheckSuitePreference
}

/*
ChecksUpdate performs requests for "checks/update"

Update a check run.

  PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
func ChecksUpdate(ctx context.Context, req *ChecksUpdateReq, opt ...options.Option) (*ChecksUpdateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ChecksUpdateReq)
	}
	resp := &ChecksUpdateResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CheckRun{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksUpdate performs requests for "checks/update"

Update a check run.

  PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
func (c Client) ChecksUpdate(ctx context.Context, req *ChecksUpdateReq, opt ...options.Option) (*ChecksUpdateResponse, error) {
	return ChecksUpdate(ctx, req, append(c, opt...)...)
}

/*
ChecksUpdateReq is request data for Client.ChecksUpdate

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
type ChecksUpdateReq struct {
	_url  string
	Owner string
	Repo  string

	// check_run_id parameter
	CheckRunId  int64
	RequestBody ChecksUpdateReqBody

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ChecksUpdateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ChecksUpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"antiope"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "checks/update",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-runs/%v", r.Owner, r.Repo, r.CheckRunId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksUpdateReq) Rel(link RelName, resp *ChecksUpdateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ChecksUpdateReqBodyActions is a value for ChecksUpdateReqBody's Actions field
type ChecksUpdateReqBodyActions struct {

	// A short explanation of what this action would do. The maximum size is 40 characters.
	Description *string `json:"description"`

	// A reference for the action on the integrator's system. The maximum size is 20 characters.
	Identifier *string `json:"identifier"`

	// The text to be displayed on a button in the web UI. The maximum size is 20 characters.
	Label *string `json:"label"`
}

// ChecksUpdateReqBodyOutput is a value for ChecksUpdateReqBody's Output field
type ChecksUpdateReqBodyOutput struct {

	/*
	Adds information from your analysis to specific lines of code. Annotations are
	visible in GitHub's pull request UI. Annotations are visible in GitHub's pull
	request UI. The Checks API limits the number of annotations to a maximum of 50
	per API request. To create more than 50 annotations, you have to make multiple
	requests to the [Update a check
	run](https://developer.github.com/v3/checks/runs/#update-a-check-run) endpoint.
	Each time you update the check run, annotations are appended to the list of
	annotations that already exist for the check run. For details about annotations
	in the UI, see "[About status
	checks](https://help.github.com/articles/about-status-checks#checks)". See the
	[`annotations`
	object](https://developer.github.com/v3/checks/runs/#annotations-object-1)
	description for details.
	*/
	Annotations []ChecksUpdateReqBodyOutputAnnotations `json:"annotations,omitempty"`

	/*
	Adds images to the output displayed in the GitHub pull request UI. See the
	[`images`
	object](https://developer.github.com/v3/checks/runs/#annotations-object-1)
	description for details.
	*/
	Images []ChecksUpdateReqBodyOutputImages `json:"images,omitempty"`

	// Can contain Markdown.
	Summary *string `json:"summary"`

	// Can contain Markdown.
	Text *string `json:"text,omitempty"`

	// **Required**.
	Title *string `json:"title,omitempty"`
}

// ChecksUpdateReqBodyOutputAnnotations is a value for ChecksUpdateReqBodyOutput's Annotations field
type ChecksUpdateReqBodyOutputAnnotations struct {

	// The level of the annotation. Can be one of `notice`, `warning`, or `failure`.
	AnnotationLevel *string `json:"annotation_level"`

	/*
	The end column of the annotation. Annotations only support `start_column` and
	`end_column` on the same line. Omit this parameter if `start_line` and
	`end_line` have different values.
	*/
	EndColumn *int64 `json:"end_column,omitempty"`

	// The end line of the annotation.
	EndLine *int64 `json:"end_line"`

	// A short description of the feedback for these lines of code. The maximum size is 64 KB.
	Message *string `json:"message"`

	// The path of the file to add an annotation to. For example, `assets/css/main.css`.
	Path *string `json:"path"`

	// Details about this annotation. The maximum size is 64 KB.
	RawDetails *string `json:"raw_details,omitempty"`

	/*
	The start column of the annotation. Annotations only support `start_column` and
	`end_column` on the same line. Omit this parameter if `start_line` and
	`end_line` have different values.
	*/
	StartColumn *int64 `json:"start_column,omitempty"`

	// The start line of the annotation.
	StartLine *int64 `json:"start_line"`

	// The title that represents the annotation. The maximum size is 255 characters.
	Title *string `json:"title,omitempty"`
}

// ChecksUpdateReqBodyOutputImages is a value for ChecksUpdateReqBodyOutput's Images field
type ChecksUpdateReqBodyOutputImages struct {

	// The alternative text for the image.
	Alt *string `json:"alt"`

	// A short image description.
	Caption *string `json:"caption,omitempty"`

	// The full URL of the image.
	ImageUrl *string `json:"image_url"`
}

/*
ChecksUpdateReqBody is a request body for checks/update

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
type ChecksUpdateReqBody struct {

	/*
	Possible further actions the integrator can perform, which a user may trigger.
	Each action includes a `label`, `identifier` and `description`. A maximum of
	three actions are accepted. See the [`actions`
	object](https://developer.github.com/v3/checks/runs/#actions-object)
	description. To learn more about check runs and requested actions, see "[Check
	runs and requested
	actions](https://developer.github.com/v3/checks/runs/#check-runs-and-requested-actions)."
	*/
	Actions []ChecksUpdateReqBodyActions `json:"actions,omitempty"`

	/*
	The time the check completed. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	CompletedAt *string `json:"completed_at,omitempty"`

	/*
	**Required if you provide `completed_at` or a `status` of `completed`**. The
	final conclusion of the check. Can be one of `success`, `failure`, `neutral`,
	`cancelled`, `skipped`, `timed_out`, or `action_required`.
	**Note:** Providing `conclusion` will automatically set the `status` parameter
	to `completed`. Only GitHub can change a check run conclusion to `stale`.
	*/
	Conclusion *string `json:"conclusion,omitempty"`

	// The URL of the integrator's site that has the full details of the check.
	DetailsUrl *string `json:"details_url,omitempty"`

	// A reference for the run on the integrator's system.
	ExternalId *string `json:"external_id,omitempty"`

	// The name of the check. For example, "code-coverage".
	Name *string `json:"name,omitempty"`

	/*
	Check runs can accept a variety of data in the `output` object, including a
	`title` and `summary` and can optionally provide descriptive details about the
	run. See the [`output`
	object](https://developer.github.com/v3/checks/runs/#output-object-1)
	description.
	*/
	Output *ChecksUpdateReqBodyOutput `json:"output,omitempty"`

	// This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	StartedAt *string `json:"started_at,omitempty"`

	// The current status. Can be one of `queued`, `in_progress`, or `completed`.
	Status *string `json:"status,omitempty"`
}

/*
ChecksUpdateResponse is a response for ChecksUpdate

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
type ChecksUpdateResponse struct {
	internal.Response
	request *ChecksUpdateReq
	Data    components.CheckRun
}
