// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
ChecksCreate performs requests for "checks/create"

Create a check run.

  POST /repos/{owner}/{repo}/check-runs

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
func (c *Client) ChecksCreate(ctx context.Context, req *ChecksCreateReq, opt ...RequestOption) (*ChecksCreateResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ChecksCreateResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ChecksCreateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksCreateReq is request data for Client.ChecksCreate

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
type ChecksCreateReq struct {
	pgURL       string
	Owner       string
	Repo        string
	RequestBody ChecksCreateReqBody

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

func (r *ChecksCreateReq) pagingURL() string {
	return r.pgURL
}

func (r *ChecksCreateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/check-runs", r.Owner, r.Repo)
}

func (r *ChecksCreateReq) method() string {
	return "POST"
}

func (r *ChecksCreateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ChecksCreateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"antiope": r.AntiopePreview}
	if requiredPreviews {
		previewVals["antiope"] = true
	}
	if allPreviews {
		previewVals["antiope"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ChecksCreateReq) body() interface{} {
	return r.RequestBody
}

func (r *ChecksCreateReq) dataStatuses() []int {
	return []int{201}
}

func (r *ChecksCreateReq) validStatuses() []int {
	return []int{201}
}

func (r *ChecksCreateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ChecksCreateReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksCreateReq) Rel(link RelName, resp *ChecksCreateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

// ChecksCreateReqBodyActions is a value for ChecksCreateReqBody's Actions field
type ChecksCreateReqBodyActions struct {

	/*
	   A short explanation of what this action would do. The maximum size is 40
	   characters.
	*/
	Description *string `json:"description"`

	/*
	   A reference for the action on the integrator's system. The maximum size is 20
	   characters.
	*/
	Identifier *string `json:"identifier"`

	/*
	   The text to be displayed on a button in the web UI. The maximum size is 20
	   characters.
	*/
	Label *string `json:"label"`
}

// ChecksCreateReqBodyOutput is a value for ChecksCreateReqBody's Output field
type ChecksCreateReqBodyOutput struct {

	/*
	   Adds information from your analysis to specific lines of code. Annotations are
	   visible on GitHub in the **Checks** and **Files changed** tab of the pull
	   request. The Checks API limits the number of annotations to a maximum of 50 per
	   API request. To create more than 50 annotations, you have to make multiple
	   requests to the [Update a check
	   run](https://developer.github.com/v3/checks/runs/#update-a-check-run) endpoint.
	   Each time you update the check run, annotations are appended to the list of
	   annotations that already exist for the check run. For details about how you can
	   view annotations on GitHub, see "[About status
	   checks](https://help.github.com/articles/about-status-checks#checks)". See the
	   [`annotations`
	   object](https://developer.github.com/v3/checks/runs/#annotations-object)
	   description for details about how to use this parameter.
	*/
	Annotations []ChecksCreateReqBodyOutputAnnotations `json:"annotations,omitempty"`

	/*
	   Adds images to the output displayed in the GitHub pull request UI. See the
	   [`images` object](https://developer.github.com/v3/checks/runs/#images-object)
	   description for details.
	*/
	Images []ChecksCreateReqBodyOutputImages `json:"images,omitempty"`

	// The summary of the check run. This parameter supports Markdown.
	Summary *string `json:"summary"`

	// The details of the check run. This parameter supports Markdown.
	Text *string `json:"text,omitempty"`

	// The title of the check run.
	Title *string `json:"title"`
}

// ChecksCreateReqBodyOutputAnnotations is a value for ChecksCreateReqBodyOutput's Annotations field
type ChecksCreateReqBodyOutputAnnotations struct {

	// The level of the annotation. Can be one of `notice`, `warning`, or `failure`.
	AnnotationLevel *string `json:"annotation_level"`

	/*
	   The end column of the annotation. Annotations only support `start_column` and
	   `end_column` on the same line. Omit this parameter if `start_line` and
	   `end_line` have different values.
	*/
	EndColumn *int64 `json:"end_column,omitempty"`

	// The end line of the annotation.
	EndLine *int64 `json:"end_line"`

	/*
	   A short description of the feedback for these lines of code. The maximum size is
	   64 KB.
	*/
	Message *string `json:"message"`

	/*
	   The path of the file to add an annotation to. For example,
	   `assets/css/main.css`.
	*/
	Path *string `json:"path"`

	// Details about this annotation. The maximum size is 64 KB.
	RawDetails *string `json:"raw_details,omitempty"`

	/*
	   The start column of the annotation. Annotations only support `start_column` and
	   `end_column` on the same line. Omit this parameter if `start_line` and
	   `end_line` have different values.
	*/
	StartColumn *int64 `json:"start_column,omitempty"`

	// The start line of the annotation.
	StartLine *int64 `json:"start_line"`

	// The title that represents the annotation. The maximum size is 255 characters.
	Title *string `json:"title,omitempty"`
}

// ChecksCreateReqBodyOutputImages is a value for ChecksCreateReqBodyOutput's Images field
type ChecksCreateReqBodyOutputImages struct {

	// The alternative text for the image.
	Alt *string `json:"alt"`

	// A short image description.
	Caption *string `json:"caption,omitempty"`

	// The full URL of the image.
	ImageUrl *string `json:"image_url"`
}

/*
ChecksCreateReqBody is a request body for checks/create

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
type ChecksCreateReqBody struct {

	/*
	   Displays a button on GitHub that can be clicked to alert your app to do
	   additional tasks. For example, a code linting app can display a button that
	   automatically fixes detected errors. The button created in this object is
	   displayed after the check run completes. When a user clicks the button, GitHub
	   sends the [`check_run.requested_action`
	   webhook](https://developer.github.com/webhooks/event-payloads/#check_run) to
	   your app. Each action includes a `label`, `identifier` and `description`. A
	   maximum of three actions are accepted. See the [`actions`
	   object](https://developer.github.com/v3/checks/runs/#actions-object)
	   description. To learn more about check runs and requested actions, see "[Check
	   runs and requested
	   actions](https://developer.github.com/v3/checks/runs/#check-runs-and-requested-actions)."
	   To learn more about check runs and requested actions, see "[Check runs and
	   requested
	   actions](https://developer.github.com/v3/checks/runs/#check-runs-and-requested-actions)."
	*/
	Actions []ChecksCreateReqBodyActions `json:"actions,omitempty"`

	/*
	   The time the check completed. This is a timestamp in [ISO
	   8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	CompletedAt *string `json:"completed_at,omitempty"`

	/*
	   **Required if you provide `completed_at` or a `status` of `completed`**. The
	   final conclusion of the check. Can be one of `success`, `failure`, `neutral`,
	   `cancelled`, `skipped`, `timed_out`, or `action_required`. When the conclusion
	   is `action_required`, additional details should be provided on the site
	   specified by `details_url`.
	   **Note:** Providing `conclusion` will automatically set the `status` parameter
	   to `completed`. Only GitHub can change a check run conclusion to `stale`.
	*/
	Conclusion *string `json:"conclusion,omitempty"`

	/*
	   The URL of the integrator's site that has the full details of the check. If the
	   integrator does not provide this, then the homepage of the GitHub app is used.
	*/
	DetailsUrl *string `json:"details_url,omitempty"`

	// A reference for the run on the integrator's system.
	ExternalId *string `json:"external_id,omitempty"`

	// The SHA of the commit.
	HeadSha *string `json:"head_sha"`

	// The name of the check. For example, "code-coverage".
	Name *string `json:"name"`

	/*
	   Check runs can accept a variety of data in the `output` object, including a
	   `title` and `summary` and can optionally provide descriptive details about the
	   run. See the [`output`
	   object](https://developer.github.com/v3/checks/runs/#output-object) description.
	*/
	Output *ChecksCreateReqBodyOutput `json:"output,omitempty"`

	/*
	   The time that the check run began. This is a timestamp in [ISO
	   8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	StartedAt *string `json:"started_at,omitempty"`

	// The current status. Can be one of `queued`, `in_progress`, or `completed`.
	Status *string `json:"status,omitempty"`
}

/*
ChecksCreateResponseBody is a response body for ChecksCreate

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
type ChecksCreateResponseBody struct {
	components.CheckRun
}

/*
ChecksCreateResponse is a response for ChecksCreate

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
type ChecksCreateResponse struct {
	response
	request *ChecksCreateReq
	Data    *ChecksCreateResponseBody
}

/*
ChecksCreateSuite performs requests for "checks/create-suite"

Create a check suite.

  POST /repos/{owner}/{repo}/check-suites

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
func (c *Client) ChecksCreateSuite(ctx context.Context, req *ChecksCreateSuiteReq, opt ...RequestOption) (*ChecksCreateSuiteResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ChecksCreateSuiteResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ChecksCreateSuiteResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksCreateSuiteReq is request data for Client.ChecksCreateSuite

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
type ChecksCreateSuiteReq struct {
	pgURL       string
	Owner       string
	Repo        string
	RequestBody ChecksCreateSuiteReqBody

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

func (r *ChecksCreateSuiteReq) pagingURL() string {
	return r.pgURL
}

func (r *ChecksCreateSuiteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/check-suites", r.Owner, r.Repo)
}

func (r *ChecksCreateSuiteReq) method() string {
	return "POST"
}

func (r *ChecksCreateSuiteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ChecksCreateSuiteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"antiope": r.AntiopePreview}
	if requiredPreviews {
		previewVals["antiope"] = true
	}
	if allPreviews {
		previewVals["antiope"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ChecksCreateSuiteReq) body() interface{} {
	return r.RequestBody
}

func (r *ChecksCreateSuiteReq) dataStatuses() []int {
	return []int{201}
}

func (r *ChecksCreateSuiteReq) validStatuses() []int {
	return []int{201}
}

func (r *ChecksCreateSuiteReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ChecksCreateSuiteReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksCreateSuiteReq) Rel(link RelName, resp *ChecksCreateSuiteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ChecksCreateSuiteReqBody is a request body for checks/create-suite

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
type ChecksCreateSuiteReqBody struct {

	// The sha of the head commit.
	HeadSha *string `json:"head_sha"`
}

/*
ChecksCreateSuiteResponseBody is a response body for ChecksCreateSuite

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
type ChecksCreateSuiteResponseBody struct {
	components.CheckSuite
}

/*
ChecksCreateSuiteResponse is a response for ChecksCreateSuite

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
type ChecksCreateSuiteResponse struct {
	response
	request *ChecksCreateSuiteReq
	Data    *ChecksCreateSuiteResponseBody
}

/*
ChecksGet performs requests for "checks/get"

Get a check run.

  GET /repos/{owner}/{repo}/check-runs/{check_run_id}

https://developer.github.com/v3/checks/runs/#get-a-check-run
*/
func (c *Client) ChecksGet(ctx context.Context, req *ChecksGetReq, opt ...RequestOption) (*ChecksGetResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ChecksGetResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ChecksGetResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksGetReq is request data for Client.ChecksGet

https://developer.github.com/v3/checks/runs/#get-a-check-run
*/
type ChecksGetReq struct {
	pgURL      string
	Owner      string
	Repo       string
	CheckRunId int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

func (r *ChecksGetReq) pagingURL() string {
	return r.pgURL
}

func (r *ChecksGetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/check-runs/%v", r.Owner, r.Repo, r.CheckRunId)
}

func (r *ChecksGetReq) method() string {
	return "GET"
}

func (r *ChecksGetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ChecksGetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"antiope": r.AntiopePreview}
	if requiredPreviews {
		previewVals["antiope"] = true
	}
	if allPreviews {
		previewVals["antiope"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ChecksGetReq) body() interface{} {
	return nil
}

func (r *ChecksGetReq) dataStatuses() []int {
	return []int{200}
}

func (r *ChecksGetReq) validStatuses() []int {
	return []int{200}
}

func (r *ChecksGetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ChecksGetReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksGetReq) Rel(link RelName, resp *ChecksGetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ChecksGetResponseBody is a response body for ChecksGet

https://developer.github.com/v3/checks/runs/#get-a-check-run
*/
type ChecksGetResponseBody struct {
	components.CheckRun2
}

/*
ChecksGetResponse is a response for ChecksGet

https://developer.github.com/v3/checks/runs/#get-a-check-run
*/
type ChecksGetResponse struct {
	response
	request *ChecksGetReq
	Data    *ChecksGetResponseBody
}

/*
ChecksGetSuite performs requests for "checks/get-suite"

Get a check suite.

  GET /repos/{owner}/{repo}/check-suites/{check_suite_id}

https://developer.github.com/v3/checks/suites/#get-a-check-suite
*/
func (c *Client) ChecksGetSuite(ctx context.Context, req *ChecksGetSuiteReq, opt ...RequestOption) (*ChecksGetSuiteResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ChecksGetSuiteResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ChecksGetSuiteResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksGetSuiteReq is request data for Client.ChecksGetSuite

https://developer.github.com/v3/checks/suites/#get-a-check-suite
*/
type ChecksGetSuiteReq struct {
	pgURL        string
	Owner        string
	Repo         string
	CheckSuiteId int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

func (r *ChecksGetSuiteReq) pagingURL() string {
	return r.pgURL
}

func (r *ChecksGetSuiteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/check-suites/%v", r.Owner, r.Repo, r.CheckSuiteId)
}

func (r *ChecksGetSuiteReq) method() string {
	return "GET"
}

func (r *ChecksGetSuiteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ChecksGetSuiteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"antiope": r.AntiopePreview}
	if requiredPreviews {
		previewVals["antiope"] = true
	}
	if allPreviews {
		previewVals["antiope"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ChecksGetSuiteReq) body() interface{} {
	return nil
}

func (r *ChecksGetSuiteReq) dataStatuses() []int {
	return []int{200}
}

func (r *ChecksGetSuiteReq) validStatuses() []int {
	return []int{200}
}

func (r *ChecksGetSuiteReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ChecksGetSuiteReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksGetSuiteReq) Rel(link RelName, resp *ChecksGetSuiteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ChecksGetSuiteResponseBody is a response body for ChecksGetSuite

https://developer.github.com/v3/checks/suites/#get-a-check-suite
*/
type ChecksGetSuiteResponseBody struct {
	components.CheckSuite
}

/*
ChecksGetSuiteResponse is a response for ChecksGetSuite

https://developer.github.com/v3/checks/suites/#get-a-check-suite
*/
type ChecksGetSuiteResponse struct {
	response
	request *ChecksGetSuiteReq
	Data    *ChecksGetSuiteResponseBody
}

/*
ChecksListAnnotations performs requests for "checks/list-annotations"

List check run annotations.

  GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations

https://developer.github.com/v3/checks/runs/#list-check-run-annotations
*/
func (c *Client) ChecksListAnnotations(ctx context.Context, req *ChecksListAnnotationsReq, opt ...RequestOption) (*ChecksListAnnotationsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ChecksListAnnotationsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ChecksListAnnotationsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksListAnnotationsReq is request data for Client.ChecksListAnnotations

https://developer.github.com/v3/checks/runs/#list-check-run-annotations
*/
type ChecksListAnnotationsReq struct {
	pgURL      string
	Owner      string
	Repo       string
	CheckRunId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

func (r *ChecksListAnnotationsReq) pagingURL() string {
	return r.pgURL
}

func (r *ChecksListAnnotationsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/check-runs/%v/annotations", r.Owner, r.Repo, r.CheckRunId)
}

func (r *ChecksListAnnotationsReq) method() string {
	return "GET"
}

func (r *ChecksListAnnotationsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ChecksListAnnotationsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"antiope": r.AntiopePreview}
	if requiredPreviews {
		previewVals["antiope"] = true
	}
	if allPreviews {
		previewVals["antiope"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ChecksListAnnotationsReq) body() interface{} {
	return nil
}

func (r *ChecksListAnnotationsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ChecksListAnnotationsReq) validStatuses() []int {
	return []int{200}
}

func (r *ChecksListAnnotationsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ChecksListAnnotationsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksListAnnotationsReq) Rel(link RelName, resp *ChecksListAnnotationsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ChecksListAnnotationsResponseBody is a response body for ChecksListAnnotations

https://developer.github.com/v3/checks/runs/#list-check-run-annotations
*/
type ChecksListAnnotationsResponseBody []struct {
	components.CheckAnnotation
}

/*
ChecksListAnnotationsResponse is a response for ChecksListAnnotations

https://developer.github.com/v3/checks/runs/#list-check-run-annotations
*/
type ChecksListAnnotationsResponse struct {
	response
	request *ChecksListAnnotationsReq
	Data    *ChecksListAnnotationsResponseBody
}

/*
ChecksListForRef performs requests for "checks/list-for-ref"

List check runs for a Git reference.

  GET /repos/{owner}/{repo}/commits/{ref}/check-runs

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
func (c *Client) ChecksListForRef(ctx context.Context, req *ChecksListForRefReq, opt ...RequestOption) (*ChecksListForRefResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ChecksListForRefResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ChecksListForRefResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksListForRefReq is request data for Client.ChecksListForRef

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
type ChecksListForRefReq struct {
	pgURL string
	Owner string
	Repo  string
	Ref   string

	// Returns check runs with the specified `name`.
	CheckName *string

	/*
	Returns check runs with the specified `status`. Can be one of `queued`,
	`in_progress`, or `completed`.
	*/
	Status *string

	/*
	Filters check runs by their `completed_at` timestamp. Can be one of `latest`
	(returning the most recent check runs) or `all`.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

func (r *ChecksListForRefReq) pagingURL() string {
	return r.pgURL
}

func (r *ChecksListForRefReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/check-runs", r.Owner, r.Repo, r.Ref)
}

func (r *ChecksListForRefReq) method() string {
	return "GET"
}

func (r *ChecksListForRefReq) urlQuery() url.Values {
	query := url.Values{}
	if r.CheckName != nil {
		query.Set("check_name", *r.CheckName)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ChecksListForRefReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"antiope": r.AntiopePreview}
	if requiredPreviews {
		previewVals["antiope"] = true
	}
	if allPreviews {
		previewVals["antiope"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ChecksListForRefReq) body() interface{} {
	return nil
}

func (r *ChecksListForRefReq) dataStatuses() []int {
	return []int{200}
}

func (r *ChecksListForRefReq) validStatuses() []int {
	return []int{200}
}

func (r *ChecksListForRefReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ChecksListForRefReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksListForRefReq) Rel(link RelName, resp *ChecksListForRefResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ChecksListForRefResponseBody is a response body for ChecksListForRef

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
type ChecksListForRefResponseBody struct {
	CheckRuns []struct {
		components.CheckRun2
	} `json:"check_runs,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
ChecksListForRefResponse is a response for ChecksListForRef

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
type ChecksListForRefResponse struct {
	response
	request *ChecksListForRefReq
	Data    *ChecksListForRefResponseBody
}

/*
ChecksListForSuite performs requests for "checks/list-for-suite"

List check runs in a check suite.

  GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
func (c *Client) ChecksListForSuite(ctx context.Context, req *ChecksListForSuiteReq, opt ...RequestOption) (*ChecksListForSuiteResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ChecksListForSuiteResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ChecksListForSuiteResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksListForSuiteReq is request data for Client.ChecksListForSuite

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
type ChecksListForSuiteReq struct {
	pgURL        string
	Owner        string
	Repo         string
	CheckSuiteId int64

	// Returns check runs with the specified `name`.
	CheckName *string

	/*
	Returns check runs with the specified `status`. Can be one of `queued`,
	`in_progress`, or `completed`.
	*/
	Status *string

	/*
	Filters check runs by their `completed_at` timestamp. Can be one of `latest`
	(returning the most recent check runs) or `all`.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

func (r *ChecksListForSuiteReq) pagingURL() string {
	return r.pgURL
}

func (r *ChecksListForSuiteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/check-suites/%v/check-runs", r.Owner, r.Repo, r.CheckSuiteId)
}

func (r *ChecksListForSuiteReq) method() string {
	return "GET"
}

func (r *ChecksListForSuiteReq) urlQuery() url.Values {
	query := url.Values{}
	if r.CheckName != nil {
		query.Set("check_name", *r.CheckName)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ChecksListForSuiteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"antiope": r.AntiopePreview}
	if requiredPreviews {
		previewVals["antiope"] = true
	}
	if allPreviews {
		previewVals["antiope"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ChecksListForSuiteReq) body() interface{} {
	return nil
}

func (r *ChecksListForSuiteReq) dataStatuses() []int {
	return []int{200}
}

func (r *ChecksListForSuiteReq) validStatuses() []int {
	return []int{200}
}

func (r *ChecksListForSuiteReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ChecksListForSuiteReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksListForSuiteReq) Rel(link RelName, resp *ChecksListForSuiteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ChecksListForSuiteResponseBody is a response body for ChecksListForSuite

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
type ChecksListForSuiteResponseBody struct {
	CheckRuns []struct {
		components.CheckRun2
	} `json:"check_runs,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
ChecksListForSuiteResponse is a response for ChecksListForSuite

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
type ChecksListForSuiteResponse struct {
	response
	request *ChecksListForSuiteReq
	Data    *ChecksListForSuiteResponseBody
}

/*
ChecksListSuitesForRef performs requests for "checks/list-suites-for-ref"

List check suites for a Git reference.

  GET /repos/{owner}/{repo}/commits/{ref}/check-suites

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
func (c *Client) ChecksListSuitesForRef(ctx context.Context, req *ChecksListSuitesForRefReq, opt ...RequestOption) (*ChecksListSuitesForRefResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ChecksListSuitesForRefResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ChecksListSuitesForRefResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksListSuitesForRefReq is request data for Client.ChecksListSuitesForRef

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
type ChecksListSuitesForRefReq struct {
	pgURL string
	Owner string
	Repo  string
	Ref   string

	// Filters check suites by GitHub App `id`.
	AppId *int64

	/*
	Filters checks suites by the name of the [check
	run](https://developer.github.com/v3/checks/runs/).
	*/
	CheckName *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

func (r *ChecksListSuitesForRefReq) pagingURL() string {
	return r.pgURL
}

func (r *ChecksListSuitesForRefReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/check-suites", r.Owner, r.Repo, r.Ref)
}

func (r *ChecksListSuitesForRefReq) method() string {
	return "GET"
}

func (r *ChecksListSuitesForRefReq) urlQuery() url.Values {
	query := url.Values{}
	if r.AppId != nil {
		query.Set("app_id", strconv.FormatInt(*r.AppId, 10))
	}
	if r.CheckName != nil {
		query.Set("check_name", *r.CheckName)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ChecksListSuitesForRefReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"antiope": r.AntiopePreview}
	if requiredPreviews {
		previewVals["antiope"] = true
	}
	if allPreviews {
		previewVals["antiope"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ChecksListSuitesForRefReq) body() interface{} {
	return nil
}

func (r *ChecksListSuitesForRefReq) dataStatuses() []int {
	return []int{200}
}

func (r *ChecksListSuitesForRefReq) validStatuses() []int {
	return []int{200}
}

func (r *ChecksListSuitesForRefReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ChecksListSuitesForRefReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksListSuitesForRefReq) Rel(link RelName, resp *ChecksListSuitesForRefResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ChecksListSuitesForRefResponseBody is a response body for ChecksListSuitesForRef

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
type ChecksListSuitesForRefResponseBody struct {
	CheckSuites []struct {
		components.CheckSuite
	} `json:"check_suites,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
ChecksListSuitesForRefResponse is a response for ChecksListSuitesForRef

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
type ChecksListSuitesForRefResponse struct {
	response
	request *ChecksListSuitesForRefReq
	Data    *ChecksListSuitesForRefResponseBody
}

/*
ChecksRerequestSuite performs requests for "checks/rerequest-suite"

Rerequest a check suite.

  POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest

https://developer.github.com/v3/checks/suites/#rerequest-a-check-suite
*/
func (c *Client) ChecksRerequestSuite(ctx context.Context, req *ChecksRerequestSuiteReq, opt ...RequestOption) (*ChecksRerequestSuiteResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ChecksRerequestSuiteResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksRerequestSuiteReq is request data for Client.ChecksRerequestSuite

https://developer.github.com/v3/checks/suites/#rerequest-a-check-suite
*/
type ChecksRerequestSuiteReq struct {
	pgURL        string
	Owner        string
	Repo         string
	CheckSuiteId int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

func (r *ChecksRerequestSuiteReq) pagingURL() string {
	return r.pgURL
}

func (r *ChecksRerequestSuiteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/check-suites/%v/rerequest", r.Owner, r.Repo, r.CheckSuiteId)
}

func (r *ChecksRerequestSuiteReq) method() string {
	return "POST"
}

func (r *ChecksRerequestSuiteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ChecksRerequestSuiteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"antiope": r.AntiopePreview}
	if requiredPreviews {
		previewVals["antiope"] = true
	}
	if allPreviews {
		previewVals["antiope"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ChecksRerequestSuiteReq) body() interface{} {
	return nil
}

func (r *ChecksRerequestSuiteReq) dataStatuses() []int {
	return []int{}
}

func (r *ChecksRerequestSuiteReq) validStatuses() []int {
	return []int{201}
}

func (r *ChecksRerequestSuiteReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ChecksRerequestSuiteReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksRerequestSuiteReq) Rel(link RelName, resp *ChecksRerequestSuiteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ChecksRerequestSuiteResponse is a response for ChecksRerequestSuite

https://developer.github.com/v3/checks/suites/#rerequest-a-check-suite
*/
type ChecksRerequestSuiteResponse struct {
	response
	request *ChecksRerequestSuiteReq
}

/*
ChecksSetSuitesPreferences performs requests for "checks/set-suites-preferences"

Update repository preferences for check suites.

  PATCH /repos/{owner}/{repo}/check-suites/preferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
func (c *Client) ChecksSetSuitesPreferences(ctx context.Context, req *ChecksSetSuitesPreferencesReq, opt ...RequestOption) (*ChecksSetSuitesPreferencesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ChecksSetSuitesPreferencesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ChecksSetSuitesPreferencesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksSetSuitesPreferencesReq is request data for Client.ChecksSetSuitesPreferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
type ChecksSetSuitesPreferencesReq struct {
	pgURL       string
	Owner       string
	Repo        string
	RequestBody ChecksSetSuitesPreferencesReqBody

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

func (r *ChecksSetSuitesPreferencesReq) pagingURL() string {
	return r.pgURL
}

func (r *ChecksSetSuitesPreferencesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/check-suites/preferences", r.Owner, r.Repo)
}

func (r *ChecksSetSuitesPreferencesReq) method() string {
	return "PATCH"
}

func (r *ChecksSetSuitesPreferencesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ChecksSetSuitesPreferencesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"antiope": r.AntiopePreview}
	if requiredPreviews {
		previewVals["antiope"] = true
	}
	if allPreviews {
		previewVals["antiope"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ChecksSetSuitesPreferencesReq) body() interface{} {
	return r.RequestBody
}

func (r *ChecksSetSuitesPreferencesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ChecksSetSuitesPreferencesReq) validStatuses() []int {
	return []int{200}
}

func (r *ChecksSetSuitesPreferencesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ChecksSetSuitesPreferencesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksSetSuitesPreferencesReq) Rel(link RelName, resp *ChecksSetSuitesPreferencesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

// ChecksSetSuitesPreferencesReqBodyAutoTriggerChecks is a value for ChecksSetSuitesPreferencesReqBody's AutoTriggerChecks field
type ChecksSetSuitesPreferencesReqBodyAutoTriggerChecks struct {

	// The `id` of the GitHub App.
	AppId *int64 `json:"app_id"`

	/*
	   Set to `true` to enable automatic creation of CheckSuite events upon pushes to
	   the repository, or `false` to disable them.
	*/
	Setting *bool `json:"setting"`
}

/*
ChecksSetSuitesPreferencesReqBody is a request body for checks/set-suites-preferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
type ChecksSetSuitesPreferencesReqBody struct {

	/*
	   Enables or disables automatic creation of CheckSuite events upon pushes to the
	   repository. Enabled by default. See the [`auto_trigger_checks`
	   object](https://developer.github.com/v3/checks/suites/#auto_trigger_checks-object)
	   description for details.
	*/
	AutoTriggerChecks []ChecksSetSuitesPreferencesReqBodyAutoTriggerChecks `json:"auto_trigger_checks,omitempty"`
}

/*
ChecksSetSuitesPreferencesResponseBody is a response body for ChecksSetSuitesPreferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
type ChecksSetSuitesPreferencesResponseBody struct {
	components.CheckSuitePreference
}

/*
ChecksSetSuitesPreferencesResponse is a response for ChecksSetSuitesPreferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
type ChecksSetSuitesPreferencesResponse struct {
	response
	request *ChecksSetSuitesPreferencesReq
	Data    *ChecksSetSuitesPreferencesResponseBody
}

/*
ChecksUpdate performs requests for "checks/update"

Update a check run.

  PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
func (c *Client) ChecksUpdate(ctx context.Context, req *ChecksUpdateReq, opt ...RequestOption) (*ChecksUpdateResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ChecksUpdateResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ChecksUpdateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ChecksUpdateReq is request data for Client.ChecksUpdate

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
type ChecksUpdateReq struct {
	pgURL       string
	Owner       string
	Repo        string
	CheckRunId  int64
	RequestBody ChecksUpdateReqBody

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

func (r *ChecksUpdateReq) pagingURL() string {
	return r.pgURL
}

func (r *ChecksUpdateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/check-runs/%v", r.Owner, r.Repo, r.CheckRunId)
}

func (r *ChecksUpdateReq) method() string {
	return "PATCH"
}

func (r *ChecksUpdateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ChecksUpdateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"antiope": r.AntiopePreview}
	if requiredPreviews {
		previewVals["antiope"] = true
	}
	if allPreviews {
		previewVals["antiope"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ChecksUpdateReq) body() interface{} {
	return r.RequestBody
}

func (r *ChecksUpdateReq) dataStatuses() []int {
	return []int{200}
}

func (r *ChecksUpdateReq) validStatuses() []int {
	return []int{200}
}

func (r *ChecksUpdateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ChecksUpdateReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ChecksUpdateReq) Rel(link RelName, resp *ChecksUpdateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

// ChecksUpdateReqBodyActions is a value for ChecksUpdateReqBody's Actions field
type ChecksUpdateReqBodyActions struct {

	/*
	   A short explanation of what this action would do. The maximum size is 40
	   characters.
	*/
	Description *string `json:"description"`

	/*
	   A reference for the action on the integrator's system. The maximum size is 20
	   characters.
	*/
	Identifier *string `json:"identifier"`

	/*
	   The text to be displayed on a button in the web UI. The maximum size is 20
	   characters.
	*/
	Label *string `json:"label"`
}

// ChecksUpdateReqBodyOutput is a value for ChecksUpdateReqBody's Output field
type ChecksUpdateReqBodyOutput struct {

	/*
	   Adds information from your analysis to specific lines of code. Annotations are
	   visible in GitHub's pull request UI. Annotations are visible in GitHub's pull
	   request UI. The Checks API limits the number of annotations to a maximum of 50
	   per API request. To create more than 50 annotations, you have to make multiple
	   requests to the [Update a check
	   run](https://developer.github.com/v3/checks/runs/#update-a-check-run) endpoint.
	   Each time you update the check run, annotations are appended to the list of
	   annotations that already exist for the check run. For details about annotations
	   in the UI, see "[About status
	   checks](https://help.github.com/articles/about-status-checks#checks)". See the
	   [`annotations`
	   object](https://developer.github.com/v3/checks/runs/#annotations-object-1)
	   description for details.
	*/
	Annotations []ChecksUpdateReqBodyOutputAnnotations `json:"annotations,omitempty"`

	/*
	   Adds images to the output displayed in the GitHub pull request UI. See the
	   [`images`
	   object](https://developer.github.com/v3/checks/runs/#annotations-object-1)
	   description for details.
	*/
	Images []ChecksUpdateReqBodyOutputImages `json:"images,omitempty"`

	// Can contain Markdown.
	Summary *string `json:"summary"`

	// Can contain Markdown.
	Text *string `json:"text,omitempty"`

	// **Required**.
	Title *string `json:"title,omitempty"`
}

// ChecksUpdateReqBodyOutputAnnotations is a value for ChecksUpdateReqBodyOutput's Annotations field
type ChecksUpdateReqBodyOutputAnnotations struct {

	// The level of the annotation. Can be one of `notice`, `warning`, or `failure`.
	AnnotationLevel *string `json:"annotation_level"`

	/*
	   The end column of the annotation. Annotations only support `start_column` and
	   `end_column` on the same line. Omit this parameter if `start_line` and
	   `end_line` have different values.
	*/
	EndColumn *int64 `json:"end_column,omitempty"`

	// The end line of the annotation.
	EndLine *int64 `json:"end_line"`

	/*
	   A short description of the feedback for these lines of code. The maximum size is
	   64 KB.
	*/
	Message *string `json:"message"`

	/*
	   The path of the file to add an annotation to. For example,
	   `assets/css/main.css`.
	*/
	Path *string `json:"path"`

	// Details about this annotation. The maximum size is 64 KB.
	RawDetails *string `json:"raw_details,omitempty"`

	/*
	   The start column of the annotation. Annotations only support `start_column` and
	   `end_column` on the same line. Omit this parameter if `start_line` and
	   `end_line` have different values.
	*/
	StartColumn *int64 `json:"start_column,omitempty"`

	// The start line of the annotation.
	StartLine *int64 `json:"start_line"`

	// The title that represents the annotation. The maximum size is 255 characters.
	Title *string `json:"title,omitempty"`
}

// ChecksUpdateReqBodyOutputImages is a value for ChecksUpdateReqBodyOutput's Images field
type ChecksUpdateReqBodyOutputImages struct {

	// The alternative text for the image.
	Alt *string `json:"alt"`

	// A short image description.
	Caption *string `json:"caption,omitempty"`

	// The full URL of the image.
	ImageUrl *string `json:"image_url"`
}

/*
ChecksUpdateReqBody is a request body for checks/update

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
type ChecksUpdateReqBody struct {

	/*
	   Possible further actions the integrator can perform, which a user may trigger.
	   Each action includes a `label`, `identifier` and `description`. A maximum of
	   three actions are accepted. See the [`actions`
	   object](https://developer.github.com/v3/checks/runs/#actions-object)
	   description. To learn more about check runs and requested actions, see "[Check
	   runs and requested
	   actions](https://developer.github.com/v3/checks/runs/#check-runs-and-requested-actions)."
	*/
	Actions []ChecksUpdateReqBodyActions `json:"actions,omitempty"`

	/*
	   The time the check completed. This is a timestamp in [ISO
	   8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	CompletedAt *string `json:"completed_at,omitempty"`

	/*
	   **Required if you provide `completed_at` or a `status` of `completed`**. The
	   final conclusion of the check. Can be one of `success`, `failure`, `neutral`,
	   `cancelled`, `skipped`, `timed_out`, or `action_required`.
	   **Note:** Providing `conclusion` will automatically set the `status` parameter
	   to `completed`. Only GitHub can change a check run conclusion to `stale`.
	*/
	Conclusion *string `json:"conclusion,omitempty"`

	// The URL of the integrator's site that has the full details of the check.
	DetailsUrl *string `json:"details_url,omitempty"`

	// A reference for the run on the integrator's system.
	ExternalId *string `json:"external_id,omitempty"`

	// The name of the check. For example, "code-coverage".
	Name *string `json:"name,omitempty"`

	/*
	   Check runs can accept a variety of data in the `output` object, including a
	   `title` and `summary` and can optionally provide descriptive details about the
	   run. See the [`output`
	   object](https://developer.github.com/v3/checks/runs/#output-object-1)
	   description.
	*/
	Output *ChecksUpdateReqBodyOutput `json:"output,omitempty"`

	/*
	   This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
	   format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	StartedAt *string `json:"started_at,omitempty"`

	// The current status. Can be one of `queued`, `in_progress`, or `completed`.
	Status *string `json:"status,omitempty"`
}

/*
ChecksUpdateResponseBody is a response body for ChecksUpdate

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
type ChecksUpdateResponseBody struct {
	components.CheckRun2
}

/*
ChecksUpdateResponse is a response for ChecksUpdate

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
type ChecksUpdateResponse struct {
	response
	request *ChecksUpdateReq
	Data    *ChecksUpdateResponseBody
}
