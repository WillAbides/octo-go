// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
ReactionsCreateForCommitComment performs requests for "reactions/create-for-commit-comment"

Create reaction for a commit comment.

  POST /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
func (c *Client) ReactionsCreateForCommitComment(ctx context.Context, req *ReactionsCreateForCommitCommentReq, opt ...RequestOption) (*ReactionsCreateForCommitCommentResponse, error) {
	resp := &ReactionsCreateForCommitCommentResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ReactionsCreateForCommitCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForCommitCommentReq is request data for Client.ReactionsCreateForCommitComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
type ReactionsCreateForCommitCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	CommentId   int64
	RequestBody ReactionsCreateForCommitCommentReqBody

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForCommitCommentReq) url() string {
	return r._url
}

func (r *ReactionsCreateForCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v/reactions", r.Owner, r.Repo, r.CommentId)
}

func (r *ReactionsCreateForCommitCommentReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForCommitCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForCommitCommentReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForCommitCommentReq) validStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForCommitCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReactionsCreateForCommitCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForCommitCommentReq) Rel(link RelName, resp *ReactionsCreateForCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForCommitCommentReqBody is a request body for reactions/create-for-commit-comment

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
type ReactionsCreateForCommitCommentReqBody struct {

	/*
	   The [reaction type](https://developer.github.com/v3/reactions/#reaction-types)
	   to add to the commit comment.
	*/
	Content *string `json:"content"`
}

/*
ReactionsCreateForCommitCommentResponseBody is a response body for ReactionsCreateForCommitComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
type ReactionsCreateForCommitCommentResponseBody struct {
	components.Reaction
}

/*
ReactionsCreateForCommitCommentResponse is a response for ReactionsCreateForCommitComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
type ReactionsCreateForCommitCommentResponse struct {
	response
	request *ReactionsCreateForCommitCommentReq
	Data    *ReactionsCreateForCommitCommentResponseBody
}

/*
ReactionsCreateForIssue performs requests for "reactions/create-for-issue"

Create reaction for an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
func (c *Client) ReactionsCreateForIssue(ctx context.Context, req *ReactionsCreateForIssueReq, opt ...RequestOption) (*ReactionsCreateForIssueResponse, error) {
	resp := &ReactionsCreateForIssueResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ReactionsCreateForIssueResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForIssueReq is request data for Client.ReactionsCreateForIssue

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
type ReactionsCreateForIssueReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody ReactionsCreateForIssueReqBody

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForIssueReq) url() string {
	return r._url
}

func (r *ReactionsCreateForIssueReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/reactions", r.Owner, r.Repo, r.IssueNumber)
}

func (r *ReactionsCreateForIssueReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForIssueReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForIssueReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForIssueReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForIssueReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForIssueReq) validStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForIssueReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReactionsCreateForIssueReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForIssueReq) Rel(link RelName, resp *ReactionsCreateForIssueResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForIssueReqBody is a request body for reactions/create-for-issue

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
type ReactionsCreateForIssueReqBody struct {

	/*
	   The [reaction type](https://developer.github.com/v3/reactions/#reaction-types)
	   to add to the issue.
	*/
	Content *string `json:"content"`
}

/*
ReactionsCreateForIssueResponseBody is a response body for ReactionsCreateForIssue

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
type ReactionsCreateForIssueResponseBody struct {
	components.Reaction
}

/*
ReactionsCreateForIssueResponse is a response for ReactionsCreateForIssue

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
type ReactionsCreateForIssueResponse struct {
	response
	request *ReactionsCreateForIssueReq
	Data    *ReactionsCreateForIssueResponseBody
}

/*
ReactionsCreateForIssueComment performs requests for "reactions/create-for-issue-comment"

Create reaction for an issue comment.

  POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
func (c *Client) ReactionsCreateForIssueComment(ctx context.Context, req *ReactionsCreateForIssueCommentReq, opt ...RequestOption) (*ReactionsCreateForIssueCommentResponse, error) {
	resp := &ReactionsCreateForIssueCommentResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ReactionsCreateForIssueCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForIssueCommentReq is request data for Client.ReactionsCreateForIssueComment

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
type ReactionsCreateForIssueCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	CommentId   int64
	RequestBody ReactionsCreateForIssueCommentReqBody

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForIssueCommentReq) url() string {
	return r._url
}

func (r *ReactionsCreateForIssueCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v/reactions", r.Owner, r.Repo, r.CommentId)
}

func (r *ReactionsCreateForIssueCommentReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForIssueCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForIssueCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForIssueCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForIssueCommentReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForIssueCommentReq) validStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForIssueCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReactionsCreateForIssueCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForIssueCommentReq) Rel(link RelName, resp *ReactionsCreateForIssueCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForIssueCommentReqBody is a request body for reactions/create-for-issue-comment

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
type ReactionsCreateForIssueCommentReqBody struct {

	/*
	   The [reaction type](https://developer.github.com/v3/reactions/#reaction-types)
	   to add to the issue comment.
	*/
	Content *string `json:"content"`
}

/*
ReactionsCreateForIssueCommentResponseBody is a response body for ReactionsCreateForIssueComment

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
type ReactionsCreateForIssueCommentResponseBody struct {
	components.Reaction
}

/*
ReactionsCreateForIssueCommentResponse is a response for ReactionsCreateForIssueComment

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
type ReactionsCreateForIssueCommentResponse struct {
	response
	request *ReactionsCreateForIssueCommentReq
	Data    *ReactionsCreateForIssueCommentResponseBody
}

/*
ReactionsCreateForPullRequestReviewComment performs requests for "reactions/create-for-pull-request-review-comment"

Create reaction for a pull request review comment.

  POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
func (c *Client) ReactionsCreateForPullRequestReviewComment(ctx context.Context, req *ReactionsCreateForPullRequestReviewCommentReq, opt ...RequestOption) (*ReactionsCreateForPullRequestReviewCommentResponse, error) {
	resp := &ReactionsCreateForPullRequestReviewCommentResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ReactionsCreateForPullRequestReviewCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForPullRequestReviewCommentReq is request data for Client.ReactionsCreateForPullRequestReviewComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
type ReactionsCreateForPullRequestReviewCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	CommentId   int64
	RequestBody ReactionsCreateForPullRequestReviewCommentReqBody

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) url() string {
	return r._url
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments/%v/reactions", r.Owner, r.Repo, r.CommentId)
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) validStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReactionsCreateForPullRequestReviewCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForPullRequestReviewCommentReq) Rel(link RelName, resp *ReactionsCreateForPullRequestReviewCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForPullRequestReviewCommentReqBody is a request body for reactions/create-for-pull-request-review-comment

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
type ReactionsCreateForPullRequestReviewCommentReqBody struct {

	/*
	   The [reaction type](https://developer.github.com/v3/reactions/#reaction-types)
	   to add to the pull request review comment.
	*/
	Content *string `json:"content"`
}

/*
ReactionsCreateForPullRequestReviewCommentResponseBody is a response body for ReactionsCreateForPullRequestReviewComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
type ReactionsCreateForPullRequestReviewCommentResponseBody struct {
	components.Reaction
}

/*
ReactionsCreateForPullRequestReviewCommentResponse is a response for ReactionsCreateForPullRequestReviewComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
type ReactionsCreateForPullRequestReviewCommentResponse struct {
	response
	request *ReactionsCreateForPullRequestReviewCommentReq
	Data    *ReactionsCreateForPullRequestReviewCommentResponseBody
}

/*
ReactionsCreateForTeamDiscussionCommentInOrg performs requests for "reactions/create-for-team-discussion-comment-in-org"

Create reaction for a team discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
func (c *Client) ReactionsCreateForTeamDiscussionCommentInOrg(ctx context.Context, req *ReactionsCreateForTeamDiscussionCommentInOrgReq, opt ...RequestOption) (*ReactionsCreateForTeamDiscussionCommentInOrgResponse, error) {
	resp := &ReactionsCreateForTeamDiscussionCommentInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ReactionsCreateForTeamDiscussionCommentInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForTeamDiscussionCommentInOrgReq is request data for Client.ReactionsCreateForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
type ReactionsCreateForTeamDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      ReactionsCreateForTeamDiscussionCommentInOrgReqBody

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber)
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) Rel(link RelName, resp *ReactionsCreateForTeamDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForTeamDiscussionCommentInOrgReqBody is a request body for reactions/create-for-team-discussion-comment-in-org

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
type ReactionsCreateForTeamDiscussionCommentInOrgReqBody struct {

	/*
	   The [reaction type](https://developer.github.com/v3/reactions/#reaction-types)
	   to add to the team discussion comment.
	*/
	Content *string `json:"content"`
}

/*
ReactionsCreateForTeamDiscussionCommentInOrgResponseBody is a response body for ReactionsCreateForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
type ReactionsCreateForTeamDiscussionCommentInOrgResponseBody struct {
	components.Reaction
}

/*
ReactionsCreateForTeamDiscussionCommentInOrgResponse is a response for ReactionsCreateForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
type ReactionsCreateForTeamDiscussionCommentInOrgResponse struct {
	response
	request *ReactionsCreateForTeamDiscussionCommentInOrgReq
	Data    *ReactionsCreateForTeamDiscussionCommentInOrgResponseBody
}

/*
ReactionsCreateForTeamDiscussionInOrg performs requests for "reactions/create-for-team-discussion-in-org"

Create reaction for a team discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
func (c *Client) ReactionsCreateForTeamDiscussionInOrg(ctx context.Context, req *ReactionsCreateForTeamDiscussionInOrgReq, opt ...RequestOption) (*ReactionsCreateForTeamDiscussionInOrgResponse, error) {
	resp := &ReactionsCreateForTeamDiscussionInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ReactionsCreateForTeamDiscussionInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForTeamDiscussionInOrgReq is request data for Client.ReactionsCreateForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
type ReactionsCreateForTeamDiscussionInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      ReactionsCreateForTeamDiscussionInOrgReqBody

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) url() string {
	return r._url
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReactionsCreateForTeamDiscussionInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForTeamDiscussionInOrgReq) Rel(link RelName, resp *ReactionsCreateForTeamDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForTeamDiscussionInOrgReqBody is a request body for reactions/create-for-team-discussion-in-org

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
type ReactionsCreateForTeamDiscussionInOrgReqBody struct {

	/*
	   The [reaction type](https://developer.github.com/v3/reactions/#reaction-types)
	   to add to the team discussion.
	*/
	Content *string `json:"content"`
}

/*
ReactionsCreateForTeamDiscussionInOrgResponseBody is a response body for ReactionsCreateForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
type ReactionsCreateForTeamDiscussionInOrgResponseBody struct {
	components.Reaction
}

/*
ReactionsCreateForTeamDiscussionInOrgResponse is a response for ReactionsCreateForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
type ReactionsCreateForTeamDiscussionInOrgResponse struct {
	response
	request *ReactionsCreateForTeamDiscussionInOrgReq
	Data    *ReactionsCreateForTeamDiscussionInOrgResponseBody
}

/*
ReactionsDeleteForCommitComment performs requests for "reactions/delete-for-commit-comment"

Delete a commit comment reaction.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
func (c *Client) ReactionsDeleteForCommitComment(ctx context.Context, req *ReactionsDeleteForCommitCommentReq, opt ...RequestOption) (*ReactionsDeleteForCommitCommentResponse, error) {
	resp := &ReactionsDeleteForCommitCommentResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForCommitCommentReq is request data for Client.ReactionsDeleteForCommitComment

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
type ReactionsDeleteForCommitCommentReq struct {
	_url       string
	Owner      string
	Repo       string
	CommentId  int64
	ReactionId int64

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsDeleteForCommitCommentReq) url() string {
	return r._url
}

func (r *ReactionsDeleteForCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v/reactions/%v", r.Owner, r.Repo, r.CommentId, r.ReactionId)
}

func (r *ReactionsDeleteForCommitCommentReq) method() string {
	return "DELETE"
}

func (r *ReactionsDeleteForCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsDeleteForCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsDeleteForCommitCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsDeleteForCommitCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *ReactionsDeleteForCommitCommentReq) validStatuses() []int {
	return []int{204}
}

func (r *ReactionsDeleteForCommitCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReactionsDeleteForCommitCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForCommitCommentReq) Rel(link RelName, resp *ReactionsDeleteForCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForCommitCommentResponse is a response for ReactionsDeleteForCommitComment

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
type ReactionsDeleteForCommitCommentResponse struct {
	response
	request *ReactionsDeleteForCommitCommentReq
}

/*
ReactionsDeleteForIssue performs requests for "reactions/delete-for-issue"

Delete an issue reaction.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
func (c *Client) ReactionsDeleteForIssue(ctx context.Context, req *ReactionsDeleteForIssueReq, opt ...RequestOption) (*ReactionsDeleteForIssueResponse, error) {
	resp := &ReactionsDeleteForIssueResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForIssueReq is request data for Client.ReactionsDeleteForIssue

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
type ReactionsDeleteForIssueReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64
	ReactionId  int64

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsDeleteForIssueReq) url() string {
	return r._url
}

func (r *ReactionsDeleteForIssueReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/reactions/%v", r.Owner, r.Repo, r.IssueNumber, r.ReactionId)
}

func (r *ReactionsDeleteForIssueReq) method() string {
	return "DELETE"
}

func (r *ReactionsDeleteForIssueReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsDeleteForIssueReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsDeleteForIssueReq) body() interface{} {
	return nil
}

func (r *ReactionsDeleteForIssueReq) dataStatuses() []int {
	return []int{}
}

func (r *ReactionsDeleteForIssueReq) validStatuses() []int {
	return []int{204}
}

func (r *ReactionsDeleteForIssueReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReactionsDeleteForIssueReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForIssueReq) Rel(link RelName, resp *ReactionsDeleteForIssueResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForIssueResponse is a response for ReactionsDeleteForIssue

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
type ReactionsDeleteForIssueResponse struct {
	response
	request *ReactionsDeleteForIssueReq
}

/*
ReactionsDeleteForIssueComment performs requests for "reactions/delete-for-issue-comment"

Delete an issue comment reaction.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
func (c *Client) ReactionsDeleteForIssueComment(ctx context.Context, req *ReactionsDeleteForIssueCommentReq, opt ...RequestOption) (*ReactionsDeleteForIssueCommentResponse, error) {
	resp := &ReactionsDeleteForIssueCommentResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForIssueCommentReq is request data for Client.ReactionsDeleteForIssueComment

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
type ReactionsDeleteForIssueCommentReq struct {
	_url       string
	Owner      string
	Repo       string
	CommentId  int64
	ReactionId int64

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsDeleteForIssueCommentReq) url() string {
	return r._url
}

func (r *ReactionsDeleteForIssueCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v/reactions/%v", r.Owner, r.Repo, r.CommentId, r.ReactionId)
}

func (r *ReactionsDeleteForIssueCommentReq) method() string {
	return "DELETE"
}

func (r *ReactionsDeleteForIssueCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsDeleteForIssueCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsDeleteForIssueCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsDeleteForIssueCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *ReactionsDeleteForIssueCommentReq) validStatuses() []int {
	return []int{204}
}

func (r *ReactionsDeleteForIssueCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReactionsDeleteForIssueCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForIssueCommentReq) Rel(link RelName, resp *ReactionsDeleteForIssueCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForIssueCommentResponse is a response for ReactionsDeleteForIssueComment

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
type ReactionsDeleteForIssueCommentResponse struct {
	response
	request *ReactionsDeleteForIssueCommentReq
}

/*
ReactionsDeleteForPullRequestComment performs requests for "reactions/delete-for-pull-request-comment"

Delete a pull request comment reaction.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
func (c *Client) ReactionsDeleteForPullRequestComment(ctx context.Context, req *ReactionsDeleteForPullRequestCommentReq, opt ...RequestOption) (*ReactionsDeleteForPullRequestCommentResponse, error) {
	resp := &ReactionsDeleteForPullRequestCommentResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForPullRequestCommentReq is request data for Client.ReactionsDeleteForPullRequestComment

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
type ReactionsDeleteForPullRequestCommentReq struct {
	_url       string
	Owner      string
	Repo       string
	CommentId  int64
	ReactionId int64

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsDeleteForPullRequestCommentReq) url() string {
	return r._url
}

func (r *ReactionsDeleteForPullRequestCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments/%v/reactions/%v", r.Owner, r.Repo, r.CommentId, r.ReactionId)
}

func (r *ReactionsDeleteForPullRequestCommentReq) method() string {
	return "DELETE"
}

func (r *ReactionsDeleteForPullRequestCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsDeleteForPullRequestCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsDeleteForPullRequestCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsDeleteForPullRequestCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *ReactionsDeleteForPullRequestCommentReq) validStatuses() []int {
	return []int{204}
}

func (r *ReactionsDeleteForPullRequestCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReactionsDeleteForPullRequestCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForPullRequestCommentReq) Rel(link RelName, resp *ReactionsDeleteForPullRequestCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForPullRequestCommentResponse is a response for ReactionsDeleteForPullRequestComment

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
type ReactionsDeleteForPullRequestCommentResponse struct {
	response
	request *ReactionsDeleteForPullRequestCommentReq
}

/*
ReactionsDeleteForTeamDiscussion performs requests for "reactions/delete-for-team-discussion"

Delete team discussion reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
func (c *Client) ReactionsDeleteForTeamDiscussion(ctx context.Context, req *ReactionsDeleteForTeamDiscussionReq, opt ...RequestOption) (*ReactionsDeleteForTeamDiscussionResponse, error) {
	resp := &ReactionsDeleteForTeamDiscussionResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForTeamDiscussionReq is request data for Client.ReactionsDeleteForTeamDiscussion

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
type ReactionsDeleteForTeamDiscussionReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	ReactionId       int64

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsDeleteForTeamDiscussionReq) url() string {
	return r._url
}

func (r *ReactionsDeleteForTeamDiscussionReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/reactions/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.ReactionId)
}

func (r *ReactionsDeleteForTeamDiscussionReq) method() string {
	return "DELETE"
}

func (r *ReactionsDeleteForTeamDiscussionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsDeleteForTeamDiscussionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsDeleteForTeamDiscussionReq) body() interface{} {
	return nil
}

func (r *ReactionsDeleteForTeamDiscussionReq) dataStatuses() []int {
	return []int{}
}

func (r *ReactionsDeleteForTeamDiscussionReq) validStatuses() []int {
	return []int{204}
}

func (r *ReactionsDeleteForTeamDiscussionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReactionsDeleteForTeamDiscussionReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForTeamDiscussionReq) Rel(link RelName, resp *ReactionsDeleteForTeamDiscussionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForTeamDiscussionResponse is a response for ReactionsDeleteForTeamDiscussion

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
type ReactionsDeleteForTeamDiscussionResponse struct {
	response
	request *ReactionsDeleteForTeamDiscussionReq
}

/*
ReactionsDeleteForTeamDiscussionComment performs requests for "reactions/delete-for-team-discussion-comment"

Delete team discussion comment reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
func (c *Client) ReactionsDeleteForTeamDiscussionComment(ctx context.Context, req *ReactionsDeleteForTeamDiscussionCommentReq, opt ...RequestOption) (*ReactionsDeleteForTeamDiscussionCommentResponse, error) {
	resp := &ReactionsDeleteForTeamDiscussionCommentResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForTeamDiscussionCommentReq is request data for Client.ReactionsDeleteForTeamDiscussionComment

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
type ReactionsDeleteForTeamDiscussionCommentReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	ReactionId       int64

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) url() string {
	return r._url
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v/reactions/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber, r.ReactionId)
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) method() string {
	return "DELETE"
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) validStatuses() []int {
	return []int{204}
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReactionsDeleteForTeamDiscussionCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForTeamDiscussionCommentReq) Rel(link RelName, resp *ReactionsDeleteForTeamDiscussionCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForTeamDiscussionCommentResponse is a response for ReactionsDeleteForTeamDiscussionComment

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
type ReactionsDeleteForTeamDiscussionCommentResponse struct {
	response
	request *ReactionsDeleteForTeamDiscussionCommentReq
}

/*
ReactionsListForCommitComment performs requests for "reactions/list-for-commit-comment"

List reactions for a commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
func (c *Client) ReactionsListForCommitComment(ctx context.Context, req *ReactionsListForCommitCommentReq, opt ...RequestOption) (*ReactionsListForCommitCommentResponse, error) {
	resp := &ReactionsListForCommitCommentResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ReactionsListForCommitCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForCommitCommentReq is request data for Client.ReactionsListForCommitComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
type ReactionsListForCommitCommentReq struct {
	_url      string
	Owner     string
	Repo      string
	CommentId int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a commit comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForCommitCommentReq) url() string {
	return r._url
}

func (r *ReactionsListForCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v/reactions", r.Owner, r.Repo, r.CommentId)
}

func (r *ReactionsListForCommitCommentReq) method() string {
	return "GET"
}

func (r *ReactionsListForCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForCommitCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsListForCommitCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForCommitCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForCommitCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReactionsListForCommitCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForCommitCommentReq) Rel(link RelName, resp *ReactionsListForCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForCommitCommentResponseBody is a response body for ReactionsListForCommitComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
type ReactionsListForCommitCommentResponseBody []struct {
	components.Reaction
}

/*
ReactionsListForCommitCommentResponse is a response for ReactionsListForCommitComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
type ReactionsListForCommitCommentResponse struct {
	response
	request *ReactionsListForCommitCommentReq
	Data    *ReactionsListForCommitCommentResponseBody
}

/*
ReactionsListForIssue performs requests for "reactions/list-for-issue"

List reactions for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
func (c *Client) ReactionsListForIssue(ctx context.Context, req *ReactionsListForIssueReq, opt ...RequestOption) (*ReactionsListForIssueResponse, error) {
	resp := &ReactionsListForIssueResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ReactionsListForIssueResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForIssueReq is request data for Client.ReactionsListForIssue

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
type ReactionsListForIssueReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to an issue.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForIssueReq) url() string {
	return r._url
}

func (r *ReactionsListForIssueReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/reactions", r.Owner, r.Repo, r.IssueNumber)
}

func (r *ReactionsListForIssueReq) method() string {
	return "GET"
}

func (r *ReactionsListForIssueReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForIssueReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForIssueReq) body() interface{} {
	return nil
}

func (r *ReactionsListForIssueReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForIssueReq) validStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForIssueReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReactionsListForIssueReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForIssueReq) Rel(link RelName, resp *ReactionsListForIssueResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForIssueResponseBody is a response body for ReactionsListForIssue

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
type ReactionsListForIssueResponseBody []struct {
	components.Reaction
}

/*
ReactionsListForIssueResponse is a response for ReactionsListForIssue

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
type ReactionsListForIssueResponse struct {
	response
	request *ReactionsListForIssueReq
	Data    *ReactionsListForIssueResponseBody
}

/*
ReactionsListForIssueComment performs requests for "reactions/list-for-issue-comment"

List reactions for an issue comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
func (c *Client) ReactionsListForIssueComment(ctx context.Context, req *ReactionsListForIssueCommentReq, opt ...RequestOption) (*ReactionsListForIssueCommentResponse, error) {
	resp := &ReactionsListForIssueCommentResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ReactionsListForIssueCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForIssueCommentReq is request data for Client.ReactionsListForIssueComment

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
type ReactionsListForIssueCommentReq struct {
	_url      string
	Owner     string
	Repo      string
	CommentId int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to an issue comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForIssueCommentReq) url() string {
	return r._url
}

func (r *ReactionsListForIssueCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v/reactions", r.Owner, r.Repo, r.CommentId)
}

func (r *ReactionsListForIssueCommentReq) method() string {
	return "GET"
}

func (r *ReactionsListForIssueCommentReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForIssueCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForIssueCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsListForIssueCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForIssueCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForIssueCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReactionsListForIssueCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForIssueCommentReq) Rel(link RelName, resp *ReactionsListForIssueCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForIssueCommentResponseBody is a response body for ReactionsListForIssueComment

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
type ReactionsListForIssueCommentResponseBody []struct {
	components.Reaction
}

/*
ReactionsListForIssueCommentResponse is a response for ReactionsListForIssueComment

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
type ReactionsListForIssueCommentResponse struct {
	response
	request *ReactionsListForIssueCommentReq
	Data    *ReactionsListForIssueCommentResponseBody
}

/*
ReactionsListForPullRequestReviewComment performs requests for "reactions/list-for-pull-request-review-comment"

List reactions for a pull request review comment.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
func (c *Client) ReactionsListForPullRequestReviewComment(ctx context.Context, req *ReactionsListForPullRequestReviewCommentReq, opt ...RequestOption) (*ReactionsListForPullRequestReviewCommentResponse, error) {
	resp := &ReactionsListForPullRequestReviewCommentResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ReactionsListForPullRequestReviewCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForPullRequestReviewCommentReq is request data for Client.ReactionsListForPullRequestReviewComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
type ReactionsListForPullRequestReviewCommentReq struct {
	_url      string
	Owner     string
	Repo      string
	CommentId int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a pull request review comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForPullRequestReviewCommentReq) url() string {
	return r._url
}

func (r *ReactionsListForPullRequestReviewCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments/%v/reactions", r.Owner, r.Repo, r.CommentId)
}

func (r *ReactionsListForPullRequestReviewCommentReq) method() string {
	return "GET"
}

func (r *ReactionsListForPullRequestReviewCommentReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForPullRequestReviewCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForPullRequestReviewCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsListForPullRequestReviewCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForPullRequestReviewCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForPullRequestReviewCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReactionsListForPullRequestReviewCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForPullRequestReviewCommentReq) Rel(link RelName, resp *ReactionsListForPullRequestReviewCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForPullRequestReviewCommentResponseBody is a response body for ReactionsListForPullRequestReviewComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
type ReactionsListForPullRequestReviewCommentResponseBody []struct {
	components.Reaction
}

/*
ReactionsListForPullRequestReviewCommentResponse is a response for ReactionsListForPullRequestReviewComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
type ReactionsListForPullRequestReviewCommentResponse struct {
	response
	request *ReactionsListForPullRequestReviewCommentReq
	Data    *ReactionsListForPullRequestReviewCommentResponseBody
}

/*
ReactionsListForTeamDiscussionCommentInOrg performs requests for "reactions/list-for-team-discussion-comment-in-org"

List reactions for a team discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
func (c *Client) ReactionsListForTeamDiscussionCommentInOrg(ctx context.Context, req *ReactionsListForTeamDiscussionCommentInOrgReq, opt ...RequestOption) (*ReactionsListForTeamDiscussionCommentInOrgResponse, error) {
	resp := &ReactionsListForTeamDiscussionCommentInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ReactionsListForTeamDiscussionCommentInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForTeamDiscussionCommentInOrgReq is request data for Client.ReactionsListForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
type ReactionsListForTeamDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber)
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) method() string {
	return "GET"
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) body() interface{} {
	return nil
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReactionsListForTeamDiscussionCommentInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForTeamDiscussionCommentInOrgReq) Rel(link RelName, resp *ReactionsListForTeamDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForTeamDiscussionCommentInOrgResponseBody is a response body for ReactionsListForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
type ReactionsListForTeamDiscussionCommentInOrgResponseBody []struct {
	components.Reaction
}

/*
ReactionsListForTeamDiscussionCommentInOrgResponse is a response for ReactionsListForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
type ReactionsListForTeamDiscussionCommentInOrgResponse struct {
	response
	request *ReactionsListForTeamDiscussionCommentInOrgReq
	Data    *ReactionsListForTeamDiscussionCommentInOrgResponseBody
}

/*
ReactionsListForTeamDiscussionInOrg performs requests for "reactions/list-for-team-discussion-in-org"

List reactions for a team discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
func (c *Client) ReactionsListForTeamDiscussionInOrg(ctx context.Context, req *ReactionsListForTeamDiscussionInOrgReq, opt ...RequestOption) (*ReactionsListForTeamDiscussionInOrgResponse, error) {
	resp := &ReactionsListForTeamDiscussionInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ReactionsListForTeamDiscussionInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForTeamDiscussionInOrgReq is request data for Client.ReactionsListForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
type ReactionsListForTeamDiscussionInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	APIs for managing reactions are currently available for developers to preview.
	See the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To access the API during the preview period, you must set this to
	true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForTeamDiscussionInOrgReq) url() string {
	return r._url
}

func (r *ReactionsListForTeamDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *ReactionsListForTeamDiscussionInOrgReq) method() string {
	return "GET"
}

func (r *ReactionsListForTeamDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForTeamDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForTeamDiscussionInOrgReq) body() interface{} {
	return nil
}

func (r *ReactionsListForTeamDiscussionInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForTeamDiscussionInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForTeamDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReactionsListForTeamDiscussionInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForTeamDiscussionInOrgReq) Rel(link RelName, resp *ReactionsListForTeamDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForTeamDiscussionInOrgResponseBody is a response body for ReactionsListForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
type ReactionsListForTeamDiscussionInOrgResponseBody []struct {
	components.Reaction
}

/*
ReactionsListForTeamDiscussionInOrgResponse is a response for ReactionsListForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
type ReactionsListForTeamDiscussionInOrgResponse struct {
	response
	request *ReactionsListForTeamDiscussionInOrgReq
	Data    *ReactionsListForTeamDiscussionInOrgResponseBody
}
