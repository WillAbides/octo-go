// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
ReactionsCreateForCommitComment performs requests for "reactions/create-for-commit-comment"

Create reaction for a commit comment.

  POST /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
func ReactionsCreateForCommitComment(ctx context.Context, req *ReactionsCreateForCommitCommentReq, opt ...RequestOption) (*ReactionsCreateForCommitCommentResponse, error) {
	if req == nil {
		req = new(ReactionsCreateForCommitCommentReq)
	}
	resp := &ReactionsCreateForCommitCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForCommitComment performs requests for "reactions/create-for-commit-comment"

Create reaction for a commit comment.

  POST /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
func (c Client) ReactionsCreateForCommitComment(ctx context.Context, req *ReactionsCreateForCommitCommentReq, opt ...RequestOption) (*ReactionsCreateForCommitCommentResponse, error) {
	return ReactionsCreateForCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForCommitCommentReq is request data for Client.ReactionsCreateForCommitComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
type ReactionsCreateForCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody ReactionsCreateForCommitCommentReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForCommitCommentReq) url() string {
	return r._url
}

func (r *ReactionsCreateForCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v/reactions", r.Owner, r.Repo, r.CommentId)
}

func (r *ReactionsCreateForCommitCommentReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForCommitCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForCommitCommentReq) dataStatuses() []int {
	return []int{200, 201}
}

func (r *ReactionsCreateForCommitCommentReq) validStatuses() []int {
	return []int{200, 201}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForCommitCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForCommitCommentReq) Rel(link RelName, resp *ReactionsCreateForCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForCommitCommentReqBody is a request body for reactions/create-for-commit-comment

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
type ReactionsCreateForCommitCommentReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the commit comment.
	Content *string `json:"content"`
}

/*
ReactionsCreateForCommitCommentResponse is a response for ReactionsCreateForCommitComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
type ReactionsCreateForCommitCommentResponse struct {
	response
	request *ReactionsCreateForCommitCommentReq
	Data    components.Reaction
}

/*
ReactionsCreateForIssue performs requests for "reactions/create-for-issue"

Create reaction for an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
func ReactionsCreateForIssue(ctx context.Context, req *ReactionsCreateForIssueReq, opt ...RequestOption) (*ReactionsCreateForIssueResponse, error) {
	if req == nil {
		req = new(ReactionsCreateForIssueReq)
	}
	resp := &ReactionsCreateForIssueResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForIssue performs requests for "reactions/create-for-issue"

Create reaction for an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
func (c Client) ReactionsCreateForIssue(ctx context.Context, req *ReactionsCreateForIssueReq, opt ...RequestOption) (*ReactionsCreateForIssueResponse, error) {
	return ReactionsCreateForIssue(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForIssueReq is request data for Client.ReactionsCreateForIssue

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
type ReactionsCreateForIssueReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody ReactionsCreateForIssueReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForIssueReq) url() string {
	return r._url
}

func (r *ReactionsCreateForIssueReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/reactions", r.Owner, r.Repo, r.IssueNumber)
}

func (r *ReactionsCreateForIssueReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForIssueReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForIssueReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForIssueReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForIssueReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForIssueReq) validStatuses() []int {
	return []int{201}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForIssueReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForIssueReq) Rel(link RelName, resp *ReactionsCreateForIssueResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForIssueReqBody is a request body for reactions/create-for-issue

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
type ReactionsCreateForIssueReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the issue.
	Content *string `json:"content"`
}

/*
ReactionsCreateForIssueResponse is a response for ReactionsCreateForIssue

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
type ReactionsCreateForIssueResponse struct {
	response
	request *ReactionsCreateForIssueReq
	Data    components.Reaction
}

/*
ReactionsCreateForIssueComment performs requests for "reactions/create-for-issue-comment"

Create reaction for an issue comment.

  POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
func ReactionsCreateForIssueComment(ctx context.Context, req *ReactionsCreateForIssueCommentReq, opt ...RequestOption) (*ReactionsCreateForIssueCommentResponse, error) {
	if req == nil {
		req = new(ReactionsCreateForIssueCommentReq)
	}
	resp := &ReactionsCreateForIssueCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForIssueComment performs requests for "reactions/create-for-issue-comment"

Create reaction for an issue comment.

  POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
func (c Client) ReactionsCreateForIssueComment(ctx context.Context, req *ReactionsCreateForIssueCommentReq, opt ...RequestOption) (*ReactionsCreateForIssueCommentResponse, error) {
	return ReactionsCreateForIssueComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForIssueCommentReq is request data for Client.ReactionsCreateForIssueComment

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
type ReactionsCreateForIssueCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody ReactionsCreateForIssueCommentReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForIssueCommentReq) url() string {
	return r._url
}

func (r *ReactionsCreateForIssueCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v/reactions", r.Owner, r.Repo, r.CommentId)
}

func (r *ReactionsCreateForIssueCommentReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForIssueCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForIssueCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForIssueCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForIssueCommentReq) dataStatuses() []int {
	return []int{200, 201}
}

func (r *ReactionsCreateForIssueCommentReq) validStatuses() []int {
	return []int{200, 201}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForIssueCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForIssueCommentReq) Rel(link RelName, resp *ReactionsCreateForIssueCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForIssueCommentReqBody is a request body for reactions/create-for-issue-comment

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
type ReactionsCreateForIssueCommentReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the issue comment.
	Content *string `json:"content"`
}

/*
ReactionsCreateForIssueCommentResponse is a response for ReactionsCreateForIssueComment

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
type ReactionsCreateForIssueCommentResponse struct {
	response
	request *ReactionsCreateForIssueCommentReq
	Data    components.Reaction
}

/*
ReactionsCreateForPullRequestReviewComment performs requests for "reactions/create-for-pull-request-review-comment"

Create reaction for a pull request review comment.

  POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
func ReactionsCreateForPullRequestReviewComment(ctx context.Context, req *ReactionsCreateForPullRequestReviewCommentReq, opt ...RequestOption) (*ReactionsCreateForPullRequestReviewCommentResponse, error) {
	if req == nil {
		req = new(ReactionsCreateForPullRequestReviewCommentReq)
	}
	resp := &ReactionsCreateForPullRequestReviewCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForPullRequestReviewComment performs requests for "reactions/create-for-pull-request-review-comment"

Create reaction for a pull request review comment.

  POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
func (c Client) ReactionsCreateForPullRequestReviewComment(ctx context.Context, req *ReactionsCreateForPullRequestReviewCommentReq, opt ...RequestOption) (*ReactionsCreateForPullRequestReviewCommentResponse, error) {
	return ReactionsCreateForPullRequestReviewComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForPullRequestReviewCommentReq is request data for Client.ReactionsCreateForPullRequestReviewComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
type ReactionsCreateForPullRequestReviewCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody ReactionsCreateForPullRequestReviewCommentReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) url() string {
	return r._url
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments/%v/reactions", r.Owner, r.Repo, r.CommentId)
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) dataStatuses() []int {
	return []int{200, 201}
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) validStatuses() []int {
	return []int{200, 201}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForPullRequestReviewCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForPullRequestReviewCommentReq) Rel(link RelName, resp *ReactionsCreateForPullRequestReviewCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForPullRequestReviewCommentReqBody is a request body for reactions/create-for-pull-request-review-comment

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
type ReactionsCreateForPullRequestReviewCommentReqBody struct {

	/*
	The [reaction type](https://developer.github.com/v3/reactions/#reaction-types)
	to add to the pull request review comment.
	*/
	Content *string `json:"content"`
}

/*
ReactionsCreateForPullRequestReviewCommentResponse is a response for ReactionsCreateForPullRequestReviewComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
type ReactionsCreateForPullRequestReviewCommentResponse struct {
	response
	request *ReactionsCreateForPullRequestReviewCommentReq
	Data    components.Reaction
}

/*
ReactionsCreateForTeamDiscussionCommentInOrg performs requests for "reactions/create-for-team-discussion-comment-in-org"

Create reaction for a team discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
func ReactionsCreateForTeamDiscussionCommentInOrg(ctx context.Context, req *ReactionsCreateForTeamDiscussionCommentInOrgReq, opt ...RequestOption) (*ReactionsCreateForTeamDiscussionCommentInOrgResponse, error) {
	if req == nil {
		req = new(ReactionsCreateForTeamDiscussionCommentInOrgReq)
	}
	resp := &ReactionsCreateForTeamDiscussionCommentInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForTeamDiscussionCommentInOrg performs requests for "reactions/create-for-team-discussion-comment-in-org"

Create reaction for a team discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
func (c Client) ReactionsCreateForTeamDiscussionCommentInOrg(ctx context.Context, req *ReactionsCreateForTeamDiscussionCommentInOrgReq, opt ...RequestOption) (*ReactionsCreateForTeamDiscussionCommentInOrgResponse, error) {
	return ReactionsCreateForTeamDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForTeamDiscussionCommentInOrgReq is request data for Client.ReactionsCreateForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
type ReactionsCreateForTeamDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      ReactionsCreateForTeamDiscussionCommentInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber)
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{201}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) Rel(link RelName, resp *ReactionsCreateForTeamDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForTeamDiscussionCommentInOrgReqBody is a request body for reactions/create-for-team-discussion-comment-in-org

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
type ReactionsCreateForTeamDiscussionCommentInOrgReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the team discussion comment.
	Content *string `json:"content"`
}

/*
ReactionsCreateForTeamDiscussionCommentInOrgResponse is a response for ReactionsCreateForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
type ReactionsCreateForTeamDiscussionCommentInOrgResponse struct {
	response
	request *ReactionsCreateForTeamDiscussionCommentInOrgReq
	Data    components.Reaction
}

/*
ReactionsCreateForTeamDiscussionCommentLegacy performs requests for "reactions/create-for-team-discussion-comment-legacy"

Create reaction for a team discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
func ReactionsCreateForTeamDiscussionCommentLegacy(ctx context.Context, req *ReactionsCreateForTeamDiscussionCommentLegacyReq, opt ...RequestOption) (*ReactionsCreateForTeamDiscussionCommentLegacyResponse, error) {
	if req == nil {
		req = new(ReactionsCreateForTeamDiscussionCommentLegacyReq)
	}
	resp := &ReactionsCreateForTeamDiscussionCommentLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForTeamDiscussionCommentLegacy performs requests for "reactions/create-for-team-discussion-comment-legacy"

Create reaction for a team discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
func (c Client) ReactionsCreateForTeamDiscussionCommentLegacy(ctx context.Context, req *ReactionsCreateForTeamDiscussionCommentLegacyReq, opt ...RequestOption) (*ReactionsCreateForTeamDiscussionCommentLegacyResponse, error) {
	return ReactionsCreateForTeamDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForTeamDiscussionCommentLegacyReq is request data for Client.ReactionsCreateForTeamDiscussionCommentLegacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
type ReactionsCreateForTeamDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      ReactionsCreateForTeamDiscussionCommentLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForTeamDiscussionCommentLegacyReq) url() string {
	return r._url
}

func (r *ReactionsCreateForTeamDiscussionCommentLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions/%v/comments/%v/reactions", r.TeamId, r.DiscussionNumber, r.CommentNumber)
}

func (r *ReactionsCreateForTeamDiscussionCommentLegacyReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForTeamDiscussionCommentLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForTeamDiscussionCommentLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForTeamDiscussionCommentLegacyReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForTeamDiscussionCommentLegacyReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForTeamDiscussionCommentLegacyReq) validStatuses() []int {
	return []int{201}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForTeamDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForTeamDiscussionCommentLegacyReq) Rel(link RelName, resp *ReactionsCreateForTeamDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForTeamDiscussionCommentLegacyReqBody is a request body for reactions/create-for-team-discussion-comment-legacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
type ReactionsCreateForTeamDiscussionCommentLegacyReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the team discussion comment.
	Content *string `json:"content"`
}

/*
ReactionsCreateForTeamDiscussionCommentLegacyResponse is a response for ReactionsCreateForTeamDiscussionCommentLegacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
type ReactionsCreateForTeamDiscussionCommentLegacyResponse struct {
	response
	request *ReactionsCreateForTeamDiscussionCommentLegacyReq
	Data    components.Reaction
}

/*
ReactionsCreateForTeamDiscussionInOrg performs requests for "reactions/create-for-team-discussion-in-org"

Create reaction for a team discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
func ReactionsCreateForTeamDiscussionInOrg(ctx context.Context, req *ReactionsCreateForTeamDiscussionInOrgReq, opt ...RequestOption) (*ReactionsCreateForTeamDiscussionInOrgResponse, error) {
	if req == nil {
		req = new(ReactionsCreateForTeamDiscussionInOrgReq)
	}
	resp := &ReactionsCreateForTeamDiscussionInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForTeamDiscussionInOrg performs requests for "reactions/create-for-team-discussion-in-org"

Create reaction for a team discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
func (c Client) ReactionsCreateForTeamDiscussionInOrg(ctx context.Context, req *ReactionsCreateForTeamDiscussionInOrgReq, opt ...RequestOption) (*ReactionsCreateForTeamDiscussionInOrgResponse, error) {
	return ReactionsCreateForTeamDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForTeamDiscussionInOrgReq is request data for Client.ReactionsCreateForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
type ReactionsCreateForTeamDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      ReactionsCreateForTeamDiscussionInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) url() string {
	return r._url
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) validStatuses() []int {
	return []int{201}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForTeamDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForTeamDiscussionInOrgReq) Rel(link RelName, resp *ReactionsCreateForTeamDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForTeamDiscussionInOrgReqBody is a request body for reactions/create-for-team-discussion-in-org

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
type ReactionsCreateForTeamDiscussionInOrgReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the team discussion.
	Content *string `json:"content"`
}

/*
ReactionsCreateForTeamDiscussionInOrgResponse is a response for ReactionsCreateForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
type ReactionsCreateForTeamDiscussionInOrgResponse struct {
	response
	request *ReactionsCreateForTeamDiscussionInOrgReq
	Data    components.Reaction
}

/*
ReactionsCreateForTeamDiscussionLegacy performs requests for "reactions/create-for-team-discussion-legacy"

Create reaction for a team discussion (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
func ReactionsCreateForTeamDiscussionLegacy(ctx context.Context, req *ReactionsCreateForTeamDiscussionLegacyReq, opt ...RequestOption) (*ReactionsCreateForTeamDiscussionLegacyResponse, error) {
	if req == nil {
		req = new(ReactionsCreateForTeamDiscussionLegacyReq)
	}
	resp := &ReactionsCreateForTeamDiscussionLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForTeamDiscussionLegacy performs requests for "reactions/create-for-team-discussion-legacy"

Create reaction for a team discussion (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
func (c Client) ReactionsCreateForTeamDiscussionLegacy(ctx context.Context, req *ReactionsCreateForTeamDiscussionLegacyReq, opt ...RequestOption) (*ReactionsCreateForTeamDiscussionLegacyResponse, error) {
	return ReactionsCreateForTeamDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForTeamDiscussionLegacyReq is request data for Client.ReactionsCreateForTeamDiscussionLegacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
type ReactionsCreateForTeamDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	RequestBody      ReactionsCreateForTeamDiscussionLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsCreateForTeamDiscussionLegacyReq) url() string {
	return r._url
}

func (r *ReactionsCreateForTeamDiscussionLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions/%v/reactions", r.TeamId, r.DiscussionNumber)
}

func (r *ReactionsCreateForTeamDiscussionLegacyReq) method() string {
	return "POST"
}

func (r *ReactionsCreateForTeamDiscussionLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsCreateForTeamDiscussionLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsCreateForTeamDiscussionLegacyReq) body() interface{} {
	return r.RequestBody
}

func (r *ReactionsCreateForTeamDiscussionLegacyReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReactionsCreateForTeamDiscussionLegacyReq) validStatuses() []int {
	return []int{201}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForTeamDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForTeamDiscussionLegacyReq) Rel(link RelName, resp *ReactionsCreateForTeamDiscussionLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForTeamDiscussionLegacyReqBody is a request body for reactions/create-for-team-discussion-legacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
type ReactionsCreateForTeamDiscussionLegacyReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the team discussion.
	Content *string `json:"content"`
}

/*
ReactionsCreateForTeamDiscussionLegacyResponse is a response for ReactionsCreateForTeamDiscussionLegacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
type ReactionsCreateForTeamDiscussionLegacyResponse struct {
	response
	request *ReactionsCreateForTeamDiscussionLegacyReq
	Data    components.Reaction
}

/*
ReactionsDeleteForCommitComment performs requests for "reactions/delete-for-commit-comment"

Delete a commit comment reaction.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
func ReactionsDeleteForCommitComment(ctx context.Context, req *ReactionsDeleteForCommitCommentReq, opt ...RequestOption) (*ReactionsDeleteForCommitCommentResponse, error) {
	if req == nil {
		req = new(ReactionsDeleteForCommitCommentReq)
	}
	resp := &ReactionsDeleteForCommitCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForCommitComment performs requests for "reactions/delete-for-commit-comment"

Delete a commit comment reaction.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
func (c Client) ReactionsDeleteForCommitComment(ctx context.Context, req *ReactionsDeleteForCommitCommentReq, opt ...RequestOption) (*ReactionsDeleteForCommitCommentResponse, error) {
	return ReactionsDeleteForCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteForCommitCommentReq is request data for Client.ReactionsDeleteForCommitComment

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
type ReactionsDeleteForCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId  int64
	ReactionId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsDeleteForCommitCommentReq) url() string {
	return r._url
}

func (r *ReactionsDeleteForCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v/reactions/%v", r.Owner, r.Repo, r.CommentId, r.ReactionId)
}

func (r *ReactionsDeleteForCommitCommentReq) method() string {
	return "DELETE"
}

func (r *ReactionsDeleteForCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsDeleteForCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsDeleteForCommitCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsDeleteForCommitCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *ReactionsDeleteForCommitCommentReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteForCommitCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForCommitCommentReq) Rel(link RelName, resp *ReactionsDeleteForCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForCommitCommentResponse is a response for ReactionsDeleteForCommitComment

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
type ReactionsDeleteForCommitCommentResponse struct {
	response
	request *ReactionsDeleteForCommitCommentReq
}

/*
ReactionsDeleteForIssue performs requests for "reactions/delete-for-issue"

Delete an issue reaction.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
func ReactionsDeleteForIssue(ctx context.Context, req *ReactionsDeleteForIssueReq, opt ...RequestOption) (*ReactionsDeleteForIssueResponse, error) {
	if req == nil {
		req = new(ReactionsDeleteForIssueReq)
	}
	resp := &ReactionsDeleteForIssueResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForIssue performs requests for "reactions/delete-for-issue"

Delete an issue reaction.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
func (c Client) ReactionsDeleteForIssue(ctx context.Context, req *ReactionsDeleteForIssueReq, opt ...RequestOption) (*ReactionsDeleteForIssueResponse, error) {
	return ReactionsDeleteForIssue(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteForIssueReq is request data for Client.ReactionsDeleteForIssue

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
type ReactionsDeleteForIssueReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	ReactionId  int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsDeleteForIssueReq) url() string {
	return r._url
}

func (r *ReactionsDeleteForIssueReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/reactions/%v", r.Owner, r.Repo, r.IssueNumber, r.ReactionId)
}

func (r *ReactionsDeleteForIssueReq) method() string {
	return "DELETE"
}

func (r *ReactionsDeleteForIssueReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsDeleteForIssueReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsDeleteForIssueReq) body() interface{} {
	return nil
}

func (r *ReactionsDeleteForIssueReq) dataStatuses() []int {
	return []int{}
}

func (r *ReactionsDeleteForIssueReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteForIssueReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForIssueReq) Rel(link RelName, resp *ReactionsDeleteForIssueResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForIssueResponse is a response for ReactionsDeleteForIssue

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
type ReactionsDeleteForIssueResponse struct {
	response
	request *ReactionsDeleteForIssueReq
}

/*
ReactionsDeleteForIssueComment performs requests for "reactions/delete-for-issue-comment"

Delete an issue comment reaction.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
func ReactionsDeleteForIssueComment(ctx context.Context, req *ReactionsDeleteForIssueCommentReq, opt ...RequestOption) (*ReactionsDeleteForIssueCommentResponse, error) {
	if req == nil {
		req = new(ReactionsDeleteForIssueCommentReq)
	}
	resp := &ReactionsDeleteForIssueCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForIssueComment performs requests for "reactions/delete-for-issue-comment"

Delete an issue comment reaction.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
func (c Client) ReactionsDeleteForIssueComment(ctx context.Context, req *ReactionsDeleteForIssueCommentReq, opt ...RequestOption) (*ReactionsDeleteForIssueCommentResponse, error) {
	return ReactionsDeleteForIssueComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteForIssueCommentReq is request data for Client.ReactionsDeleteForIssueComment

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
type ReactionsDeleteForIssueCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId  int64
	ReactionId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsDeleteForIssueCommentReq) url() string {
	return r._url
}

func (r *ReactionsDeleteForIssueCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v/reactions/%v", r.Owner, r.Repo, r.CommentId, r.ReactionId)
}

func (r *ReactionsDeleteForIssueCommentReq) method() string {
	return "DELETE"
}

func (r *ReactionsDeleteForIssueCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsDeleteForIssueCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsDeleteForIssueCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsDeleteForIssueCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *ReactionsDeleteForIssueCommentReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteForIssueCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForIssueCommentReq) Rel(link RelName, resp *ReactionsDeleteForIssueCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForIssueCommentResponse is a response for ReactionsDeleteForIssueComment

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
type ReactionsDeleteForIssueCommentResponse struct {
	response
	request *ReactionsDeleteForIssueCommentReq
}

/*
ReactionsDeleteForPullRequestComment performs requests for "reactions/delete-for-pull-request-comment"

Delete a pull request comment reaction.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
func ReactionsDeleteForPullRequestComment(ctx context.Context, req *ReactionsDeleteForPullRequestCommentReq, opt ...RequestOption) (*ReactionsDeleteForPullRequestCommentResponse, error) {
	if req == nil {
		req = new(ReactionsDeleteForPullRequestCommentReq)
	}
	resp := &ReactionsDeleteForPullRequestCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForPullRequestComment performs requests for "reactions/delete-for-pull-request-comment"

Delete a pull request comment reaction.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
func (c Client) ReactionsDeleteForPullRequestComment(ctx context.Context, req *ReactionsDeleteForPullRequestCommentReq, opt ...RequestOption) (*ReactionsDeleteForPullRequestCommentResponse, error) {
	return ReactionsDeleteForPullRequestComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteForPullRequestCommentReq is request data for Client.ReactionsDeleteForPullRequestComment

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
type ReactionsDeleteForPullRequestCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId  int64
	ReactionId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsDeleteForPullRequestCommentReq) url() string {
	return r._url
}

func (r *ReactionsDeleteForPullRequestCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments/%v/reactions/%v", r.Owner, r.Repo, r.CommentId, r.ReactionId)
}

func (r *ReactionsDeleteForPullRequestCommentReq) method() string {
	return "DELETE"
}

func (r *ReactionsDeleteForPullRequestCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsDeleteForPullRequestCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsDeleteForPullRequestCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsDeleteForPullRequestCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *ReactionsDeleteForPullRequestCommentReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteForPullRequestCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForPullRequestCommentReq) Rel(link RelName, resp *ReactionsDeleteForPullRequestCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForPullRequestCommentResponse is a response for ReactionsDeleteForPullRequestComment

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
type ReactionsDeleteForPullRequestCommentResponse struct {
	response
	request *ReactionsDeleteForPullRequestCommentReq
}

/*
ReactionsDeleteForTeamDiscussion performs requests for "reactions/delete-for-team-discussion"

Delete team discussion reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
func ReactionsDeleteForTeamDiscussion(ctx context.Context, req *ReactionsDeleteForTeamDiscussionReq, opt ...RequestOption) (*ReactionsDeleteForTeamDiscussionResponse, error) {
	if req == nil {
		req = new(ReactionsDeleteForTeamDiscussionReq)
	}
	resp := &ReactionsDeleteForTeamDiscussionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForTeamDiscussion performs requests for "reactions/delete-for-team-discussion"

Delete team discussion reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
func (c Client) ReactionsDeleteForTeamDiscussion(ctx context.Context, req *ReactionsDeleteForTeamDiscussionReq, opt ...RequestOption) (*ReactionsDeleteForTeamDiscussionResponse, error) {
	return ReactionsDeleteForTeamDiscussion(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteForTeamDiscussionReq is request data for Client.ReactionsDeleteForTeamDiscussion

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
type ReactionsDeleteForTeamDiscussionReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	ReactionId       int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsDeleteForTeamDiscussionReq) url() string {
	return r._url
}

func (r *ReactionsDeleteForTeamDiscussionReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/reactions/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.ReactionId)
}

func (r *ReactionsDeleteForTeamDiscussionReq) method() string {
	return "DELETE"
}

func (r *ReactionsDeleteForTeamDiscussionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsDeleteForTeamDiscussionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsDeleteForTeamDiscussionReq) body() interface{} {
	return nil
}

func (r *ReactionsDeleteForTeamDiscussionReq) dataStatuses() []int {
	return []int{}
}

func (r *ReactionsDeleteForTeamDiscussionReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteForTeamDiscussionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForTeamDiscussionReq) Rel(link RelName, resp *ReactionsDeleteForTeamDiscussionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForTeamDiscussionResponse is a response for ReactionsDeleteForTeamDiscussion

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
type ReactionsDeleteForTeamDiscussionResponse struct {
	response
	request *ReactionsDeleteForTeamDiscussionReq
}

/*
ReactionsDeleteForTeamDiscussionComment performs requests for "reactions/delete-for-team-discussion-comment"

Delete team discussion comment reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
func ReactionsDeleteForTeamDiscussionComment(ctx context.Context, req *ReactionsDeleteForTeamDiscussionCommentReq, opt ...RequestOption) (*ReactionsDeleteForTeamDiscussionCommentResponse, error) {
	if req == nil {
		req = new(ReactionsDeleteForTeamDiscussionCommentReq)
	}
	resp := &ReactionsDeleteForTeamDiscussionCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForTeamDiscussionComment performs requests for "reactions/delete-for-team-discussion-comment"

Delete team discussion comment reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
func (c Client) ReactionsDeleteForTeamDiscussionComment(ctx context.Context, req *ReactionsDeleteForTeamDiscussionCommentReq, opt ...RequestOption) (*ReactionsDeleteForTeamDiscussionCommentResponse, error) {
	return ReactionsDeleteForTeamDiscussionComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteForTeamDiscussionCommentReq is request data for Client.ReactionsDeleteForTeamDiscussionComment

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
type ReactionsDeleteForTeamDiscussionCommentReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	ReactionId       int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) url() string {
	return r._url
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v/reactions/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber, r.ReactionId)
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) method() string {
	return "DELETE"
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteForTeamDiscussionCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForTeamDiscussionCommentReq) Rel(link RelName, resp *ReactionsDeleteForTeamDiscussionCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForTeamDiscussionCommentResponse is a response for ReactionsDeleteForTeamDiscussionComment

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
type ReactionsDeleteForTeamDiscussionCommentResponse struct {
	response
	request *ReactionsDeleteForTeamDiscussionCommentReq
}

/*
ReactionsDeleteLegacy performs requests for "reactions/delete-legacy"

Delete a reaction (Legacy).

  DELETE /reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-reaction-legacy
*/
func ReactionsDeleteLegacy(ctx context.Context, req *ReactionsDeleteLegacyReq, opt ...RequestOption) (*ReactionsDeleteLegacyResponse, error) {
	if req == nil {
		req = new(ReactionsDeleteLegacyReq)
	}
	resp := &ReactionsDeleteLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteLegacy performs requests for "reactions/delete-legacy"

Delete a reaction (Legacy).

  DELETE /reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-reaction-legacy
*/
func (c Client) ReactionsDeleteLegacy(ctx context.Context, req *ReactionsDeleteLegacyReq, opt ...RequestOption) (*ReactionsDeleteLegacyResponse, error) {
	return ReactionsDeleteLegacy(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteLegacyReq is request data for Client.ReactionsDeleteLegacy

https://developer.github.com/v3/reactions/#delete-a-reaction-legacy
*/
type ReactionsDeleteLegacyReq struct {
	_url       string
	ReactionId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsDeleteLegacyReq) url() string {
	return r._url
}

func (r *ReactionsDeleteLegacyReq) urlPath() string {
	return fmt.Sprintf("/reactions/%v", r.ReactionId)
}

func (r *ReactionsDeleteLegacyReq) method() string {
	return "DELETE"
}

func (r *ReactionsDeleteLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReactionsDeleteLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsDeleteLegacyReq) body() interface{} {
	return nil
}

func (r *ReactionsDeleteLegacyReq) dataStatuses() []int {
	return []int{}
}

func (r *ReactionsDeleteLegacyReq) validStatuses() []int {
	return []int{204, 304}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteLegacyReq) Rel(link RelName, resp *ReactionsDeleteLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteLegacyResponse is a response for ReactionsDeleteLegacy

https://developer.github.com/v3/reactions/#delete-a-reaction-legacy
*/
type ReactionsDeleteLegacyResponse struct {
	response
	request *ReactionsDeleteLegacyReq
}

/*
ReactionsListForCommitComment performs requests for "reactions/list-for-commit-comment"

List reactions for a commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
func ReactionsListForCommitComment(ctx context.Context, req *ReactionsListForCommitCommentReq, opt ...RequestOption) (*ReactionsListForCommitCommentResponse, error) {
	if req == nil {
		req = new(ReactionsListForCommitCommentReq)
	}
	resp := &ReactionsListForCommitCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForCommitComment performs requests for "reactions/list-for-commit-comment"

List reactions for a commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
func (c Client) ReactionsListForCommitComment(ctx context.Context, req *ReactionsListForCommitCommentReq, opt ...RequestOption) (*ReactionsListForCommitCommentResponse, error) {
	return ReactionsListForCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForCommitCommentReq is request data for Client.ReactionsListForCommitComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
type ReactionsListForCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a commit comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForCommitCommentReq) url() string {
	return r._url
}

func (r *ReactionsListForCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v/reactions", r.Owner, r.Repo, r.CommentId)
}

func (r *ReactionsListForCommitCommentReq) method() string {
	return "GET"
}

func (r *ReactionsListForCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForCommitCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsListForCommitCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForCommitCommentReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForCommitCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForCommitCommentReq) Rel(link RelName, resp *ReactionsListForCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForCommitCommentResponse is a response for ReactionsListForCommitComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
type ReactionsListForCommitCommentResponse struct {
	response
	request *ReactionsListForCommitCommentReq
	Data    []components.Reaction
}

/*
ReactionsListForIssue performs requests for "reactions/list-for-issue"

List reactions for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
func ReactionsListForIssue(ctx context.Context, req *ReactionsListForIssueReq, opt ...RequestOption) (*ReactionsListForIssueResponse, error) {
	if req == nil {
		req = new(ReactionsListForIssueReq)
	}
	resp := &ReactionsListForIssueResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForIssue performs requests for "reactions/list-for-issue"

List reactions for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
func (c Client) ReactionsListForIssue(ctx context.Context, req *ReactionsListForIssueReq, opt ...RequestOption) (*ReactionsListForIssueResponse, error) {
	return ReactionsListForIssue(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForIssueReq is request data for Client.ReactionsListForIssue

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
type ReactionsListForIssueReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to an issue.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForIssueReq) url() string {
	return r._url
}

func (r *ReactionsListForIssueReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/reactions", r.Owner, r.Repo, r.IssueNumber)
}

func (r *ReactionsListForIssueReq) method() string {
	return "GET"
}

func (r *ReactionsListForIssueReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForIssueReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForIssueReq) body() interface{} {
	return nil
}

func (r *ReactionsListForIssueReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForIssueReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForIssueReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForIssueReq) Rel(link RelName, resp *ReactionsListForIssueResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForIssueResponse is a response for ReactionsListForIssue

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
type ReactionsListForIssueResponse struct {
	response
	request *ReactionsListForIssueReq
	Data    []components.Reaction
}

/*
ReactionsListForIssueComment performs requests for "reactions/list-for-issue-comment"

List reactions for an issue comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
func ReactionsListForIssueComment(ctx context.Context, req *ReactionsListForIssueCommentReq, opt ...RequestOption) (*ReactionsListForIssueCommentResponse, error) {
	if req == nil {
		req = new(ReactionsListForIssueCommentReq)
	}
	resp := &ReactionsListForIssueCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForIssueComment performs requests for "reactions/list-for-issue-comment"

List reactions for an issue comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
func (c Client) ReactionsListForIssueComment(ctx context.Context, req *ReactionsListForIssueCommentReq, opt ...RequestOption) (*ReactionsListForIssueCommentResponse, error) {
	return ReactionsListForIssueComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForIssueCommentReq is request data for Client.ReactionsListForIssueComment

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
type ReactionsListForIssueCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to an issue comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForIssueCommentReq) url() string {
	return r._url
}

func (r *ReactionsListForIssueCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v/reactions", r.Owner, r.Repo, r.CommentId)
}

func (r *ReactionsListForIssueCommentReq) method() string {
	return "GET"
}

func (r *ReactionsListForIssueCommentReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForIssueCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForIssueCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsListForIssueCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForIssueCommentReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForIssueCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForIssueCommentReq) Rel(link RelName, resp *ReactionsListForIssueCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForIssueCommentResponse is a response for ReactionsListForIssueComment

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
type ReactionsListForIssueCommentResponse struct {
	response
	request *ReactionsListForIssueCommentReq
	Data    []components.Reaction
}

/*
ReactionsListForPullRequestReviewComment performs requests for "reactions/list-for-pull-request-review-comment"

List reactions for a pull request review comment.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
func ReactionsListForPullRequestReviewComment(ctx context.Context, req *ReactionsListForPullRequestReviewCommentReq, opt ...RequestOption) (*ReactionsListForPullRequestReviewCommentResponse, error) {
	if req == nil {
		req = new(ReactionsListForPullRequestReviewCommentReq)
	}
	resp := &ReactionsListForPullRequestReviewCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForPullRequestReviewComment performs requests for "reactions/list-for-pull-request-review-comment"

List reactions for a pull request review comment.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
func (c Client) ReactionsListForPullRequestReviewComment(ctx context.Context, req *ReactionsListForPullRequestReviewCommentReq, opt ...RequestOption) (*ReactionsListForPullRequestReviewCommentResponse, error) {
	return ReactionsListForPullRequestReviewComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForPullRequestReviewCommentReq is request data for Client.ReactionsListForPullRequestReviewComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
type ReactionsListForPullRequestReviewCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a pull request review comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForPullRequestReviewCommentReq) url() string {
	return r._url
}

func (r *ReactionsListForPullRequestReviewCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments/%v/reactions", r.Owner, r.Repo, r.CommentId)
}

func (r *ReactionsListForPullRequestReviewCommentReq) method() string {
	return "GET"
}

func (r *ReactionsListForPullRequestReviewCommentReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForPullRequestReviewCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForPullRequestReviewCommentReq) body() interface{} {
	return nil
}

func (r *ReactionsListForPullRequestReviewCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForPullRequestReviewCommentReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForPullRequestReviewCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForPullRequestReviewCommentReq) Rel(link RelName, resp *ReactionsListForPullRequestReviewCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForPullRequestReviewCommentResponse is a response for ReactionsListForPullRequestReviewComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
type ReactionsListForPullRequestReviewCommentResponse struct {
	response
	request *ReactionsListForPullRequestReviewCommentReq
	Data    []components.Reaction
}

/*
ReactionsListForTeamDiscussionCommentInOrg performs requests for "reactions/list-for-team-discussion-comment-in-org"

List reactions for a team discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
func ReactionsListForTeamDiscussionCommentInOrg(ctx context.Context, req *ReactionsListForTeamDiscussionCommentInOrgReq, opt ...RequestOption) (*ReactionsListForTeamDiscussionCommentInOrgResponse, error) {
	if req == nil {
		req = new(ReactionsListForTeamDiscussionCommentInOrgReq)
	}
	resp := &ReactionsListForTeamDiscussionCommentInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForTeamDiscussionCommentInOrg performs requests for "reactions/list-for-team-discussion-comment-in-org"

List reactions for a team discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
func (c Client) ReactionsListForTeamDiscussionCommentInOrg(ctx context.Context, req *ReactionsListForTeamDiscussionCommentInOrgReq, opt ...RequestOption) (*ReactionsListForTeamDiscussionCommentInOrgResponse, error) {
	return ReactionsListForTeamDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForTeamDiscussionCommentInOrgReq is request data for Client.ReactionsListForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
type ReactionsListForTeamDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber)
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) method() string {
	return "GET"
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) body() interface{} {
	return nil
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForTeamDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForTeamDiscussionCommentInOrgReq) Rel(link RelName, resp *ReactionsListForTeamDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForTeamDiscussionCommentInOrgResponse is a response for ReactionsListForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
type ReactionsListForTeamDiscussionCommentInOrgResponse struct {
	response
	request *ReactionsListForTeamDiscussionCommentInOrgReq
	Data    []components.Reaction
}

/*
ReactionsListForTeamDiscussionCommentLegacy performs requests for "reactions/list-for-team-discussion-comment-legacy"

List reactions for a team discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment-legacy
*/
func ReactionsListForTeamDiscussionCommentLegacy(ctx context.Context, req *ReactionsListForTeamDiscussionCommentLegacyReq, opt ...RequestOption) (*ReactionsListForTeamDiscussionCommentLegacyResponse, error) {
	if req == nil {
		req = new(ReactionsListForTeamDiscussionCommentLegacyReq)
	}
	resp := &ReactionsListForTeamDiscussionCommentLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForTeamDiscussionCommentLegacy performs requests for "reactions/list-for-team-discussion-comment-legacy"

List reactions for a team discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment-legacy
*/
func (c Client) ReactionsListForTeamDiscussionCommentLegacy(ctx context.Context, req *ReactionsListForTeamDiscussionCommentLegacyReq, opt ...RequestOption) (*ReactionsListForTeamDiscussionCommentLegacyResponse, error) {
	return ReactionsListForTeamDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForTeamDiscussionCommentLegacyReq is request data for Client.ReactionsListForTeamDiscussionCommentLegacy

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment-legacy
*/
type ReactionsListForTeamDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForTeamDiscussionCommentLegacyReq) url() string {
	return r._url
}

func (r *ReactionsListForTeamDiscussionCommentLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions/%v/comments/%v/reactions", r.TeamId, r.DiscussionNumber, r.CommentNumber)
}

func (r *ReactionsListForTeamDiscussionCommentLegacyReq) method() string {
	return "GET"
}

func (r *ReactionsListForTeamDiscussionCommentLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForTeamDiscussionCommentLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForTeamDiscussionCommentLegacyReq) body() interface{} {
	return nil
}

func (r *ReactionsListForTeamDiscussionCommentLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForTeamDiscussionCommentLegacyReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForTeamDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForTeamDiscussionCommentLegacyReq) Rel(link RelName, resp *ReactionsListForTeamDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForTeamDiscussionCommentLegacyResponse is a response for ReactionsListForTeamDiscussionCommentLegacy

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment-legacy
*/
type ReactionsListForTeamDiscussionCommentLegacyResponse struct {
	response
	request *ReactionsListForTeamDiscussionCommentLegacyReq
	Data    []components.Reaction
}

/*
ReactionsListForTeamDiscussionInOrg performs requests for "reactions/list-for-team-discussion-in-org"

List reactions for a team discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
func ReactionsListForTeamDiscussionInOrg(ctx context.Context, req *ReactionsListForTeamDiscussionInOrgReq, opt ...RequestOption) (*ReactionsListForTeamDiscussionInOrgResponse, error) {
	if req == nil {
		req = new(ReactionsListForTeamDiscussionInOrgReq)
	}
	resp := &ReactionsListForTeamDiscussionInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForTeamDiscussionInOrg performs requests for "reactions/list-for-team-discussion-in-org"

List reactions for a team discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
func (c Client) ReactionsListForTeamDiscussionInOrg(ctx context.Context, req *ReactionsListForTeamDiscussionInOrgReq, opt ...RequestOption) (*ReactionsListForTeamDiscussionInOrgResponse, error) {
	return ReactionsListForTeamDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForTeamDiscussionInOrgReq is request data for Client.ReactionsListForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
type ReactionsListForTeamDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForTeamDiscussionInOrgReq) url() string {
	return r._url
}

func (r *ReactionsListForTeamDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *ReactionsListForTeamDiscussionInOrgReq) method() string {
	return "GET"
}

func (r *ReactionsListForTeamDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForTeamDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForTeamDiscussionInOrgReq) body() interface{} {
	return nil
}

func (r *ReactionsListForTeamDiscussionInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForTeamDiscussionInOrgReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForTeamDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForTeamDiscussionInOrgReq) Rel(link RelName, resp *ReactionsListForTeamDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForTeamDiscussionInOrgResponse is a response for ReactionsListForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
type ReactionsListForTeamDiscussionInOrgResponse struct {
	response
	request *ReactionsListForTeamDiscussionInOrgReq
	Data    []components.Reaction
}

/*
ReactionsListForTeamDiscussionLegacy performs requests for "reactions/list-for-team-discussion-legacy"

List reactions for a team discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-legacy
*/
func ReactionsListForTeamDiscussionLegacy(ctx context.Context, req *ReactionsListForTeamDiscussionLegacyReq, opt ...RequestOption) (*ReactionsListForTeamDiscussionLegacyResponse, error) {
	if req == nil {
		req = new(ReactionsListForTeamDiscussionLegacyReq)
	}
	resp := &ReactionsListForTeamDiscussionLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.Reaction{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForTeamDiscussionLegacy performs requests for "reactions/list-for-team-discussion-legacy"

List reactions for a team discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-legacy
*/
func (c Client) ReactionsListForTeamDiscussionLegacy(ctx context.Context, req *ReactionsListForTeamDiscussionLegacyReq, opt ...RequestOption) (*ReactionsListForTeamDiscussionLegacyResponse, error) {
	return ReactionsListForTeamDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForTeamDiscussionLegacyReq is request data for Client.ReactionsListForTeamDiscussionLegacy

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-legacy
*/
type ReactionsListForTeamDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReactionsListForTeamDiscussionLegacyReq) url() string {
	return r._url
}

func (r *ReactionsListForTeamDiscussionLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions/%v/reactions", r.TeamId, r.DiscussionNumber)
}

func (r *ReactionsListForTeamDiscussionLegacyReq) method() string {
	return "GET"
}

func (r *ReactionsListForTeamDiscussionLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReactionsListForTeamDiscussionLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if requiredPreviews {
		previewVals["squirrel-girl"] = true
	}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReactionsListForTeamDiscussionLegacyReq) body() interface{} {
	return nil
}

func (r *ReactionsListForTeamDiscussionLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReactionsListForTeamDiscussionLegacyReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForTeamDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForTeamDiscussionLegacyReq) Rel(link RelName, resp *ReactionsListForTeamDiscussionLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForTeamDiscussionLegacyResponse is a response for ReactionsListForTeamDiscussionLegacy

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-legacy
*/
type ReactionsListForTeamDiscussionLegacyResponse struct {
	response
	request *ReactionsListForTeamDiscussionLegacyReq
	Data    []components.Reaction
}
