// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
ReactionsCreateForCommitComment performs requests for "reactions/create-for-commit-comment"

Create reaction for a commit comment.

  POST /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
func ReactionsCreateForCommitComment(ctx context.Context, req *ReactionsCreateForCommitCommentReq, opt ...options.Option) (*ReactionsCreateForCommitCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsCreateForCommitCommentReq)
	}
	resp := &ReactionsCreateForCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForCommitComment performs requests for "reactions/create-for-commit-comment"

Create reaction for a commit comment.

  POST /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
func (c Client) ReactionsCreateForCommitComment(ctx context.Context, req *ReactionsCreateForCommitCommentReq, opt ...options.Option) (*ReactionsCreateForCommitCommentResponse, error) {
	return ReactionsCreateForCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForCommitCommentReq is request data for Client.ReactionsCreateForCommitComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
type ReactionsCreateForCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody ReactionsCreateForCommitCommentReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForCommitCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsCreateForCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{200, 201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-commit-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/comments/%v/reactions", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForCommitCommentReq) Rel(link string, resp *ReactionsCreateForCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForCommitCommentReqBody is a request body for reactions/create-for-commit-comment

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
type ReactionsCreateForCommitCommentReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the commit comment.
	Content *string `json:"content"`
}

/*
ReactionsCreateForCommitCommentResponse is a response for ReactionsCreateForCommitComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
type ReactionsCreateForCommitCommentResponse struct {
	common.Response
	request *ReactionsCreateForCommitCommentReq
	Data    components.Reaction
}

/*
ReactionsCreateForIssue performs requests for "reactions/create-for-issue"

Create reaction for an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
func ReactionsCreateForIssue(ctx context.Context, req *ReactionsCreateForIssueReq, opt ...options.Option) (*ReactionsCreateForIssueResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsCreateForIssueReq)
	}
	resp := &ReactionsCreateForIssueResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForIssue performs requests for "reactions/create-for-issue"

Create reaction for an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
func (c Client) ReactionsCreateForIssue(ctx context.Context, req *ReactionsCreateForIssueReq, opt ...options.Option) (*ReactionsCreateForIssueResponse, error) {
	return ReactionsCreateForIssue(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForIssueReq is request data for Client.ReactionsCreateForIssue

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
type ReactionsCreateForIssueReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody ReactionsCreateForIssueReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForIssueReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsCreateForIssueReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-issue",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/reactions", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForIssueReq) Rel(link string, resp *ReactionsCreateForIssueResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForIssueReqBody is a request body for reactions/create-for-issue

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
type ReactionsCreateForIssueReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the issue.
	Content *string `json:"content"`
}

/*
ReactionsCreateForIssueResponse is a response for ReactionsCreateForIssue

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
type ReactionsCreateForIssueResponse struct {
	common.Response
	request *ReactionsCreateForIssueReq
	Data    components.Reaction
}

/*
ReactionsCreateForIssueComment performs requests for "reactions/create-for-issue-comment"

Create reaction for an issue comment.

  POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
func ReactionsCreateForIssueComment(ctx context.Context, req *ReactionsCreateForIssueCommentReq, opt ...options.Option) (*ReactionsCreateForIssueCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsCreateForIssueCommentReq)
	}
	resp := &ReactionsCreateForIssueCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForIssueComment performs requests for "reactions/create-for-issue-comment"

Create reaction for an issue comment.

  POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
func (c Client) ReactionsCreateForIssueComment(ctx context.Context, req *ReactionsCreateForIssueCommentReq, opt ...options.Option) (*ReactionsCreateForIssueCommentResponse, error) {
	return ReactionsCreateForIssueComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForIssueCommentReq is request data for Client.ReactionsCreateForIssueComment

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
type ReactionsCreateForIssueCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody ReactionsCreateForIssueCommentReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForIssueCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsCreateForIssueCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{200, 201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-issue-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/comments/%v/reactions", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForIssueCommentReq) Rel(link string, resp *ReactionsCreateForIssueCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForIssueCommentReqBody is a request body for reactions/create-for-issue-comment

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
type ReactionsCreateForIssueCommentReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the issue comment.
	Content *string `json:"content"`
}

/*
ReactionsCreateForIssueCommentResponse is a response for ReactionsCreateForIssueComment

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
type ReactionsCreateForIssueCommentResponse struct {
	common.Response
	request *ReactionsCreateForIssueCommentReq
	Data    components.Reaction
}

/*
ReactionsCreateForPullRequestReviewComment performs requests for "reactions/create-for-pull-request-review-comment"

Create reaction for a pull request review comment.

  POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
func ReactionsCreateForPullRequestReviewComment(ctx context.Context, req *ReactionsCreateForPullRequestReviewCommentReq, opt ...options.Option) (*ReactionsCreateForPullRequestReviewCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsCreateForPullRequestReviewCommentReq)
	}
	resp := &ReactionsCreateForPullRequestReviewCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForPullRequestReviewComment performs requests for "reactions/create-for-pull-request-review-comment"

Create reaction for a pull request review comment.

  POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
func (c Client) ReactionsCreateForPullRequestReviewComment(ctx context.Context, req *ReactionsCreateForPullRequestReviewCommentReq, opt ...options.Option) (*ReactionsCreateForPullRequestReviewCommentResponse, error) {
	return ReactionsCreateForPullRequestReviewComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForPullRequestReviewCommentReq is request data for Client.ReactionsCreateForPullRequestReviewComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
type ReactionsCreateForPullRequestReviewCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody ReactionsCreateForPullRequestReviewCommentReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForPullRequestReviewCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsCreateForPullRequestReviewCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{200, 201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-pull-request-review-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/comments/%v/reactions", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForPullRequestReviewCommentReq) Rel(link string, resp *ReactionsCreateForPullRequestReviewCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForPullRequestReviewCommentReqBody is a request body for reactions/create-for-pull-request-review-comment

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
type ReactionsCreateForPullRequestReviewCommentReqBody struct {

	/*
	The [reaction type](https://developer.github.com/v3/reactions/#reaction-types)
	to add to the pull request review comment.
	*/
	Content *string `json:"content"`
}

/*
ReactionsCreateForPullRequestReviewCommentResponse is a response for ReactionsCreateForPullRequestReviewComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
type ReactionsCreateForPullRequestReviewCommentResponse struct {
	common.Response
	request *ReactionsCreateForPullRequestReviewCommentReq
	Data    components.Reaction
}

/*
ReactionsCreateForTeamDiscussionCommentInOrg performs requests for "reactions/create-for-team-discussion-comment-in-org"

Create reaction for a team discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
func ReactionsCreateForTeamDiscussionCommentInOrg(ctx context.Context, req *ReactionsCreateForTeamDiscussionCommentInOrgReq, opt ...options.Option) (*ReactionsCreateForTeamDiscussionCommentInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsCreateForTeamDiscussionCommentInOrgReq)
	}
	resp := &ReactionsCreateForTeamDiscussionCommentInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForTeamDiscussionCommentInOrg performs requests for "reactions/create-for-team-discussion-comment-in-org"

Create reaction for a team discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
func (c Client) ReactionsCreateForTeamDiscussionCommentInOrg(ctx context.Context, req *ReactionsCreateForTeamDiscussionCommentInOrgReq, opt ...options.Option) (*ReactionsCreateForTeamDiscussionCommentInOrgResponse, error) {
	return ReactionsCreateForTeamDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForTeamDiscussionCommentInOrgReq is request data for Client.ReactionsCreateForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
type ReactionsCreateForTeamDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      ReactionsCreateForTeamDiscussionCommentInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-team-discussion-comment-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForTeamDiscussionCommentInOrgReq) Rel(link string, resp *ReactionsCreateForTeamDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForTeamDiscussionCommentInOrgReqBody is a request body for reactions/create-for-team-discussion-comment-in-org

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
type ReactionsCreateForTeamDiscussionCommentInOrgReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the team discussion comment.
	Content *string `json:"content"`
}

/*
ReactionsCreateForTeamDiscussionCommentInOrgResponse is a response for ReactionsCreateForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
type ReactionsCreateForTeamDiscussionCommentInOrgResponse struct {
	common.Response
	request *ReactionsCreateForTeamDiscussionCommentInOrgReq
	Data    components.Reaction
}

/*
ReactionsCreateForTeamDiscussionCommentLegacy performs requests for "reactions/create-for-team-discussion-comment-legacy"

Create reaction for a team discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
func ReactionsCreateForTeamDiscussionCommentLegacy(ctx context.Context, req *ReactionsCreateForTeamDiscussionCommentLegacyReq, opt ...options.Option) (*ReactionsCreateForTeamDiscussionCommentLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsCreateForTeamDiscussionCommentLegacyReq)
	}
	resp := &ReactionsCreateForTeamDiscussionCommentLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForTeamDiscussionCommentLegacy performs requests for "reactions/create-for-team-discussion-comment-legacy"

Create reaction for a team discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
func (c Client) ReactionsCreateForTeamDiscussionCommentLegacy(ctx context.Context, req *ReactionsCreateForTeamDiscussionCommentLegacyReq, opt ...options.Option) (*ReactionsCreateForTeamDiscussionCommentLegacyResponse, error) {
	return ReactionsCreateForTeamDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForTeamDiscussionCommentLegacyReq is request data for Client.ReactionsCreateForTeamDiscussionCommentLegacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
type ReactionsCreateForTeamDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      ReactionsCreateForTeamDiscussionCommentLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForTeamDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsCreateForTeamDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-team-discussion-comment-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments/%v/reactions", r.TeamId, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForTeamDiscussionCommentLegacyReq) Rel(link string, resp *ReactionsCreateForTeamDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForTeamDiscussionCommentLegacyReqBody is a request body for reactions/create-for-team-discussion-comment-legacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
type ReactionsCreateForTeamDiscussionCommentLegacyReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the team discussion comment.
	Content *string `json:"content"`
}

/*
ReactionsCreateForTeamDiscussionCommentLegacyResponse is a response for ReactionsCreateForTeamDiscussionCommentLegacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
type ReactionsCreateForTeamDiscussionCommentLegacyResponse struct {
	common.Response
	request *ReactionsCreateForTeamDiscussionCommentLegacyReq
	Data    components.Reaction
}

/*
ReactionsCreateForTeamDiscussionInOrg performs requests for "reactions/create-for-team-discussion-in-org"

Create reaction for a team discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
func ReactionsCreateForTeamDiscussionInOrg(ctx context.Context, req *ReactionsCreateForTeamDiscussionInOrgReq, opt ...options.Option) (*ReactionsCreateForTeamDiscussionInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsCreateForTeamDiscussionInOrgReq)
	}
	resp := &ReactionsCreateForTeamDiscussionInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForTeamDiscussionInOrg performs requests for "reactions/create-for-team-discussion-in-org"

Create reaction for a team discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
func (c Client) ReactionsCreateForTeamDiscussionInOrg(ctx context.Context, req *ReactionsCreateForTeamDiscussionInOrgReq, opt ...options.Option) (*ReactionsCreateForTeamDiscussionInOrgResponse, error) {
	return ReactionsCreateForTeamDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForTeamDiscussionInOrgReq is request data for Client.ReactionsCreateForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
type ReactionsCreateForTeamDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      ReactionsCreateForTeamDiscussionInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForTeamDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsCreateForTeamDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-team-discussion-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForTeamDiscussionInOrgReq) Rel(link string, resp *ReactionsCreateForTeamDiscussionInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForTeamDiscussionInOrgReqBody is a request body for reactions/create-for-team-discussion-in-org

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
type ReactionsCreateForTeamDiscussionInOrgReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the team discussion.
	Content *string `json:"content"`
}

/*
ReactionsCreateForTeamDiscussionInOrgResponse is a response for ReactionsCreateForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
type ReactionsCreateForTeamDiscussionInOrgResponse struct {
	common.Response
	request *ReactionsCreateForTeamDiscussionInOrgReq
	Data    components.Reaction
}

/*
ReactionsCreateForTeamDiscussionLegacy performs requests for "reactions/create-for-team-discussion-legacy"

Create reaction for a team discussion (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
func ReactionsCreateForTeamDiscussionLegacy(ctx context.Context, req *ReactionsCreateForTeamDiscussionLegacyReq, opt ...options.Option) (*ReactionsCreateForTeamDiscussionLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsCreateForTeamDiscussionLegacyReq)
	}
	resp := &ReactionsCreateForTeamDiscussionLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsCreateForTeamDiscussionLegacy performs requests for "reactions/create-for-team-discussion-legacy"

Create reaction for a team discussion (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
func (c Client) ReactionsCreateForTeamDiscussionLegacy(ctx context.Context, req *ReactionsCreateForTeamDiscussionLegacyReq, opt ...options.Option) (*ReactionsCreateForTeamDiscussionLegacyResponse, error) {
	return ReactionsCreateForTeamDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
ReactionsCreateForTeamDiscussionLegacyReq is request data for Client.ReactionsCreateForTeamDiscussionLegacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
type ReactionsCreateForTeamDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	RequestBody      ReactionsCreateForTeamDiscussionLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsCreateForTeamDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsCreateForTeamDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-team-discussion-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/reactions", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsCreateForTeamDiscussionLegacyReq) Rel(link string, resp *ReactionsCreateForTeamDiscussionLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsCreateForTeamDiscussionLegacyReqBody is a request body for reactions/create-for-team-discussion-legacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
type ReactionsCreateForTeamDiscussionLegacyReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the team discussion.
	Content *string `json:"content"`
}

/*
ReactionsCreateForTeamDiscussionLegacyResponse is a response for ReactionsCreateForTeamDiscussionLegacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
type ReactionsCreateForTeamDiscussionLegacyResponse struct {
	common.Response
	request *ReactionsCreateForTeamDiscussionLegacyReq
	Data    components.Reaction
}

/*
ReactionsDeleteForCommitComment performs requests for "reactions/delete-for-commit-comment"

Delete a commit comment reaction.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
func ReactionsDeleteForCommitComment(ctx context.Context, req *ReactionsDeleteForCommitCommentReq, opt ...options.Option) (*ReactionsDeleteForCommitCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsDeleteForCommitCommentReq)
	}
	resp := &ReactionsDeleteForCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForCommitComment performs requests for "reactions/delete-for-commit-comment"

Delete a commit comment reaction.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
func (c Client) ReactionsDeleteForCommitComment(ctx context.Context, req *ReactionsDeleteForCommitCommentReq, opt ...options.Option) (*ReactionsDeleteForCommitCommentResponse, error) {
	return ReactionsDeleteForCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteForCommitCommentReq is request data for Client.ReactionsDeleteForCommitComment

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
type ReactionsDeleteForCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId  int64
	ReactionId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteForCommitCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsDeleteForCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "reactions/delete-for-commit-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/comments/%v/reactions/%v", r.Owner, r.Repo, r.CommentId, r.ReactionId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForCommitCommentReq) Rel(link string, resp *ReactionsDeleteForCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForCommitCommentResponse is a response for ReactionsDeleteForCommitComment

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
type ReactionsDeleteForCommitCommentResponse struct {
	common.Response
	request *ReactionsDeleteForCommitCommentReq
}

/*
ReactionsDeleteForIssue performs requests for "reactions/delete-for-issue"

Delete an issue reaction.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
func ReactionsDeleteForIssue(ctx context.Context, req *ReactionsDeleteForIssueReq, opt ...options.Option) (*ReactionsDeleteForIssueResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsDeleteForIssueReq)
	}
	resp := &ReactionsDeleteForIssueResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForIssue performs requests for "reactions/delete-for-issue"

Delete an issue reaction.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
func (c Client) ReactionsDeleteForIssue(ctx context.Context, req *ReactionsDeleteForIssueReq, opt ...options.Option) (*ReactionsDeleteForIssueResponse, error) {
	return ReactionsDeleteForIssue(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteForIssueReq is request data for Client.ReactionsDeleteForIssue

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
type ReactionsDeleteForIssueReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	ReactionId  int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteForIssueReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsDeleteForIssueReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "reactions/delete-for-issue",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/reactions/%v", r.Owner, r.Repo, r.IssueNumber, r.ReactionId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForIssueReq) Rel(link string, resp *ReactionsDeleteForIssueResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForIssueResponse is a response for ReactionsDeleteForIssue

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
type ReactionsDeleteForIssueResponse struct {
	common.Response
	request *ReactionsDeleteForIssueReq
}

/*
ReactionsDeleteForIssueComment performs requests for "reactions/delete-for-issue-comment"

Delete an issue comment reaction.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
func ReactionsDeleteForIssueComment(ctx context.Context, req *ReactionsDeleteForIssueCommentReq, opt ...options.Option) (*ReactionsDeleteForIssueCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsDeleteForIssueCommentReq)
	}
	resp := &ReactionsDeleteForIssueCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForIssueComment performs requests for "reactions/delete-for-issue-comment"

Delete an issue comment reaction.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
func (c Client) ReactionsDeleteForIssueComment(ctx context.Context, req *ReactionsDeleteForIssueCommentReq, opt ...options.Option) (*ReactionsDeleteForIssueCommentResponse, error) {
	return ReactionsDeleteForIssueComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteForIssueCommentReq is request data for Client.ReactionsDeleteForIssueComment

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
type ReactionsDeleteForIssueCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId  int64
	ReactionId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteForIssueCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsDeleteForIssueCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "reactions/delete-for-issue-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/comments/%v/reactions/%v", r.Owner, r.Repo, r.CommentId, r.ReactionId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForIssueCommentReq) Rel(link string, resp *ReactionsDeleteForIssueCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForIssueCommentResponse is a response for ReactionsDeleteForIssueComment

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
type ReactionsDeleteForIssueCommentResponse struct {
	common.Response
	request *ReactionsDeleteForIssueCommentReq
}

/*
ReactionsDeleteForPullRequestComment performs requests for "reactions/delete-for-pull-request-comment"

Delete a pull request comment reaction.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
func ReactionsDeleteForPullRequestComment(ctx context.Context, req *ReactionsDeleteForPullRequestCommentReq, opt ...options.Option) (*ReactionsDeleteForPullRequestCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsDeleteForPullRequestCommentReq)
	}
	resp := &ReactionsDeleteForPullRequestCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForPullRequestComment performs requests for "reactions/delete-for-pull-request-comment"

Delete a pull request comment reaction.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
func (c Client) ReactionsDeleteForPullRequestComment(ctx context.Context, req *ReactionsDeleteForPullRequestCommentReq, opt ...options.Option) (*ReactionsDeleteForPullRequestCommentResponse, error) {
	return ReactionsDeleteForPullRequestComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteForPullRequestCommentReq is request data for Client.ReactionsDeleteForPullRequestComment

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
type ReactionsDeleteForPullRequestCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId  int64
	ReactionId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteForPullRequestCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsDeleteForPullRequestCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "reactions/delete-for-pull-request-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/comments/%v/reactions/%v", r.Owner, r.Repo, r.CommentId, r.ReactionId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForPullRequestCommentReq) Rel(link string, resp *ReactionsDeleteForPullRequestCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForPullRequestCommentResponse is a response for ReactionsDeleteForPullRequestComment

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
type ReactionsDeleteForPullRequestCommentResponse struct {
	common.Response
	request *ReactionsDeleteForPullRequestCommentReq
}

/*
ReactionsDeleteForTeamDiscussion performs requests for "reactions/delete-for-team-discussion"

Delete team discussion reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
func ReactionsDeleteForTeamDiscussion(ctx context.Context, req *ReactionsDeleteForTeamDiscussionReq, opt ...options.Option) (*ReactionsDeleteForTeamDiscussionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsDeleteForTeamDiscussionReq)
	}
	resp := &ReactionsDeleteForTeamDiscussionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForTeamDiscussion performs requests for "reactions/delete-for-team-discussion"

Delete team discussion reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
func (c Client) ReactionsDeleteForTeamDiscussion(ctx context.Context, req *ReactionsDeleteForTeamDiscussionReq, opt ...options.Option) (*ReactionsDeleteForTeamDiscussionResponse, error) {
	return ReactionsDeleteForTeamDiscussion(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteForTeamDiscussionReq is request data for Client.ReactionsDeleteForTeamDiscussion

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
type ReactionsDeleteForTeamDiscussionReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	ReactionId       int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteForTeamDiscussionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsDeleteForTeamDiscussionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "reactions/delete-for-team-discussion",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/reactions/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.ReactionId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForTeamDiscussionReq) Rel(link string, resp *ReactionsDeleteForTeamDiscussionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForTeamDiscussionResponse is a response for ReactionsDeleteForTeamDiscussion

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
type ReactionsDeleteForTeamDiscussionResponse struct {
	common.Response
	request *ReactionsDeleteForTeamDiscussionReq
}

/*
ReactionsDeleteForTeamDiscussionComment performs requests for "reactions/delete-for-team-discussion-comment"

Delete team discussion comment reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
func ReactionsDeleteForTeamDiscussionComment(ctx context.Context, req *ReactionsDeleteForTeamDiscussionCommentReq, opt ...options.Option) (*ReactionsDeleteForTeamDiscussionCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsDeleteForTeamDiscussionCommentReq)
	}
	resp := &ReactionsDeleteForTeamDiscussionCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteForTeamDiscussionComment performs requests for "reactions/delete-for-team-discussion-comment"

Delete team discussion comment reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
func (c Client) ReactionsDeleteForTeamDiscussionComment(ctx context.Context, req *ReactionsDeleteForTeamDiscussionCommentReq, opt ...options.Option) (*ReactionsDeleteForTeamDiscussionCommentResponse, error) {
	return ReactionsDeleteForTeamDiscussionComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteForTeamDiscussionCommentReq is request data for Client.ReactionsDeleteForTeamDiscussionComment

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
type ReactionsDeleteForTeamDiscussionCommentReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	ReactionId       int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteForTeamDiscussionCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsDeleteForTeamDiscussionCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "reactions/delete-for-team-discussion-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v/reactions/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber, r.ReactionId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteForTeamDiscussionCommentReq) Rel(link string, resp *ReactionsDeleteForTeamDiscussionCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteForTeamDiscussionCommentResponse is a response for ReactionsDeleteForTeamDiscussionComment

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
type ReactionsDeleteForTeamDiscussionCommentResponse struct {
	common.Response
	request *ReactionsDeleteForTeamDiscussionCommentReq
}

/*
ReactionsDeleteLegacy performs requests for "reactions/delete-legacy"

Delete a reaction (Legacy).

  DELETE /reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-reaction-legacy
*/
func ReactionsDeleteLegacy(ctx context.Context, req *ReactionsDeleteLegacyReq, opt ...options.Option) (*ReactionsDeleteLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsDeleteLegacyReq)
	}
	resp := &ReactionsDeleteLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsDeleteLegacy performs requests for "reactions/delete-legacy"

Delete a reaction (Legacy).

  DELETE /reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-reaction-legacy
*/
func (c Client) ReactionsDeleteLegacy(ctx context.Context, req *ReactionsDeleteLegacyReq, opt ...options.Option) (*ReactionsDeleteLegacyResponse, error) {
	return ReactionsDeleteLegacy(ctx, req, append(c, opt...)...)
}

/*
ReactionsDeleteLegacyReq is request data for Client.ReactionsDeleteLegacy

https://developer.github.com/v3/reactions/#delete-a-reaction-legacy
*/
type ReactionsDeleteLegacyReq struct {
	_url       string
	ReactionId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsDeleteLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsDeleteLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "reactions/delete-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/reactions/%v", r.ReactionId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsDeleteLegacyReq) Rel(link string, resp *ReactionsDeleteLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsDeleteLegacyResponse is a response for ReactionsDeleteLegacy

https://developer.github.com/v3/reactions/#delete-a-reaction-legacy
*/
type ReactionsDeleteLegacyResponse struct {
	common.Response
	request *ReactionsDeleteLegacyReq
}

/*
ReactionsListForCommitComment performs requests for "reactions/list-for-commit-comment"

List reactions for a commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
func ReactionsListForCommitComment(ctx context.Context, req *ReactionsListForCommitCommentReq, opt ...options.Option) (*ReactionsListForCommitCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsListForCommitCommentReq)
	}
	resp := &ReactionsListForCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForCommitComment performs requests for "reactions/list-for-commit-comment"

List reactions for a commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
func (c Client) ReactionsListForCommitComment(ctx context.Context, req *ReactionsListForCommitCommentReq, opt ...options.Option) (*ReactionsListForCommitCommentResponse, error) {
	return ReactionsListForCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForCommitCommentReq is request data for Client.ReactionsListForCommitComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
type ReactionsListForCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a commit comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForCommitCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsListForCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "reactions/list-for-commit-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/comments/%v/reactions", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForCommitCommentReq) Rel(link string, resp *ReactionsListForCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForCommitCommentResponse is a response for ReactionsListForCommitComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
type ReactionsListForCommitCommentResponse struct {
	common.Response
	request *ReactionsListForCommitCommentReq
	Data    []components.Reaction
}

/*
ReactionsListForIssue performs requests for "reactions/list-for-issue"

List reactions for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
func ReactionsListForIssue(ctx context.Context, req *ReactionsListForIssueReq, opt ...options.Option) (*ReactionsListForIssueResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsListForIssueReq)
	}
	resp := &ReactionsListForIssueResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForIssue performs requests for "reactions/list-for-issue"

List reactions for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
func (c Client) ReactionsListForIssue(ctx context.Context, req *ReactionsListForIssueReq, opt ...options.Option) (*ReactionsListForIssueResponse, error) {
	return ReactionsListForIssue(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForIssueReq is request data for Client.ReactionsListForIssue

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
type ReactionsListForIssueReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to an issue.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForIssueReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsListForIssueReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "reactions/list-for-issue",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/reactions", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForIssueReq) Rel(link string, resp *ReactionsListForIssueResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForIssueResponse is a response for ReactionsListForIssue

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
type ReactionsListForIssueResponse struct {
	common.Response
	request *ReactionsListForIssueReq
	Data    []components.Reaction
}

/*
ReactionsListForIssueComment performs requests for "reactions/list-for-issue-comment"

List reactions for an issue comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
func ReactionsListForIssueComment(ctx context.Context, req *ReactionsListForIssueCommentReq, opt ...options.Option) (*ReactionsListForIssueCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsListForIssueCommentReq)
	}
	resp := &ReactionsListForIssueCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForIssueComment performs requests for "reactions/list-for-issue-comment"

List reactions for an issue comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
func (c Client) ReactionsListForIssueComment(ctx context.Context, req *ReactionsListForIssueCommentReq, opt ...options.Option) (*ReactionsListForIssueCommentResponse, error) {
	return ReactionsListForIssueComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForIssueCommentReq is request data for Client.ReactionsListForIssueComment

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
type ReactionsListForIssueCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to an issue comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForIssueCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsListForIssueCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "reactions/list-for-issue-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/comments/%v/reactions", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForIssueCommentReq) Rel(link string, resp *ReactionsListForIssueCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForIssueCommentResponse is a response for ReactionsListForIssueComment

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
type ReactionsListForIssueCommentResponse struct {
	common.Response
	request *ReactionsListForIssueCommentReq
	Data    []components.Reaction
}

/*
ReactionsListForPullRequestReviewComment performs requests for "reactions/list-for-pull-request-review-comment"

List reactions for a pull request review comment.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
func ReactionsListForPullRequestReviewComment(ctx context.Context, req *ReactionsListForPullRequestReviewCommentReq, opt ...options.Option) (*ReactionsListForPullRequestReviewCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsListForPullRequestReviewCommentReq)
	}
	resp := &ReactionsListForPullRequestReviewCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForPullRequestReviewComment performs requests for "reactions/list-for-pull-request-review-comment"

List reactions for a pull request review comment.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
func (c Client) ReactionsListForPullRequestReviewComment(ctx context.Context, req *ReactionsListForPullRequestReviewCommentReq, opt ...options.Option) (*ReactionsListForPullRequestReviewCommentResponse, error) {
	return ReactionsListForPullRequestReviewComment(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForPullRequestReviewCommentReq is request data for Client.ReactionsListForPullRequestReviewComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
type ReactionsListForPullRequestReviewCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a pull request review comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForPullRequestReviewCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsListForPullRequestReviewCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "reactions/list-for-pull-request-review-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/comments/%v/reactions", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForPullRequestReviewCommentReq) Rel(link string, resp *ReactionsListForPullRequestReviewCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForPullRequestReviewCommentResponse is a response for ReactionsListForPullRequestReviewComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
type ReactionsListForPullRequestReviewCommentResponse struct {
	common.Response
	request *ReactionsListForPullRequestReviewCommentReq
	Data    []components.Reaction
}

/*
ReactionsListForTeamDiscussionCommentInOrg performs requests for "reactions/list-for-team-discussion-comment-in-org"

List reactions for a team discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
func ReactionsListForTeamDiscussionCommentInOrg(ctx context.Context, req *ReactionsListForTeamDiscussionCommentInOrgReq, opt ...options.Option) (*ReactionsListForTeamDiscussionCommentInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsListForTeamDiscussionCommentInOrgReq)
	}
	resp := &ReactionsListForTeamDiscussionCommentInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForTeamDiscussionCommentInOrg performs requests for "reactions/list-for-team-discussion-comment-in-org"

List reactions for a team discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
func (c Client) ReactionsListForTeamDiscussionCommentInOrg(ctx context.Context, req *ReactionsListForTeamDiscussionCommentInOrgReq, opt ...options.Option) (*ReactionsListForTeamDiscussionCommentInOrgResponse, error) {
	return ReactionsListForTeamDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForTeamDiscussionCommentInOrgReq is request data for Client.ReactionsListForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
type ReactionsListForTeamDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForTeamDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsListForTeamDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "reactions/list-for-team-discussion-comment-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForTeamDiscussionCommentInOrgReq) Rel(link string, resp *ReactionsListForTeamDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForTeamDiscussionCommentInOrgResponse is a response for ReactionsListForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
type ReactionsListForTeamDiscussionCommentInOrgResponse struct {
	common.Response
	request *ReactionsListForTeamDiscussionCommentInOrgReq
	Data    []components.Reaction
}

/*
ReactionsListForTeamDiscussionCommentLegacy performs requests for "reactions/list-for-team-discussion-comment-legacy"

List reactions for a team discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment-legacy
*/
func ReactionsListForTeamDiscussionCommentLegacy(ctx context.Context, req *ReactionsListForTeamDiscussionCommentLegacyReq, opt ...options.Option) (*ReactionsListForTeamDiscussionCommentLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsListForTeamDiscussionCommentLegacyReq)
	}
	resp := &ReactionsListForTeamDiscussionCommentLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForTeamDiscussionCommentLegacy performs requests for "reactions/list-for-team-discussion-comment-legacy"

List reactions for a team discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment-legacy
*/
func (c Client) ReactionsListForTeamDiscussionCommentLegacy(ctx context.Context, req *ReactionsListForTeamDiscussionCommentLegacyReq, opt ...options.Option) (*ReactionsListForTeamDiscussionCommentLegacyResponse, error) {
	return ReactionsListForTeamDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForTeamDiscussionCommentLegacyReq is request data for Client.ReactionsListForTeamDiscussionCommentLegacy

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment-legacy
*/
type ReactionsListForTeamDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForTeamDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsListForTeamDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "reactions/list-for-team-discussion-comment-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments/%v/reactions", r.TeamId, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForTeamDiscussionCommentLegacyReq) Rel(link string, resp *ReactionsListForTeamDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForTeamDiscussionCommentLegacyResponse is a response for ReactionsListForTeamDiscussionCommentLegacy

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment-legacy
*/
type ReactionsListForTeamDiscussionCommentLegacyResponse struct {
	common.Response
	request *ReactionsListForTeamDiscussionCommentLegacyReq
	Data    []components.Reaction
}

/*
ReactionsListForTeamDiscussionInOrg performs requests for "reactions/list-for-team-discussion-in-org"

List reactions for a team discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
func ReactionsListForTeamDiscussionInOrg(ctx context.Context, req *ReactionsListForTeamDiscussionInOrgReq, opt ...options.Option) (*ReactionsListForTeamDiscussionInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsListForTeamDiscussionInOrgReq)
	}
	resp := &ReactionsListForTeamDiscussionInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForTeamDiscussionInOrg performs requests for "reactions/list-for-team-discussion-in-org"

List reactions for a team discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
func (c Client) ReactionsListForTeamDiscussionInOrg(ctx context.Context, req *ReactionsListForTeamDiscussionInOrgReq, opt ...options.Option) (*ReactionsListForTeamDiscussionInOrgResponse, error) {
	return ReactionsListForTeamDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForTeamDiscussionInOrgReq is request data for Client.ReactionsListForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
type ReactionsListForTeamDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForTeamDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsListForTeamDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "reactions/list-for-team-discussion-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForTeamDiscussionInOrgReq) Rel(link string, resp *ReactionsListForTeamDiscussionInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForTeamDiscussionInOrgResponse is a response for ReactionsListForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
type ReactionsListForTeamDiscussionInOrgResponse struct {
	common.Response
	request *ReactionsListForTeamDiscussionInOrgReq
	Data    []components.Reaction
}

/*
ReactionsListForTeamDiscussionLegacy performs requests for "reactions/list-for-team-discussion-legacy"

List reactions for a team discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-legacy
*/
func ReactionsListForTeamDiscussionLegacy(ctx context.Context, req *ReactionsListForTeamDiscussionLegacyReq, opt ...options.Option) (*ReactionsListForTeamDiscussionLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReactionsListForTeamDiscussionLegacyReq)
	}
	resp := &ReactionsListForTeamDiscussionLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReactionsListForTeamDiscussionLegacy performs requests for "reactions/list-for-team-discussion-legacy"

List reactions for a team discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-legacy
*/
func (c Client) ReactionsListForTeamDiscussionLegacy(ctx context.Context, req *ReactionsListForTeamDiscussionLegacyReq, opt ...options.Option) (*ReactionsListForTeamDiscussionLegacyResponse, error) {
	return ReactionsListForTeamDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
ReactionsListForTeamDiscussionLegacyReq is request data for Client.ReactionsListForTeamDiscussionLegacy

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-legacy
*/
type ReactionsListForTeamDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReactionsListForTeamDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReactionsListForTeamDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "reactions/list-for-team-discussion-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/reactions", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReactionsListForTeamDiscussionLegacyReq) Rel(link string, resp *ReactionsListForTeamDiscussionLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReactionsListForTeamDiscussionLegacyResponse is a response for ReactionsListForTeamDiscussionLegacy

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-legacy
*/
type ReactionsListForTeamDiscussionLegacyResponse struct {
	common.Response
	request *ReactionsListForTeamDiscussionLegacyReq
	Data    []components.Reaction
}
