// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
ActivityCheckRepoIsStarredByAuthenticatedUser performs requests for "activity/check-repo-is-starred-by-authenticated-user"

Check if a repository is starred by the authenticated user.

  GET /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
func ActivityCheckRepoIsStarredByAuthenticatedUser(ctx context.Context, req *ActivityCheckRepoIsStarredByAuthenticatedUserReq, opt ...options.Option) (*ActivityCheckRepoIsStarredByAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityCheckRepoIsStarredByAuthenticatedUserReq)
	}
	resp := &ActivityCheckRepoIsStarredByAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityCheckRepoIsStarredByAuthenticatedUser performs requests for "activity/check-repo-is-starred-by-authenticated-user"

Check if a repository is starred by the authenticated user.

  GET /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
func (c Client) ActivityCheckRepoIsStarredByAuthenticatedUser(ctx context.Context, req *ActivityCheckRepoIsStarredByAuthenticatedUserReq, opt ...options.Option) (*ActivityCheckRepoIsStarredByAuthenticatedUserResponse, error) {
	return ActivityCheckRepoIsStarredByAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ActivityCheckRepoIsStarredByAuthenticatedUserReq is request data for Client.ActivityCheckRepoIsStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
type ActivityCheckRepoIsStarredByAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "activity/check-repo-is-starred-by-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) Rel(link RelName, resp *ActivityCheckRepoIsStarredByAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityCheckRepoIsStarredByAuthenticatedUserResponse is a response for ActivityCheckRepoIsStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
type ActivityCheckRepoIsStarredByAuthenticatedUserResponse struct {
	common.Response
	request *ActivityCheckRepoIsStarredByAuthenticatedUserReq
}

/*
ActivityDeleteRepoSubscription performs requests for "activity/delete-repo-subscription"

Delete a repository subscription.

  DELETE /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
func ActivityDeleteRepoSubscription(ctx context.Context, req *ActivityDeleteRepoSubscriptionReq, opt ...options.Option) (*ActivityDeleteRepoSubscriptionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityDeleteRepoSubscriptionReq)
	}
	resp := &ActivityDeleteRepoSubscriptionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityDeleteRepoSubscription performs requests for "activity/delete-repo-subscription"

Delete a repository subscription.

  DELETE /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
func (c Client) ActivityDeleteRepoSubscription(ctx context.Context, req *ActivityDeleteRepoSubscriptionReq, opt ...options.Option) (*ActivityDeleteRepoSubscriptionResponse, error) {
	return ActivityDeleteRepoSubscription(ctx, req, append(c, opt...)...)
}

/*
ActivityDeleteRepoSubscriptionReq is request data for Client.ActivityDeleteRepoSubscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
type ActivityDeleteRepoSubscriptionReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ActivityDeleteRepoSubscriptionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityDeleteRepoSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "activity/delete-repo-subscription",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityDeleteRepoSubscriptionReq) Rel(link RelName, resp *ActivityDeleteRepoSubscriptionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityDeleteRepoSubscriptionResponse is a response for ActivityDeleteRepoSubscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
type ActivityDeleteRepoSubscriptionResponse struct {
	common.Response
	request *ActivityDeleteRepoSubscriptionReq
}

/*
ActivityDeleteThreadSubscription performs requests for "activity/delete-thread-subscription"

Delete a thread subscription.

  DELETE /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
func ActivityDeleteThreadSubscription(ctx context.Context, req *ActivityDeleteThreadSubscriptionReq, opt ...options.Option) (*ActivityDeleteThreadSubscriptionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityDeleteThreadSubscriptionReq)
	}
	resp := &ActivityDeleteThreadSubscriptionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityDeleteThreadSubscription performs requests for "activity/delete-thread-subscription"

Delete a thread subscription.

  DELETE /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
func (c Client) ActivityDeleteThreadSubscription(ctx context.Context, req *ActivityDeleteThreadSubscriptionReq, opt ...options.Option) (*ActivityDeleteThreadSubscriptionResponse, error) {
	return ActivityDeleteThreadSubscription(ctx, req, append(c, opt...)...)
}

/*
ActivityDeleteThreadSubscriptionReq is request data for Client.ActivityDeleteThreadSubscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
type ActivityDeleteThreadSubscriptionReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityDeleteThreadSubscriptionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityDeleteThreadSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "activity/delete-thread-subscription",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityDeleteThreadSubscriptionReq) Rel(link RelName, resp *ActivityDeleteThreadSubscriptionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityDeleteThreadSubscriptionResponse is a response for ActivityDeleteThreadSubscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
type ActivityDeleteThreadSubscriptionResponse struct {
	common.Response
	request *ActivityDeleteThreadSubscriptionReq
}

/*
ActivityGetFeeds performs requests for "activity/get-feeds"

Get feeds.

  GET /feeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
func ActivityGetFeeds(ctx context.Context, req *ActivityGetFeedsReq, opt ...options.Option) (*ActivityGetFeedsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityGetFeedsReq)
	}
	resp := &ActivityGetFeedsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Feed{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityGetFeeds performs requests for "activity/get-feeds"

Get feeds.

  GET /feeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
func (c Client) ActivityGetFeeds(ctx context.Context, req *ActivityGetFeedsReq, opt ...options.Option) (*ActivityGetFeedsResponse, error) {
	return ActivityGetFeeds(ctx, req, append(c, opt...)...)
}

/*
ActivityGetFeedsReq is request data for Client.ActivityGetFeeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
type ActivityGetFeedsReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *ActivityGetFeedsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityGetFeedsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/get-feeds",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/feeds"),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityGetFeedsReq) Rel(link RelName, resp *ActivityGetFeedsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityGetFeedsResponse is a response for ActivityGetFeeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
type ActivityGetFeedsResponse struct {
	common.Response
	request *ActivityGetFeedsReq
	Data    components.Feed
}

/*
ActivityGetRepoSubscription performs requests for "activity/get-repo-subscription"

Get a repository subscription.

  GET /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
func ActivityGetRepoSubscription(ctx context.Context, req *ActivityGetRepoSubscriptionReq, opt ...options.Option) (*ActivityGetRepoSubscriptionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityGetRepoSubscriptionReq)
	}
	resp := &ActivityGetRepoSubscriptionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.RepositorySubscription{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityGetRepoSubscription performs requests for "activity/get-repo-subscription"

Get a repository subscription.

  GET /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
func (c Client) ActivityGetRepoSubscription(ctx context.Context, req *ActivityGetRepoSubscriptionReq, opt ...options.Option) (*ActivityGetRepoSubscriptionResponse, error) {
	return ActivityGetRepoSubscription(ctx, req, append(c, opt...)...)
}

/*
ActivityGetRepoSubscriptionReq is request data for Client.ActivityGetRepoSubscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
type ActivityGetRepoSubscriptionReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ActivityGetRepoSubscriptionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityGetRepoSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/get-repo-subscription",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityGetRepoSubscriptionReq) Rel(link RelName, resp *ActivityGetRepoSubscriptionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityGetRepoSubscriptionResponse is a response for ActivityGetRepoSubscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
type ActivityGetRepoSubscriptionResponse struct {
	common.Response
	request *ActivityGetRepoSubscriptionReq
	Data    components.RepositorySubscription
}

/*
ActivityGetThread performs requests for "activity/get-thread"

Get a thread.

  GET /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
func ActivityGetThread(ctx context.Context, req *ActivityGetThreadReq, opt ...options.Option) (*ActivityGetThreadResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityGetThreadReq)
	}
	resp := &ActivityGetThreadResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Thread{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityGetThread performs requests for "activity/get-thread"

Get a thread.

  GET /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
func (c Client) ActivityGetThread(ctx context.Context, req *ActivityGetThreadReq, opt ...options.Option) (*ActivityGetThreadResponse, error) {
	return ActivityGetThread(ctx, req, append(c, opt...)...)
}

/*
ActivityGetThreadReq is request data for Client.ActivityGetThread

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
type ActivityGetThreadReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityGetThreadReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityGetThreadReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/get-thread",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications/threads/%v", r.ThreadId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityGetThreadReq) Rel(link RelName, resp *ActivityGetThreadResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityGetThreadResponse is a response for ActivityGetThread

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
type ActivityGetThreadResponse struct {
	common.Response
	request *ActivityGetThreadReq
	Data    components.Thread
}

/*
ActivityGetThreadSubscriptionForAuthenticatedUser performs requests for "activity/get-thread-subscription-for-authenticated-user"

Get a thread subscription for the authenticated user.

  GET /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
func ActivityGetThreadSubscriptionForAuthenticatedUser(ctx context.Context, req *ActivityGetThreadSubscriptionForAuthenticatedUserReq, opt ...options.Option) (*ActivityGetThreadSubscriptionForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityGetThreadSubscriptionForAuthenticatedUserReq)
	}
	resp := &ActivityGetThreadSubscriptionForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ThreadSubscription{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityGetThreadSubscriptionForAuthenticatedUser performs requests for "activity/get-thread-subscription-for-authenticated-user"

Get a thread subscription for the authenticated user.

  GET /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
func (c Client) ActivityGetThreadSubscriptionForAuthenticatedUser(ctx context.Context, req *ActivityGetThreadSubscriptionForAuthenticatedUserReq, opt ...options.Option) (*ActivityGetThreadSubscriptionForAuthenticatedUserResponse, error) {
	return ActivityGetThreadSubscriptionForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ActivityGetThreadSubscriptionForAuthenticatedUserReq is request data for Client.ActivityGetThreadSubscriptionForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
type ActivityGetThreadSubscriptionForAuthenticatedUserReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/get-thread-subscription-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) Rel(link RelName, resp *ActivityGetThreadSubscriptionForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityGetThreadSubscriptionForAuthenticatedUserResponse is a response for ActivityGetThreadSubscriptionForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
type ActivityGetThreadSubscriptionForAuthenticatedUserResponse struct {
	common.Response
	request *ActivityGetThreadSubscriptionForAuthenticatedUserReq
	Data    components.ThreadSubscription
}

/*
ActivityListEventsForAuthenticatedUser performs requests for "activity/list-events-for-authenticated-user"

List events for the authenticated user.

  GET /users/{username}/events

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
func ActivityListEventsForAuthenticatedUser(ctx context.Context, req *ActivityListEventsForAuthenticatedUserReq, opt ...options.Option) (*ActivityListEventsForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListEventsForAuthenticatedUserReq)
	}
	resp := &ActivityListEventsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListEventsForAuthenticatedUser performs requests for "activity/list-events-for-authenticated-user"

List events for the authenticated user.

  GET /users/{username}/events

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
func (c Client) ActivityListEventsForAuthenticatedUser(ctx context.Context, req *ActivityListEventsForAuthenticatedUserReq, opt ...options.Option) (*ActivityListEventsForAuthenticatedUserResponse, error) {
	return ActivityListEventsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ActivityListEventsForAuthenticatedUserReq is request data for Client.ActivityListEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
type ActivityListEventsForAuthenticatedUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListEventsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListEventsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-events-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/events", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListEventsForAuthenticatedUserReq) Rel(link RelName, resp *ActivityListEventsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListEventsForAuthenticatedUserResponse is a response for ActivityListEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
type ActivityListEventsForAuthenticatedUserResponse struct {
	common.Response
	request *ActivityListEventsForAuthenticatedUserReq
	Data    []components.Event
}

/*
ActivityListNotificationsForAuthenticatedUser performs requests for "activity/list-notifications-for-authenticated-user"

List notifications for the authenticated user.

  GET /notifications

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
func ActivityListNotificationsForAuthenticatedUser(ctx context.Context, req *ActivityListNotificationsForAuthenticatedUserReq, opt ...options.Option) (*ActivityListNotificationsForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListNotificationsForAuthenticatedUserReq)
	}
	resp := &ActivityListNotificationsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Thread{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListNotificationsForAuthenticatedUser performs requests for "activity/list-notifications-for-authenticated-user"

List notifications for the authenticated user.

  GET /notifications

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
func (c Client) ActivityListNotificationsForAuthenticatedUser(ctx context.Context, req *ActivityListNotificationsForAuthenticatedUserReq, opt ...options.Option) (*ActivityListNotificationsForAuthenticatedUserResponse, error) {
	return ActivityListNotificationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ActivityListNotificationsForAuthenticatedUserReq is request data for Client.ActivityListNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
type ActivityListNotificationsForAuthenticatedUserReq struct {
	_url string

	// If `true`, show notifications marked as read.
	All *bool

	/*
	If `true`, only shows notifications in which the user is directly participating
	or mentioned.
	*/
	Participating *bool

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only show notifications updated before the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Before *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListNotificationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListNotificationsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.All != nil {
		query.Set("all", strconv.FormatBool(*r.All))
	}
	if r.Participating != nil {
		query.Set("participating", strconv.FormatBool(*r.Participating))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Before != nil {
		query.Set("before", *r.Before)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-notifications-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListNotificationsForAuthenticatedUserReq) Rel(link RelName, resp *ActivityListNotificationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListNotificationsForAuthenticatedUserResponse is a response for ActivityListNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
type ActivityListNotificationsForAuthenticatedUserResponse struct {
	common.Response
	request *ActivityListNotificationsForAuthenticatedUserReq
	Data    []components.Thread
}

/*
ActivityListOrgEventsForAuthenticatedUser performs requests for "activity/list-org-events-for-authenticated-user"

List organization events for the authenticated user.

  GET /users/{username}/events/orgs/{org}

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
func ActivityListOrgEventsForAuthenticatedUser(ctx context.Context, req *ActivityListOrgEventsForAuthenticatedUserReq, opt ...options.Option) (*ActivityListOrgEventsForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListOrgEventsForAuthenticatedUserReq)
	}
	resp := &ActivityListOrgEventsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListOrgEventsForAuthenticatedUser performs requests for "activity/list-org-events-for-authenticated-user"

List organization events for the authenticated user.

  GET /users/{username}/events/orgs/{org}

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
func (c Client) ActivityListOrgEventsForAuthenticatedUser(ctx context.Context, req *ActivityListOrgEventsForAuthenticatedUserReq, opt ...options.Option) (*ActivityListOrgEventsForAuthenticatedUserResponse, error) {
	return ActivityListOrgEventsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ActivityListOrgEventsForAuthenticatedUserReq is request data for Client.ActivityListOrgEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
type ActivityListOrgEventsForAuthenticatedUserReq struct {
	_url     string
	Username string
	Org      string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListOrgEventsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListOrgEventsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-org-events-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/events/orgs/%v", r.Username, r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListOrgEventsForAuthenticatedUserReq) Rel(link RelName, resp *ActivityListOrgEventsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListOrgEventsForAuthenticatedUserResponse is a response for ActivityListOrgEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
type ActivityListOrgEventsForAuthenticatedUserResponse struct {
	common.Response
	request *ActivityListOrgEventsForAuthenticatedUserReq
	Data    []components.Event
}

/*
ActivityListPublicEvents performs requests for "activity/list-public-events"

List public events.

  GET /events

https://developer.github.com/v3/activity/events/#list-public-events
*/
func ActivityListPublicEvents(ctx context.Context, req *ActivityListPublicEventsReq, opt ...options.Option) (*ActivityListPublicEventsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListPublicEventsReq)
	}
	resp := &ActivityListPublicEventsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListPublicEvents performs requests for "activity/list-public-events"

List public events.

  GET /events

https://developer.github.com/v3/activity/events/#list-public-events
*/
func (c Client) ActivityListPublicEvents(ctx context.Context, req *ActivityListPublicEventsReq, opt ...options.Option) (*ActivityListPublicEventsResponse, error) {
	return ActivityListPublicEvents(ctx, req, append(c, opt...)...)
}

/*
ActivityListPublicEventsReq is request data for Client.ActivityListPublicEvents

https://developer.github.com/v3/activity/events/#list-public-events
*/
type ActivityListPublicEventsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListPublicEventsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListPublicEventsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-public-events",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/events"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListPublicEventsReq) Rel(link RelName, resp *ActivityListPublicEventsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListPublicEventsResponse is a response for ActivityListPublicEvents

https://developer.github.com/v3/activity/events/#list-public-events
*/
type ActivityListPublicEventsResponse struct {
	common.Response
	request *ActivityListPublicEventsReq
	Data    []components.Event
}

/*
ActivityListPublicEventsForRepoNetwork performs requests for "activity/list-public-events-for-repo-network"

List public events for a network of repositories.

  GET /networks/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
func ActivityListPublicEventsForRepoNetwork(ctx context.Context, req *ActivityListPublicEventsForRepoNetworkReq, opt ...options.Option) (*ActivityListPublicEventsForRepoNetworkResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListPublicEventsForRepoNetworkReq)
	}
	resp := &ActivityListPublicEventsForRepoNetworkResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListPublicEventsForRepoNetwork performs requests for "activity/list-public-events-for-repo-network"

List public events for a network of repositories.

  GET /networks/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
func (c Client) ActivityListPublicEventsForRepoNetwork(ctx context.Context, req *ActivityListPublicEventsForRepoNetworkReq, opt ...options.Option) (*ActivityListPublicEventsForRepoNetworkResponse, error) {
	return ActivityListPublicEventsForRepoNetwork(ctx, req, append(c, opt...)...)
}

/*
ActivityListPublicEventsForRepoNetworkReq is request data for Client.ActivityListPublicEventsForRepoNetwork

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
type ActivityListPublicEventsForRepoNetworkReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListPublicEventsForRepoNetworkReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListPublicEventsForRepoNetworkReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-public-events-for-repo-network",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/networks/%v/%v/events", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 301, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListPublicEventsForRepoNetworkReq) Rel(link RelName, resp *ActivityListPublicEventsForRepoNetworkResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListPublicEventsForRepoNetworkResponse is a response for ActivityListPublicEventsForRepoNetwork

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
type ActivityListPublicEventsForRepoNetworkResponse struct {
	common.Response
	request *ActivityListPublicEventsForRepoNetworkReq
	Data    []components.Event
}

/*
ActivityListPublicEventsForUser performs requests for "activity/list-public-events-for-user"

List public events for a user.

  GET /users/{username}/events/public

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
func ActivityListPublicEventsForUser(ctx context.Context, req *ActivityListPublicEventsForUserReq, opt ...options.Option) (*ActivityListPublicEventsForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListPublicEventsForUserReq)
	}
	resp := &ActivityListPublicEventsForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListPublicEventsForUser performs requests for "activity/list-public-events-for-user"

List public events for a user.

  GET /users/{username}/events/public

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
func (c Client) ActivityListPublicEventsForUser(ctx context.Context, req *ActivityListPublicEventsForUserReq, opt ...options.Option) (*ActivityListPublicEventsForUserResponse, error) {
	return ActivityListPublicEventsForUser(ctx, req, append(c, opt...)...)
}

/*
ActivityListPublicEventsForUserReq is request data for Client.ActivityListPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
type ActivityListPublicEventsForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListPublicEventsForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListPublicEventsForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-public-events-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/events/public", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListPublicEventsForUserReq) Rel(link RelName, resp *ActivityListPublicEventsForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListPublicEventsForUserResponse is a response for ActivityListPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
type ActivityListPublicEventsForUserResponse struct {
	common.Response
	request *ActivityListPublicEventsForUserReq
	Data    []components.Event
}

/*
ActivityListPublicOrgEvents performs requests for "activity/list-public-org-events"

List public organization events.

  GET /orgs/{org}/events

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
func ActivityListPublicOrgEvents(ctx context.Context, req *ActivityListPublicOrgEventsReq, opt ...options.Option) (*ActivityListPublicOrgEventsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListPublicOrgEventsReq)
	}
	resp := &ActivityListPublicOrgEventsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListPublicOrgEvents performs requests for "activity/list-public-org-events"

List public organization events.

  GET /orgs/{org}/events

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
func (c Client) ActivityListPublicOrgEvents(ctx context.Context, req *ActivityListPublicOrgEventsReq, opt ...options.Option) (*ActivityListPublicOrgEventsResponse, error) {
	return ActivityListPublicOrgEvents(ctx, req, append(c, opt...)...)
}

/*
ActivityListPublicOrgEventsReq is request data for Client.ActivityListPublicOrgEvents

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
type ActivityListPublicOrgEventsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListPublicOrgEventsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListPublicOrgEventsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-public-org-events",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/events", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListPublicOrgEventsReq) Rel(link RelName, resp *ActivityListPublicOrgEventsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListPublicOrgEventsResponse is a response for ActivityListPublicOrgEvents

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
type ActivityListPublicOrgEventsResponse struct {
	common.Response
	request *ActivityListPublicOrgEventsReq
	Data    []components.Event
}

/*
ActivityListReceivedEventsForUser performs requests for "activity/list-received-events-for-user"

List events received by the authenticated user.

  GET /users/{username}/received_events

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
func ActivityListReceivedEventsForUser(ctx context.Context, req *ActivityListReceivedEventsForUserReq, opt ...options.Option) (*ActivityListReceivedEventsForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListReceivedEventsForUserReq)
	}
	resp := &ActivityListReceivedEventsForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListReceivedEventsForUser performs requests for "activity/list-received-events-for-user"

List events received by the authenticated user.

  GET /users/{username}/received_events

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
func (c Client) ActivityListReceivedEventsForUser(ctx context.Context, req *ActivityListReceivedEventsForUserReq, opt ...options.Option) (*ActivityListReceivedEventsForUserResponse, error) {
	return ActivityListReceivedEventsForUser(ctx, req, append(c, opt...)...)
}

/*
ActivityListReceivedEventsForUserReq is request data for Client.ActivityListReceivedEventsForUser

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
type ActivityListReceivedEventsForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListReceivedEventsForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListReceivedEventsForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-received-events-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/received_events", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListReceivedEventsForUserReq) Rel(link RelName, resp *ActivityListReceivedEventsForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListReceivedEventsForUserResponse is a response for ActivityListReceivedEventsForUser

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
type ActivityListReceivedEventsForUserResponse struct {
	common.Response
	request *ActivityListReceivedEventsForUserReq
	Data    []components.Event
}

/*
ActivityListReceivedPublicEventsForUser performs requests for "activity/list-received-public-events-for-user"

List public events received by a user.

  GET /users/{username}/received_events/public

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
func ActivityListReceivedPublicEventsForUser(ctx context.Context, req *ActivityListReceivedPublicEventsForUserReq, opt ...options.Option) (*ActivityListReceivedPublicEventsForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListReceivedPublicEventsForUserReq)
	}
	resp := &ActivityListReceivedPublicEventsForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListReceivedPublicEventsForUser performs requests for "activity/list-received-public-events-for-user"

List public events received by a user.

  GET /users/{username}/received_events/public

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
func (c Client) ActivityListReceivedPublicEventsForUser(ctx context.Context, req *ActivityListReceivedPublicEventsForUserReq, opt ...options.Option) (*ActivityListReceivedPublicEventsForUserResponse, error) {
	return ActivityListReceivedPublicEventsForUser(ctx, req, append(c, opt...)...)
}

/*
ActivityListReceivedPublicEventsForUserReq is request data for Client.ActivityListReceivedPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
type ActivityListReceivedPublicEventsForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListReceivedPublicEventsForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListReceivedPublicEventsForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-received-public-events-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/received_events/public", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListReceivedPublicEventsForUserReq) Rel(link RelName, resp *ActivityListReceivedPublicEventsForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListReceivedPublicEventsForUserResponse is a response for ActivityListReceivedPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
type ActivityListReceivedPublicEventsForUserResponse struct {
	common.Response
	request *ActivityListReceivedPublicEventsForUserReq
	Data    []components.Event
}

/*
ActivityListRepoEvents performs requests for "activity/list-repo-events"

List repository events.

  GET /repos/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-repository-events
*/
func ActivityListRepoEvents(ctx context.Context, req *ActivityListRepoEventsReq, opt ...options.Option) (*ActivityListRepoEventsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListRepoEventsReq)
	}
	resp := &ActivityListRepoEventsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListRepoEvents performs requests for "activity/list-repo-events"

List repository events.

  GET /repos/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-repository-events
*/
func (c Client) ActivityListRepoEvents(ctx context.Context, req *ActivityListRepoEventsReq, opt ...options.Option) (*ActivityListRepoEventsResponse, error) {
	return ActivityListRepoEvents(ctx, req, append(c, opt...)...)
}

/*
ActivityListRepoEventsReq is request data for Client.ActivityListRepoEvents

https://developer.github.com/v3/activity/events/#list-repository-events
*/
type ActivityListRepoEventsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListRepoEventsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListRepoEventsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-repo-events",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/events", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListRepoEventsReq) Rel(link RelName, resp *ActivityListRepoEventsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListRepoEventsResponse is a response for ActivityListRepoEvents

https://developer.github.com/v3/activity/events/#list-repository-events
*/
type ActivityListRepoEventsResponse struct {
	common.Response
	request *ActivityListRepoEventsReq
	Data    []components.Event
}

/*
ActivityListRepoNotificationsForAuthenticatedUser performs requests for "activity/list-repo-notifications-for-authenticated-user"

List repository notifications for the authenticated user.

  GET /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
func ActivityListRepoNotificationsForAuthenticatedUser(ctx context.Context, req *ActivityListRepoNotificationsForAuthenticatedUserReq, opt ...options.Option) (*ActivityListRepoNotificationsForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListRepoNotificationsForAuthenticatedUserReq)
	}
	resp := &ActivityListRepoNotificationsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Thread{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListRepoNotificationsForAuthenticatedUser performs requests for "activity/list-repo-notifications-for-authenticated-user"

List repository notifications for the authenticated user.

  GET /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
func (c Client) ActivityListRepoNotificationsForAuthenticatedUser(ctx context.Context, req *ActivityListRepoNotificationsForAuthenticatedUserReq, opt ...options.Option) (*ActivityListRepoNotificationsForAuthenticatedUserResponse, error) {
	return ActivityListRepoNotificationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ActivityListRepoNotificationsForAuthenticatedUserReq is request data for Client.ActivityListRepoNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
type ActivityListRepoNotificationsForAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string

	// If `true`, show notifications marked as read.
	All *bool

	/*
	If `true`, only shows notifications in which the user is directly participating
	or mentioned.
	*/
	Participating *bool

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only show notifications updated before the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Before *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.All != nil {
		query.Set("all", strconv.FormatBool(*r.All))
	}
	if r.Participating != nil {
		query.Set("participating", strconv.FormatBool(*r.Participating))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Before != nil {
		query.Set("before", *r.Before)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-repo-notifications-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/notifications", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) Rel(link RelName, resp *ActivityListRepoNotificationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListRepoNotificationsForAuthenticatedUserResponse is a response for ActivityListRepoNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
type ActivityListRepoNotificationsForAuthenticatedUserResponse struct {
	common.Response
	request *ActivityListRepoNotificationsForAuthenticatedUserReq
	Data    []components.Thread
}

/*
ActivityListReposStarredByAuthenticatedUser performs requests for "activity/list-repos-starred-by-authenticated-user"

List repositories starred by the authenticated user.

  GET /user/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
func ActivityListReposStarredByAuthenticatedUser(ctx context.Context, req *ActivityListReposStarredByAuthenticatedUserReq, opt ...options.Option) (*ActivityListReposStarredByAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListReposStarredByAuthenticatedUserReq)
	}
	resp := &ActivityListReposStarredByAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.StarredRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListReposStarredByAuthenticatedUser performs requests for "activity/list-repos-starred-by-authenticated-user"

List repositories starred by the authenticated user.

  GET /user/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
func (c Client) ActivityListReposStarredByAuthenticatedUser(ctx context.Context, req *ActivityListReposStarredByAuthenticatedUserReq, opt ...options.Option) (*ActivityListReposStarredByAuthenticatedUserResponse, error) {
	return ActivityListReposStarredByAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ActivityListReposStarredByAuthenticatedUserReq is request data for Client.ActivityListReposStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
type ActivityListReposStarredByAuthenticatedUserReq struct {
	_url string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListReposStarredByAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListReposStarredByAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/vnd.github.v3.star+json")},
		Method:           "GET",
		OperationID:      "activity/list-repos-starred-by-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/starred"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListReposStarredByAuthenticatedUserReq) Rel(link RelName, resp *ActivityListReposStarredByAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListReposStarredByAuthenticatedUserResponse is a response for ActivityListReposStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
type ActivityListReposStarredByAuthenticatedUserResponse struct {
	common.Response
	request *ActivityListReposStarredByAuthenticatedUserReq
	Data    []components.StarredRepository
}

/*
ActivityListReposStarredByUser performs requests for "activity/list-repos-starred-by-user"

List repositories starred by a user.

  GET /users/{username}/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
func ActivityListReposStarredByUser(ctx context.Context, req *ActivityListReposStarredByUserReq, opt ...options.Option) (*ActivityListReposStarredByUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListReposStarredByUserReq)
	}
	resp := &ActivityListReposStarredByUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.StarredRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListReposStarredByUser performs requests for "activity/list-repos-starred-by-user"

List repositories starred by a user.

  GET /users/{username}/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
func (c Client) ActivityListReposStarredByUser(ctx context.Context, req *ActivityListReposStarredByUserReq, opt ...options.Option) (*ActivityListReposStarredByUserResponse, error) {
	return ActivityListReposStarredByUser(ctx, req, append(c, opt...)...)
}

/*
ActivityListReposStarredByUserReq is request data for Client.ActivityListReposStarredByUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
type ActivityListReposStarredByUserReq struct {
	_url     string
	Username string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListReposStarredByUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListReposStarredByUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/vnd.github.v3.star+json")},
		Method:           "GET",
		OperationID:      "activity/list-repos-starred-by-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/starred", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListReposStarredByUserReq) Rel(link RelName, resp *ActivityListReposStarredByUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListReposStarredByUserResponse is a response for ActivityListReposStarredByUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
type ActivityListReposStarredByUserResponse struct {
	common.Response
	request *ActivityListReposStarredByUserReq
	Data    []components.StarredRepository
}

/*
ActivityListReposWatchedByUser performs requests for "activity/list-repos-watched-by-user"

List repositories watched by a user.

  GET /users/{username}/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
func ActivityListReposWatchedByUser(ctx context.Context, req *ActivityListReposWatchedByUserReq, opt ...options.Option) (*ActivityListReposWatchedByUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListReposWatchedByUserReq)
	}
	resp := &ActivityListReposWatchedByUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListReposWatchedByUser performs requests for "activity/list-repos-watched-by-user"

List repositories watched by a user.

  GET /users/{username}/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
func (c Client) ActivityListReposWatchedByUser(ctx context.Context, req *ActivityListReposWatchedByUserReq, opt ...options.Option) (*ActivityListReposWatchedByUserResponse, error) {
	return ActivityListReposWatchedByUser(ctx, req, append(c, opt...)...)
}

/*
ActivityListReposWatchedByUserReq is request data for Client.ActivityListReposWatchedByUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
type ActivityListReposWatchedByUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListReposWatchedByUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListReposWatchedByUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-repos-watched-by-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/subscriptions", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListReposWatchedByUserReq) Rel(link RelName, resp *ActivityListReposWatchedByUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListReposWatchedByUserResponse is a response for ActivityListReposWatchedByUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
type ActivityListReposWatchedByUserResponse struct {
	common.Response
	request *ActivityListReposWatchedByUserReq
	Data    []components.MinimalRepository
}

/*
ActivityListStargazersForRepo performs requests for "activity/list-stargazers-for-repo"

List stargazers.

  GET /repos/{owner}/{repo}/stargazers

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
func ActivityListStargazersForRepo(ctx context.Context, req *ActivityListStargazersForRepoReq, opt ...options.Option) (*ActivityListStargazersForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListStargazersForRepoReq)
	}
	resp := &ActivityListStargazersForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Stargazer{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListStargazersForRepo performs requests for "activity/list-stargazers-for-repo"

List stargazers.

  GET /repos/{owner}/{repo}/stargazers

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
func (c Client) ActivityListStargazersForRepo(ctx context.Context, req *ActivityListStargazersForRepoReq, opt ...options.Option) (*ActivityListStargazersForRepoResponse, error) {
	return ActivityListStargazersForRepo(ctx, req, append(c, opt...)...)
}

/*
ActivityListStargazersForRepoReq is request data for Client.ActivityListStargazersForRepo

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
type ActivityListStargazersForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListStargazersForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListStargazersForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/vnd.github.v3.star+json")},
		Method:           "GET",
		OperationID:      "activity/list-stargazers-for-repo",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/stargazers", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListStargazersForRepoReq) Rel(link RelName, resp *ActivityListStargazersForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListStargazersForRepoResponse is a response for ActivityListStargazersForRepo

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
type ActivityListStargazersForRepoResponse struct {
	common.Response
	request *ActivityListStargazersForRepoReq
	Data    []components.Stargazer
}

/*
ActivityListWatchedReposForAuthenticatedUser performs requests for "activity/list-watched-repos-for-authenticated-user"

List repositories watched by the authenticated user.

  GET /user/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
func ActivityListWatchedReposForAuthenticatedUser(ctx context.Context, req *ActivityListWatchedReposForAuthenticatedUserReq, opt ...options.Option) (*ActivityListWatchedReposForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListWatchedReposForAuthenticatedUserReq)
	}
	resp := &ActivityListWatchedReposForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListWatchedReposForAuthenticatedUser performs requests for "activity/list-watched-repos-for-authenticated-user"

List repositories watched by the authenticated user.

  GET /user/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
func (c Client) ActivityListWatchedReposForAuthenticatedUser(ctx context.Context, req *ActivityListWatchedReposForAuthenticatedUserReq, opt ...options.Option) (*ActivityListWatchedReposForAuthenticatedUserResponse, error) {
	return ActivityListWatchedReposForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ActivityListWatchedReposForAuthenticatedUserReq is request data for Client.ActivityListWatchedReposForAuthenticatedUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
type ActivityListWatchedReposForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListWatchedReposForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListWatchedReposForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-watched-repos-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/subscriptions"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListWatchedReposForAuthenticatedUserReq) Rel(link RelName, resp *ActivityListWatchedReposForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListWatchedReposForAuthenticatedUserResponse is a response for ActivityListWatchedReposForAuthenticatedUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
type ActivityListWatchedReposForAuthenticatedUserResponse struct {
	common.Response
	request *ActivityListWatchedReposForAuthenticatedUserReq
	Data    []components.MinimalRepository
}

/*
ActivityListWatchersForRepo performs requests for "activity/list-watchers-for-repo"

List watchers.

  GET /repos/{owner}/{repo}/subscribers

https://developer.github.com/v3/activity/watching/#list-watchers
*/
func ActivityListWatchersForRepo(ctx context.Context, req *ActivityListWatchersForRepoReq, opt ...options.Option) (*ActivityListWatchersForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityListWatchersForRepoReq)
	}
	resp := &ActivityListWatchersForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListWatchersForRepo performs requests for "activity/list-watchers-for-repo"

List watchers.

  GET /repos/{owner}/{repo}/subscribers

https://developer.github.com/v3/activity/watching/#list-watchers
*/
func (c Client) ActivityListWatchersForRepo(ctx context.Context, req *ActivityListWatchersForRepoReq, opt ...options.Option) (*ActivityListWatchersForRepoResponse, error) {
	return ActivityListWatchersForRepo(ctx, req, append(c, opt...)...)
}

/*
ActivityListWatchersForRepoReq is request data for Client.ActivityListWatchersForRepo

https://developer.github.com/v3/activity/watching/#list-watchers
*/
type ActivityListWatchersForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityListWatchersForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityListWatchersForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-watchers-for-repo",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/subscribers", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListWatchersForRepoReq) Rel(link RelName, resp *ActivityListWatchersForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityListWatchersForRepoResponse is a response for ActivityListWatchersForRepo

https://developer.github.com/v3/activity/watching/#list-watchers
*/
type ActivityListWatchersForRepoResponse struct {
	common.Response
	request *ActivityListWatchersForRepoReq
	Data    []components.SimpleUser
}

/*
ActivityMarkNotificationsAsRead performs requests for "activity/mark-notifications-as-read"

Mark notifications as read.

  PUT /notifications

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
func ActivityMarkNotificationsAsRead(ctx context.Context, req *ActivityMarkNotificationsAsReadReq, opt ...options.Option) (*ActivityMarkNotificationsAsReadResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityMarkNotificationsAsReadReq)
	}
	resp := &ActivityMarkNotificationsAsReadResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ActivityMarkNotificationsAsReadResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityMarkNotificationsAsRead performs requests for "activity/mark-notifications-as-read"

Mark notifications as read.

  PUT /notifications

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
func (c Client) ActivityMarkNotificationsAsRead(ctx context.Context, req *ActivityMarkNotificationsAsReadReq, opt ...options.Option) (*ActivityMarkNotificationsAsReadResponse, error) {
	return ActivityMarkNotificationsAsRead(ctx, req, append(c, opt...)...)
}

/*
ActivityMarkNotificationsAsReadReq is request data for Client.ActivityMarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type ActivityMarkNotificationsAsReadReq struct {
	_url        string
	RequestBody ActivityMarkNotificationsAsReadReqBody
}

// HTTPRequest builds an *http.Request
func (r *ActivityMarkNotificationsAsReadReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityMarkNotificationsAsReadReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{202},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "activity/mark-notifications-as-read",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications"),
		URLQuery:         query,
		ValidStatuses:    []int{202, 205, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityMarkNotificationsAsReadReq) Rel(link RelName, resp *ActivityMarkNotificationsAsReadResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityMarkNotificationsAsReadReqBody is a request body for activity/mark-notifications-as-read

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type ActivityMarkNotificationsAsReadReqBody struct {

	// Describes the last point that notifications were checked.
	LastReadAt *string `json:"last_read_at,omitempty"`

	// Whether the notification has been read.
	Read *bool `json:"read,omitempty"`
}

/*
ActivityMarkNotificationsAsReadResponseBody is a response body for ActivityMarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type ActivityMarkNotificationsAsReadResponseBody struct {
	Message string `json:"message,omitempty"`
}

/*
ActivityMarkNotificationsAsReadResponse is a response for ActivityMarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type ActivityMarkNotificationsAsReadResponse struct {
	common.Response
	request *ActivityMarkNotificationsAsReadReq
	Data    ActivityMarkNotificationsAsReadResponseBody
}

/*
ActivityMarkRepoNotificationsAsRead performs requests for "activity/mark-repo-notifications-as-read"

Mark repository notifications as read.

  PUT /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
func ActivityMarkRepoNotificationsAsRead(ctx context.Context, req *ActivityMarkRepoNotificationsAsReadReq, opt ...options.Option) (*ActivityMarkRepoNotificationsAsReadResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityMarkRepoNotificationsAsReadReq)
	}
	resp := &ActivityMarkRepoNotificationsAsReadResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityMarkRepoNotificationsAsRead performs requests for "activity/mark-repo-notifications-as-read"

Mark repository notifications as read.

  PUT /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
func (c Client) ActivityMarkRepoNotificationsAsRead(ctx context.Context, req *ActivityMarkRepoNotificationsAsReadReq, opt ...options.Option) (*ActivityMarkRepoNotificationsAsReadResponse, error) {
	return ActivityMarkRepoNotificationsAsRead(ctx, req, append(c, opt...)...)
}

/*
ActivityMarkRepoNotificationsAsReadReq is request data for Client.ActivityMarkRepoNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type ActivityMarkRepoNotificationsAsReadReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ActivityMarkRepoNotificationsAsReadReqBody
}

// HTTPRequest builds an *http.Request
func (r *ActivityMarkRepoNotificationsAsReadReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityMarkRepoNotificationsAsReadReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "PUT",
		OperationID:      "activity/mark-repo-notifications-as-read",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/notifications", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{202},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityMarkRepoNotificationsAsReadReq) Rel(link RelName, resp *ActivityMarkRepoNotificationsAsReadResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityMarkRepoNotificationsAsReadReqBody is a request body for activity/mark-repo-notifications-as-read

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type ActivityMarkRepoNotificationsAsReadReqBody struct {

	/*
	Describes the last point that notifications were checked. Anything updated since
	this time will not be marked as read. If you omit this parameter, all
	notifications are marked as read. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Default: The current timestamp.
	*/
	LastReadAt *string `json:"last_read_at,omitempty"`
}

/*
ActivityMarkRepoNotificationsAsReadResponse is a response for ActivityMarkRepoNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type ActivityMarkRepoNotificationsAsReadResponse struct {
	common.Response
	request *ActivityMarkRepoNotificationsAsReadReq
}

/*
ActivityMarkThreadAsRead performs requests for "activity/mark-thread-as-read"

Mark a thread as read.

  PATCH /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
func ActivityMarkThreadAsRead(ctx context.Context, req *ActivityMarkThreadAsReadReq, opt ...options.Option) (*ActivityMarkThreadAsReadResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityMarkThreadAsReadReq)
	}
	resp := &ActivityMarkThreadAsReadResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityMarkThreadAsRead performs requests for "activity/mark-thread-as-read"

Mark a thread as read.

  PATCH /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
func (c Client) ActivityMarkThreadAsRead(ctx context.Context, req *ActivityMarkThreadAsReadReq, opt ...options.Option) (*ActivityMarkThreadAsReadResponse, error) {
	return ActivityMarkThreadAsRead(ctx, req, append(c, opt...)...)
}

/*
ActivityMarkThreadAsReadReq is request data for Client.ActivityMarkThreadAsRead

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
type ActivityMarkThreadAsReadReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request
func (r *ActivityMarkThreadAsReadReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityMarkThreadAsReadReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PATCH",
		OperationID:      "activity/mark-thread-as-read",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications/threads/%v", r.ThreadId),
		URLQuery:         query,
		ValidStatuses:    []int{205, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityMarkThreadAsReadReq) Rel(link RelName, resp *ActivityMarkThreadAsReadResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityMarkThreadAsReadResponse is a response for ActivityMarkThreadAsRead

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
type ActivityMarkThreadAsReadResponse struct {
	common.Response
	request *ActivityMarkThreadAsReadReq
}

/*
ActivitySetRepoSubscription performs requests for "activity/set-repo-subscription"

Set a repository subscription.

  PUT /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
func ActivitySetRepoSubscription(ctx context.Context, req *ActivitySetRepoSubscriptionReq, opt ...options.Option) (*ActivitySetRepoSubscriptionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivitySetRepoSubscriptionReq)
	}
	resp := &ActivitySetRepoSubscriptionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.RepositorySubscription{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivitySetRepoSubscription performs requests for "activity/set-repo-subscription"

Set a repository subscription.

  PUT /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
func (c Client) ActivitySetRepoSubscription(ctx context.Context, req *ActivitySetRepoSubscriptionReq, opt ...options.Option) (*ActivitySetRepoSubscriptionResponse, error) {
	return ActivitySetRepoSubscription(ctx, req, append(c, opt...)...)
}

/*
ActivitySetRepoSubscriptionReq is request data for Client.ActivitySetRepoSubscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type ActivitySetRepoSubscriptionReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ActivitySetRepoSubscriptionReqBody
}

// HTTPRequest builds an *http.Request
func (r *ActivitySetRepoSubscriptionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivitySetRepoSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "activity/set-repo-subscription",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivitySetRepoSubscriptionReq) Rel(link RelName, resp *ActivitySetRepoSubscriptionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivitySetRepoSubscriptionReqBody is a request body for activity/set-repo-subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type ActivitySetRepoSubscriptionReqBody struct {

	// Determines if all notifications should be blocked from this repository.
	Ignored *bool `json:"ignored,omitempty"`

	// Determines if notifications should be received from this repository.
	Subscribed *bool `json:"subscribed,omitempty"`
}

/*
ActivitySetRepoSubscriptionResponse is a response for ActivitySetRepoSubscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type ActivitySetRepoSubscriptionResponse struct {
	common.Response
	request *ActivitySetRepoSubscriptionReq
	Data    components.RepositorySubscription
}

/*
ActivitySetThreadSubscription performs requests for "activity/set-thread-subscription"

Set a thread subscription.

  PUT /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
func ActivitySetThreadSubscription(ctx context.Context, req *ActivitySetThreadSubscriptionReq, opt ...options.Option) (*ActivitySetThreadSubscriptionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivitySetThreadSubscriptionReq)
	}
	resp := &ActivitySetThreadSubscriptionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ThreadSubscription{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivitySetThreadSubscription performs requests for "activity/set-thread-subscription"

Set a thread subscription.

  PUT /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
func (c Client) ActivitySetThreadSubscription(ctx context.Context, req *ActivitySetThreadSubscriptionReq, opt ...options.Option) (*ActivitySetThreadSubscriptionResponse, error) {
	return ActivitySetThreadSubscription(ctx, req, append(c, opt...)...)
}

/*
ActivitySetThreadSubscriptionReq is request data for Client.ActivitySetThreadSubscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type ActivitySetThreadSubscriptionReq struct {
	_url string

	// thread_id parameter
	ThreadId    int64
	RequestBody ActivitySetThreadSubscriptionReqBody
}

// HTTPRequest builds an *http.Request
func (r *ActivitySetThreadSubscriptionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivitySetThreadSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "activity/set-thread-subscription",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivitySetThreadSubscriptionReq) Rel(link RelName, resp *ActivitySetThreadSubscriptionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivitySetThreadSubscriptionReqBody is a request body for activity/set-thread-subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type ActivitySetThreadSubscriptionReqBody struct {

	// Whether to block all notifications from a thread.
	Ignored *bool `json:"ignored,omitempty"`
}

/*
ActivitySetThreadSubscriptionResponse is a response for ActivitySetThreadSubscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type ActivitySetThreadSubscriptionResponse struct {
	common.Response
	request *ActivitySetThreadSubscriptionReq
	Data    components.ThreadSubscription
}

/*
ActivityStarRepoForAuthenticatedUser performs requests for "activity/star-repo-for-authenticated-user"

Star a repository for the authenticated user.

  PUT /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
func ActivityStarRepoForAuthenticatedUser(ctx context.Context, req *ActivityStarRepoForAuthenticatedUserReq, opt ...options.Option) (*ActivityStarRepoForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityStarRepoForAuthenticatedUserReq)
	}
	resp := &ActivityStarRepoForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityStarRepoForAuthenticatedUser performs requests for "activity/star-repo-for-authenticated-user"

Star a repository for the authenticated user.

  PUT /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
func (c Client) ActivityStarRepoForAuthenticatedUser(ctx context.Context, req *ActivityStarRepoForAuthenticatedUserReq, opt ...options.Option) (*ActivityStarRepoForAuthenticatedUserResponse, error) {
	return ActivityStarRepoForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ActivityStarRepoForAuthenticatedUserReq is request data for Client.ActivityStarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
type ActivityStarRepoForAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ActivityStarRepoForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityStarRepoForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "activity/star-repo-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityStarRepoForAuthenticatedUserReq) Rel(link RelName, resp *ActivityStarRepoForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityStarRepoForAuthenticatedUserResponse is a response for ActivityStarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
type ActivityStarRepoForAuthenticatedUserResponse struct {
	common.Response
	request *ActivityStarRepoForAuthenticatedUserReq
}

/*
ActivityUnstarRepoForAuthenticatedUser performs requests for "activity/unstar-repo-for-authenticated-user"

Unstar a repository for the authenticated user.

  DELETE /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
func ActivityUnstarRepoForAuthenticatedUser(ctx context.Context, req *ActivityUnstarRepoForAuthenticatedUserReq, opt ...options.Option) (*ActivityUnstarRepoForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActivityUnstarRepoForAuthenticatedUserReq)
	}
	resp := &ActivityUnstarRepoForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityUnstarRepoForAuthenticatedUser performs requests for "activity/unstar-repo-for-authenticated-user"

Unstar a repository for the authenticated user.

  DELETE /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
func (c Client) ActivityUnstarRepoForAuthenticatedUser(ctx context.Context, req *ActivityUnstarRepoForAuthenticatedUserReq, opt ...options.Option) (*ActivityUnstarRepoForAuthenticatedUserResponse, error) {
	return ActivityUnstarRepoForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ActivityUnstarRepoForAuthenticatedUserReq is request data for Client.ActivityUnstarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
type ActivityUnstarRepoForAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ActivityUnstarRepoForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActivityUnstarRepoForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "activity/unstar-repo-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityUnstarRepoForAuthenticatedUserReq) Rel(link RelName, resp *ActivityUnstarRepoForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActivityUnstarRepoForAuthenticatedUserResponse is a response for ActivityUnstarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
type ActivityUnstarRepoForAuthenticatedUserResponse struct {
	common.Response
	request *ActivityUnstarRepoForAuthenticatedUserReq
}
