// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
ActivityCheckRepoIsStarredByAuthenticatedUser performs requests for "activity/check-repo-is-starred-by-authenticated-user"

Check if a repository is starred by the authenticated user.

  GET /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
func (c *Client) ActivityCheckRepoIsStarredByAuthenticatedUser(ctx context.Context, req *ActivityCheckRepoIsStarredByAuthenticatedUserReq, opt ...RequestOption) (*ActivityCheckRepoIsStarredByAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityCheckRepoIsStarredByAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityCheckRepoIsStarredByAuthenticatedUserReq is request data for Client.ActivityCheckRepoIsStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
type ActivityCheckRepoIsStarredByAuthenticatedUserReq struct {
	pgURL string
	Owner string
	Repo  string
}

func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo)
}

func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) validStatuses() []int {
	return []int{204}
}

func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) endpointType() endpointType {
	return endpointTypeBoolean
}

// httpRequest creates an http request
func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityCheckRepoIsStarredByAuthenticatedUserReq) Rel(link RelName, resp *ActivityCheckRepoIsStarredByAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityCheckRepoIsStarredByAuthenticatedUserResponse is a response for ActivityCheckRepoIsStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
type ActivityCheckRepoIsStarredByAuthenticatedUserResponse struct {
	response
	request *ActivityCheckRepoIsStarredByAuthenticatedUserReq
	Data    bool
}

/*
ActivityDeleteRepoSubscription performs requests for "activity/delete-repo-subscription"

Delete a repository subscription.

  DELETE /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
func (c *Client) ActivityDeleteRepoSubscription(ctx context.Context, req *ActivityDeleteRepoSubscriptionReq, opt ...RequestOption) (*ActivityDeleteRepoSubscriptionResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityDeleteRepoSubscriptionResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityDeleteRepoSubscriptionReq is request data for Client.ActivityDeleteRepoSubscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
type ActivityDeleteRepoSubscriptionReq struct {
	pgURL string
	Owner string
	Repo  string
}

func (r *ActivityDeleteRepoSubscriptionReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityDeleteRepoSubscriptionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo)
}

func (r *ActivityDeleteRepoSubscriptionReq) method() string {
	return "DELETE"
}

func (r *ActivityDeleteRepoSubscriptionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivityDeleteRepoSubscriptionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityDeleteRepoSubscriptionReq) body() interface{} {
	return nil
}

func (r *ActivityDeleteRepoSubscriptionReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityDeleteRepoSubscriptionReq) validStatuses() []int {
	return []int{204}
}

func (r *ActivityDeleteRepoSubscriptionReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityDeleteRepoSubscriptionReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityDeleteRepoSubscriptionReq) Rel(link RelName, resp *ActivityDeleteRepoSubscriptionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityDeleteRepoSubscriptionResponse is a response for ActivityDeleteRepoSubscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
type ActivityDeleteRepoSubscriptionResponse struct {
	response
	request *ActivityDeleteRepoSubscriptionReq
}

/*
ActivityDeleteThreadSubscription performs requests for "activity/delete-thread-subscription"

Delete a thread subscription.

  DELETE /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
func (c *Client) ActivityDeleteThreadSubscription(ctx context.Context, req *ActivityDeleteThreadSubscriptionReq, opt ...RequestOption) (*ActivityDeleteThreadSubscriptionResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityDeleteThreadSubscriptionResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityDeleteThreadSubscriptionReq is request data for Client.ActivityDeleteThreadSubscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
type ActivityDeleteThreadSubscriptionReq struct {
	pgURL    string
	ThreadId int64
}

func (r *ActivityDeleteThreadSubscriptionReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityDeleteThreadSubscriptionReq) urlPath() string {
	return fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId)
}

func (r *ActivityDeleteThreadSubscriptionReq) method() string {
	return "DELETE"
}

func (r *ActivityDeleteThreadSubscriptionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivityDeleteThreadSubscriptionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityDeleteThreadSubscriptionReq) body() interface{} {
	return nil
}

func (r *ActivityDeleteThreadSubscriptionReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityDeleteThreadSubscriptionReq) validStatuses() []int {
	return []int{204}
}

func (r *ActivityDeleteThreadSubscriptionReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityDeleteThreadSubscriptionReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityDeleteThreadSubscriptionReq) Rel(link RelName, resp *ActivityDeleteThreadSubscriptionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityDeleteThreadSubscriptionResponse is a response for ActivityDeleteThreadSubscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
type ActivityDeleteThreadSubscriptionResponse struct {
	response
	request *ActivityDeleteThreadSubscriptionReq
}

/*
ActivityGetFeeds performs requests for "activity/get-feeds"

Get feeds.

  GET /feeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
func (c *Client) ActivityGetFeeds(ctx context.Context, req *ActivityGetFeedsReq, opt ...RequestOption) (*ActivityGetFeedsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityGetFeedsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivityGetFeedsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityGetFeedsReq is request data for Client.ActivityGetFeeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
type ActivityGetFeedsReq struct {
	pgURL string
}

func (r *ActivityGetFeedsReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityGetFeedsReq) urlPath() string {
	return fmt.Sprintf("/feeds")
}

func (r *ActivityGetFeedsReq) method() string {
	return "GET"
}

func (r *ActivityGetFeedsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivityGetFeedsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityGetFeedsReq) body() interface{} {
	return nil
}

func (r *ActivityGetFeedsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivityGetFeedsReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivityGetFeedsReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityGetFeedsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityGetFeedsReq) Rel(link RelName, resp *ActivityGetFeedsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityGetFeedsResponseBody is a response body for ActivityGetFeeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
type ActivityGetFeedsResponseBody struct {
	components.Feed
}

/*
ActivityGetFeedsResponse is a response for ActivityGetFeeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
type ActivityGetFeedsResponse struct {
	response
	request *ActivityGetFeedsReq
	Data    *ActivityGetFeedsResponseBody
}

/*
ActivityGetRepoSubscription performs requests for "activity/get-repo-subscription"

Get a repository subscription.

  GET /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
func (c *Client) ActivityGetRepoSubscription(ctx context.Context, req *ActivityGetRepoSubscriptionReq, opt ...RequestOption) (*ActivityGetRepoSubscriptionResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityGetRepoSubscriptionResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivityGetRepoSubscriptionResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityGetRepoSubscriptionReq is request data for Client.ActivityGetRepoSubscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
type ActivityGetRepoSubscriptionReq struct {
	pgURL string
	Owner string
	Repo  string
}

func (r *ActivityGetRepoSubscriptionReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityGetRepoSubscriptionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo)
}

func (r *ActivityGetRepoSubscriptionReq) method() string {
	return "GET"
}

func (r *ActivityGetRepoSubscriptionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivityGetRepoSubscriptionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityGetRepoSubscriptionReq) body() interface{} {
	return nil
}

func (r *ActivityGetRepoSubscriptionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivityGetRepoSubscriptionReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivityGetRepoSubscriptionReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityGetRepoSubscriptionReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityGetRepoSubscriptionReq) Rel(link RelName, resp *ActivityGetRepoSubscriptionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityGetRepoSubscriptionResponseBody is a response body for ActivityGetRepoSubscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
type ActivityGetRepoSubscriptionResponseBody struct {
	components.RepositorySubscription
}

/*
ActivityGetRepoSubscriptionResponse is a response for ActivityGetRepoSubscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
type ActivityGetRepoSubscriptionResponse struct {
	response
	request *ActivityGetRepoSubscriptionReq
	Data    *ActivityGetRepoSubscriptionResponseBody
}

/*
ActivityGetThread performs requests for "activity/get-thread"

Get a thread.

  GET /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
func (c *Client) ActivityGetThread(ctx context.Context, req *ActivityGetThreadReq, opt ...RequestOption) (*ActivityGetThreadResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityGetThreadResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivityGetThreadResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityGetThreadReq is request data for Client.ActivityGetThread

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
type ActivityGetThreadReq struct {
	pgURL    string
	ThreadId int64
}

func (r *ActivityGetThreadReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityGetThreadReq) urlPath() string {
	return fmt.Sprintf("/notifications/threads/%v", r.ThreadId)
}

func (r *ActivityGetThreadReq) method() string {
	return "GET"
}

func (r *ActivityGetThreadReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivityGetThreadReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityGetThreadReq) body() interface{} {
	return nil
}

func (r *ActivityGetThreadReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivityGetThreadReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivityGetThreadReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityGetThreadReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityGetThreadReq) Rel(link RelName, resp *ActivityGetThreadResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityGetThreadResponseBody is a response body for ActivityGetThread

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
type ActivityGetThreadResponseBody struct {
	components.Thread
}

/*
ActivityGetThreadResponse is a response for ActivityGetThread

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
type ActivityGetThreadResponse struct {
	response
	request *ActivityGetThreadReq
	Data    *ActivityGetThreadResponseBody
}

/*
ActivityGetThreadSubscriptionForAuthenticatedUser performs requests for "activity/get-thread-subscription-for-authenticated-user"

Get a thread subscription for the authenticated user.

  GET /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
func (c *Client) ActivityGetThreadSubscriptionForAuthenticatedUser(ctx context.Context, req *ActivityGetThreadSubscriptionForAuthenticatedUserReq, opt ...RequestOption) (*ActivityGetThreadSubscriptionForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityGetThreadSubscriptionForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivityGetThreadSubscriptionForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityGetThreadSubscriptionForAuthenticatedUserReq is request data for Client.ActivityGetThreadSubscriptionForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
type ActivityGetThreadSubscriptionForAuthenticatedUserReq struct {
	pgURL    string
	ThreadId int64
}

func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId)
}

func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityGetThreadSubscriptionForAuthenticatedUserReq) Rel(link RelName, resp *ActivityGetThreadSubscriptionForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityGetThreadSubscriptionForAuthenticatedUserResponseBody is a response body for ActivityGetThreadSubscriptionForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
type ActivityGetThreadSubscriptionForAuthenticatedUserResponseBody struct {
	components.ThreadSubscription
}

/*
ActivityGetThreadSubscriptionForAuthenticatedUserResponse is a response for ActivityGetThreadSubscriptionForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
type ActivityGetThreadSubscriptionForAuthenticatedUserResponse struct {
	response
	request *ActivityGetThreadSubscriptionForAuthenticatedUserReq
	Data    *ActivityGetThreadSubscriptionForAuthenticatedUserResponseBody
}

/*
ActivityListEventsForAuthenticatedUser performs requests for "activity/list-events-for-authenticated-user"

List events for the authenticated user.

  GET /users/{username}/events

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
func (c *Client) ActivityListEventsForAuthenticatedUser(ctx context.Context, req *ActivityListEventsForAuthenticatedUserReq, opt ...RequestOption) (*ActivityListEventsForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListEventsForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListEventsForAuthenticatedUserReq is request data for Client.ActivityListEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
type ActivityListEventsForAuthenticatedUserReq struct {
	pgURL    string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListEventsForAuthenticatedUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListEventsForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/events", r.Username)
}

func (r *ActivityListEventsForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ActivityListEventsForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListEventsForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListEventsForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ActivityListEventsForAuthenticatedUserReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityListEventsForAuthenticatedUserReq) validStatuses() []int {
	return []int{}
}

func (r *ActivityListEventsForAuthenticatedUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListEventsForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListEventsForAuthenticatedUserReq) Rel(link RelName, resp *ActivityListEventsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListEventsForAuthenticatedUserResponse is a response for ActivityListEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
type ActivityListEventsForAuthenticatedUserResponse struct {
	response
	request *ActivityListEventsForAuthenticatedUserReq
}

/*
ActivityListNotificationsForAuthenticatedUser performs requests for "activity/list-notifications-for-authenticated-user"

List notifications for the authenticated user.

  GET /notifications

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
func (c *Client) ActivityListNotificationsForAuthenticatedUser(ctx context.Context, req *ActivityListNotificationsForAuthenticatedUserReq, opt ...RequestOption) (*ActivityListNotificationsForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListNotificationsForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivityListNotificationsForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListNotificationsForAuthenticatedUserReq is request data for Client.ActivityListNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
type ActivityListNotificationsForAuthenticatedUserReq struct {
	pgURL string

	// If `true`, show notifications marked as read.
	All *bool

	/*
	If `true`, only shows notifications in which the user is directly participating
	or mentioned.
	*/
	Participating *bool

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only show notifications updated before the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Before *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListNotificationsForAuthenticatedUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListNotificationsForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/notifications")
}

func (r *ActivityListNotificationsForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ActivityListNotificationsForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.All != nil {
		query.Set("all", strconv.FormatBool(*r.All))
	}
	if r.Participating != nil {
		query.Set("participating", strconv.FormatBool(*r.Participating))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Before != nil {
		query.Set("before", *r.Before)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListNotificationsForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListNotificationsForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ActivityListNotificationsForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivityListNotificationsForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivityListNotificationsForAuthenticatedUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListNotificationsForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListNotificationsForAuthenticatedUserReq) Rel(link RelName, resp *ActivityListNotificationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListNotificationsForAuthenticatedUserResponseBody is a response body for ActivityListNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
type ActivityListNotificationsForAuthenticatedUserResponseBody []struct {
	components.Thread
}

/*
ActivityListNotificationsForAuthenticatedUserResponse is a response for ActivityListNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
type ActivityListNotificationsForAuthenticatedUserResponse struct {
	response
	request *ActivityListNotificationsForAuthenticatedUserReq
	Data    *ActivityListNotificationsForAuthenticatedUserResponseBody
}

/*
ActivityListOrgEventsForAuthenticatedUser performs requests for "activity/list-org-events-for-authenticated-user"

List organization events for the authenticated user.

  GET /users/{username}/events/orgs/{org}

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
func (c *Client) ActivityListOrgEventsForAuthenticatedUser(ctx context.Context, req *ActivityListOrgEventsForAuthenticatedUserReq, opt ...RequestOption) (*ActivityListOrgEventsForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListOrgEventsForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListOrgEventsForAuthenticatedUserReq is request data for Client.ActivityListOrgEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
type ActivityListOrgEventsForAuthenticatedUserReq struct {
	pgURL    string
	Username string
	Org      string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListOrgEventsForAuthenticatedUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListOrgEventsForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/events/orgs/%v", r.Username, r.Org)
}

func (r *ActivityListOrgEventsForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ActivityListOrgEventsForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListOrgEventsForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListOrgEventsForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ActivityListOrgEventsForAuthenticatedUserReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityListOrgEventsForAuthenticatedUserReq) validStatuses() []int {
	return []int{}
}

func (r *ActivityListOrgEventsForAuthenticatedUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListOrgEventsForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListOrgEventsForAuthenticatedUserReq) Rel(link RelName, resp *ActivityListOrgEventsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListOrgEventsForAuthenticatedUserResponse is a response for ActivityListOrgEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
type ActivityListOrgEventsForAuthenticatedUserResponse struct {
	response
	request *ActivityListOrgEventsForAuthenticatedUserReq
}

/*
ActivityListPublicEvents performs requests for "activity/list-public-events"

List public events.

  GET /events

https://developer.github.com/v3/activity/events/#list-public-events
*/
func (c *Client) ActivityListPublicEvents(ctx context.Context, req *ActivityListPublicEventsReq, opt ...RequestOption) (*ActivityListPublicEventsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListPublicEventsResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListPublicEventsReq is request data for Client.ActivityListPublicEvents

https://developer.github.com/v3/activity/events/#list-public-events
*/
type ActivityListPublicEventsReq struct {
	pgURL string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListPublicEventsReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListPublicEventsReq) urlPath() string {
	return fmt.Sprintf("/events")
}

func (r *ActivityListPublicEventsReq) method() string {
	return "GET"
}

func (r *ActivityListPublicEventsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListPublicEventsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListPublicEventsReq) body() interface{} {
	return nil
}

func (r *ActivityListPublicEventsReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityListPublicEventsReq) validStatuses() []int {
	return []int{}
}

func (r *ActivityListPublicEventsReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListPublicEventsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListPublicEventsReq) Rel(link RelName, resp *ActivityListPublicEventsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListPublicEventsResponse is a response for ActivityListPublicEvents

https://developer.github.com/v3/activity/events/#list-public-events
*/
type ActivityListPublicEventsResponse struct {
	response
	request *ActivityListPublicEventsReq
}

/*
ActivityListPublicEventsForRepoNetwork performs requests for "activity/list-public-events-for-repo-network"

List public events for a network of repositories.

  GET /networks/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
func (c *Client) ActivityListPublicEventsForRepoNetwork(ctx context.Context, req *ActivityListPublicEventsForRepoNetworkReq, opt ...RequestOption) (*ActivityListPublicEventsForRepoNetworkResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListPublicEventsForRepoNetworkResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListPublicEventsForRepoNetworkReq is request data for Client.ActivityListPublicEventsForRepoNetwork

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
type ActivityListPublicEventsForRepoNetworkReq struct {
	pgURL string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListPublicEventsForRepoNetworkReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListPublicEventsForRepoNetworkReq) urlPath() string {
	return fmt.Sprintf("/networks/%v/%v/events", r.Owner, r.Repo)
}

func (r *ActivityListPublicEventsForRepoNetworkReq) method() string {
	return "GET"
}

func (r *ActivityListPublicEventsForRepoNetworkReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListPublicEventsForRepoNetworkReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListPublicEventsForRepoNetworkReq) body() interface{} {
	return nil
}

func (r *ActivityListPublicEventsForRepoNetworkReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityListPublicEventsForRepoNetworkReq) validStatuses() []int {
	return []int{}
}

func (r *ActivityListPublicEventsForRepoNetworkReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListPublicEventsForRepoNetworkReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListPublicEventsForRepoNetworkReq) Rel(link RelName, resp *ActivityListPublicEventsForRepoNetworkResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListPublicEventsForRepoNetworkResponse is a response for ActivityListPublicEventsForRepoNetwork

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
type ActivityListPublicEventsForRepoNetworkResponse struct {
	response
	request *ActivityListPublicEventsForRepoNetworkReq
}

/*
ActivityListPublicEventsForUser performs requests for "activity/list-public-events-for-user"

List public events for a user.

  GET /users/{username}/events/public

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
func (c *Client) ActivityListPublicEventsForUser(ctx context.Context, req *ActivityListPublicEventsForUserReq, opt ...RequestOption) (*ActivityListPublicEventsForUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListPublicEventsForUserResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListPublicEventsForUserReq is request data for Client.ActivityListPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
type ActivityListPublicEventsForUserReq struct {
	pgURL    string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListPublicEventsForUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListPublicEventsForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/events/public", r.Username)
}

func (r *ActivityListPublicEventsForUserReq) method() string {
	return "GET"
}

func (r *ActivityListPublicEventsForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListPublicEventsForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListPublicEventsForUserReq) body() interface{} {
	return nil
}

func (r *ActivityListPublicEventsForUserReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityListPublicEventsForUserReq) validStatuses() []int {
	return []int{}
}

func (r *ActivityListPublicEventsForUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListPublicEventsForUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListPublicEventsForUserReq) Rel(link RelName, resp *ActivityListPublicEventsForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListPublicEventsForUserResponse is a response for ActivityListPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
type ActivityListPublicEventsForUserResponse struct {
	response
	request *ActivityListPublicEventsForUserReq
}

/*
ActivityListPublicOrgEvents performs requests for "activity/list-public-org-events"

List public organization events.

  GET /orgs/{org}/events

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
func (c *Client) ActivityListPublicOrgEvents(ctx context.Context, req *ActivityListPublicOrgEventsReq, opt ...RequestOption) (*ActivityListPublicOrgEventsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListPublicOrgEventsResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListPublicOrgEventsReq is request data for Client.ActivityListPublicOrgEvents

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
type ActivityListPublicOrgEventsReq struct {
	pgURL string
	Org   string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListPublicOrgEventsReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListPublicOrgEventsReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/events", r.Org)
}

func (r *ActivityListPublicOrgEventsReq) method() string {
	return "GET"
}

func (r *ActivityListPublicOrgEventsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListPublicOrgEventsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListPublicOrgEventsReq) body() interface{} {
	return nil
}

func (r *ActivityListPublicOrgEventsReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityListPublicOrgEventsReq) validStatuses() []int {
	return []int{}
}

func (r *ActivityListPublicOrgEventsReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListPublicOrgEventsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListPublicOrgEventsReq) Rel(link RelName, resp *ActivityListPublicOrgEventsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListPublicOrgEventsResponse is a response for ActivityListPublicOrgEvents

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
type ActivityListPublicOrgEventsResponse struct {
	response
	request *ActivityListPublicOrgEventsReq
}

/*
ActivityListReceivedEventsForUser performs requests for "activity/list-received-events-for-user"

List events received by the authenticated user.

  GET /users/{username}/received_events

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
func (c *Client) ActivityListReceivedEventsForUser(ctx context.Context, req *ActivityListReceivedEventsForUserReq, opt ...RequestOption) (*ActivityListReceivedEventsForUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListReceivedEventsForUserResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListReceivedEventsForUserReq is request data for Client.ActivityListReceivedEventsForUser

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
type ActivityListReceivedEventsForUserReq struct {
	pgURL    string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListReceivedEventsForUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListReceivedEventsForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/received_events", r.Username)
}

func (r *ActivityListReceivedEventsForUserReq) method() string {
	return "GET"
}

func (r *ActivityListReceivedEventsForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListReceivedEventsForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListReceivedEventsForUserReq) body() interface{} {
	return nil
}

func (r *ActivityListReceivedEventsForUserReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityListReceivedEventsForUserReq) validStatuses() []int {
	return []int{}
}

func (r *ActivityListReceivedEventsForUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListReceivedEventsForUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListReceivedEventsForUserReq) Rel(link RelName, resp *ActivityListReceivedEventsForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListReceivedEventsForUserResponse is a response for ActivityListReceivedEventsForUser

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
type ActivityListReceivedEventsForUserResponse struct {
	response
	request *ActivityListReceivedEventsForUserReq
}

/*
ActivityListReceivedPublicEventsForUser performs requests for "activity/list-received-public-events-for-user"

List public events received by a user.

  GET /users/{username}/received_events/public

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
func (c *Client) ActivityListReceivedPublicEventsForUser(ctx context.Context, req *ActivityListReceivedPublicEventsForUserReq, opt ...RequestOption) (*ActivityListReceivedPublicEventsForUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListReceivedPublicEventsForUserResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListReceivedPublicEventsForUserReq is request data for Client.ActivityListReceivedPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
type ActivityListReceivedPublicEventsForUserReq struct {
	pgURL    string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListReceivedPublicEventsForUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListReceivedPublicEventsForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/received_events/public", r.Username)
}

func (r *ActivityListReceivedPublicEventsForUserReq) method() string {
	return "GET"
}

func (r *ActivityListReceivedPublicEventsForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListReceivedPublicEventsForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListReceivedPublicEventsForUserReq) body() interface{} {
	return nil
}

func (r *ActivityListReceivedPublicEventsForUserReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityListReceivedPublicEventsForUserReq) validStatuses() []int {
	return []int{}
}

func (r *ActivityListReceivedPublicEventsForUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListReceivedPublicEventsForUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListReceivedPublicEventsForUserReq) Rel(link RelName, resp *ActivityListReceivedPublicEventsForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListReceivedPublicEventsForUserResponse is a response for ActivityListReceivedPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
type ActivityListReceivedPublicEventsForUserResponse struct {
	response
	request *ActivityListReceivedPublicEventsForUserReq
}

/*
ActivityListRepoEvents performs requests for "activity/list-repo-events"

List repository events.

  GET /repos/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-repository-events
*/
func (c *Client) ActivityListRepoEvents(ctx context.Context, req *ActivityListRepoEventsReq, opt ...RequestOption) (*ActivityListRepoEventsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListRepoEventsResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListRepoEventsReq is request data for Client.ActivityListRepoEvents

https://developer.github.com/v3/activity/events/#list-repository-events
*/
type ActivityListRepoEventsReq struct {
	pgURL string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListRepoEventsReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListRepoEventsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/events", r.Owner, r.Repo)
}

func (r *ActivityListRepoEventsReq) method() string {
	return "GET"
}

func (r *ActivityListRepoEventsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListRepoEventsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListRepoEventsReq) body() interface{} {
	return nil
}

func (r *ActivityListRepoEventsReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityListRepoEventsReq) validStatuses() []int {
	return []int{}
}

func (r *ActivityListRepoEventsReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListRepoEventsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListRepoEventsReq) Rel(link RelName, resp *ActivityListRepoEventsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListRepoEventsResponse is a response for ActivityListRepoEvents

https://developer.github.com/v3/activity/events/#list-repository-events
*/
type ActivityListRepoEventsResponse struct {
	response
	request *ActivityListRepoEventsReq
}

/*
ActivityListRepoNotificationsForAuthenticatedUser performs requests for "activity/list-repo-notifications-for-authenticated-user"

List repository notifications for the authenticated user.

  GET /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
func (c *Client) ActivityListRepoNotificationsForAuthenticatedUser(ctx context.Context, req *ActivityListRepoNotificationsForAuthenticatedUserReq, opt ...RequestOption) (*ActivityListRepoNotificationsForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListRepoNotificationsForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivityListRepoNotificationsForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListRepoNotificationsForAuthenticatedUserReq is request data for Client.ActivityListRepoNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
type ActivityListRepoNotificationsForAuthenticatedUserReq struct {
	pgURL string
	Owner string
	Repo  string

	// If `true`, show notifications marked as read.
	All *bool

	/*
	If `true`, only shows notifications in which the user is directly participating
	or mentioned.
	*/
	Participating *bool

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only show notifications updated before the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Before *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/notifications", r.Owner, r.Repo)
}

func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.All != nil {
		query.Set("all", strconv.FormatBool(*r.All))
	}
	if r.Participating != nil {
		query.Set("participating", strconv.FormatBool(*r.Participating))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Before != nil {
		query.Set("before", *r.Before)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListRepoNotificationsForAuthenticatedUserReq) Rel(link RelName, resp *ActivityListRepoNotificationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListRepoNotificationsForAuthenticatedUserResponseBody is a response body for ActivityListRepoNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
type ActivityListRepoNotificationsForAuthenticatedUserResponseBody []struct {
	components.Thread
}

/*
ActivityListRepoNotificationsForAuthenticatedUserResponse is a response for ActivityListRepoNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
type ActivityListRepoNotificationsForAuthenticatedUserResponse struct {
	response
	request *ActivityListRepoNotificationsForAuthenticatedUserReq
	Data    *ActivityListRepoNotificationsForAuthenticatedUserResponseBody
}

/*
ActivityListReposStarredByAuthenticatedUser performs requests for "activity/list-repos-starred-by-authenticated-user"

List repositories starred by the authenticated user.

  GET /user/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
func (c *Client) ActivityListReposStarredByAuthenticatedUser(ctx context.Context, req *ActivityListReposStarredByAuthenticatedUserReq, opt ...RequestOption) (*ActivityListReposStarredByAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListReposStarredByAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivityListReposStarredByAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListReposStarredByAuthenticatedUserReq is request data for Client.ActivityListReposStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
type ActivityListReposStarredByAuthenticatedUserReq struct {
	pgURL string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListReposStarredByAuthenticatedUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListReposStarredByAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/starred")
}

func (r *ActivityListReposStarredByAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ActivityListReposStarredByAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListReposStarredByAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListReposStarredByAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ActivityListReposStarredByAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivityListReposStarredByAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivityListReposStarredByAuthenticatedUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListReposStarredByAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListReposStarredByAuthenticatedUserReq) Rel(link RelName, resp *ActivityListReposStarredByAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListReposStarredByAuthenticatedUserResponseBody is a response body for ActivityListReposStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
type ActivityListReposStarredByAuthenticatedUserResponseBody []struct {
	components.Repository
}

/*
ActivityListReposStarredByAuthenticatedUserResponse is a response for ActivityListReposStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
type ActivityListReposStarredByAuthenticatedUserResponse struct {
	response
	request *ActivityListReposStarredByAuthenticatedUserReq
	Data    *ActivityListReposStarredByAuthenticatedUserResponseBody
}

/*
ActivityListReposStarredByUser performs requests for "activity/list-repos-starred-by-user"

List repositories starred by a user.

  GET /users/{username}/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
func (c *Client) ActivityListReposStarredByUser(ctx context.Context, req *ActivityListReposStarredByUserReq, opt ...RequestOption) (*ActivityListReposStarredByUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListReposStarredByUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivityListReposStarredByUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListReposStarredByUserReq is request data for Client.ActivityListReposStarredByUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
type ActivityListReposStarredByUserReq struct {
	pgURL    string
	Username string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListReposStarredByUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListReposStarredByUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/starred", r.Username)
}

func (r *ActivityListReposStarredByUserReq) method() string {
	return "GET"
}

func (r *ActivityListReposStarredByUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListReposStarredByUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListReposStarredByUserReq) body() interface{} {
	return nil
}

func (r *ActivityListReposStarredByUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivityListReposStarredByUserReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivityListReposStarredByUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListReposStarredByUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListReposStarredByUserReq) Rel(link RelName, resp *ActivityListReposStarredByUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListReposStarredByUserResponseBody is a response body for ActivityListReposStarredByUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
type ActivityListReposStarredByUserResponseBody []struct {
	components.Repository
}

/*
ActivityListReposStarredByUserResponse is a response for ActivityListReposStarredByUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
type ActivityListReposStarredByUserResponse struct {
	response
	request *ActivityListReposStarredByUserReq
	Data    *ActivityListReposStarredByUserResponseBody
}

/*
ActivityListReposWatchedByUser performs requests for "activity/list-repos-watched-by-user"

List repositories watched by a user.

  GET /users/{username}/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
func (c *Client) ActivityListReposWatchedByUser(ctx context.Context, req *ActivityListReposWatchedByUserReq, opt ...RequestOption) (*ActivityListReposWatchedByUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListReposWatchedByUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivityListReposWatchedByUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListReposWatchedByUserReq is request data for Client.ActivityListReposWatchedByUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
type ActivityListReposWatchedByUserReq struct {
	pgURL    string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListReposWatchedByUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListReposWatchedByUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/subscriptions", r.Username)
}

func (r *ActivityListReposWatchedByUserReq) method() string {
	return "GET"
}

func (r *ActivityListReposWatchedByUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListReposWatchedByUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListReposWatchedByUserReq) body() interface{} {
	return nil
}

func (r *ActivityListReposWatchedByUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivityListReposWatchedByUserReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivityListReposWatchedByUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListReposWatchedByUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListReposWatchedByUserReq) Rel(link RelName, resp *ActivityListReposWatchedByUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListReposWatchedByUserResponseBody is a response body for ActivityListReposWatchedByUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
type ActivityListReposWatchedByUserResponseBody []struct {
	components.MinimalRepository
}

/*
ActivityListReposWatchedByUserResponse is a response for ActivityListReposWatchedByUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
type ActivityListReposWatchedByUserResponse struct {
	response
	request *ActivityListReposWatchedByUserReq
	Data    *ActivityListReposWatchedByUserResponseBody
}

/*
ActivityListStargazersForRepo performs requests for "activity/list-stargazers-for-repo"

List stargazers.

  GET /repos/{owner}/{repo}/stargazers

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
func (c *Client) ActivityListStargazersForRepo(ctx context.Context, req *ActivityListStargazersForRepoReq, opt ...RequestOption) (*ActivityListStargazersForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListStargazersForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivityListStargazersForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListStargazersForRepoReq is request data for Client.ActivityListStargazersForRepo

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
type ActivityListStargazersForRepoReq struct {
	pgURL string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListStargazersForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListStargazersForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stargazers", r.Owner, r.Repo)
}

func (r *ActivityListStargazersForRepoReq) method() string {
	return "GET"
}

func (r *ActivityListStargazersForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListStargazersForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListStargazersForRepoReq) body() interface{} {
	return nil
}

func (r *ActivityListStargazersForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivityListStargazersForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivityListStargazersForRepoReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListStargazersForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListStargazersForRepoReq) Rel(link RelName, resp *ActivityListStargazersForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListStargazersForRepoResponseBody is a response body for ActivityListStargazersForRepo

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
type ActivityListStargazersForRepoResponseBody []struct {
	components.SimpleUser
}

/*
ActivityListStargazersForRepoResponse is a response for ActivityListStargazersForRepo

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
type ActivityListStargazersForRepoResponse struct {
	response
	request *ActivityListStargazersForRepoReq
	Data    *ActivityListStargazersForRepoResponseBody
}

/*
ActivityListWatchedReposForAuthenticatedUser performs requests for "activity/list-watched-repos-for-authenticated-user"

List repositories watched by the authenticated user.

  GET /user/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
func (c *Client) ActivityListWatchedReposForAuthenticatedUser(ctx context.Context, req *ActivityListWatchedReposForAuthenticatedUserReq, opt ...RequestOption) (*ActivityListWatchedReposForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListWatchedReposForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivityListWatchedReposForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListWatchedReposForAuthenticatedUserReq is request data for Client.ActivityListWatchedReposForAuthenticatedUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
type ActivityListWatchedReposForAuthenticatedUserReq struct {
	pgURL string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListWatchedReposForAuthenticatedUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListWatchedReposForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/subscriptions")
}

func (r *ActivityListWatchedReposForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ActivityListWatchedReposForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListWatchedReposForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListWatchedReposForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ActivityListWatchedReposForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivityListWatchedReposForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivityListWatchedReposForAuthenticatedUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListWatchedReposForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListWatchedReposForAuthenticatedUserReq) Rel(link RelName, resp *ActivityListWatchedReposForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListWatchedReposForAuthenticatedUserResponseBody is a response body for ActivityListWatchedReposForAuthenticatedUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
type ActivityListWatchedReposForAuthenticatedUserResponseBody []struct {
	components.MinimalRepository
}

/*
ActivityListWatchedReposForAuthenticatedUserResponse is a response for ActivityListWatchedReposForAuthenticatedUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
type ActivityListWatchedReposForAuthenticatedUserResponse struct {
	response
	request *ActivityListWatchedReposForAuthenticatedUserReq
	Data    *ActivityListWatchedReposForAuthenticatedUserResponseBody
}

/*
ActivityListWatchersForRepo performs requests for "activity/list-watchers-for-repo"

List watchers.

  GET /repos/{owner}/{repo}/subscribers

https://developer.github.com/v3/activity/watching/#list-watchers
*/
func (c *Client) ActivityListWatchersForRepo(ctx context.Context, req *ActivityListWatchersForRepoReq, opt ...RequestOption) (*ActivityListWatchersForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityListWatchersForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivityListWatchersForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityListWatchersForRepoReq is request data for Client.ActivityListWatchersForRepo

https://developer.github.com/v3/activity/watching/#list-watchers
*/
type ActivityListWatchersForRepoReq struct {
	pgURL string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActivityListWatchersForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityListWatchersForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/subscribers", r.Owner, r.Repo)
}

func (r *ActivityListWatchersForRepoReq) method() string {
	return "GET"
}

func (r *ActivityListWatchersForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActivityListWatchersForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityListWatchersForRepoReq) body() interface{} {
	return nil
}

func (r *ActivityListWatchersForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivityListWatchersForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivityListWatchersForRepoReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityListWatchersForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityListWatchersForRepoReq) Rel(link RelName, resp *ActivityListWatchersForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityListWatchersForRepoResponseBody is a response body for ActivityListWatchersForRepo

https://developer.github.com/v3/activity/watching/#list-watchers
*/
type ActivityListWatchersForRepoResponseBody []struct {
	components.SimpleUser
}

/*
ActivityListWatchersForRepoResponse is a response for ActivityListWatchersForRepo

https://developer.github.com/v3/activity/watching/#list-watchers
*/
type ActivityListWatchersForRepoResponse struct {
	response
	request *ActivityListWatchersForRepoReq
	Data    *ActivityListWatchersForRepoResponseBody
}

/*
ActivityMarkNotificationsAsRead performs requests for "activity/mark-notifications-as-read"

Mark notifications as read.

  PUT /notifications

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
func (c *Client) ActivityMarkNotificationsAsRead(ctx context.Context, req *ActivityMarkNotificationsAsReadReq, opt ...RequestOption) (*ActivityMarkNotificationsAsReadResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityMarkNotificationsAsReadResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityMarkNotificationsAsReadReq is request data for Client.ActivityMarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type ActivityMarkNotificationsAsReadReq struct {
	pgURL       string
	RequestBody ActivityMarkNotificationsAsReadReqBody
}

func (r *ActivityMarkNotificationsAsReadReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityMarkNotificationsAsReadReq) urlPath() string {
	return fmt.Sprintf("/notifications")
}

func (r *ActivityMarkNotificationsAsReadReq) method() string {
	return "PUT"
}

func (r *ActivityMarkNotificationsAsReadReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivityMarkNotificationsAsReadReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityMarkNotificationsAsReadReq) body() interface{} {
	return r.RequestBody
}

func (r *ActivityMarkNotificationsAsReadReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityMarkNotificationsAsReadReq) validStatuses() []int {
	return []int{205}
}

func (r *ActivityMarkNotificationsAsReadReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityMarkNotificationsAsReadReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityMarkNotificationsAsReadReq) Rel(link RelName, resp *ActivityMarkNotificationsAsReadResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityMarkNotificationsAsReadReqBody is a request body for activity/mark-notifications-as-read

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type ActivityMarkNotificationsAsReadReqBody struct {

	/*
	   Describes the last point that notifications were checked. Anything updated since
	   this time will not be marked as read. If you omit this parameter, all
	   notifications are marked as read. This is a timestamp in [ISO
	   8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	   Default: The current timestamp.
	*/
	LastReadAt *string `json:"last_read_at,omitempty"`
}

/*
ActivityMarkNotificationsAsReadResponse is a response for ActivityMarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type ActivityMarkNotificationsAsReadResponse struct {
	response
	request *ActivityMarkNotificationsAsReadReq
}

/*
ActivityMarkRepoNotificationsAsRead performs requests for "activity/mark-repo-notifications-as-read"

Mark repository notifications as read.

  PUT /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
func (c *Client) ActivityMarkRepoNotificationsAsRead(ctx context.Context, req *ActivityMarkRepoNotificationsAsReadReq, opt ...RequestOption) (*ActivityMarkRepoNotificationsAsReadResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityMarkRepoNotificationsAsReadResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityMarkRepoNotificationsAsReadReq is request data for Client.ActivityMarkRepoNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type ActivityMarkRepoNotificationsAsReadReq struct {
	pgURL       string
	Owner       string
	Repo        string
	RequestBody ActivityMarkRepoNotificationsAsReadReqBody
}

func (r *ActivityMarkRepoNotificationsAsReadReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityMarkRepoNotificationsAsReadReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/notifications", r.Owner, r.Repo)
}

func (r *ActivityMarkRepoNotificationsAsReadReq) method() string {
	return "PUT"
}

func (r *ActivityMarkRepoNotificationsAsReadReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivityMarkRepoNotificationsAsReadReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityMarkRepoNotificationsAsReadReq) body() interface{} {
	return r.RequestBody
}

func (r *ActivityMarkRepoNotificationsAsReadReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityMarkRepoNotificationsAsReadReq) validStatuses() []int {
	return []int{205}
}

func (r *ActivityMarkRepoNotificationsAsReadReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityMarkRepoNotificationsAsReadReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityMarkRepoNotificationsAsReadReq) Rel(link RelName, resp *ActivityMarkRepoNotificationsAsReadResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityMarkRepoNotificationsAsReadReqBody is a request body for activity/mark-repo-notifications-as-read

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type ActivityMarkRepoNotificationsAsReadReqBody struct {

	/*
	   Describes the last point that notifications were checked. Anything updated since
	   this time will not be marked as read. If you omit this parameter, all
	   notifications are marked as read. This is a timestamp in [ISO
	   8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	   Default: The current timestamp.
	*/
	LastReadAt *string `json:"last_read_at,omitempty"`
}

/*
ActivityMarkRepoNotificationsAsReadResponse is a response for ActivityMarkRepoNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type ActivityMarkRepoNotificationsAsReadResponse struct {
	response
	request *ActivityMarkRepoNotificationsAsReadReq
}

/*
ActivityMarkThreadAsRead performs requests for "activity/mark-thread-as-read"

Mark a thread as read.

  PATCH /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
func (c *Client) ActivityMarkThreadAsRead(ctx context.Context, req *ActivityMarkThreadAsReadReq, opt ...RequestOption) (*ActivityMarkThreadAsReadResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityMarkThreadAsReadResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityMarkThreadAsReadReq is request data for Client.ActivityMarkThreadAsRead

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
type ActivityMarkThreadAsReadReq struct {
	pgURL    string
	ThreadId int64
}

func (r *ActivityMarkThreadAsReadReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityMarkThreadAsReadReq) urlPath() string {
	return fmt.Sprintf("/notifications/threads/%v", r.ThreadId)
}

func (r *ActivityMarkThreadAsReadReq) method() string {
	return "PATCH"
}

func (r *ActivityMarkThreadAsReadReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivityMarkThreadAsReadReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityMarkThreadAsReadReq) body() interface{} {
	return nil
}

func (r *ActivityMarkThreadAsReadReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityMarkThreadAsReadReq) validStatuses() []int {
	return []int{205}
}

func (r *ActivityMarkThreadAsReadReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityMarkThreadAsReadReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityMarkThreadAsReadReq) Rel(link RelName, resp *ActivityMarkThreadAsReadResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityMarkThreadAsReadResponse is a response for ActivityMarkThreadAsRead

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
type ActivityMarkThreadAsReadResponse struct {
	response
	request *ActivityMarkThreadAsReadReq
}

/*
ActivitySetRepoSubscription performs requests for "activity/set-repo-subscription"

Set a repository subscription.

  PUT /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
func (c *Client) ActivitySetRepoSubscription(ctx context.Context, req *ActivitySetRepoSubscriptionReq, opt ...RequestOption) (*ActivitySetRepoSubscriptionResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivitySetRepoSubscriptionResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivitySetRepoSubscriptionResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivitySetRepoSubscriptionReq is request data for Client.ActivitySetRepoSubscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type ActivitySetRepoSubscriptionReq struct {
	pgURL       string
	Owner       string
	Repo        string
	RequestBody ActivitySetRepoSubscriptionReqBody
}

func (r *ActivitySetRepoSubscriptionReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivitySetRepoSubscriptionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo)
}

func (r *ActivitySetRepoSubscriptionReq) method() string {
	return "PUT"
}

func (r *ActivitySetRepoSubscriptionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivitySetRepoSubscriptionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivitySetRepoSubscriptionReq) body() interface{} {
	return r.RequestBody
}

func (r *ActivitySetRepoSubscriptionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivitySetRepoSubscriptionReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivitySetRepoSubscriptionReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivitySetRepoSubscriptionReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivitySetRepoSubscriptionReq) Rel(link RelName, resp *ActivitySetRepoSubscriptionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivitySetRepoSubscriptionReqBody is a request body for activity/set-repo-subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type ActivitySetRepoSubscriptionReqBody struct {

	// Determines if all notifications should be blocked from this repository.
	Ignored *bool `json:"ignored,omitempty"`

	// Determines if notifications should be received from this repository.
	Subscribed *bool `json:"subscribed,omitempty"`
}

/*
ActivitySetRepoSubscriptionResponseBody is a response body for ActivitySetRepoSubscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type ActivitySetRepoSubscriptionResponseBody struct {
	components.RepositorySubscription
}

/*
ActivitySetRepoSubscriptionResponse is a response for ActivitySetRepoSubscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type ActivitySetRepoSubscriptionResponse struct {
	response
	request *ActivitySetRepoSubscriptionReq
	Data    *ActivitySetRepoSubscriptionResponseBody
}

/*
ActivitySetThreadSubscription performs requests for "activity/set-thread-subscription"

Set a thread subscription.

  PUT /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
func (c *Client) ActivitySetThreadSubscription(ctx context.Context, req *ActivitySetThreadSubscriptionReq, opt ...RequestOption) (*ActivitySetThreadSubscriptionResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivitySetThreadSubscriptionResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActivitySetThreadSubscriptionResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivitySetThreadSubscriptionReq is request data for Client.ActivitySetThreadSubscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type ActivitySetThreadSubscriptionReq struct {
	pgURL       string
	ThreadId    int64
	RequestBody ActivitySetThreadSubscriptionReqBody
}

func (r *ActivitySetThreadSubscriptionReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivitySetThreadSubscriptionReq) urlPath() string {
	return fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId)
}

func (r *ActivitySetThreadSubscriptionReq) method() string {
	return "PUT"
}

func (r *ActivitySetThreadSubscriptionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivitySetThreadSubscriptionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivitySetThreadSubscriptionReq) body() interface{} {
	return r.RequestBody
}

func (r *ActivitySetThreadSubscriptionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActivitySetThreadSubscriptionReq) validStatuses() []int {
	return []int{200}
}

func (r *ActivitySetThreadSubscriptionReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivitySetThreadSubscriptionReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivitySetThreadSubscriptionReq) Rel(link RelName, resp *ActivitySetThreadSubscriptionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivitySetThreadSubscriptionReqBody is a request body for activity/set-thread-subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type ActivitySetThreadSubscriptionReqBody struct {

	/*
	   Unsubscribes and subscribes you to a conversation. Set `ignored` to `true` to
	   block all notifications from this thread.
	*/
	Ignored *bool `json:"ignored,omitempty"`
}

/*
ActivitySetThreadSubscriptionResponseBody is a response body for ActivitySetThreadSubscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type ActivitySetThreadSubscriptionResponseBody struct {
	components.ThreadSubscription
}

/*
ActivitySetThreadSubscriptionResponse is a response for ActivitySetThreadSubscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type ActivitySetThreadSubscriptionResponse struct {
	response
	request *ActivitySetThreadSubscriptionReq
	Data    *ActivitySetThreadSubscriptionResponseBody
}

/*
ActivityStarRepoForAuthenticatedUser performs requests for "activity/star-repo-for-authenticated-user"

Star a repository for the authenticated user.

  PUT /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
func (c *Client) ActivityStarRepoForAuthenticatedUser(ctx context.Context, req *ActivityStarRepoForAuthenticatedUserReq, opt ...RequestOption) (*ActivityStarRepoForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityStarRepoForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityStarRepoForAuthenticatedUserReq is request data for Client.ActivityStarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
type ActivityStarRepoForAuthenticatedUserReq struct {
	pgURL string
	Owner string
	Repo  string
}

func (r *ActivityStarRepoForAuthenticatedUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityStarRepoForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo)
}

func (r *ActivityStarRepoForAuthenticatedUserReq) method() string {
	return "PUT"
}

func (r *ActivityStarRepoForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivityStarRepoForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityStarRepoForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ActivityStarRepoForAuthenticatedUserReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityStarRepoForAuthenticatedUserReq) validStatuses() []int {
	return []int{204}
}

func (r *ActivityStarRepoForAuthenticatedUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityStarRepoForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityStarRepoForAuthenticatedUserReq) Rel(link RelName, resp *ActivityStarRepoForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityStarRepoForAuthenticatedUserResponse is a response for ActivityStarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
type ActivityStarRepoForAuthenticatedUserResponse struct {
	response
	request *ActivityStarRepoForAuthenticatedUserReq
}

/*
ActivityUnstarRepoForAuthenticatedUser performs requests for "activity/unstar-repo-for-authenticated-user"

Unstar a repository for the authenticated user.

  DELETE /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
func (c *Client) ActivityUnstarRepoForAuthenticatedUser(ctx context.Context, req *ActivityUnstarRepoForAuthenticatedUserReq, opt ...RequestOption) (*ActivityUnstarRepoForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActivityUnstarRepoForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActivityUnstarRepoForAuthenticatedUserReq is request data for Client.ActivityUnstarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
type ActivityUnstarRepoForAuthenticatedUserReq struct {
	pgURL string
	Owner string
	Repo  string
}

func (r *ActivityUnstarRepoForAuthenticatedUserReq) pagingURL() string {
	return r.pgURL
}

func (r *ActivityUnstarRepoForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo)
}

func (r *ActivityUnstarRepoForAuthenticatedUserReq) method() string {
	return "DELETE"
}

func (r *ActivityUnstarRepoForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActivityUnstarRepoForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActivityUnstarRepoForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ActivityUnstarRepoForAuthenticatedUserReq) dataStatuses() []int {
	return []int{}
}

func (r *ActivityUnstarRepoForAuthenticatedUserReq) validStatuses() []int {
	return []int{204}
}

func (r *ActivityUnstarRepoForAuthenticatedUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *ActivityUnstarRepoForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActivityUnstarRepoForAuthenticatedUserReq) Rel(link RelName, resp *ActivityUnstarRepoForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActivityUnstarRepoForAuthenticatedUserResponse is a response for ActivityUnstarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
type ActivityUnstarRepoForAuthenticatedUserResponse struct {
	response
	request *ActivityUnstarRepoForAuthenticatedUserReq
}
