// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"encoding/json"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"io"
	"net/http"
	"net/url"
	"strconv"
)

/*
ReposAcceptInvitation performs requests for "repos/accept-invitation"

Accept a repository invitation.

  PATCH /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
func ReposAcceptInvitation(ctx context.Context, req *ReposAcceptInvitationReq, opt ...options.Option) (*ReposAcceptInvitationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposAcceptInvitationReq)
	}
	resp := &ReposAcceptInvitationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAcceptInvitation performs requests for "repos/accept-invitation"

Accept a repository invitation.

  PATCH /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
func (c Client) ReposAcceptInvitation(ctx context.Context, req *ReposAcceptInvitationReq, opt ...options.Option) (*ReposAcceptInvitationResponse, error) {
	return ReposAcceptInvitation(ctx, req, append(c, opt...)...)
}

/*
ReposAcceptInvitationReq is request data for Client.ReposAcceptInvitation

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
type ReposAcceptInvitationReq struct {
	_url string

	// invitation_id parameter
	InvitationId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposAcceptInvitationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposAcceptInvitationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PATCH",
		OperationID:      "repos/accept-invitation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/repository_invitations/%v", r.InvitationId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAcceptInvitationReq) Rel(link RelName, resp *ReposAcceptInvitationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAcceptInvitationResponse is a response for ReposAcceptInvitation

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
type ReposAcceptInvitationResponse struct {
	common.Response
	request *ReposAcceptInvitationReq
}

/*
ReposAddAppAccessRestrictions performs requests for "repos/add-app-access-restrictions"

Add app access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
func ReposAddAppAccessRestrictions(ctx context.Context, req *ReposAddAppAccessRestrictionsReq, opt ...options.Option) (*ReposAddAppAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposAddAppAccessRestrictionsReq)
	}
	resp := &ReposAddAppAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Integration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddAppAccessRestrictions performs requests for "repos/add-app-access-restrictions"

Add app access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
func (c Client) ReposAddAppAccessRestrictions(ctx context.Context, req *ReposAddAppAccessRestrictionsReq, opt ...options.Option) (*ReposAddAppAccessRestrictionsResponse, error) {
	return ReposAddAppAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposAddAppAccessRestrictionsReq is request data for Client.ReposAddAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
type ReposAddAppAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposAddAppAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposAddAppAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposAddAppAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/add-app-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddAppAccessRestrictionsReq) Rel(link RelName, resp *ReposAddAppAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddAppAccessRestrictionsReqBody is a request body for repos/add-app-access-restrictions

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
type ReposAddAppAccessRestrictionsReqBody []string

/*
ReposAddAppAccessRestrictionsResponse is a response for ReposAddAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
type ReposAddAppAccessRestrictionsResponse struct {
	common.Response
	request *ReposAddAppAccessRestrictionsReq
	Data    []components.Integration
}

/*
ReposAddCollaborator performs requests for "repos/add-collaborator"

Add a repository collaborator.

  PUT /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
func ReposAddCollaborator(ctx context.Context, req *ReposAddCollaboratorReq, opt ...options.Option) (*ReposAddCollaboratorResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposAddCollaboratorReq)
	}
	resp := &ReposAddCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.RepositoryInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddCollaborator performs requests for "repos/add-collaborator"

Add a repository collaborator.

  PUT /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
func (c Client) ReposAddCollaborator(ctx context.Context, req *ReposAddCollaboratorReq, opt ...options.Option) (*ReposAddCollaboratorResponse, error) {
	return ReposAddCollaborator(ctx, req, append(c, opt...)...)
}

/*
ReposAddCollaboratorReq is request data for Client.ReposAddCollaborator

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
type ReposAddCollaboratorReq struct {
	_url        string
	Owner       string
	Repo        string
	Username    string
	RequestBody ReposAddCollaboratorReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposAddCollaboratorReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposAddCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/add-collaborator",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{201, 204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddCollaboratorReq) Rel(link RelName, resp *ReposAddCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddCollaboratorReqBody is a request body for repos/add-collaborator

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
type ReposAddCollaboratorReqBody struct {

	/*
	The permission to grant the collaborator. **Only valid on organization-owned
	repositories.** Can be one of:
	\* `pull` - can pull, but not push to or administer this repository.
	\* `push` - can pull and push, but not administer this repository.
	\* `admin` - can pull, push and administer this repository.
	\* `maintain` - Recommended for project managers who need to manage the
	repository without access to sensitive or destructive actions.
	\* `triage` - Recommended for contributors who need to proactively manage issues
	and pull requests without write access.
	*/
	Permission  *string `json:"permission,omitempty"`
	Permissions *string `json:"permissions,omitempty"`
}

/*
ReposAddCollaboratorResponse is a response for ReposAddCollaborator

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
type ReposAddCollaboratorResponse struct {
	common.Response
	request *ReposAddCollaboratorReq
	Data    components.RepositoryInvitation
}

/*
ReposAddStatusCheckContexts performs requests for "repos/add-status-check-contexts"

Add status check contexts.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
func ReposAddStatusCheckContexts(ctx context.Context, req *ReposAddStatusCheckContextsReq, opt ...options.Option) (*ReposAddStatusCheckContextsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposAddStatusCheckContextsReq)
	}
	resp := &ReposAddStatusCheckContextsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ReposAddStatusCheckContextsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddStatusCheckContexts performs requests for "repos/add-status-check-contexts"

Add status check contexts.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
func (c Client) ReposAddStatusCheckContexts(ctx context.Context, req *ReposAddStatusCheckContextsReq, opt ...options.Option) (*ReposAddStatusCheckContextsResponse, error) {
	return ReposAddStatusCheckContexts(ctx, req, append(c, opt...)...)
}

/*
ReposAddStatusCheckContextsReq is request data for Client.ReposAddStatusCheckContexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
type ReposAddStatusCheckContextsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposAddStatusCheckContextsReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposAddStatusCheckContextsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposAddStatusCheckContextsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/add-status-check-contexts",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddStatusCheckContextsReq) Rel(link RelName, resp *ReposAddStatusCheckContextsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddStatusCheckContextsReqBody is a request body for repos/add-status-check-contexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
type ReposAddStatusCheckContextsReqBody []string

/*
ReposAddStatusCheckContextsResponseBody is a response body for ReposAddStatusCheckContexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
type ReposAddStatusCheckContextsResponseBody []string

/*
ReposAddStatusCheckContextsResponse is a response for ReposAddStatusCheckContexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
type ReposAddStatusCheckContextsResponse struct {
	common.Response
	request *ReposAddStatusCheckContextsReq
	Data    ReposAddStatusCheckContextsResponseBody
}

/*
ReposAddTeamAccessRestrictions performs requests for "repos/add-team-access-restrictions"

Add team access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
func ReposAddTeamAccessRestrictions(ctx context.Context, req *ReposAddTeamAccessRestrictionsReq, opt ...options.Option) (*ReposAddTeamAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposAddTeamAccessRestrictionsReq)
	}
	resp := &ReposAddTeamAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddTeamAccessRestrictions performs requests for "repos/add-team-access-restrictions"

Add team access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
func (c Client) ReposAddTeamAccessRestrictions(ctx context.Context, req *ReposAddTeamAccessRestrictionsReq, opt ...options.Option) (*ReposAddTeamAccessRestrictionsResponse, error) {
	return ReposAddTeamAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposAddTeamAccessRestrictionsReq is request data for Client.ReposAddTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
type ReposAddTeamAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposAddTeamAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposAddTeamAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposAddTeamAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/add-team-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddTeamAccessRestrictionsReq) Rel(link RelName, resp *ReposAddTeamAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddTeamAccessRestrictionsReqBody is a request body for repos/add-team-access-restrictions

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
type ReposAddTeamAccessRestrictionsReqBody []string

/*
ReposAddTeamAccessRestrictionsResponse is a response for ReposAddTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
type ReposAddTeamAccessRestrictionsResponse struct {
	common.Response
	request *ReposAddTeamAccessRestrictionsReq
	Data    []components.Team
}

/*
ReposAddUserAccessRestrictions performs requests for "repos/add-user-access-restrictions"

Add user access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
func ReposAddUserAccessRestrictions(ctx context.Context, req *ReposAddUserAccessRestrictionsReq, opt ...options.Option) (*ReposAddUserAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposAddUserAccessRestrictionsReq)
	}
	resp := &ReposAddUserAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddUserAccessRestrictions performs requests for "repos/add-user-access-restrictions"

Add user access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
func (c Client) ReposAddUserAccessRestrictions(ctx context.Context, req *ReposAddUserAccessRestrictionsReq, opt ...options.Option) (*ReposAddUserAccessRestrictionsResponse, error) {
	return ReposAddUserAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposAddUserAccessRestrictionsReq is request data for Client.ReposAddUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
type ReposAddUserAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposAddUserAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposAddUserAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposAddUserAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/add-user-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddUserAccessRestrictionsReq) Rel(link RelName, resp *ReposAddUserAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddUserAccessRestrictionsReqBody is a request body for repos/add-user-access-restrictions

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
type ReposAddUserAccessRestrictionsReqBody []string

/*
ReposAddUserAccessRestrictionsResponse is a response for ReposAddUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
type ReposAddUserAccessRestrictionsResponse struct {
	common.Response
	request *ReposAddUserAccessRestrictionsReq
	Data    []components.SimpleUser
}

/*
ReposCheckCollaborator performs requests for "repos/check-collaborator"

Check if a user is a repository collaborator.

  GET /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-repository-collaborator
*/
func ReposCheckCollaborator(ctx context.Context, req *ReposCheckCollaboratorReq, opt ...options.Option) (*ReposCheckCollaboratorResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCheckCollaboratorReq)
	}
	resp := &ReposCheckCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCheckCollaborator performs requests for "repos/check-collaborator"

Check if a user is a repository collaborator.

  GET /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-repository-collaborator
*/
func (c Client) ReposCheckCollaborator(ctx context.Context, req *ReposCheckCollaboratorReq, opt ...options.Option) (*ReposCheckCollaboratorResponse, error) {
	return ReposCheckCollaborator(ctx, req, append(c, opt...)...)
}

/*
ReposCheckCollaboratorReq is request data for Client.ReposCheckCollaborator

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-repository-collaborator
*/
type ReposCheckCollaboratorReq struct {
	_url     string
	Owner    string
	Repo     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *ReposCheckCollaboratorReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCheckCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "repos/check-collaborator",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCheckCollaboratorReq) Rel(link RelName, resp *ReposCheckCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCheckCollaboratorResponse is a response for ReposCheckCollaborator

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-repository-collaborator
*/
type ReposCheckCollaboratorResponse struct {
	common.Response
	request *ReposCheckCollaboratorReq
	Data    bool
}

/*
ReposCheckVulnerabilityAlerts performs requests for "repos/check-vulnerability-alerts"

Check if vulnerability alerts are enabled for a repository.

  GET /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
func ReposCheckVulnerabilityAlerts(ctx context.Context, req *ReposCheckVulnerabilityAlertsReq, opt ...options.Option) (*ReposCheckVulnerabilityAlertsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCheckVulnerabilityAlertsReq)
	}
	resp := &ReposCheckVulnerabilityAlertsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCheckVulnerabilityAlerts performs requests for "repos/check-vulnerability-alerts"

Check if vulnerability alerts are enabled for a repository.

  GET /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
func (c Client) ReposCheckVulnerabilityAlerts(ctx context.Context, req *ReposCheckVulnerabilityAlertsReq, opt ...options.Option) (*ReposCheckVulnerabilityAlertsResponse, error) {
	return ReposCheckVulnerabilityAlerts(ctx, req, append(c, opt...)...)
}

/*
ReposCheckVulnerabilityAlertsReq is request data for Client.ReposCheckVulnerabilityAlerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
type ReposCheckVulnerabilityAlertsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling dependency alerts for a repository using the REST API is
	currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposCheckVulnerabilityAlertsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCheckVulnerabilityAlertsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"dorian"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "repos/check-vulnerability-alerts",
		Previews:         map[string]bool{"dorian": r.DorianPreview},
		RequiredPreviews: []string{"dorian"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCheckVulnerabilityAlertsReq) Rel(link RelName, resp *ReposCheckVulnerabilityAlertsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCheckVulnerabilityAlertsResponse is a response for ReposCheckVulnerabilityAlerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
type ReposCheckVulnerabilityAlertsResponse struct {
	common.Response
	request *ReposCheckVulnerabilityAlertsReq
	Data    bool
}

/*
ReposCompareCommits performs requests for "repos/compare-commits"

Compare two commits.

  GET /repos/{owner}/{repo}/compare/{base}...{head}

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
func ReposCompareCommits(ctx context.Context, req *ReposCompareCommitsReq, opt ...options.Option) (*ReposCompareCommitsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCompareCommitsReq)
	}
	resp := &ReposCompareCommitsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CommitComparison{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCompareCommits performs requests for "repos/compare-commits"

Compare two commits.

  GET /repos/{owner}/{repo}/compare/{base}...{head}

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
func (c Client) ReposCompareCommits(ctx context.Context, req *ReposCompareCommitsReq, opt ...options.Option) (*ReposCompareCommitsResponse, error) {
	return ReposCompareCommits(ctx, req, append(c, opt...)...)
}

/*
ReposCompareCommitsReq is request data for Client.ReposCompareCommits

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
type ReposCompareCommitsReq struct {
	_url  string
	Owner string
	Repo  string

	// base parameter
	Base string

	// head parameter
	Head string
}

// HTTPRequest builds an *http.Request
func (r *ReposCompareCommitsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCompareCommitsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/compare-commits",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/compare/%v...%v", r.Owner, r.Repo, r.Base, r.Head),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCompareCommitsReq) Rel(link RelName, resp *ReposCompareCommitsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCompareCommitsResponse is a response for ReposCompareCommits

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
type ReposCompareCommitsResponse struct {
	common.Response
	request *ReposCompareCommitsReq
	Data    components.CommitComparison
}

/*
ReposCreateCommitComment performs requests for "repos/create-commit-comment"

Create a commit comment.

  POST /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
func ReposCreateCommitComment(ctx context.Context, req *ReposCreateCommitCommentReq, opt ...options.Option) (*ReposCreateCommitCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateCommitCommentReq)
	}
	resp := &ReposCreateCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CommitComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateCommitComment performs requests for "repos/create-commit-comment"

Create a commit comment.

  POST /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
func (c Client) ReposCreateCommitComment(ctx context.Context, req *ReposCreateCommitCommentReq, opt ...options.Option) (*ReposCreateCommitCommentResponse, error) {
	return ReposCreateCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReposCreateCommitCommentReq is request data for Client.ReposCreateCommitComment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// commit_sha+ parameter
	CommitSha   string
	RequestBody ReposCreateCommitCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateCommitCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-commit-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/comments", r.Owner, r.Repo, r.CommitSha),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateCommitCommentReq) Rel(link RelName, resp *ReposCreateCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateCommitCommentReqBody is a request body for repos/create-commit-comment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`

	// **Deprecated**. Use **position** parameter instead. Line number in the file to comment on.
	Line *int64 `json:"line,omitempty"`

	// Relative path of the file to comment on.
	Path *string `json:"path,omitempty"`

	// Line index in the diff to comment on.
	Position *int64 `json:"position,omitempty"`
}

/*
ReposCreateCommitCommentResponse is a response for ReposCreateCommitComment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentResponse struct {
	common.Response
	request *ReposCreateCommitCommentReq
	Data    components.CommitComment
}

/*
ReposCreateCommitSignatureProtection performs requests for "repos/create-commit-signature-protection"

Create commit signature protection.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#create-commit-signature-protection
*/
func ReposCreateCommitSignatureProtection(ctx context.Context, req *ReposCreateCommitSignatureProtectionReq, opt ...options.Option) (*ReposCreateCommitSignatureProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateCommitSignatureProtectionReq)
	}
	resp := &ReposCreateCommitSignatureProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranchAdminEnforced{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateCommitSignatureProtection performs requests for "repos/create-commit-signature-protection"

Create commit signature protection.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#create-commit-signature-protection
*/
func (c Client) ReposCreateCommitSignatureProtection(ctx context.Context, req *ReposCreateCommitSignatureProtectionReq, opt ...options.Option) (*ReposCreateCommitSignatureProtectionResponse, error) {
	return ReposCreateCommitSignatureProtection(ctx, req, append(c, opt...)...)
}

/*
ReposCreateCommitSignatureProtectionReq is request data for Client.ReposCreateCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#create-commit-signature-protection
*/
type ReposCreateCommitSignatureProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateCommitSignatureProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateCommitSignatureProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"zzzax"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "POST",
		OperationID:      "repos/create-commit-signature-protection",
		Previews:         map[string]bool{"zzzax": r.ZzzaxPreview},
		RequiredPreviews: []string{"zzzax"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateCommitSignatureProtectionReq) Rel(link RelName, resp *ReposCreateCommitSignatureProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateCommitSignatureProtectionResponse is a response for ReposCreateCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#create-commit-signature-protection
*/
type ReposCreateCommitSignatureProtectionResponse struct {
	common.Response
	request *ReposCreateCommitSignatureProtectionReq
	Data    components.ProtectedBranchAdminEnforced
}

/*
ReposCreateCommitStatus performs requests for "repos/create-commit-status"

Create a commit status.

  POST /repos/{owner}/{repo}/statuses/{sha}

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
func ReposCreateCommitStatus(ctx context.Context, req *ReposCreateCommitStatusReq, opt ...options.Option) (*ReposCreateCommitStatusResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateCommitStatusReq)
	}
	resp := &ReposCreateCommitStatusResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Status{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateCommitStatus performs requests for "repos/create-commit-status"

Create a commit status.

  POST /repos/{owner}/{repo}/statuses/{sha}

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
func (c Client) ReposCreateCommitStatus(ctx context.Context, req *ReposCreateCommitStatusReq, opt ...options.Option) (*ReposCreateCommitStatusResponse, error) {
	return ReposCreateCommitStatus(ctx, req, append(c, opt...)...)
}

/*
ReposCreateCommitStatusReq is request data for Client.ReposCreateCommitStatus

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
type ReposCreateCommitStatusReq struct {
	_url  string
	Owner string
	Repo  string

	// sha parameter
	Sha         string
	RequestBody ReposCreateCommitStatusReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateCommitStatusReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateCommitStatusReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-commit-status",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/statuses/%v", r.Owner, r.Repo, r.Sha),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateCommitStatusReq) Rel(link RelName, resp *ReposCreateCommitStatusResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateCommitStatusReqBody is a request body for repos/create-commit-status

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
type ReposCreateCommitStatusReqBody struct {

	// A string label to differentiate this status from the status of other systems.
	Context *string `json:"context,omitempty"`

	// A short description of the status.
	Description *string `json:"description,omitempty"`

	// The state of the status. Can be one of `error`, `failure`, `pending`, or `success`.
	State *string `json:"state"`

	/*
	The target URL to associate with this status. This URL will be linked from the
	GitHub UI to allow users to easily see the source of the status.
	For example, if your continuous integration system is posting build status, you
	would want to provide the deep link for the build output for this specific SHA:
	`http://ci.example.com/user/repo/build/sha`
	*/
	TargetUrl *string `json:"target_url,omitempty"`
}

/*
ReposCreateCommitStatusResponse is a response for ReposCreateCommitStatus

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
type ReposCreateCommitStatusResponse struct {
	common.Response
	request *ReposCreateCommitStatusReq
	Data    components.Status
}

/*
ReposCreateDeployKey performs requests for "repos/create-deploy-key"

Create a deploy key.

  POST /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
func ReposCreateDeployKey(ctx context.Context, req *ReposCreateDeployKeyReq, opt ...options.Option) (*ReposCreateDeployKeyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateDeployKeyReq)
	}
	resp := &ReposCreateDeployKeyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.DeployKey{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateDeployKey performs requests for "repos/create-deploy-key"

Create a deploy key.

  POST /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
func (c Client) ReposCreateDeployKey(ctx context.Context, req *ReposCreateDeployKeyReq, opt ...options.Option) (*ReposCreateDeployKeyResponse, error) {
	return ReposCreateDeployKey(ctx, req, append(c, opt...)...)
}

/*
ReposCreateDeployKeyReq is request data for Client.ReposCreateDeployKey

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
type ReposCreateDeployKeyReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateDeployKeyReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateDeployKeyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateDeployKeyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-deploy-key",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/keys", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateDeployKeyReq) Rel(link RelName, resp *ReposCreateDeployKeyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateDeployKeyReqBody is a request body for repos/create-deploy-key

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
type ReposCreateDeployKeyReqBody struct {

	// The contents of the key.
	Key *string `json:"key"`

	/*
	If `true`, the key will only be able to read repository contents. Otherwise, the
	key will be able to read and write.

	Deploy keys with write access can perform the same actions as an organization
	member with admin access, or a collaborator on a personal repository. For more
	information, see "[Repository permission levels for an
	organization](https://help.github.com/articles/repository-permission-levels-for-an-organization/)"
	and "[Permission levels for a user account
	repository](https://help.github.com/articles/permission-levels-for-a-user-account-repository/)."
	*/
	ReadOnly *bool `json:"read_only,omitempty"`

	// A name for the key.
	Title *string `json:"title,omitempty"`
}

/*
ReposCreateDeployKeyResponse is a response for ReposCreateDeployKey

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
type ReposCreateDeployKeyResponse struct {
	common.Response
	request *ReposCreateDeployKeyReq
	Data    components.DeployKey
}

/*
ReposCreateDeployment performs requests for "repos/create-deployment"

Create a deployment.

  POST /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
func ReposCreateDeployment(ctx context.Context, req *ReposCreateDeploymentReq, opt ...options.Option) (*ReposCreateDeploymentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateDeploymentReq)
	}
	resp := &ReposCreateDeploymentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Deployment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateDeployment performs requests for "repos/create-deployment"

Create a deployment.

  POST /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
func (c Client) ReposCreateDeployment(ctx context.Context, req *ReposCreateDeploymentReq, opt ...options.Option) (*ReposCreateDeploymentResponse, error) {
	return ReposCreateDeployment(ctx, req, append(c, opt...)...)
}

/*
ReposCreateDeploymentReq is request data for Client.ReposCreateDeployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateDeploymentReqBody

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateDeploymentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateDeploymentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"ant-man"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-deployment",
		Previews:         map[string]bool{"ant-man": r.AntManPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201, 202},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateDeploymentReq) Rel(link RelName, resp *ReposCreateDeploymentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateDeploymentReqBody is a request body for repos/create-deployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentReqBody struct {

	// Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch.
	AutoMerge *bool   `json:"auto_merge,omitempty"`
	CreatedAt *string `json:"created_at,omitempty"`

	// Short description of the deployment.
	Description *string `json:"description,omitempty"`

	// Name for the target deployment environment (e.g., `production`, `staging`, `qa`).
	Environment *string `json:"environment,omitempty"`

	// JSON payload with extra information about the deployment.
	Payload *string `json:"payload,omitempty"`

	/*
	Specifies if the given environment is one that end-users directly interact with.
	Default: `true` when `environment` is `production` and `false` otherwise.
	**Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type.
	*/
	ProductionEnvironment *bool `json:"production_environment,omitempty"`

	// The ref to deploy. This can be a branch, tag, or SHA.
	Ref *string `json:"ref"`

	/*
	The [status](https://developer.github.com/v3/repos/statuses/) contexts to verify
	against commit status checks. If you omit this parameter, GitHub verifies all
	unique contexts before creating a deployment. To bypass checking entirely, pass
	an empty array. Defaults to all unique contexts.
	*/
	RequiredContexts []string `json:"required_contexts,omitempty"`

	// Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).
	Task *string `json:"task,omitempty"`

	/*
	Specifies if the given environment is specific to the deployment and will no
	longer exist at some point in the future. Default: `false`
	**Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type. **Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type.
	*/
	TransientEnvironment *bool `json:"transient_environment,omitempty"`
}

/*
ReposCreateDeploymentResponse is a response for ReposCreateDeployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentResponse struct {
	common.Response
	request *ReposCreateDeploymentReq
	Data    components.Deployment
}

/*
ReposCreateDeploymentStatus performs requests for "repos/create-deployment-status"

Create a deployment status.

  POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
func ReposCreateDeploymentStatus(ctx context.Context, req *ReposCreateDeploymentStatusReq, opt ...options.Option) (*ReposCreateDeploymentStatusResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateDeploymentStatusReq)
	}
	resp := &ReposCreateDeploymentStatusResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.DeploymentStatus{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateDeploymentStatus performs requests for "repos/create-deployment-status"

Create a deployment status.

  POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
func (c Client) ReposCreateDeploymentStatus(ctx context.Context, req *ReposCreateDeploymentStatusReq, opt ...options.Option) (*ReposCreateDeploymentStatusResponse, error) {
	return ReposCreateDeploymentStatus(ctx, req, append(c, opt...)...)
}

/*
ReposCreateDeploymentStatusReq is request data for Client.ReposCreateDeploymentStatus

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusReq struct {
	_url  string
	Owner string
	Repo  string

	// deployment_id parameter
	DeploymentId int64
	RequestBody  ReposCreateDeploymentStatusReqBody

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateDeploymentStatusReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateDeploymentStatusReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"flash", "ant-man"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:      "POST",
		OperationID: "repos/create-deployment-status",
		Previews: map[string]bool{
			"ant-man": r.AntManPreview,
			"flash":   r.FlashPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses", r.Owner, r.Repo, r.DeploymentId),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateDeploymentStatusReq) Rel(link RelName, resp *ReposCreateDeploymentStatusResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateDeploymentStatusReqBody is a request body for repos/create-deployment-status

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusReqBody struct {

	/*
	Adds a new `inactive` status to all prior non-transient, non-production
	environment deployments with the same repository and `environment` name as the
	created status's deployment. An `inactive` status is only added to deployments
	that had a `success` state. Default: `true`
	**Note:** To add an `inactive` status to `production` environments, you must use
	the
	[`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	custom media type.
	**Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type.
	*/
	AutoInactive *bool `json:"auto_inactive,omitempty"`

	// A short description of the status. The maximum description length is 140 characters.
	Description *string `json:"description,omitempty"`

	/*
	Name for the target deployment environment, which can be changed when setting a
	deploy status. For example, `production`, `staging`, or `qa`. **Note:** This
	parameter requires you to use the
	[`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	custom media type.
	*/
	Environment *string `json:"environment,omitempty"`

	/*
	Sets the URL for accessing your environment. Default: `""`
	**Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type. **Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type.
	*/
	EnvironmentUrl *string `json:"environment_url,omitempty"`

	/*
	The full URL of the deployment's output. This parameter replaces `target_url`.
	We will continue to accept `target_url` to support legacy uses, but we recommend
	replacing `target_url` with `log_url`. Setting `log_url` will automatically set
	`target_url` to the same value. Default: `""`
	**Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type. **Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type.
	*/
	LogUrl *string `json:"log_url,omitempty"`

	/*
	The state of the status. Can be one of `error`, `failure`, `inactive`,
	`in_progress`, `queued` `pending`, or `success`. **Note:** To use the `inactive`
	state, you must provide the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type. To use the `in_progress` and `queued` states, you must
	provide the
	[`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	custom media type. When you set a transient deployment to `inactive`, the
	deployment will be shown as `destroyed` in GitHub.
	*/
	State *string `json:"state"`

	/*
	The target URL to associate with this status. This URL should contain output to
	keep the user updated while the task is running or serve as historical
	information for what happened in the deployment. **Note:** It's recommended to
	use the `log_url` parameter, which replaces `target_url`.
	*/
	TargetUrl *string `json:"target_url,omitempty"`
}

/*
ReposCreateDeploymentStatusResponse is a response for ReposCreateDeploymentStatus

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusResponse struct {
	common.Response
	request *ReposCreateDeploymentStatusReq
	Data    components.DeploymentStatus
}

/*
ReposCreateDispatchEvent performs requests for "repos/create-dispatch-event"

Create a repository dispatch event.

  POST /repos/{owner}/{repo}/dispatches

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
func ReposCreateDispatchEvent(ctx context.Context, req *ReposCreateDispatchEventReq, opt ...options.Option) (*ReposCreateDispatchEventResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateDispatchEventReq)
	}
	resp := &ReposCreateDispatchEventResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateDispatchEvent performs requests for "repos/create-dispatch-event"

Create a repository dispatch event.

  POST /repos/{owner}/{repo}/dispatches

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
func (c Client) ReposCreateDispatchEvent(ctx context.Context, req *ReposCreateDispatchEventReq, opt ...options.Option) (*ReposCreateDispatchEventResponse, error) {
	return ReposCreateDispatchEvent(ctx, req, append(c, opt...)...)
}

/*
ReposCreateDispatchEventReq is request data for Client.ReposCreateDispatchEvent

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type ReposCreateDispatchEventReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateDispatchEventReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateDispatchEventReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateDispatchEventReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "POST",
		OperationID:      "repos/create-dispatch-event",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/dispatches", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateDispatchEventReq) Rel(link RelName, resp *ReposCreateDispatchEventResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateDispatchEventReqBody is a request body for repos/create-dispatch-event

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type ReposCreateDispatchEventReqBody struct {

	// JSON payload with extra information about the webhook event that your action or worklow may use.
	ClientPayload interface{} `json:"client_payload,omitempty"`

	// **Required:** A custom webhook event name.
	EventType *string `json:"event_type,omitempty"`
}

/*
ReposCreateDispatchEventResponse is a response for ReposCreateDispatchEvent

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type ReposCreateDispatchEventResponse struct {
	common.Response
	request *ReposCreateDispatchEventReq
}

/*
ReposCreateForAuthenticatedUser performs requests for "repos/create-for-authenticated-user"

Create a repository for the authenticated user.

  POST /user/repos

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
func ReposCreateForAuthenticatedUser(ctx context.Context, req *ReposCreateForAuthenticatedUserReq, opt ...options.Option) (*ReposCreateForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateForAuthenticatedUserReq)
	}
	resp := &ReposCreateForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Repository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateForAuthenticatedUser performs requests for "repos/create-for-authenticated-user"

Create a repository for the authenticated user.

  POST /user/repos

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
func (c Client) ReposCreateForAuthenticatedUser(ctx context.Context, req *ReposCreateForAuthenticatedUserReq, opt ...options.Option) (*ReposCreateForAuthenticatedUserResponse, error) {
	return ReposCreateForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ReposCreateForAuthenticatedUserReq is request data for Client.ReposCreateForAuthenticatedUser

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserReq struct {
	_url        string
	RequestBody ReposCreateForAuthenticatedUserReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"nebula", "baptiste"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:      "POST",
		OperationID: "repos/create-for-authenticated-user",
		Previews: map[string]bool{
			"baptiste": r.BaptistePreview,
			"nebula":   r.NebulaPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/repos"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateForAuthenticatedUserReq) Rel(link RelName, resp *ReposCreateForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateForAuthenticatedUserReqBody is a request body for repos/create-for-authenticated-user

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserReqBody struct {

	// Whether to allow merge commits for pull requests.
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	// Whether to allow rebase merges for pull requests.
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	// Whether to allow squash merges for pull requests.
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	// Whether the repository is initialized with a minimal README.
	AutoInit *bool `json:"auto_init,omitempty"`

	// Whether to delete head branches when pull requests are merged
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	// The desired language or platform to apply to the .gitignore.
	GitignoreTemplate *string `json:"gitignore_template,omitempty"`

	// Whether downloads are enabled.
	HasDownloads *bool `json:"has_downloads,omitempty"`

	// Whether issues are enabled.
	HasIssues *bool `json:"has_issues,omitempty"`

	// Whether projects are enabled.
	HasProjects *bool `json:"has_projects,omitempty"`

	// Whether the wiki is enabled.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	// Whether this repository acts as a template that can be used to generate new repositories.
	IsTemplate *bool `json:"is_template,omitempty"`

	// The license keyword of the open source license for this repository.
	LicenseTemplate *string `json:"license_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name"`

	// Whether the repository is private or public.
	Private *bool `json:"private,omitempty"`

	/*
	The id of the team that will be granted access to this repository. This is only
	valid when creating a repository in an organization.
	*/
	TeamId *int64 `json:"team_id,omitempty"`
}

/*
ReposCreateForAuthenticatedUserResponse is a response for ReposCreateForAuthenticatedUser

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserResponse struct {
	common.Response
	request *ReposCreateForAuthenticatedUserReq
	Data    components.Repository
}

/*
ReposCreateFork performs requests for "repos/create-fork"

Create a fork.

  POST /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
func ReposCreateFork(ctx context.Context, req *ReposCreateForkReq, opt ...options.Option) (*ReposCreateForkResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateForkReq)
	}
	resp := &ReposCreateForkResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Repository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateFork performs requests for "repos/create-fork"

Create a fork.

  POST /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
func (c Client) ReposCreateFork(ctx context.Context, req *ReposCreateForkReq, opt ...options.Option) (*ReposCreateForkResponse, error) {
	return ReposCreateFork(ctx, req, append(c, opt...)...)
}

/*
ReposCreateForkReq is request data for Client.ReposCreateFork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateForkReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateForkReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateForkReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{202},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-fork",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/forks", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{202},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateForkReq) Rel(link RelName, resp *ReposCreateForkResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateForkReqBody is a request body for repos/create-fork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkReqBody struct {

	// Optional parameter to specify the organization name if forking into an organization.
	Organization *string `json:"organization,omitempty"`
}

/*
ReposCreateForkResponse is a response for ReposCreateFork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkResponse struct {
	common.Response
	request *ReposCreateForkReq
	Data    components.Repository
}

/*
ReposCreateInOrg performs requests for "repos/create-in-org"

Create an organization repository.

  POST /orgs/{org}/repos

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
func ReposCreateInOrg(ctx context.Context, req *ReposCreateInOrgReq, opt ...options.Option) (*ReposCreateInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateInOrgReq)
	}
	resp := &ReposCreateInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Repository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateInOrg performs requests for "repos/create-in-org"

Create an organization repository.

  POST /orgs/{org}/repos

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
func (c Client) ReposCreateInOrg(ctx context.Context, req *ReposCreateInOrgReq, opt ...options.Option) (*ReposCreateInOrgResponse, error) {
	return ReposCreateInOrg(ctx, req, append(c, opt...)...)
}

/*
ReposCreateInOrgReq is request data for Client.ReposCreateInOrg

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgReq struct {
	_url        string
	Org         string
	RequestBody ReposCreateInOrgReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"nebula", "baptiste"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:      "POST",
		OperationID: "repos/create-in-org",
		Previews: map[string]bool{
			"baptiste": r.BaptistePreview,
			"nebula":   r.NebulaPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/repos", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateInOrgReq) Rel(link RelName, resp *ReposCreateInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateInOrgReqBody is a request body for repos/create-in-org

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgReqBody struct {

	/*
	Either `true` to allow merging pull requests with a merge commit, or `false` to
	prevent merging pull requests with merge commits.
	*/
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	// Pass `true` to create an initial commit with empty README.
	AutoInit *bool `json:"auto_init,omitempty"`

	/*
	Either `true` to allow automatically deleting head branches when pull requests
	are merged, or `false` to prevent automatic deletion.
	*/
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	/*
	Desired language or platform [.gitignore
	template](https://github.com/github/gitignore) to apply. Use the name of the
	template without the extension. For example, "Haskell".
	*/
	GitignoreTemplate *string `json:"gitignore_template,omitempty"`

	// Either `true` to enable issues for this repository or `false` to disable them.
	HasIssues *bool `json:"has_issues,omitempty"`

	/*
	Either `true` to enable projects for this repository or `false` to disable them.
	**Note:** If you're creating a repository in an organization that has disabled
	repository projects, the default is `false`, and if you pass `true`, the API
	returns an error.
	*/
	HasProjects *bool `json:"has_projects,omitempty"`

	// Either `true` to enable the wiki for this repository or `false` to disable it.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	// Either `true` to make this repo available as a template repository or `false` to prevent it.
	IsTemplate *bool `json:"is_template,omitempty"`

	/*
	Choose an [open source license template](https://choosealicense.com/) that best
	suits your needs, and then use the [license
	keyword](https://help.github.com/articles/licensing-a-repository/#searching-github-by-license-type)
	as the `license_template` string. For example, "mit" or "mpl-2.0".
	*/
	LicenseTemplate *string `json:"license_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name"`

	// Either `true` to create a private repository or `false` to create a public one.
	Private *bool `json:"private,omitempty"`

	/*
	The id of the team that will be granted access to this repository. This is only
	valid when creating a repository in an organization.
	*/
	TeamId *int64 `json:"team_id,omitempty"`

	/*
	Can be `public` or `private`. If your organization is associated with an
	enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server
	2.20+, `visibility` can also be `internal`. For more information, see "[Creating
	an internal
	repository](https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)"
	in the GitHub Help documentation.
	The `visibility` parameter overrides the `private` parameter when you use both
	parameters with the `nebula-preview` preview header.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ReposCreateInOrgResponse is a response for ReposCreateInOrg

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgResponse struct {
	common.Response
	request *ReposCreateInOrgReq
	Data    components.Repository
}

/*
ReposCreateOrUpdateFileContents performs requests for "repos/create-or-update-file-contents"

Create or update file contents.

  PUT /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
func ReposCreateOrUpdateFileContents(ctx context.Context, req *ReposCreateOrUpdateFileContentsReq, opt ...options.Option) (*ReposCreateOrUpdateFileContentsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateOrUpdateFileContentsReq)
	}
	resp := &ReposCreateOrUpdateFileContentsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.FileCommit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateOrUpdateFileContents performs requests for "repos/create-or-update-file-contents"

Create or update file contents.

  PUT /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
func (c Client) ReposCreateOrUpdateFileContents(ctx context.Context, req *ReposCreateOrUpdateFileContentsReq, opt ...options.Option) (*ReposCreateOrUpdateFileContentsResponse, error) {
	return ReposCreateOrUpdateFileContents(ctx, req, append(c, opt...)...)
}

/*
ReposCreateOrUpdateFileContentsReq is request data for Client.ReposCreateOrUpdateFileContents

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
type ReposCreateOrUpdateFileContentsReq struct {
	_url  string
	Owner string
	Repo  string

	// path+ parameter
	Path        string
	RequestBody ReposCreateOrUpdateFileContentsReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateOrUpdateFileContentsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateOrUpdateFileContentsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200, 201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/create-or-update-file-contents",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path),
		URLQuery:         query,
		ValidStatuses:    []int{200, 201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateOrUpdateFileContentsReq) Rel(link RelName, resp *ReposCreateOrUpdateFileContentsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposCreateOrUpdateFileContentsReqBodyAuthor is a value for ReposCreateOrUpdateFileContentsReqBody's Author field
type ReposCreateOrUpdateFileContentsReqBodyAuthor struct {
	Date *string `json:"date,omitempty"`

	// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
	Email *string `json:"email"`

	// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
	Name *string `json:"name"`
}

// ReposCreateOrUpdateFileContentsReqBodyCommitter is a value for ReposCreateOrUpdateFileContentsReqBody's Committer field
type ReposCreateOrUpdateFileContentsReqBodyCommitter struct {
	Date *string `json:"date,omitempty"`

	// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
	Email *string `json:"email"`

	// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
	Name *string `json:"name"`
}

/*
ReposCreateOrUpdateFileContentsReqBody is a request body for repos/create-or-update-file-contents

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
type ReposCreateOrUpdateFileContentsReqBody struct {

	// The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
	Author *ReposCreateOrUpdateFileContentsReqBodyAuthor `json:"author,omitempty"`

	// The branch name. Default: the repositorys default branch (usually `master`)
	Branch *string `json:"branch,omitempty"`

	// The person that committed the file. Default: the authenticated user.
	Committer *ReposCreateOrUpdateFileContentsReqBodyCommitter `json:"committer,omitempty"`

	// The new file content, using Base64 encoding.
	Content *string `json:"content"`

	// The commit message.
	Message *string `json:"message"`

	// **Required if you are updating a file**. The blob SHA of the file being replaced.
	Sha *string `json:"sha,omitempty"`
}

/*
ReposCreateOrUpdateFileContentsResponse is a response for ReposCreateOrUpdateFileContents

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
type ReposCreateOrUpdateFileContentsResponse struct {
	common.Response
	request *ReposCreateOrUpdateFileContentsReq
	Data    components.FileCommit
}

/*
ReposCreatePagesSite performs requests for "repos/create-pages-site"

Create a GitHub Pages site.

  POST /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
func ReposCreatePagesSite(ctx context.Context, req *ReposCreatePagesSiteReq, opt ...options.Option) (*ReposCreatePagesSiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreatePagesSiteReq)
	}
	resp := &ReposCreatePagesSiteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Page{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreatePagesSite performs requests for "repos/create-pages-site"

Create a GitHub Pages site.

  POST /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
func (c Client) ReposCreatePagesSite(ctx context.Context, req *ReposCreatePagesSiteReq, opt ...options.Option) (*ReposCreatePagesSiteResponse, error) {
	return ReposCreatePagesSite(ctx, req, append(c, opt...)...)
}

/*
ReposCreatePagesSiteReq is request data for Client.ReposCreatePagesSite

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
type ReposCreatePagesSiteReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreatePagesSiteReqBody

	/*
	Enabling and disabling Pages in the Pages API is currently available for
	developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-03-14-enabling-disabling-pages/)
	preview for more details. To access the new endpoints during the preview period,
	you must set this to true.
	*/
	SwitcherooPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposCreatePagesSiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreatePagesSiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"switcheroo"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-pages-site",
		Previews:         map[string]bool{"switcheroo": r.SwitcherooPreview},
		RequiredPreviews: []string{"switcheroo"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreatePagesSiteReq) Rel(link RelName, resp *ReposCreatePagesSiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposCreatePagesSiteReqBodySource is a value for ReposCreatePagesSiteReqBody's Source field
type ReposCreatePagesSiteReqBodySource struct {

	/*
	The repository branch used to publish your [site's source
	files](https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/).
	Can be either `master` or `gh-pages`.
	*/
	Branch *string `json:"branch,omitempty"`

	/*
	The repository directory that includes the source files for the Pages site. When
	`branch` is `master`, you can change `path` to `/docs`. When `branch` is
	`gh-pages`, you are unable to specify a `path` other than `/`.
	*/
	Path *string `json:"path,omitempty"`
}

/*
ReposCreatePagesSiteReqBody is a request body for repos/create-pages-site

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
type ReposCreatePagesSiteReqBody struct {
	Source *ReposCreatePagesSiteReqBodySource `json:"source,omitempty"`
}

/*
ReposCreatePagesSiteResponse is a response for ReposCreatePagesSite

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
type ReposCreatePagesSiteResponse struct {
	common.Response
	request *ReposCreatePagesSiteReq
	Data    components.Page
}

/*
ReposCreateRelease performs requests for "repos/create-release"

Create a release.

  POST /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#create-a-release
*/
func ReposCreateRelease(ctx context.Context, req *ReposCreateReleaseReq, opt ...options.Option) (*ReposCreateReleaseResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateReleaseReq)
	}
	resp := &ReposCreateReleaseResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Release{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateRelease performs requests for "repos/create-release"

Create a release.

  POST /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#create-a-release
*/
func (c Client) ReposCreateRelease(ctx context.Context, req *ReposCreateReleaseReq, opt ...options.Option) (*ReposCreateReleaseResponse, error) {
	return ReposCreateRelease(ctx, req, append(c, opt...)...)
}

/*
ReposCreateReleaseReq is request data for Client.ReposCreateRelease

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateReleaseReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateReleaseReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateReleaseReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-release",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateReleaseReq) Rel(link RelName, resp *ReposCreateReleaseResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateReleaseReqBody is a request body for repos/create-release

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseReqBody struct {

	// Text describing the contents of the tag.
	Body *string `json:"body,omitempty"`

	// `true` to create a draft (unpublished) release, `false` to create a published one.
	Draft *bool `json:"draft,omitempty"`

	// The name of the release.
	Name *string `json:"name,omitempty"`

	// `true` to identify the release as a prerelease. `false` to identify the release as a full release.
	Prerelease *bool `json:"prerelease,omitempty"`

	// The name of the tag.
	TagName *string `json:"tag_name"`

	/*
	Specifies the commitish value that determines where the Git tag is created from.
	Can be any branch or commit SHA. Unused if the Git tag already exists. Default:
	the repository's default branch (usually `master`).
	*/
	TargetCommitish *string `json:"target_commitish,omitempty"`
}

/*
ReposCreateReleaseResponse is a response for ReposCreateRelease

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseResponse struct {
	common.Response
	request *ReposCreateReleaseReq
	Data    components.Release
}

/*
ReposCreateUsingTemplate performs requests for "repos/create-using-template"

Create a repository using a template.

  POST /repos/{template_owner}/{template_repo}/generate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
func ReposCreateUsingTemplate(ctx context.Context, req *ReposCreateUsingTemplateReq, opt ...options.Option) (*ReposCreateUsingTemplateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateUsingTemplateReq)
	}
	resp := &ReposCreateUsingTemplateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Repository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateUsingTemplate performs requests for "repos/create-using-template"

Create a repository using a template.

  POST /repos/{template_owner}/{template_repo}/generate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
func (c Client) ReposCreateUsingTemplate(ctx context.Context, req *ReposCreateUsingTemplateReq, opt ...options.Option) (*ReposCreateUsingTemplateResponse, error) {
	return ReposCreateUsingTemplate(ctx, req, append(c, opt...)...)
}

/*
ReposCreateUsingTemplateReq is request data for Client.ReposCreateUsingTemplate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateReq struct {
	_url string

	// template_owner parameter
	TemplateOwner string

	// template_repo parameter
	TemplateRepo string
	RequestBody  ReposCreateUsingTemplateReqBody

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateUsingTemplateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateUsingTemplateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"baptiste"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-using-template",
		Previews:         map[string]bool{"baptiste": r.BaptistePreview},
		RequiredPreviews: []string{"baptiste"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/generate", r.TemplateOwner, r.TemplateRepo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateUsingTemplateReq) Rel(link RelName, resp *ReposCreateUsingTemplateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateUsingTemplateReqBody is a request body for repos/create-using-template

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateReqBody struct {

	// A short description of the new repository.
	Description *string `json:"description,omitempty"`

	// The name of the new repository.
	Name *string `json:"name"`

	/*
	The organization or person who will own the new repository. To create a new
	repository in an organization, the authenticated user must be a member of the
	specified organization.
	*/
	Owner *string `json:"owner,omitempty"`

	// Either `true` to create a new private repository or `false` to create a new public one.
	Private *bool `json:"private,omitempty"`
}

/*
ReposCreateUsingTemplateResponse is a response for ReposCreateUsingTemplate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateResponse struct {
	common.Response
	request *ReposCreateUsingTemplateReq
	Data    components.Repository
}

/*
ReposCreateWebhook performs requests for "repos/create-webhook"

Create a repository webhook.

  POST /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
func ReposCreateWebhook(ctx context.Context, req *ReposCreateWebhookReq, opt ...options.Option) (*ReposCreateWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposCreateWebhookReq)
	}
	resp := &ReposCreateWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Hook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateWebhook performs requests for "repos/create-webhook"

Create a repository webhook.

  POST /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
func (c Client) ReposCreateWebhook(ctx context.Context, req *ReposCreateWebhookReq, opt ...options.Option) (*ReposCreateWebhookResponse, error) {
	return ReposCreateWebhook(ctx, req, append(c, opt...)...)
}

/*
ReposCreateWebhookReq is request data for Client.ReposCreateWebhook

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
type ReposCreateWebhookReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateWebhookReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposCreateWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateWebhookReq) Rel(link RelName, resp *ReposCreateWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposCreateWebhookReqBodyConfig is a value for ReposCreateWebhookReqBody's Config field
type ReposCreateWebhookReqBodyConfig struct {

	// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
	ContentType *string `json:"content_type,omitempty"`
	Digest      *string `json:"digest,omitempty"`

	/*
	Determines whether the SSL certificate of the host for `url` will be verified
	when delivering payloads. Supported values include `0` (verification is
	performed) and `1` (verification is not performed). The default is `0`. **We
	strongly recommend not setting this to `1` as you are subject to
	man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	If provided, the `secret` will be used as the `key` to generate the HMAC hex
	digest value in the
	[`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	header.
	*/
	Secret *string `json:"secret,omitempty"`
	Token  *string `json:"token,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
ReposCreateWebhookReqBody is a request body for repos/create-webhook

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
type ReposCreateWebhookReqBody struct {

	// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
	Active *bool `json:"active,omitempty"`

	/*
	Key/value pairs to provide settings for this webhook. [These are defined
	below](https://developer.github.com/v3/repos/hooks/#create-hook-config-params).
	*/
	Config *ReposCreateWebhookReqBodyConfig `json:"config"`

	// Determines what [events](https://developer.github.com/webhooks/event-payloads) the hook is triggered for.
	Events []string `json:"events,omitempty"`

	// Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`.
	Name *string `json:"name,omitempty"`
}

/*
ReposCreateWebhookResponse is a response for ReposCreateWebhook

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
type ReposCreateWebhookResponse struct {
	common.Response
	request *ReposCreateWebhookReq
	Data    components.Hook
}

/*
ReposDeclineInvitation performs requests for "repos/decline-invitation"

Decline a repository invitation.

  DELETE /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
func ReposDeclineInvitation(ctx context.Context, req *ReposDeclineInvitationReq, opt ...options.Option) (*ReposDeclineInvitationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeclineInvitationReq)
	}
	resp := &ReposDeclineInvitationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeclineInvitation performs requests for "repos/decline-invitation"

Decline a repository invitation.

  DELETE /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
func (c Client) ReposDeclineInvitation(ctx context.Context, req *ReposDeclineInvitationReq, opt ...options.Option) (*ReposDeclineInvitationResponse, error) {
	return ReposDeclineInvitation(ctx, req, append(c, opt...)...)
}

/*
ReposDeclineInvitationReq is request data for Client.ReposDeclineInvitation

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
type ReposDeclineInvitationReq struct {
	_url string

	// invitation_id parameter
	InvitationId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposDeclineInvitationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeclineInvitationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/decline-invitation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/repository_invitations/%v", r.InvitationId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeclineInvitationReq) Rel(link RelName, resp *ReposDeclineInvitationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeclineInvitationResponse is a response for ReposDeclineInvitation

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
type ReposDeclineInvitationResponse struct {
	common.Response
	request *ReposDeclineInvitationReq
}

/*
ReposDelete performs requests for "repos/delete"

Delete a repository.

  DELETE /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#delete-a-repository
*/
func ReposDelete(ctx context.Context, req *ReposDeleteReq, opt ...options.Option) (*ReposDeleteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeleteReq)
	}
	resp := &ReposDeleteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDelete performs requests for "repos/delete"

Delete a repository.

  DELETE /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#delete-a-repository
*/
func (c Client) ReposDelete(ctx context.Context, req *ReposDeleteReq, opt ...options.Option) (*ReposDeleteResponse, error) {
	return ReposDelete(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteReq is request data for Client.ReposDelete

https://developer.github.com/v3/repos/#delete-a-repository
*/
type ReposDeleteReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeleteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteReq) Rel(link RelName, resp *ReposDeleteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteResponse is a response for ReposDelete

https://developer.github.com/v3/repos/#delete-a-repository
*/
type ReposDeleteResponse struct {
	common.Response
	request *ReposDeleteReq
}

/*
ReposDeleteAccessRestrictions performs requests for "repos/delete-access-restrictions"

Delete access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#delete-access-restrictions
*/
func ReposDeleteAccessRestrictions(ctx context.Context, req *ReposDeleteAccessRestrictionsReq, opt ...options.Option) (*ReposDeleteAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeleteAccessRestrictionsReq)
	}
	resp := &ReposDeleteAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteAccessRestrictions performs requests for "repos/delete-access-restrictions"

Delete access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#delete-access-restrictions
*/
func (c Client) ReposDeleteAccessRestrictions(ctx context.Context, req *ReposDeleteAccessRestrictionsReq, opt ...options.Option) (*ReposDeleteAccessRestrictionsResponse, error) {
	return ReposDeleteAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteAccessRestrictionsReq is request data for Client.ReposDeleteAccessRestrictions

https://developer.github.com/v3/repos/branches/#delete-access-restrictions
*/
type ReposDeleteAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeleteAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteAccessRestrictionsReq) Rel(link RelName, resp *ReposDeleteAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteAccessRestrictionsResponse is a response for ReposDeleteAccessRestrictions

https://developer.github.com/v3/repos/branches/#delete-access-restrictions
*/
type ReposDeleteAccessRestrictionsResponse struct {
	common.Response
	request *ReposDeleteAccessRestrictionsReq
}

/*
ReposDeleteAdminBranchProtection performs requests for "repos/delete-admin-branch-protection"

Delete admin branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#delete-admin-branch-protection
*/
func ReposDeleteAdminBranchProtection(ctx context.Context, req *ReposDeleteAdminBranchProtectionReq, opt ...options.Option) (*ReposDeleteAdminBranchProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeleteAdminBranchProtectionReq)
	}
	resp := &ReposDeleteAdminBranchProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteAdminBranchProtection performs requests for "repos/delete-admin-branch-protection"

Delete admin branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#delete-admin-branch-protection
*/
func (c Client) ReposDeleteAdminBranchProtection(ctx context.Context, req *ReposDeleteAdminBranchProtectionReq, opt ...options.Option) (*ReposDeleteAdminBranchProtectionResponse, error) {
	return ReposDeleteAdminBranchProtection(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteAdminBranchProtectionReq is request data for Client.ReposDeleteAdminBranchProtection

https://developer.github.com/v3/repos/branches/#delete-admin-branch-protection
*/
type ReposDeleteAdminBranchProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteAdminBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeleteAdminBranchProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-admin-branch-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteAdminBranchProtectionReq) Rel(link RelName, resp *ReposDeleteAdminBranchProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteAdminBranchProtectionResponse is a response for ReposDeleteAdminBranchProtection

https://developer.github.com/v3/repos/branches/#delete-admin-branch-protection
*/
type ReposDeleteAdminBranchProtectionResponse struct {
	common.Response
	request *ReposDeleteAdminBranchProtectionReq
	Data    bool
}

/*
ReposDeleteBranchProtection performs requests for "repos/delete-branch-protection"

Delete branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#delete-branch-protection
*/
func ReposDeleteBranchProtection(ctx context.Context, req *ReposDeleteBranchProtectionReq, opt ...options.Option) (*ReposDeleteBranchProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeleteBranchProtectionReq)
	}
	resp := &ReposDeleteBranchProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteBranchProtection performs requests for "repos/delete-branch-protection"

Delete branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#delete-branch-protection
*/
func (c Client) ReposDeleteBranchProtection(ctx context.Context, req *ReposDeleteBranchProtectionReq, opt ...options.Option) (*ReposDeleteBranchProtectionResponse, error) {
	return ReposDeleteBranchProtection(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteBranchProtectionReq is request data for Client.ReposDeleteBranchProtection

https://developer.github.com/v3/repos/branches/#delete-branch-protection
*/
type ReposDeleteBranchProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeleteBranchProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-branch-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteBranchProtectionReq) Rel(link RelName, resp *ReposDeleteBranchProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteBranchProtectionResponse is a response for ReposDeleteBranchProtection

https://developer.github.com/v3/repos/branches/#delete-branch-protection
*/
type ReposDeleteBranchProtectionResponse struct {
	common.Response
	request *ReposDeleteBranchProtectionReq
}

/*
ReposDeleteCommitComment performs requests for "repos/delete-commit-comment"

Delete a commit comment.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
func ReposDeleteCommitComment(ctx context.Context, req *ReposDeleteCommitCommentReq, opt ...options.Option) (*ReposDeleteCommitCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeleteCommitCommentReq)
	}
	resp := &ReposDeleteCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteCommitComment performs requests for "repos/delete-commit-comment"

Delete a commit comment.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
func (c Client) ReposDeleteCommitComment(ctx context.Context, req *ReposDeleteCommitCommentReq, opt ...options.Option) (*ReposDeleteCommitCommentResponse, error) {
	return ReposDeleteCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteCommitCommentReq is request data for Client.ReposDeleteCommitComment

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
type ReposDeleteCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteCommitCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeleteCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-commit-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteCommitCommentReq) Rel(link RelName, resp *ReposDeleteCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteCommitCommentResponse is a response for ReposDeleteCommitComment

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
type ReposDeleteCommitCommentResponse struct {
	common.Response
	request *ReposDeleteCommitCommentReq
	Data    bool
}

/*
ReposDeleteCommitSignatureProtection performs requests for "repos/delete-commit-signature-protection"

Delete commit signature protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#delete-commit-signature-protection
*/
func ReposDeleteCommitSignatureProtection(ctx context.Context, req *ReposDeleteCommitSignatureProtectionReq, opt ...options.Option) (*ReposDeleteCommitSignatureProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeleteCommitSignatureProtectionReq)
	}
	resp := &ReposDeleteCommitSignatureProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteCommitSignatureProtection performs requests for "repos/delete-commit-signature-protection"

Delete commit signature protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#delete-commit-signature-protection
*/
func (c Client) ReposDeleteCommitSignatureProtection(ctx context.Context, req *ReposDeleteCommitSignatureProtectionReq, opt ...options.Option) (*ReposDeleteCommitSignatureProtectionResponse, error) {
	return ReposDeleteCommitSignatureProtection(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteCommitSignatureProtectionReq is request data for Client.ReposDeleteCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#delete-commit-signature-protection
*/
type ReposDeleteCommitSignatureProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteCommitSignatureProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeleteCommitSignatureProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"zzzax"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-commit-signature-protection",
		Previews:         map[string]bool{"zzzax": r.ZzzaxPreview},
		RequiredPreviews: []string{"zzzax"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteCommitSignatureProtectionReq) Rel(link RelName, resp *ReposDeleteCommitSignatureProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteCommitSignatureProtectionResponse is a response for ReposDeleteCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#delete-commit-signature-protection
*/
type ReposDeleteCommitSignatureProtectionResponse struct {
	common.Response
	request *ReposDeleteCommitSignatureProtectionReq
	Data    bool
}

/*
ReposDeleteDeployKey performs requests for "repos/delete-deploy-key"

Delete a deploy key.

  DELETE /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
*/
func ReposDeleteDeployKey(ctx context.Context, req *ReposDeleteDeployKeyReq, opt ...options.Option) (*ReposDeleteDeployKeyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeleteDeployKeyReq)
	}
	resp := &ReposDeleteDeployKeyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteDeployKey performs requests for "repos/delete-deploy-key"

Delete a deploy key.

  DELETE /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
*/
func (c Client) ReposDeleteDeployKey(ctx context.Context, req *ReposDeleteDeployKeyReq, opt ...options.Option) (*ReposDeleteDeployKeyResponse, error) {
	return ReposDeleteDeployKey(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteDeployKeyReq is request data for Client.ReposDeleteDeployKey

https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
*/
type ReposDeleteDeployKeyReq struct {
	_url  string
	Owner string
	Repo  string

	// key_id parameter
	KeyId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteDeployKeyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeleteDeployKeyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-deploy-key",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/keys/%v", r.Owner, r.Repo, r.KeyId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteDeployKeyReq) Rel(link RelName, resp *ReposDeleteDeployKeyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteDeployKeyResponse is a response for ReposDeleteDeployKey

https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
*/
type ReposDeleteDeployKeyResponse struct {
	common.Response
	request *ReposDeleteDeployKeyReq
}

/*
ReposDeleteDeployment performs requests for "repos/delete-deployment"

Delete a deployment.

  DELETE /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
func ReposDeleteDeployment(ctx context.Context, req *ReposDeleteDeploymentReq, opt ...options.Option) (*ReposDeleteDeploymentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeleteDeploymentReq)
	}
	resp := &ReposDeleteDeploymentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteDeployment performs requests for "repos/delete-deployment"

Delete a deployment.

  DELETE /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
func (c Client) ReposDeleteDeployment(ctx context.Context, req *ReposDeleteDeploymentReq, opt ...options.Option) (*ReposDeleteDeploymentResponse, error) {
	return ReposDeleteDeployment(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteDeploymentReq is request data for Client.ReposDeleteDeployment

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
type ReposDeleteDeploymentReq struct {
	_url  string
	Owner string
	Repo  string

	// deployment_id parameter
	DeploymentId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteDeploymentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeleteDeploymentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-deployment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments/%v", r.Owner, r.Repo, r.DeploymentId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteDeploymentReq) Rel(link RelName, resp *ReposDeleteDeploymentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteDeploymentResponse is a response for ReposDeleteDeployment

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
type ReposDeleteDeploymentResponse struct {
	common.Response
	request *ReposDeleteDeploymentReq
}

/*
ReposDeleteFile performs requests for "repos/delete-file"

Delete a file.

  DELETE /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
func ReposDeleteFile(ctx context.Context, req *ReposDeleteFileReq, opt ...options.Option) (*ReposDeleteFileResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeleteFileReq)
	}
	resp := &ReposDeleteFileResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.FileCommit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteFile performs requests for "repos/delete-file"

Delete a file.

  DELETE /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
func (c Client) ReposDeleteFile(ctx context.Context, req *ReposDeleteFileReq, opt ...options.Option) (*ReposDeleteFileResponse, error) {
	return ReposDeleteFile(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteFileReq is request data for Client.ReposDeleteFile

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileReq struct {
	_url  string
	Owner string
	Repo  string

	// path+ parameter
	Path        string
	RequestBody ReposDeleteFileReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteFileReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeleteFileReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "DELETE",
		OperationID:      "repos/delete-file",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteFileReq) Rel(link RelName, resp *ReposDeleteFileResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposDeleteFileReqBodyAuthor is a value for ReposDeleteFileReqBody's Author field
type ReposDeleteFileReqBodyAuthor struct {

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

// ReposDeleteFileReqBodyCommitter is a value for ReposDeleteFileReqBody's Committer field
type ReposDeleteFileReqBodyCommitter struct {

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

/*
ReposDeleteFileReqBody is a request body for repos/delete-file

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileReqBody struct {

	// object containing information about the author.
	Author *ReposDeleteFileReqBodyAuthor `json:"author,omitempty"`

	// The branch name. Default: the repositorys default branch (usually `master`)
	Branch *string `json:"branch,omitempty"`

	// object containing information about the committer.
	Committer *ReposDeleteFileReqBodyCommitter `json:"committer,omitempty"`

	// The commit message.
	Message *string `json:"message"`

	// The blob SHA of the file being replaced.
	Sha *string `json:"sha"`
}

/*
ReposDeleteFileResponse is a response for ReposDeleteFile

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileResponse struct {
	common.Response
	request *ReposDeleteFileReq
	Data    components.FileCommit
}

/*
ReposDeleteInvitation performs requests for "repos/delete-invitation"

Delete a repository invitation.

  DELETE /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
func ReposDeleteInvitation(ctx context.Context, req *ReposDeleteInvitationReq, opt ...options.Option) (*ReposDeleteInvitationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeleteInvitationReq)
	}
	resp := &ReposDeleteInvitationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteInvitation performs requests for "repos/delete-invitation"

Delete a repository invitation.

  DELETE /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
func (c Client) ReposDeleteInvitation(ctx context.Context, req *ReposDeleteInvitationReq, opt ...options.Option) (*ReposDeleteInvitationResponse, error) {
	return ReposDeleteInvitation(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteInvitationReq is request data for Client.ReposDeleteInvitation

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
type ReposDeleteInvitationReq struct {
	_url  string
	Owner string
	Repo  string

	// invitation_id parameter
	InvitationId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteInvitationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeleteInvitationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-invitation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/invitations/%v", r.Owner, r.Repo, r.InvitationId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteInvitationReq) Rel(link RelName, resp *ReposDeleteInvitationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteInvitationResponse is a response for ReposDeleteInvitation

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
type ReposDeleteInvitationResponse struct {
	common.Response
	request *ReposDeleteInvitationReq
}

/*
ReposDeletePagesSite performs requests for "repos/delete-pages-site"

Delete a GitHub Pages site.

  DELETE /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#delete-a-github-pages-site
*/
func ReposDeletePagesSite(ctx context.Context, req *ReposDeletePagesSiteReq, opt ...options.Option) (*ReposDeletePagesSiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeletePagesSiteReq)
	}
	resp := &ReposDeletePagesSiteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeletePagesSite performs requests for "repos/delete-pages-site"

Delete a GitHub Pages site.

  DELETE /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#delete-a-github-pages-site
*/
func (c Client) ReposDeletePagesSite(ctx context.Context, req *ReposDeletePagesSiteReq, opt ...options.Option) (*ReposDeletePagesSiteResponse, error) {
	return ReposDeletePagesSite(ctx, req, append(c, opt...)...)
}

/*
ReposDeletePagesSiteReq is request data for Client.ReposDeletePagesSite

https://developer.github.com/v3/repos/pages/#delete-a-github-pages-site
*/
type ReposDeletePagesSiteReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling Pages in the Pages API is currently available for
	developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-03-14-enabling-disabling-pages/)
	preview for more details. To access the new endpoints during the preview period,
	you must set this to true.
	*/
	SwitcherooPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposDeletePagesSiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeletePagesSiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"switcheroo"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-pages-site",
		Previews:         map[string]bool{"switcheroo": r.SwitcherooPreview},
		RequiredPreviews: []string{"switcheroo"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeletePagesSiteReq) Rel(link RelName, resp *ReposDeletePagesSiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeletePagesSiteResponse is a response for ReposDeletePagesSite

https://developer.github.com/v3/repos/pages/#delete-a-github-pages-site
*/
type ReposDeletePagesSiteResponse struct {
	common.Response
	request *ReposDeletePagesSiteReq
}

/*
ReposDeletePullRequestReviewProtection performs requests for "repos/delete-pull-request-review-protection"

Delete pull request review protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#delete-pull-request-review-protection
*/
func ReposDeletePullRequestReviewProtection(ctx context.Context, req *ReposDeletePullRequestReviewProtectionReq, opt ...options.Option) (*ReposDeletePullRequestReviewProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeletePullRequestReviewProtectionReq)
	}
	resp := &ReposDeletePullRequestReviewProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeletePullRequestReviewProtection performs requests for "repos/delete-pull-request-review-protection"

Delete pull request review protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#delete-pull-request-review-protection
*/
func (c Client) ReposDeletePullRequestReviewProtection(ctx context.Context, req *ReposDeletePullRequestReviewProtectionReq, opt ...options.Option) (*ReposDeletePullRequestReviewProtectionResponse, error) {
	return ReposDeletePullRequestReviewProtection(ctx, req, append(c, opt...)...)
}

/*
ReposDeletePullRequestReviewProtectionReq is request data for Client.ReposDeletePullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#delete-pull-request-review-protection
*/
type ReposDeletePullRequestReviewProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposDeletePullRequestReviewProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeletePullRequestReviewProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-pull-request-review-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeletePullRequestReviewProtectionReq) Rel(link RelName, resp *ReposDeletePullRequestReviewProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeletePullRequestReviewProtectionResponse is a response for ReposDeletePullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#delete-pull-request-review-protection
*/
type ReposDeletePullRequestReviewProtectionResponse struct {
	common.Response
	request *ReposDeletePullRequestReviewProtectionReq
	Data    bool
}

/*
ReposDeleteRelease performs requests for "repos/delete-release"

Delete a release.

  DELETE /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
func ReposDeleteRelease(ctx context.Context, req *ReposDeleteReleaseReq, opt ...options.Option) (*ReposDeleteReleaseResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeleteReleaseReq)
	}
	resp := &ReposDeleteReleaseResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteRelease performs requests for "repos/delete-release"

Delete a release.

  DELETE /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
func (c Client) ReposDeleteRelease(ctx context.Context, req *ReposDeleteReleaseReq, opt ...options.Option) (*ReposDeleteReleaseResponse, error) {
	return ReposDeleteRelease(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteReleaseReq is request data for Client.ReposDeleteRelease

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
type ReposDeleteReleaseReq struct {
	_url  string
	Owner string
	Repo  string

	// release_id parameter
	ReleaseId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteReleaseReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeleteReleaseReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-release",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteReleaseReq) Rel(link RelName, resp *ReposDeleteReleaseResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteReleaseResponse is a response for ReposDeleteRelease

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
type ReposDeleteReleaseResponse struct {
	common.Response
	request *ReposDeleteReleaseReq
}

/*
ReposDeleteReleaseAsset performs requests for "repos/delete-release-asset"

Delete a release asset.

  DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
func ReposDeleteReleaseAsset(ctx context.Context, req *ReposDeleteReleaseAssetReq, opt ...options.Option) (*ReposDeleteReleaseAssetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeleteReleaseAssetReq)
	}
	resp := &ReposDeleteReleaseAssetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteReleaseAsset performs requests for "repos/delete-release-asset"

Delete a release asset.

  DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
func (c Client) ReposDeleteReleaseAsset(ctx context.Context, req *ReposDeleteReleaseAssetReq, opt ...options.Option) (*ReposDeleteReleaseAssetResponse, error) {
	return ReposDeleteReleaseAsset(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteReleaseAssetReq is request data for Client.ReposDeleteReleaseAsset

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
type ReposDeleteReleaseAssetReq struct {
	_url  string
	Owner string
	Repo  string

	// asset_id parameter
	AssetId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeleteReleaseAssetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-release-asset",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteReleaseAssetReq) Rel(link RelName, resp *ReposDeleteReleaseAssetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteReleaseAssetResponse is a response for ReposDeleteReleaseAsset

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
type ReposDeleteReleaseAssetResponse struct {
	common.Response
	request *ReposDeleteReleaseAssetReq
}

/*
ReposDeleteWebhook performs requests for "repos/delete-webhook"

Delete a repository webhook.

  DELETE /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#delete-a-repository-webhook
*/
func ReposDeleteWebhook(ctx context.Context, req *ReposDeleteWebhookReq, opt ...options.Option) (*ReposDeleteWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDeleteWebhookReq)
	}
	resp := &ReposDeleteWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteWebhook performs requests for "repos/delete-webhook"

Delete a repository webhook.

  DELETE /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#delete-a-repository-webhook
*/
func (c Client) ReposDeleteWebhook(ctx context.Context, req *ReposDeleteWebhookReq, opt ...options.Option) (*ReposDeleteWebhookResponse, error) {
	return ReposDeleteWebhook(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteWebhookReq is request data for Client.ReposDeleteWebhook

https://developer.github.com/v3/repos/hooks/#delete-a-repository-webhook
*/
type ReposDeleteWebhookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDeleteWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteWebhookReq) Rel(link RelName, resp *ReposDeleteWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteWebhookResponse is a response for ReposDeleteWebhook

https://developer.github.com/v3/repos/hooks/#delete-a-repository-webhook
*/
type ReposDeleteWebhookResponse struct {
	common.Response
	request *ReposDeleteWebhookReq
	Data    bool
}

/*
ReposDisableAutomatedSecurityFixes performs requests for "repos/disable-automated-security-fixes"

Disable automated security fixes.

  DELETE /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
func ReposDisableAutomatedSecurityFixes(ctx context.Context, req *ReposDisableAutomatedSecurityFixesReq, opt ...options.Option) (*ReposDisableAutomatedSecurityFixesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDisableAutomatedSecurityFixesReq)
	}
	resp := &ReposDisableAutomatedSecurityFixesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDisableAutomatedSecurityFixes performs requests for "repos/disable-automated-security-fixes"

Disable automated security fixes.

  DELETE /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
func (c Client) ReposDisableAutomatedSecurityFixes(ctx context.Context, req *ReposDisableAutomatedSecurityFixesReq, opt ...options.Option) (*ReposDisableAutomatedSecurityFixesResponse, error) {
	return ReposDisableAutomatedSecurityFixes(ctx, req, append(c, opt...)...)
}

/*
ReposDisableAutomatedSecurityFixesReq is request data for Client.ReposDisableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
type ReposDisableAutomatedSecurityFixesReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling or disabling automated security fixes is currently available for
	developers to preview. To access this new endpoint during the preview period,
	you must set this to true.
	*/
	LondonPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposDisableAutomatedSecurityFixesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDisableAutomatedSecurityFixesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"london"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/disable-automated-security-fixes",
		Previews:         map[string]bool{"london": r.LondonPreview},
		RequiredPreviews: []string{"london"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/automated-security-fixes", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDisableAutomatedSecurityFixesReq) Rel(link RelName, resp *ReposDisableAutomatedSecurityFixesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDisableAutomatedSecurityFixesResponse is a response for ReposDisableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
type ReposDisableAutomatedSecurityFixesResponse struct {
	common.Response
	request *ReposDisableAutomatedSecurityFixesReq
}

/*
ReposDisableVulnerabilityAlerts performs requests for "repos/disable-vulnerability-alerts"

Disable vulnerability alerts.

  DELETE /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
func ReposDisableVulnerabilityAlerts(ctx context.Context, req *ReposDisableVulnerabilityAlertsReq, opt ...options.Option) (*ReposDisableVulnerabilityAlertsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDisableVulnerabilityAlertsReq)
	}
	resp := &ReposDisableVulnerabilityAlertsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDisableVulnerabilityAlerts performs requests for "repos/disable-vulnerability-alerts"

Disable vulnerability alerts.

  DELETE /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
func (c Client) ReposDisableVulnerabilityAlerts(ctx context.Context, req *ReposDisableVulnerabilityAlertsReq, opt ...options.Option) (*ReposDisableVulnerabilityAlertsResponse, error) {
	return ReposDisableVulnerabilityAlerts(ctx, req, append(c, opt...)...)
}

/*
ReposDisableVulnerabilityAlertsReq is request data for Client.ReposDisableVulnerabilityAlerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
type ReposDisableVulnerabilityAlertsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling dependency alerts for a repository using the REST API is
	currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposDisableVulnerabilityAlertsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDisableVulnerabilityAlertsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"dorian"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/disable-vulnerability-alerts",
		Previews:         map[string]bool{"dorian": r.DorianPreview},
		RequiredPreviews: []string{"dorian"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDisableVulnerabilityAlertsReq) Rel(link RelName, resp *ReposDisableVulnerabilityAlertsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDisableVulnerabilityAlertsResponse is a response for ReposDisableVulnerabilityAlerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
type ReposDisableVulnerabilityAlertsResponse struct {
	common.Response
	request *ReposDisableVulnerabilityAlertsReq
}

/*
ReposDownloadTarballArchive performs requests for "repos/download-tarball-archive"

Download a repository archive (tar).

  GET /repos/{owner}/{repo}/tarball/{ref}

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
func ReposDownloadTarballArchive(ctx context.Context, req *ReposDownloadTarballArchiveReq, opt ...options.Option) (*ReposDownloadTarballArchiveResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDownloadTarballArchiveReq)
	}
	resp := &ReposDownloadTarballArchiveResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDownloadTarballArchive performs requests for "repos/download-tarball-archive"

Download a repository archive (tar).

  GET /repos/{owner}/{repo}/tarball/{ref}

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
func (c Client) ReposDownloadTarballArchive(ctx context.Context, req *ReposDownloadTarballArchiveReq, opt ...options.Option) (*ReposDownloadTarballArchiveResponse, error) {
	return ReposDownloadTarballArchive(ctx, req, append(c, opt...)...)
}

/*
ReposDownloadTarballArchiveReq is request data for Client.ReposDownloadTarballArchive

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
type ReposDownloadTarballArchiveReq struct {
	_url  string
	Owner string
	Repo  string

	// ref parameter
	Ref string
}

// HTTPRequest builds an *http.Request
func (r *ReposDownloadTarballArchiveReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDownloadTarballArchiveReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "repos/download-tarball-archive",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/tarball/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDownloadTarballArchiveReq) Rel(link RelName, resp *ReposDownloadTarballArchiveResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDownloadTarballArchiveResponse is a response for ReposDownloadTarballArchive

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
type ReposDownloadTarballArchiveResponse struct {
	common.Response
	request *ReposDownloadTarballArchiveReq
}

/*
ReposDownloadZipballArchive performs requests for "repos/download-zipball-archive"

Download a repository archive (zip).

  GET /repos/{owner}/{repo}/zipball/{ref}

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
func ReposDownloadZipballArchive(ctx context.Context, req *ReposDownloadZipballArchiveReq, opt ...options.Option) (*ReposDownloadZipballArchiveResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposDownloadZipballArchiveReq)
	}
	resp := &ReposDownloadZipballArchiveResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDownloadZipballArchive performs requests for "repos/download-zipball-archive"

Download a repository archive (zip).

  GET /repos/{owner}/{repo}/zipball/{ref}

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
func (c Client) ReposDownloadZipballArchive(ctx context.Context, req *ReposDownloadZipballArchiveReq, opt ...options.Option) (*ReposDownloadZipballArchiveResponse, error) {
	return ReposDownloadZipballArchive(ctx, req, append(c, opt...)...)
}

/*
ReposDownloadZipballArchiveReq is request data for Client.ReposDownloadZipballArchive

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
type ReposDownloadZipballArchiveReq struct {
	_url  string
	Owner string
	Repo  string

	// ref parameter
	Ref string
}

// HTTPRequest builds an *http.Request
func (r *ReposDownloadZipballArchiveReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposDownloadZipballArchiveReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "repos/download-zipball-archive",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/zipball/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDownloadZipballArchiveReq) Rel(link RelName, resp *ReposDownloadZipballArchiveResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDownloadZipballArchiveResponse is a response for ReposDownloadZipballArchive

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
type ReposDownloadZipballArchiveResponse struct {
	common.Response
	request *ReposDownloadZipballArchiveReq
}

/*
ReposEnableAutomatedSecurityFixes performs requests for "repos/enable-automated-security-fixes"

Enable automated security fixes.

  PUT /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
func ReposEnableAutomatedSecurityFixes(ctx context.Context, req *ReposEnableAutomatedSecurityFixesReq, opt ...options.Option) (*ReposEnableAutomatedSecurityFixesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposEnableAutomatedSecurityFixesReq)
	}
	resp := &ReposEnableAutomatedSecurityFixesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposEnableAutomatedSecurityFixes performs requests for "repos/enable-automated-security-fixes"

Enable automated security fixes.

  PUT /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
func (c Client) ReposEnableAutomatedSecurityFixes(ctx context.Context, req *ReposEnableAutomatedSecurityFixesReq, opt ...options.Option) (*ReposEnableAutomatedSecurityFixesResponse, error) {
	return ReposEnableAutomatedSecurityFixes(ctx, req, append(c, opt...)...)
}

/*
ReposEnableAutomatedSecurityFixesReq is request data for Client.ReposEnableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
type ReposEnableAutomatedSecurityFixesReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling or disabling automated security fixes is currently available for
	developers to preview. To access this new endpoint during the preview period,
	you must set this to true.
	*/
	LondonPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposEnableAutomatedSecurityFixesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposEnableAutomatedSecurityFixesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"london"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "repos/enable-automated-security-fixes",
		Previews:         map[string]bool{"london": r.LondonPreview},
		RequiredPreviews: []string{"london"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/automated-security-fixes", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposEnableAutomatedSecurityFixesReq) Rel(link RelName, resp *ReposEnableAutomatedSecurityFixesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposEnableAutomatedSecurityFixesResponse is a response for ReposEnableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
type ReposEnableAutomatedSecurityFixesResponse struct {
	common.Response
	request *ReposEnableAutomatedSecurityFixesReq
}

/*
ReposEnableVulnerabilityAlerts performs requests for "repos/enable-vulnerability-alerts"

Enable vulnerability alerts.

  PUT /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
func ReposEnableVulnerabilityAlerts(ctx context.Context, req *ReposEnableVulnerabilityAlertsReq, opt ...options.Option) (*ReposEnableVulnerabilityAlertsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposEnableVulnerabilityAlertsReq)
	}
	resp := &ReposEnableVulnerabilityAlertsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposEnableVulnerabilityAlerts performs requests for "repos/enable-vulnerability-alerts"

Enable vulnerability alerts.

  PUT /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
func (c Client) ReposEnableVulnerabilityAlerts(ctx context.Context, req *ReposEnableVulnerabilityAlertsReq, opt ...options.Option) (*ReposEnableVulnerabilityAlertsResponse, error) {
	return ReposEnableVulnerabilityAlerts(ctx, req, append(c, opt...)...)
}

/*
ReposEnableVulnerabilityAlertsReq is request data for Client.ReposEnableVulnerabilityAlerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
type ReposEnableVulnerabilityAlertsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling dependency alerts for a repository using the REST API is
	currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposEnableVulnerabilityAlertsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposEnableVulnerabilityAlertsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"dorian"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "repos/enable-vulnerability-alerts",
		Previews:         map[string]bool{"dorian": r.DorianPreview},
		RequiredPreviews: []string{"dorian"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposEnableVulnerabilityAlertsReq) Rel(link RelName, resp *ReposEnableVulnerabilityAlertsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposEnableVulnerabilityAlertsResponse is a response for ReposEnableVulnerabilityAlerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
type ReposEnableVulnerabilityAlertsResponse struct {
	common.Response
	request *ReposEnableVulnerabilityAlertsReq
}

/*
ReposGet performs requests for "repos/get"

Get a repository.

  GET /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#get-a-repository
*/
func ReposGet(ctx context.Context, req *ReposGetReq, opt ...options.Option) (*ReposGetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetReq)
	}
	resp := &ReposGetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.FullRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGet performs requests for "repos/get"

Get a repository.

  GET /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#get-a-repository
*/
func (c Client) ReposGet(ctx context.Context, req *ReposGetReq, opt ...options.Option) (*ReposGetResponse, error) {
	return ReposGet(ctx, req, append(c, opt...)...)
}

/*
ReposGetReq is request data for Client.ReposGet

https://developer.github.com/v3/repos/#get-a-repository
*/
type ReposGetReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The Codes of Conduct API is currently available for developers to preview.

	To access the API during the preview period, you must set this to true.
	*/
	ScarletWitchPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposGetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"nebula", "scarlet-witch"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "repos/get",
		Previews: map[string]bool{
			"nebula":        r.NebulaPreview,
			"scarlet-witch": r.ScarletWitchPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 301},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReq) Rel(link RelName, resp *ReposGetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetResponse is a response for ReposGet

https://developer.github.com/v3/repos/#get-a-repository
*/
type ReposGetResponse struct {
	common.Response
	request *ReposGetReq
	Data    components.FullRepository
}

/*
ReposGetAccessRestrictions performs requests for "repos/get-access-restrictions"

Get access restrictions.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#get-access-restrictions
*/
func ReposGetAccessRestrictions(ctx context.Context, req *ReposGetAccessRestrictionsReq, opt ...options.Option) (*ReposGetAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetAccessRestrictionsReq)
	}
	resp := &ReposGetAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.BranchRestrictionPolicy{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetAccessRestrictions performs requests for "repos/get-access-restrictions"

Get access restrictions.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#get-access-restrictions
*/
func (c Client) ReposGetAccessRestrictions(ctx context.Context, req *ReposGetAccessRestrictionsReq, opt ...options.Option) (*ReposGetAccessRestrictionsResponse, error) {
	return ReposGetAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposGetAccessRestrictionsReq is request data for Client.ReposGetAccessRestrictions

https://developer.github.com/v3/repos/branches/#get-access-restrictions
*/
type ReposGetAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetAccessRestrictionsReq) Rel(link RelName, resp *ReposGetAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetAccessRestrictionsResponse is a response for ReposGetAccessRestrictions

https://developer.github.com/v3/repos/branches/#get-access-restrictions
*/
type ReposGetAccessRestrictionsResponse struct {
	common.Response
	request *ReposGetAccessRestrictionsReq
	Data    components.BranchRestrictionPolicy
}

/*
ReposGetAdminBranchProtection performs requests for "repos/get-admin-branch-protection"

Get admin branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#get-admin-branch-protection
*/
func ReposGetAdminBranchProtection(ctx context.Context, req *ReposGetAdminBranchProtectionReq, opt ...options.Option) (*ReposGetAdminBranchProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetAdminBranchProtectionReq)
	}
	resp := &ReposGetAdminBranchProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranchAdminEnforced{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetAdminBranchProtection performs requests for "repos/get-admin-branch-protection"

Get admin branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#get-admin-branch-protection
*/
func (c Client) ReposGetAdminBranchProtection(ctx context.Context, req *ReposGetAdminBranchProtectionReq, opt ...options.Option) (*ReposGetAdminBranchProtectionResponse, error) {
	return ReposGetAdminBranchProtection(ctx, req, append(c, opt...)...)
}

/*
ReposGetAdminBranchProtectionReq is request data for Client.ReposGetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#get-admin-branch-protection
*/
type ReposGetAdminBranchProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetAdminBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetAdminBranchProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-admin-branch-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetAdminBranchProtectionReq) Rel(link RelName, resp *ReposGetAdminBranchProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetAdminBranchProtectionResponse is a response for ReposGetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#get-admin-branch-protection
*/
type ReposGetAdminBranchProtectionResponse struct {
	common.Response
	request *ReposGetAdminBranchProtectionReq
	Data    components.ProtectedBranchAdminEnforced
}

/*
ReposGetAllStatusCheckContexts performs requests for "repos/get-all-status-check-contexts"

Get all status check contexts.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
func ReposGetAllStatusCheckContexts(ctx context.Context, req *ReposGetAllStatusCheckContextsReq, opt ...options.Option) (*ReposGetAllStatusCheckContextsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetAllStatusCheckContextsReq)
	}
	resp := &ReposGetAllStatusCheckContextsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ReposGetAllStatusCheckContextsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetAllStatusCheckContexts performs requests for "repos/get-all-status-check-contexts"

Get all status check contexts.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
func (c Client) ReposGetAllStatusCheckContexts(ctx context.Context, req *ReposGetAllStatusCheckContextsReq, opt ...options.Option) (*ReposGetAllStatusCheckContextsResponse, error) {
	return ReposGetAllStatusCheckContexts(ctx, req, append(c, opt...)...)
}

/*
ReposGetAllStatusCheckContextsReq is request data for Client.ReposGetAllStatusCheckContexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
type ReposGetAllStatusCheckContextsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetAllStatusCheckContextsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetAllStatusCheckContextsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-all-status-check-contexts",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetAllStatusCheckContextsReq) Rel(link RelName, resp *ReposGetAllStatusCheckContextsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetAllStatusCheckContextsResponseBody is a response body for ReposGetAllStatusCheckContexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
type ReposGetAllStatusCheckContextsResponseBody []string

/*
ReposGetAllStatusCheckContextsResponse is a response for ReposGetAllStatusCheckContexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
type ReposGetAllStatusCheckContextsResponse struct {
	common.Response
	request *ReposGetAllStatusCheckContextsReq
	Data    ReposGetAllStatusCheckContextsResponseBody
}

/*
ReposGetAllTopics performs requests for "repos/get-all-topics"

Get all repository topics.

  GET /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
func ReposGetAllTopics(ctx context.Context, req *ReposGetAllTopicsReq, opt ...options.Option) (*ReposGetAllTopicsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetAllTopicsReq)
	}
	resp := &ReposGetAllTopicsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Topic{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetAllTopics performs requests for "repos/get-all-topics"

Get all repository topics.

  GET /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
func (c Client) ReposGetAllTopics(ctx context.Context, req *ReposGetAllTopicsReq, opt ...options.Option) (*ReposGetAllTopicsResponse, error) {
	return ReposGetAllTopics(ctx, req, append(c, opt...)...)
}

/*
ReposGetAllTopicsReq is request data for Client.ReposGetAllTopics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
type ReposGetAllTopicsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposGetAllTopicsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetAllTopicsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"mercy"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-all-topics",
		Previews:         map[string]bool{"mercy": r.MercyPreview},
		RequiredPreviews: []string{"mercy"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/topics", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetAllTopicsReq) Rel(link RelName, resp *ReposGetAllTopicsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetAllTopicsResponse is a response for ReposGetAllTopics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
type ReposGetAllTopicsResponse struct {
	common.Response
	request *ReposGetAllTopicsReq
	Data    components.Topic
}

/*
ReposGetAppsWithAccessToProtectedBranch performs requests for "repos/get-apps-with-access-to-protected-branch"

Get apps with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-the-protected-branch
*/
func ReposGetAppsWithAccessToProtectedBranch(ctx context.Context, req *ReposGetAppsWithAccessToProtectedBranchReq, opt ...options.Option) (*ReposGetAppsWithAccessToProtectedBranchResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetAppsWithAccessToProtectedBranchReq)
	}
	resp := &ReposGetAppsWithAccessToProtectedBranchResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Integration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetAppsWithAccessToProtectedBranch performs requests for "repos/get-apps-with-access-to-protected-branch"

Get apps with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-the-protected-branch
*/
func (c Client) ReposGetAppsWithAccessToProtectedBranch(ctx context.Context, req *ReposGetAppsWithAccessToProtectedBranchReq, opt ...options.Option) (*ReposGetAppsWithAccessToProtectedBranchResponse, error) {
	return ReposGetAppsWithAccessToProtectedBranch(ctx, req, append(c, opt...)...)
}

/*
ReposGetAppsWithAccessToProtectedBranchReq is request data for Client.ReposGetAppsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-the-protected-branch
*/
type ReposGetAppsWithAccessToProtectedBranchReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetAppsWithAccessToProtectedBranchReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-apps-with-access-to-protected-branch",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetAppsWithAccessToProtectedBranchReq) Rel(link RelName, resp *ReposGetAppsWithAccessToProtectedBranchResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetAppsWithAccessToProtectedBranchResponse is a response for ReposGetAppsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-the-protected-branch
*/
type ReposGetAppsWithAccessToProtectedBranchResponse struct {
	common.Response
	request *ReposGetAppsWithAccessToProtectedBranchReq
	Data    []components.Integration
}

/*
ReposGetBranch performs requests for "repos/get-branch"

Get a branch.

  GET /repos/{owner}/{repo}/branches/{branch}

https://developer.github.com/v3/repos/branches/#get-a-branch
*/
func ReposGetBranch(ctx context.Context, req *ReposGetBranchReq, opt ...options.Option) (*ReposGetBranchResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetBranchReq)
	}
	resp := &ReposGetBranchResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.BranchWithProtection{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetBranch performs requests for "repos/get-branch"

Get a branch.

  GET /repos/{owner}/{repo}/branches/{branch}

https://developer.github.com/v3/repos/branches/#get-a-branch
*/
func (c Client) ReposGetBranch(ctx context.Context, req *ReposGetBranchReq, opt ...options.Option) (*ReposGetBranchResponse, error) {
	return ReposGetBranch(ctx, req, append(c, opt...)...)
}

/*
ReposGetBranchReq is request data for Client.ReposGetBranch

https://developer.github.com/v3/repos/branches/#get-a-branch
*/
type ReposGetBranchReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetBranchReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetBranchReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-branch",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetBranchReq) Rel(link RelName, resp *ReposGetBranchResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetBranchResponse is a response for ReposGetBranch

https://developer.github.com/v3/repos/branches/#get-a-branch
*/
type ReposGetBranchResponse struct {
	common.Response
	request *ReposGetBranchReq
	Data    components.BranchWithProtection
}

/*
ReposGetBranchProtection performs requests for "repos/get-branch-protection"

Get branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
func ReposGetBranchProtection(ctx context.Context, req *ReposGetBranchProtectionReq, opt ...options.Option) (*ReposGetBranchProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetBranchProtectionReq)
	}
	resp := &ReposGetBranchProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.BranchProtection{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetBranchProtection performs requests for "repos/get-branch-protection"

Get branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
func (c Client) ReposGetBranchProtection(ctx context.Context, req *ReposGetBranchProtectionReq, opt ...options.Option) (*ReposGetBranchProtectionResponse, error) {
	return ReposGetBranchProtection(ctx, req, append(c, opt...)...)
}

/*
ReposGetBranchProtectionReq is request data for Client.ReposGetBranchProtection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
type ReposGetBranchProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposGetBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetBranchProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"luke-cage"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-branch-protection",
		Previews:         map[string]bool{"luke-cage": r.LukeCagePreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetBranchProtectionReq) Rel(link RelName, resp *ReposGetBranchProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetBranchProtectionResponse is a response for ReposGetBranchProtection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
type ReposGetBranchProtectionResponse struct {
	common.Response
	request *ReposGetBranchProtectionReq
	Data    components.BranchProtection
}

/*
ReposGetClones performs requests for "repos/get-clones"

Get repository clones.

  GET /repos/{owner}/{repo}/traffic/clones

https://developer.github.com/v3/repos/traffic/#get-repository-clones
*/
func ReposGetClones(ctx context.Context, req *ReposGetClonesReq, opt ...options.Option) (*ReposGetClonesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetClonesReq)
	}
	resp := &ReposGetClonesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CloneTraffic{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetClones performs requests for "repos/get-clones"

Get repository clones.

  GET /repos/{owner}/{repo}/traffic/clones

https://developer.github.com/v3/repos/traffic/#get-repository-clones
*/
func (c Client) ReposGetClones(ctx context.Context, req *ReposGetClonesReq, opt ...options.Option) (*ReposGetClonesResponse, error) {
	return ReposGetClones(ctx, req, append(c, opt...)...)
}

/*
ReposGetClonesReq is request data for Client.ReposGetClones

https://developer.github.com/v3/repos/traffic/#get-repository-clones
*/
type ReposGetClonesReq struct {
	_url  string
	Owner string
	Repo  string

	// Must be one of: `day`, `week`.
	Per *string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetClonesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetClonesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Per != nil {
		query.Set("per", *r.Per)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-clones",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/traffic/clones", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetClonesReq) Rel(link RelName, resp *ReposGetClonesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetClonesResponse is a response for ReposGetClones

https://developer.github.com/v3/repos/traffic/#get-repository-clones
*/
type ReposGetClonesResponse struct {
	common.Response
	request *ReposGetClonesReq
	Data    components.CloneTraffic
}

/*
ReposGetCodeFrequencyStats performs requests for "repos/get-code-frequency-stats"

Get the weekly commit activity.

  GET /repos/{owner}/{repo}/stats/code_frequency

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-activity
*/
func ReposGetCodeFrequencyStats(ctx context.Context, req *ReposGetCodeFrequencyStatsReq, opt ...options.Option) (*ReposGetCodeFrequencyStatsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetCodeFrequencyStatsReq)
	}
	resp := &ReposGetCodeFrequencyStatsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CodeFrequencyStat{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCodeFrequencyStats performs requests for "repos/get-code-frequency-stats"

Get the weekly commit activity.

  GET /repos/{owner}/{repo}/stats/code_frequency

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-activity
*/
func (c Client) ReposGetCodeFrequencyStats(ctx context.Context, req *ReposGetCodeFrequencyStatsReq, opt ...options.Option) (*ReposGetCodeFrequencyStatsResponse, error) {
	return ReposGetCodeFrequencyStats(ctx, req, append(c, opt...)...)
}

/*
ReposGetCodeFrequencyStatsReq is request data for Client.ReposGetCodeFrequencyStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-activity
*/
type ReposGetCodeFrequencyStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCodeFrequencyStatsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetCodeFrequencyStatsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-code-frequency-stats",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/stats/code_frequency", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCodeFrequencyStatsReq) Rel(link RelName, resp *ReposGetCodeFrequencyStatsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCodeFrequencyStatsResponse is a response for ReposGetCodeFrequencyStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-activity
*/
type ReposGetCodeFrequencyStatsResponse struct {
	common.Response
	request *ReposGetCodeFrequencyStatsReq
	Data    []components.CodeFrequencyStat
}

/*
ReposGetCollaboratorPermissionLevel performs requests for "repos/get-collaborator-permission-level"

Get repository permissions for a user.

  GET /repos/{owner}/{repo}/collaborators/{username}/permission

https://developer.github.com/v3/repos/collaborators/#get-repository-permissions-for-a-user
*/
func ReposGetCollaboratorPermissionLevel(ctx context.Context, req *ReposGetCollaboratorPermissionLevelReq, opt ...options.Option) (*ReposGetCollaboratorPermissionLevelResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetCollaboratorPermissionLevelReq)
	}
	resp := &ReposGetCollaboratorPermissionLevelResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.RepositoryCollaboratorPermission{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCollaboratorPermissionLevel performs requests for "repos/get-collaborator-permission-level"

Get repository permissions for a user.

  GET /repos/{owner}/{repo}/collaborators/{username}/permission

https://developer.github.com/v3/repos/collaborators/#get-repository-permissions-for-a-user
*/
func (c Client) ReposGetCollaboratorPermissionLevel(ctx context.Context, req *ReposGetCollaboratorPermissionLevelReq, opt ...options.Option) (*ReposGetCollaboratorPermissionLevelResponse, error) {
	return ReposGetCollaboratorPermissionLevel(ctx, req, append(c, opt...)...)
}

/*
ReposGetCollaboratorPermissionLevelReq is request data for Client.ReposGetCollaboratorPermissionLevel

https://developer.github.com/v3/repos/collaborators/#get-repository-permissions-for-a-user
*/
type ReposGetCollaboratorPermissionLevelReq struct {
	_url     string
	Owner    string
	Repo     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCollaboratorPermissionLevelReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetCollaboratorPermissionLevelReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-collaborator-permission-level",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/collaborators/%v/permission", r.Owner, r.Repo, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCollaboratorPermissionLevelReq) Rel(link RelName, resp *ReposGetCollaboratorPermissionLevelResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCollaboratorPermissionLevelResponse is a response for ReposGetCollaboratorPermissionLevel

https://developer.github.com/v3/repos/collaborators/#get-repository-permissions-for-a-user
*/
type ReposGetCollaboratorPermissionLevelResponse struct {
	common.Response
	request *ReposGetCollaboratorPermissionLevelReq
	Data    components.RepositoryCollaboratorPermission
}

/*
ReposGetCombinedStatusForRef performs requests for "repos/get-combined-status-for-ref"

Get the combined status for a specific reference.

  GET /repos/{owner}/{repo}/commits/{ref}/status

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-reference
*/
func ReposGetCombinedStatusForRef(ctx context.Context, req *ReposGetCombinedStatusForRefReq, opt ...options.Option) (*ReposGetCombinedStatusForRefResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetCombinedStatusForRefReq)
	}
	resp := &ReposGetCombinedStatusForRefResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CombinedCommitStatus{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCombinedStatusForRef performs requests for "repos/get-combined-status-for-ref"

Get the combined status for a specific reference.

  GET /repos/{owner}/{repo}/commits/{ref}/status

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-reference
*/
func (c Client) ReposGetCombinedStatusForRef(ctx context.Context, req *ReposGetCombinedStatusForRefReq, opt ...options.Option) (*ReposGetCombinedStatusForRefResponse, error) {
	return ReposGetCombinedStatusForRef(ctx, req, append(c, opt...)...)
}

/*
ReposGetCombinedStatusForRefReq is request data for Client.ReposGetCombinedStatusForRef

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-reference
*/
type ReposGetCombinedStatusForRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCombinedStatusForRefReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetCombinedStatusForRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-combined-status-for-ref",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/status", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCombinedStatusForRefReq) Rel(link RelName, resp *ReposGetCombinedStatusForRefResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCombinedStatusForRefResponse is a response for ReposGetCombinedStatusForRef

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-reference
*/
type ReposGetCombinedStatusForRefResponse struct {
	common.Response
	request *ReposGetCombinedStatusForRefReq
	Data    components.CombinedCommitStatus
}

/*
ReposGetCommit performs requests for "repos/get-commit"

Get a commit.

  GET /repos/{owner}/{repo}/commits/{ref}

https://developer.github.com/v3/repos/commits/#get-a-commit
*/
func ReposGetCommit(ctx context.Context, req *ReposGetCommitReq, opt ...options.Option) (*ReposGetCommitResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetCommitReq)
	}
	resp := &ReposGetCommitResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Commit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCommit performs requests for "repos/get-commit"

Get a commit.

  GET /repos/{owner}/{repo}/commits/{ref}

https://developer.github.com/v3/repos/commits/#get-a-commit
*/
func (c Client) ReposGetCommit(ctx context.Context, req *ReposGetCommitReq, opt ...options.Option) (*ReposGetCommitResponse, error) {
	return ReposGetCommit(ctx, req, append(c, opt...)...)
}

/*
ReposGetCommitReq is request data for Client.ReposGetCommit

https://developer.github.com/v3/repos/commits/#get-a-commit
*/
type ReposGetCommitReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCommitReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetCommitReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-commit",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCommitReq) Rel(link RelName, resp *ReposGetCommitResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCommitResponse is a response for ReposGetCommit

https://developer.github.com/v3/repos/commits/#get-a-commit
*/
type ReposGetCommitResponse struct {
	common.Response
	request *ReposGetCommitReq
	Data    components.Commit
}

/*
ReposGetCommitActivityStats performs requests for "repos/get-commit-activity-stats"

Get the last year of commit activity.

  GET /repos/{owner}/{repo}/stats/commit_activity

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity
*/
func ReposGetCommitActivityStats(ctx context.Context, req *ReposGetCommitActivityStatsReq, opt ...options.Option) (*ReposGetCommitActivityStatsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetCommitActivityStatsReq)
	}
	resp := &ReposGetCommitActivityStatsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CommitActivity{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCommitActivityStats performs requests for "repos/get-commit-activity-stats"

Get the last year of commit activity.

  GET /repos/{owner}/{repo}/stats/commit_activity

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity
*/
func (c Client) ReposGetCommitActivityStats(ctx context.Context, req *ReposGetCommitActivityStatsReq, opt ...options.Option) (*ReposGetCommitActivityStatsResponse, error) {
	return ReposGetCommitActivityStats(ctx, req, append(c, opt...)...)
}

/*
ReposGetCommitActivityStatsReq is request data for Client.ReposGetCommitActivityStats

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity
*/
type ReposGetCommitActivityStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCommitActivityStatsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetCommitActivityStatsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-commit-activity-stats",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/stats/commit_activity", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCommitActivityStatsReq) Rel(link RelName, resp *ReposGetCommitActivityStatsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCommitActivityStatsResponse is a response for ReposGetCommitActivityStats

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity
*/
type ReposGetCommitActivityStatsResponse struct {
	common.Response
	request *ReposGetCommitActivityStatsReq
	Data    []components.CommitActivity
}

/*
ReposGetCommitComment performs requests for "repos/get-commit-comment"

Get a commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#get-a-commit-comment
*/
func ReposGetCommitComment(ctx context.Context, req *ReposGetCommitCommentReq, opt ...options.Option) (*ReposGetCommitCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetCommitCommentReq)
	}
	resp := &ReposGetCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CommitComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCommitComment performs requests for "repos/get-commit-comment"

Get a commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#get-a-commit-comment
*/
func (c Client) ReposGetCommitComment(ctx context.Context, req *ReposGetCommitCommentReq, opt ...options.Option) (*ReposGetCommitCommentResponse, error) {
	return ReposGetCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReposGetCommitCommentReq is request data for Client.ReposGetCommitComment

https://developer.github.com/v3/repos/comments/#get-a-commit-comment
*/
type ReposGetCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCommitCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-commit-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCommitCommentReq) Rel(link RelName, resp *ReposGetCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCommitCommentResponse is a response for ReposGetCommitComment

https://developer.github.com/v3/repos/comments/#get-a-commit-comment
*/
type ReposGetCommitCommentResponse struct {
	common.Response
	request *ReposGetCommitCommentReq
	Data    components.CommitComment
}

/*
ReposGetCommitSignatureProtection performs requests for "repos/get-commit-signature-protection"

Get commit signature protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#get-commit-signature-protection
*/
func ReposGetCommitSignatureProtection(ctx context.Context, req *ReposGetCommitSignatureProtectionReq, opt ...options.Option) (*ReposGetCommitSignatureProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetCommitSignatureProtectionReq)
	}
	resp := &ReposGetCommitSignatureProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranchAdminEnforced{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCommitSignatureProtection performs requests for "repos/get-commit-signature-protection"

Get commit signature protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#get-commit-signature-protection
*/
func (c Client) ReposGetCommitSignatureProtection(ctx context.Context, req *ReposGetCommitSignatureProtectionReq, opt ...options.Option) (*ReposGetCommitSignatureProtectionResponse, error) {
	return ReposGetCommitSignatureProtection(ctx, req, append(c, opt...)...)
}

/*
ReposGetCommitSignatureProtectionReq is request data for Client.ReposGetCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#get-commit-signature-protection
*/
type ReposGetCommitSignatureProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCommitSignatureProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetCommitSignatureProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"zzzax"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-commit-signature-protection",
		Previews:         map[string]bool{"zzzax": r.ZzzaxPreview},
		RequiredPreviews: []string{"zzzax"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCommitSignatureProtectionReq) Rel(link RelName, resp *ReposGetCommitSignatureProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCommitSignatureProtectionResponse is a response for ReposGetCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#get-commit-signature-protection
*/
type ReposGetCommitSignatureProtectionResponse struct {
	common.Response
	request *ReposGetCommitSignatureProtectionReq
	Data    components.ProtectedBranchAdminEnforced
}

/*
ReposGetCommunityProfileMetrics performs requests for "repos/get-community-profile-metrics"

Get community profile metrics.

  GET /repos/{owner}/{repo}/community/profile

https://developer.github.com/v3/repos/community/#get-community-profile-metrics
*/
func ReposGetCommunityProfileMetrics(ctx context.Context, req *ReposGetCommunityProfileMetricsReq, opt ...options.Option) (*ReposGetCommunityProfileMetricsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetCommunityProfileMetricsReq)
	}
	resp := &ReposGetCommunityProfileMetricsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CommunityProfile{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCommunityProfileMetrics performs requests for "repos/get-community-profile-metrics"

Get community profile metrics.

  GET /repos/{owner}/{repo}/community/profile

https://developer.github.com/v3/repos/community/#get-community-profile-metrics
*/
func (c Client) ReposGetCommunityProfileMetrics(ctx context.Context, req *ReposGetCommunityProfileMetricsReq, opt ...options.Option) (*ReposGetCommunityProfileMetricsResponse, error) {
	return ReposGetCommunityProfileMetrics(ctx, req, append(c, opt...)...)
}

/*
ReposGetCommunityProfileMetricsReq is request data for Client.ReposGetCommunityProfileMetrics

https://developer.github.com/v3/repos/community/#get-community-profile-metrics
*/
type ReposGetCommunityProfileMetricsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	We're currently offering a preview of the Community Profile API (also known as
	community health). To access the API during the preview period, you must set
	this to true.
	*/
	BlackPantherPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCommunityProfileMetricsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetCommunityProfileMetricsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"black-panther"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-community-profile-metrics",
		Previews:         map[string]bool{"black-panther": r.BlackPantherPreview},
		RequiredPreviews: []string{"black-panther"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/community/profile", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCommunityProfileMetricsReq) Rel(link RelName, resp *ReposGetCommunityProfileMetricsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCommunityProfileMetricsResponse is a response for ReposGetCommunityProfileMetrics

https://developer.github.com/v3/repos/community/#get-community-profile-metrics
*/
type ReposGetCommunityProfileMetricsResponse struct {
	common.Response
	request *ReposGetCommunityProfileMetricsReq
	Data    components.CommunityProfile
}

/*
ReposGetContent performs requests for "repos/get-content"

Get repository content.

  GET /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
func ReposGetContent(ctx context.Context, req *ReposGetContentReq, opt ...options.Option) (*ReposGetContentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetContentReq)
	}
	resp := &ReposGetContentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ReposGetContentResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetContent performs requests for "repos/get-content"

Get repository content.

  GET /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
func (c Client) ReposGetContent(ctx context.Context, req *ReposGetContentReq, opt ...options.Option) (*ReposGetContentResponse, error) {
	return ReposGetContent(ctx, req, append(c, opt...)...)
}

/*
ReposGetContentReq is request data for Client.ReposGetContent

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
type ReposGetContentReq struct {
	_url  string
	Owner string
	Repo  string

	// path+ parameter
	Path string

	/*
	The name of the commit/branch/tag. Default: the repositorys default branch
	(usually `master`)
	*/
	Ref *string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetContentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetContentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-content",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path),
		URLQuery:         query,
		ValidStatuses:    []int{200, 302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetContentReq) Rel(link RelName, resp *ReposGetContentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetContentResponseBody is a response body for ReposGetContent

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
type ReposGetContentResponseBody struct {
	oneOfField string

	// A list of directory items
	contentDirectory components.ContentDirectory

	// Content File
	contentFile components.ContentFile

	// An object describing a symlink
	contentSymlink components.ContentSymlink

	// An object describing a symlink
	contentSubmodule components.ContentSubmodule
}

// Value returns ReposGetContentResponseBody's value. The type will be one of ContentDirectory, ContentFile, ContentSymlink or ContentSubmodule.
func (c *ReposGetContentResponseBody) Value() interface{} {
	switch c.oneOfField {
	case "contentDirectory":
		return c.contentDirectory
	case "contentFile":
		return c.contentFile
	case "contentSymlink":
		return c.contentSymlink
	case "contentSubmodule":
		return c.contentSubmodule
	}
	return nil
}

// SetValue sets ReposGetContentResponseBody's value. The type must be one of ContentDirectory, ContentFile, ContentSymlink or ContentSubmodule.
func (c *ReposGetContentResponseBody) SetValue(value interface{}) {
	switch v := value.(type) {
	case components.ContentDirectory:
		c.contentDirectory = v
	case components.ContentFile:
		c.contentFile = v
	case components.ContentSymlink:
		c.contentSymlink = v
	case components.ContentSubmodule:
		c.contentSubmodule = v
	default:
		panic("type not acceptable")
	}
}

func (c *ReposGetContentResponseBody) MarshalJSON() ([]byte, error) {
	switch c.oneOfField {
	case "contentDirectory":
		return json.Marshal(&c.contentDirectory)
	case "contentFile":
		return json.Marshal(&c.contentFile)
	case "contentSymlink":
		return json.Marshal(&c.contentSymlink)
	case "contentSubmodule":
		return json.Marshal(&c.contentSubmodule)
	}
	return json.Marshal(interface{}(nil))
}

func (c *ReposGetContentResponseBody) UnmarshalJSON(data []byte) error {
	var err error
	err = json.Unmarshal(data, &c.contentDirectory)
	if err == nil {
		c.oneOfField = "contentDirectory"
		return nil
	}
	err = json.Unmarshal(data, &c.contentFile)
	if err == nil {
		c.oneOfField = "contentFile"
		return nil
	}
	err = json.Unmarshal(data, &c.contentSymlink)
	if err == nil {
		c.oneOfField = "contentSymlink"
		return nil
	}
	err = json.Unmarshal(data, &c.contentSubmodule)
	if err == nil {
		c.oneOfField = "contentSubmodule"
		return nil
	}
	return fmt.Errorf("could not unmarshal json")
}

/*
ReposGetContentResponse is a response for ReposGetContent

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
type ReposGetContentResponse struct {
	common.Response
	request *ReposGetContentReq
	Data    ReposGetContentResponseBody
}

/*
ReposGetContributorsStats performs requests for "repos/get-contributors-stats"

Get all contributor commit activity.

  GET /repos/{owner}/{repo}/stats/contributors

https://developer.github.com/v3/repos/statistics/#get-all-contributor-commit-activity
*/
func ReposGetContributorsStats(ctx context.Context, req *ReposGetContributorsStatsReq, opt ...options.Option) (*ReposGetContributorsStatsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetContributorsStatsReq)
	}
	resp := &ReposGetContributorsStatsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ContributorActivity{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetContributorsStats performs requests for "repos/get-contributors-stats"

Get all contributor commit activity.

  GET /repos/{owner}/{repo}/stats/contributors

https://developer.github.com/v3/repos/statistics/#get-all-contributor-commit-activity
*/
func (c Client) ReposGetContributorsStats(ctx context.Context, req *ReposGetContributorsStatsReq, opt ...options.Option) (*ReposGetContributorsStatsResponse, error) {
	return ReposGetContributorsStats(ctx, req, append(c, opt...)...)
}

/*
ReposGetContributorsStatsReq is request data for Client.ReposGetContributorsStats

https://developer.github.com/v3/repos/statistics/#get-all-contributor-commit-activity
*/
type ReposGetContributorsStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetContributorsStatsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetContributorsStatsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-contributors-stats",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/stats/contributors", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetContributorsStatsReq) Rel(link RelName, resp *ReposGetContributorsStatsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetContributorsStatsResponse is a response for ReposGetContributorsStats

https://developer.github.com/v3/repos/statistics/#get-all-contributor-commit-activity
*/
type ReposGetContributorsStatsResponse struct {
	common.Response
	request *ReposGetContributorsStatsReq
	Data    []components.ContributorActivity
}

/*
ReposGetDeployKey performs requests for "repos/get-deploy-key"

Get a deploy key.

  GET /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
func ReposGetDeployKey(ctx context.Context, req *ReposGetDeployKeyReq, opt ...options.Option) (*ReposGetDeployKeyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetDeployKeyReq)
	}
	resp := &ReposGetDeployKeyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.DeployKey{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetDeployKey performs requests for "repos/get-deploy-key"

Get a deploy key.

  GET /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
func (c Client) ReposGetDeployKey(ctx context.Context, req *ReposGetDeployKeyReq, opt ...options.Option) (*ReposGetDeployKeyResponse, error) {
	return ReposGetDeployKey(ctx, req, append(c, opt...)...)
}

/*
ReposGetDeployKeyReq is request data for Client.ReposGetDeployKey

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
type ReposGetDeployKeyReq struct {
	_url  string
	Owner string
	Repo  string

	// key_id parameter
	KeyId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposGetDeployKeyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetDeployKeyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-deploy-key",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/keys/%v", r.Owner, r.Repo, r.KeyId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetDeployKeyReq) Rel(link RelName, resp *ReposGetDeployKeyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetDeployKeyResponse is a response for ReposGetDeployKey

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
type ReposGetDeployKeyResponse struct {
	common.Response
	request *ReposGetDeployKeyReq
	Data    components.DeployKey
}

/*
ReposGetDeployment performs requests for "repos/get-deployment"

Get a deployment.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#get-a-deployment
*/
func ReposGetDeployment(ctx context.Context, req *ReposGetDeploymentReq, opt ...options.Option) (*ReposGetDeploymentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetDeploymentReq)
	}
	resp := &ReposGetDeploymentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Deployment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetDeployment performs requests for "repos/get-deployment"

Get a deployment.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#get-a-deployment
*/
func (c Client) ReposGetDeployment(ctx context.Context, req *ReposGetDeploymentReq, opt ...options.Option) (*ReposGetDeploymentResponse, error) {
	return ReposGetDeployment(ctx, req, append(c, opt...)...)
}

/*
ReposGetDeploymentReq is request data for Client.ReposGetDeployment

https://developer.github.com/v3/repos/deployments/#get-a-deployment
*/
type ReposGetDeploymentReq struct {
	_url  string
	Owner string
	Repo  string

	// deployment_id parameter
	DeploymentId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposGetDeploymentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetDeploymentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man", "ant-man"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "repos/get-deployment",
		Previews: map[string]bool{
			"ant-man":     r.AntManPreview,
			"machine-man": r.MachineManPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments/%v", r.Owner, r.Repo, r.DeploymentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetDeploymentReq) Rel(link RelName, resp *ReposGetDeploymentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetDeploymentResponse is a response for ReposGetDeployment

https://developer.github.com/v3/repos/deployments/#get-a-deployment
*/
type ReposGetDeploymentResponse struct {
	common.Response
	request *ReposGetDeploymentReq
	Data    components.Deployment
}

/*
ReposGetDeploymentStatus performs requests for "repos/get-deployment-status"

Get a deployment status.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}

https://developer.github.com/v3/repos/deployments/#get-a-deployment-status
*/
func ReposGetDeploymentStatus(ctx context.Context, req *ReposGetDeploymentStatusReq, opt ...options.Option) (*ReposGetDeploymentStatusResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetDeploymentStatusReq)
	}
	resp := &ReposGetDeploymentStatusResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.DeploymentStatus{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetDeploymentStatus performs requests for "repos/get-deployment-status"

Get a deployment status.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}

https://developer.github.com/v3/repos/deployments/#get-a-deployment-status
*/
func (c Client) ReposGetDeploymentStatus(ctx context.Context, req *ReposGetDeploymentStatusReq, opt ...options.Option) (*ReposGetDeploymentStatusResponse, error) {
	return ReposGetDeploymentStatus(ctx, req, append(c, opt...)...)
}

/*
ReposGetDeploymentStatusReq is request data for Client.ReposGetDeploymentStatus

https://developer.github.com/v3/repos/deployments/#get-a-deployment-status
*/
type ReposGetDeploymentStatusReq struct {
	_url  string
	Owner string
	Repo  string

	// deployment_id parameter
	DeploymentId int64

	// status_id parameter
	StatusId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposGetDeploymentStatusReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetDeploymentStatusReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man", "flash", "ant-man"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "repos/get-deployment-status",
		Previews: map[string]bool{
			"ant-man":     r.AntManPreview,
			"flash":       r.FlashPreview,
			"machine-man": r.MachineManPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses/%v", r.Owner, r.Repo, r.DeploymentId, r.StatusId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetDeploymentStatusReq) Rel(link RelName, resp *ReposGetDeploymentStatusResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetDeploymentStatusResponse is a response for ReposGetDeploymentStatus

https://developer.github.com/v3/repos/deployments/#get-a-deployment-status
*/
type ReposGetDeploymentStatusResponse struct {
	common.Response
	request *ReposGetDeploymentStatusReq
	Data    components.DeploymentStatus
}

/*
ReposGetLatestPagesBuild performs requests for "repos/get-latest-pages-build"

Get latest Pages build.

  GET /repos/{owner}/{repo}/pages/builds/latest

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
func ReposGetLatestPagesBuild(ctx context.Context, req *ReposGetLatestPagesBuildReq, opt ...options.Option) (*ReposGetLatestPagesBuildResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetLatestPagesBuildReq)
	}
	resp := &ReposGetLatestPagesBuildResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PageBuild{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetLatestPagesBuild performs requests for "repos/get-latest-pages-build"

Get latest Pages build.

  GET /repos/{owner}/{repo}/pages/builds/latest

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
func (c Client) ReposGetLatestPagesBuild(ctx context.Context, req *ReposGetLatestPagesBuildReq, opt ...options.Option) (*ReposGetLatestPagesBuildResponse, error) {
	return ReposGetLatestPagesBuild(ctx, req, append(c, opt...)...)
}

/*
ReposGetLatestPagesBuildReq is request data for Client.ReposGetLatestPagesBuild

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
type ReposGetLatestPagesBuildReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetLatestPagesBuildReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetLatestPagesBuildReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-latest-pages-build",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages/builds/latest", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetLatestPagesBuildReq) Rel(link RelName, resp *ReposGetLatestPagesBuildResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetLatestPagesBuildResponse is a response for ReposGetLatestPagesBuild

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
type ReposGetLatestPagesBuildResponse struct {
	common.Response
	request *ReposGetLatestPagesBuildReq
	Data    components.PageBuild
}

/*
ReposGetLatestRelease performs requests for "repos/get-latest-release"

Get the latest release.

  GET /repos/{owner}/{repo}/releases/latest

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
func ReposGetLatestRelease(ctx context.Context, req *ReposGetLatestReleaseReq, opt ...options.Option) (*ReposGetLatestReleaseResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetLatestReleaseReq)
	}
	resp := &ReposGetLatestReleaseResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Release{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetLatestRelease performs requests for "repos/get-latest-release"

Get the latest release.

  GET /repos/{owner}/{repo}/releases/latest

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
func (c Client) ReposGetLatestRelease(ctx context.Context, req *ReposGetLatestReleaseReq, opt ...options.Option) (*ReposGetLatestReleaseResponse, error) {
	return ReposGetLatestRelease(ctx, req, append(c, opt...)...)
}

/*
ReposGetLatestReleaseReq is request data for Client.ReposGetLatestRelease

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
type ReposGetLatestReleaseReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetLatestReleaseReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetLatestReleaseReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-latest-release",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/latest", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetLatestReleaseReq) Rel(link RelName, resp *ReposGetLatestReleaseResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetLatestReleaseResponse is a response for ReposGetLatestRelease

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
type ReposGetLatestReleaseResponse struct {
	common.Response
	request *ReposGetLatestReleaseReq
	Data    components.Release
}

/*
ReposGetPages performs requests for "repos/get-pages"

Get a GitHub Pages site.

  GET /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#get-a-github-pages-site
*/
func ReposGetPages(ctx context.Context, req *ReposGetPagesReq, opt ...options.Option) (*ReposGetPagesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetPagesReq)
	}
	resp := &ReposGetPagesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Page{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetPages performs requests for "repos/get-pages"

Get a GitHub Pages site.

  GET /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#get-a-github-pages-site
*/
func (c Client) ReposGetPages(ctx context.Context, req *ReposGetPagesReq, opt ...options.Option) (*ReposGetPagesResponse, error) {
	return ReposGetPages(ctx, req, append(c, opt...)...)
}

/*
ReposGetPagesReq is request data for Client.ReposGetPages

https://developer.github.com/v3/repos/pages/#get-a-github-pages-site
*/
type ReposGetPagesReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetPagesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetPagesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-pages",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetPagesReq) Rel(link RelName, resp *ReposGetPagesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetPagesResponse is a response for ReposGetPages

https://developer.github.com/v3/repos/pages/#get-a-github-pages-site
*/
type ReposGetPagesResponse struct {
	common.Response
	request *ReposGetPagesReq
	Data    components.Page
}

/*
ReposGetPagesBuild performs requests for "repos/get-pages-build"

Get GitHub Pages build.

  GET /repos/{owner}/{repo}/pages/builds/{build_id}

https://developer.github.com/v3/repos/pages/#get-github-pages-build
*/
func ReposGetPagesBuild(ctx context.Context, req *ReposGetPagesBuildReq, opt ...options.Option) (*ReposGetPagesBuildResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetPagesBuildReq)
	}
	resp := &ReposGetPagesBuildResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PageBuild{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetPagesBuild performs requests for "repos/get-pages-build"

Get GitHub Pages build.

  GET /repos/{owner}/{repo}/pages/builds/{build_id}

https://developer.github.com/v3/repos/pages/#get-github-pages-build
*/
func (c Client) ReposGetPagesBuild(ctx context.Context, req *ReposGetPagesBuildReq, opt ...options.Option) (*ReposGetPagesBuildResponse, error) {
	return ReposGetPagesBuild(ctx, req, append(c, opt...)...)
}

/*
ReposGetPagesBuildReq is request data for Client.ReposGetPagesBuild

https://developer.github.com/v3/repos/pages/#get-github-pages-build
*/
type ReposGetPagesBuildReq struct {
	_url  string
	Owner string
	Repo  string

	// build_id parameter
	BuildId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposGetPagesBuildReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetPagesBuildReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-pages-build",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages/builds/%v", r.Owner, r.Repo, r.BuildId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetPagesBuildReq) Rel(link RelName, resp *ReposGetPagesBuildResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetPagesBuildResponse is a response for ReposGetPagesBuild

https://developer.github.com/v3/repos/pages/#get-github-pages-build
*/
type ReposGetPagesBuildResponse struct {
	common.Response
	request *ReposGetPagesBuildReq
	Data    components.PageBuild
}

/*
ReposGetParticipationStats performs requests for "repos/get-participation-stats"

Get the weekly commit count.

  GET /repos/{owner}/{repo}/stats/participation

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count
*/
func ReposGetParticipationStats(ctx context.Context, req *ReposGetParticipationStatsReq, opt ...options.Option) (*ReposGetParticipationStatsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetParticipationStatsReq)
	}
	resp := &ReposGetParticipationStatsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ParticipationStats{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetParticipationStats performs requests for "repos/get-participation-stats"

Get the weekly commit count.

  GET /repos/{owner}/{repo}/stats/participation

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count
*/
func (c Client) ReposGetParticipationStats(ctx context.Context, req *ReposGetParticipationStatsReq, opt ...options.Option) (*ReposGetParticipationStatsResponse, error) {
	return ReposGetParticipationStats(ctx, req, append(c, opt...)...)
}

/*
ReposGetParticipationStatsReq is request data for Client.ReposGetParticipationStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count
*/
type ReposGetParticipationStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetParticipationStatsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetParticipationStatsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-participation-stats",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/stats/participation", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetParticipationStatsReq) Rel(link RelName, resp *ReposGetParticipationStatsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetParticipationStatsResponse is a response for ReposGetParticipationStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count
*/
type ReposGetParticipationStatsResponse struct {
	common.Response
	request *ReposGetParticipationStatsReq
	Data    components.ParticipationStats
}

/*
ReposGetPullRequestReviewProtection performs requests for "repos/get-pull-request-review-protection"

Get pull request review protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#get-pull-request-review-protection
*/
func ReposGetPullRequestReviewProtection(ctx context.Context, req *ReposGetPullRequestReviewProtectionReq, opt ...options.Option) (*ReposGetPullRequestReviewProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetPullRequestReviewProtectionReq)
	}
	resp := &ReposGetPullRequestReviewProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranchPullRequestReview{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetPullRequestReviewProtection performs requests for "repos/get-pull-request-review-protection"

Get pull request review protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#get-pull-request-review-protection
*/
func (c Client) ReposGetPullRequestReviewProtection(ctx context.Context, req *ReposGetPullRequestReviewProtectionReq, opt ...options.Option) (*ReposGetPullRequestReviewProtectionResponse, error) {
	return ReposGetPullRequestReviewProtection(ctx, req, append(c, opt...)...)
}

/*
ReposGetPullRequestReviewProtectionReq is request data for Client.ReposGetPullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#get-pull-request-review-protection
*/
type ReposGetPullRequestReviewProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposGetPullRequestReviewProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetPullRequestReviewProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"luke-cage"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/vnd.github.luke-cage-preview+json")},
		Method:           "GET",
		OperationID:      "repos/get-pull-request-review-protection",
		Previews:         map[string]bool{"luke-cage": r.LukeCagePreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetPullRequestReviewProtectionReq) Rel(link RelName, resp *ReposGetPullRequestReviewProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetPullRequestReviewProtectionResponse is a response for ReposGetPullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#get-pull-request-review-protection
*/
type ReposGetPullRequestReviewProtectionResponse struct {
	common.Response
	request *ReposGetPullRequestReviewProtectionReq
	Data    components.ProtectedBranchPullRequestReview
}

/*
ReposGetPunchCardStats performs requests for "repos/get-punch-card-stats"

Get the hourly commit count for each day.

  GET /repos/{owner}/{repo}/stats/punch_card

https://developer.github.com/v3/repos/statistics/#get-the-hourly-commit-count-for-each-day
*/
func ReposGetPunchCardStats(ctx context.Context, req *ReposGetPunchCardStatsReq, opt ...options.Option) (*ReposGetPunchCardStatsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetPunchCardStatsReq)
	}
	resp := &ReposGetPunchCardStatsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CodeFrequencyStat{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetPunchCardStats performs requests for "repos/get-punch-card-stats"

Get the hourly commit count for each day.

  GET /repos/{owner}/{repo}/stats/punch_card

https://developer.github.com/v3/repos/statistics/#get-the-hourly-commit-count-for-each-day
*/
func (c Client) ReposGetPunchCardStats(ctx context.Context, req *ReposGetPunchCardStatsReq, opt ...options.Option) (*ReposGetPunchCardStatsResponse, error) {
	return ReposGetPunchCardStats(ctx, req, append(c, opt...)...)
}

/*
ReposGetPunchCardStatsReq is request data for Client.ReposGetPunchCardStats

https://developer.github.com/v3/repos/statistics/#get-the-hourly-commit-count-for-each-day
*/
type ReposGetPunchCardStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetPunchCardStatsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetPunchCardStatsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-punch-card-stats",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/stats/punch_card", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetPunchCardStatsReq) Rel(link RelName, resp *ReposGetPunchCardStatsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetPunchCardStatsResponse is a response for ReposGetPunchCardStats

https://developer.github.com/v3/repos/statistics/#get-the-hourly-commit-count-for-each-day
*/
type ReposGetPunchCardStatsResponse struct {
	common.Response
	request *ReposGetPunchCardStatsReq
	Data    []components.CodeFrequencyStat
}

/*
ReposGetReadme performs requests for "repos/get-readme"

Get a repository README.

  GET /repos/{owner}/{repo}/readme

https://developer.github.com/v3/repos/contents/#get-a-repository-readme
*/
func ReposGetReadme(ctx context.Context, req *ReposGetReadmeReq, opt ...options.Option) (*ReposGetReadmeResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetReadmeReq)
	}
	resp := &ReposGetReadmeResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ContentFile{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetReadme performs requests for "repos/get-readme"

Get a repository README.

  GET /repos/{owner}/{repo}/readme

https://developer.github.com/v3/repos/contents/#get-a-repository-readme
*/
func (c Client) ReposGetReadme(ctx context.Context, req *ReposGetReadmeReq, opt ...options.Option) (*ReposGetReadmeResponse, error) {
	return ReposGetReadme(ctx, req, append(c, opt...)...)
}

/*
ReposGetReadmeReq is request data for Client.ReposGetReadme

https://developer.github.com/v3/repos/contents/#get-a-repository-readme
*/
type ReposGetReadmeReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	The name of the commit/branch/tag. Default: the repositorys default branch
	(usually `master`)
	*/
	Ref *string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetReadmeReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetReadmeReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-readme",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/readme", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReadmeReq) Rel(link RelName, resp *ReposGetReadmeResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetReadmeResponse is a response for ReposGetReadme

https://developer.github.com/v3/repos/contents/#get-a-repository-readme
*/
type ReposGetReadmeResponse struct {
	common.Response
	request *ReposGetReadmeReq
	Data    components.ContentFile
}

/*
ReposGetRelease performs requests for "repos/get-release"

Get a release.

  GET /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#get-a-release
*/
func ReposGetRelease(ctx context.Context, req *ReposGetReleaseReq, opt ...options.Option) (*ReposGetReleaseResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetReleaseReq)
	}
	resp := &ReposGetReleaseResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Release{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetRelease performs requests for "repos/get-release"

Get a release.

  GET /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#get-a-release
*/
func (c Client) ReposGetRelease(ctx context.Context, req *ReposGetReleaseReq, opt ...options.Option) (*ReposGetReleaseResponse, error) {
	return ReposGetRelease(ctx, req, append(c, opt...)...)
}

/*
ReposGetReleaseReq is request data for Client.ReposGetRelease

https://developer.github.com/v3/repos/releases/#get-a-release
*/
type ReposGetReleaseReq struct {
	_url  string
	Owner string
	Repo  string

	// release_id parameter
	ReleaseId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposGetReleaseReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetReleaseReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-release",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReleaseReq) Rel(link RelName, resp *ReposGetReleaseResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetReleaseResponse is a response for ReposGetRelease

https://developer.github.com/v3/repos/releases/#get-a-release
*/
type ReposGetReleaseResponse struct {
	common.Response
	request *ReposGetReleaseReq
	Data    components.Release
}

/*
ReposGetReleaseAsset performs requests for "repos/get-release-asset"

Get a release asset.

  GET /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#get-a-release-asset
*/
func ReposGetReleaseAsset(ctx context.Context, req *ReposGetReleaseAssetReq, opt ...options.Option) (*ReposGetReleaseAssetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetReleaseAssetReq)
	}
	resp := &ReposGetReleaseAssetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ReleaseAsset{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetReleaseAsset performs requests for "repos/get-release-asset"

Get a release asset.

  GET /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#get-a-release-asset
*/
func (c Client) ReposGetReleaseAsset(ctx context.Context, req *ReposGetReleaseAssetReq, opt ...options.Option) (*ReposGetReleaseAssetResponse, error) {
	return ReposGetReleaseAsset(ctx, req, append(c, opt...)...)
}

/*
ReposGetReleaseAssetReq is request data for Client.ReposGetReleaseAsset

https://developer.github.com/v3/repos/releases/#get-a-release-asset
*/
type ReposGetReleaseAssetReq struct {
	_url  string
	Owner string
	Repo  string

	// asset_id parameter
	AssetId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposGetReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetReleaseAssetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-release-asset",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReleaseAssetReq) Rel(link RelName, resp *ReposGetReleaseAssetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetReleaseAssetResponse is a response for ReposGetReleaseAsset

https://developer.github.com/v3/repos/releases/#get-a-release-asset
*/
type ReposGetReleaseAssetResponse struct {
	common.Response
	request *ReposGetReleaseAssetReq
	Data    components.ReleaseAsset
}

/*
ReposGetReleaseByTag performs requests for "repos/get-release-by-tag"

Get a release by tag name.

  GET /repos/{owner}/{repo}/releases/tags/{tag}

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
func ReposGetReleaseByTag(ctx context.Context, req *ReposGetReleaseByTagReq, opt ...options.Option) (*ReposGetReleaseByTagResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetReleaseByTagReq)
	}
	resp := &ReposGetReleaseByTagResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Release{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetReleaseByTag performs requests for "repos/get-release-by-tag"

Get a release by tag name.

  GET /repos/{owner}/{repo}/releases/tags/{tag}

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
func (c Client) ReposGetReleaseByTag(ctx context.Context, req *ReposGetReleaseByTagReq, opt ...options.Option) (*ReposGetReleaseByTagResponse, error) {
	return ReposGetReleaseByTag(ctx, req, append(c, opt...)...)
}

/*
ReposGetReleaseByTagReq is request data for Client.ReposGetReleaseByTag

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
type ReposGetReleaseByTagReq struct {
	_url  string
	Owner string
	Repo  string

	// tag+ parameter
	Tag string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetReleaseByTagReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetReleaseByTagReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-release-by-tag",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/tags/%v", r.Owner, r.Repo, r.Tag),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReleaseByTagReq) Rel(link RelName, resp *ReposGetReleaseByTagResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetReleaseByTagResponse is a response for ReposGetReleaseByTag

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
type ReposGetReleaseByTagResponse struct {
	common.Response
	request *ReposGetReleaseByTagReq
	Data    components.Release
}

/*
ReposGetStatusChecksProtection performs requests for "repos/get-status-checks-protection"

Get status checks protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#get-status-checks-protection
*/
func ReposGetStatusChecksProtection(ctx context.Context, req *ReposGetStatusChecksProtectionReq, opt ...options.Option) (*ReposGetStatusChecksProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetStatusChecksProtectionReq)
	}
	resp := &ReposGetStatusChecksProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.StatusCheckPolicy{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetStatusChecksProtection performs requests for "repos/get-status-checks-protection"

Get status checks protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#get-status-checks-protection
*/
func (c Client) ReposGetStatusChecksProtection(ctx context.Context, req *ReposGetStatusChecksProtectionReq, opt ...options.Option) (*ReposGetStatusChecksProtectionResponse, error) {
	return ReposGetStatusChecksProtection(ctx, req, append(c, opt...)...)
}

/*
ReposGetStatusChecksProtectionReq is request data for Client.ReposGetStatusChecksProtection

https://developer.github.com/v3/repos/branches/#get-status-checks-protection
*/
type ReposGetStatusChecksProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetStatusChecksProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetStatusChecksProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-status-checks-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetStatusChecksProtectionReq) Rel(link RelName, resp *ReposGetStatusChecksProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetStatusChecksProtectionResponse is a response for ReposGetStatusChecksProtection

https://developer.github.com/v3/repos/branches/#get-status-checks-protection
*/
type ReposGetStatusChecksProtectionResponse struct {
	common.Response
	request *ReposGetStatusChecksProtectionReq
	Data    components.StatusCheckPolicy
}

/*
ReposGetTeamsWithAccessToProtectedBranch performs requests for "repos/get-teams-with-access-to-protected-branch"

Get teams with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-the-protected-branch
*/
func ReposGetTeamsWithAccessToProtectedBranch(ctx context.Context, req *ReposGetTeamsWithAccessToProtectedBranchReq, opt ...options.Option) (*ReposGetTeamsWithAccessToProtectedBranchResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetTeamsWithAccessToProtectedBranchReq)
	}
	resp := &ReposGetTeamsWithAccessToProtectedBranchResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetTeamsWithAccessToProtectedBranch performs requests for "repos/get-teams-with-access-to-protected-branch"

Get teams with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-the-protected-branch
*/
func (c Client) ReposGetTeamsWithAccessToProtectedBranch(ctx context.Context, req *ReposGetTeamsWithAccessToProtectedBranchReq, opt ...options.Option) (*ReposGetTeamsWithAccessToProtectedBranchResponse, error) {
	return ReposGetTeamsWithAccessToProtectedBranch(ctx, req, append(c, opt...)...)
}

/*
ReposGetTeamsWithAccessToProtectedBranchReq is request data for Client.ReposGetTeamsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-the-protected-branch
*/
type ReposGetTeamsWithAccessToProtectedBranchReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetTeamsWithAccessToProtectedBranchReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-teams-with-access-to-protected-branch",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetTeamsWithAccessToProtectedBranchReq) Rel(link RelName, resp *ReposGetTeamsWithAccessToProtectedBranchResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetTeamsWithAccessToProtectedBranchResponse is a response for ReposGetTeamsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-the-protected-branch
*/
type ReposGetTeamsWithAccessToProtectedBranchResponse struct {
	common.Response
	request *ReposGetTeamsWithAccessToProtectedBranchReq
	Data    []components.Team
}

/*
ReposGetTopPaths performs requests for "repos/get-top-paths"

Get top referral paths.

  GET /repos/{owner}/{repo}/traffic/popular/paths

https://developer.github.com/v3/repos/traffic/#get-top-referral-paths
*/
func ReposGetTopPaths(ctx context.Context, req *ReposGetTopPathsReq, opt ...options.Option) (*ReposGetTopPathsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetTopPathsReq)
	}
	resp := &ReposGetTopPathsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ContentTraffic{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetTopPaths performs requests for "repos/get-top-paths"

Get top referral paths.

  GET /repos/{owner}/{repo}/traffic/popular/paths

https://developer.github.com/v3/repos/traffic/#get-top-referral-paths
*/
func (c Client) ReposGetTopPaths(ctx context.Context, req *ReposGetTopPathsReq, opt ...options.Option) (*ReposGetTopPathsResponse, error) {
	return ReposGetTopPaths(ctx, req, append(c, opt...)...)
}

/*
ReposGetTopPathsReq is request data for Client.ReposGetTopPaths

https://developer.github.com/v3/repos/traffic/#get-top-referral-paths
*/
type ReposGetTopPathsReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetTopPathsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetTopPathsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-top-paths",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/traffic/popular/paths", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetTopPathsReq) Rel(link RelName, resp *ReposGetTopPathsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetTopPathsResponse is a response for ReposGetTopPaths

https://developer.github.com/v3/repos/traffic/#get-top-referral-paths
*/
type ReposGetTopPathsResponse struct {
	common.Response
	request *ReposGetTopPathsReq
	Data    []components.ContentTraffic
}

/*
ReposGetTopReferrers performs requests for "repos/get-top-referrers"

Get top referral sources.

  GET /repos/{owner}/{repo}/traffic/popular/referrers

https://developer.github.com/v3/repos/traffic/#get-top-referral-sources
*/
func ReposGetTopReferrers(ctx context.Context, req *ReposGetTopReferrersReq, opt ...options.Option) (*ReposGetTopReferrersResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetTopReferrersReq)
	}
	resp := &ReposGetTopReferrersResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ReferrerTraffic{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetTopReferrers performs requests for "repos/get-top-referrers"

Get top referral sources.

  GET /repos/{owner}/{repo}/traffic/popular/referrers

https://developer.github.com/v3/repos/traffic/#get-top-referral-sources
*/
func (c Client) ReposGetTopReferrers(ctx context.Context, req *ReposGetTopReferrersReq, opt ...options.Option) (*ReposGetTopReferrersResponse, error) {
	return ReposGetTopReferrers(ctx, req, append(c, opt...)...)
}

/*
ReposGetTopReferrersReq is request data for Client.ReposGetTopReferrers

https://developer.github.com/v3/repos/traffic/#get-top-referral-sources
*/
type ReposGetTopReferrersReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetTopReferrersReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetTopReferrersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-top-referrers",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/traffic/popular/referrers", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetTopReferrersReq) Rel(link RelName, resp *ReposGetTopReferrersResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetTopReferrersResponse is a response for ReposGetTopReferrers

https://developer.github.com/v3/repos/traffic/#get-top-referral-sources
*/
type ReposGetTopReferrersResponse struct {
	common.Response
	request *ReposGetTopReferrersReq
	Data    []components.ReferrerTraffic
}

/*
ReposGetUsersWithAccessToProtectedBranch performs requests for "repos/get-users-with-access-to-protected-branch"

Get users with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-the-protected-branch
*/
func ReposGetUsersWithAccessToProtectedBranch(ctx context.Context, req *ReposGetUsersWithAccessToProtectedBranchReq, opt ...options.Option) (*ReposGetUsersWithAccessToProtectedBranchResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetUsersWithAccessToProtectedBranchReq)
	}
	resp := &ReposGetUsersWithAccessToProtectedBranchResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetUsersWithAccessToProtectedBranch performs requests for "repos/get-users-with-access-to-protected-branch"

Get users with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-the-protected-branch
*/
func (c Client) ReposGetUsersWithAccessToProtectedBranch(ctx context.Context, req *ReposGetUsersWithAccessToProtectedBranchReq, opt ...options.Option) (*ReposGetUsersWithAccessToProtectedBranchResponse, error) {
	return ReposGetUsersWithAccessToProtectedBranch(ctx, req, append(c, opt...)...)
}

/*
ReposGetUsersWithAccessToProtectedBranchReq is request data for Client.ReposGetUsersWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-the-protected-branch
*/
type ReposGetUsersWithAccessToProtectedBranchReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetUsersWithAccessToProtectedBranchReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-users-with-access-to-protected-branch",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetUsersWithAccessToProtectedBranchReq) Rel(link RelName, resp *ReposGetUsersWithAccessToProtectedBranchResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetUsersWithAccessToProtectedBranchResponse is a response for ReposGetUsersWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-the-protected-branch
*/
type ReposGetUsersWithAccessToProtectedBranchResponse struct {
	common.Response
	request *ReposGetUsersWithAccessToProtectedBranchReq
	Data    []components.SimpleUser
}

/*
ReposGetViews performs requests for "repos/get-views"

Get page views.

  GET /repos/{owner}/{repo}/traffic/views

https://developer.github.com/v3/repos/traffic/#get-page-views
*/
func ReposGetViews(ctx context.Context, req *ReposGetViewsReq, opt ...options.Option) (*ReposGetViewsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetViewsReq)
	}
	resp := &ReposGetViewsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ViewTraffic{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetViews performs requests for "repos/get-views"

Get page views.

  GET /repos/{owner}/{repo}/traffic/views

https://developer.github.com/v3/repos/traffic/#get-page-views
*/
func (c Client) ReposGetViews(ctx context.Context, req *ReposGetViewsReq, opt ...options.Option) (*ReposGetViewsResponse, error) {
	return ReposGetViews(ctx, req, append(c, opt...)...)
}

/*
ReposGetViewsReq is request data for Client.ReposGetViews

https://developer.github.com/v3/repos/traffic/#get-page-views
*/
type ReposGetViewsReq struct {
	_url  string
	Owner string
	Repo  string

	// Must be one of: `day`, `week`.
	Per *string
}

// HTTPRequest builds an *http.Request
func (r *ReposGetViewsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetViewsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Per != nil {
		query.Set("per", *r.Per)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-views",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/traffic/views", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetViewsReq) Rel(link RelName, resp *ReposGetViewsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetViewsResponse is a response for ReposGetViews

https://developer.github.com/v3/repos/traffic/#get-page-views
*/
type ReposGetViewsResponse struct {
	common.Response
	request *ReposGetViewsReq
	Data    components.ViewTraffic
}

/*
ReposGetWebhook performs requests for "repos/get-webhook"

Get a repository webhook.

  GET /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#get-a-repository-webhook
*/
func ReposGetWebhook(ctx context.Context, req *ReposGetWebhookReq, opt ...options.Option) (*ReposGetWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposGetWebhookReq)
	}
	resp := &ReposGetWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Hook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetWebhook performs requests for "repos/get-webhook"

Get a repository webhook.

  GET /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#get-a-repository-webhook
*/
func (c Client) ReposGetWebhook(ctx context.Context, req *ReposGetWebhookReq, opt ...options.Option) (*ReposGetWebhookResponse, error) {
	return ReposGetWebhook(ctx, req, append(c, opt...)...)
}

/*
ReposGetWebhookReq is request data for Client.ReposGetWebhook

https://developer.github.com/v3/repos/hooks/#get-a-repository-webhook
*/
type ReposGetWebhookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposGetWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposGetWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetWebhookReq) Rel(link RelName, resp *ReposGetWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetWebhookResponse is a response for ReposGetWebhook

https://developer.github.com/v3/repos/hooks/#get-a-repository-webhook
*/
type ReposGetWebhookResponse struct {
	common.Response
	request *ReposGetWebhookReq
	Data    components.Hook
}

/*
ReposListBranches performs requests for "repos/list-branches"

List branches.

  GET /repos/{owner}/{repo}/branches

https://developer.github.com/v3/repos/branches/#list-branches
*/
func ReposListBranches(ctx context.Context, req *ReposListBranchesReq, opt ...options.Option) (*ReposListBranchesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListBranchesReq)
	}
	resp := &ReposListBranchesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ShortBranch{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListBranches performs requests for "repos/list-branches"

List branches.

  GET /repos/{owner}/{repo}/branches

https://developer.github.com/v3/repos/branches/#list-branches
*/
func (c Client) ReposListBranches(ctx context.Context, req *ReposListBranchesReq, opt ...options.Option) (*ReposListBranchesResponse, error) {
	return ReposListBranches(ctx, req, append(c, opt...)...)
}

/*
ReposListBranchesReq is request data for Client.ReposListBranches

https://developer.github.com/v3/repos/branches/#list-branches
*/
type ReposListBranchesReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Setting to `true` returns only protected branches. When set to `false`, only
	unprotected branches are returned. Omitting this parameter returns all branches.
	*/
	Protected *bool

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListBranchesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListBranchesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Protected != nil {
		query.Set("protected", strconv.FormatBool(*r.Protected))
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-branches",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListBranchesReq) Rel(link RelName, resp *ReposListBranchesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListBranchesResponse is a response for ReposListBranches

https://developer.github.com/v3/repos/branches/#list-branches
*/
type ReposListBranchesResponse struct {
	common.Response
	request *ReposListBranchesReq
	Data    []components.ShortBranch
}

/*
ReposListBranchesForHeadCommit performs requests for "repos/list-branches-for-head-commit"

List branches for HEAD commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
func ReposListBranchesForHeadCommit(ctx context.Context, req *ReposListBranchesForHeadCommitReq, opt ...options.Option) (*ReposListBranchesForHeadCommitResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListBranchesForHeadCommitReq)
	}
	resp := &ReposListBranchesForHeadCommitResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.BranchShort{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListBranchesForHeadCommit performs requests for "repos/list-branches-for-head-commit"

List branches for HEAD commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
func (c Client) ReposListBranchesForHeadCommit(ctx context.Context, req *ReposListBranchesForHeadCommitReq, opt ...options.Option) (*ReposListBranchesForHeadCommitResponse, error) {
	return ReposListBranchesForHeadCommit(ctx, req, append(c, opt...)...)
}

/*
ReposListBranchesForHeadCommitReq is request data for Client.ReposListBranchesForHeadCommit

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
type ReposListBranchesForHeadCommitReq struct {
	_url  string
	Owner string
	Repo  string

	// commit_sha+ parameter
	CommitSha string

	/*
	Listing branches or pull requests for a commit in the Commits API is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-04-11-pulls-branches-for-commit/)
	for more details. To access the new endpoints during the preview period, you
	must set this to true.
	*/
	GrootPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposListBranchesForHeadCommitReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListBranchesForHeadCommitReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"groot"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-branches-for-head-commit",
		Previews:         map[string]bool{"groot": r.GrootPreview},
		RequiredPreviews: []string{"groot"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/branches-where-head", r.Owner, r.Repo, r.CommitSha),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListBranchesForHeadCommitReq) Rel(link RelName, resp *ReposListBranchesForHeadCommitResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListBranchesForHeadCommitResponse is a response for ReposListBranchesForHeadCommit

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
type ReposListBranchesForHeadCommitResponse struct {
	common.Response
	request *ReposListBranchesForHeadCommitReq
	Data    []components.BranchShort
}

/*
ReposListCollaborators performs requests for "repos/list-collaborators"

List repository collaborators.

  GET /repos/{owner}/{repo}/collaborators

https://developer.github.com/v3/repos/collaborators/#list-repository-collaborators
*/
func ReposListCollaborators(ctx context.Context, req *ReposListCollaboratorsReq, opt ...options.Option) (*ReposListCollaboratorsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListCollaboratorsReq)
	}
	resp := &ReposListCollaboratorsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Collaborator{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCollaborators performs requests for "repos/list-collaborators"

List repository collaborators.

  GET /repos/{owner}/{repo}/collaborators

https://developer.github.com/v3/repos/collaborators/#list-repository-collaborators
*/
func (c Client) ReposListCollaborators(ctx context.Context, req *ReposListCollaboratorsReq, opt ...options.Option) (*ReposListCollaboratorsResponse, error) {
	return ReposListCollaborators(ctx, req, append(c, opt...)...)
}

/*
ReposListCollaboratorsReq is request data for Client.ReposListCollaborators

https://developer.github.com/v3/repos/collaborators/#list-repository-collaborators
*/
type ReposListCollaboratorsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Filter collaborators returned by their affiliation. Can be one of:
	\* `outside`: All outside collaborators of an organization-owned repository.
	\* `direct`: All collaborators with permissions to an organization-owned
	repository, regardless of organization membership status.
	\* `all`: All collaborators the authenticated user can see.
	*/
	Affiliation *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListCollaboratorsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListCollaboratorsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-collaborators",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/collaborators", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCollaboratorsReq) Rel(link RelName, resp *ReposListCollaboratorsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCollaboratorsResponse is a response for ReposListCollaborators

https://developer.github.com/v3/repos/collaborators/#list-repository-collaborators
*/
type ReposListCollaboratorsResponse struct {
	common.Response
	request *ReposListCollaboratorsReq
	Data    []components.Collaborator
}

/*
ReposListCommentsForCommit performs requests for "repos/list-comments-for-commit"

List commit comments.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments
*/
func ReposListCommentsForCommit(ctx context.Context, req *ReposListCommentsForCommitReq, opt ...options.Option) (*ReposListCommentsForCommitResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListCommentsForCommitReq)
	}
	resp := &ReposListCommentsForCommitResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CommitComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCommentsForCommit performs requests for "repos/list-comments-for-commit"

List commit comments.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments
*/
func (c Client) ReposListCommentsForCommit(ctx context.Context, req *ReposListCommentsForCommitReq, opt ...options.Option) (*ReposListCommentsForCommitResponse, error) {
	return ReposListCommentsForCommit(ctx, req, append(c, opt...)...)
}

/*
ReposListCommentsForCommitReq is request data for Client.ReposListCommentsForCommit

https://developer.github.com/v3/repos/comments/#list-commit-comments
*/
type ReposListCommentsForCommitReq struct {
	_url  string
	Owner string
	Repo  string

	// commit_sha+ parameter
	CommitSha string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposListCommentsForCommitReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListCommentsForCommitReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-comments-for-commit",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/comments", r.Owner, r.Repo, r.CommitSha),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCommentsForCommitReq) Rel(link RelName, resp *ReposListCommentsForCommitResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCommentsForCommitResponse is a response for ReposListCommentsForCommit

https://developer.github.com/v3/repos/comments/#list-commit-comments
*/
type ReposListCommentsForCommitResponse struct {
	common.Response
	request *ReposListCommentsForCommitReq
	Data    []components.CommitComment
}

/*
ReposListCommitCommentsForRepo performs requests for "repos/list-commit-comments-for-repo"

List commit comments for a repository.

  GET /repos/{owner}/{repo}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
func ReposListCommitCommentsForRepo(ctx context.Context, req *ReposListCommitCommentsForRepoReq, opt ...options.Option) (*ReposListCommitCommentsForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListCommitCommentsForRepoReq)
	}
	resp := &ReposListCommitCommentsForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CommitComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCommitCommentsForRepo performs requests for "repos/list-commit-comments-for-repo"

List commit comments for a repository.

  GET /repos/{owner}/{repo}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
func (c Client) ReposListCommitCommentsForRepo(ctx context.Context, req *ReposListCommitCommentsForRepoReq, opt ...options.Option) (*ReposListCommitCommentsForRepoResponse, error) {
	return ReposListCommitCommentsForRepo(ctx, req, append(c, opt...)...)
}

/*
ReposListCommitCommentsForRepoReq is request data for Client.ReposListCommitCommentsForRepo

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
type ReposListCommitCommentsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposListCommitCommentsForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListCommitCommentsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-commit-comments-for-repo",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/comments", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCommitCommentsForRepoReq) Rel(link RelName, resp *ReposListCommitCommentsForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCommitCommentsForRepoResponse is a response for ReposListCommitCommentsForRepo

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
type ReposListCommitCommentsForRepoResponse struct {
	common.Response
	request *ReposListCommitCommentsForRepoReq
	Data    []components.CommitComment
}

/*
ReposListCommitStatusesForRef performs requests for "repos/list-commit-statuses-for-ref"

List commit statuses for a reference.

  GET /repos/{owner}/{repo}/commits/{ref}/statuses

https://developer.github.com/v3/repos/statuses/#list-commit-statuses-for-a-reference
*/
func ReposListCommitStatusesForRef(ctx context.Context, req *ReposListCommitStatusesForRefReq, opt ...options.Option) (*ReposListCommitStatusesForRefResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListCommitStatusesForRefReq)
	}
	resp := &ReposListCommitStatusesForRefResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Status{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCommitStatusesForRef performs requests for "repos/list-commit-statuses-for-ref"

List commit statuses for a reference.

  GET /repos/{owner}/{repo}/commits/{ref}/statuses

https://developer.github.com/v3/repos/statuses/#list-commit-statuses-for-a-reference
*/
func (c Client) ReposListCommitStatusesForRef(ctx context.Context, req *ReposListCommitStatusesForRefReq, opt ...options.Option) (*ReposListCommitStatusesForRefResponse, error) {
	return ReposListCommitStatusesForRef(ctx, req, append(c, opt...)...)
}

/*
ReposListCommitStatusesForRefReq is request data for Client.ReposListCommitStatusesForRef

https://developer.github.com/v3/repos/statuses/#list-commit-statuses-for-a-reference
*/
type ReposListCommitStatusesForRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListCommitStatusesForRefReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListCommitStatusesForRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-commit-statuses-for-ref",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/statuses", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{200, 301},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCommitStatusesForRefReq) Rel(link RelName, resp *ReposListCommitStatusesForRefResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCommitStatusesForRefResponse is a response for ReposListCommitStatusesForRef

https://developer.github.com/v3/repos/statuses/#list-commit-statuses-for-a-reference
*/
type ReposListCommitStatusesForRefResponse struct {
	common.Response
	request *ReposListCommitStatusesForRefReq
	Data    []components.Status
}

/*
ReposListCommits performs requests for "repos/list-commits"

List commits.

  GET /repos/{owner}/{repo}/commits

https://developer.github.com/v3/repos/commits/#list-commits
*/
func ReposListCommits(ctx context.Context, req *ReposListCommitsReq, opt ...options.Option) (*ReposListCommitsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListCommitsReq)
	}
	resp := &ReposListCommitsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleCommit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCommits performs requests for "repos/list-commits"

List commits.

  GET /repos/{owner}/{repo}/commits

https://developer.github.com/v3/repos/commits/#list-commits
*/
func (c Client) ReposListCommits(ctx context.Context, req *ReposListCommitsReq, opt ...options.Option) (*ReposListCommitsResponse, error) {
	return ReposListCommits(ctx, req, append(c, opt...)...)
}

/*
ReposListCommitsReq is request data for Client.ReposListCommits

https://developer.github.com/v3/repos/commits/#list-commits
*/
type ReposListCommitsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	SHA or branch to start listing commits from. Default: the repositorys default
	branch (usually `master`).
	*/
	Sha *string

	// Only commits containing this file path will be returned.
	Path *string

	// GitHub login or email address by which to filter by commit author.
	Author *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only commits before this date will be returned. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Until *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListCommitsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListCommitsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sha != nil {
		query.Set("sha", *r.Sha)
	}
	if r.Path != nil {
		query.Set("path", *r.Path)
	}
	if r.Author != nil {
		query.Set("author", *r.Author)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Until != nil {
		query.Set("until", *r.Until)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-commits",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCommitsReq) Rel(link RelName, resp *ReposListCommitsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCommitsResponse is a response for ReposListCommits

https://developer.github.com/v3/repos/commits/#list-commits
*/
type ReposListCommitsResponse struct {
	common.Response
	request *ReposListCommitsReq
	Data    []components.SimpleCommit
}

/*
ReposListContributors performs requests for "repos/list-contributors"

List repository contributors.

  GET /repos/{owner}/{repo}/contributors

https://developer.github.com/v3/repos/#list-repository-contributors
*/
func ReposListContributors(ctx context.Context, req *ReposListContributorsReq, opt ...options.Option) (*ReposListContributorsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListContributorsReq)
	}
	resp := &ReposListContributorsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Contributor{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListContributors performs requests for "repos/list-contributors"

List repository contributors.

  GET /repos/{owner}/{repo}/contributors

https://developer.github.com/v3/repos/#list-repository-contributors
*/
func (c Client) ReposListContributors(ctx context.Context, req *ReposListContributorsReq, opt ...options.Option) (*ReposListContributorsResponse, error) {
	return ReposListContributors(ctx, req, append(c, opt...)...)
}

/*
ReposListContributorsReq is request data for Client.ReposListContributors

https://developer.github.com/v3/repos/#list-repository-contributors
*/
type ReposListContributorsReq struct {
	_url  string
	Owner string
	Repo  string

	// Set to `1` or `true` to include anonymous contributors in results.
	Anon *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListContributorsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListContributorsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Anon != nil {
		query.Set("anon", *r.Anon)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-contributors",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/contributors", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListContributorsReq) Rel(link RelName, resp *ReposListContributorsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListContributorsResponse is a response for ReposListContributors

https://developer.github.com/v3/repos/#list-repository-contributors
*/
type ReposListContributorsResponse struct {
	common.Response
	request *ReposListContributorsReq
	Data    []components.Contributor
}

/*
ReposListDeployKeys performs requests for "repos/list-deploy-keys"

List deploy keys.

  GET /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
func ReposListDeployKeys(ctx context.Context, req *ReposListDeployKeysReq, opt ...options.Option) (*ReposListDeployKeysResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListDeployKeysReq)
	}
	resp := &ReposListDeployKeysResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.DeployKey{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListDeployKeys performs requests for "repos/list-deploy-keys"

List deploy keys.

  GET /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
func (c Client) ReposListDeployKeys(ctx context.Context, req *ReposListDeployKeysReq, opt ...options.Option) (*ReposListDeployKeysResponse, error) {
	return ReposListDeployKeys(ctx, req, append(c, opt...)...)
}

/*
ReposListDeployKeysReq is request data for Client.ReposListDeployKeys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
type ReposListDeployKeysReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListDeployKeysReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListDeployKeysReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-deploy-keys",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/keys", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListDeployKeysReq) Rel(link RelName, resp *ReposListDeployKeysResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListDeployKeysResponse is a response for ReposListDeployKeys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
type ReposListDeployKeysResponse struct {
	common.Response
	request *ReposListDeployKeysReq
	Data    []components.DeployKey
}

/*
ReposListDeploymentStatuses performs requests for "repos/list-deployment-statuses"

List deployment statuses.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
func ReposListDeploymentStatuses(ctx context.Context, req *ReposListDeploymentStatusesReq, opt ...options.Option) (*ReposListDeploymentStatusesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListDeploymentStatusesReq)
	}
	resp := &ReposListDeploymentStatusesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.DeploymentStatus{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListDeploymentStatuses performs requests for "repos/list-deployment-statuses"

List deployment statuses.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
func (c Client) ReposListDeploymentStatuses(ctx context.Context, req *ReposListDeploymentStatusesReq, opt ...options.Option) (*ReposListDeploymentStatusesResponse, error) {
	return ReposListDeploymentStatuses(ctx, req, append(c, opt...)...)
}

/*
ReposListDeploymentStatusesReq is request data for Client.ReposListDeploymentStatuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
type ReposListDeploymentStatusesReq struct {
	_url  string
	Owner string
	Repo  string

	// deployment_id parameter
	DeploymentId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposListDeploymentStatusesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListDeploymentStatusesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"flash", "ant-man"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "repos/list-deployment-statuses",
		Previews: map[string]bool{
			"ant-man": r.AntManPreview,
			"flash":   r.FlashPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses", r.Owner, r.Repo, r.DeploymentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListDeploymentStatusesReq) Rel(link RelName, resp *ReposListDeploymentStatusesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListDeploymentStatusesResponse is a response for ReposListDeploymentStatuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
type ReposListDeploymentStatusesResponse struct {
	common.Response
	request *ReposListDeploymentStatusesReq
	Data    []components.DeploymentStatus
}

/*
ReposListDeployments performs requests for "repos/list-deployments"

List deployments.

  GET /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
func ReposListDeployments(ctx context.Context, req *ReposListDeploymentsReq, opt ...options.Option) (*ReposListDeploymentsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListDeploymentsReq)
	}
	resp := &ReposListDeploymentsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Deployment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListDeployments performs requests for "repos/list-deployments"

List deployments.

  GET /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
func (c Client) ReposListDeployments(ctx context.Context, req *ReposListDeploymentsReq, opt ...options.Option) (*ReposListDeploymentsResponse, error) {
	return ReposListDeployments(ctx, req, append(c, opt...)...)
}

/*
ReposListDeploymentsReq is request data for Client.ReposListDeployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
type ReposListDeploymentsReq struct {
	_url  string
	Owner string
	Repo  string

	// The SHA recorded at creation time.
	Sha *string

	// The name of the ref. This can be a branch, tag, or SHA.
	Ref *string

	// The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).
	Task *string

	/*
	The name of the environment that was deployed to (e.g., `staging` or
	`production`).
	*/
	Environment *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposListDeploymentsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListDeploymentsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sha != nil {
		query.Set("sha", *r.Sha)
	}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}
	if r.Task != nil {
		query.Set("task", *r.Task)
	}
	if r.Environment != nil {
		query.Set("environment", *r.Environment)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"ant-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-deployments",
		Previews:         map[string]bool{"ant-man": r.AntManPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListDeploymentsReq) Rel(link RelName, resp *ReposListDeploymentsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListDeploymentsResponse is a response for ReposListDeployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
type ReposListDeploymentsResponse struct {
	common.Response
	request *ReposListDeploymentsReq
	Data    []components.Deployment
}

/*
ReposListForAuthenticatedUser performs requests for "repos/list-for-authenticated-user"

List repositories for the authenticated user.

  GET /user/repos

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
func ReposListForAuthenticatedUser(ctx context.Context, req *ReposListForAuthenticatedUserReq, opt ...options.Option) (*ReposListForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListForAuthenticatedUserReq)
	}
	resp := &ReposListForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Repository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListForAuthenticatedUser performs requests for "repos/list-for-authenticated-user"

List repositories for the authenticated user.

  GET /user/repos

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
func (c Client) ReposListForAuthenticatedUser(ctx context.Context, req *ReposListForAuthenticatedUserReq, opt ...options.Option) (*ReposListForAuthenticatedUserResponse, error) {
	return ReposListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ReposListForAuthenticatedUserReq is request data for Client.ReposListForAuthenticatedUser

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
type ReposListForAuthenticatedUserReq struct {
	_url string

	// Can be one of `all`, `public`, or `private`.
	Visibility *string

	/*
	Comma-separated list of values. Can include:
	\* `owner`: Repositories that are owned by the authenticated user.
	\* `collaborator`: Repositories that the user has been added to as a
	collaborator.
	\* `organization_member`: Repositories that the user has access to through being
	a member of an organization. This includes every repository on every team that
	the user is on.
	*/
	Affiliation *string

	/*
	Can be one of `all`, `owner`, `public`, `private`, `member`. Default: `all`

	Will cause a `422` error if used in the same request as **visibility** or
	**affiliation**. Will cause a `422` error if used in the same request as
	**visibility** or **affiliation**.
	*/
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only show notifications updated before the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Before *string
}

// HTTPRequest builds an *http.Request
func (r *ReposListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Visibility != nil {
		query.Set("visibility", *r.Visibility)
	}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Before != nil {
		query.Set("before", *r.Before)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/repos"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListForAuthenticatedUserReq) Rel(link RelName, resp *ReposListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListForAuthenticatedUserResponse is a response for ReposListForAuthenticatedUser

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
type ReposListForAuthenticatedUserResponse struct {
	common.Response
	request *ReposListForAuthenticatedUserReq
	Data    []components.Repository
}

/*
ReposListForOrg performs requests for "repos/list-for-org"

List organization repositories.

  GET /orgs/{org}/repos

https://developer.github.com/v3/repos/#list-organization-repositories
*/
func ReposListForOrg(ctx context.Context, req *ReposListForOrgReq, opt ...options.Option) (*ReposListForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListForOrgReq)
	}
	resp := &ReposListForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListForOrg performs requests for "repos/list-for-org"

List organization repositories.

  GET /orgs/{org}/repos

https://developer.github.com/v3/repos/#list-organization-repositories
*/
func (c Client) ReposListForOrg(ctx context.Context, req *ReposListForOrgReq, opt ...options.Option) (*ReposListForOrgResponse, error) {
	return ReposListForOrg(ctx, req, append(c, opt...)...)
}

/*
ReposListForOrgReq is request data for Client.ReposListForOrg

https://developer.github.com/v3/repos/#list-organization-repositories
*/
type ReposListForOrgReq struct {
	_url string
	Org  string

	/*
	Specifies the types of repositories you want returned. Can be one of `all`,
	`public`, `private`, `forks`, `sources`, `member`, `internal`. Default: `all`.
	If your organization is associated with an enterprise account using GitHub
	Enterprise Cloud or GitHub Enterprise Server 2.20+, `type` can also be
	`internal`.
	*/
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: when using `full_name`: `asc`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposListForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"nebula", "baptiste"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "repos/list-for-org",
		Previews: map[string]bool{
			"baptiste": r.BaptistePreview,
			"nebula":   r.NebulaPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/repos", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListForOrgReq) Rel(link RelName, resp *ReposListForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListForOrgResponse is a response for ReposListForOrg

https://developer.github.com/v3/repos/#list-organization-repositories
*/
type ReposListForOrgResponse struct {
	common.Response
	request *ReposListForOrgReq
	Data    []components.MinimalRepository
}

/*
ReposListForUser performs requests for "repos/list-for-user"

List repositories for a user.

  GET /users/{username}/repos

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
func ReposListForUser(ctx context.Context, req *ReposListForUserReq, opt ...options.Option) (*ReposListForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListForUserReq)
	}
	resp := &ReposListForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListForUser performs requests for "repos/list-for-user"

List repositories for a user.

  GET /users/{username}/repos

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
func (c Client) ReposListForUser(ctx context.Context, req *ReposListForUserReq, opt ...options.Option) (*ReposListForUserResponse, error) {
	return ReposListForUser(ctx, req, append(c, opt...)...)
}

/*
ReposListForUserReq is request data for Client.ReposListForUser

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
type ReposListForUserReq struct {
	_url     string
	Username string

	// Can be one of `all`, `owner`, `member`.
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposListForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"nebula"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-for-user",
		Previews:         map[string]bool{"nebula": r.NebulaPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/repos", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListForUserReq) Rel(link RelName, resp *ReposListForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListForUserResponse is a response for ReposListForUser

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
type ReposListForUserResponse struct {
	common.Response
	request *ReposListForUserReq
	Data    []components.MinimalRepository
}

/*
ReposListForks performs requests for "repos/list-forks"

List forks.

  GET /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#list-forks
*/
func ReposListForks(ctx context.Context, req *ReposListForksReq, opt ...options.Option) (*ReposListForksResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListForksReq)
	}
	resp := &ReposListForksResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListForks performs requests for "repos/list-forks"

List forks.

  GET /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#list-forks
*/
func (c Client) ReposListForks(ctx context.Context, req *ReposListForksReq, opt ...options.Option) (*ReposListForksResponse, error) {
	return ReposListForks(ctx, req, append(c, opt...)...)
}

/*
ReposListForksReq is request data for Client.ReposListForks

https://developer.github.com/v3/repos/forks/#list-forks
*/
type ReposListForksReq struct {
	_url  string
	Owner string
	Repo  string

	// The sort order. Can be either `newest`, `oldest`, or `stargazers`.
	Sort *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListForksReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListForksReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-forks",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/forks", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListForksReq) Rel(link RelName, resp *ReposListForksResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListForksResponse is a response for ReposListForks

https://developer.github.com/v3/repos/forks/#list-forks
*/
type ReposListForksResponse struct {
	common.Response
	request *ReposListForksReq
	Data    []components.MinimalRepository
}

/*
ReposListInvitations performs requests for "repos/list-invitations"

List repository invitations.

  GET /repos/{owner}/{repo}/invitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations
*/
func ReposListInvitations(ctx context.Context, req *ReposListInvitationsReq, opt ...options.Option) (*ReposListInvitationsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListInvitationsReq)
	}
	resp := &ReposListInvitationsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.RepositoryInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListInvitations performs requests for "repos/list-invitations"

List repository invitations.

  GET /repos/{owner}/{repo}/invitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations
*/
func (c Client) ReposListInvitations(ctx context.Context, req *ReposListInvitationsReq, opt ...options.Option) (*ReposListInvitationsResponse, error) {
	return ReposListInvitations(ctx, req, append(c, opt...)...)
}

/*
ReposListInvitationsReq is request data for Client.ReposListInvitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations
*/
type ReposListInvitationsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListInvitationsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListInvitationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-invitations",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/invitations", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListInvitationsReq) Rel(link RelName, resp *ReposListInvitationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListInvitationsResponse is a response for ReposListInvitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations
*/
type ReposListInvitationsResponse struct {
	common.Response
	request *ReposListInvitationsReq
	Data    []components.RepositoryInvitation
}

/*
ReposListInvitationsForAuthenticatedUser performs requests for "repos/list-invitations-for-authenticated-user"

List repository invitations for the authenticated user.

  GET /user/repository_invitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations-for-the-authenticated-user
*/
func ReposListInvitationsForAuthenticatedUser(ctx context.Context, req *ReposListInvitationsForAuthenticatedUserReq, opt ...options.Option) (*ReposListInvitationsForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListInvitationsForAuthenticatedUserReq)
	}
	resp := &ReposListInvitationsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.RepositoryInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListInvitationsForAuthenticatedUser performs requests for "repos/list-invitations-for-authenticated-user"

List repository invitations for the authenticated user.

  GET /user/repository_invitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations-for-the-authenticated-user
*/
func (c Client) ReposListInvitationsForAuthenticatedUser(ctx context.Context, req *ReposListInvitationsForAuthenticatedUserReq, opt ...options.Option) (*ReposListInvitationsForAuthenticatedUserResponse, error) {
	return ReposListInvitationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ReposListInvitationsForAuthenticatedUserReq is request data for Client.ReposListInvitationsForAuthenticatedUser

https://developer.github.com/v3/repos/invitations/#list-repository-invitations-for-the-authenticated-user
*/
type ReposListInvitationsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListInvitationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListInvitationsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-invitations-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/repository_invitations"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListInvitationsForAuthenticatedUserReq) Rel(link RelName, resp *ReposListInvitationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListInvitationsForAuthenticatedUserResponse is a response for ReposListInvitationsForAuthenticatedUser

https://developer.github.com/v3/repos/invitations/#list-repository-invitations-for-the-authenticated-user
*/
type ReposListInvitationsForAuthenticatedUserResponse struct {
	common.Response
	request *ReposListInvitationsForAuthenticatedUserReq
	Data    []components.RepositoryInvitation
}

/*
ReposListLanguages performs requests for "repos/list-languages"

List repository languages.

  GET /repos/{owner}/{repo}/languages

https://developer.github.com/v3/repos/#list-repository-languages
*/
func ReposListLanguages(ctx context.Context, req *ReposListLanguagesReq, opt ...options.Option) (*ReposListLanguagesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListLanguagesReq)
	}
	resp := &ReposListLanguagesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Language{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListLanguages performs requests for "repos/list-languages"

List repository languages.

  GET /repos/{owner}/{repo}/languages

https://developer.github.com/v3/repos/#list-repository-languages
*/
func (c Client) ReposListLanguages(ctx context.Context, req *ReposListLanguagesReq, opt ...options.Option) (*ReposListLanguagesResponse, error) {
	return ReposListLanguages(ctx, req, append(c, opt...)...)
}

/*
ReposListLanguagesReq is request data for Client.ReposListLanguages

https://developer.github.com/v3/repos/#list-repository-languages
*/
type ReposListLanguagesReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ReposListLanguagesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListLanguagesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-languages",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/languages", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListLanguagesReq) Rel(link RelName, resp *ReposListLanguagesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListLanguagesResponse is a response for ReposListLanguages

https://developer.github.com/v3/repos/#list-repository-languages
*/
type ReposListLanguagesResponse struct {
	common.Response
	request *ReposListLanguagesReq
	Data    components.Language
}

/*
ReposListPagesBuilds performs requests for "repos/list-pages-builds"

List GitHub Pages builds.

  GET /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#list-github-pages-builds
*/
func ReposListPagesBuilds(ctx context.Context, req *ReposListPagesBuildsReq, opt ...options.Option) (*ReposListPagesBuildsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListPagesBuildsReq)
	}
	resp := &ReposListPagesBuildsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.PageBuild{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListPagesBuilds performs requests for "repos/list-pages-builds"

List GitHub Pages builds.

  GET /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#list-github-pages-builds
*/
func (c Client) ReposListPagesBuilds(ctx context.Context, req *ReposListPagesBuildsReq, opt ...options.Option) (*ReposListPagesBuildsResponse, error) {
	return ReposListPagesBuilds(ctx, req, append(c, opt...)...)
}

/*
ReposListPagesBuildsReq is request data for Client.ReposListPagesBuilds

https://developer.github.com/v3/repos/pages/#list-github-pages-builds
*/
type ReposListPagesBuildsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListPagesBuildsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListPagesBuildsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-pages-builds",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages/builds", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListPagesBuildsReq) Rel(link RelName, resp *ReposListPagesBuildsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListPagesBuildsResponse is a response for ReposListPagesBuilds

https://developer.github.com/v3/repos/pages/#list-github-pages-builds
*/
type ReposListPagesBuildsResponse struct {
	common.Response
	request *ReposListPagesBuildsReq
	Data    []components.PageBuild
}

/*
ReposListPublic performs requests for "repos/list-public"

List public repositories.

  GET /repositories

https://developer.github.com/v3/repos/#list-public-repositories
*/
func ReposListPublic(ctx context.Context, req *ReposListPublicReq, opt ...options.Option) (*ReposListPublicResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListPublicReq)
	}
	resp := &ReposListPublicResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListPublic performs requests for "repos/list-public"

List public repositories.

  GET /repositories

https://developer.github.com/v3/repos/#list-public-repositories
*/
func (c Client) ReposListPublic(ctx context.Context, req *ReposListPublicReq, opt ...options.Option) (*ReposListPublicResponse, error) {
	return ReposListPublic(ctx, req, append(c, opt...)...)
}

/*
ReposListPublicReq is request data for Client.ReposListPublic

https://developer.github.com/v3/repos/#list-public-repositories
*/
type ReposListPublicReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since      *string
	Visibility *string
}

// HTTPRequest builds an *http.Request
func (r *ReposListPublicReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListPublicReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Visibility != nil {
		query.Set("visibility", *r.Visibility)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-public",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repositories"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListPublicReq) Rel(link RelName, resp *ReposListPublicResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListPublicResponse is a response for ReposListPublic

https://developer.github.com/v3/repos/#list-public-repositories
*/
type ReposListPublicResponse struct {
	common.Response
	request *ReposListPublicReq
	Data    []components.MinimalRepository
}

/*
ReposListPullRequestsAssociatedWithCommit performs requests for "repos/list-pull-requests-associated-with-commit"

List pull requests associated with a commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-a-commit
*/
func ReposListPullRequestsAssociatedWithCommit(ctx context.Context, req *ReposListPullRequestsAssociatedWithCommitReq, opt ...options.Option) (*ReposListPullRequestsAssociatedWithCommitResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListPullRequestsAssociatedWithCommitReq)
	}
	resp := &ReposListPullRequestsAssociatedWithCommitResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.PullRequestSimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListPullRequestsAssociatedWithCommit performs requests for "repos/list-pull-requests-associated-with-commit"

List pull requests associated with a commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-a-commit
*/
func (c Client) ReposListPullRequestsAssociatedWithCommit(ctx context.Context, req *ReposListPullRequestsAssociatedWithCommitReq, opt ...options.Option) (*ReposListPullRequestsAssociatedWithCommitResponse, error) {
	return ReposListPullRequestsAssociatedWithCommit(ctx, req, append(c, opt...)...)
}

/*
ReposListPullRequestsAssociatedWithCommitReq is request data for Client.ReposListPullRequestsAssociatedWithCommit

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-a-commit
*/
type ReposListPullRequestsAssociatedWithCommitReq struct {
	_url  string
	Owner string
	Repo  string

	// commit_sha+ parameter
	CommitSha string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Listing branches or pull requests for a commit in the Commits API is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-04-11-pulls-branches-for-commit/)
	for more details. To access the new endpoints during the preview period, you
	must set this to true.
	*/
	GrootPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposListPullRequestsAssociatedWithCommitReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"groot"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-pull-requests-associated-with-commit",
		Previews:         map[string]bool{"groot": r.GrootPreview},
		RequiredPreviews: []string{"groot"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/pulls", r.Owner, r.Repo, r.CommitSha),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListPullRequestsAssociatedWithCommitReq) Rel(link RelName, resp *ReposListPullRequestsAssociatedWithCommitResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListPullRequestsAssociatedWithCommitResponse is a response for ReposListPullRequestsAssociatedWithCommit

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-a-commit
*/
type ReposListPullRequestsAssociatedWithCommitResponse struct {
	common.Response
	request *ReposListPullRequestsAssociatedWithCommitReq
	Data    []components.PullRequestSimple
}

/*
ReposListReleaseAssets performs requests for "repos/list-release-assets"

List release assets.

  GET /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#list-release-assets
*/
func ReposListReleaseAssets(ctx context.Context, req *ReposListReleaseAssetsReq, opt ...options.Option) (*ReposListReleaseAssetsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListReleaseAssetsReq)
	}
	resp := &ReposListReleaseAssetsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ReleaseAsset{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListReleaseAssets performs requests for "repos/list-release-assets"

List release assets.

  GET /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#list-release-assets
*/
func (c Client) ReposListReleaseAssets(ctx context.Context, req *ReposListReleaseAssetsReq, opt ...options.Option) (*ReposListReleaseAssetsResponse, error) {
	return ReposListReleaseAssets(ctx, req, append(c, opt...)...)
}

/*
ReposListReleaseAssetsReq is request data for Client.ReposListReleaseAssets

https://developer.github.com/v3/repos/releases/#list-release-assets
*/
type ReposListReleaseAssetsReq struct {
	_url  string
	Owner string
	Repo  string

	// release_id parameter
	ReleaseId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListReleaseAssetsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListReleaseAssetsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-release-assets",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/%v/assets", r.Owner, r.Repo, r.ReleaseId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListReleaseAssetsReq) Rel(link RelName, resp *ReposListReleaseAssetsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListReleaseAssetsResponse is a response for ReposListReleaseAssets

https://developer.github.com/v3/repos/releases/#list-release-assets
*/
type ReposListReleaseAssetsResponse struct {
	common.Response
	request *ReposListReleaseAssetsReq
	Data    []components.ReleaseAsset
}

/*
ReposListReleases performs requests for "repos/list-releases"

List releases.

  GET /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#list-releases
*/
func ReposListReleases(ctx context.Context, req *ReposListReleasesReq, opt ...options.Option) (*ReposListReleasesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListReleasesReq)
	}
	resp := &ReposListReleasesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Release{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListReleases performs requests for "repos/list-releases"

List releases.

  GET /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#list-releases
*/
func (c Client) ReposListReleases(ctx context.Context, req *ReposListReleasesReq, opt ...options.Option) (*ReposListReleasesResponse, error) {
	return ReposListReleases(ctx, req, append(c, opt...)...)
}

/*
ReposListReleasesReq is request data for Client.ReposListReleases

https://developer.github.com/v3/repos/releases/#list-releases
*/
type ReposListReleasesReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListReleasesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListReleasesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-releases",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListReleasesReq) Rel(link RelName, resp *ReposListReleasesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListReleasesResponse is a response for ReposListReleases

https://developer.github.com/v3/repos/releases/#list-releases
*/
type ReposListReleasesResponse struct {
	common.Response
	request *ReposListReleasesReq
	Data    []components.Release
}

/*
ReposListTags performs requests for "repos/list-tags"

List repository tags.

  GET /repos/{owner}/{repo}/tags

https://developer.github.com/v3/repos/#list-repository-tags
*/
func ReposListTags(ctx context.Context, req *ReposListTagsReq, opt ...options.Option) (*ReposListTagsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListTagsReq)
	}
	resp := &ReposListTagsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Tag{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListTags performs requests for "repos/list-tags"

List repository tags.

  GET /repos/{owner}/{repo}/tags

https://developer.github.com/v3/repos/#list-repository-tags
*/
func (c Client) ReposListTags(ctx context.Context, req *ReposListTagsReq, opt ...options.Option) (*ReposListTagsResponse, error) {
	return ReposListTags(ctx, req, append(c, opt...)...)
}

/*
ReposListTagsReq is request data for Client.ReposListTags

https://developer.github.com/v3/repos/#list-repository-tags
*/
type ReposListTagsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListTagsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListTagsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-tags",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/tags", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListTagsReq) Rel(link RelName, resp *ReposListTagsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListTagsResponse is a response for ReposListTags

https://developer.github.com/v3/repos/#list-repository-tags
*/
type ReposListTagsResponse struct {
	common.Response
	request *ReposListTagsReq
	Data    []components.Tag
}

/*
ReposListTeams performs requests for "repos/list-teams"

List repository teams.

  GET /repos/{owner}/{repo}/teams

https://developer.github.com/v3/repos/#list-repository-teams
*/
func ReposListTeams(ctx context.Context, req *ReposListTeamsReq, opt ...options.Option) (*ReposListTeamsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListTeamsReq)
	}
	resp := &ReposListTeamsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListTeams performs requests for "repos/list-teams"

List repository teams.

  GET /repos/{owner}/{repo}/teams

https://developer.github.com/v3/repos/#list-repository-teams
*/
func (c Client) ReposListTeams(ctx context.Context, req *ReposListTeamsReq, opt ...options.Option) (*ReposListTeamsResponse, error) {
	return ReposListTeams(ctx, req, append(c, opt...)...)
}

/*
ReposListTeamsReq is request data for Client.ReposListTeams

https://developer.github.com/v3/repos/#list-repository-teams
*/
type ReposListTeamsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListTeamsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListTeamsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-teams",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/teams", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListTeamsReq) Rel(link RelName, resp *ReposListTeamsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListTeamsResponse is a response for ReposListTeams

https://developer.github.com/v3/repos/#list-repository-teams
*/
type ReposListTeamsResponse struct {
	common.Response
	request *ReposListTeamsReq
	Data    []components.Team
}

/*
ReposListWebhooks performs requests for "repos/list-webhooks"

List repository webhooks.

  GET /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#list-repository-webhooks
*/
func ReposListWebhooks(ctx context.Context, req *ReposListWebhooksReq, opt ...options.Option) (*ReposListWebhooksResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposListWebhooksReq)
	}
	resp := &ReposListWebhooksResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Hook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListWebhooks performs requests for "repos/list-webhooks"

List repository webhooks.

  GET /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#list-repository-webhooks
*/
func (c Client) ReposListWebhooks(ctx context.Context, req *ReposListWebhooksReq, opt ...options.Option) (*ReposListWebhooksResponse, error) {
	return ReposListWebhooks(ctx, req, append(c, opt...)...)
}

/*
ReposListWebhooksReq is request data for Client.ReposListWebhooks

https://developer.github.com/v3/repos/hooks/#list-repository-webhooks
*/
type ReposListWebhooksReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ReposListWebhooksReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposListWebhooksReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-webhooks",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListWebhooksReq) Rel(link RelName, resp *ReposListWebhooksResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListWebhooksResponse is a response for ReposListWebhooks

https://developer.github.com/v3/repos/hooks/#list-repository-webhooks
*/
type ReposListWebhooksResponse struct {
	common.Response
	request *ReposListWebhooksReq
	Data    []components.Hook
}

/*
ReposMerge performs requests for "repos/merge"

Merge a branch.

  POST /repos/{owner}/{repo}/merges

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
func ReposMerge(ctx context.Context, req *ReposMergeReq, opt ...options.Option) (*ReposMergeResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposMergeReq)
	}
	resp := &ReposMergeResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Commit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposMerge performs requests for "repos/merge"

Merge a branch.

  POST /repos/{owner}/{repo}/merges

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
func (c Client) ReposMerge(ctx context.Context, req *ReposMergeReq, opt ...options.Option) (*ReposMergeResponse, error) {
	return ReposMerge(ctx, req, append(c, opt...)...)
}

/*
ReposMergeReq is request data for Client.ReposMerge

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
type ReposMergeReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposMergeReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposMergeReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposMergeReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/merge",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/merges", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposMergeReq) Rel(link RelName, resp *ReposMergeResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposMergeReqBody is a request body for repos/merge

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
type ReposMergeReqBody struct {

	// The name of the base branch that the head will be merged into.
	Base *string `json:"base"`

	// Commit message to use for the merge commit. If omitted, a default message will be used.
	CommitMessage *string `json:"commit_message,omitempty"`

	// The head to merge. This can be a branch name or a commit SHA1.
	Head *string `json:"head"`
}

/*
ReposMergeResponse is a response for ReposMerge

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
type ReposMergeResponse struct {
	common.Response
	request *ReposMergeReq
	Data    components.Commit
}

/*
ReposPingWebhook performs requests for "repos/ping-webhook"

Ping a repository webhook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/pings

https://developer.github.com/v3/repos/hooks/#ping-a-repository-webhook
*/
func ReposPingWebhook(ctx context.Context, req *ReposPingWebhookReq, opt ...options.Option) (*ReposPingWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposPingWebhookReq)
	}
	resp := &ReposPingWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposPingWebhook performs requests for "repos/ping-webhook"

Ping a repository webhook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/pings

https://developer.github.com/v3/repos/hooks/#ping-a-repository-webhook
*/
func (c Client) ReposPingWebhook(ctx context.Context, req *ReposPingWebhookReq, opt ...options.Option) (*ReposPingWebhookResponse, error) {
	return ReposPingWebhook(ctx, req, append(c, opt...)...)
}

/*
ReposPingWebhookReq is request data for Client.ReposPingWebhook

https://developer.github.com/v3/repos/hooks/#ping-a-repository-webhook
*/
type ReposPingWebhookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposPingWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposPingWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "POST",
		OperationID:      "repos/ping-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks/%v/pings", r.Owner, r.Repo, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposPingWebhookReq) Rel(link RelName, resp *ReposPingWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposPingWebhookResponse is a response for ReposPingWebhook

https://developer.github.com/v3/repos/hooks/#ping-a-repository-webhook
*/
type ReposPingWebhookResponse struct {
	common.Response
	request *ReposPingWebhookReq
	Data    bool
}

/*
ReposRemoveAppAccessRestrictions performs requests for "repos/remove-app-access-restrictions"

Remove app access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
func ReposRemoveAppAccessRestrictions(ctx context.Context, req *ReposRemoveAppAccessRestrictionsReq, opt ...options.Option) (*ReposRemoveAppAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposRemoveAppAccessRestrictionsReq)
	}
	resp := &ReposRemoveAppAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Integration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveAppAccessRestrictions performs requests for "repos/remove-app-access-restrictions"

Remove app access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
func (c Client) ReposRemoveAppAccessRestrictions(ctx context.Context, req *ReposRemoveAppAccessRestrictionsReq, opt ...options.Option) (*ReposRemoveAppAccessRestrictionsResponse, error) {
	return ReposRemoveAppAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposRemoveAppAccessRestrictionsReq is request data for Client.ReposRemoveAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
type ReposRemoveAppAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposRemoveAppAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposRemoveAppAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposRemoveAppAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "DELETE",
		OperationID:      "repos/remove-app-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveAppAccessRestrictionsReq) Rel(link RelName, resp *ReposRemoveAppAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveAppAccessRestrictionsReqBody is a request body for repos/remove-app-access-restrictions

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
type ReposRemoveAppAccessRestrictionsReqBody []string

/*
ReposRemoveAppAccessRestrictionsResponse is a response for ReposRemoveAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
type ReposRemoveAppAccessRestrictionsResponse struct {
	common.Response
	request *ReposRemoveAppAccessRestrictionsReq
	Data    []components.Integration
}

/*
ReposRemoveCollaborator performs requests for "repos/remove-collaborator"

Remove a repository collaborator.

  DELETE /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#remove-a-repository-collaborator
*/
func ReposRemoveCollaborator(ctx context.Context, req *ReposRemoveCollaboratorReq, opt ...options.Option) (*ReposRemoveCollaboratorResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposRemoveCollaboratorReq)
	}
	resp := &ReposRemoveCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveCollaborator performs requests for "repos/remove-collaborator"

Remove a repository collaborator.

  DELETE /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#remove-a-repository-collaborator
*/
func (c Client) ReposRemoveCollaborator(ctx context.Context, req *ReposRemoveCollaboratorReq, opt ...options.Option) (*ReposRemoveCollaboratorResponse, error) {
	return ReposRemoveCollaborator(ctx, req, append(c, opt...)...)
}

/*
ReposRemoveCollaboratorReq is request data for Client.ReposRemoveCollaborator

https://developer.github.com/v3/repos/collaborators/#remove-a-repository-collaborator
*/
type ReposRemoveCollaboratorReq struct {
	_url     string
	Owner    string
	Repo     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *ReposRemoveCollaboratorReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposRemoveCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/remove-collaborator",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveCollaboratorReq) Rel(link RelName, resp *ReposRemoveCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveCollaboratorResponse is a response for ReposRemoveCollaborator

https://developer.github.com/v3/repos/collaborators/#remove-a-repository-collaborator
*/
type ReposRemoveCollaboratorResponse struct {
	common.Response
	request *ReposRemoveCollaboratorReq
}

/*
ReposRemoveStatusCheckContexts performs requests for "repos/remove-status-check-contexts"

Remove status check contexts.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
func ReposRemoveStatusCheckContexts(ctx context.Context, req *ReposRemoveStatusCheckContextsReq, opt ...options.Option) (*ReposRemoveStatusCheckContextsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposRemoveStatusCheckContextsReq)
	}
	resp := &ReposRemoveStatusCheckContextsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ReposRemoveStatusCheckContextsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveStatusCheckContexts performs requests for "repos/remove-status-check-contexts"

Remove status check contexts.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
func (c Client) ReposRemoveStatusCheckContexts(ctx context.Context, req *ReposRemoveStatusCheckContextsReq, opt ...options.Option) (*ReposRemoveStatusCheckContextsResponse, error) {
	return ReposRemoveStatusCheckContexts(ctx, req, append(c, opt...)...)
}

/*
ReposRemoveStatusCheckContextsReq is request data for Client.ReposRemoveStatusCheckContexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
type ReposRemoveStatusCheckContextsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposRemoveStatusCheckContextsReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposRemoveStatusCheckContextsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposRemoveStatusCheckContextsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "DELETE",
		OperationID:      "repos/remove-status-check-contexts",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveStatusCheckContextsReq) Rel(link RelName, resp *ReposRemoveStatusCheckContextsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveStatusCheckContextsReqBody is a request body for repos/remove-status-check-contexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
type ReposRemoveStatusCheckContextsReqBody []string

/*
ReposRemoveStatusCheckContextsResponseBody is a response body for ReposRemoveStatusCheckContexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
type ReposRemoveStatusCheckContextsResponseBody []string

/*
ReposRemoveStatusCheckContextsResponse is a response for ReposRemoveStatusCheckContexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
type ReposRemoveStatusCheckContextsResponse struct {
	common.Response
	request *ReposRemoveStatusCheckContextsReq
	Data    ReposRemoveStatusCheckContextsResponseBody
}

/*
ReposRemoveStatusCheckProtection performs requests for "repos/remove-status-check-protection"

Remove status check protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#remove-status-check-protection
*/
func ReposRemoveStatusCheckProtection(ctx context.Context, req *ReposRemoveStatusCheckProtectionReq, opt ...options.Option) (*ReposRemoveStatusCheckProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposRemoveStatusCheckProtectionReq)
	}
	resp := &ReposRemoveStatusCheckProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveStatusCheckProtection performs requests for "repos/remove-status-check-protection"

Remove status check protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#remove-status-check-protection
*/
func (c Client) ReposRemoveStatusCheckProtection(ctx context.Context, req *ReposRemoveStatusCheckProtectionReq, opt ...options.Option) (*ReposRemoveStatusCheckProtectionResponse, error) {
	return ReposRemoveStatusCheckProtection(ctx, req, append(c, opt...)...)
}

/*
ReposRemoveStatusCheckProtectionReq is request data for Client.ReposRemoveStatusCheckProtection

https://developer.github.com/v3/repos/branches/#remove-status-check-protection
*/
type ReposRemoveStatusCheckProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposRemoveStatusCheckProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposRemoveStatusCheckProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/remove-status-check-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveStatusCheckProtectionReq) Rel(link RelName, resp *ReposRemoveStatusCheckProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveStatusCheckProtectionResponse is a response for ReposRemoveStatusCheckProtection

https://developer.github.com/v3/repos/branches/#remove-status-check-protection
*/
type ReposRemoveStatusCheckProtectionResponse struct {
	common.Response
	request *ReposRemoveStatusCheckProtectionReq
}

/*
ReposRemoveTeamAccessRestrictions performs requests for "repos/remove-team-access-restrictions"

Remove team access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
func ReposRemoveTeamAccessRestrictions(ctx context.Context, req *ReposRemoveTeamAccessRestrictionsReq, opt ...options.Option) (*ReposRemoveTeamAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposRemoveTeamAccessRestrictionsReq)
	}
	resp := &ReposRemoveTeamAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveTeamAccessRestrictions performs requests for "repos/remove-team-access-restrictions"

Remove team access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
func (c Client) ReposRemoveTeamAccessRestrictions(ctx context.Context, req *ReposRemoveTeamAccessRestrictionsReq, opt ...options.Option) (*ReposRemoveTeamAccessRestrictionsResponse, error) {
	return ReposRemoveTeamAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposRemoveTeamAccessRestrictionsReq is request data for Client.ReposRemoveTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
type ReposRemoveTeamAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposRemoveTeamAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposRemoveTeamAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposRemoveTeamAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "DELETE",
		OperationID:      "repos/remove-team-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveTeamAccessRestrictionsReq) Rel(link RelName, resp *ReposRemoveTeamAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveTeamAccessRestrictionsReqBody is a request body for repos/remove-team-access-restrictions

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
type ReposRemoveTeamAccessRestrictionsReqBody []string

/*
ReposRemoveTeamAccessRestrictionsResponse is a response for ReposRemoveTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
type ReposRemoveTeamAccessRestrictionsResponse struct {
	common.Response
	request *ReposRemoveTeamAccessRestrictionsReq
	Data    []components.Team
}

/*
ReposRemoveUserAccessRestrictions performs requests for "repos/remove-user-access-restrictions"

Remove user access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
func ReposRemoveUserAccessRestrictions(ctx context.Context, req *ReposRemoveUserAccessRestrictionsReq, opt ...options.Option) (*ReposRemoveUserAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposRemoveUserAccessRestrictionsReq)
	}
	resp := &ReposRemoveUserAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveUserAccessRestrictions performs requests for "repos/remove-user-access-restrictions"

Remove user access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
func (c Client) ReposRemoveUserAccessRestrictions(ctx context.Context, req *ReposRemoveUserAccessRestrictionsReq, opt ...options.Option) (*ReposRemoveUserAccessRestrictionsResponse, error) {
	return ReposRemoveUserAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposRemoveUserAccessRestrictionsReq is request data for Client.ReposRemoveUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
type ReposRemoveUserAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposRemoveUserAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposRemoveUserAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposRemoveUserAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "DELETE",
		OperationID:      "repos/remove-user-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveUserAccessRestrictionsReq) Rel(link RelName, resp *ReposRemoveUserAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveUserAccessRestrictionsReqBody is a request body for repos/remove-user-access-restrictions

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
type ReposRemoveUserAccessRestrictionsReqBody []string

/*
ReposRemoveUserAccessRestrictionsResponse is a response for ReposRemoveUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
type ReposRemoveUserAccessRestrictionsResponse struct {
	common.Response
	request *ReposRemoveUserAccessRestrictionsReq
	Data    []components.SimpleUser
}

/*
ReposReplaceAllTopics performs requests for "repos/replace-all-topics"

Replace all repository topics.

  PUT /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
func ReposReplaceAllTopics(ctx context.Context, req *ReposReplaceAllTopicsReq, opt ...options.Option) (*ReposReplaceAllTopicsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposReplaceAllTopicsReq)
	}
	resp := &ReposReplaceAllTopicsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Topic{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposReplaceAllTopics performs requests for "repos/replace-all-topics"

Replace all repository topics.

  PUT /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
func (c Client) ReposReplaceAllTopics(ctx context.Context, req *ReposReplaceAllTopicsReq, opt ...options.Option) (*ReposReplaceAllTopicsResponse, error) {
	return ReposReplaceAllTopics(ctx, req, append(c, opt...)...)
}

/*
ReposReplaceAllTopicsReq is request data for Client.ReposReplaceAllTopics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposReplaceAllTopicsReqBody

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposReplaceAllTopicsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposReplaceAllTopicsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"mercy"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/replace-all-topics",
		Previews:         map[string]bool{"mercy": r.MercyPreview},
		RequiredPreviews: []string{"mercy"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/topics", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposReplaceAllTopicsReq) Rel(link RelName, resp *ReposReplaceAllTopicsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposReplaceAllTopicsReqBody is a request body for repos/replace-all-topics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsReqBody struct {

	/*
	An array of topics to add to the repository. Pass one or more topics to
	_replace_ the set of existing topics. Send an empty array (`[]`) to clear all
	topics from the repository. **Note:** Topic `names` cannot contain uppercase
	letters.
	*/
	Names []string `json:"names"`
}

/*
ReposReplaceAllTopicsResponse is a response for ReposReplaceAllTopics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsResponse struct {
	common.Response
	request *ReposReplaceAllTopicsReq
	Data    components.Topic
}

/*
ReposRequestPagesBuild performs requests for "repos/request-pages-build"

Request a GitHub Pages build.

  POST /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#request-a-github-pages-build
*/
func ReposRequestPagesBuild(ctx context.Context, req *ReposRequestPagesBuildReq, opt ...options.Option) (*ReposRequestPagesBuildResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposRequestPagesBuildReq)
	}
	resp := &ReposRequestPagesBuildResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PageBuildStatus{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRequestPagesBuild performs requests for "repos/request-pages-build"

Request a GitHub Pages build.

  POST /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#request-a-github-pages-build
*/
func (c Client) ReposRequestPagesBuild(ctx context.Context, req *ReposRequestPagesBuildReq, opt ...options.Option) (*ReposRequestPagesBuildResponse, error) {
	return ReposRequestPagesBuild(ctx, req, append(c, opt...)...)
}

/*
ReposRequestPagesBuildReq is request data for Client.ReposRequestPagesBuild

https://developer.github.com/v3/repos/pages/#request-a-github-pages-build
*/
type ReposRequestPagesBuildReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ReposRequestPagesBuildReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposRequestPagesBuildReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{201},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "POST",
		OperationID:      "repos/request-pages-build",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages/builds", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRequestPagesBuildReq) Rel(link RelName, resp *ReposRequestPagesBuildResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRequestPagesBuildResponse is a response for ReposRequestPagesBuild

https://developer.github.com/v3/repos/pages/#request-a-github-pages-build
*/
type ReposRequestPagesBuildResponse struct {
	common.Response
	request *ReposRequestPagesBuildReq
	Data    components.PageBuildStatus
}

/*
ReposSetAdminBranchProtection performs requests for "repos/set-admin-branch-protection"

Set admin branch protection.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#set-admin-branch-protection
*/
func ReposSetAdminBranchProtection(ctx context.Context, req *ReposSetAdminBranchProtectionReq, opt ...options.Option) (*ReposSetAdminBranchProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposSetAdminBranchProtectionReq)
	}
	resp := &ReposSetAdminBranchProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranchAdminEnforced{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposSetAdminBranchProtection performs requests for "repos/set-admin-branch-protection"

Set admin branch protection.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#set-admin-branch-protection
*/
func (c Client) ReposSetAdminBranchProtection(ctx context.Context, req *ReposSetAdminBranchProtectionReq, opt ...options.Option) (*ReposSetAdminBranchProtectionResponse, error) {
	return ReposSetAdminBranchProtection(ctx, req, append(c, opt...)...)
}

/*
ReposSetAdminBranchProtectionReq is request data for Client.ReposSetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#set-admin-branch-protection
*/
type ReposSetAdminBranchProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *ReposSetAdminBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposSetAdminBranchProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "POST",
		OperationID:      "repos/set-admin-branch-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposSetAdminBranchProtectionReq) Rel(link RelName, resp *ReposSetAdminBranchProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposSetAdminBranchProtectionResponse is a response for ReposSetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#set-admin-branch-protection
*/
type ReposSetAdminBranchProtectionResponse struct {
	common.Response
	request *ReposSetAdminBranchProtectionReq
	Data    components.ProtectedBranchAdminEnforced
}

/*
ReposSetAppAccessRestrictions performs requests for "repos/set-app-access-restrictions"

Set app access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
func ReposSetAppAccessRestrictions(ctx context.Context, req *ReposSetAppAccessRestrictionsReq, opt ...options.Option) (*ReposSetAppAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposSetAppAccessRestrictionsReq)
	}
	resp := &ReposSetAppAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Integration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposSetAppAccessRestrictions performs requests for "repos/set-app-access-restrictions"

Set app access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
func (c Client) ReposSetAppAccessRestrictions(ctx context.Context, req *ReposSetAppAccessRestrictionsReq, opt ...options.Option) (*ReposSetAppAccessRestrictionsResponse, error) {
	return ReposSetAppAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposSetAppAccessRestrictionsReq is request data for Client.ReposSetAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
type ReposSetAppAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposSetAppAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposSetAppAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposSetAppAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/set-app-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposSetAppAccessRestrictionsReq) Rel(link RelName, resp *ReposSetAppAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposSetAppAccessRestrictionsReqBody is a request body for repos/set-app-access-restrictions

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
type ReposSetAppAccessRestrictionsReqBody []string

/*
ReposSetAppAccessRestrictionsResponse is a response for ReposSetAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
type ReposSetAppAccessRestrictionsResponse struct {
	common.Response
	request *ReposSetAppAccessRestrictionsReq
	Data    []components.Integration
}

/*
ReposSetStatusCheckContexts performs requests for "repos/set-status-check-contexts"

Set status check contexts.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
func ReposSetStatusCheckContexts(ctx context.Context, req *ReposSetStatusCheckContextsReq, opt ...options.Option) (*ReposSetStatusCheckContextsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposSetStatusCheckContextsReq)
	}
	resp := &ReposSetStatusCheckContextsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ReposSetStatusCheckContextsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposSetStatusCheckContexts performs requests for "repos/set-status-check-contexts"

Set status check contexts.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
func (c Client) ReposSetStatusCheckContexts(ctx context.Context, req *ReposSetStatusCheckContextsReq, opt ...options.Option) (*ReposSetStatusCheckContextsResponse, error) {
	return ReposSetStatusCheckContexts(ctx, req, append(c, opt...)...)
}

/*
ReposSetStatusCheckContextsReq is request data for Client.ReposSetStatusCheckContexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
type ReposSetStatusCheckContextsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposSetStatusCheckContextsReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposSetStatusCheckContextsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposSetStatusCheckContextsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/set-status-check-contexts",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposSetStatusCheckContextsReq) Rel(link RelName, resp *ReposSetStatusCheckContextsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposSetStatusCheckContextsReqBody is a request body for repos/set-status-check-contexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
type ReposSetStatusCheckContextsReqBody []string

/*
ReposSetStatusCheckContextsResponseBody is a response body for ReposSetStatusCheckContexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
type ReposSetStatusCheckContextsResponseBody []string

/*
ReposSetStatusCheckContextsResponse is a response for ReposSetStatusCheckContexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
type ReposSetStatusCheckContextsResponse struct {
	common.Response
	request *ReposSetStatusCheckContextsReq
	Data    ReposSetStatusCheckContextsResponseBody
}

/*
ReposSetTeamAccessRestrictions performs requests for "repos/set-team-access-restrictions"

Set team access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
func ReposSetTeamAccessRestrictions(ctx context.Context, req *ReposSetTeamAccessRestrictionsReq, opt ...options.Option) (*ReposSetTeamAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposSetTeamAccessRestrictionsReq)
	}
	resp := &ReposSetTeamAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposSetTeamAccessRestrictions performs requests for "repos/set-team-access-restrictions"

Set team access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
func (c Client) ReposSetTeamAccessRestrictions(ctx context.Context, req *ReposSetTeamAccessRestrictionsReq, opt ...options.Option) (*ReposSetTeamAccessRestrictionsResponse, error) {
	return ReposSetTeamAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposSetTeamAccessRestrictionsReq is request data for Client.ReposSetTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
type ReposSetTeamAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposSetTeamAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposSetTeamAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposSetTeamAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/set-team-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposSetTeamAccessRestrictionsReq) Rel(link RelName, resp *ReposSetTeamAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposSetTeamAccessRestrictionsReqBody is a request body for repos/set-team-access-restrictions

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
type ReposSetTeamAccessRestrictionsReqBody []string

/*
ReposSetTeamAccessRestrictionsResponse is a response for ReposSetTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
type ReposSetTeamAccessRestrictionsResponse struct {
	common.Response
	request *ReposSetTeamAccessRestrictionsReq
	Data    []components.Team
}

/*
ReposSetUserAccessRestrictions performs requests for "repos/set-user-access-restrictions"

Set user access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
func ReposSetUserAccessRestrictions(ctx context.Context, req *ReposSetUserAccessRestrictionsReq, opt ...options.Option) (*ReposSetUserAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposSetUserAccessRestrictionsReq)
	}
	resp := &ReposSetUserAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposSetUserAccessRestrictions performs requests for "repos/set-user-access-restrictions"

Set user access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
func (c Client) ReposSetUserAccessRestrictions(ctx context.Context, req *ReposSetUserAccessRestrictionsReq, opt ...options.Option) (*ReposSetUserAccessRestrictionsResponse, error) {
	return ReposSetUserAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposSetUserAccessRestrictionsReq is request data for Client.ReposSetUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
type ReposSetUserAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposSetUserAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposSetUserAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposSetUserAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/set-user-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposSetUserAccessRestrictionsReq) Rel(link RelName, resp *ReposSetUserAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposSetUserAccessRestrictionsReqBody is a request body for repos/set-user-access-restrictions

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
type ReposSetUserAccessRestrictionsReqBody []string

/*
ReposSetUserAccessRestrictionsResponse is a response for ReposSetUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
type ReposSetUserAccessRestrictionsResponse struct {
	common.Response
	request *ReposSetUserAccessRestrictionsReq
	Data    []components.SimpleUser
}

/*
ReposTestPushWebhook performs requests for "repos/test-push-webhook"

Test the push repository webhook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/tests

https://developer.github.com/v3/repos/hooks/#test-the-push-repository-webhook
*/
func ReposTestPushWebhook(ctx context.Context, req *ReposTestPushWebhookReq, opt ...options.Option) (*ReposTestPushWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposTestPushWebhookReq)
	}
	resp := &ReposTestPushWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposTestPushWebhook performs requests for "repos/test-push-webhook"

Test the push repository webhook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/tests

https://developer.github.com/v3/repos/hooks/#test-the-push-repository-webhook
*/
func (c Client) ReposTestPushWebhook(ctx context.Context, req *ReposTestPushWebhookReq, opt ...options.Option) (*ReposTestPushWebhookResponse, error) {
	return ReposTestPushWebhook(ctx, req, append(c, opt...)...)
}

/*
ReposTestPushWebhookReq is request data for Client.ReposTestPushWebhook

https://developer.github.com/v3/repos/hooks/#test-the-push-repository-webhook
*/
type ReposTestPushWebhookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *ReposTestPushWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposTestPushWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "POST",
		OperationID:      "repos/test-push-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks/%v/tests", r.Owner, r.Repo, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposTestPushWebhookReq) Rel(link RelName, resp *ReposTestPushWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposTestPushWebhookResponse is a response for ReposTestPushWebhook

https://developer.github.com/v3/repos/hooks/#test-the-push-repository-webhook
*/
type ReposTestPushWebhookResponse struct {
	common.Response
	request *ReposTestPushWebhookReq
	Data    bool
}

/*
ReposTransfer performs requests for "repos/transfer"

Transfer a repository.

  POST /repos/{owner}/{repo}/transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
func ReposTransfer(ctx context.Context, req *ReposTransferReq, opt ...options.Option) (*ReposTransferResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposTransferReq)
	}
	resp := &ReposTransferResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Repository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposTransfer performs requests for "repos/transfer"

Transfer a repository.

  POST /repos/{owner}/{repo}/transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
func (c Client) ReposTransfer(ctx context.Context, req *ReposTransferReq, opt ...options.Option) (*ReposTransferResponse, error) {
	return ReposTransfer(ctx, req, append(c, opt...)...)
}

/*
ReposTransferReq is request data for Client.ReposTransfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposTransferReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposTransferReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposTransferReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{202},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/transfer",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/transfer", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{202},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposTransferReq) Rel(link RelName, resp *ReposTransferResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposTransferReqBody is a request body for repos/transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferReqBody struct {

	// **Required:** The username or organization name the repository will be transferred to.
	NewOwner *string `json:"new_owner,omitempty"`

	// ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
	TeamIds []int64 `json:"team_ids,omitempty"`
}

/*
ReposTransferResponse is a response for ReposTransfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferResponse struct {
	common.Response
	request *ReposTransferReq
	Data    components.Repository
}

/*
ReposUpdate performs requests for "repos/update"

Update a repository.

  PATCH /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#update-a-repository
*/
func ReposUpdate(ctx context.Context, req *ReposUpdateReq, opt ...options.Option) (*ReposUpdateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposUpdateReq)
	}
	resp := &ReposUpdateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.FullRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdate performs requests for "repos/update"

Update a repository.

  PATCH /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#update-a-repository
*/
func (c Client) ReposUpdate(ctx context.Context, req *ReposUpdateReq, opt ...options.Option) (*ReposUpdateResponse, error) {
	return ReposUpdate(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateReq is request data for Client.ReposUpdate

https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposUpdateReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposUpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"nebula", "baptiste"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:      "PATCH",
		OperationID: "repos/update",
		Previews: map[string]bool{
			"baptiste": r.BaptistePreview,
			"nebula":   r.NebulaPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateReq) Rel(link RelName, resp *ReposUpdateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateReqBody is a request body for repos/update

https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateReqBody struct {

	/*
	Either `true` to allow merging pull requests with a merge commit, or `false` to
	prevent merging pull requests with merge commits.
	*/
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	// `true` to archive this repository. **Note**: You cannot unarchive repositories through the API.
	Archived *bool `json:"archived,omitempty"`

	// Updates the default branch for this repository.
	DefaultBranch *string `json:"default_branch,omitempty"`

	/*
	Either `true` to allow automatically deleting head branches when pull requests
	are merged, or `false` to prevent automatic deletion.
	*/
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	// Either `true` to enable issues for this repository or `false` to disable them.
	HasIssues *bool `json:"has_issues,omitempty"`

	/*
	Either `true` to enable projects for this repository or `false` to disable them.
	**Note:** If you're creating a repository in an organization that has disabled
	repository projects, the default is `false`, and if you pass `true`, the API
	returns an error.
	*/
	HasProjects *bool `json:"has_projects,omitempty"`

	// Either `true` to enable the wiki for this repository or `false` to disable it.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	// Either `true` to make this repo available as a template repository or `false` to prevent it.
	IsTemplate *bool `json:"is_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name,omitempty"`

	/*
	Either `true` to make the repository private or `false` to make it public.
	Default: `false`.
	**Note**: You will get a `422` error if the organization restricts [changing
	repository
	visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories)
	to organization owners and a non-owner tries to change the value of private.
	**Note**: You will get a `422` error if the organization restricts [changing
	repository
	visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories)
	to organization owners and a non-owner tries to change the value of private.
	*/
	Private *bool `json:"private,omitempty"`

	/*
	Can be `public` or `private`. If your organization is associated with an
	enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server
	2.20+, `visibility` can also be `internal`. The `visibility` parameter overrides
	the `private` parameter when you use both along with the `nebula-preview`
	preview header.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ReposUpdateResponse is a response for ReposUpdate

https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateResponse struct {
	common.Response
	request *ReposUpdateReq
	Data    components.FullRepository
}

/*
ReposUpdateBranchProtection performs requests for "repos/update-branch-protection"

Update branch protection.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
func ReposUpdateBranchProtection(ctx context.Context, req *ReposUpdateBranchProtectionReq, opt ...options.Option) (*ReposUpdateBranchProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposUpdateBranchProtectionReq)
	}
	resp := &ReposUpdateBranchProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranch{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateBranchProtection performs requests for "repos/update-branch-protection"

Update branch protection.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
func (c Client) ReposUpdateBranchProtection(ctx context.Context, req *ReposUpdateBranchProtectionReq, opt ...options.Option) (*ReposUpdateBranchProtectionResponse, error) {
	return ReposUpdateBranchProtection(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateBranchProtectionReq is request data for Client.ReposUpdateBranchProtection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposUpdateBranchProtectionReqBody

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposUpdateBranchProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"luke-cage"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/update-branch-protection",
		Previews:         map[string]bool{"luke-cage": r.LukeCagePreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateBranchProtectionReq) Rel(link RelName, resp *ReposUpdateBranchProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews is a value for ReposUpdateBranchProtectionReqBody's RequiredPullRequestReviews field
type ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews struct {

	// Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
	DismissStaleReviews *bool `json:"dismiss_stale_reviews,omitempty"`

	/*
	Specify which users and teams can dismiss pull request reviews. Pass an empty
	`dismissal_restrictions` object to disable. User and team
	`dismissal_restrictions` are only available for organization-owned repositories.
	Omit this parameter for personal repositories.
	*/
	DismissalRestrictions *ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions `json:"dismissal_restrictions,omitempty"`

	// Blocks merging pull requests until [code owners](https://help.github.com/articles/about-code-owners/) review them.
	RequireCodeOwnerReviews *bool `json:"require_code_owner_reviews,omitempty"`

	// Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6.
	RequiredApprovingReviewCount *int64 `json:"required_approving_review_count,omitempty"`
}

// ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions is a value for ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews's DismissalRestrictions field
type ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions struct {

	// The list of team `slug`s with dismissal access
	Teams []string `json:"teams,omitempty"`

	// The list of user `login`s with dismissal access
	Users []string `json:"users,omitempty"`
}

// ReposUpdateBranchProtectionReqBodyRequiredStatusChecks is a value for ReposUpdateBranchProtectionReqBody's RequiredStatusChecks field
type ReposUpdateBranchProtectionReqBodyRequiredStatusChecks struct {

	// The list of status checks to require in order to merge into this branch
	Contexts []string `json:"contexts"`

	// Require branches to be up to date before merging.
	Strict *bool `json:"strict"`
}

// ReposUpdateBranchProtectionReqBodyRestrictions is a value for ReposUpdateBranchProtectionReqBody's Restrictions field
type ReposUpdateBranchProtectionReqBodyRestrictions struct {

	// The list of app `slug`s with push access
	Apps []string `json:"apps,omitempty"`

	// The list of team `slug`s with push access
	Teams []string `json:"teams"`

	// The list of user `login`s with push access
	Users []string `json:"users"`
}

/*
ReposUpdateBranchProtectionReqBody is a request body for repos/update-branch-protection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionReqBody struct {

	/*
	Allows deletion of the protected branch by anyone with write access to the
	repository. Set to `false` to prevent deletion of the protected branch. Default:
	`false`. For more information, see "[Enabling force pushes to a protected
	branch](https://help.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)"
	in the GitHub Help documentation.
	*/
	AllowDeletions *bool `json:"allow_deletions,omitempty"`

	/*
	Permits force pushes to the protected branch by anyone with write access to the
	repository. Set to `true` to allow force pushes. Set to `false` or `null` to
	block force pushes. Default: `false`. For more information, see "[Enabling force
	pushes to a protected
	branch](https://help.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)"
	in the GitHub Help documentation."
	*/
	AllowForcePushes *bool `json:"allow_force_pushes,omitempty"`

	/*
	Enforce all configured restrictions for administrators. Set to `true` to enforce
	required status checks for repository administrators. Set to `null` to disable.
	*/
	EnforceAdmins *bool `json:"enforce_admins"`

	/*
	Enforces a linear commit Git history, which prevents anyone from pushing merge
	commits to a branch. Set to `true` to enforce a linear commit history. Set to
	`false` to disable a linear commit Git history. Your repository must allow
	squash merging or rebase merging before you can enable a linear commit history.
	Default: `false`. For more information, see "[Requiring a linear commit
	history](https://help.github.com/github/administering-a-repository/requiring-a-linear-commit-history)"
	in the GitHub Help documentation.
	*/
	RequiredLinearHistory *bool `json:"required_linear_history,omitempty"`

	// Require at least one approving review on a pull request, before merging. Set to `null` to disable.
	RequiredPullRequestReviews *ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews `json:"required_pull_request_reviews"`

	// Require status checks to pass before merging. Set to `null` to disable.
	RequiredStatusChecks *ReposUpdateBranchProtectionReqBodyRequiredStatusChecks `json:"required_status_checks"`

	/*
	Restrict who can push to the protected branch. User, app, and team
	`restrictions` are only available for organization-owned repositories. Set to
	`null` to disable.
	*/
	Restrictions *ReposUpdateBranchProtectionReqBodyRestrictions `json:"restrictions"`
}

/*
ReposUpdateBranchProtectionResponse is a response for ReposUpdateBranchProtection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionResponse struct {
	common.Response
	request *ReposUpdateBranchProtectionReq
	Data    components.ProtectedBranch
}

/*
ReposUpdateCommitComment performs requests for "repos/update-commit-comment"

Update a commit comment.

  PATCH /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
func ReposUpdateCommitComment(ctx context.Context, req *ReposUpdateCommitCommentReq, opt ...options.Option) (*ReposUpdateCommitCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposUpdateCommitCommentReq)
	}
	resp := &ReposUpdateCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CommitComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateCommitComment performs requests for "repos/update-commit-comment"

Update a commit comment.

  PATCH /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
func (c Client) ReposUpdateCommitComment(ctx context.Context, req *ReposUpdateCommitCommentReq, opt ...options.Option) (*ReposUpdateCommitCommentResponse, error) {
	return ReposUpdateCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateCommitCommentReq is request data for Client.ReposUpdateCommitComment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody ReposUpdateCommitCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateCommitCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposUpdateCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-commit-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateCommitCommentReq) Rel(link RelName, resp *ReposUpdateCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateCommitCommentReqBody is a request body for repos/update-commit-comment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentReqBody struct {

	// The contents of the comment
	Body *string `json:"body"`
}

/*
ReposUpdateCommitCommentResponse is a response for ReposUpdateCommitComment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentResponse struct {
	common.Response
	request *ReposUpdateCommitCommentReq
	Data    components.CommitComment
}

/*
ReposUpdateInformationAboutPagesSite performs requests for "repos/update-information-about-pages-site"

Update information about a GitHub Pages site.

  PUT /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
func ReposUpdateInformationAboutPagesSite(ctx context.Context, req *ReposUpdateInformationAboutPagesSiteReq, opt ...options.Option) (*ReposUpdateInformationAboutPagesSiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposUpdateInformationAboutPagesSiteReq)
	}
	resp := &ReposUpdateInformationAboutPagesSiteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateInformationAboutPagesSite performs requests for "repos/update-information-about-pages-site"

Update information about a GitHub Pages site.

  PUT /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
func (c Client) ReposUpdateInformationAboutPagesSite(ctx context.Context, req *ReposUpdateInformationAboutPagesSiteReq, opt ...options.Option) (*ReposUpdateInformationAboutPagesSiteResponse, error) {
	return ReposUpdateInformationAboutPagesSite(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateInformationAboutPagesSiteReq is request data for Client.ReposUpdateInformationAboutPagesSite

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
type ReposUpdateInformationAboutPagesSiteReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposUpdateInformationAboutPagesSiteReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateInformationAboutPagesSiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposUpdateInformationAboutPagesSiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "PUT",
		OperationID:      "repos/update-information-about-pages-site",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateInformationAboutPagesSiteReq) Rel(link RelName, resp *ReposUpdateInformationAboutPagesSiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateInformationAboutPagesSiteReqBody is a request body for repos/update-information-about-pages-site

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
type ReposUpdateInformationAboutPagesSiteReqBody struct {

	/*
	Specify a custom domain for the repository. Sending a `null` value will remove
	the custom domain. For more about custom domains, see "[Using a custom domain
	with GitHub
	Pages](https://help.github.com/articles/using-a-custom-domain-with-github-pages/)."
	*/
	Cname  *string     `json:"cname,omitempty"`
	Source interface{} `json:"source,omitempty"`
}

/*
ReposUpdateInformationAboutPagesSiteResponse is a response for ReposUpdateInformationAboutPagesSite

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
type ReposUpdateInformationAboutPagesSiteResponse struct {
	common.Response
	request *ReposUpdateInformationAboutPagesSiteReq
}

/*
ReposUpdateInvitation performs requests for "repos/update-invitation"

Update a repository invitation.

  PATCH /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
func ReposUpdateInvitation(ctx context.Context, req *ReposUpdateInvitationReq, opt ...options.Option) (*ReposUpdateInvitationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposUpdateInvitationReq)
	}
	resp := &ReposUpdateInvitationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.RepositoryInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateInvitation performs requests for "repos/update-invitation"

Update a repository invitation.

  PATCH /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
func (c Client) ReposUpdateInvitation(ctx context.Context, req *ReposUpdateInvitationReq, opt ...options.Option) (*ReposUpdateInvitationResponse, error) {
	return ReposUpdateInvitation(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateInvitationReq is request data for Client.ReposUpdateInvitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationReq struct {
	_url  string
	Owner string
	Repo  string

	// invitation_id parameter
	InvitationId int64
	RequestBody  ReposUpdateInvitationReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateInvitationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposUpdateInvitationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-invitation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/invitations/%v", r.Owner, r.Repo, r.InvitationId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateInvitationReq) Rel(link RelName, resp *ReposUpdateInvitationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateInvitationReqBody is a request body for repos/update-invitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationReqBody struct {

	/*
	The permissions that the associated user will have on the repository. Valid
	values are `read`, `write`, `maintain`, `triage`, and `admin`.
	*/
	Permissions *string `json:"permissions,omitempty"`
}

/*
ReposUpdateInvitationResponse is a response for ReposUpdateInvitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationResponse struct {
	common.Response
	request *ReposUpdateInvitationReq
	Data    components.RepositoryInvitation
}

/*
ReposUpdatePullRequestReviewProtection performs requests for "repos/update-pull-request-review-protection"

Update pull request review protection.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
func ReposUpdatePullRequestReviewProtection(ctx context.Context, req *ReposUpdatePullRequestReviewProtectionReq, opt ...options.Option) (*ReposUpdatePullRequestReviewProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposUpdatePullRequestReviewProtectionReq)
	}
	resp := &ReposUpdatePullRequestReviewProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranchPullRequestReview{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdatePullRequestReviewProtection performs requests for "repos/update-pull-request-review-protection"

Update pull request review protection.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
func (c Client) ReposUpdatePullRequestReviewProtection(ctx context.Context, req *ReposUpdatePullRequestReviewProtectionReq, opt ...options.Option) (*ReposUpdatePullRequestReviewProtectionResponse, error) {
	return ReposUpdatePullRequestReviewProtection(ctx, req, append(c, opt...)...)
}

/*
ReposUpdatePullRequestReviewProtectionReq is request data for Client.ReposUpdatePullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
type ReposUpdatePullRequestReviewProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposUpdatePullRequestReviewProtectionReqBody

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdatePullRequestReviewProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposUpdatePullRequestReviewProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"luke-cage"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-pull-request-review-protection",
		Previews:         map[string]bool{"luke-cage": r.LukeCagePreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdatePullRequestReviewProtectionReq) Rel(link RelName, resp *ReposUpdatePullRequestReviewProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposUpdatePullRequestReviewProtectionReqBodyDismissalRestrictions is a value for ReposUpdatePullRequestReviewProtectionReqBody's DismissalRestrictions field
type ReposUpdatePullRequestReviewProtectionReqBodyDismissalRestrictions struct {

	// The list of team `slug`s with dismissal access
	Teams []string `json:"teams,omitempty"`

	// The list of user `login`s with dismissal access
	Users []string `json:"users,omitempty"`
}

/*
ReposUpdatePullRequestReviewProtectionReqBody is a request body for repos/update-pull-request-review-protection

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
type ReposUpdatePullRequestReviewProtectionReqBody struct {

	// Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
	DismissStaleReviews *bool `json:"dismiss_stale_reviews,omitempty"`

	/*
	Specify which users and teams can dismiss pull request reviews. Pass an empty
	`dismissal_restrictions` object to disable. User and team
	`dismissal_restrictions` are only available for organization-owned repositories.
	Omit this parameter for personal repositories.
	*/
	DismissalRestrictions *ReposUpdatePullRequestReviewProtectionReqBodyDismissalRestrictions `json:"dismissal_restrictions,omitempty"`

	// Blocks merging pull requests until [code owners](https://help.github.com/articles/about-code-owners/) have reviewed.
	RequireCodeOwnerReviews *bool `json:"require_code_owner_reviews,omitempty"`

	// Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6.
	RequiredApprovingReviewCount *int64 `json:"required_approving_review_count,omitempty"`
}

/*
ReposUpdatePullRequestReviewProtectionResponse is a response for ReposUpdatePullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
type ReposUpdatePullRequestReviewProtectionResponse struct {
	common.Response
	request *ReposUpdatePullRequestReviewProtectionReq
	Data    components.ProtectedBranchPullRequestReview
}

/*
ReposUpdateRelease performs requests for "repos/update-release"

Update a release.

  PATCH /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#update-a-release
*/
func ReposUpdateRelease(ctx context.Context, req *ReposUpdateReleaseReq, opt ...options.Option) (*ReposUpdateReleaseResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposUpdateReleaseReq)
	}
	resp := &ReposUpdateReleaseResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Release{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateRelease performs requests for "repos/update-release"

Update a release.

  PATCH /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#update-a-release
*/
func (c Client) ReposUpdateRelease(ctx context.Context, req *ReposUpdateReleaseReq, opt ...options.Option) (*ReposUpdateReleaseResponse, error) {
	return ReposUpdateRelease(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateReleaseReq is request data for Client.ReposUpdateRelease

https://developer.github.com/v3/repos/releases/#update-a-release
*/
type ReposUpdateReleaseReq struct {
	_url  string
	Owner string
	Repo  string

	// release_id parameter
	ReleaseId   int64
	RequestBody ReposUpdateReleaseReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateReleaseReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposUpdateReleaseReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-release",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateReleaseReq) Rel(link RelName, resp *ReposUpdateReleaseResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateReleaseReqBody is a request body for repos/update-release

https://developer.github.com/v3/repos/releases/#update-a-release
*/
type ReposUpdateReleaseReqBody struct {

	// Text describing the contents of the tag.
	Body *string `json:"body,omitempty"`

	// `true` makes the release a draft, and `false` publishes the release.
	Draft *bool `json:"draft,omitempty"`

	// The name of the release.
	Name *string `json:"name,omitempty"`

	// `true` to identify the release as a prerelease, `false` to identify the release as a full release.
	Prerelease *bool `json:"prerelease,omitempty"`

	// The name of the tag.
	TagName *string `json:"tag_name,omitempty"`

	/*
	Specifies the commitish value that determines where the Git tag is created from.
	Can be any branch or commit SHA. Unused if the Git tag already exists. Default:
	the repository's default branch (usually `master`).
	*/
	TargetCommitish *string `json:"target_commitish,omitempty"`
}

/*
ReposUpdateReleaseResponse is a response for ReposUpdateRelease

https://developer.github.com/v3/repos/releases/#update-a-release
*/
type ReposUpdateReleaseResponse struct {
	common.Response
	request *ReposUpdateReleaseReq
	Data    components.Release
}

/*
ReposUpdateReleaseAsset performs requests for "repos/update-release-asset"

Update a release asset.

  PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
func ReposUpdateReleaseAsset(ctx context.Context, req *ReposUpdateReleaseAssetReq, opt ...options.Option) (*ReposUpdateReleaseAssetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposUpdateReleaseAssetReq)
	}
	resp := &ReposUpdateReleaseAssetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ReleaseAsset{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateReleaseAsset performs requests for "repos/update-release-asset"

Update a release asset.

  PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
func (c Client) ReposUpdateReleaseAsset(ctx context.Context, req *ReposUpdateReleaseAssetReq, opt ...options.Option) (*ReposUpdateReleaseAssetResponse, error) {
	return ReposUpdateReleaseAsset(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateReleaseAssetReq is request data for Client.ReposUpdateReleaseAsset

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
type ReposUpdateReleaseAssetReq struct {
	_url  string
	Owner string
	Repo  string

	// asset_id parameter
	AssetId     int64
	RequestBody ReposUpdateReleaseAssetReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposUpdateReleaseAssetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-release-asset",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateReleaseAssetReq) Rel(link RelName, resp *ReposUpdateReleaseAssetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateReleaseAssetReqBody is a request body for repos/update-release-asset

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
type ReposUpdateReleaseAssetReqBody struct {

	// An alternate short description of the asset. Used in place of the filename.
	Label *string `json:"label,omitempty"`

	// The file name of the asset.
	Name  *string `json:"name,omitempty"`
	State *string `json:"state,omitempty"`
}

/*
ReposUpdateReleaseAssetResponse is a response for ReposUpdateReleaseAsset

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
type ReposUpdateReleaseAssetResponse struct {
	common.Response
	request *ReposUpdateReleaseAssetReq
	Data    components.ReleaseAsset
}

/*
ReposUpdateStatusCheckProtection performs requests for "repos/update-status-check-protection"

Update status check protection.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
func ReposUpdateStatusCheckProtection(ctx context.Context, req *ReposUpdateStatusCheckProtectionReq, opt ...options.Option) (*ReposUpdateStatusCheckProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposUpdateStatusCheckProtectionReq)
	}
	resp := &ReposUpdateStatusCheckProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.StatusCheckPolicy{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateStatusCheckProtection performs requests for "repos/update-status-check-protection"

Update status check protection.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
func (c Client) ReposUpdateStatusCheckProtection(ctx context.Context, req *ReposUpdateStatusCheckProtectionReq, opt ...options.Option) (*ReposUpdateStatusCheckProtectionResponse, error) {
	return ReposUpdateStatusCheckProtection(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateStatusCheckProtectionReq is request data for Client.ReposUpdateStatusCheckProtection

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
type ReposUpdateStatusCheckProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody ReposUpdateStatusCheckProtectionReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateStatusCheckProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposUpdateStatusCheckProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-status-check-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateStatusCheckProtectionReq) Rel(link RelName, resp *ReposUpdateStatusCheckProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateStatusCheckProtectionReqBody is a request body for repos/update-status-check-protection

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
type ReposUpdateStatusCheckProtectionReqBody struct {

	// The list of status checks to require in order to merge into this branch
	Contexts []string `json:"contexts,omitempty"`

	// Require branches to be up to date before merging.
	Strict *bool `json:"strict,omitempty"`
}

/*
ReposUpdateStatusCheckProtectionResponse is a response for ReposUpdateStatusCheckProtection

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
type ReposUpdateStatusCheckProtectionResponse struct {
	common.Response
	request *ReposUpdateStatusCheckProtectionReq
	Data    components.StatusCheckPolicy
}

/*
ReposUpdateWebhook performs requests for "repos/update-webhook"

Update a repository webhook.

  PATCH /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
func ReposUpdateWebhook(ctx context.Context, req *ReposUpdateWebhookReq, opt ...options.Option) (*ReposUpdateWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposUpdateWebhookReq)
	}
	resp := &ReposUpdateWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Hook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateWebhook performs requests for "repos/update-webhook"

Update a repository webhook.

  PATCH /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
func (c Client) ReposUpdateWebhook(ctx context.Context, req *ReposUpdateWebhookReq, opt ...options.Option) (*ReposUpdateWebhookResponse, error) {
	return ReposUpdateWebhook(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateWebhookReq is request data for Client.ReposUpdateWebhook

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
type ReposUpdateWebhookReq struct {
	_url        string
	Owner       string
	Repo        string
	HookId      int64
	RequestBody ReposUpdateWebhookReqBody
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposUpdateWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateWebhookReq) Rel(link RelName, resp *ReposUpdateWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposUpdateWebhookReqBodyConfig is a value for ReposUpdateWebhookReqBody's Config field
type ReposUpdateWebhookReqBodyConfig struct {
	Address *string `json:"address,omitempty"`

	// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
	ContentType *string `json:"content_type,omitempty"`

	/*
	Determines whether the SSL certificate of the host for `url` will be verified
	when delivering payloads. Supported values include `0` (verification is
	performed) and `1` (verification is not performed). The default is `0`. **We
	strongly recommend not setting this to `1` as you are subject to
	man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`
	Room        *string `json:"room,omitempty"`

	/*
	If provided, the `secret` will be used as the `key` to generate the HMAC hex
	digest value in the
	[`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
ReposUpdateWebhookReqBody is a request body for repos/update-webhook

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
type ReposUpdateWebhookReqBody struct {

	// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
	Active *bool `json:"active,omitempty"`

	// Determines a list of events to be added to the list of events that the Hook triggers for.
	AddEvents []string `json:"add_events,omitempty"`

	/*
	Key/value pairs to provide settings for this webhook. [These are defined
	below](https://developer.github.com/v3/repos/hooks/#create-hook-config-params).
	*/
	Config *ReposUpdateWebhookReqBodyConfig `json:"config,omitempty"`

	/*
	Determines what [events](https://developer.github.com/webhooks/event-payloads)
	the hook is triggered for. This replaces the entire array of events.
	*/
	Events []string `json:"events,omitempty"`

	// Determines a list of events to be removed from the list of events that the Hook triggers for.
	RemoveEvents []string `json:"remove_events,omitempty"`
}

/*
ReposUpdateWebhookResponse is a response for ReposUpdateWebhook

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
type ReposUpdateWebhookResponse struct {
	common.Response
	request *ReposUpdateWebhookReq
	Data    components.Hook
}

/*
ReposUploadReleaseAsset performs requests for "repos/upload-release-asset"

Upload a release asset.

  POST /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
func ReposUploadReleaseAsset(ctx context.Context, req *ReposUploadReleaseAssetReq, opt ...options.Option) (*ReposUploadReleaseAssetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposUploadReleaseAssetReq)
	}
	resp := &ReposUploadReleaseAssetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ReleaseAsset{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUploadReleaseAsset performs requests for "repos/upload-release-asset"

Upload a release asset.

  POST /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
func (c Client) ReposUploadReleaseAsset(ctx context.Context, req *ReposUploadReleaseAssetReq, opt ...options.Option) (*ReposUploadReleaseAssetResponse, error) {
	return ReposUploadReleaseAsset(ctx, req, append(c, opt...)...)
}

/*
ReposUploadReleaseAssetReq is request data for Client.ReposUploadReleaseAsset

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
type ReposUploadReleaseAssetReq struct {
	_url string

	// URL to query. This must be explicitly set for this endpoint and any base URL set in options will be ignored.
	URL string

	// name parameter
	Name *string

	// label parameter
	Label *string

	// http request's body
	RequestBody io.Reader

	// Content-Type for the uploaded file
	ContentTypeHeader *string
}

// HTTPRequest builds an *http.Request
func (r *ReposUploadReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposUploadReleaseAssetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Name != nil {
		query.Set("name", *r.Name)
	}
	if r.Label != nil {
		query.Set("label", *r.Label)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r.URL,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": r.ContentTypeHeader,
		},
		Method:           "POST",
		OperationID:      "repos/upload-release-asset",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          "",
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUploadReleaseAssetReq) Rel(link RelName, resp *ReposUploadReleaseAssetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUploadReleaseAssetResponse is a response for ReposUploadReleaseAsset

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
type ReposUploadReleaseAssetResponse struct {
	common.Response
	request *ReposUploadReleaseAssetReq
	Data    components.ReleaseAsset
}
