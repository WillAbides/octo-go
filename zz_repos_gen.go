// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
ReposAcceptInvitationReq builds requests for "repos/accept-invitation"

Accept a repository invitation.

  PATCH /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
type ReposAcceptInvitationReq struct {
	InvitationId int64
}

func (r *ReposAcceptInvitationReq) urlPath() string {
	return fmt.Sprintf("/user/repository_invitations/%v", r.InvitationId)
}

func (r *ReposAcceptInvitationReq) method() string {
	return "PATCH"
}

func (r *ReposAcceptInvitationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAcceptInvitationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAcceptInvitationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposAcceptInvitationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposAddCollaboratorReq builds requests for "repos/add-collaborator"

Add user as a collaborator.

  PUT /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#add-user-as-a-collaborator
*/
type ReposAddCollaboratorReq struct {
	Owner       string
	Repo        string
	Username    string
	RequestBody ReposAddCollaboratorReqBody
}

func (r *ReposAddCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username)
}

func (r *ReposAddCollaboratorReq) method() string {
	return "PUT"
}

func (r *ReposAddCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddCollaboratorReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposAddCollaboratorReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposAddCollaboratorReqBody is a request body for repos/add-collaborator

API documentation: https://developer.github.com/v3/repos/collaborators/#add-user-as-a-collaborator
*/
type ReposAddCollaboratorReqBody struct {

	/*
	   The permission to grant the collaborator. **Only valid on organization-owned
	   repositories.** Can be one of:
	   \* `pull` - can pull, but not push to or administer this repository.
	   \* `push` - can pull and push, but not administer this repository.
	   \* `admin` - can pull, push and administer this repository.
	   \* `maintain` - Recommended for project managers who need to manage the
	   repository without access to sensitive or destructive actions.
	   \* `triage` - Recommended for contributors who need to proactively manage issues
	   and pull requests without write access.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
ReposAddCollaboratorResponseBody201 is a response body for repos/add-collaborator

API documentation: https://developer.github.com/v3/repos/collaborators/#add-user-as-a-collaborator
*/
type ReposAddCollaboratorResponseBody201 struct {
	components.RepositoryInvitation
}

/*
ReposAddDeployKeyReq builds requests for "repos/add-deploy-key"

Add a new deploy key.

  POST /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#add-a-new-deploy-key
*/
type ReposAddDeployKeyReq struct {
	Owner       string
	Repo        string
	RequestBody ReposAddDeployKeyReqBody
}

func (r *ReposAddDeployKeyReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/keys", r.Owner, r.Repo)
}

func (r *ReposAddDeployKeyReq) method() string {
	return "POST"
}

func (r *ReposAddDeployKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddDeployKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddDeployKeyReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposAddDeployKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposAddDeployKeyReqBody is a request body for repos/add-deploy-key

API documentation: https://developer.github.com/v3/repos/keys/#add-a-new-deploy-key
*/
type ReposAddDeployKeyReqBody struct {

	// The contents of the key.
	Key *string `json:"key"`

	/*
	   If `true`, the key will only be able to read repository contents. Otherwise, the
	   key will be able to read and write.

	   Deploy keys with write access can perform the same actions as an organization
	   member with admin access, or a collaborator on a personal repository. For more
	   information, see "[Repository permission levels for an
	   organization](https://help.github.com/articles/repository-permission-levels-for-an-organization/)"
	   and "[Permission levels for a user account
	   repository](https://help.github.com/articles/permission-levels-for-a-user-account-repository/)."
	*/
	ReadOnly *bool `json:"read_only,omitempty"`

	// A name for the key.
	Title *string `json:"title,omitempty"`
}

/*
ReposAddDeployKeyResponseBody201 is a response body for repos/add-deploy-key

API documentation: https://developer.github.com/v3/repos/keys/#add-a-new-deploy-key
*/
type ReposAddDeployKeyResponseBody201 struct {
	components.DeployKey
}

/*
ReposAddProtectedBranchAdminEnforcementReq builds requests for "repos/add-protected-branch-admin-enforcement"

Add admin enforcement of protected branch.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#add-admin-enforcement-of-protected-branch
*/
type ReposAddProtectedBranchAdminEnforcementReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) method() string {
	return "POST"
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposAddProtectedBranchAdminEnforcementReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposAddProtectedBranchAdminEnforcementResponseBody200 is a response body for repos/add-protected-branch-admin-enforcement

API documentation: https://developer.github.com/v3/repos/branches/#add-admin-enforcement-of-protected-branch
*/
type ReposAddProtectedBranchAdminEnforcementResponseBody200 struct {
	components.ProtectedBranchAdminEnforced
}

/*
ReposAddProtectedBranchAppRestrictionsReq builds requests for "repos/add-protected-branch-app-restrictions"

Add app restrictions of protected branch.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#add-app-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchAppRestrictionsReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposAddProtectedBranchAppRestrictionsReqBody
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) method() string {
	return "POST"
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposAddProtectedBranchAppRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposAddProtectedBranchAppRestrictionsReqBody is a request body for repos/add-protected-branch-app-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#add-app-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchAppRestrictionsReqBody []string

/*
ReposAddProtectedBranchAppRestrictionsResponseBody200 is a response body for repos/add-protected-branch-app-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#add-app-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchAppRestrictionsResponseBody200 []struct {
	components.Integration2
}

/*
ReposAddProtectedBranchRequiredSignaturesReq builds requests for "repos/add-protected-branch-required-signatures"

Add required signatures of protected branch.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#add-required-signatures-of-protected-branch
*/
type ReposAddProtectedBranchRequiredSignaturesReq struct {
	Owner  string
	Repo   string
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) method() string {
	return "POST"
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"zzzax": r.ZzzaxPreview}
	if requiredPreviews {
		previewVals["zzzax"] = true
	}
	if allPreviews {
		previewVals["zzzax"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposAddProtectedBranchRequiredSignaturesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposAddProtectedBranchRequiredSignaturesResponseBody200 is a response body for repos/add-protected-branch-required-signatures

API documentation: https://developer.github.com/v3/repos/branches/#add-required-signatures-of-protected-branch
*/
type ReposAddProtectedBranchRequiredSignaturesResponseBody200 struct {
	components.ProtectedBranchAdminEnforced
}

/*
ReposAddProtectedBranchRequiredStatusChecksContextsReq builds requests for "repos/add-protected-branch-required-status-checks-contexts"

Add required status checks contexts of protected branch.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#add-required-status-checks-contexts-of-protected-branch
*/
type ReposAddProtectedBranchRequiredStatusChecksContextsReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposAddProtectedBranchRequiredStatusChecksContextsReqBody
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) method() string {
	return "POST"
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposAddProtectedBranchRequiredStatusChecksContextsReqBody is a request body for repos/add-protected-branch-required-status-checks-contexts

API documentation: https://developer.github.com/v3/repos/branches/#add-required-status-checks-contexts-of-protected-branch
*/
type ReposAddProtectedBranchRequiredStatusChecksContextsReqBody []string

/*
ReposAddProtectedBranchRequiredStatusChecksContextsResponseBody200 is a response body for repos/add-protected-branch-required-status-checks-contexts

API documentation: https://developer.github.com/v3/repos/branches/#add-required-status-checks-contexts-of-protected-branch
*/
type ReposAddProtectedBranchRequiredStatusChecksContextsResponseBody200 []string

/*
ReposAddProtectedBranchTeamRestrictionsReq builds requests for "repos/add-protected-branch-team-restrictions"

Add team restrictions of protected branch.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#add-team-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchTeamRestrictionsReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposAddProtectedBranchTeamRestrictionsReqBody
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) method() string {
	return "POST"
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposAddProtectedBranchTeamRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposAddProtectedBranchTeamRestrictionsReqBody is a request body for repos/add-protected-branch-team-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#add-team-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchTeamRestrictionsReqBody []string

/*
ReposAddProtectedBranchTeamRestrictionsResponseBody200 is a response body for repos/add-protected-branch-team-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#add-team-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchTeamRestrictionsResponseBody200 []struct {
	components.Team
}

/*
ReposAddProtectedBranchUserRestrictionsReq builds requests for "repos/add-protected-branch-user-restrictions"

Add user restrictions of protected branch.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#add-user-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchUserRestrictionsReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposAddProtectedBranchUserRestrictionsReqBody
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) method() string {
	return "POST"
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposAddProtectedBranchUserRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposAddProtectedBranchUserRestrictionsReqBody is a request body for repos/add-protected-branch-user-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#add-user-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchUserRestrictionsReqBody []string

/*
ReposAddProtectedBranchUserRestrictionsResponseBody200 is a response body for repos/add-protected-branch-user-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#add-user-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchUserRestrictionsResponseBody200 []struct {
	components.SimpleUser
}

/*
ReposCheckCollaboratorReq builds requests for "repos/check-collaborator"

Check if a user is a collaborator.

  GET /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-collaborator
*/
type ReposCheckCollaboratorReq struct {
	Owner    string
	Repo     string
	Username string
}

func (r *ReposCheckCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username)
}

func (r *ReposCheckCollaboratorReq) method() string {
	return "GET"
}

func (r *ReposCheckCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCheckCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCheckCollaboratorReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposCheckCollaboratorReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposCheckVulnerabilityAlertsReq builds requests for "repos/check-vulnerability-alerts"

Check if vulnerability alerts are enabled for a repository.

  GET /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
type ReposCheckVulnerabilityAlertsReq struct {
	Owner string
	Repo  string

	/*
	Enabling and disabling vulnerability alerts for a repository using the REST API
	is currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

func (r *ReposCheckVulnerabilityAlertsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo)
}

func (r *ReposCheckVulnerabilityAlertsReq) method() string {
	return "GET"
}

func (r *ReposCheckVulnerabilityAlertsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCheckVulnerabilityAlertsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"dorian": r.DorianPreview}
	if requiredPreviews {
		previewVals["dorian"] = true
	}
	if allPreviews {
		previewVals["dorian"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCheckVulnerabilityAlertsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposCheckVulnerabilityAlertsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposCompareCommitsReq builds requests for "repos/compare-commits"

Compare two commits.

  GET /repos/{owner}/{repo}/compare/{base}...{head}

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
type ReposCompareCommitsReq struct {
	Owner string
	Repo  string
	Base  string
	Head  string
}

func (r *ReposCompareCommitsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/compare/%v...%v", r.Owner, r.Repo, r.Base, r.Head)
}

func (r *ReposCompareCommitsReq) method() string {
	return "GET"
}

func (r *ReposCompareCommitsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCompareCommitsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCompareCommitsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposCompareCommitsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposCompareCommitsResponseBody200 is a response body for repos/compare-commits

API documentation: https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
type ReposCompareCommitsResponseBody200 struct {
	components.CommitComparison
}

/*
ReposCreateCommitCommentReq builds requests for "repos/create-commit-comment"

Create a commit comment.

  POST /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentReq struct {
	Owner       string
	Repo        string
	CommitSha   string
	RequestBody ReposCreateCommitCommentReqBody
}

func (r *ReposCreateCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/comments", r.Owner, r.Repo, r.CommitSha)
}

func (r *ReposCreateCommitCommentReq) method() string {
	return "POST"
}

func (r *ReposCreateCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateCommitCommentReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposCreateCommitCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposCreateCommitCommentReqBody is a request body for repos/create-commit-comment

API documentation: https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`

	/*
	   **Deprecated**. Use **position** parameter instead. Line number in the file to
	   comment on.
	*/
	Line *int64 `json:"line,omitempty"`

	// Relative path of the file to comment on.
	Path *string `json:"path,omitempty"`

	// Line index in the diff to comment on.
	Position *int64 `json:"position,omitempty"`
}

/*
ReposCreateCommitCommentResponseBody201 is a response body for repos/create-commit-comment

API documentation: https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentResponseBody201 struct {
	components.CommitComment
}

/*
ReposCreateDeploymentReq builds requests for "repos/create-deployment"

Create a deployment.

  POST /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentReq struct {
	Owner       string
	Repo        string
	RequestBody ReposCreateDeploymentReqBody

	/*
	The `transient_environment` and `production_environment` parameters are
	currently available for developers to preview. During the preview period, the
	API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposCreateDeploymentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments", r.Owner, r.Repo)
}

func (r *ReposCreateDeploymentReq) method() string {
	return "POST"
}

func (r *ReposCreateDeploymentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateDeploymentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"ant-man": r.AntManPreview}
	if allPreviews {
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateDeploymentReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposCreateDeploymentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposCreateDeploymentReqBody is a request body for repos/create-deployment

API documentation: https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentReqBody struct {

	/*
	   Attempts to automatically merge the default branch into the requested ref, if
	   it's behind the default branch.
	*/
	AutoMerge *bool `json:"auto_merge,omitempty"`

	// Short description of the deployment.
	Description *string `json:"description,omitempty"`

	/*
	   Name for the target deployment environment (e.g., `production`, `staging`,
	   `qa`).
	*/
	Environment *string `json:"environment,omitempty"`

	// JSON payload with extra information about the deployment.
	Payload *string `json:"payload,omitempty"`

	/*
	   Specifies if the given environment is one that end-users directly interact with.
	   Default: `true` when `environment` is `production` and `false` otherwise.
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	ProductionEnvironment *bool `json:"production_environment,omitempty"`

	// The ref to deploy. This can be a branch, tag, or SHA.
	Ref *string `json:"ref"`

	/*
	   The [status](https://developer.github.com/v3/repos/statuses/) contexts to verify
	   against commit status checks. If you omit this parameter, GitHub verifies all
	   unique contexts before creating a deployment. To bypass checking entirely, pass
	   an empty array. Defaults to all unique contexts.
	*/
	RequiredContexts []string `json:"required_contexts,omitempty"`

	// Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).
	Task *string `json:"task,omitempty"`

	/*
	   Specifies if the given environment is specific to the deployment and will no
	   longer exist at some point in the future. Default: `false`
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type. **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	TransientEnvironment *bool `json:"transient_environment,omitempty"`
}

/*
ReposCreateDeploymentResponseBody201 is a response body for repos/create-deployment

API documentation: https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentResponseBody201 struct {
	components.Deployment
}

/*
ReposCreateDeploymentResponseBody202 is a response body for repos/create-deployment

API documentation: https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentResponseBody202 struct {
	Message string `json:"message,omitempty"`
}

/*
ReposCreateDeploymentStatusReq builds requests for "repos/create-deployment-status"

Create a deployment status.

  POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusReq struct {
	Owner        string
	Repo         string
	DeploymentId int64
	RequestBody  ReposCreateDeploymentStatusReqBody

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposCreateDeploymentStatusReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses", r.Owner, r.Repo, r.DeploymentId)
}

func (r *ReposCreateDeploymentStatusReq) method() string {
	return "POST"
}

func (r *ReposCreateDeploymentStatusReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateDeploymentStatusReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"ant-man": r.AntManPreview,
		"flash":   r.FlashPreview,
	}
	if allPreviews {
		previewVals["flash"] = true
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateDeploymentStatusReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposCreateDeploymentStatusReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposCreateDeploymentStatusReqBody is a request body for repos/create-deployment-status

API documentation: https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusReqBody struct {

	/*
	   Adds a new `inactive` status to all prior non-transient, non-production
	   environment deployments with the same repository and `environment` name as the
	   created status's deployment. An `inactive` status is only added to deployments
	   that had a `success` state. Default: `true`
	   **Note:** To add an `inactive` status to `production` environments, you must use
	   the
	   [`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	   custom media type.
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	AutoInactive *bool `json:"auto_inactive,omitempty"`

	/*
	   A short description of the status. The maximum description length is 140
	   characters.
	*/
	Description *string `json:"description,omitempty"`

	/*
	   Name for the target deployment environment, which can be changed when setting a
	   deploy status. For example, `production`, `staging`, or `qa`. **Note:** This
	   parameter requires you to use the
	   [`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	   custom media type.
	*/
	Environment *string `json:"environment,omitempty"`

	/*
	   Sets the URL for accessing your environment. Default: `""`
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type. **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	EnvironmentUrl *string `json:"environment_url,omitempty"`

	/*
	   The full URL of the deployment's output. This parameter replaces `target_url`.
	   We will continue to accept `target_url` to support legacy uses, but we recommend
	   replacing `target_url` with `log_url`. Setting `log_url` will automatically set
	   `target_url` to the same value. Default: `""`
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type. **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	LogUrl *string `json:"log_url,omitempty"`

	/*
	   The state of the status. Can be one of `error`, `failure`, `inactive`,
	   `in_progress`, `queued` `pending`, or `success`. **Note:** To use the `inactive`
	   state, you must provide the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type. To use the `in_progress` and `queued` states, you must
	   provide the
	   [`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	   custom media type.
	*/
	State *string `json:"state"`

	/*
	   The target URL to associate with this status. This URL should contain output to
	   keep the user updated while the task is running or serve as historical
	   information for what happened in the deployment. **Note:** It's recommended to
	   use the `log_url` parameter, which replaces `target_url`.
	*/
	TargetUrl *string `json:"target_url,omitempty"`
}

/*
ReposCreateDeploymentStatusResponseBody201 is a response body for repos/create-deployment-status

API documentation: https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusResponseBody201 struct {
	components.DeploymentStatus
}

/*
ReposCreateDispatchEventReq builds requests for "repos/create-dispatch-event"

Create a repository dispatch event.

  POST /repos/{owner}/{repo}/dispatches

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type ReposCreateDispatchEventReq struct {
	Owner       string
	Repo        string
	RequestBody ReposCreateDispatchEventReqBody
}

func (r *ReposCreateDispatchEventReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/dispatches", r.Owner, r.Repo)
}

func (r *ReposCreateDispatchEventReq) method() string {
	return "POST"
}

func (r *ReposCreateDispatchEventReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateDispatchEventReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateDispatchEventReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposCreateDispatchEventReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposCreateDispatchEventReqBody is a request body for repos/create-dispatch-event

API documentation: https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type ReposCreateDispatchEventReqBody struct {

	/*
	   JSON payload with extra information about the webhook event that your action or
	   worklow may use.
	*/
	ClientPayload interface{} `json:"client_payload,omitempty"`

	// **Required:** A custom webhook event name.
	EventType *string `json:"event_type,omitempty"`
}

/*
ReposCreateForAuthenticatedUserReq builds requests for "repos/create-for-authenticated-user"

Create a repository for the authenticated user.

  POST /user/repos

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserReq struct {
	RequestBody ReposCreateForAuthenticatedUserReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

func (r *ReposCreateForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/repos")
}

func (r *ReposCreateForAuthenticatedUserReq) method() string {
	return "POST"
}

func (r *ReposCreateForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"baptiste": r.BaptistePreview,
		"nebula":   r.NebulaPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateForAuthenticatedUserReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposCreateForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposCreateForAuthenticatedUserReqBody is a request body for repos/create-for-authenticated-user

API documentation: https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserReqBody struct {

	/*
	   Either `true` to allow merging pull requests with a merge commit, or `false` to
	   prevent merging pull requests with merge commits.
	*/
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	/*
	   Either `true` to allow rebase-merging pull requests, or `false` to prevent
	   rebase-merging.
	*/
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	/*
	   Either `true` to allow squash-merging pull requests, or `false` to prevent
	   squash-merging.
	*/
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	// Pass `true` to create an initial commit with empty README.
	AutoInit *bool `json:"auto_init,omitempty"`

	/*
	   Either `true` to allow automatically deleting head branches when pull requests
	   are merged, or `false` to prevent automatic deletion.
	*/
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	/*
	   Desired language or platform [.gitignore
	   template](https://github.com/github/gitignore) to apply. Use the name of the
	   template without the extension. For example, "Haskell".
	*/
	GitignoreTemplate *string `json:"gitignore_template,omitempty"`

	// Either `true` to enable issues for this repository or `false` to disable them.
	HasIssues *bool `json:"has_issues,omitempty"`

	/*
	   Either `true` to enable projects for this repository or `false` to disable them.
	   **Note:** If you're creating a repository in an organization that has disabled
	   repository projects, the default is `false`, and if you pass `true`, the API
	   returns an error.
	*/
	HasProjects *bool `json:"has_projects,omitempty"`

	// Either `true` to enable the wiki for this repository or `false` to disable it.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	/*
	   Either `true` to make this repo available as a template repository or `false` to
	   prevent it.
	*/
	IsTemplate *bool `json:"is_template,omitempty"`

	/*
	   Choose an [open source license template](https://choosealicense.com/) that best
	   suits your needs, and then use the [license
	   keyword](https://help.github.com/articles/licensing-a-repository/#searching-github-by-license-type)
	   as the `license_template` string. For example, "mit" or "mpl-2.0".
	*/
	LicenseTemplate *string `json:"license_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name"`

	// Either `true` to create a private repository or `false` to create a public one.
	Private *bool `json:"private,omitempty"`

	/*
	   The id of the team that will be granted access to this repository. This is only
	   valid when creating a repository in an organization.
	*/
	TeamId *int64 `json:"team_id,omitempty"`

	/*
	   Can be `public` or `private`. If your organization is associated with an
	   enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server
	   2.20+, `visibility` can also be `internal`. For more information, see "[Creating
	   an internal
	   repository](https://help.github.com/github/creating-cloning-and-archiving-repositories/creating-an-internal-repository)"
	   in the GitHub Help documentation.
	   The `visibility` parameter overrides the `private` parameter when you use both
	   parameters with the `nebula-preview` preview header.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ReposCreateForAuthenticatedUserResponseBody201 is a response body for repos/create-for-authenticated-user

API documentation: https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserResponseBody201 struct {
	components.Repository
}

/*
ReposCreateForkReq builds requests for "repos/create-fork"

Create a fork.

  POST /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkReq struct {
	Owner       string
	Repo        string
	RequestBody ReposCreateForkReqBody
}

func (r *ReposCreateForkReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/forks", r.Owner, r.Repo)
}

func (r *ReposCreateForkReq) method() string {
	return "POST"
}

func (r *ReposCreateForkReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateForkReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateForkReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposCreateForkReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposCreateForkReqBody is a request body for repos/create-fork

API documentation: https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkReqBody struct {

	/*
	   Optional parameter to specify the organization name if forking into an
	   organization.
	*/
	Organization *string `json:"organization,omitempty"`
}

/*
ReposCreateForkResponseBody202 is a response body for repos/create-fork

API documentation: https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkResponseBody202 struct {
	components.Repository
}

/*
ReposCreateHookReq builds requests for "repos/create-hook"

Create a hook.

  POST /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#create-a-hook
*/
type ReposCreateHookReq struct {
	Owner       string
	Repo        string
	RequestBody ReposCreateHookReqBody
}

func (r *ReposCreateHookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks", r.Owner, r.Repo)
}

func (r *ReposCreateHookReq) method() string {
	return "POST"
}

func (r *ReposCreateHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateHookReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposCreateHookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

// ReposCreateHookReqBodyConfig is a value for ReposCreateHookReqBody's Config field
type ReposCreateHookReqBodyConfig struct {

	/*
	   The media type used to serialize the payloads. Supported values include `json`
	   and `form`. The default is `form`.
	*/
	ContentType *string `json:"content_type,omitempty"`

	/*
	   Determines whether the SSL certificate of the host for `url` will be verified
	   when delivering payloads. Supported values include `0` (verification is
	   performed) and `1` (verification is not performed). The default is `0`. **We
	   strongly recommend not setting this to `1` as you are subject to
	   man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	   If provided, the `secret` will be used as the `key` to generate the HMAC hex
	   digest value in the
	   [`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	   header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
ReposCreateHookReqBody is a request body for repos/create-hook

API documentation: https://developer.github.com/v3/repos/hooks/#create-a-hook
*/
type ReposCreateHookReqBody struct {

	/*
	   Determines if notifications are sent when the webhook is triggered. Set to
	   `true` to send notifications.
	*/
	Active *bool `json:"active,omitempty"`

	/*
	   Key/value pairs to provide settings for this webhook. [These are defined
	   below](https://developer.github.com/v3/repos/hooks/#create-hook-config-params).
	*/
	Config *ReposCreateHookReqBodyConfig `json:"config"`

	/*
	   Determines what [events](https://developer.github.com/webhooks/event-payloads)
	   the hook is triggered for.
	*/
	Events []string `json:"events,omitempty"`

	/*
	   Use `web` to create a webhook. Default: `web`. This parameter only accepts the
	   value `web`.
	*/
	Name *string `json:"name,omitempty"`
}

/*
ReposCreateHookResponseBody201 is a response body for repos/create-hook

API documentation: https://developer.github.com/v3/repos/hooks/#create-a-hook
*/
type ReposCreateHookResponseBody201 struct {
	components.Hook
}

/*
ReposCreateInOrgReq builds requests for "repos/create-in-org"

Create an organization repository.

  POST /orgs/{org}/repos

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgReq struct {
	Org         string
	RequestBody ReposCreateInOrgReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

func (r *ReposCreateInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/repos", r.Org)
}

func (r *ReposCreateInOrgReq) method() string {
	return "POST"
}

func (r *ReposCreateInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"baptiste": r.BaptistePreview,
		"nebula":   r.NebulaPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateInOrgReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposCreateInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposCreateInOrgReqBody is a request body for repos/create-in-org

API documentation: https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgReqBody struct {

	/*
	   Either `true` to allow merging pull requests with a merge commit, or `false` to
	   prevent merging pull requests with merge commits.
	*/
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	/*
	   Either `true` to allow rebase-merging pull requests, or `false` to prevent
	   rebase-merging.
	*/
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	/*
	   Either `true` to allow squash-merging pull requests, or `false` to prevent
	   squash-merging.
	*/
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	// Pass `true` to create an initial commit with empty README.
	AutoInit *bool `json:"auto_init,omitempty"`

	/*
	   Either `true` to allow automatically deleting head branches when pull requests
	   are merged, or `false` to prevent automatic deletion.
	*/
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	/*
	   Desired language or platform [.gitignore
	   template](https://github.com/github/gitignore) to apply. Use the name of the
	   template without the extension. For example, "Haskell".
	*/
	GitignoreTemplate *string `json:"gitignore_template,omitempty"`

	// Either `true` to enable issues for this repository or `false` to disable them.
	HasIssues *bool `json:"has_issues,omitempty"`

	/*
	   Either `true` to enable projects for this repository or `false` to disable them.
	   **Note:** If you're creating a repository in an organization that has disabled
	   repository projects, the default is `false`, and if you pass `true`, the API
	   returns an error.
	*/
	HasProjects *bool `json:"has_projects,omitempty"`

	// Either `true` to enable the wiki for this repository or `false` to disable it.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	/*
	   Either `true` to make this repo available as a template repository or `false` to
	   prevent it.
	*/
	IsTemplate *bool `json:"is_template,omitempty"`

	/*
	   Choose an [open source license template](https://choosealicense.com/) that best
	   suits your needs, and then use the [license
	   keyword](https://help.github.com/articles/licensing-a-repository/#searching-github-by-license-type)
	   as the `license_template` string. For example, "mit" or "mpl-2.0".
	*/
	LicenseTemplate *string `json:"license_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name"`

	// Either `true` to create a private repository or `false` to create a public one.
	Private *bool `json:"private,omitempty"`

	/*
	   The id of the team that will be granted access to this repository. This is only
	   valid when creating a repository in an organization.
	*/
	TeamId *int64 `json:"team_id,omitempty"`

	/*
	   Can be `public` or `private`. If your organization is associated with an
	   enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server
	   2.20+, `visibility` can also be `internal`. For more information, see "[Creating
	   an internal
	   repository](https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)"
	   in the GitHub Help documentation.
	   The `visibility` parameter overrides the `private` parameter when you use both
	   parameters with the `nebula-preview` preview header.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ReposCreateInOrgResponseBody201 is a response body for repos/create-in-org

API documentation: https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgResponseBody201 struct {
	components.Repository
}

/*
ReposCreateOrUpdateFileReq builds requests for "repos/create-or-update-file"

Create or update a file.

  PUT /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#create-or-update-a-file
*/
type ReposCreateOrUpdateFileReq struct {
	Owner       string
	Repo        string
	Path        string
	RequestBody ReposCreateOrUpdateFileReqBody
}

func (r *ReposCreateOrUpdateFileReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path)
}

func (r *ReposCreateOrUpdateFileReq) method() string {
	return "PUT"
}

func (r *ReposCreateOrUpdateFileReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateOrUpdateFileReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateOrUpdateFileReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposCreateOrUpdateFileReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

// ReposCreateOrUpdateFileReqBodyAuthor is a value for ReposCreateOrUpdateFileReqBody's Author field
type ReposCreateOrUpdateFileReqBodyAuthor struct {

	/*
	   The email of the author or committer of the commit. You'll receive a `422`
	   status code if `email` is omitted.
	*/
	Email *string `json:"email"`

	/*
	   The name of the author or committer of the commit. You'll receive a `422` status
	   code if `name` is omitted.
	*/
	Name *string `json:"name"`
}

// ReposCreateOrUpdateFileReqBodyCommitter is a value for ReposCreateOrUpdateFileReqBody's Committer field
type ReposCreateOrUpdateFileReqBodyCommitter struct {

	/*
	   The email of the author or committer of the commit. You'll receive a `422`
	   status code if `email` is omitted.
	*/
	Email *string `json:"email"`

	/*
	   The name of the author or committer of the commit. You'll receive a `422` status
	   code if `name` is omitted.
	*/
	Name *string `json:"name"`
}

/*
ReposCreateOrUpdateFileReqBody is a request body for repos/create-or-update-file

API documentation: https://developer.github.com/v3/repos/contents/#create-or-update-a-file
*/
type ReposCreateOrUpdateFileReqBody struct {

	/*
	   The author of the file. Default: The `committer` or the authenticated user if
	   you omit `committer`.
	*/
	Author *ReposCreateOrUpdateFileReqBodyAuthor `json:"author,omitempty"`

	// The branch name. Default: the repositorys default branch (usually `master`)
	Branch *string `json:"branch,omitempty"`

	// The person that committed the file. Default: the authenticated user.
	Committer *ReposCreateOrUpdateFileReqBodyCommitter `json:"committer,omitempty"`

	// The new file content, using Base64 encoding.
	Content *string `json:"content"`

	// The commit message.
	Message *string `json:"message"`

	/*
	   **Required if you are updating a file**. The blob SHA of the file being
	   replaced.
	*/
	Sha *string `json:"sha,omitempty"`
}

/*
ReposCreateOrUpdateFileResponseBody200 is a response body for repos/create-or-update-file

API documentation: https://developer.github.com/v3/repos/contents/#create-or-update-a-file
*/
type ReposCreateOrUpdateFileResponseBody200 struct {
	components.FileCommit
}

/*
ReposCreateOrUpdateFileResponseBody201 is a response body for repos/create-or-update-file

API documentation: https://developer.github.com/v3/repos/contents/#create-or-update-a-file
*/
type ReposCreateOrUpdateFileResponseBody201 struct {
	components.FileCommit
}

/*
ReposCreateReleaseReq builds requests for "repos/create-release"

Create a release.

  POST /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseReq struct {
	Owner       string
	Repo        string
	RequestBody ReposCreateReleaseReqBody
}

func (r *ReposCreateReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases", r.Owner, r.Repo)
}

func (r *ReposCreateReleaseReq) method() string {
	return "POST"
}

func (r *ReposCreateReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateReleaseReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposCreateReleaseReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposCreateReleaseReqBody is a request body for repos/create-release

API documentation: https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseReqBody struct {

	// Text describing the contents of the tag.
	Body *string `json:"body,omitempty"`

	/*
	   `true` to create a draft (unpublished) release, `false` to create a published
	   one.
	*/
	Draft *bool `json:"draft,omitempty"`

	// The name of the release.
	Name *string `json:"name,omitempty"`

	/*
	   `true` to identify the release as a prerelease. `false` to identify the release
	   as a full release.
	*/
	Prerelease *bool `json:"prerelease,omitempty"`

	// The name of the tag.
	TagName *string `json:"tag_name"`

	/*
	   Specifies the commitish value that determines where the Git tag is created from.
	   Can be any branch or commit SHA. Unused if the Git tag already exists. Default:
	   the repository's default branch (usually `master`).
	*/
	TargetCommitish *string `json:"target_commitish,omitempty"`
}

/*
ReposCreateReleaseResponseBody201 is a response body for repos/create-release

API documentation: https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseResponseBody201 struct {
	components.Release
}

/*
ReposCreateStatusReq builds requests for "repos/create-status"

Create a status.

  POST /repos/{owner}/{repo}/statuses/{sha}

https://developer.github.com/v3/repos/statuses/#create-a-status
*/
type ReposCreateStatusReq struct {
	Owner       string
	Repo        string
	Sha         string
	RequestBody ReposCreateStatusReqBody
}

func (r *ReposCreateStatusReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/statuses/%v", r.Owner, r.Repo, r.Sha)
}

func (r *ReposCreateStatusReq) method() string {
	return "POST"
}

func (r *ReposCreateStatusReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateStatusReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateStatusReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposCreateStatusReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposCreateStatusReqBody is a request body for repos/create-status

API documentation: https://developer.github.com/v3/repos/statuses/#create-a-status
*/
type ReposCreateStatusReqBody struct {

	// A string label to differentiate this status from the status of other systems.
	Context *string `json:"context,omitempty"`

	// A short description of the status.
	Description *string `json:"description,omitempty"`

	/*
	   The state of the status. Can be one of `error`, `failure`, `pending`, or
	   `success`.
	*/
	State *string `json:"state"`

	/*
	   The target URL to associate with this status. This URL will be linked from the
	   GitHub UI to allow users to easily see the source of the status.
	   For example, if your continuous integration system is posting build status, you
	   would want to provide the deep link for the build output for this specific SHA:
	   `http://ci.example.com/user/repo/build/sha`
	*/
	TargetUrl *string `json:"target_url,omitempty"`
}

/*
ReposCreateStatusResponseBody201 is a response body for repos/create-status

API documentation: https://developer.github.com/v3/repos/statuses/#create-a-status
*/
type ReposCreateStatusResponseBody201 struct {
	components.Status
}

/*
ReposCreateUsingTemplateReq builds requests for "repos/create-using-template"

Create a repository using a template.

  POST /repos/{template_owner}/{template_repo}/generate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateReq struct {
	TemplateOwner string
	TemplateRepo  string
	RequestBody   ReposCreateUsingTemplateReqBody

	/*
	Creating and using repository templates is currently available for developers to
	preview. To access this new endpoint during the preview period, you must set
	this to true.
	*/
	BaptistePreview bool
}

func (r *ReposCreateUsingTemplateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/generate", r.TemplateOwner, r.TemplateRepo)
}

func (r *ReposCreateUsingTemplateReq) method() string {
	return "POST"
}

func (r *ReposCreateUsingTemplateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateUsingTemplateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"baptiste": r.BaptistePreview}
	if requiredPreviews {
		previewVals["baptiste"] = true
	}
	if allPreviews {
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateUsingTemplateReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposCreateUsingTemplateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposCreateUsingTemplateReqBody is a request body for repos/create-using-template

API documentation: https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateReqBody struct {

	// A short description of the new repository.
	Description *string `json:"description,omitempty"`

	// The name of the new repository.
	Name *string `json:"name"`

	/*
	   The organization or person who will own the new repository. To create a new
	   repository in an organization, the authenticated user must be a member of the
	   specified organization.
	*/
	Owner *string `json:"owner,omitempty"`

	/*
	   Either `true` to create a new private repository or `false` to create a new
	   public one.
	*/
	Private *bool `json:"private,omitempty"`
}

/*
ReposCreateUsingTemplateResponseBody201 is a response body for repos/create-using-template

API documentation: https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateResponseBody201 struct {
	components.Repository3
}

/*
ReposDeclineInvitationReq builds requests for "repos/decline-invitation"

Decline a repository invitation.

  DELETE /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
type ReposDeclineInvitationReq struct {
	InvitationId int64
}

func (r *ReposDeclineInvitationReq) urlPath() string {
	return fmt.Sprintf("/user/repository_invitations/%v", r.InvitationId)
}

func (r *ReposDeclineInvitationReq) method() string {
	return "DELETE"
}

func (r *ReposDeclineInvitationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeclineInvitationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeclineInvitationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposDeclineInvitationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposDeleteReq builds requests for "repos/delete"

Delete a repository.

  DELETE /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#delete-a-repository
*/
type ReposDeleteReq struct {
	Owner string
	Repo  string
}

func (r *ReposDeleteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo)
}

func (r *ReposDeleteReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposDeleteReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposDeleteCommitCommentReq builds requests for "repos/delete-commit-comment"

Delete a commit comment.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
type ReposDeleteCommitCommentReq struct {
	Owner     string
	Repo      string
	CommentId int64
}

func (r *ReposDeleteCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *ReposDeleteCommitCommentReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteCommitCommentReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposDeleteCommitCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposDeleteDeploymentReq builds requests for "repos/delete-deployment"

Delete a deployment.

  DELETE /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
type ReposDeleteDeploymentReq struct {
	Owner        string
	Repo         string
	DeploymentId int64
}

func (r *ReposDeleteDeploymentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v", r.Owner, r.Repo, r.DeploymentId)
}

func (r *ReposDeleteDeploymentReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteDeploymentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteDeploymentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteDeploymentReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposDeleteDeploymentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposDeleteDownloadReq builds requests for "repos/delete-download"

Delete a download.

  DELETE /repos/{owner}/{repo}/downloads/{download_id}

https://developer.github.com/v3/repos/downloads/#delete-a-download
*/
type ReposDeleteDownloadReq struct {
	Owner      string
	Repo       string
	DownloadId int64
}

func (r *ReposDeleteDownloadReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/downloads/%v", r.Owner, r.Repo, r.DownloadId)
}

func (r *ReposDeleteDownloadReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteDownloadReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteDownloadReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteDownloadReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposDeleteDownloadReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposDeleteFileReq builds requests for "repos/delete-file"

Delete a file.

  DELETE /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileReq struct {
	Owner       string
	Repo        string
	Path        string
	RequestBody ReposDeleteFileReqBody
}

func (r *ReposDeleteFileReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path)
}

func (r *ReposDeleteFileReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteFileReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteFileReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteFileReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposDeleteFileReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

// ReposDeleteFileReqBodyAuthor is a value for ReposDeleteFileReqBody's Author field
type ReposDeleteFileReqBodyAuthor struct {

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

// ReposDeleteFileReqBodyCommitter is a value for ReposDeleteFileReqBody's Committer field
type ReposDeleteFileReqBodyCommitter struct {

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

/*
ReposDeleteFileReqBody is a request body for repos/delete-file

API documentation: https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileReqBody struct {

	// object containing information about the author.
	Author *ReposDeleteFileReqBodyAuthor `json:"author,omitempty"`

	// The branch name. Default: the repositorys default branch (usually `master`)
	Branch *string `json:"branch,omitempty"`

	// object containing information about the committer.
	Committer *ReposDeleteFileReqBodyCommitter `json:"committer,omitempty"`

	// The commit message.
	Message *string `json:"message"`

	// The blob SHA of the file being replaced.
	Sha *string `json:"sha"`
}

/*
ReposDeleteFileResponseBody200 is a response body for repos/delete-file

API documentation: https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileResponseBody200 struct {
	components.FileCommit2
}

/*
ReposDeleteHookReq builds requests for "repos/delete-hook"

Delete a hook.

  DELETE /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#delete-a-hook
*/
type ReposDeleteHookReq struct {
	Owner  string
	Repo   string
	HookId int64
}

func (r *ReposDeleteHookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId)
}

func (r *ReposDeleteHookReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteHookReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposDeleteHookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposDeleteInvitationReq builds requests for "repos/delete-invitation"

Delete a repository invitation.

  DELETE /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
type ReposDeleteInvitationReq struct {
	Owner        string
	Repo         string
	InvitationId int64
}

func (r *ReposDeleteInvitationReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/invitations/%v", r.Owner, r.Repo, r.InvitationId)
}

func (r *ReposDeleteInvitationReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteInvitationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteInvitationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteInvitationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposDeleteInvitationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposDeleteReleaseReq builds requests for "repos/delete-release"

Delete a release.

  DELETE /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
type ReposDeleteReleaseReq struct {
	Owner     string
	Repo      string
	ReleaseId int64
}

func (r *ReposDeleteReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposDeleteReleaseReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteReleaseReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposDeleteReleaseReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposDeleteReleaseAssetReq builds requests for "repos/delete-release-asset"

Delete a release asset.

  DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
type ReposDeleteReleaseAssetReq struct {
	Owner   string
	Repo    string
	AssetId int64
}

func (r *ReposDeleteReleaseAssetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId)
}

func (r *ReposDeleteReleaseAssetReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteReleaseAssetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteReleaseAssetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteReleaseAssetReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposDeleteReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposDisableAutomatedSecurityFixesReq builds requests for "repos/disable-automated-security-fixes"

Disable automated security fixes.

  DELETE /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
type ReposDisableAutomatedSecurityFixesReq struct {
	Owner string
	Repo  string

	/*
	Enabling or disabling automated security fixes is currently available for
	developers to preview. To access this new endpoint during the preview period,
	you must set this to true.
	*/
	LondonPreview bool
}

func (r *ReposDisableAutomatedSecurityFixesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/automated-security-fixes", r.Owner, r.Repo)
}

func (r *ReposDisableAutomatedSecurityFixesReq) method() string {
	return "DELETE"
}

func (r *ReposDisableAutomatedSecurityFixesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDisableAutomatedSecurityFixesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"london": r.LondonPreview}
	if requiredPreviews {
		previewVals["london"] = true
	}
	if allPreviews {
		previewVals["london"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDisableAutomatedSecurityFixesReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposDisableAutomatedSecurityFixesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposDisablePagesSiteReq builds requests for "repos/disable-pages-site"

Disable a Pages site.

  DELETE /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#disable-a-pages-site
*/
type ReposDisablePagesSiteReq struct {
	Owner string
	Repo  string

	/*
	Enabling and disabling Pages in the Pages API is currently available for
	developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-03-14-enabling-disabling-pages/)
	preview for more details. To access the new endpoints during the preview period,
	you must set this to true.
	*/
	SwitcherooPreview bool
}

func (r *ReposDisablePagesSiteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo)
}

func (r *ReposDisablePagesSiteReq) method() string {
	return "DELETE"
}

func (r *ReposDisablePagesSiteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDisablePagesSiteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"switcheroo": r.SwitcherooPreview}
	if requiredPreviews {
		previewVals["switcheroo"] = true
	}
	if allPreviews {
		previewVals["switcheroo"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDisablePagesSiteReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposDisablePagesSiteReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposDisableVulnerabilityAlertsReq builds requests for "repos/disable-vulnerability-alerts"

Disable vulnerability alerts.

  DELETE /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
type ReposDisableVulnerabilityAlertsReq struct {
	Owner string
	Repo  string

	/*
	Enabling and disabling vulnerability alerts for a repository using the REST API
	is currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

func (r *ReposDisableVulnerabilityAlertsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo)
}

func (r *ReposDisableVulnerabilityAlertsReq) method() string {
	return "DELETE"
}

func (r *ReposDisableVulnerabilityAlertsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDisableVulnerabilityAlertsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"dorian": r.DorianPreview}
	if requiredPreviews {
		previewVals["dorian"] = true
	}
	if allPreviews {
		previewVals["dorian"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDisableVulnerabilityAlertsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposDisableVulnerabilityAlertsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposEnableAutomatedSecurityFixesReq builds requests for "repos/enable-automated-security-fixes"

Enable automated security fixes.

  PUT /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
type ReposEnableAutomatedSecurityFixesReq struct {
	Owner string
	Repo  string

	/*
	Enabling or disabling automated security fixes is currently available for
	developers to preview. To access this new endpoint during the preview period,
	you must set this to true.
	*/
	LondonPreview bool
}

func (r *ReposEnableAutomatedSecurityFixesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/automated-security-fixes", r.Owner, r.Repo)
}

func (r *ReposEnableAutomatedSecurityFixesReq) method() string {
	return "PUT"
}

func (r *ReposEnableAutomatedSecurityFixesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposEnableAutomatedSecurityFixesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"london": r.LondonPreview}
	if requiredPreviews {
		previewVals["london"] = true
	}
	if allPreviews {
		previewVals["london"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposEnableAutomatedSecurityFixesReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposEnableAutomatedSecurityFixesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposEnablePagesSiteReq builds requests for "repos/enable-pages-site"

Enable a Pages site.

  POST /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#enable-a-pages-site
*/
type ReposEnablePagesSiteReq struct {
	Owner       string
	Repo        string
	RequestBody ReposEnablePagesSiteReqBody

	/*
	Enabling and disabling Pages in the Pages API is currently available for
	developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-03-14-enabling-disabling-pages/)
	preview for more details. To access the new endpoints during the preview period,
	you must set this to true.
	*/
	SwitcherooPreview bool
}

func (r *ReposEnablePagesSiteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo)
}

func (r *ReposEnablePagesSiteReq) method() string {
	return "POST"
}

func (r *ReposEnablePagesSiteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposEnablePagesSiteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"switcheroo": r.SwitcherooPreview}
	if requiredPreviews {
		previewVals["switcheroo"] = true
	}
	if allPreviews {
		previewVals["switcheroo"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposEnablePagesSiteReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposEnablePagesSiteReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

// ReposEnablePagesSiteReqBodySource is a value for ReposEnablePagesSiteReqBody's Source field
type ReposEnablePagesSiteReqBodySource struct {

	/*
	   The repository branch used to publish your [site's source
	   files](https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/).
	   Can be either `master` or `gh-pages`.
	*/
	Branch *string `json:"branch,omitempty"`

	/*
	   The repository directory that includes the source files for the Pages site. When
	   `branch` is `master`, you can change `path` to `/docs`. When `branch` is
	   `gh-pages`, you are unable to specify a `path` other than `/`.
	*/
	Path *string `json:"path,omitempty"`
}

/*
ReposEnablePagesSiteReqBody is a request body for repos/enable-pages-site

API documentation: https://developer.github.com/v3/repos/pages/#enable-a-pages-site
*/
type ReposEnablePagesSiteReqBody struct {
	Source *ReposEnablePagesSiteReqBodySource `json:"source,omitempty"`
}

/*
ReposEnablePagesSiteResponseBody201 is a response body for repos/enable-pages-site

API documentation: https://developer.github.com/v3/repos/pages/#enable-a-pages-site
*/
type ReposEnablePagesSiteResponseBody201 struct {
	components.Page
}

/*
ReposEnableVulnerabilityAlertsReq builds requests for "repos/enable-vulnerability-alerts"

Enable vulnerability alerts.

  PUT /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
type ReposEnableVulnerabilityAlertsReq struct {
	Owner string
	Repo  string

	/*
	Enabling and disabling vulnerability alerts for a repository using the REST API
	is currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

func (r *ReposEnableVulnerabilityAlertsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo)
}

func (r *ReposEnableVulnerabilityAlertsReq) method() string {
	return "PUT"
}

func (r *ReposEnableVulnerabilityAlertsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposEnableVulnerabilityAlertsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"dorian": r.DorianPreview}
	if requiredPreviews {
		previewVals["dorian"] = true
	}
	if allPreviews {
		previewVals["dorian"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposEnableVulnerabilityAlertsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposEnableVulnerabilityAlertsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetReq builds requests for "repos/get"

Get a repository.

  GET /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#get-a-repository
*/
type ReposGetReq struct {
	Owner string
	Repo  string

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	Developers can preview a new `code_of_conduct` key in responses. For more
	information, see [Codes of Conduct
	API](https://developer.github.com/v3/codes_of_conduct/).

	To access this new response key during the preview period, you must set this to
	true.
	*/
	ScarletWitchPreview bool
}

func (r *ReposGetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo)
}

func (r *ReposGetReq) method() string {
	return "GET"
}

func (r *ReposGetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"nebula":        r.NebulaPreview,
		"scarlet-witch": r.ScarletWitchPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["scarlet-witch"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetResponseBody200 is a response body for repos/get

API documentation: https://developer.github.com/v3/repos/#get-a-repository
*/
type ReposGetResponseBody200 struct {
	components.FullRepository
}

/*
ReposGetAllTopicsReq builds requests for "repos/get-all-topics"

Get all repository topics.

  GET /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
type ReposGetAllTopicsReq struct {
	Owner string
	Repo  string

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

func (r *ReposGetAllTopicsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/topics", r.Owner, r.Repo)
}

func (r *ReposGetAllTopicsReq) method() string {
	return "GET"
}

func (r *ReposGetAllTopicsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetAllTopicsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"mercy": r.MercyPreview}
	if requiredPreviews {
		previewVals["mercy"] = true
	}
	if allPreviews {
		previewVals["mercy"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetAllTopicsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetAllTopicsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetAllTopicsResponseBody200 is a response body for repos/get-all-topics

API documentation: https://developer.github.com/v3/repos/#get-all-repository-topics
*/
type ReposGetAllTopicsResponseBody200 struct {
	components.Topic
}

/*
ReposGetAppsWithAccessToProtectedBranchReq builds requests for "repos/get-apps-with-access-to-protected-branch"

Get apps with access to protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-protected-branch
*/
type ReposGetAppsWithAccessToProtectedBranchReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) method() string {
	return "GET"
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetAppsWithAccessToProtectedBranchReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetAppsWithAccessToProtectedBranchResponseBody200 is a response body for repos/get-apps-with-access-to-protected-branch

API documentation: https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-protected-branch
*/
type ReposGetAppsWithAccessToProtectedBranchResponseBody200 []struct {
	components.Integration2
}

/*
ReposGetArchiveLinkReq builds requests for "repos/get-archive-link"

Get archive link.

  GET /repos/{owner}/{repo}/{archive_format}/{ref}

https://developer.github.com/v3/repos/contents/#get-archive-link
*/
type ReposGetArchiveLinkReq struct {
	Owner         string
	Repo          string
	ArchiveFormat string
	Ref           string
}

func (r *ReposGetArchiveLinkReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/%v/%v", r.Owner, r.Repo, r.ArchiveFormat, r.Ref)
}

func (r *ReposGetArchiveLinkReq) method() string {
	return "GET"
}

func (r *ReposGetArchiveLinkReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetArchiveLinkReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetArchiveLinkReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetArchiveLinkReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetBranchReq builds requests for "repos/get-branch"

Get branch.

  GET /repos/{owner}/{repo}/branches/{branch}

https://developer.github.com/v3/repos/branches/#get-branch
*/
type ReposGetBranchReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetBranchReq) method() string {
	return "GET"
}

func (r *ReposGetBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetBranchReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetBranchReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetBranchResponseBody200 is a response body for repos/get-branch

API documentation: https://developer.github.com/v3/repos/branches/#get-branch
*/
type ReposGetBranchResponseBody200 struct {
	components.BranchWithProtection
}

/*
ReposGetBranchProtectionReq builds requests for "repos/get-branch-protection"

Get branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
type ReposGetBranchProtectionReq struct {
	Owner  string
	Repo   string
	Branch string

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

func (r *ReposGetBranchProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetBranchProtectionReq) method() string {
	return "GET"
}

func (r *ReposGetBranchProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetBranchProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"luke-cage": r.LukeCagePreview}
	if allPreviews {
		previewVals["luke-cage"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetBranchProtectionReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetBranchProtectionResponseBody200 is a response body for repos/get-branch-protection

API documentation: https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
type ReposGetBranchProtectionResponseBody200 struct {
	components.BranchProtection
}

/*
ReposGetClonesReq builds requests for "repos/get-clones"

Clones.

  GET /repos/{owner}/{repo}/traffic/clones

https://developer.github.com/v3/repos/traffic/#clones
*/
type ReposGetClonesReq struct {
	Owner string
	Repo  string

	// Must be one of: `day`, `week`.
	Per *string
}

func (r *ReposGetClonesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/traffic/clones", r.Owner, r.Repo)
}

func (r *ReposGetClonesReq) method() string {
	return "GET"
}

func (r *ReposGetClonesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Per != nil {
		query.Set("per", *r.Per)
	}
	return query
}

func (r *ReposGetClonesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetClonesReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetClonesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetClonesResponseBody200 is a response body for repos/get-clones

API documentation: https://developer.github.com/v3/repos/traffic/#clones
*/
type ReposGetClonesResponseBody200 struct {
	components.CloneTraffic
}

/*
ReposGetCodeFrequencyStatsReq builds requests for "repos/get-code-frequency-stats"

Get the number of additions and deletions per week.

  GET /repos/{owner}/{repo}/stats/code_frequency

https://developer.github.com/v3/repos/statistics/#get-the-number-of-additions-and-deletions-per-week
*/
type ReposGetCodeFrequencyStatsReq struct {
	Owner string
	Repo  string
}

func (r *ReposGetCodeFrequencyStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/code_frequency", r.Owner, r.Repo)
}

func (r *ReposGetCodeFrequencyStatsReq) method() string {
	return "GET"
}

func (r *ReposGetCodeFrequencyStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCodeFrequencyStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCodeFrequencyStatsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetCodeFrequencyStatsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetCodeFrequencyStatsResponseBody200 is a response body for repos/get-code-frequency-stats

API documentation: https://developer.github.com/v3/repos/statistics/#get-the-number-of-additions-and-deletions-per-week
*/
type ReposGetCodeFrequencyStatsResponseBody200 []struct {
	components.CodeFrequencyStat
}

/*
ReposGetCollaboratorPermissionLevelReq builds requests for "repos/get-collaborator-permission-level"

Review a user's permission level.

  GET /repos/{owner}/{repo}/collaborators/{username}/permission

https://developer.github.com/v3/repos/collaborators/#review-a-users-permission-level
*/
type ReposGetCollaboratorPermissionLevelReq struct {
	Owner    string
	Repo     string
	Username string
}

func (r *ReposGetCollaboratorPermissionLevelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators/%v/permission", r.Owner, r.Repo, r.Username)
}

func (r *ReposGetCollaboratorPermissionLevelReq) method() string {
	return "GET"
}

func (r *ReposGetCollaboratorPermissionLevelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCollaboratorPermissionLevelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCollaboratorPermissionLevelReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetCollaboratorPermissionLevelReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetCollaboratorPermissionLevelResponseBody200 is a response body for repos/get-collaborator-permission-level

API documentation: https://developer.github.com/v3/repos/collaborators/#review-a-users-permission-level
*/
type ReposGetCollaboratorPermissionLevelResponseBody200 struct {
	components.RepositoryCollaboratorPermission
}

/*
ReposGetCombinedStatusForRefReq builds requests for "repos/get-combined-status-for-ref"

Get the combined status for a specific ref.

  GET /repos/{owner}/{repo}/commits/{ref}/status

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
*/
type ReposGetCombinedStatusForRefReq struct {
	Owner string
	Repo  string
	Ref   string
}

func (r *ReposGetCombinedStatusForRefReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/status", r.Owner, r.Repo, r.Ref)
}

func (r *ReposGetCombinedStatusForRefReq) method() string {
	return "GET"
}

func (r *ReposGetCombinedStatusForRefReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCombinedStatusForRefReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCombinedStatusForRefReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetCombinedStatusForRefReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetCombinedStatusForRefResponseBody200 is a response body for repos/get-combined-status-for-ref

API documentation: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
*/
type ReposGetCombinedStatusForRefResponseBody200 struct {
	components.CombinedCommitStatus
}

/*
ReposGetCommitReq builds requests for "repos/get-commit"

Get a single commit.

  GET /repos/{owner}/{repo}/commits/{ref}

https://developer.github.com/v3/repos/commits/#get-a-single-commit
*/
type ReposGetCommitReq struct {
	Owner string
	Repo  string
	Ref   string
}

func (r *ReposGetCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v", r.Owner, r.Repo, r.Ref)
}

func (r *ReposGetCommitReq) method() string {
	return "GET"
}

func (r *ReposGetCommitReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCommitReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetCommitReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetCommitResponseBody200 is a response body for repos/get-commit

API documentation: https://developer.github.com/v3/repos/commits/#get-a-single-commit
*/
type ReposGetCommitResponseBody200 struct {
	components.Commit
}

/*
ReposGetCommitActivityStatsReq builds requests for "repos/get-commit-activity-stats"

Get the last year of commit activity data.

  GET /repos/{owner}/{repo}/stats/commit_activity

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data
*/
type ReposGetCommitActivityStatsReq struct {
	Owner string
	Repo  string
}

func (r *ReposGetCommitActivityStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/commit_activity", r.Owner, r.Repo)
}

func (r *ReposGetCommitActivityStatsReq) method() string {
	return "GET"
}

func (r *ReposGetCommitActivityStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCommitActivityStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCommitActivityStatsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetCommitActivityStatsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetCommitActivityStatsResponseBody200 is a response body for repos/get-commit-activity-stats

API documentation: https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data
*/
type ReposGetCommitActivityStatsResponseBody200 []struct {
	components.CommitActivity
}

/*
ReposGetCommitCommentReq builds requests for "repos/get-commit-comment"

Get a single commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#get-a-single-commit-comment
*/
type ReposGetCommitCommentReq struct {
	Owner     string
	Repo      string
	CommentId int64

	/*
	An additional `reactions` object in the commit comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReposGetCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *ReposGetCommitCommentReq) method() string {
	return "GET"
}

func (r *ReposGetCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCommitCommentReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetCommitCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetCommitCommentResponseBody200 is a response body for repos/get-commit-comment

API documentation: https://developer.github.com/v3/repos/comments/#get-a-single-commit-comment
*/
type ReposGetCommitCommentResponseBody200 struct {
	components.CommitComment
}

/*
ReposGetContentsReq builds requests for "repos/get-contents"

Get contents.

  GET /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#get-contents
*/
type ReposGetContentsReq struct {
	Owner string
	Repo  string
	Path  string

	/*
	The name of the commit/branch/tag. Default: the repositorys default branch
	(usually `master`)
	*/
	Ref *string
}

func (r *ReposGetContentsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path)
}

func (r *ReposGetContentsReq) method() string {
	return "GET"
}

func (r *ReposGetContentsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}
	return query
}

func (r *ReposGetContentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetContentsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetContentsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetContentsResponseBody200 is a response body for repos/get-contents

API documentation: https://developer.github.com/v3/repos/contents/#get-contents
*/
type ReposGetContentsResponseBody200 struct {
	components.ContentFile
}

/*
ReposGetContributorsStatsReq builds requests for "repos/get-contributors-stats"

Get contributors list with additions, deletions, and commit counts.

  GET /repos/{owner}/{repo}/stats/contributors

https://developer.github.com/v3/repos/statistics/#get-contributors-list-with-additions-deletions-and-commit-counts
*/
type ReposGetContributorsStatsReq struct {
	Owner string
	Repo  string
}

func (r *ReposGetContributorsStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/contributors", r.Owner, r.Repo)
}

func (r *ReposGetContributorsStatsReq) method() string {
	return "GET"
}

func (r *ReposGetContributorsStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetContributorsStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetContributorsStatsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetContributorsStatsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetContributorsStatsResponseBody200 is a response body for repos/get-contributors-stats

API documentation: https://developer.github.com/v3/repos/statistics/#get-contributors-list-with-additions-deletions-and-commit-counts
*/
type ReposGetContributorsStatsResponseBody200 []struct {
	components.ContributorActivity
}

/*
ReposGetDeployKeyReq builds requests for "repos/get-deploy-key"

Get a deploy key.

  GET /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
type ReposGetDeployKeyReq struct {
	Owner string
	Repo  string
	KeyId int64
}

func (r *ReposGetDeployKeyReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/keys/%v", r.Owner, r.Repo, r.KeyId)
}

func (r *ReposGetDeployKeyReq) method() string {
	return "GET"
}

func (r *ReposGetDeployKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetDeployKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetDeployKeyReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetDeployKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetDeployKeyResponseBody200 is a response body for repos/get-deploy-key

API documentation: https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
type ReposGetDeployKeyResponseBody200 struct {
	components.DeployKey
}

/*
ReposGetDeploymentReq builds requests for "repos/get-deployment"

Get a single deployment.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#get-a-single-deployment
*/
type ReposGetDeploymentReq struct {
	Owner        string
	Repo         string
	DeploymentId int64

	/*
	If a deployment is created via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	The `transient_environment` and `production_environment` parameters are
	currently available for developers to preview. During the preview period, the
	API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposGetDeploymentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v", r.Owner, r.Repo, r.DeploymentId)
}

func (r *ReposGetDeploymentReq) method() string {
	return "GET"
}

func (r *ReposGetDeploymentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetDeploymentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"ant-man":     r.AntManPreview,
		"machine-man": r.MachineManPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetDeploymentReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetDeploymentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetDeploymentResponseBody200 is a response body for repos/get-deployment

API documentation: https://developer.github.com/v3/repos/deployments/#get-a-single-deployment
*/
type ReposGetDeploymentResponseBody200 struct {
	components.Deployment
}

/*
ReposGetDeploymentStatusReq builds requests for "repos/get-deployment-status"

Get a single deployment status.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}

https://developer.github.com/v3/repos/deployments/#get-a-single-deployment-status
*/
type ReposGetDeploymentStatusReq struct {
	Owner        string
	Repo         string
	DeploymentId int64
	StatusId     int64

	/*
	If a deployment is created via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposGetDeploymentStatusReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses/%v", r.Owner, r.Repo, r.DeploymentId, r.StatusId)
}

func (r *ReposGetDeploymentStatusReq) method() string {
	return "GET"
}

func (r *ReposGetDeploymentStatusReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetDeploymentStatusReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"ant-man":     r.AntManPreview,
		"flash":       r.FlashPreview,
		"machine-man": r.MachineManPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["flash"] = true
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetDeploymentStatusReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetDeploymentStatusReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetDeploymentStatusResponseBody200 is a response body for repos/get-deployment-status

API documentation: https://developer.github.com/v3/repos/deployments/#get-a-single-deployment-status
*/
type ReposGetDeploymentStatusResponseBody200 struct {
	components.DeploymentStatus
}

/*
ReposGetDownloadReq builds requests for "repos/get-download"

Get a single download.

  GET /repos/{owner}/{repo}/downloads/{download_id}

https://developer.github.com/v3/repos/downloads/#get-a-single-download
*/
type ReposGetDownloadReq struct {
	Owner      string
	Repo       string
	DownloadId int64
}

func (r *ReposGetDownloadReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/downloads/%v", r.Owner, r.Repo, r.DownloadId)
}

func (r *ReposGetDownloadReq) method() string {
	return "GET"
}

func (r *ReposGetDownloadReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetDownloadReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetDownloadReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetDownloadReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetDownloadResponseBody200 is a response body for repos/get-download

API documentation: https://developer.github.com/v3/repos/downloads/#get-a-single-download
*/
type ReposGetDownloadResponseBody200 struct {
	components.Download
}

/*
ReposGetHookReq builds requests for "repos/get-hook"

Get single hook.

  GET /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#get-single-hook
*/
type ReposGetHookReq struct {
	Owner  string
	Repo   string
	HookId int64
}

func (r *ReposGetHookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId)
}

func (r *ReposGetHookReq) method() string {
	return "GET"
}

func (r *ReposGetHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetHookReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetHookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetHookResponseBody200 is a response body for repos/get-hook

API documentation: https://developer.github.com/v3/repos/hooks/#get-single-hook
*/
type ReposGetHookResponseBody200 struct {
	components.Hook
}

/*
ReposGetLatestPagesBuildReq builds requests for "repos/get-latest-pages-build"

Get latest Pages build.

  GET /repos/{owner}/{repo}/pages/builds/latest

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
type ReposGetLatestPagesBuildReq struct {
	Owner string
	Repo  string
}

func (r *ReposGetLatestPagesBuildReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages/builds/latest", r.Owner, r.Repo)
}

func (r *ReposGetLatestPagesBuildReq) method() string {
	return "GET"
}

func (r *ReposGetLatestPagesBuildReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetLatestPagesBuildReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetLatestPagesBuildReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetLatestPagesBuildReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetLatestPagesBuildResponseBody200 is a response body for repos/get-latest-pages-build

API documentation: https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
type ReposGetLatestPagesBuildResponseBody200 struct {
	components.PageBuild
}

/*
ReposGetLatestReleaseReq builds requests for "repos/get-latest-release"

Get the latest release.

  GET /repos/{owner}/{repo}/releases/latest

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
type ReposGetLatestReleaseReq struct {
	Owner string
	Repo  string
}

func (r *ReposGetLatestReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/latest", r.Owner, r.Repo)
}

func (r *ReposGetLatestReleaseReq) method() string {
	return "GET"
}

func (r *ReposGetLatestReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetLatestReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetLatestReleaseReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetLatestReleaseReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetLatestReleaseResponseBody200 is a response body for repos/get-latest-release

API documentation: https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
type ReposGetLatestReleaseResponseBody200 struct {
	components.Release2
}

/*
ReposGetPagesReq builds requests for "repos/get-pages"

Get information about a Pages site.

  GET /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#get-information-about-a-pages-site
*/
type ReposGetPagesReq struct {
	Owner string
	Repo  string
}

func (r *ReposGetPagesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo)
}

func (r *ReposGetPagesReq) method() string {
	return "GET"
}

func (r *ReposGetPagesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetPagesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetPagesReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetPagesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetPagesResponseBody200 is a response body for repos/get-pages

API documentation: https://developer.github.com/v3/repos/pages/#get-information-about-a-pages-site
*/
type ReposGetPagesResponseBody200 struct {
	components.Page
}

/*
ReposGetPagesBuildReq builds requests for "repos/get-pages-build"

Get a specific Pages build.

  GET /repos/{owner}/{repo}/pages/builds/{build_id}

https://developer.github.com/v3/repos/pages/#get-a-specific-pages-build
*/
type ReposGetPagesBuildReq struct {
	Owner   string
	Repo    string
	BuildId int64
}

func (r *ReposGetPagesBuildReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages/builds/%v", r.Owner, r.Repo, r.BuildId)
}

func (r *ReposGetPagesBuildReq) method() string {
	return "GET"
}

func (r *ReposGetPagesBuildReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetPagesBuildReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetPagesBuildReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetPagesBuildReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetPagesBuildResponseBody200 is a response body for repos/get-pages-build

API documentation: https://developer.github.com/v3/repos/pages/#get-a-specific-pages-build
*/
type ReposGetPagesBuildResponseBody200 struct {
	components.PageBuild
}

/*
ReposGetParticipationStatsReq builds requests for "repos/get-participation-stats"

Get the weekly commit count for the repository owner and everyone else.

  GET /repos/{owner}/{repo}/stats/participation

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count-for-the-repository-owner-and-everyone-else
*/
type ReposGetParticipationStatsReq struct {
	Owner string
	Repo  string
}

func (r *ReposGetParticipationStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/participation", r.Owner, r.Repo)
}

func (r *ReposGetParticipationStatsReq) method() string {
	return "GET"
}

func (r *ReposGetParticipationStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetParticipationStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetParticipationStatsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetParticipationStatsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetParticipationStatsResponseBody200 is a response body for repos/get-participation-stats

API documentation: https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count-for-the-repository-owner-and-everyone-else
*/
type ReposGetParticipationStatsResponseBody200 struct {
	components.ParticipationStats
}

/*
ReposGetProtectedBranchAdminEnforcementReq builds requests for "repos/get-protected-branch-admin-enforcement"

Get admin enforcement of protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#get-admin-enforcement-of-protected-branch
*/
type ReposGetProtectedBranchAdminEnforcementReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) method() string {
	return "GET"
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetProtectedBranchAdminEnforcementReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetProtectedBranchAdminEnforcementResponseBody200 is a response body for repos/get-protected-branch-admin-enforcement

API documentation: https://developer.github.com/v3/repos/branches/#get-admin-enforcement-of-protected-branch
*/
type ReposGetProtectedBranchAdminEnforcementResponseBody200 struct {
	components.ProtectedBranchAdminEnforced
}

/*
ReposGetProtectedBranchPullRequestReviewEnforcementReq builds requests for "repos/get-protected-branch-pull-request-review-enforcement"

Get pull request review enforcement of protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#get-pull-request-review-enforcement-of-protected-branch
*/
type ReposGetProtectedBranchPullRequestReviewEnforcementReq struct {
	Owner  string
	Repo   string
	Branch string

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) method() string {
	return "GET"
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"luke-cage": r.LukeCagePreview}
	if allPreviews {
		previewVals["luke-cage"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetProtectedBranchRequiredSignaturesReq builds requests for "repos/get-protected-branch-required-signatures"

Get required signatures of protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#get-required-signatures-of-protected-branch
*/
type ReposGetProtectedBranchRequiredSignaturesReq struct {
	Owner  string
	Repo   string
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) method() string {
	return "GET"
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"zzzax": r.ZzzaxPreview}
	if requiredPreviews {
		previewVals["zzzax"] = true
	}
	if allPreviews {
		previewVals["zzzax"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetProtectedBranchRequiredSignaturesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetProtectedBranchRequiredSignaturesResponseBody200 is a response body for repos/get-protected-branch-required-signatures

API documentation: https://developer.github.com/v3/repos/branches/#get-required-signatures-of-protected-branch
*/
type ReposGetProtectedBranchRequiredSignaturesResponseBody200 struct {
	components.ProtectedBranchAdminEnforced
}

/*
ReposGetProtectedBranchRequiredStatusChecksReq builds requests for "repos/get-protected-branch-required-status-checks"

Get required status checks of protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#get-required-status-checks-of-protected-branch
*/
type ReposGetProtectedBranchRequiredStatusChecksReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) method() string {
	return "GET"
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetProtectedBranchRequiredStatusChecksReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetProtectedBranchRequiredStatusChecksResponseBody200 is a response body for repos/get-protected-branch-required-status-checks

API documentation: https://developer.github.com/v3/repos/branches/#get-required-status-checks-of-protected-branch
*/
type ReposGetProtectedBranchRequiredStatusChecksResponseBody200 struct {
	components.StatusCheckPolicy
}

/*
ReposGetProtectedBranchRestrictionsReq builds requests for "repos/get-protected-branch-restrictions"

Get restrictions of protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#get-restrictions-of-protected-branch
*/
type ReposGetProtectedBranchRestrictionsReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetProtectedBranchRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetProtectedBranchRestrictionsReq) method() string {
	return "GET"
}

func (r *ReposGetProtectedBranchRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetProtectedBranchRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetProtectedBranchRestrictionsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetProtectedBranchRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetProtectedBranchRestrictionsResponseBody200 is a response body for repos/get-protected-branch-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#get-restrictions-of-protected-branch
*/
type ReposGetProtectedBranchRestrictionsResponseBody200 struct {
	components.BranchRestrictionPolicy
}

/*
ReposGetPunchCardStatsReq builds requests for "repos/get-punch-card-stats"

Get the number of commits per hour in each day.

  GET /repos/{owner}/{repo}/stats/punch_card

https://developer.github.com/v3/repos/statistics/#get-the-number-of-commits-per-hour-in-each-day
*/
type ReposGetPunchCardStatsReq struct {
	Owner string
	Repo  string
}

func (r *ReposGetPunchCardStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/punch_card", r.Owner, r.Repo)
}

func (r *ReposGetPunchCardStatsReq) method() string {
	return "GET"
}

func (r *ReposGetPunchCardStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetPunchCardStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetPunchCardStatsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetPunchCardStatsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetPunchCardStatsResponseBody200 is a response body for repos/get-punch-card-stats

API documentation: https://developer.github.com/v3/repos/statistics/#get-the-number-of-commits-per-hour-in-each-day
*/
type ReposGetPunchCardStatsResponseBody200 []struct {
	components.CodeFrequencyStat
}

/*
ReposGetReadmeReq builds requests for "repos/get-readme"

Get the README.

  GET /repos/{owner}/{repo}/readme

https://developer.github.com/v3/repos/contents/#get-the-readme
*/
type ReposGetReadmeReq struct {
	Owner string
	Repo  string

	/*
	The name of the commit/branch/tag. Default: the repositorys default branch
	(usually `master`)
	*/
	Ref *string
}

func (r *ReposGetReadmeReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/readme", r.Owner, r.Repo)
}

func (r *ReposGetReadmeReq) method() string {
	return "GET"
}

func (r *ReposGetReadmeReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}
	return query
}

func (r *ReposGetReadmeReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReadmeReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetReadmeReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetReadmeResponseBody200 is a response body for repos/get-readme

API documentation: https://developer.github.com/v3/repos/contents/#get-the-readme
*/
type ReposGetReadmeResponseBody200 struct {
	components.ContentFile
}

/*
ReposGetReleaseReq builds requests for "repos/get-release"

Get a single release.

  GET /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#get-a-single-release
*/
type ReposGetReleaseReq struct {
	Owner     string
	Repo      string
	ReleaseId int64
}

func (r *ReposGetReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposGetReleaseReq) method() string {
	return "GET"
}

func (r *ReposGetReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReleaseReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetReleaseReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetReleaseResponseBody200 is a response body for repos/get-release

API documentation: https://developer.github.com/v3/repos/releases/#get-a-single-release
*/
type ReposGetReleaseResponseBody200 struct {
	components.Release2
}

/*
ReposGetReleaseAssetReq builds requests for "repos/get-release-asset"

Get a single release asset.

  GET /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#get-a-single-release-asset
*/
type ReposGetReleaseAssetReq struct {
	Owner   string
	Repo    string
	AssetId int64
}

func (r *ReposGetReleaseAssetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId)
}

func (r *ReposGetReleaseAssetReq) method() string {
	return "GET"
}

func (r *ReposGetReleaseAssetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetReleaseAssetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReleaseAssetReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetReleaseAssetResponseBody200 is a response body for repos/get-release-asset

API documentation: https://developer.github.com/v3/repos/releases/#get-a-single-release-asset
*/
type ReposGetReleaseAssetResponseBody200 struct {
	components.ReleaseAsset
}

/*
ReposGetReleaseByTagReq builds requests for "repos/get-release-by-tag"

Get a release by tag name.

  GET /repos/{owner}/{repo}/releases/tags/{tag}

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
type ReposGetReleaseByTagReq struct {
	Owner string
	Repo  string
	Tag   string
}

func (r *ReposGetReleaseByTagReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/tags/%v", r.Owner, r.Repo, r.Tag)
}

func (r *ReposGetReleaseByTagReq) method() string {
	return "GET"
}

func (r *ReposGetReleaseByTagReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetReleaseByTagReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReleaseByTagReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetReleaseByTagReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetReleaseByTagResponseBody200 is a response body for repos/get-release-by-tag

API documentation: https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
type ReposGetReleaseByTagResponseBody200 struct {
	components.Release2
}

/*
ReposGetTeamsWithAccessToProtectedBranchReq builds requests for "repos/get-teams-with-access-to-protected-branch"

Get teams with access to protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-protected-branch
*/
type ReposGetTeamsWithAccessToProtectedBranchReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) method() string {
	return "GET"
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetTeamsWithAccessToProtectedBranchReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetTeamsWithAccessToProtectedBranchResponseBody200 is a response body for repos/get-teams-with-access-to-protected-branch

API documentation: https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-protected-branch
*/
type ReposGetTeamsWithAccessToProtectedBranchResponseBody200 []struct {
	components.Team
}

/*
ReposGetTopPathsReq builds requests for "repos/get-top-paths"

List paths.

  GET /repos/{owner}/{repo}/traffic/popular/paths

https://developer.github.com/v3/repos/traffic/#list-paths
*/
type ReposGetTopPathsReq struct {
	Owner string
	Repo  string
}

func (r *ReposGetTopPathsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/traffic/popular/paths", r.Owner, r.Repo)
}

func (r *ReposGetTopPathsReq) method() string {
	return "GET"
}

func (r *ReposGetTopPathsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetTopPathsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetTopPathsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetTopPathsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetTopPathsResponseBody200 is a response body for repos/get-top-paths

API documentation: https://developer.github.com/v3/repos/traffic/#list-paths
*/
type ReposGetTopPathsResponseBody200 []struct {
	components.ContentTraffic
}

/*
ReposGetTopReferrersReq builds requests for "repos/get-top-referrers"

List referrers.

  GET /repos/{owner}/{repo}/traffic/popular/referrers

https://developer.github.com/v3/repos/traffic/#list-referrers
*/
type ReposGetTopReferrersReq struct {
	Owner string
	Repo  string
}

func (r *ReposGetTopReferrersReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/traffic/popular/referrers", r.Owner, r.Repo)
}

func (r *ReposGetTopReferrersReq) method() string {
	return "GET"
}

func (r *ReposGetTopReferrersReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetTopReferrersReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetTopReferrersReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetTopReferrersReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetTopReferrersResponseBody200 is a response body for repos/get-top-referrers

API documentation: https://developer.github.com/v3/repos/traffic/#list-referrers
*/
type ReposGetTopReferrersResponseBody200 []struct {
	components.ReferrerTraffic
}

/*
ReposGetUsersWithAccessToProtectedBranchReq builds requests for "repos/get-users-with-access-to-protected-branch"

Get users with access to protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-protected-branch
*/
type ReposGetUsersWithAccessToProtectedBranchReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) method() string {
	return "GET"
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetUsersWithAccessToProtectedBranchReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetUsersWithAccessToProtectedBranchResponseBody200 is a response body for repos/get-users-with-access-to-protected-branch

API documentation: https://developer.github.com/v3/repos/branches/#list-users-with-access-to-protected-branch
*/
type ReposGetUsersWithAccessToProtectedBranchResponseBody200 []struct {
	components.SimpleUser
}

/*
ReposGetViewsReq builds requests for "repos/get-views"

Views.

  GET /repos/{owner}/{repo}/traffic/views

https://developer.github.com/v3/repos/traffic/#views
*/
type ReposGetViewsReq struct {
	Owner string
	Repo  string

	// Must be one of: `day`, `week`.
	Per *string
}

func (r *ReposGetViewsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/traffic/views", r.Owner, r.Repo)
}

func (r *ReposGetViewsReq) method() string {
	return "GET"
}

func (r *ReposGetViewsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Per != nil {
		query.Set("per", *r.Per)
	}
	return query
}

func (r *ReposGetViewsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetViewsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposGetViewsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposGetViewsResponseBody200 is a response body for repos/get-views

API documentation: https://developer.github.com/v3/repos/traffic/#views
*/
type ReposGetViewsResponseBody200 struct {
	components.ViewTraffic
}

/*
ReposListAssetsForReleaseReq builds requests for "repos/list-assets-for-release"

List assets for a release.

  GET /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#list-assets-for-a-release
*/
type ReposListAssetsForReleaseReq struct {
	Owner     string
	Repo      string
	ReleaseId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListAssetsForReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v/assets", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposListAssetsForReleaseReq) method() string {
	return "GET"
}

func (r *ReposListAssetsForReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListAssetsForReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListAssetsForReleaseReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListAssetsForReleaseReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListAssetsForReleaseResponseBody200 is a response body for repos/list-assets-for-release

API documentation: https://developer.github.com/v3/repos/releases/#list-assets-for-a-release
*/
type ReposListAssetsForReleaseResponseBody200 []struct {
	components.ReleaseAsset
}

/*
ReposListBranchesReq builds requests for "repos/list-branches"

List branches.

  GET /repos/{owner}/{repo}/branches

https://developer.github.com/v3/repos/branches/#list-branches
*/
type ReposListBranchesReq struct {
	Owner string
	Repo  string

	/*
	Setting to `true` returns only protected branches. When set to `false`, only
	unprotected branches are returned. Omitting this parameter returns all branches.
	*/
	Protected *bool

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListBranchesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches", r.Owner, r.Repo)
}

func (r *ReposListBranchesReq) method() string {
	return "GET"
}

func (r *ReposListBranchesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Protected != nil {
		query.Set("protected", strconv.FormatBool(*r.Protected))
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListBranchesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListBranchesReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListBranchesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListBranchesResponseBody200 is a response body for repos/list-branches

API documentation: https://developer.github.com/v3/repos/branches/#list-branches
*/
type ReposListBranchesResponseBody200 []struct {
	components.ShortBranchWithProtection
}

/*
ReposListBranchesForHeadCommitReq builds requests for "repos/list-branches-for-head-commit"

List branches for HEAD commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
type ReposListBranchesForHeadCommitReq struct {
	Owner     string
	Repo      string
	CommitSha string

	/*
	Listing branches or pull requests for a commit in the Commits API is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-04-11-pulls-branches-for-commit/)
	for more details. To access the new endpoints during the preview period, you
	must set this to true.
	*/
	GrootPreview bool
}

func (r *ReposListBranchesForHeadCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/branches-where-head", r.Owner, r.Repo, r.CommitSha)
}

func (r *ReposListBranchesForHeadCommitReq) method() string {
	return "GET"
}

func (r *ReposListBranchesForHeadCommitReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposListBranchesForHeadCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"groot": r.GrootPreview}
	if requiredPreviews {
		previewVals["groot"] = true
	}
	if allPreviews {
		previewVals["groot"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListBranchesForHeadCommitReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListBranchesForHeadCommitReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListBranchesForHeadCommitResponseBody200 is a response body for repos/list-branches-for-head-commit

API documentation: https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
type ReposListBranchesForHeadCommitResponseBody200 []struct {
	components.BranchShort
}

/*
ReposListCollaboratorsReq builds requests for "repos/list-collaborators"

List collaborators.

  GET /repos/{owner}/{repo}/collaborators

https://developer.github.com/v3/repos/collaborators/#list-collaborators
*/
type ReposListCollaboratorsReq struct {
	Owner string
	Repo  string

	/*
	Filter collaborators returned by their affiliation. Can be one of:
	\* `outside`: All outside collaborators of an organization-owned repository.
	\* `direct`: All collaborators with permissions to an organization-owned
	repository, regardless of organization membership status.
	\* `all`: All collaborators the authenticated user can see.
	*/
	Affiliation *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListCollaboratorsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators", r.Owner, r.Repo)
}

func (r *ReposListCollaboratorsReq) method() string {
	return "GET"
}

func (r *ReposListCollaboratorsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListCollaboratorsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListCollaboratorsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListCollaboratorsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListCollaboratorsResponseBody200 is a response body for repos/list-collaborators

API documentation: https://developer.github.com/v3/repos/collaborators/#list-collaborators
*/
type ReposListCollaboratorsResponseBody200 []struct {
	components.Collaborator
}

/*
ReposListCommentsForCommitReq builds requests for "repos/list-comments-for-commit"

List comments for a single commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#list-comments-for-a-single-commit
*/
type ReposListCommentsForCommitReq struct {
	Owner     string
	Repo      string
	CommitSha string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the commit comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReposListCommentsForCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/comments", r.Owner, r.Repo, r.CommitSha)
}

func (r *ReposListCommentsForCommitReq) method() string {
	return "GET"
}

func (r *ReposListCommentsForCommitReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListCommentsForCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListCommentsForCommitReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListCommentsForCommitReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListCommentsForCommitResponseBody200 is a response body for repos/list-comments-for-commit

API documentation: https://developer.github.com/v3/repos/comments/#list-comments-for-a-single-commit
*/
type ReposListCommentsForCommitResponseBody200 []struct {
	components.CommitComment
}

/*
ReposListCommitCommentsReq builds requests for "repos/list-commit-comments"

List commit comments for a repository.

  GET /repos/{owner}/{repo}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
type ReposListCommitCommentsReq struct {
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the commit comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReposListCommitCommentsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments", r.Owner, r.Repo)
}

func (r *ReposListCommitCommentsReq) method() string {
	return "GET"
}

func (r *ReposListCommitCommentsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListCommitCommentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListCommitCommentsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListCommitCommentsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListCommitCommentsResponseBody200 is a response body for repos/list-commit-comments

API documentation: https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
type ReposListCommitCommentsResponseBody200 []struct {
	components.CommitComment
}

/*
ReposListCommitsReq builds requests for "repos/list-commits"

List commits on a repository.

  GET /repos/{owner}/{repo}/commits

https://developer.github.com/v3/repos/commits/#list-commits-on-a-repository
*/
type ReposListCommitsReq struct {
	Owner string
	Repo  string

	/*
	SHA or branch to start listing commits from. Default: the repositorys default
	branch (usually `master`).
	*/
	Sha *string

	// Only commits containing this file path will be returned.
	Path *string

	// GitHub login or email address by which to filter by commit author.
	Author *string

	/*
	Only commits after this date will be returned. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only commits before this date will be returned. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Until *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListCommitsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits", r.Owner, r.Repo)
}

func (r *ReposListCommitsReq) method() string {
	return "GET"
}

func (r *ReposListCommitsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sha != nil {
		query.Set("sha", *r.Sha)
	}
	if r.Path != nil {
		query.Set("path", *r.Path)
	}
	if r.Author != nil {
		query.Set("author", *r.Author)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Until != nil {
		query.Set("until", *r.Until)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListCommitsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListCommitsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListCommitsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListCommitsResponseBody200 is a response body for repos/list-commits

API documentation: https://developer.github.com/v3/repos/commits/#list-commits-on-a-repository
*/
type ReposListCommitsResponseBody200 []struct {
	components.SimpleCommit
}

/*
ReposListContributorsReq builds requests for "repos/list-contributors"

List contributors.

  GET /repos/{owner}/{repo}/contributors

https://developer.github.com/v3/repos/#list-contributors
*/
type ReposListContributorsReq struct {
	Owner string
	Repo  string

	// Set to `1` or `true` to include anonymous contributors in results.
	Anon *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListContributorsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/contributors", r.Owner, r.Repo)
}

func (r *ReposListContributorsReq) method() string {
	return "GET"
}

func (r *ReposListContributorsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Anon != nil {
		query.Set("anon", *r.Anon)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListContributorsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListContributorsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListContributorsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListContributorsResponseBody200 is a response body for repos/list-contributors

API documentation: https://developer.github.com/v3/repos/#list-contributors
*/
type ReposListContributorsResponseBody200 []struct {
	components.Contributor
}

/*
ReposListDeployKeysReq builds requests for "repos/list-deploy-keys"

List deploy keys.

  GET /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
type ReposListDeployKeysReq struct {
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListDeployKeysReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/keys", r.Owner, r.Repo)
}

func (r *ReposListDeployKeysReq) method() string {
	return "GET"
}

func (r *ReposListDeployKeysReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListDeployKeysReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListDeployKeysReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListDeployKeysReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListDeployKeysResponseBody200 is a response body for repos/list-deploy-keys

API documentation: https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
type ReposListDeployKeysResponseBody200 []struct {
	components.DeployKey
}

/*
ReposListDeploymentStatusesReq builds requests for "repos/list-deployment-statuses"

List deployment statuses.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
type ReposListDeploymentStatusesReq struct {
	Owner        string
	Repo         string
	DeploymentId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposListDeploymentStatusesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses", r.Owner, r.Repo, r.DeploymentId)
}

func (r *ReposListDeploymentStatusesReq) method() string {
	return "GET"
}

func (r *ReposListDeploymentStatusesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListDeploymentStatusesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"ant-man": r.AntManPreview,
		"flash":   r.FlashPreview,
	}
	if allPreviews {
		previewVals["flash"] = true
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListDeploymentStatusesReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListDeploymentStatusesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListDeploymentStatusesResponseBody200 is a response body for repos/list-deployment-statuses

API documentation: https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
type ReposListDeploymentStatusesResponseBody200 []struct {
	components.DeploymentStatus
}

/*
ReposListDeploymentsReq builds requests for "repos/list-deployments"

List deployments.

  GET /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
type ReposListDeploymentsReq struct {
	Owner string
	Repo  string

	// The SHA recorded at creation time.
	Sha *string

	// The name of the ref. This can be a branch, tag, or SHA.
	Ref *string

	// The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).
	Task *string

	/*
	The name of the environment that was deployed to (e.g., `staging` or
	`production`).
	*/
	Environment *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The `transient_environment` and `production_environment` parameters are
	currently available for developers to preview. During the preview period, the
	API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposListDeploymentsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments", r.Owner, r.Repo)
}

func (r *ReposListDeploymentsReq) method() string {
	return "GET"
}

func (r *ReposListDeploymentsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sha != nil {
		query.Set("sha", *r.Sha)
	}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}
	if r.Task != nil {
		query.Set("task", *r.Task)
	}
	if r.Environment != nil {
		query.Set("environment", *r.Environment)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListDeploymentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"ant-man": r.AntManPreview}
	if allPreviews {
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListDeploymentsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListDeploymentsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListDeploymentsResponseBody200 is a response body for repos/list-deployments

API documentation: https://developer.github.com/v3/repos/deployments/#list-deployments
*/
type ReposListDeploymentsResponseBody200 []struct {
	components.Deployment
}

/*
ReposListDownloadsReq builds requests for "repos/list-downloads"

List downloads for a repository.

  GET /repos/{owner}/{repo}/downloads

https://developer.github.com/v3/repos/downloads/#list-downloads-for-a-repository
*/
type ReposListDownloadsReq struct {
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListDownloadsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/downloads", r.Owner, r.Repo)
}

func (r *ReposListDownloadsReq) method() string {
	return "GET"
}

func (r *ReposListDownloadsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListDownloadsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListDownloadsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListDownloadsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListDownloadsResponseBody200 is a response body for repos/list-downloads

API documentation: https://developer.github.com/v3/repos/downloads/#list-downloads-for-a-repository
*/
type ReposListDownloadsResponseBody200 []struct {
	components.Download
}

/*
ReposListForAuthenticatedUserReq builds requests for "repos/list-for-authenticated-user"

List repositories for the authenticated user.

  GET /user/repos

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
type ReposListForAuthenticatedUserReq struct {

	// Can be one of `all`, `public`, or `private`.
	Visibility *string

	/*
	Comma-separated list of values. Can include:
	\* `owner`: Repositories that are owned by the authenticated user.
	\* `collaborator`: Repositories that the user has been added to as a
	collaborator.
	\* `organization_member`: Repositories that the user has access to through being
	a member of an organization. This includes every repository on every team that
	the user is on.
	*/
	Affiliation *string

	/*
	Can be one of `all`, `owner`, `public`, `private`, `member`. Default: `all`

	Will cause a `422` error if used in the same request as **visibility** or
	**affiliation**. Will cause a `422` error if used in the same request as
	**visibility** or **affiliation**.
	*/
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/repos")
}

func (r *ReposListForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ReposListForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Visibility != nil {
		query.Set("visibility", *r.Visibility)
	}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListForAuthenticatedUserReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListForOrgReq builds requests for "repos/list-for-org"

List organization repositories.

  GET /orgs/{org}/repos

https://developer.github.com/v3/repos/#list-organization-repositories
*/
type ReposListForOrgReq struct {
	Org string

	/*
	Specifies the types of repositories you want returned. Can be one of `all`,
	`public`, `private`, `forks`, `sources`, `member`, `internal`. Default: `all`.
	If your organization is associated with an enterprise account using GitHub
	Enterprise Cloud or GitHub Enterprise Server 2.20+, `type` can also be
	`internal`.
	*/
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: when using `full_name`: `asc`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

func (r *ReposListForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/repos", r.Org)
}

func (r *ReposListForOrgReq) method() string {
	return "GET"
}

func (r *ReposListForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"baptiste": r.BaptistePreview,
		"nebula":   r.NebulaPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListForOrgReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListForOrgResponseBody200 is a response body for repos/list-for-org

API documentation: https://developer.github.com/v3/repos/#list-organization-repositories
*/
type ReposListForOrgResponseBody200 []struct {
	components.MinimalRepository
}

/*
ReposListForUserReq builds requests for "repos/list-for-user"

List repositories for a user.

  GET /users/{username}/repos

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
type ReposListForUserReq struct {
	Username string

	// Can be one of `all`, `owner`, `member`.
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool
}

func (r *ReposListForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/repos", r.Username)
}

func (r *ReposListForUserReq) method() string {
	return "GET"
}

func (r *ReposListForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"nebula": r.NebulaPreview}
	if allPreviews {
		previewVals["nebula"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListForUserReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListForksReq builds requests for "repos/list-forks"

List forks.

  GET /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#list-forks
*/
type ReposListForksReq struct {
	Owner string
	Repo  string

	// The sort order. Can be either `newest`, `oldest`, or `stargazers`.
	Sort *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListForksReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/forks", r.Owner, r.Repo)
}

func (r *ReposListForksReq) method() string {
	return "GET"
}

func (r *ReposListForksReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListForksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListForksReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListForksReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListForksResponseBody200 is a response body for repos/list-forks

API documentation: https://developer.github.com/v3/repos/forks/#list-forks
*/
type ReposListForksResponseBody200 []struct {
	components.MinimalRepository
}

/*
ReposListHooksReq builds requests for "repos/list-hooks"

List hooks.

  GET /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#list-hooks
*/
type ReposListHooksReq struct {
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListHooksReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks", r.Owner, r.Repo)
}

func (r *ReposListHooksReq) method() string {
	return "GET"
}

func (r *ReposListHooksReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListHooksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListHooksReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListHooksReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListHooksResponseBody200 is a response body for repos/list-hooks

API documentation: https://developer.github.com/v3/repos/hooks/#list-hooks
*/
type ReposListHooksResponseBody200 []struct {
	components.Hook
}

/*
ReposListInvitationsReq builds requests for "repos/list-invitations"

List invitations for a repository.

  GET /repos/{owner}/{repo}/invitations

https://developer.github.com/v3/repos/invitations/#list-invitations-for-a-repository
*/
type ReposListInvitationsReq struct {
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListInvitationsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/invitations", r.Owner, r.Repo)
}

func (r *ReposListInvitationsReq) method() string {
	return "GET"
}

func (r *ReposListInvitationsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListInvitationsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListInvitationsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListInvitationsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListInvitationsResponseBody200 is a response body for repos/list-invitations

API documentation: https://developer.github.com/v3/repos/invitations/#list-invitations-for-a-repository
*/
type ReposListInvitationsResponseBody200 []struct {
	components.RepositoryInvitation
}

/*
ReposListInvitationsForAuthenticatedUserReq builds requests for "repos/list-invitations-for-authenticated-user"

List a user's repository invitations.

  GET /user/repository_invitations

https://developer.github.com/v3/repos/invitations/#list-a-users-repository-invitations
*/
type ReposListInvitationsForAuthenticatedUserReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListInvitationsForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/repository_invitations")
}

func (r *ReposListInvitationsForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ReposListInvitationsForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListInvitationsForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListInvitationsForAuthenticatedUserReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListInvitationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListInvitationsForAuthenticatedUserResponseBody200 is a response body for repos/list-invitations-for-authenticated-user

API documentation: https://developer.github.com/v3/repos/invitations/#list-a-users-repository-invitations
*/
type ReposListInvitationsForAuthenticatedUserResponseBody200 []struct {
	components.RepositoryInvitation
}

/*
ReposListLanguagesReq builds requests for "repos/list-languages"

List languages.

  GET /repos/{owner}/{repo}/languages

https://developer.github.com/v3/repos/#list-languages
*/
type ReposListLanguagesReq struct {
	Owner string
	Repo  string
}

func (r *ReposListLanguagesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/languages", r.Owner, r.Repo)
}

func (r *ReposListLanguagesReq) method() string {
	return "GET"
}

func (r *ReposListLanguagesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposListLanguagesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListLanguagesReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListLanguagesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListLanguagesResponseBody200 is a response body for repos/list-languages

API documentation: https://developer.github.com/v3/repos/#list-languages
*/
type ReposListLanguagesResponseBody200 struct {
	components.Language
}

/*
ReposListPagesBuildsReq builds requests for "repos/list-pages-builds"

List Pages builds.

  GET /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#list-pages-builds
*/
type ReposListPagesBuildsReq struct {
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListPagesBuildsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages/builds", r.Owner, r.Repo)
}

func (r *ReposListPagesBuildsReq) method() string {
	return "GET"
}

func (r *ReposListPagesBuildsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListPagesBuildsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListPagesBuildsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListPagesBuildsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListPagesBuildsResponseBody200 is a response body for repos/list-pages-builds

API documentation: https://developer.github.com/v3/repos/pages/#list-pages-builds
*/
type ReposListPagesBuildsResponseBody200 []struct {
	components.PageBuild
}

/*
ReposListProtectedBranchRequiredStatusChecksContextsReq builds requests for "repos/list-protected-branch-required-status-checks-contexts"

List required status checks contexts of protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#list-required-status-checks-contexts-of-protected-branch
*/
type ReposListProtectedBranchRequiredStatusChecksContextsReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch)
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) method() string {
	return "GET"
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListProtectedBranchRequiredStatusChecksContextsResponseBody200 is a response body for repos/list-protected-branch-required-status-checks-contexts

API documentation: https://developer.github.com/v3/repos/branches/#list-required-status-checks-contexts-of-protected-branch
*/
type ReposListProtectedBranchRequiredStatusChecksContextsResponseBody200 []string

/*
ReposListPublicReq builds requests for "repos/list-public"

List public repositories.

  GET /repositories

https://developer.github.com/v3/repos/#list-public-repositories
*/
type ReposListPublicReq struct {

	// The integer ID of the last repository that you've seen.
	Since *int64
}

func (r *ReposListPublicReq) urlPath() string {
	return fmt.Sprintf("/repositories")
}

func (r *ReposListPublicReq) method() string {
	return "GET"
}

func (r *ReposListPublicReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", strconv.FormatInt(*r.Since, 10))
	}
	return query
}

func (r *ReposListPublicReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListPublicReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListPublicReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListPublicResponseBody200 is a response body for repos/list-public

API documentation: https://developer.github.com/v3/repos/#list-public-repositories
*/
type ReposListPublicResponseBody200 []struct {
	components.PublicRepository
}

/*
ReposListPullRequestsAssociatedWithCommitReq builds requests for "repos/list-pull-requests-associated-with-commit"

List pull requests associated with commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-commit
*/
type ReposListPullRequestsAssociatedWithCommitReq struct {
	Owner     string
	Repo      string
	CommitSha string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Listing branches or pull requests for a commit in the Commits API is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-04-11-pulls-branches-for-commit/)
	for more details. To access the new endpoints during the preview period, you
	must set this to true.
	*/
	GrootPreview bool
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/pulls", r.Owner, r.Repo, r.CommitSha)
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) method() string {
	return "GET"
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"groot": r.GrootPreview}
	if requiredPreviews {
		previewVals["groot"] = true
	}
	if allPreviews {
		previewVals["groot"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListPullRequestsAssociatedWithCommitReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListPullRequestsAssociatedWithCommitResponseBody200 is a response body for repos/list-pull-requests-associated-with-commit

API documentation: https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-commit
*/
type ReposListPullRequestsAssociatedWithCommitResponseBody200 []struct {
	components.PullRequestSimple
}

/*
ReposListReleasesReq builds requests for "repos/list-releases"

List releases for a repository.

  GET /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#list-releases-for-a-repository
*/
type ReposListReleasesReq struct {
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListReleasesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases", r.Owner, r.Repo)
}

func (r *ReposListReleasesReq) method() string {
	return "GET"
}

func (r *ReposListReleasesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListReleasesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListReleasesReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListReleasesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListReleasesResponseBody200 is a response body for repos/list-releases

API documentation: https://developer.github.com/v3/repos/releases/#list-releases-for-a-repository
*/
type ReposListReleasesResponseBody200 []struct {
	components.Release2
}

/*
ReposListStatusesForRefReq builds requests for "repos/list-statuses-for-ref"

List statuses for a specific ref.

  GET /repos/{owner}/{repo}/commits/{ref}/statuses

https://developer.github.com/v3/repos/statuses/#list-statuses-for-a-specific-ref
*/
type ReposListStatusesForRefReq struct {
	Owner string
	Repo  string
	Ref   string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListStatusesForRefReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/statuses", r.Owner, r.Repo, r.Ref)
}

func (r *ReposListStatusesForRefReq) method() string {
	return "GET"
}

func (r *ReposListStatusesForRefReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListStatusesForRefReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListStatusesForRefReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListStatusesForRefReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListStatusesForRefResponseBody200 is a response body for repos/list-statuses-for-ref

API documentation: https://developer.github.com/v3/repos/statuses/#list-statuses-for-a-specific-ref
*/
type ReposListStatusesForRefResponseBody200 []struct {
	components.Status
}

/*
ReposListTagsReq builds requests for "repos/list-tags"

List tags.

  GET /repos/{owner}/{repo}/tags

https://developer.github.com/v3/repos/#list-tags
*/
type ReposListTagsReq struct {
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListTagsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/tags", r.Owner, r.Repo)
}

func (r *ReposListTagsReq) method() string {
	return "GET"
}

func (r *ReposListTagsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListTagsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListTagsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListTagsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListTagsResponseBody200 is a response body for repos/list-tags

API documentation: https://developer.github.com/v3/repos/#list-tags
*/
type ReposListTagsResponseBody200 []struct {
	components.Tag
}

/*
ReposListTeamsReq builds requests for "repos/list-teams"

List teams.

  GET /repos/{owner}/{repo}/teams

https://developer.github.com/v3/repos/#list-teams
*/
type ReposListTeamsReq struct {
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListTeamsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/teams", r.Owner, r.Repo)
}

func (r *ReposListTeamsReq) method() string {
	return "GET"
}

func (r *ReposListTeamsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListTeamsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListTeamsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposListTeamsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposListTeamsResponseBody200 is a response body for repos/list-teams

API documentation: https://developer.github.com/v3/repos/#list-teams
*/
type ReposListTeamsResponseBody200 []struct {
	components.Team
}

/*
ReposMergeReq builds requests for "repos/merge"

Perform a merge.

  POST /repos/{owner}/{repo}/merges

https://developer.github.com/v3/repos/merging/#perform-a-merge
*/
type ReposMergeReq struct {
	Owner       string
	Repo        string
	RequestBody ReposMergeReqBody
}

func (r *ReposMergeReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/merges", r.Owner, r.Repo)
}

func (r *ReposMergeReq) method() string {
	return "POST"
}

func (r *ReposMergeReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposMergeReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposMergeReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposMergeReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposMergeReqBody is a request body for repos/merge

API documentation: https://developer.github.com/v3/repos/merging/#perform-a-merge
*/
type ReposMergeReqBody struct {

	// The name of the base branch that the head will be merged into.
	Base *string `json:"base"`

	/*
	   Commit message to use for the merge commit. If omitted, a default message will
	   be used.
	*/
	CommitMessage *string `json:"commit_message,omitempty"`

	// The head to merge. This can be a branch name or a commit SHA1.
	Head *string `json:"head"`
}

/*
ReposMergeResponseBody201 is a response body for repos/merge

API documentation: https://developer.github.com/v3/repos/merging/#perform-a-merge
*/
type ReposMergeResponseBody201 struct {
	components.SimpleCommit2
}

/*
ReposPingHookReq builds requests for "repos/ping-hook"

Ping a hook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/pings

https://developer.github.com/v3/repos/hooks/#ping-a-hook
*/
type ReposPingHookReq struct {
	Owner  string
	Repo   string
	HookId int64
}

func (r *ReposPingHookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v/pings", r.Owner, r.Repo, r.HookId)
}

func (r *ReposPingHookReq) method() string {
	return "POST"
}

func (r *ReposPingHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposPingHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposPingHookReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposPingHookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRemoveBranchProtectionReq builds requests for "repos/remove-branch-protection"

Remove branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#remove-branch-protection
*/
type ReposRemoveBranchProtectionReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposRemoveBranchProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveBranchProtectionReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveBranchProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveBranchProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveBranchProtectionReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposRemoveBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRemoveCollaboratorReq builds requests for "repos/remove-collaborator"

Remove user as a collaborator.

  DELETE /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#remove-user-as-a-collaborator
*/
type ReposRemoveCollaboratorReq struct {
	Owner    string
	Repo     string
	Username string
}

func (r *ReposRemoveCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username)
}

func (r *ReposRemoveCollaboratorReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveCollaboratorReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposRemoveCollaboratorReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRemoveDeployKeyReq builds requests for "repos/remove-deploy-key"

Remove a deploy key.

  DELETE /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#remove-a-deploy-key
*/
type ReposRemoveDeployKeyReq struct {
	Owner string
	Repo  string
	KeyId int64
}

func (r *ReposRemoveDeployKeyReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/keys/%v", r.Owner, r.Repo, r.KeyId)
}

func (r *ReposRemoveDeployKeyReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveDeployKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveDeployKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveDeployKeyReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposRemoveDeployKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRemoveProtectedBranchAdminEnforcementReq builds requests for "repos/remove-protected-branch-admin-enforcement"

Remove admin enforcement of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#remove-admin-enforcement-of-protected-branch
*/
type ReposRemoveProtectedBranchAdminEnforcementReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposRemoveProtectedBranchAdminEnforcementReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRemoveProtectedBranchAppRestrictionsReq builds requests for "repos/remove-protected-branch-app-restrictions"

Remove app restrictions of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#remove-app-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchAppRestrictionsReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposRemoveProtectedBranchAppRestrictionsReqBody
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposRemoveProtectedBranchAppRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRemoveProtectedBranchAppRestrictionsReqBody is a request body for repos/remove-protected-branch-app-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#remove-app-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchAppRestrictionsReqBody []string

/*
ReposRemoveProtectedBranchAppRestrictionsResponseBody200 is a response body for repos/remove-protected-branch-app-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#remove-app-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchAppRestrictionsResponseBody200 []struct {
	components.Integration2
}

/*
ReposRemoveProtectedBranchPullRequestReviewEnforcementReq builds requests for "repos/remove-protected-branch-pull-request-review-enforcement"

Remove pull request review enforcement of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#remove-pull-request-review-enforcement-of-protected-branch
*/
type ReposRemoveProtectedBranchPullRequestReviewEnforcementReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRemoveProtectedBranchRequiredSignaturesReq builds requests for "repos/remove-protected-branch-required-signatures"

Remove required signatures of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#remove-required-signatures-of-protected-branch
*/
type ReposRemoveProtectedBranchRequiredSignaturesReq struct {
	Owner  string
	Repo   string
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"zzzax": r.ZzzaxPreview}
	if requiredPreviews {
		previewVals["zzzax"] = true
	}
	if allPreviews {
		previewVals["zzzax"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRemoveProtectedBranchRequiredStatusChecksReq builds requests for "repos/remove-protected-branch-required-status-checks"

Remove required status checks of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#remove-required-status-checks-of-protected-branch
*/
type ReposRemoveProtectedBranchRequiredStatusChecksReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRemoveProtectedBranchRequiredStatusChecksContextsReq builds requests for "repos/remove-protected-branch-required-status-checks-contexts"

Remove required status checks contexts of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#remove-required-status-checks-contexts-of-protected-branch
*/
type ReposRemoveProtectedBranchRequiredStatusChecksContextsReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposRemoveProtectedBranchRequiredStatusChecksContextsReqBody
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRemoveProtectedBranchRequiredStatusChecksContextsReqBody is a request body for repos/remove-protected-branch-required-status-checks-contexts

API documentation: https://developer.github.com/v3/repos/branches/#remove-required-status-checks-contexts-of-protected-branch
*/
type ReposRemoveProtectedBranchRequiredStatusChecksContextsReqBody []string

/*
ReposRemoveProtectedBranchRequiredStatusChecksContextsResponseBody200 is a response body for repos/remove-protected-branch-required-status-checks-contexts

API documentation: https://developer.github.com/v3/repos/branches/#remove-required-status-checks-contexts-of-protected-branch
*/
type ReposRemoveProtectedBranchRequiredStatusChecksContextsResponseBody200 []string

/*
ReposRemoveProtectedBranchRestrictionsReq builds requests for "repos/remove-protected-branch-restrictions"

Remove restrictions of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#remove-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchRestrictionsReq struct {
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposRemoveProtectedBranchRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRemoveProtectedBranchTeamRestrictionsReq builds requests for "repos/remove-protected-branch-team-restrictions"

Remove team restrictions of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#remove-team-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchTeamRestrictionsReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposRemoveProtectedBranchTeamRestrictionsReqBody
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRemoveProtectedBranchTeamRestrictionsReqBody is a request body for repos/remove-protected-branch-team-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#remove-team-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchTeamRestrictionsReqBody []string

/*
ReposRemoveProtectedBranchTeamRestrictionsResponseBody200 is a response body for repos/remove-protected-branch-team-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#remove-team-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchTeamRestrictionsResponseBody200 []struct {
	components.Team
}

/*
ReposRemoveProtectedBranchUserRestrictionsReq builds requests for "repos/remove-protected-branch-user-restrictions"

Remove user restrictions of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#remove-user-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchUserRestrictionsReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposRemoveProtectedBranchUserRestrictionsReqBody
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposRemoveProtectedBranchUserRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRemoveProtectedBranchUserRestrictionsReqBody is a request body for repos/remove-protected-branch-user-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#remove-user-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchUserRestrictionsReqBody []string

/*
ReposRemoveProtectedBranchUserRestrictionsResponseBody200 is a response body for repos/remove-protected-branch-user-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#remove-user-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchUserRestrictionsResponseBody200 []struct {
	components.SimpleUser
}

/*
ReposReplaceAllTopicsReq builds requests for "repos/replace-all-topics"

Replace all repository topics.

  PUT /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsReq struct {
	Owner       string
	Repo        string
	RequestBody ReposReplaceAllTopicsReqBody

	/*
	Repository topics on GitHub are currently available for developers to preview.
	To use this endpoint, you must set this to true.
	*/
	MercyPreview bool
}

func (r *ReposReplaceAllTopicsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/topics", r.Owner, r.Repo)
}

func (r *ReposReplaceAllTopicsReq) method() string {
	return "PUT"
}

func (r *ReposReplaceAllTopicsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposReplaceAllTopicsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"mercy": r.MercyPreview}
	if requiredPreviews {
		previewVals["mercy"] = true
	}
	if allPreviews {
		previewVals["mercy"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposReplaceAllTopicsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposReplaceAllTopicsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposReplaceAllTopicsReqBody is a request body for repos/replace-all-topics

API documentation: https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsReqBody struct {

	/*
	   An array of topics to add to the repository. Pass one or more topics to
	   _replace_ the set of existing topics. Send an empty array (`[]`) to clear all
	   topics from the repository. **Note:** Topic `names` cannot contain uppercase
	   letters.
	*/
	Names []string `json:"names"`
}

/*
ReposReplaceAllTopicsResponseBody200 is a response body for repos/replace-all-topics

API documentation: https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsResponseBody200 struct {
	components.Topic
}

/*
ReposReplaceProtectedBranchAppRestrictionsReq builds requests for "repos/replace-protected-branch-app-restrictions"

Replace app restrictions of protected branch.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#replace-app-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchAppRestrictionsReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposReplaceProtectedBranchAppRestrictionsReqBody
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch)
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) method() string {
	return "PUT"
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposReplaceProtectedBranchAppRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposReplaceProtectedBranchAppRestrictionsReqBody is a request body for repos/replace-protected-branch-app-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#replace-app-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchAppRestrictionsReqBody []string

/*
ReposReplaceProtectedBranchAppRestrictionsResponseBody200 is a response body for repos/replace-protected-branch-app-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#replace-app-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchAppRestrictionsResponseBody200 []struct {
	components.Integration2
}

/*
ReposReplaceProtectedBranchRequiredStatusChecksContextsReq builds requests for "repos/replace-protected-branch-required-status-checks-contexts"

Replace required status checks contexts of protected branch.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#replace-required-status-checks-contexts-of-protected-branch
*/
type ReposReplaceProtectedBranchRequiredStatusChecksContextsReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposReplaceProtectedBranchRequiredStatusChecksContextsReqBody
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch)
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) method() string {
	return "PUT"
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposReplaceProtectedBranchRequiredStatusChecksContextsReqBody is a request body for repos/replace-protected-branch-required-status-checks-contexts

API documentation: https://developer.github.com/v3/repos/branches/#replace-required-status-checks-contexts-of-protected-branch
*/
type ReposReplaceProtectedBranchRequiredStatusChecksContextsReqBody []string

/*
ReposReplaceProtectedBranchRequiredStatusChecksContextsResponseBody200 is a response body for repos/replace-protected-branch-required-status-checks-contexts

API documentation: https://developer.github.com/v3/repos/branches/#replace-required-status-checks-contexts-of-protected-branch
*/
type ReposReplaceProtectedBranchRequiredStatusChecksContextsResponseBody200 []string

/*
ReposReplaceProtectedBranchTeamRestrictionsReq builds requests for "repos/replace-protected-branch-team-restrictions"

Replace team restrictions of protected branch.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#replace-team-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchTeamRestrictionsReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposReplaceProtectedBranchTeamRestrictionsReqBody
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch)
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) method() string {
	return "PUT"
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposReplaceProtectedBranchTeamRestrictionsReqBody is a request body for repos/replace-protected-branch-team-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#replace-team-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchTeamRestrictionsReqBody []string

/*
ReposReplaceProtectedBranchTeamRestrictionsResponseBody200 is a response body for repos/replace-protected-branch-team-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#replace-team-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchTeamRestrictionsResponseBody200 []struct {
	components.Team
}

/*
ReposReplaceProtectedBranchUserRestrictionsReq builds requests for "repos/replace-protected-branch-user-restrictions"

Replace user restrictions of protected branch.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#replace-user-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchUserRestrictionsReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposReplaceProtectedBranchUserRestrictionsReqBody
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch)
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) method() string {
	return "PUT"
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposReplaceProtectedBranchUserRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposReplaceProtectedBranchUserRestrictionsReqBody is a request body for repos/replace-protected-branch-user-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#replace-user-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchUserRestrictionsReqBody []string

/*
ReposReplaceProtectedBranchUserRestrictionsResponseBody200 is a response body for repos/replace-protected-branch-user-restrictions

API documentation: https://developer.github.com/v3/repos/branches/#replace-user-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchUserRestrictionsResponseBody200 []struct {
	components.SimpleUser
}

/*
ReposRequestPageBuildReq builds requests for "repos/request-page-build"

Request a page build.

  POST /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#request-a-page-build
*/
type ReposRequestPageBuildReq struct {
	Owner string
	Repo  string
}

func (r *ReposRequestPageBuildReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages/builds", r.Owner, r.Repo)
}

func (r *ReposRequestPageBuildReq) method() string {
	return "POST"
}

func (r *ReposRequestPageBuildReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRequestPageBuildReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRequestPageBuildReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposRequestPageBuildReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRequestPageBuildResponseBody200 is a response body for repos/request-page-build

API documentation: https://developer.github.com/v3/repos/pages/#request-a-page-build
*/
type ReposRequestPageBuildResponseBody200 struct {
	components.PageBuildStatus
}

/*
ReposRetrieveCommunityProfileMetricsReq builds requests for "repos/retrieve-community-profile-metrics"

Retrieve community profile metrics.

  GET /repos/{owner}/{repo}/community/profile

https://developer.github.com/v3/repos/community/#retrieve-community-profile-metrics
*/
type ReposRetrieveCommunityProfileMetricsReq struct {
	Owner string
	Repo  string
}

func (r *ReposRetrieveCommunityProfileMetricsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/community/profile", r.Owner, r.Repo)
}

func (r *ReposRetrieveCommunityProfileMetricsReq) method() string {
	return "GET"
}

func (r *ReposRetrieveCommunityProfileMetricsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRetrieveCommunityProfileMetricsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRetrieveCommunityProfileMetricsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposRetrieveCommunityProfileMetricsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposRetrieveCommunityProfileMetricsResponseBody200 is a response body for repos/retrieve-community-profile-metrics

API documentation: https://developer.github.com/v3/repos/community/#retrieve-community-profile-metrics
*/
type ReposRetrieveCommunityProfileMetricsResponseBody200 struct {
	components.CommunityProfile
}

/*
ReposTestPushHookReq builds requests for "repos/test-push-hook"

Test a push hook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/tests

https://developer.github.com/v3/repos/hooks/#test-a-push-hook
*/
type ReposTestPushHookReq struct {
	Owner  string
	Repo   string
	HookId int64
}

func (r *ReposTestPushHookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v/tests", r.Owner, r.Repo, r.HookId)
}

func (r *ReposTestPushHookReq) method() string {
	return "POST"
}

func (r *ReposTestPushHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposTestPushHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposTestPushHookReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposTestPushHookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposTransferReq builds requests for "repos/transfer"

Transfer a repository.

  POST /repos/{owner}/{repo}/transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferReq struct {
	Owner       string
	Repo        string
	RequestBody ReposTransferReqBody
}

func (r *ReposTransferReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/transfer", r.Owner, r.Repo)
}

func (r *ReposTransferReq) method() string {
	return "POST"
}

func (r *ReposTransferReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposTransferReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposTransferReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposTransferReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposTransferReqBody is a request body for repos/transfer

API documentation: https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferReqBody struct {

	/*
	   **Required:** The username or organization name the repository will be
	   transferred to.
	*/
	NewOwner *string `json:"new_owner,omitempty"`

	/*
	   ID of the team or teams to add to the repository. Teams can only be added to
	   organization-owned repositories.
	*/
	TeamIds []int64 `json:"team_ids,omitempty"`
}

/*
ReposTransferResponseBody202 is a response body for repos/transfer

API documentation: https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferResponseBody202 struct {
	components.Repository
}

/*
ReposUpdateReq builds requests for "repos/update"

Update a repository.

  PATCH /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateReq struct {
	Owner       string
	Repo        string
	RequestBody ReposUpdateReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

func (r *ReposUpdateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo)
}

func (r *ReposUpdateReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"baptiste": r.BaptistePreview,
		"nebula":   r.NebulaPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposUpdateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposUpdateReqBody is a request body for repos/update

API documentation: https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateReqBody struct {

	/*
	   Either `true` to allow merging pull requests with a merge commit, or `false` to
	   prevent merging pull requests with merge commits.
	*/
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	/*
	   Either `true` to allow rebase-merging pull requests, or `false` to prevent
	   rebase-merging.
	*/
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	/*
	   Either `true` to allow squash-merging pull requests, or `false` to prevent
	   squash-merging.
	*/
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	/*
	   `true` to archive this repository. **Note**: You cannot unarchive repositories
	   through the API.
	*/
	Archived *bool `json:"archived,omitempty"`

	// Updates the default branch for this repository.
	DefaultBranch *string `json:"default_branch,omitempty"`

	/*
	   Either `true` to allow automatically deleting head branches when pull requests
	   are merged, or `false` to prevent automatic deletion.
	*/
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	// Either `true` to enable issues for this repository or `false` to disable them.
	HasIssues *bool `json:"has_issues,omitempty"`

	/*
	   Either `true` to enable projects for this repository or `false` to disable them.
	   **Note:** If you're creating a repository in an organization that has disabled
	   repository projects, the default is `false`, and if you pass `true`, the API
	   returns an error.
	*/
	HasProjects *bool `json:"has_projects,omitempty"`

	// Either `true` to enable the wiki for this repository or `false` to disable it.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	/*
	   Either `true` to make this repo available as a template repository or `false` to
	   prevent it.
	*/
	IsTemplate *bool `json:"is_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name,omitempty"`

	/*
	   Either `true` to make the repository private or `false` to make it public.
	   Default: `false`.
	   **Note**: You will get a `422` error if the organization restricts [changing
	   repository
	   visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories)
	   to organization owners and a non-owner tries to change the value of private.
	   **Note**: You will get a `422` error if the organization restricts [changing
	   repository
	   visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories)
	   to organization owners and a non-owner tries to change the value of private.
	*/
	Private *bool `json:"private,omitempty"`

	/*
	   Can be `public` or `private`. If your organization is associated with an
	   enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server
	   2.20+, `visibility` can also be `internal`. The `visibility` parameter overrides
	   the `private` parameter when you use both along with the `nebula-preview`
	   preview header.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ReposUpdateResponseBody200 is a response body for repos/update

API documentation: https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateResponseBody200 struct {
	components.FullRepository2
}

/*
ReposUpdateBranchProtectionReq builds requests for "repos/update-branch-protection"

Update branch protection.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposUpdateBranchProtectionReqBody

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

func (r *ReposUpdateBranchProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch)
}

func (r *ReposUpdateBranchProtectionReq) method() string {
	return "PUT"
}

func (r *ReposUpdateBranchProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateBranchProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"luke-cage": r.LukeCagePreview}
	if allPreviews {
		previewVals["luke-cage"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateBranchProtectionReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposUpdateBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

// ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews is a value for ReposUpdateBranchProtectionReqBody's RequiredPullRequestReviews field
type ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews struct {

	/*
	   Set to `true` if you want to automatically dismiss approving reviews when
	   someone pushes a new commit.
	*/
	DismissStaleReviews *bool `json:"dismiss_stale_reviews,omitempty"`

	/*
	   Specify which users and teams can dismiss pull request reviews. Pass an empty
	   `dismissal_restrictions` object to disable. User and team
	   `dismissal_restrictions` are only available for organization-owned repositories.
	   Omit this parameter for personal repositories.
	*/
	DismissalRestrictions *ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions `json:"dismissal_restrictions,omitempty"`

	/*
	   Blocks merging pull requests until [code
	   owners](https://help.github.com/articles/about-code-owners/) review them.
	*/
	RequireCodeOwnerReviews *bool `json:"require_code_owner_reviews,omitempty"`

	/*
	   Specify the number of reviewers required to approve pull requests. Use a number
	   between 1 and 6.
	*/
	RequiredApprovingReviewCount *int64 `json:"required_approving_review_count,omitempty"`
}

// ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions is a value for ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews's DismissalRestrictions field
type ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions struct {

	// The list of team `slug`s with dismissal access
	Teams []string `json:"teams,omitempty"`

	// The list of user `login`s with dismissal access
	Users []string `json:"users,omitempty"`
}

// ReposUpdateBranchProtectionReqBodyRequiredStatusChecks is a value for ReposUpdateBranchProtectionReqBody's RequiredStatusChecks field
type ReposUpdateBranchProtectionReqBodyRequiredStatusChecks struct {

	// The list of status checks to require in order to merge into this branch
	Contexts []string `json:"contexts"`

	// Require branches to be up to date before merging.
	Strict *bool `json:"strict"`
}

// ReposUpdateBranchProtectionReqBodyRestrictions is a value for ReposUpdateBranchProtectionReqBody's Restrictions field
type ReposUpdateBranchProtectionReqBodyRestrictions struct {

	// The list of app `slug`s with push access
	Apps []string `json:"apps,omitempty"`

	// The list of team `slug`s with push access
	Teams []string `json:"teams"`

	// The list of user `login`s with push access
	Users []string `json:"users"`
}

/*
ReposUpdateBranchProtectionReqBody is a request body for repos/update-branch-protection

API documentation: https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionReqBody struct {

	/*
	   Allows deletion of the protected branch by anyone with write access to the
	   repository. Set to `false` to prevent deletion of the protected branch. Default:
	   `false`. For more information, see "[Enabling force pushes to a protected
	   branch](https://help.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)"
	   in the GitHub Help documentation.
	*/
	AllowDeletions *bool `json:"allow_deletions,omitempty"`

	/*
	   Permits force pushes to the protected branch by anyone with write access to the
	   repository. Set to `true` to allow force pushes. Set to `false` or `null` to
	   block force pushes. Default: `false`. For more information, see "[Enabling force
	   pushes to a protected
	   branch](https://help.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)"
	   in the GitHub Help documentation."
	*/
	AllowForcePushes *bool `json:"allow_force_pushes,omitempty"`

	/*
	   Enforce all configured restrictions for administrators. Set to `true` to enforce
	   required status checks for repository administrators. Set to `null` to disable.
	*/
	EnforceAdmins *bool `json:"enforce_admins"`

	/*
	   Enforces a linear commit Git history, which prevents anyone from pushing merge
	   commits to a branch. Set to `true` to enforce a linear commit history. Set to
	   `false` to disable a linear commit Git history. Your repository must allow
	   squash merging or rebase merging before you can enable a linear commit history.
	   Default: `false`. For more information, see "[Requiring a linear commit
	   history](https://help.github.com/github/administering-a-repository/requiring-a-linear-commit-history)"
	   in the GitHub Help documentation.
	*/
	RequiredLinearHistory *bool `json:"required_linear_history,omitempty"`

	/*
	   Require at least one approving review on a pull request, before merging. Set to
	   `null` to disable.
	*/
	RequiredPullRequestReviews *ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews `json:"required_pull_request_reviews"`

	// Require status checks to pass before merging. Set to `null` to disable.
	RequiredStatusChecks *ReposUpdateBranchProtectionReqBodyRequiredStatusChecks `json:"required_status_checks"`

	/*
	   Restrict who can push to the protected branch. User, app, and team
	   `restrictions` are only available for organization-owned repositories. Set to
	   `null` to disable.
	*/
	Restrictions *ReposUpdateBranchProtectionReqBodyRestrictions `json:"restrictions"`
}

/*
ReposUpdateBranchProtectionResponseBody200 is a response body for repos/update-branch-protection

API documentation: https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionResponseBody200 struct {
	components.BranchProtection
}

/*
ReposUpdateCommitCommentReq builds requests for "repos/update-commit-comment"

Update a commit comment.

  PATCH /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentReq struct {
	Owner       string
	Repo        string
	CommentId   int64
	RequestBody ReposUpdateCommitCommentReqBody
}

func (r *ReposUpdateCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *ReposUpdateCommitCommentReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateCommitCommentReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposUpdateCommitCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposUpdateCommitCommentReqBody is a request body for repos/update-commit-comment

API documentation: https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentReqBody struct {

	// The contents of the comment
	Body *string `json:"body"`
}

/*
ReposUpdateCommitCommentResponseBody200 is a response body for repos/update-commit-comment

API documentation: https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentResponseBody200 struct {
	components.CommitComment
}

/*
ReposUpdateHookReq builds requests for "repos/update-hook"

Edit a hook.

  PATCH /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#edit-a-hook
*/
type ReposUpdateHookReq struct {
	Owner       string
	Repo        string
	HookId      int64
	RequestBody ReposUpdateHookReqBody
}

func (r *ReposUpdateHookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId)
}

func (r *ReposUpdateHookReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateHookReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposUpdateHookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

// ReposUpdateHookReqBodyConfig is a value for ReposUpdateHookReqBody's Config field
type ReposUpdateHookReqBodyConfig struct {

	/*
	   The media type used to serialize the payloads. Supported values include `json`
	   and `form`. The default is `form`.
	*/
	ContentType *string `json:"content_type,omitempty"`

	/*
	   Determines whether the SSL certificate of the host for `url` will be verified
	   when delivering payloads. Supported values include `0` (verification is
	   performed) and `1` (verification is not performed). The default is `0`. **We
	   strongly recommend not setting this to `1` as you are subject to
	   man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	   If provided, the `secret` will be used as the `key` to generate the HMAC hex
	   digest value in the
	   [`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	   header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
ReposUpdateHookReqBody is a request body for repos/update-hook

API documentation: https://developer.github.com/v3/repos/hooks/#edit-a-hook
*/
type ReposUpdateHookReqBody struct {

	/*
	   Determines if notifications are sent when the webhook is triggered. Set to
	   `true` to send notifications.
	*/
	Active *bool `json:"active,omitempty"`

	/*
	   Determines a list of events to be added to the list of events that the Hook
	   triggers for.
	*/
	AddEvents []string `json:"add_events,omitempty"`

	/*
	   Key/value pairs to provide settings for this webhook. [These are defined
	   below](https://developer.github.com/v3/repos/hooks/#create-hook-config-params).
	*/
	Config *ReposUpdateHookReqBodyConfig `json:"config,omitempty"`

	/*
	   Determines what [events](https://developer.github.com/webhooks/event-payloads)
	   the hook is triggered for. This replaces the entire array of events.
	*/
	Events []string `json:"events,omitempty"`

	/*
	   Determines a list of events to be removed from the list of events that the Hook
	   triggers for.
	*/
	RemoveEvents []string `json:"remove_events,omitempty"`
}

/*
ReposUpdateHookResponseBody200 is a response body for repos/update-hook

API documentation: https://developer.github.com/v3/repos/hooks/#edit-a-hook
*/
type ReposUpdateHookResponseBody200 struct {
	components.Hook
}

/*
ReposUpdateInformationAboutPagesSiteReq builds requests for "repos/update-information-about-pages-site"

Update information about a Pages site.

  PUT /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#update-information-about-a-pages-site
*/
type ReposUpdateInformationAboutPagesSiteReq struct {
	Owner       string
	Repo        string
	RequestBody ReposUpdateInformationAboutPagesSiteReqBody
}

func (r *ReposUpdateInformationAboutPagesSiteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo)
}

func (r *ReposUpdateInformationAboutPagesSiteReq) method() string {
	return "PUT"
}

func (r *ReposUpdateInformationAboutPagesSiteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateInformationAboutPagesSiteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateInformationAboutPagesSiteReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposUpdateInformationAboutPagesSiteReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposUpdateInformationAboutPagesSiteReqBody is a request body for repos/update-information-about-pages-site

API documentation: https://developer.github.com/v3/repos/pages/#update-information-about-a-pages-site
*/
type ReposUpdateInformationAboutPagesSiteReqBody struct {

	/*
	   Specify a custom domain for the repository. Sending a `null` value will remove
	   the custom domain. For more about custom domains, see "[Using a custom domain
	   with GitHub
	   Pages](https://help.github.com/articles/using-a-custom-domain-with-github-pages/)."
	*/
	Cname *string `json:"cname,omitempty"`

	/*
	   Update the source for the repository. Must include the branch name, and may
	   optionally specify the subdirectory `/docs`. Possible values are `"gh-pages"`,
	   `"master"`, and `"master /docs"`.
	*/
	Source *string `json:"source,omitempty"`
}

/*
ReposUpdateInvitationReq builds requests for "repos/update-invitation"

Update a repository invitation.

  PATCH /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationReq struct {
	Owner        string
	Repo         string
	InvitationId int64
	RequestBody  ReposUpdateInvitationReqBody
}

func (r *ReposUpdateInvitationReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/invitations/%v", r.Owner, r.Repo, r.InvitationId)
}

func (r *ReposUpdateInvitationReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateInvitationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateInvitationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateInvitationReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposUpdateInvitationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposUpdateInvitationReqBody is a request body for repos/update-invitation

API documentation: https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationReqBody struct {

	/*
	   The permissions that the associated user will have on the repository. Valid
	   values are `read`, `write`, `maintain`, `triage`, and `admin`.
	*/
	Permissions *string `json:"permissions,omitempty"`
}

/*
ReposUpdateInvitationResponseBody200 is a response body for repos/update-invitation

API documentation: https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationResponseBody200 struct {
	components.RepositoryInvitation
}

/*
ReposUpdateProtectedBranchPullRequestReviewEnforcementReq builds requests for "repos/update-protected-branch-pull-request-review-enforcement"

Update pull request review enforcement of protected branch.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#update-pull-request-review-enforcement-of-protected-branch
*/
type ReposUpdateProtectedBranchPullRequestReviewEnforcementReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBody

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch)
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"luke-cage": r.LukeCagePreview}
	if allPreviews {
		previewVals["luke-cage"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

// ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBodyDismissalRestrictions is a value for ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBody's DismissalRestrictions field
type ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBodyDismissalRestrictions struct {

	// The list of team `slug`s with dismissal access
	Teams []string `json:"teams,omitempty"`

	// The list of user `login`s with dismissal access
	Users []string `json:"users,omitempty"`
}

/*
ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBody is a request body for repos/update-protected-branch-pull-request-review-enforcement

API documentation: https://developer.github.com/v3/repos/branches/#update-pull-request-review-enforcement-of-protected-branch
*/
type ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBody struct {

	/*
	   Set to `true` if you want to automatically dismiss approving reviews when
	   someone pushes a new commit.
	*/
	DismissStaleReviews *bool `json:"dismiss_stale_reviews,omitempty"`

	/*
	   Specify which users and teams can dismiss pull request reviews. Pass an empty
	   `dismissal_restrictions` object to disable. User and team
	   `dismissal_restrictions` are only available for organization-owned repositories.
	   Omit this parameter for personal repositories.
	*/
	DismissalRestrictions *ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBodyDismissalRestrictions `json:"dismissal_restrictions,omitempty"`

	/*
	   Blocks merging pull requests until [code
	   owners](https://help.github.com/articles/about-code-owners/) have reviewed.
	*/
	RequireCodeOwnerReviews *bool `json:"require_code_owner_reviews,omitempty"`

	/*
	   Specifies the number of reviewers required to approve pull requests. Use a
	   number between 1 and 6.
	*/
	RequiredApprovingReviewCount *int64 `json:"required_approving_review_count,omitempty"`
}

/*
ReposUpdateProtectedBranchPullRequestReviewEnforcementResponseBody200 is a response body for repos/update-protected-branch-pull-request-review-enforcement

API documentation: https://developer.github.com/v3/repos/branches/#update-pull-request-review-enforcement-of-protected-branch
*/
type ReposUpdateProtectedBranchPullRequestReviewEnforcementResponseBody200 struct {
	components.ProtectedBranchPullRequestReview
}

/*
ReposUpdateProtectedBranchRequiredStatusChecksReq builds requests for "repos/update-protected-branch-required-status-checks"

Update required status checks of protected branch.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#update-required-status-checks-of-protected-branch
*/
type ReposUpdateProtectedBranchRequiredStatusChecksReq struct {
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposUpdateProtectedBranchRequiredStatusChecksReqBody
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch)
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposUpdateProtectedBranchRequiredStatusChecksReqBody is a request body for repos/update-protected-branch-required-status-checks

API documentation: https://developer.github.com/v3/repos/branches/#update-required-status-checks-of-protected-branch
*/
type ReposUpdateProtectedBranchRequiredStatusChecksReqBody struct {

	// The list of status checks to require in order to merge into this branch
	Contexts []string `json:"contexts,omitempty"`

	// Require branches to be up to date before merging.
	Strict *bool `json:"strict,omitempty"`
}

/*
ReposUpdateProtectedBranchRequiredStatusChecksResponseBody200 is a response body for repos/update-protected-branch-required-status-checks

API documentation: https://developer.github.com/v3/repos/branches/#update-required-status-checks-of-protected-branch
*/
type ReposUpdateProtectedBranchRequiredStatusChecksResponseBody200 struct {
	components.StatusCheckPolicy
}

/*
ReposUpdateReleaseReq builds requests for "repos/update-release"

Edit a release.

  PATCH /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#edit-a-release
*/
type ReposUpdateReleaseReq struct {
	Owner       string
	Repo        string
	ReleaseId   int64
	RequestBody ReposUpdateReleaseReqBody
}

func (r *ReposUpdateReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposUpdateReleaseReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateReleaseReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposUpdateReleaseReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposUpdateReleaseReqBody is a request body for repos/update-release

API documentation: https://developer.github.com/v3/repos/releases/#edit-a-release
*/
type ReposUpdateReleaseReqBody struct {

	// Text describing the contents of the tag.
	Body *string `json:"body,omitempty"`

	// `true` makes the release a draft, and `false` publishes the release.
	Draft *bool `json:"draft,omitempty"`

	// The name of the release.
	Name *string `json:"name,omitempty"`

	/*
	   `true` to identify the release as a prerelease, `false` to identify the release
	   as a full release.
	*/
	Prerelease *bool `json:"prerelease,omitempty"`

	// The name of the tag.
	TagName *string `json:"tag_name,omitempty"`

	/*
	   Specifies the commitish value that determines where the Git tag is created from.
	   Can be any branch or commit SHA. Unused if the Git tag already exists. Default:
	   the repository's default branch (usually `master`).
	*/
	TargetCommitish *string `json:"target_commitish,omitempty"`
}

/*
ReposUpdateReleaseResponseBody200 is a response body for repos/update-release

API documentation: https://developer.github.com/v3/repos/releases/#edit-a-release
*/
type ReposUpdateReleaseResponseBody200 struct {
	components.Release2
}

/*
ReposUpdateReleaseAssetReq builds requests for "repos/update-release-asset"

Edit a release asset.

  PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#edit-a-release-asset
*/
type ReposUpdateReleaseAssetReq struct {
	Owner       string
	Repo        string
	AssetId     int64
	RequestBody ReposUpdateReleaseAssetReqBody
}

func (r *ReposUpdateReleaseAssetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId)
}

func (r *ReposUpdateReleaseAssetReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateReleaseAssetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateReleaseAssetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateReleaseAssetReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *ReposUpdateReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposUpdateReleaseAssetReqBody is a request body for repos/update-release-asset

API documentation: https://developer.github.com/v3/repos/releases/#edit-a-release-asset
*/
type ReposUpdateReleaseAssetReqBody struct {

	// An alternate short description of the asset. Used in place of the filename.
	Label *string `json:"label,omitempty"`

	// The file name of the asset.
	Name *string `json:"name,omitempty"`
}

/*
ReposUpdateReleaseAssetResponseBody200 is a response body for repos/update-release-asset

API documentation: https://developer.github.com/v3/repos/releases/#edit-a-release-asset
*/
type ReposUpdateReleaseAssetResponseBody200 struct {
	components.ReleaseAsset
}

/*
ReposUploadReleaseAssetReq builds requests for "repos/upload-release-asset"

Upload a release asset.

  POST /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
type ReposUploadReleaseAssetReq struct {

	// owner parameter
	Owner string

	// repo parameter
	Repo string

	// release_id parameter
	ReleaseId int64

	// name parameter
	Name *string

	// label parameter
	Label *string

	/*
	Size of the asset in bytes. Most libraries will calculate the header
	automatically
	*/
	ContentLengthHeader *string

	/*
	Media Type of the asset. For a list of media types, see
	https://www.iana.org/assignments/media-types/media-types.xhtml
	*/
	ContentTypeHeader *string
}

func (r *ReposUploadReleaseAssetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v/assets", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposUploadReleaseAssetReq) method() string {
	return "POST"
}

func (r *ReposUploadReleaseAssetReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Name != nil {
		query.Set("name", *r.Name)
	}
	if r.Label != nil {
		query.Set("label", *r.Label)
	}
	return query
}

func (r *ReposUploadReleaseAssetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"content-length": r.ContentLengthHeader,
		"content-type":   r.ContentTypeHeader,
	}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUploadReleaseAssetReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *ReposUploadReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
ReposUploadReleaseAssetResponseBody201 is a response body for repos/upload-release-asset

API documentation: https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
type ReposUploadReleaseAssetResponseBody201 struct {
	components.ReleaseAsset
}
