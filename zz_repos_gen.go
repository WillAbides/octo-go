// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"io"
	"net/http"
	"net/url"
	"strconv"
)

/*
ReposAcceptInvitation performs requests for "repos/accept-invitation"

Accept a repository invitation.

  PATCH /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
func (c *Client) ReposAcceptInvitation(ctx context.Context, req *ReposAcceptInvitationReq, opt ...RequestOption) (*ReposAcceptInvitationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposAcceptInvitationResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAcceptInvitationReq is request data for Client.ReposAcceptInvitation

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
type ReposAcceptInvitationReq struct {
	_url         string
	InvitationId int64
}

func (r *ReposAcceptInvitationReq) url() string {
	return r._url
}

func (r *ReposAcceptInvitationReq) urlPath() string {
	return fmt.Sprintf("/user/repository_invitations/%v", r.InvitationId)
}

func (r *ReposAcceptInvitationReq) method() string {
	return "PATCH"
}

func (r *ReposAcceptInvitationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAcceptInvitationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAcceptInvitationReq) body() interface{} {
	return nil
}

func (r *ReposAcceptInvitationReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposAcceptInvitationReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposAcceptInvitationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposAcceptInvitationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAcceptInvitationReq) Rel(link RelName, resp *ReposAcceptInvitationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAcceptInvitationResponse is a response for ReposAcceptInvitation

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
type ReposAcceptInvitationResponse struct {
	response
	request *ReposAcceptInvitationReq
}

/*
ReposAddCollaborator performs requests for "repos/add-collaborator"

Add user as a collaborator.

  PUT /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#add-user-as-a-collaborator
*/
func (c *Client) ReposAddCollaborator(ctx context.Context, req *ReposAddCollaboratorReq, opt ...RequestOption) (*ReposAddCollaboratorResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposAddCollaboratorResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposAddCollaboratorResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddCollaboratorReq is request data for Client.ReposAddCollaborator

https://developer.github.com/v3/repos/collaborators/#add-user-as-a-collaborator
*/
type ReposAddCollaboratorReq struct {
	_url        string
	Owner       string
	Repo        string
	Username    string
	RequestBody ReposAddCollaboratorReqBody
}

func (r *ReposAddCollaboratorReq) url() string {
	return r._url
}

func (r *ReposAddCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username)
}

func (r *ReposAddCollaboratorReq) method() string {
	return "PUT"
}

func (r *ReposAddCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddCollaboratorReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposAddCollaboratorReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposAddCollaboratorReq) validStatuses() []int {
	return []int{201, 204}
}

func (r *ReposAddCollaboratorReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposAddCollaboratorReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddCollaboratorReq) Rel(link RelName, resp *ReposAddCollaboratorResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddCollaboratorReqBody is a request body for repos/add-collaborator

https://developer.github.com/v3/repos/collaborators/#add-user-as-a-collaborator
*/
type ReposAddCollaboratorReqBody struct {

	/*
	   The permission to grant the collaborator. **Only valid on organization-owned
	   repositories.** Can be one of:
	   \* `pull` - can pull, but not push to or administer this repository.
	   \* `push` - can pull and push, but not administer this repository.
	   \* `admin` - can pull, push and administer this repository.
	   \* `maintain` - Recommended for project managers who need to manage the
	   repository without access to sensitive or destructive actions.
	   \* `triage` - Recommended for contributors who need to proactively manage issues
	   and pull requests without write access.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
ReposAddCollaboratorResponseBody is a response body for ReposAddCollaborator

https://developer.github.com/v3/repos/collaborators/#add-user-as-a-collaborator
*/
type ReposAddCollaboratorResponseBody struct {
	components.RepositoryInvitation
}

/*
ReposAddCollaboratorResponse is a response for ReposAddCollaborator

https://developer.github.com/v3/repos/collaborators/#add-user-as-a-collaborator
*/
type ReposAddCollaboratorResponse struct {
	response
	request *ReposAddCollaboratorReq
	Data    *ReposAddCollaboratorResponseBody
}

/*
ReposAddDeployKey performs requests for "repos/add-deploy-key"

Add a new deploy key.

  POST /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#add-a-new-deploy-key
*/
func (c *Client) ReposAddDeployKey(ctx context.Context, req *ReposAddDeployKeyReq, opt ...RequestOption) (*ReposAddDeployKeyResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposAddDeployKeyResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposAddDeployKeyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddDeployKeyReq is request data for Client.ReposAddDeployKey

https://developer.github.com/v3/repos/keys/#add-a-new-deploy-key
*/
type ReposAddDeployKeyReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposAddDeployKeyReqBody
}

func (r *ReposAddDeployKeyReq) url() string {
	return r._url
}

func (r *ReposAddDeployKeyReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/keys", r.Owner, r.Repo)
}

func (r *ReposAddDeployKeyReq) method() string {
	return "POST"
}

func (r *ReposAddDeployKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddDeployKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddDeployKeyReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposAddDeployKeyReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposAddDeployKeyReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposAddDeployKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposAddDeployKeyReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddDeployKeyReq) Rel(link RelName, resp *ReposAddDeployKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddDeployKeyReqBody is a request body for repos/add-deploy-key

https://developer.github.com/v3/repos/keys/#add-a-new-deploy-key
*/
type ReposAddDeployKeyReqBody struct {

	// The contents of the key.
	Key *string `json:"key"`

	/*
	   If `true`, the key will only be able to read repository contents. Otherwise, the
	   key will be able to read and write.

	   Deploy keys with write access can perform the same actions as an organization
	   member with admin access, or a collaborator on a personal repository. For more
	   information, see "[Repository permission levels for an
	   organization](https://help.github.com/articles/repository-permission-levels-for-an-organization/)"
	   and "[Permission levels for a user account
	   repository](https://help.github.com/articles/permission-levels-for-a-user-account-repository/)."
	*/
	ReadOnly *bool `json:"read_only,omitempty"`

	// A name for the key.
	Title *string `json:"title,omitempty"`
}

/*
ReposAddDeployKeyResponseBody is a response body for ReposAddDeployKey

https://developer.github.com/v3/repos/keys/#add-a-new-deploy-key
*/
type ReposAddDeployKeyResponseBody struct {
	components.DeployKey
}

/*
ReposAddDeployKeyResponse is a response for ReposAddDeployKey

https://developer.github.com/v3/repos/keys/#add-a-new-deploy-key
*/
type ReposAddDeployKeyResponse struct {
	response
	request *ReposAddDeployKeyReq
	Data    *ReposAddDeployKeyResponseBody
}

/*
ReposAddProtectedBranchAdminEnforcement performs requests for "repos/add-protected-branch-admin-enforcement"

Add admin enforcement of protected branch.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#add-admin-enforcement-of-protected-branch
*/
func (c *Client) ReposAddProtectedBranchAdminEnforcement(ctx context.Context, req *ReposAddProtectedBranchAdminEnforcementReq, opt ...RequestOption) (*ReposAddProtectedBranchAdminEnforcementResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposAddProtectedBranchAdminEnforcementResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposAddProtectedBranchAdminEnforcementResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddProtectedBranchAdminEnforcementReq is request data for Client.ReposAddProtectedBranchAdminEnforcement

https://developer.github.com/v3/repos/branches/#add-admin-enforcement-of-protected-branch
*/
type ReposAddProtectedBranchAdminEnforcementReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) url() string {
	return r._url
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) method() string {
	return "POST"
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) body() interface{} {
	return nil
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposAddProtectedBranchAdminEnforcementReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposAddProtectedBranchAdminEnforcementReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddProtectedBranchAdminEnforcementReq) Rel(link RelName, resp *ReposAddProtectedBranchAdminEnforcementResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddProtectedBranchAdminEnforcementResponseBody is a response body for ReposAddProtectedBranchAdminEnforcement

https://developer.github.com/v3/repos/branches/#add-admin-enforcement-of-protected-branch
*/
type ReposAddProtectedBranchAdminEnforcementResponseBody struct {
	components.ProtectedBranchAdminEnforced
}

/*
ReposAddProtectedBranchAdminEnforcementResponse is a response for ReposAddProtectedBranchAdminEnforcement

https://developer.github.com/v3/repos/branches/#add-admin-enforcement-of-protected-branch
*/
type ReposAddProtectedBranchAdminEnforcementResponse struct {
	response
	request *ReposAddProtectedBranchAdminEnforcementReq
	Data    *ReposAddProtectedBranchAdminEnforcementResponseBody
}

/*
ReposAddProtectedBranchAppRestrictions performs requests for "repos/add-protected-branch-app-restrictions"

Add app restrictions of protected branch.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#add-app-restrictions-of-protected-branch
*/
func (c *Client) ReposAddProtectedBranchAppRestrictions(ctx context.Context, req *ReposAddProtectedBranchAppRestrictionsReq, opt ...RequestOption) (*ReposAddProtectedBranchAppRestrictionsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposAddProtectedBranchAppRestrictionsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposAddProtectedBranchAppRestrictionsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddProtectedBranchAppRestrictionsReq is request data for Client.ReposAddProtectedBranchAppRestrictions

https://developer.github.com/v3/repos/branches/#add-app-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchAppRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposAddProtectedBranchAppRestrictionsReqBody
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) url() string {
	return r._url
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) method() string {
	return "POST"
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposAddProtectedBranchAppRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposAddProtectedBranchAppRestrictionsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddProtectedBranchAppRestrictionsReq) Rel(link RelName, resp *ReposAddProtectedBranchAppRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddProtectedBranchAppRestrictionsReqBody is a request body for repos/add-protected-branch-app-restrictions

https://developer.github.com/v3/repos/branches/#add-app-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchAppRestrictionsReqBody []string

/*
ReposAddProtectedBranchAppRestrictionsResponseBody is a response body for ReposAddProtectedBranchAppRestrictions

https://developer.github.com/v3/repos/branches/#add-app-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchAppRestrictionsResponseBody []struct {
	components.Integration2
}

/*
ReposAddProtectedBranchAppRestrictionsResponse is a response for ReposAddProtectedBranchAppRestrictions

https://developer.github.com/v3/repos/branches/#add-app-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchAppRestrictionsResponse struct {
	response
	request *ReposAddProtectedBranchAppRestrictionsReq
	Data    *ReposAddProtectedBranchAppRestrictionsResponseBody
}

/*
ReposAddProtectedBranchRequiredSignatures performs requests for "repos/add-protected-branch-required-signatures"

Add required signatures of protected branch.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#add-required-signatures-of-protected-branch
*/
func (c *Client) ReposAddProtectedBranchRequiredSignatures(ctx context.Context, req *ReposAddProtectedBranchRequiredSignaturesReq, opt ...RequestOption) (*ReposAddProtectedBranchRequiredSignaturesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposAddProtectedBranchRequiredSignaturesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposAddProtectedBranchRequiredSignaturesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddProtectedBranchRequiredSignaturesReq is request data for Client.ReposAddProtectedBranchRequiredSignatures

https://developer.github.com/v3/repos/branches/#add-required-signatures-of-protected-branch
*/
type ReposAddProtectedBranchRequiredSignaturesReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) url() string {
	return r._url
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) method() string {
	return "POST"
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"zzzax": r.ZzzaxPreview}
	if requiredPreviews {
		previewVals["zzzax"] = true
	}
	if allPreviews {
		previewVals["zzzax"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) body() interface{} {
	return nil
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposAddProtectedBranchRequiredSignaturesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposAddProtectedBranchRequiredSignaturesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddProtectedBranchRequiredSignaturesReq) Rel(link RelName, resp *ReposAddProtectedBranchRequiredSignaturesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddProtectedBranchRequiredSignaturesResponseBody is a response body for ReposAddProtectedBranchRequiredSignatures

https://developer.github.com/v3/repos/branches/#add-required-signatures-of-protected-branch
*/
type ReposAddProtectedBranchRequiredSignaturesResponseBody struct {
	components.ProtectedBranchAdminEnforced
}

/*
ReposAddProtectedBranchRequiredSignaturesResponse is a response for ReposAddProtectedBranchRequiredSignatures

https://developer.github.com/v3/repos/branches/#add-required-signatures-of-protected-branch
*/
type ReposAddProtectedBranchRequiredSignaturesResponse struct {
	response
	request *ReposAddProtectedBranchRequiredSignaturesReq
	Data    *ReposAddProtectedBranchRequiredSignaturesResponseBody
}

/*
ReposAddProtectedBranchRequiredStatusChecksContexts performs requests for "repos/add-protected-branch-required-status-checks-contexts"

Add required status checks contexts of protected branch.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#add-required-status-checks-contexts-of-protected-branch
*/
func (c *Client) ReposAddProtectedBranchRequiredStatusChecksContexts(ctx context.Context, req *ReposAddProtectedBranchRequiredStatusChecksContextsReq, opt ...RequestOption) (*ReposAddProtectedBranchRequiredStatusChecksContextsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposAddProtectedBranchRequiredStatusChecksContextsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposAddProtectedBranchRequiredStatusChecksContextsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddProtectedBranchRequiredStatusChecksContextsReq is request data for Client.ReposAddProtectedBranchRequiredStatusChecksContexts

https://developer.github.com/v3/repos/branches/#add-required-status-checks-contexts-of-protected-branch
*/
type ReposAddProtectedBranchRequiredStatusChecksContextsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposAddProtectedBranchRequiredStatusChecksContextsReqBody
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) url() string {
	return r._url
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) method() string {
	return "POST"
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddProtectedBranchRequiredStatusChecksContextsReq) Rel(link RelName, resp *ReposAddProtectedBranchRequiredStatusChecksContextsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddProtectedBranchRequiredStatusChecksContextsReqBody is a request body for repos/add-protected-branch-required-status-checks-contexts

https://developer.github.com/v3/repos/branches/#add-required-status-checks-contexts-of-protected-branch
*/
type ReposAddProtectedBranchRequiredStatusChecksContextsReqBody []string

/*
ReposAddProtectedBranchRequiredStatusChecksContextsResponseBody is a response body for ReposAddProtectedBranchRequiredStatusChecksContexts

https://developer.github.com/v3/repos/branches/#add-required-status-checks-contexts-of-protected-branch
*/
type ReposAddProtectedBranchRequiredStatusChecksContextsResponseBody []string

/*
ReposAddProtectedBranchRequiredStatusChecksContextsResponse is a response for ReposAddProtectedBranchRequiredStatusChecksContexts

https://developer.github.com/v3/repos/branches/#add-required-status-checks-contexts-of-protected-branch
*/
type ReposAddProtectedBranchRequiredStatusChecksContextsResponse struct {
	response
	request *ReposAddProtectedBranchRequiredStatusChecksContextsReq
	Data    *ReposAddProtectedBranchRequiredStatusChecksContextsResponseBody
}

/*
ReposAddProtectedBranchTeamRestrictions performs requests for "repos/add-protected-branch-team-restrictions"

Add team restrictions of protected branch.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#add-team-restrictions-of-protected-branch
*/
func (c *Client) ReposAddProtectedBranchTeamRestrictions(ctx context.Context, req *ReposAddProtectedBranchTeamRestrictionsReq, opt ...RequestOption) (*ReposAddProtectedBranchTeamRestrictionsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposAddProtectedBranchTeamRestrictionsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposAddProtectedBranchTeamRestrictionsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddProtectedBranchTeamRestrictionsReq is request data for Client.ReposAddProtectedBranchTeamRestrictions

https://developer.github.com/v3/repos/branches/#add-team-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchTeamRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposAddProtectedBranchTeamRestrictionsReqBody
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) url() string {
	return r._url
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) method() string {
	return "POST"
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposAddProtectedBranchTeamRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposAddProtectedBranchTeamRestrictionsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddProtectedBranchTeamRestrictionsReq) Rel(link RelName, resp *ReposAddProtectedBranchTeamRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddProtectedBranchTeamRestrictionsReqBody is a request body for repos/add-protected-branch-team-restrictions

https://developer.github.com/v3/repos/branches/#add-team-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchTeamRestrictionsReqBody []string

/*
ReposAddProtectedBranchTeamRestrictionsResponseBody is a response body for ReposAddProtectedBranchTeamRestrictions

https://developer.github.com/v3/repos/branches/#add-team-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchTeamRestrictionsResponseBody []struct {
	components.Team
}

/*
ReposAddProtectedBranchTeamRestrictionsResponse is a response for ReposAddProtectedBranchTeamRestrictions

https://developer.github.com/v3/repos/branches/#add-team-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchTeamRestrictionsResponse struct {
	response
	request *ReposAddProtectedBranchTeamRestrictionsReq
	Data    *ReposAddProtectedBranchTeamRestrictionsResponseBody
}

/*
ReposAddProtectedBranchUserRestrictions performs requests for "repos/add-protected-branch-user-restrictions"

Add user restrictions of protected branch.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#add-user-restrictions-of-protected-branch
*/
func (c *Client) ReposAddProtectedBranchUserRestrictions(ctx context.Context, req *ReposAddProtectedBranchUserRestrictionsReq, opt ...RequestOption) (*ReposAddProtectedBranchUserRestrictionsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposAddProtectedBranchUserRestrictionsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposAddProtectedBranchUserRestrictionsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddProtectedBranchUserRestrictionsReq is request data for Client.ReposAddProtectedBranchUserRestrictions

https://developer.github.com/v3/repos/branches/#add-user-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchUserRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposAddProtectedBranchUserRestrictionsReqBody
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) url() string {
	return r._url
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) method() string {
	return "POST"
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposAddProtectedBranchUserRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposAddProtectedBranchUserRestrictionsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddProtectedBranchUserRestrictionsReq) Rel(link RelName, resp *ReposAddProtectedBranchUserRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddProtectedBranchUserRestrictionsReqBody is a request body for repos/add-protected-branch-user-restrictions

https://developer.github.com/v3/repos/branches/#add-user-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchUserRestrictionsReqBody []string

/*
ReposAddProtectedBranchUserRestrictionsResponseBody is a response body for ReposAddProtectedBranchUserRestrictions

https://developer.github.com/v3/repos/branches/#add-user-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchUserRestrictionsResponseBody []struct {
	components.SimpleUser
}

/*
ReposAddProtectedBranchUserRestrictionsResponse is a response for ReposAddProtectedBranchUserRestrictions

https://developer.github.com/v3/repos/branches/#add-user-restrictions-of-protected-branch
*/
type ReposAddProtectedBranchUserRestrictionsResponse struct {
	response
	request *ReposAddProtectedBranchUserRestrictionsReq
	Data    *ReposAddProtectedBranchUserRestrictionsResponseBody
}

/*
ReposCheckCollaborator performs requests for "repos/check-collaborator"

Check if a user is a collaborator.

  GET /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-collaborator
*/
func (c *Client) ReposCheckCollaborator(ctx context.Context, req *ReposCheckCollaboratorReq, opt ...RequestOption) (*ReposCheckCollaboratorResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCheckCollaboratorResponse{
		request:  req,
		response: *r,
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCheckCollaboratorReq is request data for Client.ReposCheckCollaborator

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-collaborator
*/
type ReposCheckCollaboratorReq struct {
	_url     string
	Owner    string
	Repo     string
	Username string
}

func (r *ReposCheckCollaboratorReq) url() string {
	return r._url
}

func (r *ReposCheckCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username)
}

func (r *ReposCheckCollaboratorReq) method() string {
	return "GET"
}

func (r *ReposCheckCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCheckCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCheckCollaboratorReq) body() interface{} {
	return nil
}

func (r *ReposCheckCollaboratorReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposCheckCollaboratorReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposCheckCollaboratorReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// httpRequest creates an http request
func (r *ReposCheckCollaboratorReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCheckCollaboratorReq) Rel(link RelName, resp *ReposCheckCollaboratorResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCheckCollaboratorResponse is a response for ReposCheckCollaborator

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-collaborator
*/
type ReposCheckCollaboratorResponse struct {
	response
	request *ReposCheckCollaboratorReq
	Data    bool
}

/*
ReposCheckVulnerabilityAlerts performs requests for "repos/check-vulnerability-alerts"

Check if vulnerability alerts are enabled for a repository.

  GET /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
func (c *Client) ReposCheckVulnerabilityAlerts(ctx context.Context, req *ReposCheckVulnerabilityAlertsReq, opt ...RequestOption) (*ReposCheckVulnerabilityAlertsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCheckVulnerabilityAlertsResponse{
		request:  req,
		response: *r,
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCheckVulnerabilityAlertsReq is request data for Client.ReposCheckVulnerabilityAlerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
type ReposCheckVulnerabilityAlertsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling vulnerability alerts for a repository using the REST API
	is currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

func (r *ReposCheckVulnerabilityAlertsReq) url() string {
	return r._url
}

func (r *ReposCheckVulnerabilityAlertsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo)
}

func (r *ReposCheckVulnerabilityAlertsReq) method() string {
	return "GET"
}

func (r *ReposCheckVulnerabilityAlertsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCheckVulnerabilityAlertsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"dorian": r.DorianPreview}
	if requiredPreviews {
		previewVals["dorian"] = true
	}
	if allPreviews {
		previewVals["dorian"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCheckVulnerabilityAlertsReq) body() interface{} {
	return nil
}

func (r *ReposCheckVulnerabilityAlertsReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposCheckVulnerabilityAlertsReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposCheckVulnerabilityAlertsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// httpRequest creates an http request
func (r *ReposCheckVulnerabilityAlertsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCheckVulnerabilityAlertsReq) Rel(link RelName, resp *ReposCheckVulnerabilityAlertsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCheckVulnerabilityAlertsResponse is a response for ReposCheckVulnerabilityAlerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
type ReposCheckVulnerabilityAlertsResponse struct {
	response
	request *ReposCheckVulnerabilityAlertsReq
	Data    bool
}

/*
ReposCompareCommits performs requests for "repos/compare-commits"

Compare two commits.

  GET /repos/{owner}/{repo}/compare/{base}...{head}

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
func (c *Client) ReposCompareCommits(ctx context.Context, req *ReposCompareCommitsReq, opt ...RequestOption) (*ReposCompareCommitsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCompareCommitsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposCompareCommitsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCompareCommitsReq is request data for Client.ReposCompareCommits

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
type ReposCompareCommitsReq struct {
	_url  string
	Owner string
	Repo  string
	Base  string
	Head  string
}

func (r *ReposCompareCommitsReq) url() string {
	return r._url
}

func (r *ReposCompareCommitsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/compare/%v...%v", r.Owner, r.Repo, r.Base, r.Head)
}

func (r *ReposCompareCommitsReq) method() string {
	return "GET"
}

func (r *ReposCompareCommitsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCompareCommitsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCompareCommitsReq) body() interface{} {
	return nil
}

func (r *ReposCompareCommitsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposCompareCommitsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposCompareCommitsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposCompareCommitsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCompareCommitsReq) Rel(link RelName, resp *ReposCompareCommitsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCompareCommitsResponseBody is a response body for ReposCompareCommits

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
type ReposCompareCommitsResponseBody struct {
	components.CommitComparison
}

/*
ReposCompareCommitsResponse is a response for ReposCompareCommits

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
type ReposCompareCommitsResponse struct {
	response
	request *ReposCompareCommitsReq
	Data    *ReposCompareCommitsResponseBody
}

/*
ReposCreateCommitComment performs requests for "repos/create-commit-comment"

Create a commit comment.

  POST /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
func (c *Client) ReposCreateCommitComment(ctx context.Context, req *ReposCreateCommitCommentReq, opt ...RequestOption) (*ReposCreateCommitCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCreateCommitCommentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposCreateCommitCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateCommitCommentReq is request data for Client.ReposCreateCommitComment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	CommitSha   string
	RequestBody ReposCreateCommitCommentReqBody
}

func (r *ReposCreateCommitCommentReq) url() string {
	return r._url
}

func (r *ReposCreateCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/comments", r.Owner, r.Repo, r.CommitSha)
}

func (r *ReposCreateCommitCommentReq) method() string {
	return "POST"
}

func (r *ReposCreateCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateCommitCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateCommitCommentReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateCommitCommentReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateCommitCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposCreateCommitCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateCommitCommentReq) Rel(link RelName, resp *ReposCreateCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateCommitCommentReqBody is a request body for repos/create-commit-comment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`

	/*
	   **Deprecated**. Use **position** parameter instead. Line number in the file to
	   comment on.
	*/
	Line *int64 `json:"line,omitempty"`

	// Relative path of the file to comment on.
	Path *string `json:"path,omitempty"`

	// Line index in the diff to comment on.
	Position *int64 `json:"position,omitempty"`
}

/*
ReposCreateCommitCommentResponseBody is a response body for ReposCreateCommitComment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentResponseBody struct {
	components.CommitComment
}

/*
ReposCreateCommitCommentResponse is a response for ReposCreateCommitComment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentResponse struct {
	response
	request *ReposCreateCommitCommentReq
	Data    *ReposCreateCommitCommentResponseBody
}

/*
ReposCreateDeployment performs requests for "repos/create-deployment"

Create a deployment.

  POST /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
func (c *Client) ReposCreateDeployment(ctx context.Context, req *ReposCreateDeploymentReq, opt ...RequestOption) (*ReposCreateDeploymentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCreateDeploymentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposCreateDeploymentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateDeploymentReq is request data for Client.ReposCreateDeployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateDeploymentReqBody

	/*
	The `transient_environment` and `production_environment` parameters are
	currently available for developers to preview. During the preview period, the
	API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposCreateDeploymentReq) url() string {
	return r._url
}

func (r *ReposCreateDeploymentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments", r.Owner, r.Repo)
}

func (r *ReposCreateDeploymentReq) method() string {
	return "POST"
}

func (r *ReposCreateDeploymentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateDeploymentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"ant-man": r.AntManPreview}
	if allPreviews {
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateDeploymentReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateDeploymentReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateDeploymentReq) validStatuses() []int {
	return []int{201, 202}
}

func (r *ReposCreateDeploymentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposCreateDeploymentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateDeploymentReq) Rel(link RelName, resp *ReposCreateDeploymentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateDeploymentReqBody is a request body for repos/create-deployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentReqBody struct {

	/*
	   Attempts to automatically merge the default branch into the requested ref, if
	   it's behind the default branch.
	*/
	AutoMerge *bool `json:"auto_merge,omitempty"`

	// Short description of the deployment.
	Description *string `json:"description,omitempty"`

	/*
	   Name for the target deployment environment (e.g., `production`, `staging`,
	   `qa`).
	*/
	Environment *string `json:"environment,omitempty"`

	// JSON payload with extra information about the deployment.
	Payload *string `json:"payload,omitempty"`

	/*
	   Specifies if the given environment is one that end-users directly interact with.
	   Default: `true` when `environment` is `production` and `false` otherwise.
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	ProductionEnvironment *bool `json:"production_environment,omitempty"`

	// The ref to deploy. This can be a branch, tag, or SHA.
	Ref *string `json:"ref"`

	/*
	   The [status](https://developer.github.com/v3/repos/statuses/) contexts to verify
	   against commit status checks. If you omit this parameter, GitHub verifies all
	   unique contexts before creating a deployment. To bypass checking entirely, pass
	   an empty array. Defaults to all unique contexts.
	*/
	RequiredContexts []string `json:"required_contexts,omitempty"`

	// Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).
	Task *string `json:"task,omitempty"`

	/*
	   Specifies if the given environment is specific to the deployment and will no
	   longer exist at some point in the future. Default: `false`
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type. **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	TransientEnvironment *bool `json:"transient_environment,omitempty"`
}

/*
ReposCreateDeploymentResponseBody is a response body for ReposCreateDeployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentResponseBody struct {
	components.Deployment
}

/*
ReposCreateDeploymentResponse is a response for ReposCreateDeployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentResponse struct {
	response
	request *ReposCreateDeploymentReq
	Data    *ReposCreateDeploymentResponseBody
}

/*
ReposCreateDeploymentStatus performs requests for "repos/create-deployment-status"

Create a deployment status.

  POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
func (c *Client) ReposCreateDeploymentStatus(ctx context.Context, req *ReposCreateDeploymentStatusReq, opt ...RequestOption) (*ReposCreateDeploymentStatusResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCreateDeploymentStatusResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposCreateDeploymentStatusResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateDeploymentStatusReq is request data for Client.ReposCreateDeploymentStatus

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusReq struct {
	_url         string
	Owner        string
	Repo         string
	DeploymentId int64
	RequestBody  ReposCreateDeploymentStatusReqBody

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposCreateDeploymentStatusReq) url() string {
	return r._url
}

func (r *ReposCreateDeploymentStatusReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses", r.Owner, r.Repo, r.DeploymentId)
}

func (r *ReposCreateDeploymentStatusReq) method() string {
	return "POST"
}

func (r *ReposCreateDeploymentStatusReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateDeploymentStatusReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"ant-man": r.AntManPreview,
		"flash":   r.FlashPreview,
	}
	if allPreviews {
		previewVals["flash"] = true
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateDeploymentStatusReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateDeploymentStatusReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateDeploymentStatusReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateDeploymentStatusReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposCreateDeploymentStatusReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateDeploymentStatusReq) Rel(link RelName, resp *ReposCreateDeploymentStatusResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateDeploymentStatusReqBody is a request body for repos/create-deployment-status

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusReqBody struct {

	/*
	   Adds a new `inactive` status to all prior non-transient, non-production
	   environment deployments with the same repository and `environment` name as the
	   created status's deployment. An `inactive` status is only added to deployments
	   that had a `success` state. Default: `true`
	   **Note:** To add an `inactive` status to `production` environments, you must use
	   the
	   [`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	   custom media type.
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	AutoInactive *bool `json:"auto_inactive,omitempty"`

	/*
	   A short description of the status. The maximum description length is 140
	   characters.
	*/
	Description *string `json:"description,omitempty"`

	/*
	   Name for the target deployment environment, which can be changed when setting a
	   deploy status. For example, `production`, `staging`, or `qa`. **Note:** This
	   parameter requires you to use the
	   [`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	   custom media type.
	*/
	Environment *string `json:"environment,omitempty"`

	/*
	   Sets the URL for accessing your environment. Default: `""`
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type. **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	EnvironmentUrl *string `json:"environment_url,omitempty"`

	/*
	   The full URL of the deployment's output. This parameter replaces `target_url`.
	   We will continue to accept `target_url` to support legacy uses, but we recommend
	   replacing `target_url` with `log_url`. Setting `log_url` will automatically set
	   `target_url` to the same value. Default: `""`
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type. **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	LogUrl *string `json:"log_url,omitempty"`

	/*
	   The state of the status. Can be one of `error`, `failure`, `inactive`,
	   `in_progress`, `queued` `pending`, or `success`. **Note:** To use the `inactive`
	   state, you must provide the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type. To use the `in_progress` and `queued` states, you must
	   provide the
	   [`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	   custom media type.
	*/
	State *string `json:"state"`

	/*
	   The target URL to associate with this status. This URL should contain output to
	   keep the user updated while the task is running or serve as historical
	   information for what happened in the deployment. **Note:** It's recommended to
	   use the `log_url` parameter, which replaces `target_url`.
	*/
	TargetUrl *string `json:"target_url,omitempty"`
}

/*
ReposCreateDeploymentStatusResponseBody is a response body for ReposCreateDeploymentStatus

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusResponseBody struct {
	components.DeploymentStatus
}

/*
ReposCreateDeploymentStatusResponse is a response for ReposCreateDeploymentStatus

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusResponse struct {
	response
	request *ReposCreateDeploymentStatusReq
	Data    *ReposCreateDeploymentStatusResponseBody
}

/*
ReposCreateDispatchEvent performs requests for "repos/create-dispatch-event"

Create a repository dispatch event.

  POST /repos/{owner}/{repo}/dispatches

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
func (c *Client) ReposCreateDispatchEvent(ctx context.Context, req *ReposCreateDispatchEventReq, opt ...RequestOption) (*ReposCreateDispatchEventResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCreateDispatchEventResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateDispatchEventReq is request data for Client.ReposCreateDispatchEvent

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type ReposCreateDispatchEventReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateDispatchEventReqBody
}

func (r *ReposCreateDispatchEventReq) url() string {
	return r._url
}

func (r *ReposCreateDispatchEventReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/dispatches", r.Owner, r.Repo)
}

func (r *ReposCreateDispatchEventReq) method() string {
	return "POST"
}

func (r *ReposCreateDispatchEventReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateDispatchEventReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateDispatchEventReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateDispatchEventReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposCreateDispatchEventReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposCreateDispatchEventReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposCreateDispatchEventReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateDispatchEventReq) Rel(link RelName, resp *ReposCreateDispatchEventResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateDispatchEventReqBody is a request body for repos/create-dispatch-event

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type ReposCreateDispatchEventReqBody struct {

	/*
	   JSON payload with extra information about the webhook event that your action or
	   worklow may use.
	*/
	ClientPayload interface{} `json:"client_payload,omitempty"`

	// **Required:** A custom webhook event name.
	EventType *string `json:"event_type,omitempty"`
}

/*
ReposCreateDispatchEventResponse is a response for ReposCreateDispatchEvent

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type ReposCreateDispatchEventResponse struct {
	response
	request *ReposCreateDispatchEventReq
}

/*
ReposCreateForAuthenticatedUser performs requests for "repos/create-for-authenticated-user"

Create a repository for the authenticated user.

  POST /user/repos

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
func (c *Client) ReposCreateForAuthenticatedUser(ctx context.Context, req *ReposCreateForAuthenticatedUserReq, opt ...RequestOption) (*ReposCreateForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCreateForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposCreateForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateForAuthenticatedUserReq is request data for Client.ReposCreateForAuthenticatedUser

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserReq struct {
	_url        string
	RequestBody ReposCreateForAuthenticatedUserReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

func (r *ReposCreateForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *ReposCreateForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/repos")
}

func (r *ReposCreateForAuthenticatedUserReq) method() string {
	return "POST"
}

func (r *ReposCreateForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"baptiste": r.BaptistePreview,
		"nebula":   r.NebulaPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateForAuthenticatedUserReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateForAuthenticatedUserReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateForAuthenticatedUserReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposCreateForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateForAuthenticatedUserReq) Rel(link RelName, resp *ReposCreateForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateForAuthenticatedUserReqBody is a request body for repos/create-for-authenticated-user

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserReqBody struct {

	/*
	   Either `true` to allow merging pull requests with a merge commit, or `false` to
	   prevent merging pull requests with merge commits.
	*/
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	/*
	   Either `true` to allow rebase-merging pull requests, or `false` to prevent
	   rebase-merging.
	*/
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	/*
	   Either `true` to allow squash-merging pull requests, or `false` to prevent
	   squash-merging.
	*/
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	// Pass `true` to create an initial commit with empty README.
	AutoInit *bool `json:"auto_init,omitempty"`

	/*
	   Either `true` to allow automatically deleting head branches when pull requests
	   are merged, or `false` to prevent automatic deletion.
	*/
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	/*
	   Desired language or platform [.gitignore
	   template](https://github.com/github/gitignore) to apply. Use the name of the
	   template without the extension. For example, "Haskell".
	*/
	GitignoreTemplate *string `json:"gitignore_template,omitempty"`

	// Either `true` to enable issues for this repository or `false` to disable them.
	HasIssues *bool `json:"has_issues,omitempty"`

	/*
	   Either `true` to enable projects for this repository or `false` to disable them.
	   **Note:** If you're creating a repository in an organization that has disabled
	   repository projects, the default is `false`, and if you pass `true`, the API
	   returns an error.
	*/
	HasProjects *bool `json:"has_projects,omitempty"`

	// Either `true` to enable the wiki for this repository or `false` to disable it.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	/*
	   Either `true` to make this repo available as a template repository or `false` to
	   prevent it.
	*/
	IsTemplate *bool `json:"is_template,omitempty"`

	/*
	   Choose an [open source license template](https://choosealicense.com/) that best
	   suits your needs, and then use the [license
	   keyword](https://help.github.com/articles/licensing-a-repository/#searching-github-by-license-type)
	   as the `license_template` string. For example, "mit" or "mpl-2.0".
	*/
	LicenseTemplate *string `json:"license_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name"`

	// Either `true` to create a private repository or `false` to create a public one.
	Private *bool `json:"private,omitempty"`

	/*
	   The id of the team that will be granted access to this repository. This is only
	   valid when creating a repository in an organization.
	*/
	TeamId *int64 `json:"team_id,omitempty"`

	/*
	   Can be `public` or `private`. If your organization is associated with an
	   enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server
	   2.20+, `visibility` can also be `internal`. For more information, see "[Creating
	   an internal
	   repository](https://help.github.com/github/creating-cloning-and-archiving-repositories/creating-an-internal-repository)"
	   in the GitHub Help documentation.
	   The `visibility` parameter overrides the `private` parameter when you use both
	   parameters with the `nebula-preview` preview header.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ReposCreateForAuthenticatedUserResponseBody is a response body for ReposCreateForAuthenticatedUser

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserResponseBody struct {
	components.Repository
}

/*
ReposCreateForAuthenticatedUserResponse is a response for ReposCreateForAuthenticatedUser

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserResponse struct {
	response
	request *ReposCreateForAuthenticatedUserReq
	Data    *ReposCreateForAuthenticatedUserResponseBody
}

/*
ReposCreateFork performs requests for "repos/create-fork"

Create a fork.

  POST /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
func (c *Client) ReposCreateFork(ctx context.Context, req *ReposCreateForkReq, opt ...RequestOption) (*ReposCreateForkResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCreateForkResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposCreateForkResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateForkReq is request data for Client.ReposCreateFork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateForkReqBody
}

func (r *ReposCreateForkReq) url() string {
	return r._url
}

func (r *ReposCreateForkReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/forks", r.Owner, r.Repo)
}

func (r *ReposCreateForkReq) method() string {
	return "POST"
}

func (r *ReposCreateForkReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateForkReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateForkReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateForkReq) dataStatuses() []int {
	return []int{202}
}

func (r *ReposCreateForkReq) validStatuses() []int {
	return []int{202}
}

func (r *ReposCreateForkReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposCreateForkReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateForkReq) Rel(link RelName, resp *ReposCreateForkResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateForkReqBody is a request body for repos/create-fork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkReqBody struct {

	/*
	   Optional parameter to specify the organization name if forking into an
	   organization.
	*/
	Organization *string `json:"organization,omitempty"`
}

/*
ReposCreateForkResponseBody is a response body for ReposCreateFork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkResponseBody struct {
	components.Repository
}

/*
ReposCreateForkResponse is a response for ReposCreateFork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkResponse struct {
	response
	request *ReposCreateForkReq
	Data    *ReposCreateForkResponseBody
}

/*
ReposCreateHook performs requests for "repos/create-hook"

Create a hook.

  POST /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#create-a-hook
*/
func (c *Client) ReposCreateHook(ctx context.Context, req *ReposCreateHookReq, opt ...RequestOption) (*ReposCreateHookResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCreateHookResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposCreateHookResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateHookReq is request data for Client.ReposCreateHook

https://developer.github.com/v3/repos/hooks/#create-a-hook
*/
type ReposCreateHookReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateHookReqBody
}

func (r *ReposCreateHookReq) url() string {
	return r._url
}

func (r *ReposCreateHookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks", r.Owner, r.Repo)
}

func (r *ReposCreateHookReq) method() string {
	return "POST"
}

func (r *ReposCreateHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateHookReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateHookReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateHookReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateHookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposCreateHookReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateHookReq) Rel(link RelName, resp *ReposCreateHookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposCreateHookReqBodyConfig is a value for ReposCreateHookReqBody's Config field
type ReposCreateHookReqBodyConfig struct {

	/*
	   The media type used to serialize the payloads. Supported values include `json`
	   and `form`. The default is `form`.
	*/
	ContentType *string `json:"content_type,omitempty"`

	/*
	   Determines whether the SSL certificate of the host for `url` will be verified
	   when delivering payloads. Supported values include `0` (verification is
	   performed) and `1` (verification is not performed). The default is `0`. **We
	   strongly recommend not setting this to `1` as you are subject to
	   man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	   If provided, the `secret` will be used as the `key` to generate the HMAC hex
	   digest value in the
	   [`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	   header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
ReposCreateHookReqBody is a request body for repos/create-hook

https://developer.github.com/v3/repos/hooks/#create-a-hook
*/
type ReposCreateHookReqBody struct {

	/*
	   Determines if notifications are sent when the webhook is triggered. Set to
	   `true` to send notifications.
	*/
	Active *bool `json:"active,omitempty"`

	/*
	   Key/value pairs to provide settings for this webhook. [These are defined
	   below](https://developer.github.com/v3/repos/hooks/#create-hook-config-params).
	*/
	Config *ReposCreateHookReqBodyConfig `json:"config"`

	/*
	   Determines what [events](https://developer.github.com/webhooks/event-payloads)
	   the hook is triggered for.
	*/
	Events []string `json:"events,omitempty"`

	/*
	   Use `web` to create a webhook. Default: `web`. This parameter only accepts the
	   value `web`.
	*/
	Name *string `json:"name,omitempty"`
}

/*
ReposCreateHookResponseBody is a response body for ReposCreateHook

https://developer.github.com/v3/repos/hooks/#create-a-hook
*/
type ReposCreateHookResponseBody struct {
	components.Hook
}

/*
ReposCreateHookResponse is a response for ReposCreateHook

https://developer.github.com/v3/repos/hooks/#create-a-hook
*/
type ReposCreateHookResponse struct {
	response
	request *ReposCreateHookReq
	Data    *ReposCreateHookResponseBody
}

/*
ReposCreateInOrg performs requests for "repos/create-in-org"

Create an organization repository.

  POST /orgs/{org}/repos

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
func (c *Client) ReposCreateInOrg(ctx context.Context, req *ReposCreateInOrgReq, opt ...RequestOption) (*ReposCreateInOrgResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCreateInOrgResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposCreateInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateInOrgReq is request data for Client.ReposCreateInOrg

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgReq struct {
	_url        string
	Org         string
	RequestBody ReposCreateInOrgReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

func (r *ReposCreateInOrgReq) url() string {
	return r._url
}

func (r *ReposCreateInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/repos", r.Org)
}

func (r *ReposCreateInOrgReq) method() string {
	return "POST"
}

func (r *ReposCreateInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"baptiste": r.BaptistePreview,
		"nebula":   r.NebulaPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateInOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposCreateInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateInOrgReq) Rel(link RelName, resp *ReposCreateInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateInOrgReqBody is a request body for repos/create-in-org

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgReqBody struct {

	/*
	   Either `true` to allow merging pull requests with a merge commit, or `false` to
	   prevent merging pull requests with merge commits.
	*/
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	/*
	   Either `true` to allow rebase-merging pull requests, or `false` to prevent
	   rebase-merging.
	*/
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	/*
	   Either `true` to allow squash-merging pull requests, or `false` to prevent
	   squash-merging.
	*/
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	// Pass `true` to create an initial commit with empty README.
	AutoInit *bool `json:"auto_init,omitempty"`

	/*
	   Either `true` to allow automatically deleting head branches when pull requests
	   are merged, or `false` to prevent automatic deletion.
	*/
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	/*
	   Desired language or platform [.gitignore
	   template](https://github.com/github/gitignore) to apply. Use the name of the
	   template without the extension. For example, "Haskell".
	*/
	GitignoreTemplate *string `json:"gitignore_template,omitempty"`

	// Either `true` to enable issues for this repository or `false` to disable them.
	HasIssues *bool `json:"has_issues,omitempty"`

	/*
	   Either `true` to enable projects for this repository or `false` to disable them.
	   **Note:** If you're creating a repository in an organization that has disabled
	   repository projects, the default is `false`, and if you pass `true`, the API
	   returns an error.
	*/
	HasProjects *bool `json:"has_projects,omitempty"`

	// Either `true` to enable the wiki for this repository or `false` to disable it.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	/*
	   Either `true` to make this repo available as a template repository or `false` to
	   prevent it.
	*/
	IsTemplate *bool `json:"is_template,omitempty"`

	/*
	   Choose an [open source license template](https://choosealicense.com/) that best
	   suits your needs, and then use the [license
	   keyword](https://help.github.com/articles/licensing-a-repository/#searching-github-by-license-type)
	   as the `license_template` string. For example, "mit" or "mpl-2.0".
	*/
	LicenseTemplate *string `json:"license_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name"`

	// Either `true` to create a private repository or `false` to create a public one.
	Private *bool `json:"private,omitempty"`

	/*
	   The id of the team that will be granted access to this repository. This is only
	   valid when creating a repository in an organization.
	*/
	TeamId *int64 `json:"team_id,omitempty"`

	/*
	   Can be `public` or `private`. If your organization is associated with an
	   enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server
	   2.20+, `visibility` can also be `internal`. For more information, see "[Creating
	   an internal
	   repository](https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)"
	   in the GitHub Help documentation.
	   The `visibility` parameter overrides the `private` parameter when you use both
	   parameters with the `nebula-preview` preview header.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ReposCreateInOrgResponseBody is a response body for ReposCreateInOrg

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgResponseBody struct {
	components.Repository
}

/*
ReposCreateInOrgResponse is a response for ReposCreateInOrg

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgResponse struct {
	response
	request *ReposCreateInOrgReq
	Data    *ReposCreateInOrgResponseBody
}

/*
ReposCreateOrUpdateFile performs requests for "repos/create-or-update-file"

Create or update a file.

  PUT /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#create-or-update-a-file
*/
func (c *Client) ReposCreateOrUpdateFile(ctx context.Context, req *ReposCreateOrUpdateFileReq, opt ...RequestOption) (*ReposCreateOrUpdateFileResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCreateOrUpdateFileResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposCreateOrUpdateFileResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateOrUpdateFileReq is request data for Client.ReposCreateOrUpdateFile

https://developer.github.com/v3/repos/contents/#create-or-update-a-file
*/
type ReposCreateOrUpdateFileReq struct {
	_url        string
	Owner       string
	Repo        string
	Path        string
	RequestBody ReposCreateOrUpdateFileReqBody
}

func (r *ReposCreateOrUpdateFileReq) url() string {
	return r._url
}

func (r *ReposCreateOrUpdateFileReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path)
}

func (r *ReposCreateOrUpdateFileReq) method() string {
	return "PUT"
}

func (r *ReposCreateOrUpdateFileReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateOrUpdateFileReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateOrUpdateFileReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateOrUpdateFileReq) dataStatuses() []int {
	return []int{200, 201}
}

func (r *ReposCreateOrUpdateFileReq) validStatuses() []int {
	return []int{200, 201}
}

func (r *ReposCreateOrUpdateFileReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposCreateOrUpdateFileReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateOrUpdateFileReq) Rel(link RelName, resp *ReposCreateOrUpdateFileResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposCreateOrUpdateFileReqBodyAuthor is a value for ReposCreateOrUpdateFileReqBody's Author field
type ReposCreateOrUpdateFileReqBodyAuthor struct {

	/*
	   The email of the author or committer of the commit. You'll receive a `422`
	   status code if `email` is omitted.
	*/
	Email *string `json:"email"`

	/*
	   The name of the author or committer of the commit. You'll receive a `422` status
	   code if `name` is omitted.
	*/
	Name *string `json:"name"`
}

// ReposCreateOrUpdateFileReqBodyCommitter is a value for ReposCreateOrUpdateFileReqBody's Committer field
type ReposCreateOrUpdateFileReqBodyCommitter struct {

	/*
	   The email of the author or committer of the commit. You'll receive a `422`
	   status code if `email` is omitted.
	*/
	Email *string `json:"email"`

	/*
	   The name of the author or committer of the commit. You'll receive a `422` status
	   code if `name` is omitted.
	*/
	Name *string `json:"name"`
}

/*
ReposCreateOrUpdateFileReqBody is a request body for repos/create-or-update-file

https://developer.github.com/v3/repos/contents/#create-or-update-a-file
*/
type ReposCreateOrUpdateFileReqBody struct {

	/*
	   The author of the file. Default: The `committer` or the authenticated user if
	   you omit `committer`.
	*/
	Author *ReposCreateOrUpdateFileReqBodyAuthor `json:"author,omitempty"`

	// The branch name. Default: the repositorys default branch (usually `master`)
	Branch *string `json:"branch,omitempty"`

	// The person that committed the file. Default: the authenticated user.
	Committer *ReposCreateOrUpdateFileReqBodyCommitter `json:"committer,omitempty"`

	// The new file content, using Base64 encoding.
	Content *string `json:"content"`

	// The commit message.
	Message *string `json:"message"`

	/*
	   **Required if you are updating a file**. The blob SHA of the file being
	   replaced.
	*/
	Sha *string `json:"sha,omitempty"`
}

/*
ReposCreateOrUpdateFileResponseBody is a response body for ReposCreateOrUpdateFile

https://developer.github.com/v3/repos/contents/#create-or-update-a-file
*/
type ReposCreateOrUpdateFileResponseBody struct {
	components.FileCommit
}

/*
ReposCreateOrUpdateFileResponse is a response for ReposCreateOrUpdateFile

https://developer.github.com/v3/repos/contents/#create-or-update-a-file
*/
type ReposCreateOrUpdateFileResponse struct {
	response
	request *ReposCreateOrUpdateFileReq
	Data    *ReposCreateOrUpdateFileResponseBody
}

/*
ReposCreateRelease performs requests for "repos/create-release"

Create a release.

  POST /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#create-a-release
*/
func (c *Client) ReposCreateRelease(ctx context.Context, req *ReposCreateReleaseReq, opt ...RequestOption) (*ReposCreateReleaseResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCreateReleaseResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposCreateReleaseResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateReleaseReq is request data for Client.ReposCreateRelease

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateReleaseReqBody
}

func (r *ReposCreateReleaseReq) url() string {
	return r._url
}

func (r *ReposCreateReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases", r.Owner, r.Repo)
}

func (r *ReposCreateReleaseReq) method() string {
	return "POST"
}

func (r *ReposCreateReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateReleaseReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateReleaseReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateReleaseReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateReleaseReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposCreateReleaseReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateReleaseReq) Rel(link RelName, resp *ReposCreateReleaseResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateReleaseReqBody is a request body for repos/create-release

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseReqBody struct {

	// Text describing the contents of the tag.
	Body *string `json:"body,omitempty"`

	/*
	   `true` to create a draft (unpublished) release, `false` to create a published
	   one.
	*/
	Draft *bool `json:"draft,omitempty"`

	// The name of the release.
	Name *string `json:"name,omitempty"`

	/*
	   `true` to identify the release as a prerelease. `false` to identify the release
	   as a full release.
	*/
	Prerelease *bool `json:"prerelease,omitempty"`

	// The name of the tag.
	TagName *string `json:"tag_name"`

	/*
	   Specifies the commitish value that determines where the Git tag is created from.
	   Can be any branch or commit SHA. Unused if the Git tag already exists. Default:
	   the repository's default branch (usually `master`).
	*/
	TargetCommitish *string `json:"target_commitish,omitempty"`
}

/*
ReposCreateReleaseResponseBody is a response body for ReposCreateRelease

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseResponseBody struct {
	components.Release
}

/*
ReposCreateReleaseResponse is a response for ReposCreateRelease

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseResponse struct {
	response
	request *ReposCreateReleaseReq
	Data    *ReposCreateReleaseResponseBody
}

/*
ReposCreateStatus performs requests for "repos/create-status"

Create a status.

  POST /repos/{owner}/{repo}/statuses/{sha}

https://developer.github.com/v3/repos/statuses/#create-a-status
*/
func (c *Client) ReposCreateStatus(ctx context.Context, req *ReposCreateStatusReq, opt ...RequestOption) (*ReposCreateStatusResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCreateStatusResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposCreateStatusResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateStatusReq is request data for Client.ReposCreateStatus

https://developer.github.com/v3/repos/statuses/#create-a-status
*/
type ReposCreateStatusReq struct {
	_url        string
	Owner       string
	Repo        string
	Sha         string
	RequestBody ReposCreateStatusReqBody
}

func (r *ReposCreateStatusReq) url() string {
	return r._url
}

func (r *ReposCreateStatusReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/statuses/%v", r.Owner, r.Repo, r.Sha)
}

func (r *ReposCreateStatusReq) method() string {
	return "POST"
}

func (r *ReposCreateStatusReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateStatusReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateStatusReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateStatusReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateStatusReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateStatusReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposCreateStatusReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateStatusReq) Rel(link RelName, resp *ReposCreateStatusResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateStatusReqBody is a request body for repos/create-status

https://developer.github.com/v3/repos/statuses/#create-a-status
*/
type ReposCreateStatusReqBody struct {

	// A string label to differentiate this status from the status of other systems.
	Context *string `json:"context,omitempty"`

	// A short description of the status.
	Description *string `json:"description,omitempty"`

	/*
	   The state of the status. Can be one of `error`, `failure`, `pending`, or
	   `success`.
	*/
	State *string `json:"state"`

	/*
	   The target URL to associate with this status. This URL will be linked from the
	   GitHub UI to allow users to easily see the source of the status.
	   For example, if your continuous integration system is posting build status, you
	   would want to provide the deep link for the build output for this specific SHA:
	   `http://ci.example.com/user/repo/build/sha`
	*/
	TargetUrl *string `json:"target_url,omitempty"`
}

/*
ReposCreateStatusResponseBody is a response body for ReposCreateStatus

https://developer.github.com/v3/repos/statuses/#create-a-status
*/
type ReposCreateStatusResponseBody struct {
	components.Status
}

/*
ReposCreateStatusResponse is a response for ReposCreateStatus

https://developer.github.com/v3/repos/statuses/#create-a-status
*/
type ReposCreateStatusResponse struct {
	response
	request *ReposCreateStatusReq
	Data    *ReposCreateStatusResponseBody
}

/*
ReposCreateUsingTemplate performs requests for "repos/create-using-template"

Create a repository using a template.

  POST /repos/{template_owner}/{template_repo}/generate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
func (c *Client) ReposCreateUsingTemplate(ctx context.Context, req *ReposCreateUsingTemplateReq, opt ...RequestOption) (*ReposCreateUsingTemplateResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposCreateUsingTemplateResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposCreateUsingTemplateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateUsingTemplateReq is request data for Client.ReposCreateUsingTemplate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateReq struct {
	_url          string
	TemplateOwner string
	TemplateRepo  string
	RequestBody   ReposCreateUsingTemplateReqBody

	/*
	Creating and using repository templates is currently available for developers to
	preview. To access this new endpoint during the preview period, you must set
	this to true.
	*/
	BaptistePreview bool
}

func (r *ReposCreateUsingTemplateReq) url() string {
	return r._url
}

func (r *ReposCreateUsingTemplateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/generate", r.TemplateOwner, r.TemplateRepo)
}

func (r *ReposCreateUsingTemplateReq) method() string {
	return "POST"
}

func (r *ReposCreateUsingTemplateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateUsingTemplateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"baptiste": r.BaptistePreview}
	if requiredPreviews {
		previewVals["baptiste"] = true
	}
	if allPreviews {
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateUsingTemplateReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateUsingTemplateReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateUsingTemplateReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateUsingTemplateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposCreateUsingTemplateReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateUsingTemplateReq) Rel(link RelName, resp *ReposCreateUsingTemplateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateUsingTemplateReqBody is a request body for repos/create-using-template

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateReqBody struct {

	// A short description of the new repository.
	Description *string `json:"description,omitempty"`

	// The name of the new repository.
	Name *string `json:"name"`

	/*
	   The organization or person who will own the new repository. To create a new
	   repository in an organization, the authenticated user must be a member of the
	   specified organization.
	*/
	Owner *string `json:"owner,omitempty"`

	/*
	   Either `true` to create a new private repository or `false` to create a new
	   public one.
	*/
	Private *bool `json:"private,omitempty"`
}

/*
ReposCreateUsingTemplateResponseBody is a response body for ReposCreateUsingTemplate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateResponseBody struct {
	components.Repository3
}

/*
ReposCreateUsingTemplateResponse is a response for ReposCreateUsingTemplate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateResponse struct {
	response
	request *ReposCreateUsingTemplateReq
	Data    *ReposCreateUsingTemplateResponseBody
}

/*
ReposDeclineInvitation performs requests for "repos/decline-invitation"

Decline a repository invitation.

  DELETE /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
func (c *Client) ReposDeclineInvitation(ctx context.Context, req *ReposDeclineInvitationReq, opt ...RequestOption) (*ReposDeclineInvitationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposDeclineInvitationResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeclineInvitationReq is request data for Client.ReposDeclineInvitation

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
type ReposDeclineInvitationReq struct {
	_url         string
	InvitationId int64
}

func (r *ReposDeclineInvitationReq) url() string {
	return r._url
}

func (r *ReposDeclineInvitationReq) urlPath() string {
	return fmt.Sprintf("/user/repository_invitations/%v", r.InvitationId)
}

func (r *ReposDeclineInvitationReq) method() string {
	return "DELETE"
}

func (r *ReposDeclineInvitationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeclineInvitationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeclineInvitationReq) body() interface{} {
	return nil
}

func (r *ReposDeclineInvitationReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeclineInvitationReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeclineInvitationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposDeclineInvitationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeclineInvitationReq) Rel(link RelName, resp *ReposDeclineInvitationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeclineInvitationResponse is a response for ReposDeclineInvitation

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
type ReposDeclineInvitationResponse struct {
	response
	request *ReposDeclineInvitationReq
}

/*
ReposDelete performs requests for "repos/delete"

Delete a repository.

  DELETE /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#delete-a-repository
*/
func (c *Client) ReposDelete(ctx context.Context, req *ReposDeleteReq, opt ...RequestOption) (*ReposDeleteResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposDeleteResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteReq is request data for Client.ReposDelete

https://developer.github.com/v3/repos/#delete-a-repository
*/
type ReposDeleteReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposDeleteReq) url() string {
	return r._url
}

func (r *ReposDeleteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo)
}

func (r *ReposDeleteReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteReq) body() interface{} {
	return nil
}

func (r *ReposDeleteReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposDeleteReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteReq) Rel(link RelName, resp *ReposDeleteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteResponse is a response for ReposDelete

https://developer.github.com/v3/repos/#delete-a-repository
*/
type ReposDeleteResponse struct {
	response
	request *ReposDeleteReq
}

/*
ReposDeleteCommitComment performs requests for "repos/delete-commit-comment"

Delete a commit comment.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
func (c *Client) ReposDeleteCommitComment(ctx context.Context, req *ReposDeleteCommitCommentReq, opt ...RequestOption) (*ReposDeleteCommitCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposDeleteCommitCommentResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteCommitCommentReq is request data for Client.ReposDeleteCommitComment

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
type ReposDeleteCommitCommentReq struct {
	_url      string
	Owner     string
	Repo      string
	CommentId int64
}

func (r *ReposDeleteCommitCommentReq) url() string {
	return r._url
}

func (r *ReposDeleteCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *ReposDeleteCommitCommentReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteCommitCommentReq) body() interface{} {
	return nil
}

func (r *ReposDeleteCommitCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteCommitCommentReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteCommitCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposDeleteCommitCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteCommitCommentReq) Rel(link RelName, resp *ReposDeleteCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteCommitCommentResponse is a response for ReposDeleteCommitComment

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
type ReposDeleteCommitCommentResponse struct {
	response
	request *ReposDeleteCommitCommentReq
}

/*
ReposDeleteDeployment performs requests for "repos/delete-deployment"

Delete a deployment.

  DELETE /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
func (c *Client) ReposDeleteDeployment(ctx context.Context, req *ReposDeleteDeploymentReq, opt ...RequestOption) (*ReposDeleteDeploymentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposDeleteDeploymentResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteDeploymentReq is request data for Client.ReposDeleteDeployment

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
type ReposDeleteDeploymentReq struct {
	_url         string
	Owner        string
	Repo         string
	DeploymentId int64
}

func (r *ReposDeleteDeploymentReq) url() string {
	return r._url
}

func (r *ReposDeleteDeploymentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v", r.Owner, r.Repo, r.DeploymentId)
}

func (r *ReposDeleteDeploymentReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteDeploymentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteDeploymentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteDeploymentReq) body() interface{} {
	return nil
}

func (r *ReposDeleteDeploymentReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteDeploymentReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteDeploymentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposDeleteDeploymentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteDeploymentReq) Rel(link RelName, resp *ReposDeleteDeploymentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteDeploymentResponse is a response for ReposDeleteDeployment

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
type ReposDeleteDeploymentResponse struct {
	response
	request *ReposDeleteDeploymentReq
}

/*
ReposDeleteDownload performs requests for "repos/delete-download"

Delete a download.

  DELETE /repos/{owner}/{repo}/downloads/{download_id}

https://developer.github.com/v3/repos/downloads/#delete-a-download
*/
func (c *Client) ReposDeleteDownload(ctx context.Context, req *ReposDeleteDownloadReq, opt ...RequestOption) (*ReposDeleteDownloadResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposDeleteDownloadResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteDownloadReq is request data for Client.ReposDeleteDownload

https://developer.github.com/v3/repos/downloads/#delete-a-download
*/
type ReposDeleteDownloadReq struct {
	_url       string
	Owner      string
	Repo       string
	DownloadId int64
}

func (r *ReposDeleteDownloadReq) url() string {
	return r._url
}

func (r *ReposDeleteDownloadReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/downloads/%v", r.Owner, r.Repo, r.DownloadId)
}

func (r *ReposDeleteDownloadReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteDownloadReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteDownloadReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteDownloadReq) body() interface{} {
	return nil
}

func (r *ReposDeleteDownloadReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteDownloadReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteDownloadReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposDeleteDownloadReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteDownloadReq) Rel(link RelName, resp *ReposDeleteDownloadResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteDownloadResponse is a response for ReposDeleteDownload

https://developer.github.com/v3/repos/downloads/#delete-a-download
*/
type ReposDeleteDownloadResponse struct {
	response
	request *ReposDeleteDownloadReq
}

/*
ReposDeleteFile performs requests for "repos/delete-file"

Delete a file.

  DELETE /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
func (c *Client) ReposDeleteFile(ctx context.Context, req *ReposDeleteFileReq, opt ...RequestOption) (*ReposDeleteFileResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposDeleteFileResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposDeleteFileResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteFileReq is request data for Client.ReposDeleteFile

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileReq struct {
	_url        string
	Owner       string
	Repo        string
	Path        string
	RequestBody ReposDeleteFileReqBody
}

func (r *ReposDeleteFileReq) url() string {
	return r._url
}

func (r *ReposDeleteFileReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path)
}

func (r *ReposDeleteFileReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteFileReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteFileReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteFileReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposDeleteFileReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposDeleteFileReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposDeleteFileReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposDeleteFileReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteFileReq) Rel(link RelName, resp *ReposDeleteFileResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposDeleteFileReqBodyAuthor is a value for ReposDeleteFileReqBody's Author field
type ReposDeleteFileReqBodyAuthor struct {

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

// ReposDeleteFileReqBodyCommitter is a value for ReposDeleteFileReqBody's Committer field
type ReposDeleteFileReqBodyCommitter struct {

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

/*
ReposDeleteFileReqBody is a request body for repos/delete-file

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileReqBody struct {

	// object containing information about the author.
	Author *ReposDeleteFileReqBodyAuthor `json:"author,omitempty"`

	// The branch name. Default: the repositorys default branch (usually `master`)
	Branch *string `json:"branch,omitempty"`

	// object containing information about the committer.
	Committer *ReposDeleteFileReqBodyCommitter `json:"committer,omitempty"`

	// The commit message.
	Message *string `json:"message"`

	// The blob SHA of the file being replaced.
	Sha *string `json:"sha"`
}

/*
ReposDeleteFileResponseBody is a response body for ReposDeleteFile

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileResponseBody struct {
	components.FileCommit2
}

/*
ReposDeleteFileResponse is a response for ReposDeleteFile

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileResponse struct {
	response
	request *ReposDeleteFileReq
	Data    *ReposDeleteFileResponseBody
}

/*
ReposDeleteHook performs requests for "repos/delete-hook"

Delete a hook.

  DELETE /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#delete-a-hook
*/
func (c *Client) ReposDeleteHook(ctx context.Context, req *ReposDeleteHookReq, opt ...RequestOption) (*ReposDeleteHookResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposDeleteHookResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteHookReq is request data for Client.ReposDeleteHook

https://developer.github.com/v3/repos/hooks/#delete-a-hook
*/
type ReposDeleteHookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

func (r *ReposDeleteHookReq) url() string {
	return r._url
}

func (r *ReposDeleteHookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId)
}

func (r *ReposDeleteHookReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteHookReq) body() interface{} {
	return nil
}

func (r *ReposDeleteHookReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteHookReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteHookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposDeleteHookReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteHookReq) Rel(link RelName, resp *ReposDeleteHookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteHookResponse is a response for ReposDeleteHook

https://developer.github.com/v3/repos/hooks/#delete-a-hook
*/
type ReposDeleteHookResponse struct {
	response
	request *ReposDeleteHookReq
}

/*
ReposDeleteInvitation performs requests for "repos/delete-invitation"

Delete a repository invitation.

  DELETE /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
func (c *Client) ReposDeleteInvitation(ctx context.Context, req *ReposDeleteInvitationReq, opt ...RequestOption) (*ReposDeleteInvitationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposDeleteInvitationResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteInvitationReq is request data for Client.ReposDeleteInvitation

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
type ReposDeleteInvitationReq struct {
	_url         string
	Owner        string
	Repo         string
	InvitationId int64
}

func (r *ReposDeleteInvitationReq) url() string {
	return r._url
}

func (r *ReposDeleteInvitationReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/invitations/%v", r.Owner, r.Repo, r.InvitationId)
}

func (r *ReposDeleteInvitationReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteInvitationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteInvitationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteInvitationReq) body() interface{} {
	return nil
}

func (r *ReposDeleteInvitationReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteInvitationReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteInvitationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposDeleteInvitationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteInvitationReq) Rel(link RelName, resp *ReposDeleteInvitationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteInvitationResponse is a response for ReposDeleteInvitation

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
type ReposDeleteInvitationResponse struct {
	response
	request *ReposDeleteInvitationReq
}

/*
ReposDeleteRelease performs requests for "repos/delete-release"

Delete a release.

  DELETE /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
func (c *Client) ReposDeleteRelease(ctx context.Context, req *ReposDeleteReleaseReq, opt ...RequestOption) (*ReposDeleteReleaseResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposDeleteReleaseResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteReleaseReq is request data for Client.ReposDeleteRelease

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
type ReposDeleteReleaseReq struct {
	_url      string
	Owner     string
	Repo      string
	ReleaseId int64
}

func (r *ReposDeleteReleaseReq) url() string {
	return r._url
}

func (r *ReposDeleteReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposDeleteReleaseReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteReleaseReq) body() interface{} {
	return nil
}

func (r *ReposDeleteReleaseReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteReleaseReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteReleaseReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposDeleteReleaseReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteReleaseReq) Rel(link RelName, resp *ReposDeleteReleaseResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteReleaseResponse is a response for ReposDeleteRelease

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
type ReposDeleteReleaseResponse struct {
	response
	request *ReposDeleteReleaseReq
}

/*
ReposDeleteReleaseAsset performs requests for "repos/delete-release-asset"

Delete a release asset.

  DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
func (c *Client) ReposDeleteReleaseAsset(ctx context.Context, req *ReposDeleteReleaseAssetReq, opt ...RequestOption) (*ReposDeleteReleaseAssetResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposDeleteReleaseAssetResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteReleaseAssetReq is request data for Client.ReposDeleteReleaseAsset

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
type ReposDeleteReleaseAssetReq struct {
	_url    string
	Owner   string
	Repo    string
	AssetId int64
}

func (r *ReposDeleteReleaseAssetReq) url() string {
	return r._url
}

func (r *ReposDeleteReleaseAssetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId)
}

func (r *ReposDeleteReleaseAssetReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteReleaseAssetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteReleaseAssetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteReleaseAssetReq) body() interface{} {
	return nil
}

func (r *ReposDeleteReleaseAssetReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteReleaseAssetReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteReleaseAssetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposDeleteReleaseAssetReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteReleaseAssetReq) Rel(link RelName, resp *ReposDeleteReleaseAssetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteReleaseAssetResponse is a response for ReposDeleteReleaseAsset

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
type ReposDeleteReleaseAssetResponse struct {
	response
	request *ReposDeleteReleaseAssetReq
}

/*
ReposDisableAutomatedSecurityFixes performs requests for "repos/disable-automated-security-fixes"

Disable automated security fixes.

  DELETE /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
func (c *Client) ReposDisableAutomatedSecurityFixes(ctx context.Context, req *ReposDisableAutomatedSecurityFixesReq, opt ...RequestOption) (*ReposDisableAutomatedSecurityFixesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposDisableAutomatedSecurityFixesResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDisableAutomatedSecurityFixesReq is request data for Client.ReposDisableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
type ReposDisableAutomatedSecurityFixesReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling or disabling automated security fixes is currently available for
	developers to preview. To access this new endpoint during the preview period,
	you must set this to true.
	*/
	LondonPreview bool
}

func (r *ReposDisableAutomatedSecurityFixesReq) url() string {
	return r._url
}

func (r *ReposDisableAutomatedSecurityFixesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/automated-security-fixes", r.Owner, r.Repo)
}

func (r *ReposDisableAutomatedSecurityFixesReq) method() string {
	return "DELETE"
}

func (r *ReposDisableAutomatedSecurityFixesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDisableAutomatedSecurityFixesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"london": r.LondonPreview}
	if requiredPreviews {
		previewVals["london"] = true
	}
	if allPreviews {
		previewVals["london"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDisableAutomatedSecurityFixesReq) body() interface{} {
	return nil
}

func (r *ReposDisableAutomatedSecurityFixesReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDisableAutomatedSecurityFixesReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDisableAutomatedSecurityFixesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposDisableAutomatedSecurityFixesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDisableAutomatedSecurityFixesReq) Rel(link RelName, resp *ReposDisableAutomatedSecurityFixesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDisableAutomatedSecurityFixesResponse is a response for ReposDisableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
type ReposDisableAutomatedSecurityFixesResponse struct {
	response
	request *ReposDisableAutomatedSecurityFixesReq
}

/*
ReposDisablePagesSite performs requests for "repos/disable-pages-site"

Disable a Pages site.

  DELETE /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#disable-a-pages-site
*/
func (c *Client) ReposDisablePagesSite(ctx context.Context, req *ReposDisablePagesSiteReq, opt ...RequestOption) (*ReposDisablePagesSiteResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposDisablePagesSiteResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDisablePagesSiteReq is request data for Client.ReposDisablePagesSite

https://developer.github.com/v3/repos/pages/#disable-a-pages-site
*/
type ReposDisablePagesSiteReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling Pages in the Pages API is currently available for
	developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-03-14-enabling-disabling-pages/)
	preview for more details. To access the new endpoints during the preview period,
	you must set this to true.
	*/
	SwitcherooPreview bool
}

func (r *ReposDisablePagesSiteReq) url() string {
	return r._url
}

func (r *ReposDisablePagesSiteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo)
}

func (r *ReposDisablePagesSiteReq) method() string {
	return "DELETE"
}

func (r *ReposDisablePagesSiteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDisablePagesSiteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"switcheroo": r.SwitcherooPreview}
	if requiredPreviews {
		previewVals["switcheroo"] = true
	}
	if allPreviews {
		previewVals["switcheroo"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDisablePagesSiteReq) body() interface{} {
	return nil
}

func (r *ReposDisablePagesSiteReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDisablePagesSiteReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDisablePagesSiteReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposDisablePagesSiteReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDisablePagesSiteReq) Rel(link RelName, resp *ReposDisablePagesSiteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDisablePagesSiteResponse is a response for ReposDisablePagesSite

https://developer.github.com/v3/repos/pages/#disable-a-pages-site
*/
type ReposDisablePagesSiteResponse struct {
	response
	request *ReposDisablePagesSiteReq
}

/*
ReposDisableVulnerabilityAlerts performs requests for "repos/disable-vulnerability-alerts"

Disable vulnerability alerts.

  DELETE /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
func (c *Client) ReposDisableVulnerabilityAlerts(ctx context.Context, req *ReposDisableVulnerabilityAlertsReq, opt ...RequestOption) (*ReposDisableVulnerabilityAlertsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposDisableVulnerabilityAlertsResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDisableVulnerabilityAlertsReq is request data for Client.ReposDisableVulnerabilityAlerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
type ReposDisableVulnerabilityAlertsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling vulnerability alerts for a repository using the REST API
	is currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

func (r *ReposDisableVulnerabilityAlertsReq) url() string {
	return r._url
}

func (r *ReposDisableVulnerabilityAlertsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo)
}

func (r *ReposDisableVulnerabilityAlertsReq) method() string {
	return "DELETE"
}

func (r *ReposDisableVulnerabilityAlertsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDisableVulnerabilityAlertsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"dorian": r.DorianPreview}
	if requiredPreviews {
		previewVals["dorian"] = true
	}
	if allPreviews {
		previewVals["dorian"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDisableVulnerabilityAlertsReq) body() interface{} {
	return nil
}

func (r *ReposDisableVulnerabilityAlertsReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDisableVulnerabilityAlertsReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDisableVulnerabilityAlertsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposDisableVulnerabilityAlertsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDisableVulnerabilityAlertsReq) Rel(link RelName, resp *ReposDisableVulnerabilityAlertsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDisableVulnerabilityAlertsResponse is a response for ReposDisableVulnerabilityAlerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
type ReposDisableVulnerabilityAlertsResponse struct {
	response
	request *ReposDisableVulnerabilityAlertsReq
}

/*
ReposEnableAutomatedSecurityFixes performs requests for "repos/enable-automated-security-fixes"

Enable automated security fixes.

  PUT /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
func (c *Client) ReposEnableAutomatedSecurityFixes(ctx context.Context, req *ReposEnableAutomatedSecurityFixesReq, opt ...RequestOption) (*ReposEnableAutomatedSecurityFixesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposEnableAutomatedSecurityFixesResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposEnableAutomatedSecurityFixesReq is request data for Client.ReposEnableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
type ReposEnableAutomatedSecurityFixesReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling or disabling automated security fixes is currently available for
	developers to preview. To access this new endpoint during the preview period,
	you must set this to true.
	*/
	LondonPreview bool
}

func (r *ReposEnableAutomatedSecurityFixesReq) url() string {
	return r._url
}

func (r *ReposEnableAutomatedSecurityFixesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/automated-security-fixes", r.Owner, r.Repo)
}

func (r *ReposEnableAutomatedSecurityFixesReq) method() string {
	return "PUT"
}

func (r *ReposEnableAutomatedSecurityFixesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposEnableAutomatedSecurityFixesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"london": r.LondonPreview}
	if requiredPreviews {
		previewVals["london"] = true
	}
	if allPreviews {
		previewVals["london"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposEnableAutomatedSecurityFixesReq) body() interface{} {
	return nil
}

func (r *ReposEnableAutomatedSecurityFixesReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposEnableAutomatedSecurityFixesReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposEnableAutomatedSecurityFixesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposEnableAutomatedSecurityFixesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposEnableAutomatedSecurityFixesReq) Rel(link RelName, resp *ReposEnableAutomatedSecurityFixesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposEnableAutomatedSecurityFixesResponse is a response for ReposEnableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
type ReposEnableAutomatedSecurityFixesResponse struct {
	response
	request *ReposEnableAutomatedSecurityFixesReq
}

/*
ReposEnablePagesSite performs requests for "repos/enable-pages-site"

Enable a Pages site.

  POST /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#enable-a-pages-site
*/
func (c *Client) ReposEnablePagesSite(ctx context.Context, req *ReposEnablePagesSiteReq, opt ...RequestOption) (*ReposEnablePagesSiteResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposEnablePagesSiteResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposEnablePagesSiteResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposEnablePagesSiteReq is request data for Client.ReposEnablePagesSite

https://developer.github.com/v3/repos/pages/#enable-a-pages-site
*/
type ReposEnablePagesSiteReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposEnablePagesSiteReqBody

	/*
	Enabling and disabling Pages in the Pages API is currently available for
	developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-03-14-enabling-disabling-pages/)
	preview for more details. To access the new endpoints during the preview period,
	you must set this to true.
	*/
	SwitcherooPreview bool
}

func (r *ReposEnablePagesSiteReq) url() string {
	return r._url
}

func (r *ReposEnablePagesSiteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo)
}

func (r *ReposEnablePagesSiteReq) method() string {
	return "POST"
}

func (r *ReposEnablePagesSiteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposEnablePagesSiteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"switcheroo": r.SwitcherooPreview}
	if requiredPreviews {
		previewVals["switcheroo"] = true
	}
	if allPreviews {
		previewVals["switcheroo"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposEnablePagesSiteReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposEnablePagesSiteReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposEnablePagesSiteReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposEnablePagesSiteReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposEnablePagesSiteReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposEnablePagesSiteReq) Rel(link RelName, resp *ReposEnablePagesSiteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposEnablePagesSiteReqBodySource is a value for ReposEnablePagesSiteReqBody's Source field
type ReposEnablePagesSiteReqBodySource struct {

	/*
	   The repository branch used to publish your [site's source
	   files](https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/).
	   Can be either `master` or `gh-pages`.
	*/
	Branch *string `json:"branch,omitempty"`

	/*
	   The repository directory that includes the source files for the Pages site. When
	   `branch` is `master`, you can change `path` to `/docs`. When `branch` is
	   `gh-pages`, you are unable to specify a `path` other than `/`.
	*/
	Path *string `json:"path,omitempty"`
}

/*
ReposEnablePagesSiteReqBody is a request body for repos/enable-pages-site

https://developer.github.com/v3/repos/pages/#enable-a-pages-site
*/
type ReposEnablePagesSiteReqBody struct {
	Source *ReposEnablePagesSiteReqBodySource `json:"source,omitempty"`
}

/*
ReposEnablePagesSiteResponseBody is a response body for ReposEnablePagesSite

https://developer.github.com/v3/repos/pages/#enable-a-pages-site
*/
type ReposEnablePagesSiteResponseBody struct {
	components.Page
}

/*
ReposEnablePagesSiteResponse is a response for ReposEnablePagesSite

https://developer.github.com/v3/repos/pages/#enable-a-pages-site
*/
type ReposEnablePagesSiteResponse struct {
	response
	request *ReposEnablePagesSiteReq
	Data    *ReposEnablePagesSiteResponseBody
}

/*
ReposEnableVulnerabilityAlerts performs requests for "repos/enable-vulnerability-alerts"

Enable vulnerability alerts.

  PUT /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
func (c *Client) ReposEnableVulnerabilityAlerts(ctx context.Context, req *ReposEnableVulnerabilityAlertsReq, opt ...RequestOption) (*ReposEnableVulnerabilityAlertsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposEnableVulnerabilityAlertsResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposEnableVulnerabilityAlertsReq is request data for Client.ReposEnableVulnerabilityAlerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
type ReposEnableVulnerabilityAlertsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling vulnerability alerts for a repository using the REST API
	is currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

func (r *ReposEnableVulnerabilityAlertsReq) url() string {
	return r._url
}

func (r *ReposEnableVulnerabilityAlertsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo)
}

func (r *ReposEnableVulnerabilityAlertsReq) method() string {
	return "PUT"
}

func (r *ReposEnableVulnerabilityAlertsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposEnableVulnerabilityAlertsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"dorian": r.DorianPreview}
	if requiredPreviews {
		previewVals["dorian"] = true
	}
	if allPreviews {
		previewVals["dorian"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposEnableVulnerabilityAlertsReq) body() interface{} {
	return nil
}

func (r *ReposEnableVulnerabilityAlertsReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposEnableVulnerabilityAlertsReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposEnableVulnerabilityAlertsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposEnableVulnerabilityAlertsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposEnableVulnerabilityAlertsReq) Rel(link RelName, resp *ReposEnableVulnerabilityAlertsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposEnableVulnerabilityAlertsResponse is a response for ReposEnableVulnerabilityAlerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
type ReposEnableVulnerabilityAlertsResponse struct {
	response
	request *ReposEnableVulnerabilityAlertsReq
}

/*
ReposGet performs requests for "repos/get"

Get a repository.

  GET /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#get-a-repository
*/
func (c *Client) ReposGet(ctx context.Context, req *ReposGetReq, opt ...RequestOption) (*ReposGetResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetReq is request data for Client.ReposGet

https://developer.github.com/v3/repos/#get-a-repository
*/
type ReposGetReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	Developers can preview a new `code_of_conduct` key in responses. For more
	information, see [Codes of Conduct
	API](https://developer.github.com/v3/codes_of_conduct/).

	To access this new response key during the preview period, you must set this to
	true.
	*/
	ScarletWitchPreview bool
}

func (r *ReposGetReq) url() string {
	return r._url
}

func (r *ReposGetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo)
}

func (r *ReposGetReq) method() string {
	return "GET"
}

func (r *ReposGetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"nebula":        r.NebulaPreview,
		"scarlet-witch": r.ScarletWitchPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["scarlet-witch"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReq) body() interface{} {
	return nil
}

func (r *ReposGetReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReq) Rel(link RelName, resp *ReposGetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetResponseBody is a response body for ReposGet

https://developer.github.com/v3/repos/#get-a-repository
*/
type ReposGetResponseBody struct {
	components.FullRepository
}

/*
ReposGetResponse is a response for ReposGet

https://developer.github.com/v3/repos/#get-a-repository
*/
type ReposGetResponse struct {
	response
	request *ReposGetReq
	Data    *ReposGetResponseBody
}

/*
ReposGetAllTopics performs requests for "repos/get-all-topics"

Get all repository topics.

  GET /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
func (c *Client) ReposGetAllTopics(ctx context.Context, req *ReposGetAllTopicsReq, opt ...RequestOption) (*ReposGetAllTopicsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetAllTopicsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetAllTopicsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetAllTopicsReq is request data for Client.ReposGetAllTopics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
type ReposGetAllTopicsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

func (r *ReposGetAllTopicsReq) url() string {
	return r._url
}

func (r *ReposGetAllTopicsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/topics", r.Owner, r.Repo)
}

func (r *ReposGetAllTopicsReq) method() string {
	return "GET"
}

func (r *ReposGetAllTopicsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetAllTopicsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"mercy": r.MercyPreview}
	if requiredPreviews {
		previewVals["mercy"] = true
	}
	if allPreviews {
		previewVals["mercy"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetAllTopicsReq) body() interface{} {
	return nil
}

func (r *ReposGetAllTopicsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetAllTopicsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetAllTopicsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetAllTopicsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetAllTopicsReq) Rel(link RelName, resp *ReposGetAllTopicsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetAllTopicsResponseBody is a response body for ReposGetAllTopics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
type ReposGetAllTopicsResponseBody struct {
	components.Topic
}

/*
ReposGetAllTopicsResponse is a response for ReposGetAllTopics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
type ReposGetAllTopicsResponse struct {
	response
	request *ReposGetAllTopicsReq
	Data    *ReposGetAllTopicsResponseBody
}

/*
ReposGetAppsWithAccessToProtectedBranch performs requests for "repos/get-apps-with-access-to-protected-branch"

Get apps with access to protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-protected-branch
*/
func (c *Client) ReposGetAppsWithAccessToProtectedBranch(ctx context.Context, req *ReposGetAppsWithAccessToProtectedBranchReq, opt ...RequestOption) (*ReposGetAppsWithAccessToProtectedBranchResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetAppsWithAccessToProtectedBranchResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetAppsWithAccessToProtectedBranchResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetAppsWithAccessToProtectedBranchReq is request data for Client.ReposGetAppsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-protected-branch
*/
type ReposGetAppsWithAccessToProtectedBranchReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) url() string {
	return r._url
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) method() string {
	return "GET"
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) body() interface{} {
	return nil
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetAppsWithAccessToProtectedBranchReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetAppsWithAccessToProtectedBranchReq) Rel(link RelName, resp *ReposGetAppsWithAccessToProtectedBranchResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetAppsWithAccessToProtectedBranchResponseBody is a response body for ReposGetAppsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-protected-branch
*/
type ReposGetAppsWithAccessToProtectedBranchResponseBody []struct {
	components.Integration2
}

/*
ReposGetAppsWithAccessToProtectedBranchResponse is a response for ReposGetAppsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-protected-branch
*/
type ReposGetAppsWithAccessToProtectedBranchResponse struct {
	response
	request *ReposGetAppsWithAccessToProtectedBranchReq
	Data    *ReposGetAppsWithAccessToProtectedBranchResponseBody
}

/*
ReposGetArchiveLink performs requests for "repos/get-archive-link"

Get archive link.

  GET /repos/{owner}/{repo}/{archive_format}/{ref}

https://developer.github.com/v3/repos/contents/#get-archive-link
*/
func (c *Client) ReposGetArchiveLink(ctx context.Context, req *ReposGetArchiveLinkReq, opt ...RequestOption) (*ReposGetArchiveLinkResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetArchiveLinkResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetArchiveLinkReq is request data for Client.ReposGetArchiveLink

https://developer.github.com/v3/repos/contents/#get-archive-link
*/
type ReposGetArchiveLinkReq struct {
	_url          string
	Owner         string
	Repo          string
	ArchiveFormat string
	Ref           string
}

func (r *ReposGetArchiveLinkReq) url() string {
	return r._url
}

func (r *ReposGetArchiveLinkReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/%v/%v", r.Owner, r.Repo, r.ArchiveFormat, r.Ref)
}

func (r *ReposGetArchiveLinkReq) method() string {
	return "GET"
}

func (r *ReposGetArchiveLinkReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetArchiveLinkReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetArchiveLinkReq) body() interface{} {
	return nil
}

func (r *ReposGetArchiveLinkReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposGetArchiveLinkReq) validStatuses() []int {
	return []int{302}
}

func (r *ReposGetArchiveLinkReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrRedirectOnly}
}

// httpRequest creates an http request
func (r *ReposGetArchiveLinkReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetArchiveLinkReq) Rel(link RelName, resp *ReposGetArchiveLinkResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetArchiveLinkResponse is a response for ReposGetArchiveLink

https://developer.github.com/v3/repos/contents/#get-archive-link
*/
type ReposGetArchiveLinkResponse struct {
	response
	request *ReposGetArchiveLinkReq
}

/*
ReposGetBranch performs requests for "repos/get-branch"

Get branch.

  GET /repos/{owner}/{repo}/branches/{branch}

https://developer.github.com/v3/repos/branches/#get-branch
*/
func (c *Client) ReposGetBranch(ctx context.Context, req *ReposGetBranchReq, opt ...RequestOption) (*ReposGetBranchResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetBranchResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetBranchResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetBranchReq is request data for Client.ReposGetBranch

https://developer.github.com/v3/repos/branches/#get-branch
*/
type ReposGetBranchReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetBranchReq) url() string {
	return r._url
}

func (r *ReposGetBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetBranchReq) method() string {
	return "GET"
}

func (r *ReposGetBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetBranchReq) body() interface{} {
	return nil
}

func (r *ReposGetBranchReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetBranchReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetBranchReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetBranchReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetBranchReq) Rel(link RelName, resp *ReposGetBranchResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetBranchResponseBody is a response body for ReposGetBranch

https://developer.github.com/v3/repos/branches/#get-branch
*/
type ReposGetBranchResponseBody struct {
	components.BranchWithProtection
}

/*
ReposGetBranchResponse is a response for ReposGetBranch

https://developer.github.com/v3/repos/branches/#get-branch
*/
type ReposGetBranchResponse struct {
	response
	request *ReposGetBranchReq
	Data    *ReposGetBranchResponseBody
}

/*
ReposGetBranchProtection performs requests for "repos/get-branch-protection"

Get branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
func (c *Client) ReposGetBranchProtection(ctx context.Context, req *ReposGetBranchProtectionReq, opt ...RequestOption) (*ReposGetBranchProtectionResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetBranchProtectionResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetBranchProtectionResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetBranchProtectionReq is request data for Client.ReposGetBranchProtection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
type ReposGetBranchProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

func (r *ReposGetBranchProtectionReq) url() string {
	return r._url
}

func (r *ReposGetBranchProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetBranchProtectionReq) method() string {
	return "GET"
}

func (r *ReposGetBranchProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetBranchProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"luke-cage": r.LukeCagePreview}
	if allPreviews {
		previewVals["luke-cage"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetBranchProtectionReq) body() interface{} {
	return nil
}

func (r *ReposGetBranchProtectionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetBranchProtectionReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetBranchProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetBranchProtectionReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetBranchProtectionReq) Rel(link RelName, resp *ReposGetBranchProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetBranchProtectionResponseBody is a response body for ReposGetBranchProtection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
type ReposGetBranchProtectionResponseBody struct {
	components.BranchProtection
}

/*
ReposGetBranchProtectionResponse is a response for ReposGetBranchProtection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
type ReposGetBranchProtectionResponse struct {
	response
	request *ReposGetBranchProtectionReq
	Data    *ReposGetBranchProtectionResponseBody
}

/*
ReposGetClones performs requests for "repos/get-clones"

Clones.

  GET /repos/{owner}/{repo}/traffic/clones

https://developer.github.com/v3/repos/traffic/#clones
*/
func (c *Client) ReposGetClones(ctx context.Context, req *ReposGetClonesReq, opt ...RequestOption) (*ReposGetClonesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetClonesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetClonesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetClonesReq is request data for Client.ReposGetClones

https://developer.github.com/v3/repos/traffic/#clones
*/
type ReposGetClonesReq struct {
	_url  string
	Owner string
	Repo  string

	// Must be one of: `day`, `week`.
	Per *string
}

func (r *ReposGetClonesReq) url() string {
	return r._url
}

func (r *ReposGetClonesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/traffic/clones", r.Owner, r.Repo)
}

func (r *ReposGetClonesReq) method() string {
	return "GET"
}

func (r *ReposGetClonesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Per != nil {
		query.Set("per", *r.Per)
	}
	return query
}

func (r *ReposGetClonesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetClonesReq) body() interface{} {
	return nil
}

func (r *ReposGetClonesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetClonesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetClonesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetClonesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetClonesReq) Rel(link RelName, resp *ReposGetClonesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetClonesResponseBody is a response body for ReposGetClones

https://developer.github.com/v3/repos/traffic/#clones
*/
type ReposGetClonesResponseBody struct {
	components.CloneTraffic
}

/*
ReposGetClonesResponse is a response for ReposGetClones

https://developer.github.com/v3/repos/traffic/#clones
*/
type ReposGetClonesResponse struct {
	response
	request *ReposGetClonesReq
	Data    *ReposGetClonesResponseBody
}

/*
ReposGetCodeFrequencyStats performs requests for "repos/get-code-frequency-stats"

Get the number of additions and deletions per week.

  GET /repos/{owner}/{repo}/stats/code_frequency

https://developer.github.com/v3/repos/statistics/#get-the-number-of-additions-and-deletions-per-week
*/
func (c *Client) ReposGetCodeFrequencyStats(ctx context.Context, req *ReposGetCodeFrequencyStatsReq, opt ...RequestOption) (*ReposGetCodeFrequencyStatsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetCodeFrequencyStatsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetCodeFrequencyStatsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCodeFrequencyStatsReq is request data for Client.ReposGetCodeFrequencyStats

https://developer.github.com/v3/repos/statistics/#get-the-number-of-additions-and-deletions-per-week
*/
type ReposGetCodeFrequencyStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetCodeFrequencyStatsReq) url() string {
	return r._url
}

func (r *ReposGetCodeFrequencyStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/code_frequency", r.Owner, r.Repo)
}

func (r *ReposGetCodeFrequencyStatsReq) method() string {
	return "GET"
}

func (r *ReposGetCodeFrequencyStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCodeFrequencyStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCodeFrequencyStatsReq) body() interface{} {
	return nil
}

func (r *ReposGetCodeFrequencyStatsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCodeFrequencyStatsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCodeFrequencyStatsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetCodeFrequencyStatsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCodeFrequencyStatsReq) Rel(link RelName, resp *ReposGetCodeFrequencyStatsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCodeFrequencyStatsResponseBody is a response body for ReposGetCodeFrequencyStats

https://developer.github.com/v3/repos/statistics/#get-the-number-of-additions-and-deletions-per-week
*/
type ReposGetCodeFrequencyStatsResponseBody []struct {
	components.CodeFrequencyStat
}

/*
ReposGetCodeFrequencyStatsResponse is a response for ReposGetCodeFrequencyStats

https://developer.github.com/v3/repos/statistics/#get-the-number-of-additions-and-deletions-per-week
*/
type ReposGetCodeFrequencyStatsResponse struct {
	response
	request *ReposGetCodeFrequencyStatsReq
	Data    *ReposGetCodeFrequencyStatsResponseBody
}

/*
ReposGetCollaboratorPermissionLevel performs requests for "repos/get-collaborator-permission-level"

Review a user's permission level.

  GET /repos/{owner}/{repo}/collaborators/{username}/permission

https://developer.github.com/v3/repos/collaborators/#review-a-users-permission-level
*/
func (c *Client) ReposGetCollaboratorPermissionLevel(ctx context.Context, req *ReposGetCollaboratorPermissionLevelReq, opt ...RequestOption) (*ReposGetCollaboratorPermissionLevelResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetCollaboratorPermissionLevelResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetCollaboratorPermissionLevelResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCollaboratorPermissionLevelReq is request data for Client.ReposGetCollaboratorPermissionLevel

https://developer.github.com/v3/repos/collaborators/#review-a-users-permission-level
*/
type ReposGetCollaboratorPermissionLevelReq struct {
	_url     string
	Owner    string
	Repo     string
	Username string
}

func (r *ReposGetCollaboratorPermissionLevelReq) url() string {
	return r._url
}

func (r *ReposGetCollaboratorPermissionLevelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators/%v/permission", r.Owner, r.Repo, r.Username)
}

func (r *ReposGetCollaboratorPermissionLevelReq) method() string {
	return "GET"
}

func (r *ReposGetCollaboratorPermissionLevelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCollaboratorPermissionLevelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCollaboratorPermissionLevelReq) body() interface{} {
	return nil
}

func (r *ReposGetCollaboratorPermissionLevelReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCollaboratorPermissionLevelReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCollaboratorPermissionLevelReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetCollaboratorPermissionLevelReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCollaboratorPermissionLevelReq) Rel(link RelName, resp *ReposGetCollaboratorPermissionLevelResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCollaboratorPermissionLevelResponseBody is a response body for ReposGetCollaboratorPermissionLevel

https://developer.github.com/v3/repos/collaborators/#review-a-users-permission-level
*/
type ReposGetCollaboratorPermissionLevelResponseBody struct {
	components.RepositoryCollaboratorPermission
}

/*
ReposGetCollaboratorPermissionLevelResponse is a response for ReposGetCollaboratorPermissionLevel

https://developer.github.com/v3/repos/collaborators/#review-a-users-permission-level
*/
type ReposGetCollaboratorPermissionLevelResponse struct {
	response
	request *ReposGetCollaboratorPermissionLevelReq
	Data    *ReposGetCollaboratorPermissionLevelResponseBody
}

/*
ReposGetCombinedStatusForRef performs requests for "repos/get-combined-status-for-ref"

Get the combined status for a specific ref.

  GET /repos/{owner}/{repo}/commits/{ref}/status

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
*/
func (c *Client) ReposGetCombinedStatusForRef(ctx context.Context, req *ReposGetCombinedStatusForRefReq, opt ...RequestOption) (*ReposGetCombinedStatusForRefResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetCombinedStatusForRefResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetCombinedStatusForRefResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCombinedStatusForRefReq is request data for Client.ReposGetCombinedStatusForRef

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
*/
type ReposGetCombinedStatusForRefReq struct {
	_url  string
	Owner string
	Repo  string
	Ref   string
}

func (r *ReposGetCombinedStatusForRefReq) url() string {
	return r._url
}

func (r *ReposGetCombinedStatusForRefReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/status", r.Owner, r.Repo, r.Ref)
}

func (r *ReposGetCombinedStatusForRefReq) method() string {
	return "GET"
}

func (r *ReposGetCombinedStatusForRefReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCombinedStatusForRefReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCombinedStatusForRefReq) body() interface{} {
	return nil
}

func (r *ReposGetCombinedStatusForRefReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCombinedStatusForRefReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCombinedStatusForRefReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetCombinedStatusForRefReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCombinedStatusForRefReq) Rel(link RelName, resp *ReposGetCombinedStatusForRefResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCombinedStatusForRefResponseBody is a response body for ReposGetCombinedStatusForRef

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
*/
type ReposGetCombinedStatusForRefResponseBody struct {
	components.CombinedCommitStatus
}

/*
ReposGetCombinedStatusForRefResponse is a response for ReposGetCombinedStatusForRef

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
*/
type ReposGetCombinedStatusForRefResponse struct {
	response
	request *ReposGetCombinedStatusForRefReq
	Data    *ReposGetCombinedStatusForRefResponseBody
}

/*
ReposGetCommit performs requests for "repos/get-commit"

Get a single commit.

  GET /repos/{owner}/{repo}/commits/{ref}

https://developer.github.com/v3/repos/commits/#get-a-single-commit
*/
func (c *Client) ReposGetCommit(ctx context.Context, req *ReposGetCommitReq, opt ...RequestOption) (*ReposGetCommitResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetCommitResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetCommitResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCommitReq is request data for Client.ReposGetCommit

https://developer.github.com/v3/repos/commits/#get-a-single-commit
*/
type ReposGetCommitReq struct {
	_url  string
	Owner string
	Repo  string
	Ref   string
}

func (r *ReposGetCommitReq) url() string {
	return r._url
}

func (r *ReposGetCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v", r.Owner, r.Repo, r.Ref)
}

func (r *ReposGetCommitReq) method() string {
	return "GET"
}

func (r *ReposGetCommitReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCommitReq) body() interface{} {
	return nil
}

func (r *ReposGetCommitReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetCommitReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCommitReq) Rel(link RelName, resp *ReposGetCommitResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCommitResponseBody is a response body for ReposGetCommit

https://developer.github.com/v3/repos/commits/#get-a-single-commit
*/
type ReposGetCommitResponseBody struct {
	components.Commit
}

/*
ReposGetCommitResponse is a response for ReposGetCommit

https://developer.github.com/v3/repos/commits/#get-a-single-commit
*/
type ReposGetCommitResponse struct {
	response
	request *ReposGetCommitReq
	Data    *ReposGetCommitResponseBody
}

/*
ReposGetCommitActivityStats performs requests for "repos/get-commit-activity-stats"

Get the last year of commit activity data.

  GET /repos/{owner}/{repo}/stats/commit_activity

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data
*/
func (c *Client) ReposGetCommitActivityStats(ctx context.Context, req *ReposGetCommitActivityStatsReq, opt ...RequestOption) (*ReposGetCommitActivityStatsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetCommitActivityStatsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetCommitActivityStatsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCommitActivityStatsReq is request data for Client.ReposGetCommitActivityStats

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data
*/
type ReposGetCommitActivityStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetCommitActivityStatsReq) url() string {
	return r._url
}

func (r *ReposGetCommitActivityStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/commit_activity", r.Owner, r.Repo)
}

func (r *ReposGetCommitActivityStatsReq) method() string {
	return "GET"
}

func (r *ReposGetCommitActivityStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCommitActivityStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCommitActivityStatsReq) body() interface{} {
	return nil
}

func (r *ReposGetCommitActivityStatsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitActivityStatsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitActivityStatsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetCommitActivityStatsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCommitActivityStatsReq) Rel(link RelName, resp *ReposGetCommitActivityStatsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCommitActivityStatsResponseBody is a response body for ReposGetCommitActivityStats

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data
*/
type ReposGetCommitActivityStatsResponseBody []struct {
	components.CommitActivity
}

/*
ReposGetCommitActivityStatsResponse is a response for ReposGetCommitActivityStats

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data
*/
type ReposGetCommitActivityStatsResponse struct {
	response
	request *ReposGetCommitActivityStatsReq
	Data    *ReposGetCommitActivityStatsResponseBody
}

/*
ReposGetCommitComment performs requests for "repos/get-commit-comment"

Get a single commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#get-a-single-commit-comment
*/
func (c *Client) ReposGetCommitComment(ctx context.Context, req *ReposGetCommitCommentReq, opt ...RequestOption) (*ReposGetCommitCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetCommitCommentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetCommitCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCommitCommentReq is request data for Client.ReposGetCommitComment

https://developer.github.com/v3/repos/comments/#get-a-single-commit-comment
*/
type ReposGetCommitCommentReq struct {
	_url      string
	Owner     string
	Repo      string
	CommentId int64

	/*
	An additional `reactions` object in the commit comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReposGetCommitCommentReq) url() string {
	return r._url
}

func (r *ReposGetCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *ReposGetCommitCommentReq) method() string {
	return "GET"
}

func (r *ReposGetCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCommitCommentReq) body() interface{} {
	return nil
}

func (r *ReposGetCommitCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetCommitCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCommitCommentReq) Rel(link RelName, resp *ReposGetCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCommitCommentResponseBody is a response body for ReposGetCommitComment

https://developer.github.com/v3/repos/comments/#get-a-single-commit-comment
*/
type ReposGetCommitCommentResponseBody struct {
	components.CommitComment
}

/*
ReposGetCommitCommentResponse is a response for ReposGetCommitComment

https://developer.github.com/v3/repos/comments/#get-a-single-commit-comment
*/
type ReposGetCommitCommentResponse struct {
	response
	request *ReposGetCommitCommentReq
	Data    *ReposGetCommitCommentResponseBody
}

/*
ReposGetContents performs requests for "repos/get-contents"

Get contents.

  GET /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#get-contents
*/
func (c *Client) ReposGetContents(ctx context.Context, req *ReposGetContentsReq, opt ...RequestOption) (*ReposGetContentsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetContentsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetContentsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetContentsReq is request data for Client.ReposGetContents

https://developer.github.com/v3/repos/contents/#get-contents
*/
type ReposGetContentsReq struct {
	_url  string
	Owner string
	Repo  string
	Path  string

	/*
	The name of the commit/branch/tag. Default: the repositorys default branch
	(usually `master`)
	*/
	Ref *string
}

func (r *ReposGetContentsReq) url() string {
	return r._url
}

func (r *ReposGetContentsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path)
}

func (r *ReposGetContentsReq) method() string {
	return "GET"
}

func (r *ReposGetContentsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}
	return query
}

func (r *ReposGetContentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetContentsReq) body() interface{} {
	return nil
}

func (r *ReposGetContentsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetContentsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetContentsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetContentsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetContentsReq) Rel(link RelName, resp *ReposGetContentsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetContentsResponseBody is a response body for ReposGetContents

https://developer.github.com/v3/repos/contents/#get-contents
*/
type ReposGetContentsResponseBody struct {
	components.ContentFile
}

/*
ReposGetContentsResponse is a response for ReposGetContents

https://developer.github.com/v3/repos/contents/#get-contents
*/
type ReposGetContentsResponse struct {
	response
	request *ReposGetContentsReq
	Data    *ReposGetContentsResponseBody
}

/*
ReposGetContributorsStats performs requests for "repos/get-contributors-stats"

Get contributors list with additions, deletions, and commit counts.

  GET /repos/{owner}/{repo}/stats/contributors

https://developer.github.com/v3/repos/statistics/#get-contributors-list-with-additions-deletions-and-commit-counts
*/
func (c *Client) ReposGetContributorsStats(ctx context.Context, req *ReposGetContributorsStatsReq, opt ...RequestOption) (*ReposGetContributorsStatsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetContributorsStatsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetContributorsStatsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetContributorsStatsReq is request data for Client.ReposGetContributorsStats

https://developer.github.com/v3/repos/statistics/#get-contributors-list-with-additions-deletions-and-commit-counts
*/
type ReposGetContributorsStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetContributorsStatsReq) url() string {
	return r._url
}

func (r *ReposGetContributorsStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/contributors", r.Owner, r.Repo)
}

func (r *ReposGetContributorsStatsReq) method() string {
	return "GET"
}

func (r *ReposGetContributorsStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetContributorsStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetContributorsStatsReq) body() interface{} {
	return nil
}

func (r *ReposGetContributorsStatsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetContributorsStatsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetContributorsStatsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetContributorsStatsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetContributorsStatsReq) Rel(link RelName, resp *ReposGetContributorsStatsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetContributorsStatsResponseBody is a response body for ReposGetContributorsStats

https://developer.github.com/v3/repos/statistics/#get-contributors-list-with-additions-deletions-and-commit-counts
*/
type ReposGetContributorsStatsResponseBody []struct {
	components.ContributorActivity
}

/*
ReposGetContributorsStatsResponse is a response for ReposGetContributorsStats

https://developer.github.com/v3/repos/statistics/#get-contributors-list-with-additions-deletions-and-commit-counts
*/
type ReposGetContributorsStatsResponse struct {
	response
	request *ReposGetContributorsStatsReq
	Data    *ReposGetContributorsStatsResponseBody
}

/*
ReposGetDeployKey performs requests for "repos/get-deploy-key"

Get a deploy key.

  GET /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
func (c *Client) ReposGetDeployKey(ctx context.Context, req *ReposGetDeployKeyReq, opt ...RequestOption) (*ReposGetDeployKeyResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetDeployKeyResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetDeployKeyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetDeployKeyReq is request data for Client.ReposGetDeployKey

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
type ReposGetDeployKeyReq struct {
	_url  string
	Owner string
	Repo  string
	KeyId int64
}

func (r *ReposGetDeployKeyReq) url() string {
	return r._url
}

func (r *ReposGetDeployKeyReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/keys/%v", r.Owner, r.Repo, r.KeyId)
}

func (r *ReposGetDeployKeyReq) method() string {
	return "GET"
}

func (r *ReposGetDeployKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetDeployKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetDeployKeyReq) body() interface{} {
	return nil
}

func (r *ReposGetDeployKeyReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetDeployKeyReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetDeployKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetDeployKeyReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetDeployKeyReq) Rel(link RelName, resp *ReposGetDeployKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetDeployKeyResponseBody is a response body for ReposGetDeployKey

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
type ReposGetDeployKeyResponseBody struct {
	components.DeployKey
}

/*
ReposGetDeployKeyResponse is a response for ReposGetDeployKey

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
type ReposGetDeployKeyResponse struct {
	response
	request *ReposGetDeployKeyReq
	Data    *ReposGetDeployKeyResponseBody
}

/*
ReposGetDeployment performs requests for "repos/get-deployment"

Get a single deployment.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#get-a-single-deployment
*/
func (c *Client) ReposGetDeployment(ctx context.Context, req *ReposGetDeploymentReq, opt ...RequestOption) (*ReposGetDeploymentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetDeploymentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetDeploymentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetDeploymentReq is request data for Client.ReposGetDeployment

https://developer.github.com/v3/repos/deployments/#get-a-single-deployment
*/
type ReposGetDeploymentReq struct {
	_url         string
	Owner        string
	Repo         string
	DeploymentId int64

	/*
	If a deployment is created via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	The `transient_environment` and `production_environment` parameters are
	currently available for developers to preview. During the preview period, the
	API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposGetDeploymentReq) url() string {
	return r._url
}

func (r *ReposGetDeploymentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v", r.Owner, r.Repo, r.DeploymentId)
}

func (r *ReposGetDeploymentReq) method() string {
	return "GET"
}

func (r *ReposGetDeploymentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetDeploymentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"ant-man":     r.AntManPreview,
		"machine-man": r.MachineManPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetDeploymentReq) body() interface{} {
	return nil
}

func (r *ReposGetDeploymentReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetDeploymentReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetDeploymentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetDeploymentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetDeploymentReq) Rel(link RelName, resp *ReposGetDeploymentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetDeploymentResponseBody is a response body for ReposGetDeployment

https://developer.github.com/v3/repos/deployments/#get-a-single-deployment
*/
type ReposGetDeploymentResponseBody struct {
	components.Deployment
}

/*
ReposGetDeploymentResponse is a response for ReposGetDeployment

https://developer.github.com/v3/repos/deployments/#get-a-single-deployment
*/
type ReposGetDeploymentResponse struct {
	response
	request *ReposGetDeploymentReq
	Data    *ReposGetDeploymentResponseBody
}

/*
ReposGetDeploymentStatus performs requests for "repos/get-deployment-status"

Get a single deployment status.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}

https://developer.github.com/v3/repos/deployments/#get-a-single-deployment-status
*/
func (c *Client) ReposGetDeploymentStatus(ctx context.Context, req *ReposGetDeploymentStatusReq, opt ...RequestOption) (*ReposGetDeploymentStatusResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetDeploymentStatusResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetDeploymentStatusResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetDeploymentStatusReq is request data for Client.ReposGetDeploymentStatus

https://developer.github.com/v3/repos/deployments/#get-a-single-deployment-status
*/
type ReposGetDeploymentStatusReq struct {
	_url         string
	Owner        string
	Repo         string
	DeploymentId int64
	StatusId     int64

	/*
	If a deployment is created via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposGetDeploymentStatusReq) url() string {
	return r._url
}

func (r *ReposGetDeploymentStatusReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses/%v", r.Owner, r.Repo, r.DeploymentId, r.StatusId)
}

func (r *ReposGetDeploymentStatusReq) method() string {
	return "GET"
}

func (r *ReposGetDeploymentStatusReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetDeploymentStatusReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"ant-man":     r.AntManPreview,
		"flash":       r.FlashPreview,
		"machine-man": r.MachineManPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["flash"] = true
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetDeploymentStatusReq) body() interface{} {
	return nil
}

func (r *ReposGetDeploymentStatusReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetDeploymentStatusReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetDeploymentStatusReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetDeploymentStatusReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetDeploymentStatusReq) Rel(link RelName, resp *ReposGetDeploymentStatusResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetDeploymentStatusResponseBody is a response body for ReposGetDeploymentStatus

https://developer.github.com/v3/repos/deployments/#get-a-single-deployment-status
*/
type ReposGetDeploymentStatusResponseBody struct {
	components.DeploymentStatus
}

/*
ReposGetDeploymentStatusResponse is a response for ReposGetDeploymentStatus

https://developer.github.com/v3/repos/deployments/#get-a-single-deployment-status
*/
type ReposGetDeploymentStatusResponse struct {
	response
	request *ReposGetDeploymentStatusReq
	Data    *ReposGetDeploymentStatusResponseBody
}

/*
ReposGetDownload performs requests for "repos/get-download"

Get a single download.

  GET /repos/{owner}/{repo}/downloads/{download_id}

https://developer.github.com/v3/repos/downloads/#get-a-single-download
*/
func (c *Client) ReposGetDownload(ctx context.Context, req *ReposGetDownloadReq, opt ...RequestOption) (*ReposGetDownloadResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetDownloadResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetDownloadResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetDownloadReq is request data for Client.ReposGetDownload

https://developer.github.com/v3/repos/downloads/#get-a-single-download
*/
type ReposGetDownloadReq struct {
	_url       string
	Owner      string
	Repo       string
	DownloadId int64
}

func (r *ReposGetDownloadReq) url() string {
	return r._url
}

func (r *ReposGetDownloadReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/downloads/%v", r.Owner, r.Repo, r.DownloadId)
}

func (r *ReposGetDownloadReq) method() string {
	return "GET"
}

func (r *ReposGetDownloadReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetDownloadReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetDownloadReq) body() interface{} {
	return nil
}

func (r *ReposGetDownloadReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetDownloadReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetDownloadReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetDownloadReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetDownloadReq) Rel(link RelName, resp *ReposGetDownloadResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetDownloadResponseBody is a response body for ReposGetDownload

https://developer.github.com/v3/repos/downloads/#get-a-single-download
*/
type ReposGetDownloadResponseBody struct {
	components.Download
}

/*
ReposGetDownloadResponse is a response for ReposGetDownload

https://developer.github.com/v3/repos/downloads/#get-a-single-download
*/
type ReposGetDownloadResponse struct {
	response
	request *ReposGetDownloadReq
	Data    *ReposGetDownloadResponseBody
}

/*
ReposGetHook performs requests for "repos/get-hook"

Get single hook.

  GET /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#get-single-hook
*/
func (c *Client) ReposGetHook(ctx context.Context, req *ReposGetHookReq, opt ...RequestOption) (*ReposGetHookResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetHookResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetHookResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetHookReq is request data for Client.ReposGetHook

https://developer.github.com/v3/repos/hooks/#get-single-hook
*/
type ReposGetHookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

func (r *ReposGetHookReq) url() string {
	return r._url
}

func (r *ReposGetHookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId)
}

func (r *ReposGetHookReq) method() string {
	return "GET"
}

func (r *ReposGetHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetHookReq) body() interface{} {
	return nil
}

func (r *ReposGetHookReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetHookReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetHookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetHookReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetHookReq) Rel(link RelName, resp *ReposGetHookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetHookResponseBody is a response body for ReposGetHook

https://developer.github.com/v3/repos/hooks/#get-single-hook
*/
type ReposGetHookResponseBody struct {
	components.Hook
}

/*
ReposGetHookResponse is a response for ReposGetHook

https://developer.github.com/v3/repos/hooks/#get-single-hook
*/
type ReposGetHookResponse struct {
	response
	request *ReposGetHookReq
	Data    *ReposGetHookResponseBody
}

/*
ReposGetLatestPagesBuild performs requests for "repos/get-latest-pages-build"

Get latest Pages build.

  GET /repos/{owner}/{repo}/pages/builds/latest

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
func (c *Client) ReposGetLatestPagesBuild(ctx context.Context, req *ReposGetLatestPagesBuildReq, opt ...RequestOption) (*ReposGetLatestPagesBuildResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetLatestPagesBuildResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetLatestPagesBuildResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetLatestPagesBuildReq is request data for Client.ReposGetLatestPagesBuild

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
type ReposGetLatestPagesBuildReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetLatestPagesBuildReq) url() string {
	return r._url
}

func (r *ReposGetLatestPagesBuildReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages/builds/latest", r.Owner, r.Repo)
}

func (r *ReposGetLatestPagesBuildReq) method() string {
	return "GET"
}

func (r *ReposGetLatestPagesBuildReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetLatestPagesBuildReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetLatestPagesBuildReq) body() interface{} {
	return nil
}

func (r *ReposGetLatestPagesBuildReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetLatestPagesBuildReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetLatestPagesBuildReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetLatestPagesBuildReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetLatestPagesBuildReq) Rel(link RelName, resp *ReposGetLatestPagesBuildResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetLatestPagesBuildResponseBody is a response body for ReposGetLatestPagesBuild

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
type ReposGetLatestPagesBuildResponseBody struct {
	components.PageBuild
}

/*
ReposGetLatestPagesBuildResponse is a response for ReposGetLatestPagesBuild

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
type ReposGetLatestPagesBuildResponse struct {
	response
	request *ReposGetLatestPagesBuildReq
	Data    *ReposGetLatestPagesBuildResponseBody
}

/*
ReposGetLatestRelease performs requests for "repos/get-latest-release"

Get the latest release.

  GET /repos/{owner}/{repo}/releases/latest

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
func (c *Client) ReposGetLatestRelease(ctx context.Context, req *ReposGetLatestReleaseReq, opt ...RequestOption) (*ReposGetLatestReleaseResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetLatestReleaseResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetLatestReleaseResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetLatestReleaseReq is request data for Client.ReposGetLatestRelease

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
type ReposGetLatestReleaseReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetLatestReleaseReq) url() string {
	return r._url
}

func (r *ReposGetLatestReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/latest", r.Owner, r.Repo)
}

func (r *ReposGetLatestReleaseReq) method() string {
	return "GET"
}

func (r *ReposGetLatestReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetLatestReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetLatestReleaseReq) body() interface{} {
	return nil
}

func (r *ReposGetLatestReleaseReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetLatestReleaseReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetLatestReleaseReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetLatestReleaseReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetLatestReleaseReq) Rel(link RelName, resp *ReposGetLatestReleaseResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetLatestReleaseResponseBody is a response body for ReposGetLatestRelease

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
type ReposGetLatestReleaseResponseBody struct {
	components.Release2
}

/*
ReposGetLatestReleaseResponse is a response for ReposGetLatestRelease

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
type ReposGetLatestReleaseResponse struct {
	response
	request *ReposGetLatestReleaseReq
	Data    *ReposGetLatestReleaseResponseBody
}

/*
ReposGetPages performs requests for "repos/get-pages"

Get information about a Pages site.

  GET /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#get-information-about-a-pages-site
*/
func (c *Client) ReposGetPages(ctx context.Context, req *ReposGetPagesReq, opt ...RequestOption) (*ReposGetPagesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetPagesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetPagesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetPagesReq is request data for Client.ReposGetPages

https://developer.github.com/v3/repos/pages/#get-information-about-a-pages-site
*/
type ReposGetPagesReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetPagesReq) url() string {
	return r._url
}

func (r *ReposGetPagesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo)
}

func (r *ReposGetPagesReq) method() string {
	return "GET"
}

func (r *ReposGetPagesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetPagesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetPagesReq) body() interface{} {
	return nil
}

func (r *ReposGetPagesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetPagesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetPagesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetPagesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetPagesReq) Rel(link RelName, resp *ReposGetPagesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetPagesResponseBody is a response body for ReposGetPages

https://developer.github.com/v3/repos/pages/#get-information-about-a-pages-site
*/
type ReposGetPagesResponseBody struct {
	components.Page
}

/*
ReposGetPagesResponse is a response for ReposGetPages

https://developer.github.com/v3/repos/pages/#get-information-about-a-pages-site
*/
type ReposGetPagesResponse struct {
	response
	request *ReposGetPagesReq
	Data    *ReposGetPagesResponseBody
}

/*
ReposGetPagesBuild performs requests for "repos/get-pages-build"

Get a specific Pages build.

  GET /repos/{owner}/{repo}/pages/builds/{build_id}

https://developer.github.com/v3/repos/pages/#get-a-specific-pages-build
*/
func (c *Client) ReposGetPagesBuild(ctx context.Context, req *ReposGetPagesBuildReq, opt ...RequestOption) (*ReposGetPagesBuildResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetPagesBuildResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetPagesBuildResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetPagesBuildReq is request data for Client.ReposGetPagesBuild

https://developer.github.com/v3/repos/pages/#get-a-specific-pages-build
*/
type ReposGetPagesBuildReq struct {
	_url    string
	Owner   string
	Repo    string
	BuildId int64
}

func (r *ReposGetPagesBuildReq) url() string {
	return r._url
}

func (r *ReposGetPagesBuildReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages/builds/%v", r.Owner, r.Repo, r.BuildId)
}

func (r *ReposGetPagesBuildReq) method() string {
	return "GET"
}

func (r *ReposGetPagesBuildReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetPagesBuildReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetPagesBuildReq) body() interface{} {
	return nil
}

func (r *ReposGetPagesBuildReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetPagesBuildReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetPagesBuildReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetPagesBuildReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetPagesBuildReq) Rel(link RelName, resp *ReposGetPagesBuildResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetPagesBuildResponseBody is a response body for ReposGetPagesBuild

https://developer.github.com/v3/repos/pages/#get-a-specific-pages-build
*/
type ReposGetPagesBuildResponseBody struct {
	components.PageBuild
}

/*
ReposGetPagesBuildResponse is a response for ReposGetPagesBuild

https://developer.github.com/v3/repos/pages/#get-a-specific-pages-build
*/
type ReposGetPagesBuildResponse struct {
	response
	request *ReposGetPagesBuildReq
	Data    *ReposGetPagesBuildResponseBody
}

/*
ReposGetParticipationStats performs requests for "repos/get-participation-stats"

Get the weekly commit count for the repository owner and everyone else.

  GET /repos/{owner}/{repo}/stats/participation

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count-for-the-repository-owner-and-everyone-else
*/
func (c *Client) ReposGetParticipationStats(ctx context.Context, req *ReposGetParticipationStatsReq, opt ...RequestOption) (*ReposGetParticipationStatsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetParticipationStatsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetParticipationStatsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetParticipationStatsReq is request data for Client.ReposGetParticipationStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count-for-the-repository-owner-and-everyone-else
*/
type ReposGetParticipationStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetParticipationStatsReq) url() string {
	return r._url
}

func (r *ReposGetParticipationStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/participation", r.Owner, r.Repo)
}

func (r *ReposGetParticipationStatsReq) method() string {
	return "GET"
}

func (r *ReposGetParticipationStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetParticipationStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetParticipationStatsReq) body() interface{} {
	return nil
}

func (r *ReposGetParticipationStatsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetParticipationStatsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetParticipationStatsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetParticipationStatsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetParticipationStatsReq) Rel(link RelName, resp *ReposGetParticipationStatsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetParticipationStatsResponseBody is a response body for ReposGetParticipationStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count-for-the-repository-owner-and-everyone-else
*/
type ReposGetParticipationStatsResponseBody struct {
	components.ParticipationStats
}

/*
ReposGetParticipationStatsResponse is a response for ReposGetParticipationStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count-for-the-repository-owner-and-everyone-else
*/
type ReposGetParticipationStatsResponse struct {
	response
	request *ReposGetParticipationStatsReq
	Data    *ReposGetParticipationStatsResponseBody
}

/*
ReposGetProtectedBranchAdminEnforcement performs requests for "repos/get-protected-branch-admin-enforcement"

Get admin enforcement of protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#get-admin-enforcement-of-protected-branch
*/
func (c *Client) ReposGetProtectedBranchAdminEnforcement(ctx context.Context, req *ReposGetProtectedBranchAdminEnforcementReq, opt ...RequestOption) (*ReposGetProtectedBranchAdminEnforcementResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetProtectedBranchAdminEnforcementResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetProtectedBranchAdminEnforcementResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetProtectedBranchAdminEnforcementReq is request data for Client.ReposGetProtectedBranchAdminEnforcement

https://developer.github.com/v3/repos/branches/#get-admin-enforcement-of-protected-branch
*/
type ReposGetProtectedBranchAdminEnforcementReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) url() string {
	return r._url
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) method() string {
	return "GET"
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) body() interface{} {
	return nil
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetProtectedBranchAdminEnforcementReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetProtectedBranchAdminEnforcementReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetProtectedBranchAdminEnforcementReq) Rel(link RelName, resp *ReposGetProtectedBranchAdminEnforcementResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetProtectedBranchAdminEnforcementResponseBody is a response body for ReposGetProtectedBranchAdminEnforcement

https://developer.github.com/v3/repos/branches/#get-admin-enforcement-of-protected-branch
*/
type ReposGetProtectedBranchAdminEnforcementResponseBody struct {
	components.ProtectedBranchAdminEnforced
}

/*
ReposGetProtectedBranchAdminEnforcementResponse is a response for ReposGetProtectedBranchAdminEnforcement

https://developer.github.com/v3/repos/branches/#get-admin-enforcement-of-protected-branch
*/
type ReposGetProtectedBranchAdminEnforcementResponse struct {
	response
	request *ReposGetProtectedBranchAdminEnforcementReq
	Data    *ReposGetProtectedBranchAdminEnforcementResponseBody
}

/*
ReposGetProtectedBranchPullRequestReviewEnforcement performs requests for "repos/get-protected-branch-pull-request-review-enforcement"

Get pull request review enforcement of protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#get-pull-request-review-enforcement-of-protected-branch
*/
func (c *Client) ReposGetProtectedBranchPullRequestReviewEnforcement(ctx context.Context, req *ReposGetProtectedBranchPullRequestReviewEnforcementReq, opt ...RequestOption) (*ReposGetProtectedBranchPullRequestReviewEnforcementResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetProtectedBranchPullRequestReviewEnforcementResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetProtectedBranchPullRequestReviewEnforcementReq is request data for Client.ReposGetProtectedBranchPullRequestReviewEnforcement

https://developer.github.com/v3/repos/branches/#get-pull-request-review-enforcement-of-protected-branch
*/
type ReposGetProtectedBranchPullRequestReviewEnforcementReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) url() string {
	return r._url
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) method() string {
	return "GET"
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"luke-cage": r.LukeCagePreview}
	if allPreviews {
		previewVals["luke-cage"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) body() interface{} {
	return nil
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetProtectedBranchPullRequestReviewEnforcementReq) Rel(link RelName, resp *ReposGetProtectedBranchPullRequestReviewEnforcementResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetProtectedBranchPullRequestReviewEnforcementResponse is a response for ReposGetProtectedBranchPullRequestReviewEnforcement

https://developer.github.com/v3/repos/branches/#get-pull-request-review-enforcement-of-protected-branch
*/
type ReposGetProtectedBranchPullRequestReviewEnforcementResponse struct {
	response
	request *ReposGetProtectedBranchPullRequestReviewEnforcementReq
}

/*
ReposGetProtectedBranchRequiredSignatures performs requests for "repos/get-protected-branch-required-signatures"

Get required signatures of protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#get-required-signatures-of-protected-branch
*/
func (c *Client) ReposGetProtectedBranchRequiredSignatures(ctx context.Context, req *ReposGetProtectedBranchRequiredSignaturesReq, opt ...RequestOption) (*ReposGetProtectedBranchRequiredSignaturesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetProtectedBranchRequiredSignaturesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetProtectedBranchRequiredSignaturesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetProtectedBranchRequiredSignaturesReq is request data for Client.ReposGetProtectedBranchRequiredSignatures

https://developer.github.com/v3/repos/branches/#get-required-signatures-of-protected-branch
*/
type ReposGetProtectedBranchRequiredSignaturesReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) url() string {
	return r._url
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) method() string {
	return "GET"
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"zzzax": r.ZzzaxPreview}
	if requiredPreviews {
		previewVals["zzzax"] = true
	}
	if allPreviews {
		previewVals["zzzax"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) body() interface{} {
	return nil
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetProtectedBranchRequiredSignaturesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetProtectedBranchRequiredSignaturesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetProtectedBranchRequiredSignaturesReq) Rel(link RelName, resp *ReposGetProtectedBranchRequiredSignaturesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetProtectedBranchRequiredSignaturesResponseBody is a response body for ReposGetProtectedBranchRequiredSignatures

https://developer.github.com/v3/repos/branches/#get-required-signatures-of-protected-branch
*/
type ReposGetProtectedBranchRequiredSignaturesResponseBody struct {
	components.ProtectedBranchAdminEnforced
}

/*
ReposGetProtectedBranchRequiredSignaturesResponse is a response for ReposGetProtectedBranchRequiredSignatures

https://developer.github.com/v3/repos/branches/#get-required-signatures-of-protected-branch
*/
type ReposGetProtectedBranchRequiredSignaturesResponse struct {
	response
	request *ReposGetProtectedBranchRequiredSignaturesReq
	Data    *ReposGetProtectedBranchRequiredSignaturesResponseBody
}

/*
ReposGetProtectedBranchRequiredStatusChecks performs requests for "repos/get-protected-branch-required-status-checks"

Get required status checks of protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#get-required-status-checks-of-protected-branch
*/
func (c *Client) ReposGetProtectedBranchRequiredStatusChecks(ctx context.Context, req *ReposGetProtectedBranchRequiredStatusChecksReq, opt ...RequestOption) (*ReposGetProtectedBranchRequiredStatusChecksResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetProtectedBranchRequiredStatusChecksResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetProtectedBranchRequiredStatusChecksResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetProtectedBranchRequiredStatusChecksReq is request data for Client.ReposGetProtectedBranchRequiredStatusChecks

https://developer.github.com/v3/repos/branches/#get-required-status-checks-of-protected-branch
*/
type ReposGetProtectedBranchRequiredStatusChecksReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) url() string {
	return r._url
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) method() string {
	return "GET"
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) body() interface{} {
	return nil
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetProtectedBranchRequiredStatusChecksReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetProtectedBranchRequiredStatusChecksReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetProtectedBranchRequiredStatusChecksReq) Rel(link RelName, resp *ReposGetProtectedBranchRequiredStatusChecksResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetProtectedBranchRequiredStatusChecksResponseBody is a response body for ReposGetProtectedBranchRequiredStatusChecks

https://developer.github.com/v3/repos/branches/#get-required-status-checks-of-protected-branch
*/
type ReposGetProtectedBranchRequiredStatusChecksResponseBody struct {
	components.StatusCheckPolicy
}

/*
ReposGetProtectedBranchRequiredStatusChecksResponse is a response for ReposGetProtectedBranchRequiredStatusChecks

https://developer.github.com/v3/repos/branches/#get-required-status-checks-of-protected-branch
*/
type ReposGetProtectedBranchRequiredStatusChecksResponse struct {
	response
	request *ReposGetProtectedBranchRequiredStatusChecksReq
	Data    *ReposGetProtectedBranchRequiredStatusChecksResponseBody
}

/*
ReposGetProtectedBranchRestrictions performs requests for "repos/get-protected-branch-restrictions"

Get restrictions of protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#get-restrictions-of-protected-branch
*/
func (c *Client) ReposGetProtectedBranchRestrictions(ctx context.Context, req *ReposGetProtectedBranchRestrictionsReq, opt ...RequestOption) (*ReposGetProtectedBranchRestrictionsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetProtectedBranchRestrictionsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetProtectedBranchRestrictionsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetProtectedBranchRestrictionsReq is request data for Client.ReposGetProtectedBranchRestrictions

https://developer.github.com/v3/repos/branches/#get-restrictions-of-protected-branch
*/
type ReposGetProtectedBranchRestrictionsReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetProtectedBranchRestrictionsReq) url() string {
	return r._url
}

func (r *ReposGetProtectedBranchRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetProtectedBranchRestrictionsReq) method() string {
	return "GET"
}

func (r *ReposGetProtectedBranchRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetProtectedBranchRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetProtectedBranchRestrictionsReq) body() interface{} {
	return nil
}

func (r *ReposGetProtectedBranchRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetProtectedBranchRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetProtectedBranchRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetProtectedBranchRestrictionsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetProtectedBranchRestrictionsReq) Rel(link RelName, resp *ReposGetProtectedBranchRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetProtectedBranchRestrictionsResponseBody is a response body for ReposGetProtectedBranchRestrictions

https://developer.github.com/v3/repos/branches/#get-restrictions-of-protected-branch
*/
type ReposGetProtectedBranchRestrictionsResponseBody struct {
	components.BranchRestrictionPolicy
}

/*
ReposGetProtectedBranchRestrictionsResponse is a response for ReposGetProtectedBranchRestrictions

https://developer.github.com/v3/repos/branches/#get-restrictions-of-protected-branch
*/
type ReposGetProtectedBranchRestrictionsResponse struct {
	response
	request *ReposGetProtectedBranchRestrictionsReq
	Data    *ReposGetProtectedBranchRestrictionsResponseBody
}

/*
ReposGetPunchCardStats performs requests for "repos/get-punch-card-stats"

Get the number of commits per hour in each day.

  GET /repos/{owner}/{repo}/stats/punch_card

https://developer.github.com/v3/repos/statistics/#get-the-number-of-commits-per-hour-in-each-day
*/
func (c *Client) ReposGetPunchCardStats(ctx context.Context, req *ReposGetPunchCardStatsReq, opt ...RequestOption) (*ReposGetPunchCardStatsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetPunchCardStatsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetPunchCardStatsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetPunchCardStatsReq is request data for Client.ReposGetPunchCardStats

https://developer.github.com/v3/repos/statistics/#get-the-number-of-commits-per-hour-in-each-day
*/
type ReposGetPunchCardStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetPunchCardStatsReq) url() string {
	return r._url
}

func (r *ReposGetPunchCardStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/punch_card", r.Owner, r.Repo)
}

func (r *ReposGetPunchCardStatsReq) method() string {
	return "GET"
}

func (r *ReposGetPunchCardStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetPunchCardStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetPunchCardStatsReq) body() interface{} {
	return nil
}

func (r *ReposGetPunchCardStatsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetPunchCardStatsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetPunchCardStatsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetPunchCardStatsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetPunchCardStatsReq) Rel(link RelName, resp *ReposGetPunchCardStatsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetPunchCardStatsResponseBody is a response body for ReposGetPunchCardStats

https://developer.github.com/v3/repos/statistics/#get-the-number-of-commits-per-hour-in-each-day
*/
type ReposGetPunchCardStatsResponseBody []struct {
	components.CodeFrequencyStat
}

/*
ReposGetPunchCardStatsResponse is a response for ReposGetPunchCardStats

https://developer.github.com/v3/repos/statistics/#get-the-number-of-commits-per-hour-in-each-day
*/
type ReposGetPunchCardStatsResponse struct {
	response
	request *ReposGetPunchCardStatsReq
	Data    *ReposGetPunchCardStatsResponseBody
}

/*
ReposGetReadme performs requests for "repos/get-readme"

Get the README.

  GET /repos/{owner}/{repo}/readme

https://developer.github.com/v3/repos/contents/#get-the-readme
*/
func (c *Client) ReposGetReadme(ctx context.Context, req *ReposGetReadmeReq, opt ...RequestOption) (*ReposGetReadmeResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetReadmeResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetReadmeResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetReadmeReq is request data for Client.ReposGetReadme

https://developer.github.com/v3/repos/contents/#get-the-readme
*/
type ReposGetReadmeReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	The name of the commit/branch/tag. Default: the repositorys default branch
	(usually `master`)
	*/
	Ref *string
}

func (r *ReposGetReadmeReq) url() string {
	return r._url
}

func (r *ReposGetReadmeReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/readme", r.Owner, r.Repo)
}

func (r *ReposGetReadmeReq) method() string {
	return "GET"
}

func (r *ReposGetReadmeReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}
	return query
}

func (r *ReposGetReadmeReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReadmeReq) body() interface{} {
	return nil
}

func (r *ReposGetReadmeReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetReadmeReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetReadmeReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetReadmeReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReadmeReq) Rel(link RelName, resp *ReposGetReadmeResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetReadmeResponseBody is a response body for ReposGetReadme

https://developer.github.com/v3/repos/contents/#get-the-readme
*/
type ReposGetReadmeResponseBody struct {
	components.ContentFile
}

/*
ReposGetReadmeResponse is a response for ReposGetReadme

https://developer.github.com/v3/repos/contents/#get-the-readme
*/
type ReposGetReadmeResponse struct {
	response
	request *ReposGetReadmeReq
	Data    *ReposGetReadmeResponseBody
}

/*
ReposGetRelease performs requests for "repos/get-release"

Get a single release.

  GET /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#get-a-single-release
*/
func (c *Client) ReposGetRelease(ctx context.Context, req *ReposGetReleaseReq, opt ...RequestOption) (*ReposGetReleaseResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetReleaseResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetReleaseResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetReleaseReq is request data for Client.ReposGetRelease

https://developer.github.com/v3/repos/releases/#get-a-single-release
*/
type ReposGetReleaseReq struct {
	_url      string
	Owner     string
	Repo      string
	ReleaseId int64
}

func (r *ReposGetReleaseReq) url() string {
	return r._url
}

func (r *ReposGetReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposGetReleaseReq) method() string {
	return "GET"
}

func (r *ReposGetReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReleaseReq) body() interface{} {
	return nil
}

func (r *ReposGetReleaseReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetReleaseReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetReleaseReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetReleaseReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReleaseReq) Rel(link RelName, resp *ReposGetReleaseResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetReleaseResponseBody is a response body for ReposGetRelease

https://developer.github.com/v3/repos/releases/#get-a-single-release
*/
type ReposGetReleaseResponseBody struct {
	components.Release2
}

/*
ReposGetReleaseResponse is a response for ReposGetRelease

https://developer.github.com/v3/repos/releases/#get-a-single-release
*/
type ReposGetReleaseResponse struct {
	response
	request *ReposGetReleaseReq
	Data    *ReposGetReleaseResponseBody
}

/*
ReposGetReleaseAsset performs requests for "repos/get-release-asset"

Get a single release asset.

  GET /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#get-a-single-release-asset
*/
func (c *Client) ReposGetReleaseAsset(ctx context.Context, req *ReposGetReleaseAssetReq, opt ...RequestOption) (*ReposGetReleaseAssetResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetReleaseAssetResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetReleaseAssetResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetReleaseAssetReq is request data for Client.ReposGetReleaseAsset

https://developer.github.com/v3/repos/releases/#get-a-single-release-asset
*/
type ReposGetReleaseAssetReq struct {
	_url    string
	Owner   string
	Repo    string
	AssetId int64
}

func (r *ReposGetReleaseAssetReq) url() string {
	return r._url
}

func (r *ReposGetReleaseAssetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId)
}

func (r *ReposGetReleaseAssetReq) method() string {
	return "GET"
}

func (r *ReposGetReleaseAssetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetReleaseAssetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReleaseAssetReq) body() interface{} {
	return nil
}

func (r *ReposGetReleaseAssetReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetReleaseAssetReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetReleaseAssetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetReleaseAssetReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReleaseAssetReq) Rel(link RelName, resp *ReposGetReleaseAssetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetReleaseAssetResponseBody is a response body for ReposGetReleaseAsset

https://developer.github.com/v3/repos/releases/#get-a-single-release-asset
*/
type ReposGetReleaseAssetResponseBody struct {
	components.ReleaseAsset
}

/*
ReposGetReleaseAssetResponse is a response for ReposGetReleaseAsset

https://developer.github.com/v3/repos/releases/#get-a-single-release-asset
*/
type ReposGetReleaseAssetResponse struct {
	response
	request *ReposGetReleaseAssetReq
	Data    *ReposGetReleaseAssetResponseBody
}

/*
ReposGetReleaseByTag performs requests for "repos/get-release-by-tag"

Get a release by tag name.

  GET /repos/{owner}/{repo}/releases/tags/{tag}

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
func (c *Client) ReposGetReleaseByTag(ctx context.Context, req *ReposGetReleaseByTagReq, opt ...RequestOption) (*ReposGetReleaseByTagResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetReleaseByTagResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetReleaseByTagResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetReleaseByTagReq is request data for Client.ReposGetReleaseByTag

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
type ReposGetReleaseByTagReq struct {
	_url  string
	Owner string
	Repo  string
	Tag   string
}

func (r *ReposGetReleaseByTagReq) url() string {
	return r._url
}

func (r *ReposGetReleaseByTagReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/tags/%v", r.Owner, r.Repo, r.Tag)
}

func (r *ReposGetReleaseByTagReq) method() string {
	return "GET"
}

func (r *ReposGetReleaseByTagReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetReleaseByTagReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReleaseByTagReq) body() interface{} {
	return nil
}

func (r *ReposGetReleaseByTagReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetReleaseByTagReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetReleaseByTagReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetReleaseByTagReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReleaseByTagReq) Rel(link RelName, resp *ReposGetReleaseByTagResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetReleaseByTagResponseBody is a response body for ReposGetReleaseByTag

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
type ReposGetReleaseByTagResponseBody struct {
	components.Release2
}

/*
ReposGetReleaseByTagResponse is a response for ReposGetReleaseByTag

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
type ReposGetReleaseByTagResponse struct {
	response
	request *ReposGetReleaseByTagReq
	Data    *ReposGetReleaseByTagResponseBody
}

/*
ReposGetTeamsWithAccessToProtectedBranch performs requests for "repos/get-teams-with-access-to-protected-branch"

Get teams with access to protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-protected-branch
*/
func (c *Client) ReposGetTeamsWithAccessToProtectedBranch(ctx context.Context, req *ReposGetTeamsWithAccessToProtectedBranchReq, opt ...RequestOption) (*ReposGetTeamsWithAccessToProtectedBranchResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetTeamsWithAccessToProtectedBranchResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetTeamsWithAccessToProtectedBranchResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetTeamsWithAccessToProtectedBranchReq is request data for Client.ReposGetTeamsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-protected-branch
*/
type ReposGetTeamsWithAccessToProtectedBranchReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) url() string {
	return r._url
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) method() string {
	return "GET"
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) body() interface{} {
	return nil
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetTeamsWithAccessToProtectedBranchReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetTeamsWithAccessToProtectedBranchReq) Rel(link RelName, resp *ReposGetTeamsWithAccessToProtectedBranchResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetTeamsWithAccessToProtectedBranchResponseBody is a response body for ReposGetTeamsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-protected-branch
*/
type ReposGetTeamsWithAccessToProtectedBranchResponseBody []struct {
	components.Team
}

/*
ReposGetTeamsWithAccessToProtectedBranchResponse is a response for ReposGetTeamsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-protected-branch
*/
type ReposGetTeamsWithAccessToProtectedBranchResponse struct {
	response
	request *ReposGetTeamsWithAccessToProtectedBranchReq
	Data    *ReposGetTeamsWithAccessToProtectedBranchResponseBody
}

/*
ReposGetTopPaths performs requests for "repos/get-top-paths"

List paths.

  GET /repos/{owner}/{repo}/traffic/popular/paths

https://developer.github.com/v3/repos/traffic/#list-paths
*/
func (c *Client) ReposGetTopPaths(ctx context.Context, req *ReposGetTopPathsReq, opt ...RequestOption) (*ReposGetTopPathsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetTopPathsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetTopPathsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetTopPathsReq is request data for Client.ReposGetTopPaths

https://developer.github.com/v3/repos/traffic/#list-paths
*/
type ReposGetTopPathsReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetTopPathsReq) url() string {
	return r._url
}

func (r *ReposGetTopPathsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/traffic/popular/paths", r.Owner, r.Repo)
}

func (r *ReposGetTopPathsReq) method() string {
	return "GET"
}

func (r *ReposGetTopPathsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetTopPathsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetTopPathsReq) body() interface{} {
	return nil
}

func (r *ReposGetTopPathsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetTopPathsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetTopPathsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetTopPathsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetTopPathsReq) Rel(link RelName, resp *ReposGetTopPathsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetTopPathsResponseBody is a response body for ReposGetTopPaths

https://developer.github.com/v3/repos/traffic/#list-paths
*/
type ReposGetTopPathsResponseBody []struct {
	components.ContentTraffic
}

/*
ReposGetTopPathsResponse is a response for ReposGetTopPaths

https://developer.github.com/v3/repos/traffic/#list-paths
*/
type ReposGetTopPathsResponse struct {
	response
	request *ReposGetTopPathsReq
	Data    *ReposGetTopPathsResponseBody
}

/*
ReposGetTopReferrers performs requests for "repos/get-top-referrers"

List referrers.

  GET /repos/{owner}/{repo}/traffic/popular/referrers

https://developer.github.com/v3/repos/traffic/#list-referrers
*/
func (c *Client) ReposGetTopReferrers(ctx context.Context, req *ReposGetTopReferrersReq, opt ...RequestOption) (*ReposGetTopReferrersResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetTopReferrersResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetTopReferrersResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetTopReferrersReq is request data for Client.ReposGetTopReferrers

https://developer.github.com/v3/repos/traffic/#list-referrers
*/
type ReposGetTopReferrersReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetTopReferrersReq) url() string {
	return r._url
}

func (r *ReposGetTopReferrersReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/traffic/popular/referrers", r.Owner, r.Repo)
}

func (r *ReposGetTopReferrersReq) method() string {
	return "GET"
}

func (r *ReposGetTopReferrersReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetTopReferrersReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetTopReferrersReq) body() interface{} {
	return nil
}

func (r *ReposGetTopReferrersReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetTopReferrersReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetTopReferrersReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetTopReferrersReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetTopReferrersReq) Rel(link RelName, resp *ReposGetTopReferrersResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetTopReferrersResponseBody is a response body for ReposGetTopReferrers

https://developer.github.com/v3/repos/traffic/#list-referrers
*/
type ReposGetTopReferrersResponseBody []struct {
	components.ReferrerTraffic
}

/*
ReposGetTopReferrersResponse is a response for ReposGetTopReferrers

https://developer.github.com/v3/repos/traffic/#list-referrers
*/
type ReposGetTopReferrersResponse struct {
	response
	request *ReposGetTopReferrersReq
	Data    *ReposGetTopReferrersResponseBody
}

/*
ReposGetUsersWithAccessToProtectedBranch performs requests for "repos/get-users-with-access-to-protected-branch"

Get users with access to protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-protected-branch
*/
func (c *Client) ReposGetUsersWithAccessToProtectedBranch(ctx context.Context, req *ReposGetUsersWithAccessToProtectedBranchReq, opt ...RequestOption) (*ReposGetUsersWithAccessToProtectedBranchResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetUsersWithAccessToProtectedBranchResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetUsersWithAccessToProtectedBranchResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetUsersWithAccessToProtectedBranchReq is request data for Client.ReposGetUsersWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-protected-branch
*/
type ReposGetUsersWithAccessToProtectedBranchReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) url() string {
	return r._url
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) method() string {
	return "GET"
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) body() interface{} {
	return nil
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetUsersWithAccessToProtectedBranchReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetUsersWithAccessToProtectedBranchReq) Rel(link RelName, resp *ReposGetUsersWithAccessToProtectedBranchResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetUsersWithAccessToProtectedBranchResponseBody is a response body for ReposGetUsersWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-protected-branch
*/
type ReposGetUsersWithAccessToProtectedBranchResponseBody []struct {
	components.SimpleUser
}

/*
ReposGetUsersWithAccessToProtectedBranchResponse is a response for ReposGetUsersWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-protected-branch
*/
type ReposGetUsersWithAccessToProtectedBranchResponse struct {
	response
	request *ReposGetUsersWithAccessToProtectedBranchReq
	Data    *ReposGetUsersWithAccessToProtectedBranchResponseBody
}

/*
ReposGetViews performs requests for "repos/get-views"

Views.

  GET /repos/{owner}/{repo}/traffic/views

https://developer.github.com/v3/repos/traffic/#views
*/
func (c *Client) ReposGetViews(ctx context.Context, req *ReposGetViewsReq, opt ...RequestOption) (*ReposGetViewsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposGetViewsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposGetViewsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetViewsReq is request data for Client.ReposGetViews

https://developer.github.com/v3/repos/traffic/#views
*/
type ReposGetViewsReq struct {
	_url  string
	Owner string
	Repo  string

	// Must be one of: `day`, `week`.
	Per *string
}

func (r *ReposGetViewsReq) url() string {
	return r._url
}

func (r *ReposGetViewsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/traffic/views", r.Owner, r.Repo)
}

func (r *ReposGetViewsReq) method() string {
	return "GET"
}

func (r *ReposGetViewsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Per != nil {
		query.Set("per", *r.Per)
	}
	return query
}

func (r *ReposGetViewsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetViewsReq) body() interface{} {
	return nil
}

func (r *ReposGetViewsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetViewsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetViewsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposGetViewsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetViewsReq) Rel(link RelName, resp *ReposGetViewsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetViewsResponseBody is a response body for ReposGetViews

https://developer.github.com/v3/repos/traffic/#views
*/
type ReposGetViewsResponseBody struct {
	components.ViewTraffic
}

/*
ReposGetViewsResponse is a response for ReposGetViews

https://developer.github.com/v3/repos/traffic/#views
*/
type ReposGetViewsResponse struct {
	response
	request *ReposGetViewsReq
	Data    *ReposGetViewsResponseBody
}

/*
ReposListAssetsForRelease performs requests for "repos/list-assets-for-release"

List assets for a release.

  GET /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#list-assets-for-a-release
*/
func (c *Client) ReposListAssetsForRelease(ctx context.Context, req *ReposListAssetsForReleaseReq, opt ...RequestOption) (*ReposListAssetsForReleaseResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListAssetsForReleaseResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListAssetsForReleaseResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListAssetsForReleaseReq is request data for Client.ReposListAssetsForRelease

https://developer.github.com/v3/repos/releases/#list-assets-for-a-release
*/
type ReposListAssetsForReleaseReq struct {
	_url      string
	Owner     string
	Repo      string
	ReleaseId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListAssetsForReleaseReq) url() string {
	return r._url
}

func (r *ReposListAssetsForReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v/assets", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposListAssetsForReleaseReq) method() string {
	return "GET"
}

func (r *ReposListAssetsForReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListAssetsForReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListAssetsForReleaseReq) body() interface{} {
	return nil
}

func (r *ReposListAssetsForReleaseReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListAssetsForReleaseReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListAssetsForReleaseReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListAssetsForReleaseReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListAssetsForReleaseReq) Rel(link RelName, resp *ReposListAssetsForReleaseResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListAssetsForReleaseResponseBody is a response body for ReposListAssetsForRelease

https://developer.github.com/v3/repos/releases/#list-assets-for-a-release
*/
type ReposListAssetsForReleaseResponseBody []struct {
	components.ReleaseAsset
}

/*
ReposListAssetsForReleaseResponse is a response for ReposListAssetsForRelease

https://developer.github.com/v3/repos/releases/#list-assets-for-a-release
*/
type ReposListAssetsForReleaseResponse struct {
	response
	request *ReposListAssetsForReleaseReq
	Data    *ReposListAssetsForReleaseResponseBody
}

/*
ReposListBranches performs requests for "repos/list-branches"

List branches.

  GET /repos/{owner}/{repo}/branches

https://developer.github.com/v3/repos/branches/#list-branches
*/
func (c *Client) ReposListBranches(ctx context.Context, req *ReposListBranchesReq, opt ...RequestOption) (*ReposListBranchesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListBranchesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListBranchesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListBranchesReq is request data for Client.ReposListBranches

https://developer.github.com/v3/repos/branches/#list-branches
*/
type ReposListBranchesReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Setting to `true` returns only protected branches. When set to `false`, only
	unprotected branches are returned. Omitting this parameter returns all branches.
	*/
	Protected *bool

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListBranchesReq) url() string {
	return r._url
}

func (r *ReposListBranchesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches", r.Owner, r.Repo)
}

func (r *ReposListBranchesReq) method() string {
	return "GET"
}

func (r *ReposListBranchesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Protected != nil {
		query.Set("protected", strconv.FormatBool(*r.Protected))
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListBranchesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListBranchesReq) body() interface{} {
	return nil
}

func (r *ReposListBranchesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListBranchesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListBranchesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListBranchesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListBranchesReq) Rel(link RelName, resp *ReposListBranchesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListBranchesResponseBody is a response body for ReposListBranches

https://developer.github.com/v3/repos/branches/#list-branches
*/
type ReposListBranchesResponseBody []struct {
	components.ShortBranchWithProtection
}

/*
ReposListBranchesResponse is a response for ReposListBranches

https://developer.github.com/v3/repos/branches/#list-branches
*/
type ReposListBranchesResponse struct {
	response
	request *ReposListBranchesReq
	Data    *ReposListBranchesResponseBody
}

/*
ReposListBranchesForHeadCommit performs requests for "repos/list-branches-for-head-commit"

List branches for HEAD commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
func (c *Client) ReposListBranchesForHeadCommit(ctx context.Context, req *ReposListBranchesForHeadCommitReq, opt ...RequestOption) (*ReposListBranchesForHeadCommitResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListBranchesForHeadCommitResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListBranchesForHeadCommitResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListBranchesForHeadCommitReq is request data for Client.ReposListBranchesForHeadCommit

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
type ReposListBranchesForHeadCommitReq struct {
	_url      string
	Owner     string
	Repo      string
	CommitSha string

	/*
	Listing branches or pull requests for a commit in the Commits API is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-04-11-pulls-branches-for-commit/)
	for more details. To access the new endpoints during the preview period, you
	must set this to true.
	*/
	GrootPreview bool
}

func (r *ReposListBranchesForHeadCommitReq) url() string {
	return r._url
}

func (r *ReposListBranchesForHeadCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/branches-where-head", r.Owner, r.Repo, r.CommitSha)
}

func (r *ReposListBranchesForHeadCommitReq) method() string {
	return "GET"
}

func (r *ReposListBranchesForHeadCommitReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposListBranchesForHeadCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"groot": r.GrootPreview}
	if requiredPreviews {
		previewVals["groot"] = true
	}
	if allPreviews {
		previewVals["groot"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListBranchesForHeadCommitReq) body() interface{} {
	return nil
}

func (r *ReposListBranchesForHeadCommitReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListBranchesForHeadCommitReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListBranchesForHeadCommitReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListBranchesForHeadCommitReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListBranchesForHeadCommitReq) Rel(link RelName, resp *ReposListBranchesForHeadCommitResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListBranchesForHeadCommitResponseBody is a response body for ReposListBranchesForHeadCommit

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
type ReposListBranchesForHeadCommitResponseBody []struct {
	components.BranchShort
}

/*
ReposListBranchesForHeadCommitResponse is a response for ReposListBranchesForHeadCommit

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
type ReposListBranchesForHeadCommitResponse struct {
	response
	request *ReposListBranchesForHeadCommitReq
	Data    *ReposListBranchesForHeadCommitResponseBody
}

/*
ReposListCollaborators performs requests for "repos/list-collaborators"

List collaborators.

  GET /repos/{owner}/{repo}/collaborators

https://developer.github.com/v3/repos/collaborators/#list-collaborators
*/
func (c *Client) ReposListCollaborators(ctx context.Context, req *ReposListCollaboratorsReq, opt ...RequestOption) (*ReposListCollaboratorsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListCollaboratorsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListCollaboratorsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCollaboratorsReq is request data for Client.ReposListCollaborators

https://developer.github.com/v3/repos/collaborators/#list-collaborators
*/
type ReposListCollaboratorsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Filter collaborators returned by their affiliation. Can be one of:
	\* `outside`: All outside collaborators of an organization-owned repository.
	\* `direct`: All collaborators with permissions to an organization-owned
	repository, regardless of organization membership status.
	\* `all`: All collaborators the authenticated user can see.
	*/
	Affiliation *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListCollaboratorsReq) url() string {
	return r._url
}

func (r *ReposListCollaboratorsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators", r.Owner, r.Repo)
}

func (r *ReposListCollaboratorsReq) method() string {
	return "GET"
}

func (r *ReposListCollaboratorsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListCollaboratorsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListCollaboratorsReq) body() interface{} {
	return nil
}

func (r *ReposListCollaboratorsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListCollaboratorsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListCollaboratorsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListCollaboratorsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCollaboratorsReq) Rel(link RelName, resp *ReposListCollaboratorsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCollaboratorsResponseBody is a response body for ReposListCollaborators

https://developer.github.com/v3/repos/collaborators/#list-collaborators
*/
type ReposListCollaboratorsResponseBody []struct {
	components.Collaborator
}

/*
ReposListCollaboratorsResponse is a response for ReposListCollaborators

https://developer.github.com/v3/repos/collaborators/#list-collaborators
*/
type ReposListCollaboratorsResponse struct {
	response
	request *ReposListCollaboratorsReq
	Data    *ReposListCollaboratorsResponseBody
}

/*
ReposListCommentsForCommit performs requests for "repos/list-comments-for-commit"

List comments for a single commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#list-comments-for-a-single-commit
*/
func (c *Client) ReposListCommentsForCommit(ctx context.Context, req *ReposListCommentsForCommitReq, opt ...RequestOption) (*ReposListCommentsForCommitResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListCommentsForCommitResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListCommentsForCommitResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCommentsForCommitReq is request data for Client.ReposListCommentsForCommit

https://developer.github.com/v3/repos/comments/#list-comments-for-a-single-commit
*/
type ReposListCommentsForCommitReq struct {
	_url      string
	Owner     string
	Repo      string
	CommitSha string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the commit comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReposListCommentsForCommitReq) url() string {
	return r._url
}

func (r *ReposListCommentsForCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/comments", r.Owner, r.Repo, r.CommitSha)
}

func (r *ReposListCommentsForCommitReq) method() string {
	return "GET"
}

func (r *ReposListCommentsForCommitReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListCommentsForCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListCommentsForCommitReq) body() interface{} {
	return nil
}

func (r *ReposListCommentsForCommitReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListCommentsForCommitReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListCommentsForCommitReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListCommentsForCommitReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCommentsForCommitReq) Rel(link RelName, resp *ReposListCommentsForCommitResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCommentsForCommitResponseBody is a response body for ReposListCommentsForCommit

https://developer.github.com/v3/repos/comments/#list-comments-for-a-single-commit
*/
type ReposListCommentsForCommitResponseBody []struct {
	components.CommitComment
}

/*
ReposListCommentsForCommitResponse is a response for ReposListCommentsForCommit

https://developer.github.com/v3/repos/comments/#list-comments-for-a-single-commit
*/
type ReposListCommentsForCommitResponse struct {
	response
	request *ReposListCommentsForCommitReq
	Data    *ReposListCommentsForCommitResponseBody
}

/*
ReposListCommitComments performs requests for "repos/list-commit-comments"

List commit comments for a repository.

  GET /repos/{owner}/{repo}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
func (c *Client) ReposListCommitComments(ctx context.Context, req *ReposListCommitCommentsReq, opt ...RequestOption) (*ReposListCommitCommentsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListCommitCommentsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListCommitCommentsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCommitCommentsReq is request data for Client.ReposListCommitComments

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
type ReposListCommitCommentsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the commit comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReposListCommitCommentsReq) url() string {
	return r._url
}

func (r *ReposListCommitCommentsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments", r.Owner, r.Repo)
}

func (r *ReposListCommitCommentsReq) method() string {
	return "GET"
}

func (r *ReposListCommitCommentsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListCommitCommentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListCommitCommentsReq) body() interface{} {
	return nil
}

func (r *ReposListCommitCommentsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListCommitCommentsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListCommitCommentsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListCommitCommentsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCommitCommentsReq) Rel(link RelName, resp *ReposListCommitCommentsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCommitCommentsResponseBody is a response body for ReposListCommitComments

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
type ReposListCommitCommentsResponseBody []struct {
	components.CommitComment
}

/*
ReposListCommitCommentsResponse is a response for ReposListCommitComments

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
type ReposListCommitCommentsResponse struct {
	response
	request *ReposListCommitCommentsReq
	Data    *ReposListCommitCommentsResponseBody
}

/*
ReposListCommits performs requests for "repos/list-commits"

List commits on a repository.

  GET /repos/{owner}/{repo}/commits

https://developer.github.com/v3/repos/commits/#list-commits-on-a-repository
*/
func (c *Client) ReposListCommits(ctx context.Context, req *ReposListCommitsReq, opt ...RequestOption) (*ReposListCommitsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListCommitsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListCommitsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCommitsReq is request data for Client.ReposListCommits

https://developer.github.com/v3/repos/commits/#list-commits-on-a-repository
*/
type ReposListCommitsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	SHA or branch to start listing commits from. Default: the repositorys default
	branch (usually `master`).
	*/
	Sha *string

	// Only commits containing this file path will be returned.
	Path *string

	// GitHub login or email address by which to filter by commit author.
	Author *string

	/*
	Only commits after this date will be returned. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only commits before this date will be returned. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Until *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListCommitsReq) url() string {
	return r._url
}

func (r *ReposListCommitsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits", r.Owner, r.Repo)
}

func (r *ReposListCommitsReq) method() string {
	return "GET"
}

func (r *ReposListCommitsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sha != nil {
		query.Set("sha", *r.Sha)
	}
	if r.Path != nil {
		query.Set("path", *r.Path)
	}
	if r.Author != nil {
		query.Set("author", *r.Author)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Until != nil {
		query.Set("until", *r.Until)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListCommitsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListCommitsReq) body() interface{} {
	return nil
}

func (r *ReposListCommitsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListCommitsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListCommitsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListCommitsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCommitsReq) Rel(link RelName, resp *ReposListCommitsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCommitsResponseBody is a response body for ReposListCommits

https://developer.github.com/v3/repos/commits/#list-commits-on-a-repository
*/
type ReposListCommitsResponseBody []struct {
	components.SimpleCommit
}

/*
ReposListCommitsResponse is a response for ReposListCommits

https://developer.github.com/v3/repos/commits/#list-commits-on-a-repository
*/
type ReposListCommitsResponse struct {
	response
	request *ReposListCommitsReq
	Data    *ReposListCommitsResponseBody
}

/*
ReposListContributors performs requests for "repos/list-contributors"

List contributors.

  GET /repos/{owner}/{repo}/contributors

https://developer.github.com/v3/repos/#list-contributors
*/
func (c *Client) ReposListContributors(ctx context.Context, req *ReposListContributorsReq, opt ...RequestOption) (*ReposListContributorsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListContributorsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListContributorsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListContributorsReq is request data for Client.ReposListContributors

https://developer.github.com/v3/repos/#list-contributors
*/
type ReposListContributorsReq struct {
	_url  string
	Owner string
	Repo  string

	// Set to `1` or `true` to include anonymous contributors in results.
	Anon *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListContributorsReq) url() string {
	return r._url
}

func (r *ReposListContributorsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/contributors", r.Owner, r.Repo)
}

func (r *ReposListContributorsReq) method() string {
	return "GET"
}

func (r *ReposListContributorsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Anon != nil {
		query.Set("anon", *r.Anon)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListContributorsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListContributorsReq) body() interface{} {
	return nil
}

func (r *ReposListContributorsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListContributorsReq) validStatuses() []int {
	return []int{200, 204}
}

func (r *ReposListContributorsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListContributorsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListContributorsReq) Rel(link RelName, resp *ReposListContributorsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListContributorsResponseBody is a response body for ReposListContributors

https://developer.github.com/v3/repos/#list-contributors
*/
type ReposListContributorsResponseBody []struct {
	components.Contributor
}

/*
ReposListContributorsResponse is a response for ReposListContributors

https://developer.github.com/v3/repos/#list-contributors
*/
type ReposListContributorsResponse struct {
	response
	request *ReposListContributorsReq
	Data    *ReposListContributorsResponseBody
}

/*
ReposListDeployKeys performs requests for "repos/list-deploy-keys"

List deploy keys.

  GET /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
func (c *Client) ReposListDeployKeys(ctx context.Context, req *ReposListDeployKeysReq, opt ...RequestOption) (*ReposListDeployKeysResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListDeployKeysResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListDeployKeysResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListDeployKeysReq is request data for Client.ReposListDeployKeys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
type ReposListDeployKeysReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListDeployKeysReq) url() string {
	return r._url
}

func (r *ReposListDeployKeysReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/keys", r.Owner, r.Repo)
}

func (r *ReposListDeployKeysReq) method() string {
	return "GET"
}

func (r *ReposListDeployKeysReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListDeployKeysReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListDeployKeysReq) body() interface{} {
	return nil
}

func (r *ReposListDeployKeysReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListDeployKeysReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListDeployKeysReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListDeployKeysReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListDeployKeysReq) Rel(link RelName, resp *ReposListDeployKeysResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListDeployKeysResponseBody is a response body for ReposListDeployKeys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
type ReposListDeployKeysResponseBody []struct {
	components.DeployKey
}

/*
ReposListDeployKeysResponse is a response for ReposListDeployKeys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
type ReposListDeployKeysResponse struct {
	response
	request *ReposListDeployKeysReq
	Data    *ReposListDeployKeysResponseBody
}

/*
ReposListDeploymentStatuses performs requests for "repos/list-deployment-statuses"

List deployment statuses.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
func (c *Client) ReposListDeploymentStatuses(ctx context.Context, req *ReposListDeploymentStatusesReq, opt ...RequestOption) (*ReposListDeploymentStatusesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListDeploymentStatusesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListDeploymentStatusesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListDeploymentStatusesReq is request data for Client.ReposListDeploymentStatuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
type ReposListDeploymentStatusesReq struct {
	_url         string
	Owner        string
	Repo         string
	DeploymentId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposListDeploymentStatusesReq) url() string {
	return r._url
}

func (r *ReposListDeploymentStatusesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses", r.Owner, r.Repo, r.DeploymentId)
}

func (r *ReposListDeploymentStatusesReq) method() string {
	return "GET"
}

func (r *ReposListDeploymentStatusesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListDeploymentStatusesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"ant-man": r.AntManPreview,
		"flash":   r.FlashPreview,
	}
	if allPreviews {
		previewVals["flash"] = true
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListDeploymentStatusesReq) body() interface{} {
	return nil
}

func (r *ReposListDeploymentStatusesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListDeploymentStatusesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListDeploymentStatusesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListDeploymentStatusesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListDeploymentStatusesReq) Rel(link RelName, resp *ReposListDeploymentStatusesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListDeploymentStatusesResponseBody is a response body for ReposListDeploymentStatuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
type ReposListDeploymentStatusesResponseBody []struct {
	components.DeploymentStatus
}

/*
ReposListDeploymentStatusesResponse is a response for ReposListDeploymentStatuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
type ReposListDeploymentStatusesResponse struct {
	response
	request *ReposListDeploymentStatusesReq
	Data    *ReposListDeploymentStatusesResponseBody
}

/*
ReposListDeployments performs requests for "repos/list-deployments"

List deployments.

  GET /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
func (c *Client) ReposListDeployments(ctx context.Context, req *ReposListDeploymentsReq, opt ...RequestOption) (*ReposListDeploymentsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListDeploymentsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListDeploymentsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListDeploymentsReq is request data for Client.ReposListDeployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
type ReposListDeploymentsReq struct {
	_url  string
	Owner string
	Repo  string

	// The SHA recorded at creation time.
	Sha *string

	// The name of the ref. This can be a branch, tag, or SHA.
	Ref *string

	// The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).
	Task *string

	/*
	The name of the environment that was deployed to (e.g., `staging` or
	`production`).
	*/
	Environment *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The `transient_environment` and `production_environment` parameters are
	currently available for developers to preview. During the preview period, the
	API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposListDeploymentsReq) url() string {
	return r._url
}

func (r *ReposListDeploymentsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments", r.Owner, r.Repo)
}

func (r *ReposListDeploymentsReq) method() string {
	return "GET"
}

func (r *ReposListDeploymentsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sha != nil {
		query.Set("sha", *r.Sha)
	}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}
	if r.Task != nil {
		query.Set("task", *r.Task)
	}
	if r.Environment != nil {
		query.Set("environment", *r.Environment)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListDeploymentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"ant-man": r.AntManPreview}
	if allPreviews {
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListDeploymentsReq) body() interface{} {
	return nil
}

func (r *ReposListDeploymentsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListDeploymentsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListDeploymentsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListDeploymentsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListDeploymentsReq) Rel(link RelName, resp *ReposListDeploymentsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListDeploymentsResponseBody is a response body for ReposListDeployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
type ReposListDeploymentsResponseBody []struct {
	components.Deployment
}

/*
ReposListDeploymentsResponse is a response for ReposListDeployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
type ReposListDeploymentsResponse struct {
	response
	request *ReposListDeploymentsReq
	Data    *ReposListDeploymentsResponseBody
}

/*
ReposListDownloads performs requests for "repos/list-downloads"

List downloads for a repository.

  GET /repos/{owner}/{repo}/downloads

https://developer.github.com/v3/repos/downloads/#list-downloads-for-a-repository
*/
func (c *Client) ReposListDownloads(ctx context.Context, req *ReposListDownloadsReq, opt ...RequestOption) (*ReposListDownloadsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListDownloadsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListDownloadsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListDownloadsReq is request data for Client.ReposListDownloads

https://developer.github.com/v3/repos/downloads/#list-downloads-for-a-repository
*/
type ReposListDownloadsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListDownloadsReq) url() string {
	return r._url
}

func (r *ReposListDownloadsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/downloads", r.Owner, r.Repo)
}

func (r *ReposListDownloadsReq) method() string {
	return "GET"
}

func (r *ReposListDownloadsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListDownloadsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListDownloadsReq) body() interface{} {
	return nil
}

func (r *ReposListDownloadsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListDownloadsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListDownloadsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListDownloadsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListDownloadsReq) Rel(link RelName, resp *ReposListDownloadsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListDownloadsResponseBody is a response body for ReposListDownloads

https://developer.github.com/v3/repos/downloads/#list-downloads-for-a-repository
*/
type ReposListDownloadsResponseBody []struct {
	components.Download
}

/*
ReposListDownloadsResponse is a response for ReposListDownloads

https://developer.github.com/v3/repos/downloads/#list-downloads-for-a-repository
*/
type ReposListDownloadsResponse struct {
	response
	request *ReposListDownloadsReq
	Data    *ReposListDownloadsResponseBody
}

/*
ReposListForAuthenticatedUser performs requests for "repos/list-for-authenticated-user"

List repositories for the authenticated user.

  GET /user/repos

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
func (c *Client) ReposListForAuthenticatedUser(ctx context.Context, req *ReposListForAuthenticatedUserReq, opt ...RequestOption) (*ReposListForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListForAuthenticatedUserReq is request data for Client.ReposListForAuthenticatedUser

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
type ReposListForAuthenticatedUserReq struct {
	_url string

	// Can be one of `all`, `public`, or `private`.
	Visibility *string

	/*
	Comma-separated list of values. Can include:
	\* `owner`: Repositories that are owned by the authenticated user.
	\* `collaborator`: Repositories that the user has been added to as a
	collaborator.
	\* `organization_member`: Repositories that the user has access to through being
	a member of an organization. This includes every repository on every team that
	the user is on.
	*/
	Affiliation *string

	/*
	Can be one of `all`, `owner`, `public`, `private`, `member`. Default: `all`

	Will cause a `422` error if used in the same request as **visibility** or
	**affiliation**. Will cause a `422` error if used in the same request as
	**visibility** or **affiliation**.
	*/
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *ReposListForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/repos")
}

func (r *ReposListForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ReposListForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Visibility != nil {
		query.Set("visibility", *r.Visibility)
	}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ReposListForAuthenticatedUserReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposListForAuthenticatedUserReq) validStatuses() []int {
	return []int{}
}

func (r *ReposListForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListForAuthenticatedUserReq) Rel(link RelName, resp *ReposListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListForAuthenticatedUserResponse is a response for ReposListForAuthenticatedUser

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
type ReposListForAuthenticatedUserResponse struct {
	response
	request *ReposListForAuthenticatedUserReq
}

/*
ReposListForOrg performs requests for "repos/list-for-org"

List organization repositories.

  GET /orgs/{org}/repos

https://developer.github.com/v3/repos/#list-organization-repositories
*/
func (c *Client) ReposListForOrg(ctx context.Context, req *ReposListForOrgReq, opt ...RequestOption) (*ReposListForOrgResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListForOrgResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListForOrgReq is request data for Client.ReposListForOrg

https://developer.github.com/v3/repos/#list-organization-repositories
*/
type ReposListForOrgReq struct {
	_url string
	Org  string

	/*
	Specifies the types of repositories you want returned. Can be one of `all`,
	`public`, `private`, `forks`, `sources`, `member`, `internal`. Default: `all`.
	If your organization is associated with an enterprise account using GitHub
	Enterprise Cloud or GitHub Enterprise Server 2.20+, `type` can also be
	`internal`.
	*/
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: when using `full_name`: `asc`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

func (r *ReposListForOrgReq) url() string {
	return r._url
}

func (r *ReposListForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/repos", r.Org)
}

func (r *ReposListForOrgReq) method() string {
	return "GET"
}

func (r *ReposListForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"baptiste": r.BaptistePreview,
		"nebula":   r.NebulaPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListForOrgReq) body() interface{} {
	return nil
}

func (r *ReposListForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListForOrgReq) Rel(link RelName, resp *ReposListForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListForOrgResponseBody is a response body for ReposListForOrg

https://developer.github.com/v3/repos/#list-organization-repositories
*/
type ReposListForOrgResponseBody []struct {
	components.MinimalRepository
}

/*
ReposListForOrgResponse is a response for ReposListForOrg

https://developer.github.com/v3/repos/#list-organization-repositories
*/
type ReposListForOrgResponse struct {
	response
	request *ReposListForOrgReq
	Data    *ReposListForOrgResponseBody
}

/*
ReposListForUser performs requests for "repos/list-for-user"

List repositories for a user.

  GET /users/{username}/repos

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
func (c *Client) ReposListForUser(ctx context.Context, req *ReposListForUserReq, opt ...RequestOption) (*ReposListForUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListForUserResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListForUserReq is request data for Client.ReposListForUser

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
type ReposListForUserReq struct {
	_url     string
	Username string

	// Can be one of `all`, `owner`, `member`.
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool
}

func (r *ReposListForUserReq) url() string {
	return r._url
}

func (r *ReposListForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/repos", r.Username)
}

func (r *ReposListForUserReq) method() string {
	return "GET"
}

func (r *ReposListForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"nebula": r.NebulaPreview}
	if allPreviews {
		previewVals["nebula"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListForUserReq) body() interface{} {
	return nil
}

func (r *ReposListForUserReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposListForUserReq) validStatuses() []int {
	return []int{}
}

func (r *ReposListForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListForUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListForUserReq) Rel(link RelName, resp *ReposListForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListForUserResponse is a response for ReposListForUser

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
type ReposListForUserResponse struct {
	response
	request *ReposListForUserReq
}

/*
ReposListForks performs requests for "repos/list-forks"

List forks.

  GET /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#list-forks
*/
func (c *Client) ReposListForks(ctx context.Context, req *ReposListForksReq, opt ...RequestOption) (*ReposListForksResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListForksResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListForksResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListForksReq is request data for Client.ReposListForks

https://developer.github.com/v3/repos/forks/#list-forks
*/
type ReposListForksReq struct {
	_url  string
	Owner string
	Repo  string

	// The sort order. Can be either `newest`, `oldest`, or `stargazers`.
	Sort *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListForksReq) url() string {
	return r._url
}

func (r *ReposListForksReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/forks", r.Owner, r.Repo)
}

func (r *ReposListForksReq) method() string {
	return "GET"
}

func (r *ReposListForksReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListForksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListForksReq) body() interface{} {
	return nil
}

func (r *ReposListForksReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListForksReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListForksReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListForksReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListForksReq) Rel(link RelName, resp *ReposListForksResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListForksResponseBody is a response body for ReposListForks

https://developer.github.com/v3/repos/forks/#list-forks
*/
type ReposListForksResponseBody []struct {
	components.MinimalRepository
}

/*
ReposListForksResponse is a response for ReposListForks

https://developer.github.com/v3/repos/forks/#list-forks
*/
type ReposListForksResponse struct {
	response
	request *ReposListForksReq
	Data    *ReposListForksResponseBody
}

/*
ReposListHooks performs requests for "repos/list-hooks"

List hooks.

  GET /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#list-hooks
*/
func (c *Client) ReposListHooks(ctx context.Context, req *ReposListHooksReq, opt ...RequestOption) (*ReposListHooksResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListHooksResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListHooksResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListHooksReq is request data for Client.ReposListHooks

https://developer.github.com/v3/repos/hooks/#list-hooks
*/
type ReposListHooksReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListHooksReq) url() string {
	return r._url
}

func (r *ReposListHooksReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks", r.Owner, r.Repo)
}

func (r *ReposListHooksReq) method() string {
	return "GET"
}

func (r *ReposListHooksReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListHooksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListHooksReq) body() interface{} {
	return nil
}

func (r *ReposListHooksReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListHooksReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListHooksReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListHooksReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListHooksReq) Rel(link RelName, resp *ReposListHooksResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListHooksResponseBody is a response body for ReposListHooks

https://developer.github.com/v3/repos/hooks/#list-hooks
*/
type ReposListHooksResponseBody []struct {
	components.Hook
}

/*
ReposListHooksResponse is a response for ReposListHooks

https://developer.github.com/v3/repos/hooks/#list-hooks
*/
type ReposListHooksResponse struct {
	response
	request *ReposListHooksReq
	Data    *ReposListHooksResponseBody
}

/*
ReposListInvitations performs requests for "repos/list-invitations"

List invitations for a repository.

  GET /repos/{owner}/{repo}/invitations

https://developer.github.com/v3/repos/invitations/#list-invitations-for-a-repository
*/
func (c *Client) ReposListInvitations(ctx context.Context, req *ReposListInvitationsReq, opt ...RequestOption) (*ReposListInvitationsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListInvitationsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListInvitationsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListInvitationsReq is request data for Client.ReposListInvitations

https://developer.github.com/v3/repos/invitations/#list-invitations-for-a-repository
*/
type ReposListInvitationsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListInvitationsReq) url() string {
	return r._url
}

func (r *ReposListInvitationsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/invitations", r.Owner, r.Repo)
}

func (r *ReposListInvitationsReq) method() string {
	return "GET"
}

func (r *ReposListInvitationsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListInvitationsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListInvitationsReq) body() interface{} {
	return nil
}

func (r *ReposListInvitationsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListInvitationsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListInvitationsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListInvitationsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListInvitationsReq) Rel(link RelName, resp *ReposListInvitationsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListInvitationsResponseBody is a response body for ReposListInvitations

https://developer.github.com/v3/repos/invitations/#list-invitations-for-a-repository
*/
type ReposListInvitationsResponseBody []struct {
	components.RepositoryInvitation
}

/*
ReposListInvitationsResponse is a response for ReposListInvitations

https://developer.github.com/v3/repos/invitations/#list-invitations-for-a-repository
*/
type ReposListInvitationsResponse struct {
	response
	request *ReposListInvitationsReq
	Data    *ReposListInvitationsResponseBody
}

/*
ReposListInvitationsForAuthenticatedUser performs requests for "repos/list-invitations-for-authenticated-user"

List a user's repository invitations.

  GET /user/repository_invitations

https://developer.github.com/v3/repos/invitations/#list-a-users-repository-invitations
*/
func (c *Client) ReposListInvitationsForAuthenticatedUser(ctx context.Context, req *ReposListInvitationsForAuthenticatedUserReq, opt ...RequestOption) (*ReposListInvitationsForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListInvitationsForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListInvitationsForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListInvitationsForAuthenticatedUserReq is request data for Client.ReposListInvitationsForAuthenticatedUser

https://developer.github.com/v3/repos/invitations/#list-a-users-repository-invitations
*/
type ReposListInvitationsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListInvitationsForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *ReposListInvitationsForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/repository_invitations")
}

func (r *ReposListInvitationsForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ReposListInvitationsForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListInvitationsForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListInvitationsForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ReposListInvitationsForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListInvitationsForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListInvitationsForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListInvitationsForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListInvitationsForAuthenticatedUserReq) Rel(link RelName, resp *ReposListInvitationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListInvitationsForAuthenticatedUserResponseBody is a response body for ReposListInvitationsForAuthenticatedUser

https://developer.github.com/v3/repos/invitations/#list-a-users-repository-invitations
*/
type ReposListInvitationsForAuthenticatedUserResponseBody []struct {
	components.RepositoryInvitation
}

/*
ReposListInvitationsForAuthenticatedUserResponse is a response for ReposListInvitationsForAuthenticatedUser

https://developer.github.com/v3/repos/invitations/#list-a-users-repository-invitations
*/
type ReposListInvitationsForAuthenticatedUserResponse struct {
	response
	request *ReposListInvitationsForAuthenticatedUserReq
	Data    *ReposListInvitationsForAuthenticatedUserResponseBody
}

/*
ReposListLanguages performs requests for "repos/list-languages"

List languages.

  GET /repos/{owner}/{repo}/languages

https://developer.github.com/v3/repos/#list-languages
*/
func (c *Client) ReposListLanguages(ctx context.Context, req *ReposListLanguagesReq, opt ...RequestOption) (*ReposListLanguagesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListLanguagesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListLanguagesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListLanguagesReq is request data for Client.ReposListLanguages

https://developer.github.com/v3/repos/#list-languages
*/
type ReposListLanguagesReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposListLanguagesReq) url() string {
	return r._url
}

func (r *ReposListLanguagesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/languages", r.Owner, r.Repo)
}

func (r *ReposListLanguagesReq) method() string {
	return "GET"
}

func (r *ReposListLanguagesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposListLanguagesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListLanguagesReq) body() interface{} {
	return nil
}

func (r *ReposListLanguagesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListLanguagesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListLanguagesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListLanguagesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListLanguagesReq) Rel(link RelName, resp *ReposListLanguagesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListLanguagesResponseBody is a response body for ReposListLanguages

https://developer.github.com/v3/repos/#list-languages
*/
type ReposListLanguagesResponseBody struct {
	components.Language
}

/*
ReposListLanguagesResponse is a response for ReposListLanguages

https://developer.github.com/v3/repos/#list-languages
*/
type ReposListLanguagesResponse struct {
	response
	request *ReposListLanguagesReq
	Data    *ReposListLanguagesResponseBody
}

/*
ReposListPagesBuilds performs requests for "repos/list-pages-builds"

List Pages builds.

  GET /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#list-pages-builds
*/
func (c *Client) ReposListPagesBuilds(ctx context.Context, req *ReposListPagesBuildsReq, opt ...RequestOption) (*ReposListPagesBuildsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListPagesBuildsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListPagesBuildsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListPagesBuildsReq is request data for Client.ReposListPagesBuilds

https://developer.github.com/v3/repos/pages/#list-pages-builds
*/
type ReposListPagesBuildsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListPagesBuildsReq) url() string {
	return r._url
}

func (r *ReposListPagesBuildsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages/builds", r.Owner, r.Repo)
}

func (r *ReposListPagesBuildsReq) method() string {
	return "GET"
}

func (r *ReposListPagesBuildsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListPagesBuildsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListPagesBuildsReq) body() interface{} {
	return nil
}

func (r *ReposListPagesBuildsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListPagesBuildsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListPagesBuildsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListPagesBuildsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListPagesBuildsReq) Rel(link RelName, resp *ReposListPagesBuildsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListPagesBuildsResponseBody is a response body for ReposListPagesBuilds

https://developer.github.com/v3/repos/pages/#list-pages-builds
*/
type ReposListPagesBuildsResponseBody []struct {
	components.PageBuild
}

/*
ReposListPagesBuildsResponse is a response for ReposListPagesBuilds

https://developer.github.com/v3/repos/pages/#list-pages-builds
*/
type ReposListPagesBuildsResponse struct {
	response
	request *ReposListPagesBuildsReq
	Data    *ReposListPagesBuildsResponseBody
}

/*
ReposListProtectedBranchRequiredStatusChecksContexts performs requests for "repos/list-protected-branch-required-status-checks-contexts"

List required status checks contexts of protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#list-required-status-checks-contexts-of-protected-branch
*/
func (c *Client) ReposListProtectedBranchRequiredStatusChecksContexts(ctx context.Context, req *ReposListProtectedBranchRequiredStatusChecksContextsReq, opt ...RequestOption) (*ReposListProtectedBranchRequiredStatusChecksContextsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListProtectedBranchRequiredStatusChecksContextsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListProtectedBranchRequiredStatusChecksContextsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListProtectedBranchRequiredStatusChecksContextsReq is request data for Client.ReposListProtectedBranchRequiredStatusChecksContexts

https://developer.github.com/v3/repos/branches/#list-required-status-checks-contexts-of-protected-branch
*/
type ReposListProtectedBranchRequiredStatusChecksContextsReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) url() string {
	return r._url
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch)
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) method() string {
	return "GET"
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) body() interface{} {
	return nil
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListProtectedBranchRequiredStatusChecksContextsReq) Rel(link RelName, resp *ReposListProtectedBranchRequiredStatusChecksContextsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListProtectedBranchRequiredStatusChecksContextsResponseBody is a response body for ReposListProtectedBranchRequiredStatusChecksContexts

https://developer.github.com/v3/repos/branches/#list-required-status-checks-contexts-of-protected-branch
*/
type ReposListProtectedBranchRequiredStatusChecksContextsResponseBody []string

/*
ReposListProtectedBranchRequiredStatusChecksContextsResponse is a response for ReposListProtectedBranchRequiredStatusChecksContexts

https://developer.github.com/v3/repos/branches/#list-required-status-checks-contexts-of-protected-branch
*/
type ReposListProtectedBranchRequiredStatusChecksContextsResponse struct {
	response
	request *ReposListProtectedBranchRequiredStatusChecksContextsReq
	Data    *ReposListProtectedBranchRequiredStatusChecksContextsResponseBody
}

/*
ReposListPublic performs requests for "repos/list-public"

List public repositories.

  GET /repositories

https://developer.github.com/v3/repos/#list-public-repositories
*/
func (c *Client) ReposListPublic(ctx context.Context, req *ReposListPublicReq, opt ...RequestOption) (*ReposListPublicResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListPublicResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListPublicResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListPublicReq is request data for Client.ReposListPublic

https://developer.github.com/v3/repos/#list-public-repositories
*/
type ReposListPublicReq struct {
	_url string

	// The integer ID of the last repository that you've seen.
	Since *int64
}

func (r *ReposListPublicReq) url() string {
	return r._url
}

func (r *ReposListPublicReq) urlPath() string {
	return fmt.Sprintf("/repositories")
}

func (r *ReposListPublicReq) method() string {
	return "GET"
}

func (r *ReposListPublicReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", strconv.FormatInt(*r.Since, 10))
	}
	return query
}

func (r *ReposListPublicReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListPublicReq) body() interface{} {
	return nil
}

func (r *ReposListPublicReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListPublicReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListPublicReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListPublicReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListPublicReq) Rel(link RelName, resp *ReposListPublicResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListPublicResponseBody is a response body for ReposListPublic

https://developer.github.com/v3/repos/#list-public-repositories
*/
type ReposListPublicResponseBody []struct {
	components.PublicRepository
}

/*
ReposListPublicResponse is a response for ReposListPublic

https://developer.github.com/v3/repos/#list-public-repositories
*/
type ReposListPublicResponse struct {
	response
	request *ReposListPublicReq
	Data    *ReposListPublicResponseBody
}

/*
ReposListPullRequestsAssociatedWithCommit performs requests for "repos/list-pull-requests-associated-with-commit"

List pull requests associated with commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-commit
*/
func (c *Client) ReposListPullRequestsAssociatedWithCommit(ctx context.Context, req *ReposListPullRequestsAssociatedWithCommitReq, opt ...RequestOption) (*ReposListPullRequestsAssociatedWithCommitResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListPullRequestsAssociatedWithCommitResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListPullRequestsAssociatedWithCommitResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListPullRequestsAssociatedWithCommitReq is request data for Client.ReposListPullRequestsAssociatedWithCommit

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-commit
*/
type ReposListPullRequestsAssociatedWithCommitReq struct {
	_url      string
	Owner     string
	Repo      string
	CommitSha string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Listing branches or pull requests for a commit in the Commits API is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-04-11-pulls-branches-for-commit/)
	for more details. To access the new endpoints during the preview period, you
	must set this to true.
	*/
	GrootPreview bool
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) url() string {
	return r._url
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/pulls", r.Owner, r.Repo, r.CommitSha)
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) method() string {
	return "GET"
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"groot": r.GrootPreview}
	if requiredPreviews {
		previewVals["groot"] = true
	}
	if allPreviews {
		previewVals["groot"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) body() interface{} {
	return nil
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListPullRequestsAssociatedWithCommitReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListPullRequestsAssociatedWithCommitReq) Rel(link RelName, resp *ReposListPullRequestsAssociatedWithCommitResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListPullRequestsAssociatedWithCommitResponseBody is a response body for ReposListPullRequestsAssociatedWithCommit

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-commit
*/
type ReposListPullRequestsAssociatedWithCommitResponseBody []struct {
	components.PullRequestSimple
}

/*
ReposListPullRequestsAssociatedWithCommitResponse is a response for ReposListPullRequestsAssociatedWithCommit

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-commit
*/
type ReposListPullRequestsAssociatedWithCommitResponse struct {
	response
	request *ReposListPullRequestsAssociatedWithCommitReq
	Data    *ReposListPullRequestsAssociatedWithCommitResponseBody
}

/*
ReposListReleases performs requests for "repos/list-releases"

List releases for a repository.

  GET /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#list-releases-for-a-repository
*/
func (c *Client) ReposListReleases(ctx context.Context, req *ReposListReleasesReq, opt ...RequestOption) (*ReposListReleasesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListReleasesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListReleasesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListReleasesReq is request data for Client.ReposListReleases

https://developer.github.com/v3/repos/releases/#list-releases-for-a-repository
*/
type ReposListReleasesReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListReleasesReq) url() string {
	return r._url
}

func (r *ReposListReleasesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases", r.Owner, r.Repo)
}

func (r *ReposListReleasesReq) method() string {
	return "GET"
}

func (r *ReposListReleasesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListReleasesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListReleasesReq) body() interface{} {
	return nil
}

func (r *ReposListReleasesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListReleasesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListReleasesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListReleasesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListReleasesReq) Rel(link RelName, resp *ReposListReleasesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListReleasesResponseBody is a response body for ReposListReleases

https://developer.github.com/v3/repos/releases/#list-releases-for-a-repository
*/
type ReposListReleasesResponseBody []struct {
	components.Release2
}

/*
ReposListReleasesResponse is a response for ReposListReleases

https://developer.github.com/v3/repos/releases/#list-releases-for-a-repository
*/
type ReposListReleasesResponse struct {
	response
	request *ReposListReleasesReq
	Data    *ReposListReleasesResponseBody
}

/*
ReposListStatusesForRef performs requests for "repos/list-statuses-for-ref"

List statuses for a specific ref.

  GET /repos/{owner}/{repo}/commits/{ref}/statuses

https://developer.github.com/v3/repos/statuses/#list-statuses-for-a-specific-ref
*/
func (c *Client) ReposListStatusesForRef(ctx context.Context, req *ReposListStatusesForRefReq, opt ...RequestOption) (*ReposListStatusesForRefResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListStatusesForRefResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListStatusesForRefResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListStatusesForRefReq is request data for Client.ReposListStatusesForRef

https://developer.github.com/v3/repos/statuses/#list-statuses-for-a-specific-ref
*/
type ReposListStatusesForRefReq struct {
	_url  string
	Owner string
	Repo  string
	Ref   string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListStatusesForRefReq) url() string {
	return r._url
}

func (r *ReposListStatusesForRefReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/statuses", r.Owner, r.Repo, r.Ref)
}

func (r *ReposListStatusesForRefReq) method() string {
	return "GET"
}

func (r *ReposListStatusesForRefReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListStatusesForRefReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListStatusesForRefReq) body() interface{} {
	return nil
}

func (r *ReposListStatusesForRefReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListStatusesForRefReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListStatusesForRefReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListStatusesForRefReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListStatusesForRefReq) Rel(link RelName, resp *ReposListStatusesForRefResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListStatusesForRefResponseBody is a response body for ReposListStatusesForRef

https://developer.github.com/v3/repos/statuses/#list-statuses-for-a-specific-ref
*/
type ReposListStatusesForRefResponseBody []struct {
	components.Status
}

/*
ReposListStatusesForRefResponse is a response for ReposListStatusesForRef

https://developer.github.com/v3/repos/statuses/#list-statuses-for-a-specific-ref
*/
type ReposListStatusesForRefResponse struct {
	response
	request *ReposListStatusesForRefReq
	Data    *ReposListStatusesForRefResponseBody
}

/*
ReposListTags performs requests for "repos/list-tags"

List tags.

  GET /repos/{owner}/{repo}/tags

https://developer.github.com/v3/repos/#list-tags
*/
func (c *Client) ReposListTags(ctx context.Context, req *ReposListTagsReq, opt ...RequestOption) (*ReposListTagsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListTagsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListTagsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListTagsReq is request data for Client.ReposListTags

https://developer.github.com/v3/repos/#list-tags
*/
type ReposListTagsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListTagsReq) url() string {
	return r._url
}

func (r *ReposListTagsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/tags", r.Owner, r.Repo)
}

func (r *ReposListTagsReq) method() string {
	return "GET"
}

func (r *ReposListTagsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListTagsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListTagsReq) body() interface{} {
	return nil
}

func (r *ReposListTagsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListTagsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListTagsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListTagsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListTagsReq) Rel(link RelName, resp *ReposListTagsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListTagsResponseBody is a response body for ReposListTags

https://developer.github.com/v3/repos/#list-tags
*/
type ReposListTagsResponseBody []struct {
	components.Tag
}

/*
ReposListTagsResponse is a response for ReposListTags

https://developer.github.com/v3/repos/#list-tags
*/
type ReposListTagsResponse struct {
	response
	request *ReposListTagsReq
	Data    *ReposListTagsResponseBody
}

/*
ReposListTeams performs requests for "repos/list-teams"

List teams.

  GET /repos/{owner}/{repo}/teams

https://developer.github.com/v3/repos/#list-teams
*/
func (c *Client) ReposListTeams(ctx context.Context, req *ReposListTeamsReq, opt ...RequestOption) (*ReposListTeamsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposListTeamsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposListTeamsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListTeamsReq is request data for Client.ReposListTeams

https://developer.github.com/v3/repos/#list-teams
*/
type ReposListTeamsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListTeamsReq) url() string {
	return r._url
}

func (r *ReposListTeamsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/teams", r.Owner, r.Repo)
}

func (r *ReposListTeamsReq) method() string {
	return "GET"
}

func (r *ReposListTeamsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListTeamsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListTeamsReq) body() interface{} {
	return nil
}

func (r *ReposListTeamsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListTeamsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListTeamsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposListTeamsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListTeamsReq) Rel(link RelName, resp *ReposListTeamsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListTeamsResponseBody is a response body for ReposListTeams

https://developer.github.com/v3/repos/#list-teams
*/
type ReposListTeamsResponseBody []struct {
	components.Team
}

/*
ReposListTeamsResponse is a response for ReposListTeams

https://developer.github.com/v3/repos/#list-teams
*/
type ReposListTeamsResponse struct {
	response
	request *ReposListTeamsReq
	Data    *ReposListTeamsResponseBody
}

/*
ReposMerge performs requests for "repos/merge"

Perform a merge.

  POST /repos/{owner}/{repo}/merges

https://developer.github.com/v3/repos/merging/#perform-a-merge
*/
func (c *Client) ReposMerge(ctx context.Context, req *ReposMergeReq, opt ...RequestOption) (*ReposMergeResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposMergeResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposMergeResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposMergeReq is request data for Client.ReposMerge

https://developer.github.com/v3/repos/merging/#perform-a-merge
*/
type ReposMergeReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposMergeReqBody
}

func (r *ReposMergeReq) url() string {
	return r._url
}

func (r *ReposMergeReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/merges", r.Owner, r.Repo)
}

func (r *ReposMergeReq) method() string {
	return "POST"
}

func (r *ReposMergeReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposMergeReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposMergeReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposMergeReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposMergeReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposMergeReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposMergeReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposMergeReq) Rel(link RelName, resp *ReposMergeResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposMergeReqBody is a request body for repos/merge

https://developer.github.com/v3/repos/merging/#perform-a-merge
*/
type ReposMergeReqBody struct {

	// The name of the base branch that the head will be merged into.
	Base *string `json:"base"`

	/*
	   Commit message to use for the merge commit. If omitted, a default message will
	   be used.
	*/
	CommitMessage *string `json:"commit_message,omitempty"`

	// The head to merge. This can be a branch name or a commit SHA1.
	Head *string `json:"head"`
}

/*
ReposMergeResponseBody is a response body for ReposMerge

https://developer.github.com/v3/repos/merging/#perform-a-merge
*/
type ReposMergeResponseBody struct {
	components.SimpleCommit2
}

/*
ReposMergeResponse is a response for ReposMerge

https://developer.github.com/v3/repos/merging/#perform-a-merge
*/
type ReposMergeResponse struct {
	response
	request *ReposMergeReq
	Data    *ReposMergeResponseBody
}

/*
ReposPingHook performs requests for "repos/ping-hook"

Ping a hook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/pings

https://developer.github.com/v3/repos/hooks/#ping-a-hook
*/
func (c *Client) ReposPingHook(ctx context.Context, req *ReposPingHookReq, opt ...RequestOption) (*ReposPingHookResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposPingHookResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposPingHookReq is request data for Client.ReposPingHook

https://developer.github.com/v3/repos/hooks/#ping-a-hook
*/
type ReposPingHookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

func (r *ReposPingHookReq) url() string {
	return r._url
}

func (r *ReposPingHookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v/pings", r.Owner, r.Repo, r.HookId)
}

func (r *ReposPingHookReq) method() string {
	return "POST"
}

func (r *ReposPingHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposPingHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposPingHookReq) body() interface{} {
	return nil
}

func (r *ReposPingHookReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposPingHookReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposPingHookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposPingHookReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposPingHookReq) Rel(link RelName, resp *ReposPingHookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposPingHookResponse is a response for ReposPingHook

https://developer.github.com/v3/repos/hooks/#ping-a-hook
*/
type ReposPingHookResponse struct {
	response
	request *ReposPingHookReq
}

/*
ReposRemoveBranchProtection performs requests for "repos/remove-branch-protection"

Remove branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#remove-branch-protection
*/
func (c *Client) ReposRemoveBranchProtection(ctx context.Context, req *ReposRemoveBranchProtectionReq, opt ...RequestOption) (*ReposRemoveBranchProtectionResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRemoveBranchProtectionResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveBranchProtectionReq is request data for Client.ReposRemoveBranchProtection

https://developer.github.com/v3/repos/branches/#remove-branch-protection
*/
type ReposRemoveBranchProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposRemoveBranchProtectionReq) url() string {
	return r._url
}

func (r *ReposRemoveBranchProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveBranchProtectionReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveBranchProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveBranchProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveBranchProtectionReq) body() interface{} {
	return nil
}

func (r *ReposRemoveBranchProtectionReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposRemoveBranchProtectionReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposRemoveBranchProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposRemoveBranchProtectionReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveBranchProtectionReq) Rel(link RelName, resp *ReposRemoveBranchProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveBranchProtectionResponse is a response for ReposRemoveBranchProtection

https://developer.github.com/v3/repos/branches/#remove-branch-protection
*/
type ReposRemoveBranchProtectionResponse struct {
	response
	request *ReposRemoveBranchProtectionReq
}

/*
ReposRemoveCollaborator performs requests for "repos/remove-collaborator"

Remove user as a collaborator.

  DELETE /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#remove-user-as-a-collaborator
*/
func (c *Client) ReposRemoveCollaborator(ctx context.Context, req *ReposRemoveCollaboratorReq, opt ...RequestOption) (*ReposRemoveCollaboratorResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRemoveCollaboratorResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveCollaboratorReq is request data for Client.ReposRemoveCollaborator

https://developer.github.com/v3/repos/collaborators/#remove-user-as-a-collaborator
*/
type ReposRemoveCollaboratorReq struct {
	_url     string
	Owner    string
	Repo     string
	Username string
}

func (r *ReposRemoveCollaboratorReq) url() string {
	return r._url
}

func (r *ReposRemoveCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username)
}

func (r *ReposRemoveCollaboratorReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveCollaboratorReq) body() interface{} {
	return nil
}

func (r *ReposRemoveCollaboratorReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposRemoveCollaboratorReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposRemoveCollaboratorReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposRemoveCollaboratorReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveCollaboratorReq) Rel(link RelName, resp *ReposRemoveCollaboratorResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveCollaboratorResponse is a response for ReposRemoveCollaborator

https://developer.github.com/v3/repos/collaborators/#remove-user-as-a-collaborator
*/
type ReposRemoveCollaboratorResponse struct {
	response
	request *ReposRemoveCollaboratorReq
}

/*
ReposRemoveDeployKey performs requests for "repos/remove-deploy-key"

Remove a deploy key.

  DELETE /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#remove-a-deploy-key
*/
func (c *Client) ReposRemoveDeployKey(ctx context.Context, req *ReposRemoveDeployKeyReq, opt ...RequestOption) (*ReposRemoveDeployKeyResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRemoveDeployKeyResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveDeployKeyReq is request data for Client.ReposRemoveDeployKey

https://developer.github.com/v3/repos/keys/#remove-a-deploy-key
*/
type ReposRemoveDeployKeyReq struct {
	_url  string
	Owner string
	Repo  string
	KeyId int64
}

func (r *ReposRemoveDeployKeyReq) url() string {
	return r._url
}

func (r *ReposRemoveDeployKeyReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/keys/%v", r.Owner, r.Repo, r.KeyId)
}

func (r *ReposRemoveDeployKeyReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveDeployKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveDeployKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveDeployKeyReq) body() interface{} {
	return nil
}

func (r *ReposRemoveDeployKeyReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposRemoveDeployKeyReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposRemoveDeployKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposRemoveDeployKeyReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveDeployKeyReq) Rel(link RelName, resp *ReposRemoveDeployKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveDeployKeyResponse is a response for ReposRemoveDeployKey

https://developer.github.com/v3/repos/keys/#remove-a-deploy-key
*/
type ReposRemoveDeployKeyResponse struct {
	response
	request *ReposRemoveDeployKeyReq
}

/*
ReposRemoveProtectedBranchAdminEnforcement performs requests for "repos/remove-protected-branch-admin-enforcement"

Remove admin enforcement of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#remove-admin-enforcement-of-protected-branch
*/
func (c *Client) ReposRemoveProtectedBranchAdminEnforcement(ctx context.Context, req *ReposRemoveProtectedBranchAdminEnforcementReq, opt ...RequestOption) (*ReposRemoveProtectedBranchAdminEnforcementResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRemoveProtectedBranchAdminEnforcementResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveProtectedBranchAdminEnforcementReq is request data for Client.ReposRemoveProtectedBranchAdminEnforcement

https://developer.github.com/v3/repos/branches/#remove-admin-enforcement-of-protected-branch
*/
type ReposRemoveProtectedBranchAdminEnforcementReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) url() string {
	return r._url
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) body() interface{} {
	return nil
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) validStatuses() []int {
	return []int{}
}

func (r *ReposRemoveProtectedBranchAdminEnforcementReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposRemoveProtectedBranchAdminEnforcementReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveProtectedBranchAdminEnforcementReq) Rel(link RelName, resp *ReposRemoveProtectedBranchAdminEnforcementResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveProtectedBranchAdminEnforcementResponse is a response for ReposRemoveProtectedBranchAdminEnforcement

https://developer.github.com/v3/repos/branches/#remove-admin-enforcement-of-protected-branch
*/
type ReposRemoveProtectedBranchAdminEnforcementResponse struct {
	response
	request *ReposRemoveProtectedBranchAdminEnforcementReq
}

/*
ReposRemoveProtectedBranchAppRestrictions performs requests for "repos/remove-protected-branch-app-restrictions"

Remove app restrictions of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#remove-app-restrictions-of-protected-branch
*/
func (c *Client) ReposRemoveProtectedBranchAppRestrictions(ctx context.Context, req *ReposRemoveProtectedBranchAppRestrictionsReq, opt ...RequestOption) (*ReposRemoveProtectedBranchAppRestrictionsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRemoveProtectedBranchAppRestrictionsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposRemoveProtectedBranchAppRestrictionsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveProtectedBranchAppRestrictionsReq is request data for Client.ReposRemoveProtectedBranchAppRestrictions

https://developer.github.com/v3/repos/branches/#remove-app-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchAppRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposRemoveProtectedBranchAppRestrictionsReqBody
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) url() string {
	return r._url
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveProtectedBranchAppRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposRemoveProtectedBranchAppRestrictionsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveProtectedBranchAppRestrictionsReq) Rel(link RelName, resp *ReposRemoveProtectedBranchAppRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveProtectedBranchAppRestrictionsReqBody is a request body for repos/remove-protected-branch-app-restrictions

https://developer.github.com/v3/repos/branches/#remove-app-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchAppRestrictionsReqBody []string

/*
ReposRemoveProtectedBranchAppRestrictionsResponseBody is a response body for ReposRemoveProtectedBranchAppRestrictions

https://developer.github.com/v3/repos/branches/#remove-app-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchAppRestrictionsResponseBody []struct {
	components.Integration2
}

/*
ReposRemoveProtectedBranchAppRestrictionsResponse is a response for ReposRemoveProtectedBranchAppRestrictions

https://developer.github.com/v3/repos/branches/#remove-app-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchAppRestrictionsResponse struct {
	response
	request *ReposRemoveProtectedBranchAppRestrictionsReq
	Data    *ReposRemoveProtectedBranchAppRestrictionsResponseBody
}

/*
ReposRemoveProtectedBranchPullRequestReviewEnforcement performs requests for "repos/remove-protected-branch-pull-request-review-enforcement"

Remove pull request review enforcement of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#remove-pull-request-review-enforcement-of-protected-branch
*/
func (c *Client) ReposRemoveProtectedBranchPullRequestReviewEnforcement(ctx context.Context, req *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq, opt ...RequestOption) (*ReposRemoveProtectedBranchPullRequestReviewEnforcementResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRemoveProtectedBranchPullRequestReviewEnforcementResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveProtectedBranchPullRequestReviewEnforcementReq is request data for Client.ReposRemoveProtectedBranchPullRequestReviewEnforcement

https://developer.github.com/v3/repos/branches/#remove-pull-request-review-enforcement-of-protected-branch
*/
type ReposRemoveProtectedBranchPullRequestReviewEnforcementReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) url() string {
	return r._url
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) body() interface{} {
	return nil
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) validStatuses() []int {
	return []int{}
}

func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq) Rel(link RelName, resp *ReposRemoveProtectedBranchPullRequestReviewEnforcementResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveProtectedBranchPullRequestReviewEnforcementResponse is a response for ReposRemoveProtectedBranchPullRequestReviewEnforcement

https://developer.github.com/v3/repos/branches/#remove-pull-request-review-enforcement-of-protected-branch
*/
type ReposRemoveProtectedBranchPullRequestReviewEnforcementResponse struct {
	response
	request *ReposRemoveProtectedBranchPullRequestReviewEnforcementReq
}

/*
ReposRemoveProtectedBranchRequiredSignatures performs requests for "repos/remove-protected-branch-required-signatures"

Remove required signatures of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#remove-required-signatures-of-protected-branch
*/
func (c *Client) ReposRemoveProtectedBranchRequiredSignatures(ctx context.Context, req *ReposRemoveProtectedBranchRequiredSignaturesReq, opt ...RequestOption) (*ReposRemoveProtectedBranchRequiredSignaturesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRemoveProtectedBranchRequiredSignaturesResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveProtectedBranchRequiredSignaturesReq is request data for Client.ReposRemoveProtectedBranchRequiredSignatures

https://developer.github.com/v3/repos/branches/#remove-required-signatures-of-protected-branch
*/
type ReposRemoveProtectedBranchRequiredSignaturesReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) url() string {
	return r._url
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"zzzax": r.ZzzaxPreview}
	if requiredPreviews {
		previewVals["zzzax"] = true
	}
	if allPreviews {
		previewVals["zzzax"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) body() interface{} {
	return nil
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) validStatuses() []int {
	return []int{}
}

func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveProtectedBranchRequiredSignaturesReq) Rel(link RelName, resp *ReposRemoveProtectedBranchRequiredSignaturesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveProtectedBranchRequiredSignaturesResponse is a response for ReposRemoveProtectedBranchRequiredSignatures

https://developer.github.com/v3/repos/branches/#remove-required-signatures-of-protected-branch
*/
type ReposRemoveProtectedBranchRequiredSignaturesResponse struct {
	response
	request *ReposRemoveProtectedBranchRequiredSignaturesReq
}

/*
ReposRemoveProtectedBranchRequiredStatusChecks performs requests for "repos/remove-protected-branch-required-status-checks"

Remove required status checks of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#remove-required-status-checks-of-protected-branch
*/
func (c *Client) ReposRemoveProtectedBranchRequiredStatusChecks(ctx context.Context, req *ReposRemoveProtectedBranchRequiredStatusChecksReq, opt ...RequestOption) (*ReposRemoveProtectedBranchRequiredStatusChecksResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRemoveProtectedBranchRequiredStatusChecksResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveProtectedBranchRequiredStatusChecksReq is request data for Client.ReposRemoveProtectedBranchRequiredStatusChecks

https://developer.github.com/v3/repos/branches/#remove-required-status-checks-of-protected-branch
*/
type ReposRemoveProtectedBranchRequiredStatusChecksReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) url() string {
	return r._url
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) body() interface{} {
	return nil
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) validStatuses() []int {
	return []int{}
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveProtectedBranchRequiredStatusChecksReq) Rel(link RelName, resp *ReposRemoveProtectedBranchRequiredStatusChecksResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveProtectedBranchRequiredStatusChecksResponse is a response for ReposRemoveProtectedBranchRequiredStatusChecks

https://developer.github.com/v3/repos/branches/#remove-required-status-checks-of-protected-branch
*/
type ReposRemoveProtectedBranchRequiredStatusChecksResponse struct {
	response
	request *ReposRemoveProtectedBranchRequiredStatusChecksReq
}

/*
ReposRemoveProtectedBranchRequiredStatusChecksContexts performs requests for "repos/remove-protected-branch-required-status-checks-contexts"

Remove required status checks contexts of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#remove-required-status-checks-contexts-of-protected-branch
*/
func (c *Client) ReposRemoveProtectedBranchRequiredStatusChecksContexts(ctx context.Context, req *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq, opt ...RequestOption) (*ReposRemoveProtectedBranchRequiredStatusChecksContextsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRemoveProtectedBranchRequiredStatusChecksContextsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposRemoveProtectedBranchRequiredStatusChecksContextsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveProtectedBranchRequiredStatusChecksContextsReq is request data for Client.ReposRemoveProtectedBranchRequiredStatusChecksContexts

https://developer.github.com/v3/repos/branches/#remove-required-status-checks-contexts-of-protected-branch
*/
type ReposRemoveProtectedBranchRequiredStatusChecksContextsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposRemoveProtectedBranchRequiredStatusChecksContextsReqBody
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) url() string {
	return r._url
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq) Rel(link RelName, resp *ReposRemoveProtectedBranchRequiredStatusChecksContextsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveProtectedBranchRequiredStatusChecksContextsReqBody is a request body for repos/remove-protected-branch-required-status-checks-contexts

https://developer.github.com/v3/repos/branches/#remove-required-status-checks-contexts-of-protected-branch
*/
type ReposRemoveProtectedBranchRequiredStatusChecksContextsReqBody []string

/*
ReposRemoveProtectedBranchRequiredStatusChecksContextsResponseBody is a response body for ReposRemoveProtectedBranchRequiredStatusChecksContexts

https://developer.github.com/v3/repos/branches/#remove-required-status-checks-contexts-of-protected-branch
*/
type ReposRemoveProtectedBranchRequiredStatusChecksContextsResponseBody []string

/*
ReposRemoveProtectedBranchRequiredStatusChecksContextsResponse is a response for ReposRemoveProtectedBranchRequiredStatusChecksContexts

https://developer.github.com/v3/repos/branches/#remove-required-status-checks-contexts-of-protected-branch
*/
type ReposRemoveProtectedBranchRequiredStatusChecksContextsResponse struct {
	response
	request *ReposRemoveProtectedBranchRequiredStatusChecksContextsReq
	Data    *ReposRemoveProtectedBranchRequiredStatusChecksContextsResponseBody
}

/*
ReposRemoveProtectedBranchRestrictions performs requests for "repos/remove-protected-branch-restrictions"

Remove restrictions of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#remove-restrictions-of-protected-branch
*/
func (c *Client) ReposRemoveProtectedBranchRestrictions(ctx context.Context, req *ReposRemoveProtectedBranchRestrictionsReq, opt ...RequestOption) (*ReposRemoveProtectedBranchRestrictionsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRemoveProtectedBranchRestrictionsResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveProtectedBranchRestrictionsReq is request data for Client.ReposRemoveProtectedBranchRestrictions

https://developer.github.com/v3/repos/branches/#remove-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchRestrictionsReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) url() string {
	return r._url
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) body() interface{} {
	return nil
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) validStatuses() []int {
	return []int{}
}

func (r *ReposRemoveProtectedBranchRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposRemoveProtectedBranchRestrictionsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveProtectedBranchRestrictionsReq) Rel(link RelName, resp *ReposRemoveProtectedBranchRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveProtectedBranchRestrictionsResponse is a response for ReposRemoveProtectedBranchRestrictions

https://developer.github.com/v3/repos/branches/#remove-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchRestrictionsResponse struct {
	response
	request *ReposRemoveProtectedBranchRestrictionsReq
}

/*
ReposRemoveProtectedBranchTeamRestrictions performs requests for "repos/remove-protected-branch-team-restrictions"

Remove team restrictions of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#remove-team-restrictions-of-protected-branch
*/
func (c *Client) ReposRemoveProtectedBranchTeamRestrictions(ctx context.Context, req *ReposRemoveProtectedBranchTeamRestrictionsReq, opt ...RequestOption) (*ReposRemoveProtectedBranchTeamRestrictionsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRemoveProtectedBranchTeamRestrictionsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposRemoveProtectedBranchTeamRestrictionsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveProtectedBranchTeamRestrictionsReq is request data for Client.ReposRemoveProtectedBranchTeamRestrictions

https://developer.github.com/v3/repos/branches/#remove-team-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchTeamRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposRemoveProtectedBranchTeamRestrictionsReqBody
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) url() string {
	return r._url
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveProtectedBranchTeamRestrictionsReq) Rel(link RelName, resp *ReposRemoveProtectedBranchTeamRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveProtectedBranchTeamRestrictionsReqBody is a request body for repos/remove-protected-branch-team-restrictions

https://developer.github.com/v3/repos/branches/#remove-team-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchTeamRestrictionsReqBody []string

/*
ReposRemoveProtectedBranchTeamRestrictionsResponseBody is a response body for ReposRemoveProtectedBranchTeamRestrictions

https://developer.github.com/v3/repos/branches/#remove-team-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchTeamRestrictionsResponseBody []struct {
	components.Team
}

/*
ReposRemoveProtectedBranchTeamRestrictionsResponse is a response for ReposRemoveProtectedBranchTeamRestrictions

https://developer.github.com/v3/repos/branches/#remove-team-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchTeamRestrictionsResponse struct {
	response
	request *ReposRemoveProtectedBranchTeamRestrictionsReq
	Data    *ReposRemoveProtectedBranchTeamRestrictionsResponseBody
}

/*
ReposRemoveProtectedBranchUserRestrictions performs requests for "repos/remove-protected-branch-user-restrictions"

Remove user restrictions of protected branch.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#remove-user-restrictions-of-protected-branch
*/
func (c *Client) ReposRemoveProtectedBranchUserRestrictions(ctx context.Context, req *ReposRemoveProtectedBranchUserRestrictionsReq, opt ...RequestOption) (*ReposRemoveProtectedBranchUserRestrictionsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRemoveProtectedBranchUserRestrictionsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposRemoveProtectedBranchUserRestrictionsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveProtectedBranchUserRestrictionsReq is request data for Client.ReposRemoveProtectedBranchUserRestrictions

https://developer.github.com/v3/repos/branches/#remove-user-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchUserRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposRemoveProtectedBranchUserRestrictionsReqBody
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) url() string {
	return r._url
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveProtectedBranchUserRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposRemoveProtectedBranchUserRestrictionsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveProtectedBranchUserRestrictionsReq) Rel(link RelName, resp *ReposRemoveProtectedBranchUserRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveProtectedBranchUserRestrictionsReqBody is a request body for repos/remove-protected-branch-user-restrictions

https://developer.github.com/v3/repos/branches/#remove-user-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchUserRestrictionsReqBody []string

/*
ReposRemoveProtectedBranchUserRestrictionsResponseBody is a response body for ReposRemoveProtectedBranchUserRestrictions

https://developer.github.com/v3/repos/branches/#remove-user-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchUserRestrictionsResponseBody []struct {
	components.SimpleUser
}

/*
ReposRemoveProtectedBranchUserRestrictionsResponse is a response for ReposRemoveProtectedBranchUserRestrictions

https://developer.github.com/v3/repos/branches/#remove-user-restrictions-of-protected-branch
*/
type ReposRemoveProtectedBranchUserRestrictionsResponse struct {
	response
	request *ReposRemoveProtectedBranchUserRestrictionsReq
	Data    *ReposRemoveProtectedBranchUserRestrictionsResponseBody
}

/*
ReposReplaceAllTopics performs requests for "repos/replace-all-topics"

Replace all repository topics.

  PUT /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
func (c *Client) ReposReplaceAllTopics(ctx context.Context, req *ReposReplaceAllTopicsReq, opt ...RequestOption) (*ReposReplaceAllTopicsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposReplaceAllTopicsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposReplaceAllTopicsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposReplaceAllTopicsReq is request data for Client.ReposReplaceAllTopics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposReplaceAllTopicsReqBody

	/*
	Repository topics on GitHub are currently available for developers to preview.
	To use this endpoint, you must set this to true.
	*/
	MercyPreview bool
}

func (r *ReposReplaceAllTopicsReq) url() string {
	return r._url
}

func (r *ReposReplaceAllTopicsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/topics", r.Owner, r.Repo)
}

func (r *ReposReplaceAllTopicsReq) method() string {
	return "PUT"
}

func (r *ReposReplaceAllTopicsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposReplaceAllTopicsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"mercy": r.MercyPreview}
	if requiredPreviews {
		previewVals["mercy"] = true
	}
	if allPreviews {
		previewVals["mercy"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposReplaceAllTopicsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposReplaceAllTopicsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposReplaceAllTopicsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposReplaceAllTopicsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposReplaceAllTopicsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposReplaceAllTopicsReq) Rel(link RelName, resp *ReposReplaceAllTopicsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposReplaceAllTopicsReqBody is a request body for repos/replace-all-topics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsReqBody struct {

	/*
	   An array of topics to add to the repository. Pass one or more topics to
	   _replace_ the set of existing topics. Send an empty array (`[]`) to clear all
	   topics from the repository. **Note:** Topic `names` cannot contain uppercase
	   letters.
	*/
	Names []string `json:"names"`
}

/*
ReposReplaceAllTopicsResponseBody is a response body for ReposReplaceAllTopics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsResponseBody struct {
	components.Topic
}

/*
ReposReplaceAllTopicsResponse is a response for ReposReplaceAllTopics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsResponse struct {
	response
	request *ReposReplaceAllTopicsReq
	Data    *ReposReplaceAllTopicsResponseBody
}

/*
ReposReplaceProtectedBranchAppRestrictions performs requests for "repos/replace-protected-branch-app-restrictions"

Replace app restrictions of protected branch.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#replace-app-restrictions-of-protected-branch
*/
func (c *Client) ReposReplaceProtectedBranchAppRestrictions(ctx context.Context, req *ReposReplaceProtectedBranchAppRestrictionsReq, opt ...RequestOption) (*ReposReplaceProtectedBranchAppRestrictionsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposReplaceProtectedBranchAppRestrictionsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposReplaceProtectedBranchAppRestrictionsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposReplaceProtectedBranchAppRestrictionsReq is request data for Client.ReposReplaceProtectedBranchAppRestrictions

https://developer.github.com/v3/repos/branches/#replace-app-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchAppRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposReplaceProtectedBranchAppRestrictionsReqBody
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) url() string {
	return r._url
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch)
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) method() string {
	return "PUT"
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposReplaceProtectedBranchAppRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposReplaceProtectedBranchAppRestrictionsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposReplaceProtectedBranchAppRestrictionsReq) Rel(link RelName, resp *ReposReplaceProtectedBranchAppRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposReplaceProtectedBranchAppRestrictionsReqBody is a request body for repos/replace-protected-branch-app-restrictions

https://developer.github.com/v3/repos/branches/#replace-app-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchAppRestrictionsReqBody []string

/*
ReposReplaceProtectedBranchAppRestrictionsResponseBody is a response body for ReposReplaceProtectedBranchAppRestrictions

https://developer.github.com/v3/repos/branches/#replace-app-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchAppRestrictionsResponseBody []struct {
	components.Integration2
}

/*
ReposReplaceProtectedBranchAppRestrictionsResponse is a response for ReposReplaceProtectedBranchAppRestrictions

https://developer.github.com/v3/repos/branches/#replace-app-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchAppRestrictionsResponse struct {
	response
	request *ReposReplaceProtectedBranchAppRestrictionsReq
	Data    *ReposReplaceProtectedBranchAppRestrictionsResponseBody
}

/*
ReposReplaceProtectedBranchRequiredStatusChecksContexts performs requests for "repos/replace-protected-branch-required-status-checks-contexts"

Replace required status checks contexts of protected branch.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#replace-required-status-checks-contexts-of-protected-branch
*/
func (c *Client) ReposReplaceProtectedBranchRequiredStatusChecksContexts(ctx context.Context, req *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq, opt ...RequestOption) (*ReposReplaceProtectedBranchRequiredStatusChecksContextsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposReplaceProtectedBranchRequiredStatusChecksContextsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposReplaceProtectedBranchRequiredStatusChecksContextsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposReplaceProtectedBranchRequiredStatusChecksContextsReq is request data for Client.ReposReplaceProtectedBranchRequiredStatusChecksContexts

https://developer.github.com/v3/repos/branches/#replace-required-status-checks-contexts-of-protected-branch
*/
type ReposReplaceProtectedBranchRequiredStatusChecksContextsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposReplaceProtectedBranchRequiredStatusChecksContextsReqBody
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) url() string {
	return r._url
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch)
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) method() string {
	return "PUT"
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq) Rel(link RelName, resp *ReposReplaceProtectedBranchRequiredStatusChecksContextsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposReplaceProtectedBranchRequiredStatusChecksContextsReqBody is a request body for repos/replace-protected-branch-required-status-checks-contexts

https://developer.github.com/v3/repos/branches/#replace-required-status-checks-contexts-of-protected-branch
*/
type ReposReplaceProtectedBranchRequiredStatusChecksContextsReqBody []string

/*
ReposReplaceProtectedBranchRequiredStatusChecksContextsResponseBody is a response body for ReposReplaceProtectedBranchRequiredStatusChecksContexts

https://developer.github.com/v3/repos/branches/#replace-required-status-checks-contexts-of-protected-branch
*/
type ReposReplaceProtectedBranchRequiredStatusChecksContextsResponseBody []string

/*
ReposReplaceProtectedBranchRequiredStatusChecksContextsResponse is a response for ReposReplaceProtectedBranchRequiredStatusChecksContexts

https://developer.github.com/v3/repos/branches/#replace-required-status-checks-contexts-of-protected-branch
*/
type ReposReplaceProtectedBranchRequiredStatusChecksContextsResponse struct {
	response
	request *ReposReplaceProtectedBranchRequiredStatusChecksContextsReq
	Data    *ReposReplaceProtectedBranchRequiredStatusChecksContextsResponseBody
}

/*
ReposReplaceProtectedBranchTeamRestrictions performs requests for "repos/replace-protected-branch-team-restrictions"

Replace team restrictions of protected branch.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#replace-team-restrictions-of-protected-branch
*/
func (c *Client) ReposReplaceProtectedBranchTeamRestrictions(ctx context.Context, req *ReposReplaceProtectedBranchTeamRestrictionsReq, opt ...RequestOption) (*ReposReplaceProtectedBranchTeamRestrictionsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposReplaceProtectedBranchTeamRestrictionsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposReplaceProtectedBranchTeamRestrictionsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposReplaceProtectedBranchTeamRestrictionsReq is request data for Client.ReposReplaceProtectedBranchTeamRestrictions

https://developer.github.com/v3/repos/branches/#replace-team-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchTeamRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposReplaceProtectedBranchTeamRestrictionsReqBody
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) url() string {
	return r._url
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch)
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) method() string {
	return "PUT"
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposReplaceProtectedBranchTeamRestrictionsReq) Rel(link RelName, resp *ReposReplaceProtectedBranchTeamRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposReplaceProtectedBranchTeamRestrictionsReqBody is a request body for repos/replace-protected-branch-team-restrictions

https://developer.github.com/v3/repos/branches/#replace-team-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchTeamRestrictionsReqBody []string

/*
ReposReplaceProtectedBranchTeamRestrictionsResponseBody is a response body for ReposReplaceProtectedBranchTeamRestrictions

https://developer.github.com/v3/repos/branches/#replace-team-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchTeamRestrictionsResponseBody []struct {
	components.Team
}

/*
ReposReplaceProtectedBranchTeamRestrictionsResponse is a response for ReposReplaceProtectedBranchTeamRestrictions

https://developer.github.com/v3/repos/branches/#replace-team-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchTeamRestrictionsResponse struct {
	response
	request *ReposReplaceProtectedBranchTeamRestrictionsReq
	Data    *ReposReplaceProtectedBranchTeamRestrictionsResponseBody
}

/*
ReposReplaceProtectedBranchUserRestrictions performs requests for "repos/replace-protected-branch-user-restrictions"

Replace user restrictions of protected branch.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#replace-user-restrictions-of-protected-branch
*/
func (c *Client) ReposReplaceProtectedBranchUserRestrictions(ctx context.Context, req *ReposReplaceProtectedBranchUserRestrictionsReq, opt ...RequestOption) (*ReposReplaceProtectedBranchUserRestrictionsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposReplaceProtectedBranchUserRestrictionsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposReplaceProtectedBranchUserRestrictionsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposReplaceProtectedBranchUserRestrictionsReq is request data for Client.ReposReplaceProtectedBranchUserRestrictions

https://developer.github.com/v3/repos/branches/#replace-user-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchUserRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposReplaceProtectedBranchUserRestrictionsReqBody
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) url() string {
	return r._url
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch)
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) method() string {
	return "PUT"
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposReplaceProtectedBranchUserRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposReplaceProtectedBranchUserRestrictionsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposReplaceProtectedBranchUserRestrictionsReq) Rel(link RelName, resp *ReposReplaceProtectedBranchUserRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposReplaceProtectedBranchUserRestrictionsReqBody is a request body for repos/replace-protected-branch-user-restrictions

https://developer.github.com/v3/repos/branches/#replace-user-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchUserRestrictionsReqBody []string

/*
ReposReplaceProtectedBranchUserRestrictionsResponseBody is a response body for ReposReplaceProtectedBranchUserRestrictions

https://developer.github.com/v3/repos/branches/#replace-user-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchUserRestrictionsResponseBody []struct {
	components.SimpleUser
}

/*
ReposReplaceProtectedBranchUserRestrictionsResponse is a response for ReposReplaceProtectedBranchUserRestrictions

https://developer.github.com/v3/repos/branches/#replace-user-restrictions-of-protected-branch
*/
type ReposReplaceProtectedBranchUserRestrictionsResponse struct {
	response
	request *ReposReplaceProtectedBranchUserRestrictionsReq
	Data    *ReposReplaceProtectedBranchUserRestrictionsResponseBody
}

/*
ReposRequestPageBuild performs requests for "repos/request-page-build"

Request a page build.

  POST /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#request-a-page-build
*/
func (c *Client) ReposRequestPageBuild(ctx context.Context, req *ReposRequestPageBuildReq, opt ...RequestOption) (*ReposRequestPageBuildResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRequestPageBuildResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposRequestPageBuildResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRequestPageBuildReq is request data for Client.ReposRequestPageBuild

https://developer.github.com/v3/repos/pages/#request-a-page-build
*/
type ReposRequestPageBuildReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposRequestPageBuildReq) url() string {
	return r._url
}

func (r *ReposRequestPageBuildReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages/builds", r.Owner, r.Repo)
}

func (r *ReposRequestPageBuildReq) method() string {
	return "POST"
}

func (r *ReposRequestPageBuildReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRequestPageBuildReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRequestPageBuildReq) body() interface{} {
	return nil
}

func (r *ReposRequestPageBuildReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposRequestPageBuildReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposRequestPageBuildReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposRequestPageBuildReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRequestPageBuildReq) Rel(link RelName, resp *ReposRequestPageBuildResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRequestPageBuildResponseBody is a response body for ReposRequestPageBuild

https://developer.github.com/v3/repos/pages/#request-a-page-build
*/
type ReposRequestPageBuildResponseBody struct {
	components.PageBuildStatus
}

/*
ReposRequestPageBuildResponse is a response for ReposRequestPageBuild

https://developer.github.com/v3/repos/pages/#request-a-page-build
*/
type ReposRequestPageBuildResponse struct {
	response
	request *ReposRequestPageBuildReq
	Data    *ReposRequestPageBuildResponseBody
}

/*
ReposRetrieveCommunityProfileMetrics performs requests for "repos/retrieve-community-profile-metrics"

Retrieve community profile metrics.

  GET /repos/{owner}/{repo}/community/profile

https://developer.github.com/v3/repos/community/#retrieve-community-profile-metrics
*/
func (c *Client) ReposRetrieveCommunityProfileMetrics(ctx context.Context, req *ReposRetrieveCommunityProfileMetricsReq, opt ...RequestOption) (*ReposRetrieveCommunityProfileMetricsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposRetrieveCommunityProfileMetricsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposRetrieveCommunityProfileMetricsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRetrieveCommunityProfileMetricsReq is request data for Client.ReposRetrieveCommunityProfileMetrics

https://developer.github.com/v3/repos/community/#retrieve-community-profile-metrics
*/
type ReposRetrieveCommunityProfileMetricsReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposRetrieveCommunityProfileMetricsReq) url() string {
	return r._url
}

func (r *ReposRetrieveCommunityProfileMetricsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/community/profile", r.Owner, r.Repo)
}

func (r *ReposRetrieveCommunityProfileMetricsReq) method() string {
	return "GET"
}

func (r *ReposRetrieveCommunityProfileMetricsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRetrieveCommunityProfileMetricsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRetrieveCommunityProfileMetricsReq) body() interface{} {
	return nil
}

func (r *ReposRetrieveCommunityProfileMetricsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposRetrieveCommunityProfileMetricsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposRetrieveCommunityProfileMetricsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposRetrieveCommunityProfileMetricsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRetrieveCommunityProfileMetricsReq) Rel(link RelName, resp *ReposRetrieveCommunityProfileMetricsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRetrieveCommunityProfileMetricsResponseBody is a response body for ReposRetrieveCommunityProfileMetrics

https://developer.github.com/v3/repos/community/#retrieve-community-profile-metrics
*/
type ReposRetrieveCommunityProfileMetricsResponseBody struct {
	components.CommunityProfile
}

/*
ReposRetrieveCommunityProfileMetricsResponse is a response for ReposRetrieveCommunityProfileMetrics

https://developer.github.com/v3/repos/community/#retrieve-community-profile-metrics
*/
type ReposRetrieveCommunityProfileMetricsResponse struct {
	response
	request *ReposRetrieveCommunityProfileMetricsReq
	Data    *ReposRetrieveCommunityProfileMetricsResponseBody
}

/*
ReposTestPushHook performs requests for "repos/test-push-hook"

Test a push hook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/tests

https://developer.github.com/v3/repos/hooks/#test-a-push-hook
*/
func (c *Client) ReposTestPushHook(ctx context.Context, req *ReposTestPushHookReq, opt ...RequestOption) (*ReposTestPushHookResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposTestPushHookResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposTestPushHookReq is request data for Client.ReposTestPushHook

https://developer.github.com/v3/repos/hooks/#test-a-push-hook
*/
type ReposTestPushHookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

func (r *ReposTestPushHookReq) url() string {
	return r._url
}

func (r *ReposTestPushHookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v/tests", r.Owner, r.Repo, r.HookId)
}

func (r *ReposTestPushHookReq) method() string {
	return "POST"
}

func (r *ReposTestPushHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposTestPushHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposTestPushHookReq) body() interface{} {
	return nil
}

func (r *ReposTestPushHookReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposTestPushHookReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposTestPushHookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ReposTestPushHookReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposTestPushHookReq) Rel(link RelName, resp *ReposTestPushHookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposTestPushHookResponse is a response for ReposTestPushHook

https://developer.github.com/v3/repos/hooks/#test-a-push-hook
*/
type ReposTestPushHookResponse struct {
	response
	request *ReposTestPushHookReq
}

/*
ReposTransfer performs requests for "repos/transfer"

Transfer a repository.

  POST /repos/{owner}/{repo}/transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
func (c *Client) ReposTransfer(ctx context.Context, req *ReposTransferReq, opt ...RequestOption) (*ReposTransferResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposTransferResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposTransferResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposTransferReq is request data for Client.ReposTransfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposTransferReqBody
}

func (r *ReposTransferReq) url() string {
	return r._url
}

func (r *ReposTransferReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/transfer", r.Owner, r.Repo)
}

func (r *ReposTransferReq) method() string {
	return "POST"
}

func (r *ReposTransferReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposTransferReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposTransferReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposTransferReq) dataStatuses() []int {
	return []int{202}
}

func (r *ReposTransferReq) validStatuses() []int {
	return []int{202}
}

func (r *ReposTransferReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposTransferReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposTransferReq) Rel(link RelName, resp *ReposTransferResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposTransferReqBody is a request body for repos/transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferReqBody struct {

	/*
	   **Required:** The username or organization name the repository will be
	   transferred to.
	*/
	NewOwner *string `json:"new_owner,omitempty"`

	/*
	   ID of the team or teams to add to the repository. Teams can only be added to
	   organization-owned repositories.
	*/
	TeamIds []int64 `json:"team_ids,omitempty"`
}

/*
ReposTransferResponseBody is a response body for ReposTransfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferResponseBody struct {
	components.Repository
}

/*
ReposTransferResponse is a response for ReposTransfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferResponse struct {
	response
	request *ReposTransferReq
	Data    *ReposTransferResponseBody
}

/*
ReposUpdate performs requests for "repos/update"

Update a repository.

  PATCH /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#update-a-repository
*/
func (c *Client) ReposUpdate(ctx context.Context, req *ReposUpdateReq, opt ...RequestOption) (*ReposUpdateResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposUpdateResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposUpdateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateReq is request data for Client.ReposUpdate

https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposUpdateReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

func (r *ReposUpdateReq) url() string {
	return r._url
}

func (r *ReposUpdateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo)
}

func (r *ReposUpdateReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"baptiste": r.BaptistePreview,
		"nebula":   r.NebulaPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposUpdateReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateReq) Rel(link RelName, resp *ReposUpdateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateReqBody is a request body for repos/update

https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateReqBody struct {

	/*
	   Either `true` to allow merging pull requests with a merge commit, or `false` to
	   prevent merging pull requests with merge commits.
	*/
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	/*
	   Either `true` to allow rebase-merging pull requests, or `false` to prevent
	   rebase-merging.
	*/
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	/*
	   Either `true` to allow squash-merging pull requests, or `false` to prevent
	   squash-merging.
	*/
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	/*
	   `true` to archive this repository. **Note**: You cannot unarchive repositories
	   through the API.
	*/
	Archived *bool `json:"archived,omitempty"`

	// Updates the default branch for this repository.
	DefaultBranch *string `json:"default_branch,omitempty"`

	/*
	   Either `true` to allow automatically deleting head branches when pull requests
	   are merged, or `false` to prevent automatic deletion.
	*/
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	// Either `true` to enable issues for this repository or `false` to disable them.
	HasIssues *bool `json:"has_issues,omitempty"`

	/*
	   Either `true` to enable projects for this repository or `false` to disable them.
	   **Note:** If you're creating a repository in an organization that has disabled
	   repository projects, the default is `false`, and if you pass `true`, the API
	   returns an error.
	*/
	HasProjects *bool `json:"has_projects,omitempty"`

	// Either `true` to enable the wiki for this repository or `false` to disable it.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	/*
	   Either `true` to make this repo available as a template repository or `false` to
	   prevent it.
	*/
	IsTemplate *bool `json:"is_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name,omitempty"`

	/*
	   Either `true` to make the repository private or `false` to make it public.
	   Default: `false`.
	   **Note**: You will get a `422` error if the organization restricts [changing
	   repository
	   visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories)
	   to organization owners and a non-owner tries to change the value of private.
	   **Note**: You will get a `422` error if the organization restricts [changing
	   repository
	   visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories)
	   to organization owners and a non-owner tries to change the value of private.
	*/
	Private *bool `json:"private,omitempty"`

	/*
	   Can be `public` or `private`. If your organization is associated with an
	   enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server
	   2.20+, `visibility` can also be `internal`. The `visibility` parameter overrides
	   the `private` parameter when you use both along with the `nebula-preview`
	   preview header.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ReposUpdateResponseBody is a response body for ReposUpdate

https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateResponseBody struct {
	components.FullRepository2
}

/*
ReposUpdateResponse is a response for ReposUpdate

https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateResponse struct {
	response
	request *ReposUpdateReq
	Data    *ReposUpdateResponseBody
}

/*
ReposUpdateBranchProtection performs requests for "repos/update-branch-protection"

Update branch protection.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
func (c *Client) ReposUpdateBranchProtection(ctx context.Context, req *ReposUpdateBranchProtectionReq, opt ...RequestOption) (*ReposUpdateBranchProtectionResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposUpdateBranchProtectionResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposUpdateBranchProtectionResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateBranchProtectionReq is request data for Client.ReposUpdateBranchProtection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposUpdateBranchProtectionReqBody

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

func (r *ReposUpdateBranchProtectionReq) url() string {
	return r._url
}

func (r *ReposUpdateBranchProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch)
}

func (r *ReposUpdateBranchProtectionReq) method() string {
	return "PUT"
}

func (r *ReposUpdateBranchProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateBranchProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"luke-cage": r.LukeCagePreview}
	if allPreviews {
		previewVals["luke-cage"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateBranchProtectionReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateBranchProtectionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateBranchProtectionReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateBranchProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposUpdateBranchProtectionReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateBranchProtectionReq) Rel(link RelName, resp *ReposUpdateBranchProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews is a value for ReposUpdateBranchProtectionReqBody's RequiredPullRequestReviews field
type ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews struct {

	/*
	   Set to `true` if you want to automatically dismiss approving reviews when
	   someone pushes a new commit.
	*/
	DismissStaleReviews *bool `json:"dismiss_stale_reviews,omitempty"`

	/*
	   Specify which users and teams can dismiss pull request reviews. Pass an empty
	   `dismissal_restrictions` object to disable. User and team
	   `dismissal_restrictions` are only available for organization-owned repositories.
	   Omit this parameter for personal repositories.
	*/
	DismissalRestrictions *ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions `json:"dismissal_restrictions,omitempty"`

	/*
	   Blocks merging pull requests until [code
	   owners](https://help.github.com/articles/about-code-owners/) review them.
	*/
	RequireCodeOwnerReviews *bool `json:"require_code_owner_reviews,omitempty"`

	/*
	   Specify the number of reviewers required to approve pull requests. Use a number
	   between 1 and 6.
	*/
	RequiredApprovingReviewCount *int64 `json:"required_approving_review_count,omitempty"`
}

// ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions is a value for ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews's DismissalRestrictions field
type ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions struct {

	// The list of team `slug`s with dismissal access
	Teams []string `json:"teams,omitempty"`

	// The list of user `login`s with dismissal access
	Users []string `json:"users,omitempty"`
}

// ReposUpdateBranchProtectionReqBodyRequiredStatusChecks is a value for ReposUpdateBranchProtectionReqBody's RequiredStatusChecks field
type ReposUpdateBranchProtectionReqBodyRequiredStatusChecks struct {

	// The list of status checks to require in order to merge into this branch
	Contexts []string `json:"contexts"`

	// Require branches to be up to date before merging.
	Strict *bool `json:"strict"`
}

// ReposUpdateBranchProtectionReqBodyRestrictions is a value for ReposUpdateBranchProtectionReqBody's Restrictions field
type ReposUpdateBranchProtectionReqBodyRestrictions struct {

	// The list of app `slug`s with push access
	Apps []string `json:"apps,omitempty"`

	// The list of team `slug`s with push access
	Teams []string `json:"teams"`

	// The list of user `login`s with push access
	Users []string `json:"users"`
}

/*
ReposUpdateBranchProtectionReqBody is a request body for repos/update-branch-protection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionReqBody struct {

	/*
	   Allows deletion of the protected branch by anyone with write access to the
	   repository. Set to `false` to prevent deletion of the protected branch. Default:
	   `false`. For more information, see "[Enabling force pushes to a protected
	   branch](https://help.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)"
	   in the GitHub Help documentation.
	*/
	AllowDeletions *bool `json:"allow_deletions,omitempty"`

	/*
	   Permits force pushes to the protected branch by anyone with write access to the
	   repository. Set to `true` to allow force pushes. Set to `false` or `null` to
	   block force pushes. Default: `false`. For more information, see "[Enabling force
	   pushes to a protected
	   branch](https://help.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)"
	   in the GitHub Help documentation."
	*/
	AllowForcePushes *bool `json:"allow_force_pushes,omitempty"`

	/*
	   Enforce all configured restrictions for administrators. Set to `true` to enforce
	   required status checks for repository administrators. Set to `null` to disable.
	*/
	EnforceAdmins *bool `json:"enforce_admins"`

	/*
	   Enforces a linear commit Git history, which prevents anyone from pushing merge
	   commits to a branch. Set to `true` to enforce a linear commit history. Set to
	   `false` to disable a linear commit Git history. Your repository must allow
	   squash merging or rebase merging before you can enable a linear commit history.
	   Default: `false`. For more information, see "[Requiring a linear commit
	   history](https://help.github.com/github/administering-a-repository/requiring-a-linear-commit-history)"
	   in the GitHub Help documentation.
	*/
	RequiredLinearHistory *bool `json:"required_linear_history,omitempty"`

	/*
	   Require at least one approving review on a pull request, before merging. Set to
	   `null` to disable.
	*/
	RequiredPullRequestReviews *ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews `json:"required_pull_request_reviews"`

	// Require status checks to pass before merging. Set to `null` to disable.
	RequiredStatusChecks *ReposUpdateBranchProtectionReqBodyRequiredStatusChecks `json:"required_status_checks"`

	/*
	   Restrict who can push to the protected branch. User, app, and team
	   `restrictions` are only available for organization-owned repositories. Set to
	   `null` to disable.
	*/
	Restrictions *ReposUpdateBranchProtectionReqBodyRestrictions `json:"restrictions"`
}

/*
ReposUpdateBranchProtectionResponseBody is a response body for ReposUpdateBranchProtection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionResponseBody struct {
	components.BranchProtection
}

/*
ReposUpdateBranchProtectionResponse is a response for ReposUpdateBranchProtection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionResponse struct {
	response
	request *ReposUpdateBranchProtectionReq
	Data    *ReposUpdateBranchProtectionResponseBody
}

/*
ReposUpdateCommitComment performs requests for "repos/update-commit-comment"

Update a commit comment.

  PATCH /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
func (c *Client) ReposUpdateCommitComment(ctx context.Context, req *ReposUpdateCommitCommentReq, opt ...RequestOption) (*ReposUpdateCommitCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposUpdateCommitCommentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposUpdateCommitCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateCommitCommentReq is request data for Client.ReposUpdateCommitComment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	CommentId   int64
	RequestBody ReposUpdateCommitCommentReqBody
}

func (r *ReposUpdateCommitCommentReq) url() string {
	return r._url
}

func (r *ReposUpdateCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *ReposUpdateCommitCommentReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateCommitCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateCommitCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateCommitCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateCommitCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposUpdateCommitCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateCommitCommentReq) Rel(link RelName, resp *ReposUpdateCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateCommitCommentReqBody is a request body for repos/update-commit-comment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentReqBody struct {

	// The contents of the comment
	Body *string `json:"body"`
}

/*
ReposUpdateCommitCommentResponseBody is a response body for ReposUpdateCommitComment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentResponseBody struct {
	components.CommitComment
}

/*
ReposUpdateCommitCommentResponse is a response for ReposUpdateCommitComment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentResponse struct {
	response
	request *ReposUpdateCommitCommentReq
	Data    *ReposUpdateCommitCommentResponseBody
}

/*
ReposUpdateHook performs requests for "repos/update-hook"

Edit a hook.

  PATCH /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#edit-a-hook
*/
func (c *Client) ReposUpdateHook(ctx context.Context, req *ReposUpdateHookReq, opt ...RequestOption) (*ReposUpdateHookResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposUpdateHookResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposUpdateHookResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateHookReq is request data for Client.ReposUpdateHook

https://developer.github.com/v3/repos/hooks/#edit-a-hook
*/
type ReposUpdateHookReq struct {
	_url        string
	Owner       string
	Repo        string
	HookId      int64
	RequestBody ReposUpdateHookReqBody
}

func (r *ReposUpdateHookReq) url() string {
	return r._url
}

func (r *ReposUpdateHookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId)
}

func (r *ReposUpdateHookReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateHookReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateHookReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateHookReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateHookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposUpdateHookReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateHookReq) Rel(link RelName, resp *ReposUpdateHookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposUpdateHookReqBodyConfig is a value for ReposUpdateHookReqBody's Config field
type ReposUpdateHookReqBodyConfig struct {

	/*
	   The media type used to serialize the payloads. Supported values include `json`
	   and `form`. The default is `form`.
	*/
	ContentType *string `json:"content_type,omitempty"`

	/*
	   Determines whether the SSL certificate of the host for `url` will be verified
	   when delivering payloads. Supported values include `0` (verification is
	   performed) and `1` (verification is not performed). The default is `0`. **We
	   strongly recommend not setting this to `1` as you are subject to
	   man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	   If provided, the `secret` will be used as the `key` to generate the HMAC hex
	   digest value in the
	   [`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	   header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
ReposUpdateHookReqBody is a request body for repos/update-hook

https://developer.github.com/v3/repos/hooks/#edit-a-hook
*/
type ReposUpdateHookReqBody struct {

	/*
	   Determines if notifications are sent when the webhook is triggered. Set to
	   `true` to send notifications.
	*/
	Active *bool `json:"active,omitempty"`

	/*
	   Determines a list of events to be added to the list of events that the Hook
	   triggers for.
	*/
	AddEvents []string `json:"add_events,omitempty"`

	/*
	   Key/value pairs to provide settings for this webhook. [These are defined
	   below](https://developer.github.com/v3/repos/hooks/#create-hook-config-params).
	*/
	Config *ReposUpdateHookReqBodyConfig `json:"config,omitempty"`

	/*
	   Determines what [events](https://developer.github.com/webhooks/event-payloads)
	   the hook is triggered for. This replaces the entire array of events.
	*/
	Events []string `json:"events,omitempty"`

	/*
	   Determines a list of events to be removed from the list of events that the Hook
	   triggers for.
	*/
	RemoveEvents []string `json:"remove_events,omitempty"`
}

/*
ReposUpdateHookResponseBody is a response body for ReposUpdateHook

https://developer.github.com/v3/repos/hooks/#edit-a-hook
*/
type ReposUpdateHookResponseBody struct {
	components.Hook
}

/*
ReposUpdateHookResponse is a response for ReposUpdateHook

https://developer.github.com/v3/repos/hooks/#edit-a-hook
*/
type ReposUpdateHookResponse struct {
	response
	request *ReposUpdateHookReq
	Data    *ReposUpdateHookResponseBody
}

/*
ReposUpdateInformationAboutPagesSite performs requests for "repos/update-information-about-pages-site"

Update information about a Pages site.

  PUT /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#update-information-about-a-pages-site
*/
func (c *Client) ReposUpdateInformationAboutPagesSite(ctx context.Context, req *ReposUpdateInformationAboutPagesSiteReq, opt ...RequestOption) (*ReposUpdateInformationAboutPagesSiteResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposUpdateInformationAboutPagesSiteResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateInformationAboutPagesSiteReq is request data for Client.ReposUpdateInformationAboutPagesSite

https://developer.github.com/v3/repos/pages/#update-information-about-a-pages-site
*/
type ReposUpdateInformationAboutPagesSiteReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposUpdateInformationAboutPagesSiteReqBody
}

func (r *ReposUpdateInformationAboutPagesSiteReq) url() string {
	return r._url
}

func (r *ReposUpdateInformationAboutPagesSiteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo)
}

func (r *ReposUpdateInformationAboutPagesSiteReq) method() string {
	return "PUT"
}

func (r *ReposUpdateInformationAboutPagesSiteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateInformationAboutPagesSiteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateInformationAboutPagesSiteReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateInformationAboutPagesSiteReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposUpdateInformationAboutPagesSiteReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposUpdateInformationAboutPagesSiteReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposUpdateInformationAboutPagesSiteReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateInformationAboutPagesSiteReq) Rel(link RelName, resp *ReposUpdateInformationAboutPagesSiteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateInformationAboutPagesSiteReqBody is a request body for repos/update-information-about-pages-site

https://developer.github.com/v3/repos/pages/#update-information-about-a-pages-site
*/
type ReposUpdateInformationAboutPagesSiteReqBody struct {

	/*
	   Specify a custom domain for the repository. Sending a `null` value will remove
	   the custom domain. For more about custom domains, see "[Using a custom domain
	   with GitHub
	   Pages](https://help.github.com/articles/using-a-custom-domain-with-github-pages/)."
	*/
	Cname *string `json:"cname,omitempty"`

	/*
	   Update the source for the repository. Must include the branch name, and may
	   optionally specify the subdirectory `/docs`. Possible values are `"gh-pages"`,
	   `"master"`, and `"master /docs"`.
	*/
	Source *string `json:"source,omitempty"`
}

/*
ReposUpdateInformationAboutPagesSiteResponse is a response for ReposUpdateInformationAboutPagesSite

https://developer.github.com/v3/repos/pages/#update-information-about-a-pages-site
*/
type ReposUpdateInformationAboutPagesSiteResponse struct {
	response
	request *ReposUpdateInformationAboutPagesSiteReq
}

/*
ReposUpdateInvitation performs requests for "repos/update-invitation"

Update a repository invitation.

  PATCH /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
func (c *Client) ReposUpdateInvitation(ctx context.Context, req *ReposUpdateInvitationReq, opt ...RequestOption) (*ReposUpdateInvitationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposUpdateInvitationResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposUpdateInvitationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateInvitationReq is request data for Client.ReposUpdateInvitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationReq struct {
	_url         string
	Owner        string
	Repo         string
	InvitationId int64
	RequestBody  ReposUpdateInvitationReqBody
}

func (r *ReposUpdateInvitationReq) url() string {
	return r._url
}

func (r *ReposUpdateInvitationReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/invitations/%v", r.Owner, r.Repo, r.InvitationId)
}

func (r *ReposUpdateInvitationReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateInvitationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateInvitationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateInvitationReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateInvitationReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateInvitationReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateInvitationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposUpdateInvitationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateInvitationReq) Rel(link RelName, resp *ReposUpdateInvitationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateInvitationReqBody is a request body for repos/update-invitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationReqBody struct {

	/*
	   The permissions that the associated user will have on the repository. Valid
	   values are `read`, `write`, `maintain`, `triage`, and `admin`.
	*/
	Permissions *string `json:"permissions,omitempty"`
}

/*
ReposUpdateInvitationResponseBody is a response body for ReposUpdateInvitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationResponseBody struct {
	components.RepositoryInvitation
}

/*
ReposUpdateInvitationResponse is a response for ReposUpdateInvitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationResponse struct {
	response
	request *ReposUpdateInvitationReq
	Data    *ReposUpdateInvitationResponseBody
}

/*
ReposUpdateProtectedBranchPullRequestReviewEnforcement performs requests for "repos/update-protected-branch-pull-request-review-enforcement"

Update pull request review enforcement of protected branch.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#update-pull-request-review-enforcement-of-protected-branch
*/
func (c *Client) ReposUpdateProtectedBranchPullRequestReviewEnforcement(ctx context.Context, req *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq, opt ...RequestOption) (*ReposUpdateProtectedBranchPullRequestReviewEnforcementResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposUpdateProtectedBranchPullRequestReviewEnforcementResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposUpdateProtectedBranchPullRequestReviewEnforcementResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateProtectedBranchPullRequestReviewEnforcementReq is request data for Client.ReposUpdateProtectedBranchPullRequestReviewEnforcement

https://developer.github.com/v3/repos/branches/#update-pull-request-review-enforcement-of-protected-branch
*/
type ReposUpdateProtectedBranchPullRequestReviewEnforcementReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBody

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) url() string {
	return r._url
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch)
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"luke-cage": r.LukeCagePreview}
	if allPreviews {
		previewVals["luke-cage"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq) Rel(link RelName, resp *ReposUpdateProtectedBranchPullRequestReviewEnforcementResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBodyDismissalRestrictions is a value for ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBody's DismissalRestrictions field
type ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBodyDismissalRestrictions struct {

	// The list of team `slug`s with dismissal access
	Teams []string `json:"teams,omitempty"`

	// The list of user `login`s with dismissal access
	Users []string `json:"users,omitempty"`
}

/*
ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBody is a request body for repos/update-protected-branch-pull-request-review-enforcement

https://developer.github.com/v3/repos/branches/#update-pull-request-review-enforcement-of-protected-branch
*/
type ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBody struct {

	/*
	   Set to `true` if you want to automatically dismiss approving reviews when
	   someone pushes a new commit.
	*/
	DismissStaleReviews *bool `json:"dismiss_stale_reviews,omitempty"`

	/*
	   Specify which users and teams can dismiss pull request reviews. Pass an empty
	   `dismissal_restrictions` object to disable. User and team
	   `dismissal_restrictions` are only available for organization-owned repositories.
	   Omit this parameter for personal repositories.
	*/
	DismissalRestrictions *ReposUpdateProtectedBranchPullRequestReviewEnforcementReqBodyDismissalRestrictions `json:"dismissal_restrictions,omitempty"`

	/*
	   Blocks merging pull requests until [code
	   owners](https://help.github.com/articles/about-code-owners/) have reviewed.
	*/
	RequireCodeOwnerReviews *bool `json:"require_code_owner_reviews,omitempty"`

	/*
	   Specifies the number of reviewers required to approve pull requests. Use a
	   number between 1 and 6.
	*/
	RequiredApprovingReviewCount *int64 `json:"required_approving_review_count,omitempty"`
}

/*
ReposUpdateProtectedBranchPullRequestReviewEnforcementResponseBody is a response body for ReposUpdateProtectedBranchPullRequestReviewEnforcement

https://developer.github.com/v3/repos/branches/#update-pull-request-review-enforcement-of-protected-branch
*/
type ReposUpdateProtectedBranchPullRequestReviewEnforcementResponseBody struct {
	components.ProtectedBranchPullRequestReview
}

/*
ReposUpdateProtectedBranchPullRequestReviewEnforcementResponse is a response for ReposUpdateProtectedBranchPullRequestReviewEnforcement

https://developer.github.com/v3/repos/branches/#update-pull-request-review-enforcement-of-protected-branch
*/
type ReposUpdateProtectedBranchPullRequestReviewEnforcementResponse struct {
	response
	request *ReposUpdateProtectedBranchPullRequestReviewEnforcementReq
	Data    *ReposUpdateProtectedBranchPullRequestReviewEnforcementResponseBody
}

/*
ReposUpdateProtectedBranchRequiredStatusChecks performs requests for "repos/update-protected-branch-required-status-checks"

Update required status checks of protected branch.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#update-required-status-checks-of-protected-branch
*/
func (c *Client) ReposUpdateProtectedBranchRequiredStatusChecks(ctx context.Context, req *ReposUpdateProtectedBranchRequiredStatusChecksReq, opt ...RequestOption) (*ReposUpdateProtectedBranchRequiredStatusChecksResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposUpdateProtectedBranchRequiredStatusChecksResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposUpdateProtectedBranchRequiredStatusChecksResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateProtectedBranchRequiredStatusChecksReq is request data for Client.ReposUpdateProtectedBranchRequiredStatusChecks

https://developer.github.com/v3/repos/branches/#update-required-status-checks-of-protected-branch
*/
type ReposUpdateProtectedBranchRequiredStatusChecksReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposUpdateProtectedBranchRequiredStatusChecksReqBody
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) url() string {
	return r._url
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch)
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateProtectedBranchRequiredStatusChecksReq) Rel(link RelName, resp *ReposUpdateProtectedBranchRequiredStatusChecksResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateProtectedBranchRequiredStatusChecksReqBody is a request body for repos/update-protected-branch-required-status-checks

https://developer.github.com/v3/repos/branches/#update-required-status-checks-of-protected-branch
*/
type ReposUpdateProtectedBranchRequiredStatusChecksReqBody struct {

	// The list of status checks to require in order to merge into this branch
	Contexts []string `json:"contexts,omitempty"`

	// Require branches to be up to date before merging.
	Strict *bool `json:"strict,omitempty"`
}

/*
ReposUpdateProtectedBranchRequiredStatusChecksResponseBody is a response body for ReposUpdateProtectedBranchRequiredStatusChecks

https://developer.github.com/v3/repos/branches/#update-required-status-checks-of-protected-branch
*/
type ReposUpdateProtectedBranchRequiredStatusChecksResponseBody struct {
	components.StatusCheckPolicy
}

/*
ReposUpdateProtectedBranchRequiredStatusChecksResponse is a response for ReposUpdateProtectedBranchRequiredStatusChecks

https://developer.github.com/v3/repos/branches/#update-required-status-checks-of-protected-branch
*/
type ReposUpdateProtectedBranchRequiredStatusChecksResponse struct {
	response
	request *ReposUpdateProtectedBranchRequiredStatusChecksReq
	Data    *ReposUpdateProtectedBranchRequiredStatusChecksResponseBody
}

/*
ReposUpdateRelease performs requests for "repos/update-release"

Edit a release.

  PATCH /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#edit-a-release
*/
func (c *Client) ReposUpdateRelease(ctx context.Context, req *ReposUpdateReleaseReq, opt ...RequestOption) (*ReposUpdateReleaseResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposUpdateReleaseResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposUpdateReleaseResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateReleaseReq is request data for Client.ReposUpdateRelease

https://developer.github.com/v3/repos/releases/#edit-a-release
*/
type ReposUpdateReleaseReq struct {
	_url        string
	Owner       string
	Repo        string
	ReleaseId   int64
	RequestBody ReposUpdateReleaseReqBody
}

func (r *ReposUpdateReleaseReq) url() string {
	return r._url
}

func (r *ReposUpdateReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposUpdateReleaseReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateReleaseReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateReleaseReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateReleaseReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateReleaseReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposUpdateReleaseReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateReleaseReq) Rel(link RelName, resp *ReposUpdateReleaseResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateReleaseReqBody is a request body for repos/update-release

https://developer.github.com/v3/repos/releases/#edit-a-release
*/
type ReposUpdateReleaseReqBody struct {

	// Text describing the contents of the tag.
	Body *string `json:"body,omitempty"`

	// `true` makes the release a draft, and `false` publishes the release.
	Draft *bool `json:"draft,omitempty"`

	// The name of the release.
	Name *string `json:"name,omitempty"`

	/*
	   `true` to identify the release as a prerelease, `false` to identify the release
	   as a full release.
	*/
	Prerelease *bool `json:"prerelease,omitempty"`

	// The name of the tag.
	TagName *string `json:"tag_name,omitempty"`

	/*
	   Specifies the commitish value that determines where the Git tag is created from.
	   Can be any branch or commit SHA. Unused if the Git tag already exists. Default:
	   the repository's default branch (usually `master`).
	*/
	TargetCommitish *string `json:"target_commitish,omitempty"`
}

/*
ReposUpdateReleaseResponseBody is a response body for ReposUpdateRelease

https://developer.github.com/v3/repos/releases/#edit-a-release
*/
type ReposUpdateReleaseResponseBody struct {
	components.Release2
}

/*
ReposUpdateReleaseResponse is a response for ReposUpdateRelease

https://developer.github.com/v3/repos/releases/#edit-a-release
*/
type ReposUpdateReleaseResponse struct {
	response
	request *ReposUpdateReleaseReq
	Data    *ReposUpdateReleaseResponseBody
}

/*
ReposUpdateReleaseAsset performs requests for "repos/update-release-asset"

Edit a release asset.

  PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#edit-a-release-asset
*/
func (c *Client) ReposUpdateReleaseAsset(ctx context.Context, req *ReposUpdateReleaseAssetReq, opt ...RequestOption) (*ReposUpdateReleaseAssetResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposUpdateReleaseAssetResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposUpdateReleaseAssetResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateReleaseAssetReq is request data for Client.ReposUpdateReleaseAsset

https://developer.github.com/v3/repos/releases/#edit-a-release-asset
*/
type ReposUpdateReleaseAssetReq struct {
	_url        string
	Owner       string
	Repo        string
	AssetId     int64
	RequestBody ReposUpdateReleaseAssetReqBody
}

func (r *ReposUpdateReleaseAssetReq) url() string {
	return r._url
}

func (r *ReposUpdateReleaseAssetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId)
}

func (r *ReposUpdateReleaseAssetReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateReleaseAssetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateReleaseAssetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateReleaseAssetReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateReleaseAssetReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateReleaseAssetReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateReleaseAssetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ReposUpdateReleaseAssetReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateReleaseAssetReq) Rel(link RelName, resp *ReposUpdateReleaseAssetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateReleaseAssetReqBody is a request body for repos/update-release-asset

https://developer.github.com/v3/repos/releases/#edit-a-release-asset
*/
type ReposUpdateReleaseAssetReqBody struct {

	// An alternate short description of the asset. Used in place of the filename.
	Label *string `json:"label,omitempty"`

	// The file name of the asset.
	Name *string `json:"name,omitempty"`
}

/*
ReposUpdateReleaseAssetResponseBody is a response body for ReposUpdateReleaseAsset

https://developer.github.com/v3/repos/releases/#edit-a-release-asset
*/
type ReposUpdateReleaseAssetResponseBody struct {
	components.ReleaseAsset
}

/*
ReposUpdateReleaseAssetResponse is a response for ReposUpdateReleaseAsset

https://developer.github.com/v3/repos/releases/#edit-a-release-asset
*/
type ReposUpdateReleaseAssetResponse struct {
	response
	request *ReposUpdateReleaseAssetReq
	Data    *ReposUpdateReleaseAssetResponseBody
}

/*
ReposUploadReleaseAsset performs requests for "repos/upload-release-asset"

Upload a release asset.

  POST /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
func (c *Client) ReposUploadReleaseAsset(ctx context.Context, req *ReposUploadReleaseAssetReq, opt ...RequestOption) (*ReposUploadReleaseAssetResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ReposUploadReleaseAssetResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ReposUploadReleaseAssetResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUploadReleaseAssetReq is request data for Client.ReposUploadReleaseAsset

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
type ReposUploadReleaseAssetReq struct {
	_url string

	// owner parameter
	Owner string

	// repo parameter
	Repo string

	// release_id parameter
	ReleaseId int64

	// name parameter
	Name *string

	// label parameter
	Label *string

	// http request's body
	RequestBody io.ReadCloser

	/*
	Size of the asset in bytes. Most libraries will calculate the header
	automatically
	*/
	ContentLengthHeader *string

	/*
	Media Type of the asset. For a list of media types, see
	https://www.iana.org/assignments/media-types/media-types.xhtml
	*/
	ContentTypeHeader *string
}

func (r *ReposUploadReleaseAssetReq) url() string {
	return r._url
}

func (r *ReposUploadReleaseAssetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v/assets", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposUploadReleaseAssetReq) method() string {
	return "POST"
}

func (r *ReposUploadReleaseAssetReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Name != nil {
		query.Set("name", *r.Name)
	}
	if r.Label != nil {
		query.Set("label", *r.Label)
	}
	return query
}

func (r *ReposUploadReleaseAssetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"content-length": r.ContentLengthHeader,
		"content-type":   r.ContentTypeHeader,
	}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUploadReleaseAssetReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUploadReleaseAssetReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposUploadReleaseAssetReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposUploadReleaseAssetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBodyUploader}
}

// httpRequest creates an http request
func (r *ReposUploadReleaseAssetReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUploadReleaseAssetReq) Rel(link RelName, resp *ReposUploadReleaseAssetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUploadReleaseAssetResponseBody is a response body for ReposUploadReleaseAsset

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
type ReposUploadReleaseAssetResponseBody struct {
	components.ReleaseAsset
}

/*
ReposUploadReleaseAssetResponse is a response for ReposUploadReleaseAsset

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
type ReposUploadReleaseAssetResponse struct {
	response
	request *ReposUploadReleaseAssetReq
	Data    *ReposUploadReleaseAssetResponseBody
}
