// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"io"
	"net/http"
	"net/url"
	"strconv"
)

/*
ReposAcceptInvitation performs requests for "repos/accept-invitation"

Accept a repository invitation.

  PATCH /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
func ReposAcceptInvitation(ctx context.Context, req *ReposAcceptInvitationReq, opt ...RequestOption) (*ReposAcceptInvitationResponse, error) {
	if req == nil {
		req = new(ReposAcceptInvitationReq)
	}
	resp := &ReposAcceptInvitationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAcceptInvitation performs requests for "repos/accept-invitation"

Accept a repository invitation.

  PATCH /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
func (c Client) ReposAcceptInvitation(ctx context.Context, req *ReposAcceptInvitationReq, opt ...RequestOption) (*ReposAcceptInvitationResponse, error) {
	return ReposAcceptInvitation(ctx, req, append(c, opt...)...)
}

/*
ReposAcceptInvitationReq is request data for Client.ReposAcceptInvitation

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
type ReposAcceptInvitationReq struct {
	_url         string
	InvitationId int64
}

func (r *ReposAcceptInvitationReq) url() string {
	return r._url
}

func (r *ReposAcceptInvitationReq) urlPath() string {
	return fmt.Sprintf("/user/repository_invitations/%v", r.InvitationId)
}

func (r *ReposAcceptInvitationReq) method() string {
	return "PATCH"
}

func (r *ReposAcceptInvitationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAcceptInvitationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAcceptInvitationReq) body() interface{} {
	return nil
}

func (r *ReposAcceptInvitationReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposAcceptInvitationReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposAcceptInvitationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposAcceptInvitationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAcceptInvitationReq) Rel(link RelName, resp *ReposAcceptInvitationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAcceptInvitationResponse is a response for ReposAcceptInvitation

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
type ReposAcceptInvitationResponse struct {
	response
	request *ReposAcceptInvitationReq
}

/*
ReposAddAppAccessRestrictions performs requests for "repos/add-app-access-restrictions"

Add app access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
func ReposAddAppAccessRestrictions(ctx context.Context, req *ReposAddAppAccessRestrictionsReq, opt ...RequestOption) (*ReposAddAppAccessRestrictionsResponse, error) {
	if req == nil {
		req = new(ReposAddAppAccessRestrictionsReq)
	}
	resp := &ReposAddAppAccessRestrictionsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposAddAppAccessRestrictionsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddAppAccessRestrictions performs requests for "repos/add-app-access-restrictions"

Add app access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
func (c Client) ReposAddAppAccessRestrictions(ctx context.Context, req *ReposAddAppAccessRestrictionsReq, opt ...RequestOption) (*ReposAddAppAccessRestrictionsResponse, error) {
	return ReposAddAppAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposAddAppAccessRestrictionsReq is request data for Client.ReposAddAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
type ReposAddAppAccessRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposAddAppAccessRestrictionsReqBody
}

func (r *ReposAddAppAccessRestrictionsReq) url() string {
	return r._url
}

func (r *ReposAddAppAccessRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddAppAccessRestrictionsReq) method() string {
	return "POST"
}

func (r *ReposAddAppAccessRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddAppAccessRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddAppAccessRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposAddAppAccessRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposAddAppAccessRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposAddAppAccessRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposAddAppAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddAppAccessRestrictionsReq) Rel(link RelName, resp *ReposAddAppAccessRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddAppAccessRestrictionsReqBody is a request body for repos/add-app-access-restrictions

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
type ReposAddAppAccessRestrictionsReqBody []string

/*
ReposAddAppAccessRestrictionsResponseBody is a response body for ReposAddAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
type ReposAddAppAccessRestrictionsResponseBody []components.Integration

/*
ReposAddAppAccessRestrictionsResponse is a response for ReposAddAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
type ReposAddAppAccessRestrictionsResponse struct {
	response
	request *ReposAddAppAccessRestrictionsReq
	Data    ReposAddAppAccessRestrictionsResponseBody
}

/*
ReposAddCollaborator performs requests for "repos/add-collaborator"

Add a repository collaborator.

  PUT /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
func ReposAddCollaborator(ctx context.Context, req *ReposAddCollaboratorReq, opt ...RequestOption) (*ReposAddCollaboratorResponse, error) {
	if req == nil {
		req = new(ReposAddCollaboratorReq)
	}
	resp := &ReposAddCollaboratorResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposAddCollaboratorResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddCollaborator performs requests for "repos/add-collaborator"

Add a repository collaborator.

  PUT /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
func (c Client) ReposAddCollaborator(ctx context.Context, req *ReposAddCollaboratorReq, opt ...RequestOption) (*ReposAddCollaboratorResponse, error) {
	return ReposAddCollaborator(ctx, req, append(c, opt...)...)
}

/*
ReposAddCollaboratorReq is request data for Client.ReposAddCollaborator

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
type ReposAddCollaboratorReq struct {
	_url        string
	Owner       string
	Repo        string
	Username    string
	RequestBody ReposAddCollaboratorReqBody
}

func (r *ReposAddCollaboratorReq) url() string {
	return r._url
}

func (r *ReposAddCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username)
}

func (r *ReposAddCollaboratorReq) method() string {
	return "PUT"
}

func (r *ReposAddCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddCollaboratorReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposAddCollaboratorReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposAddCollaboratorReq) validStatuses() []int {
	return []int{201, 204}
}

func (r *ReposAddCollaboratorReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposAddCollaboratorReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddCollaboratorReq) Rel(link RelName, resp *ReposAddCollaboratorResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddCollaboratorReqBody is a request body for repos/add-collaborator

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
type ReposAddCollaboratorReqBody struct {

	/*
	   The permission to grant the collaborator. **Only valid on organization-owned
	   repositories.** Can be one of:
	   \* `pull` - can pull, but not push to or administer this repository.
	   \* `push` - can pull and push, but not administer this repository.
	   \* `admin` - can pull, push and administer this repository.
	   \* `maintain` - Recommended for project managers who need to manage the
	   repository without access to sensitive or destructive actions.
	   \* `triage` - Recommended for contributors who need to proactively manage issues
	   and pull requests without write access.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
ReposAddCollaboratorResponseBody is a response body for ReposAddCollaborator

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
type ReposAddCollaboratorResponseBody components.RepositoryInvitation

/*
ReposAddCollaboratorResponse is a response for ReposAddCollaborator

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
type ReposAddCollaboratorResponse struct {
	response
	request *ReposAddCollaboratorReq
	Data    ReposAddCollaboratorResponseBody
}

/*
ReposAddStatusCheckContexts performs requests for "repos/add-status-check-contexts"

Add status check contexts.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
func ReposAddStatusCheckContexts(ctx context.Context, req *ReposAddStatusCheckContextsReq, opt ...RequestOption) (*ReposAddStatusCheckContextsResponse, error) {
	if req == nil {
		req = new(ReposAddStatusCheckContextsReq)
	}
	resp := &ReposAddStatusCheckContextsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposAddStatusCheckContextsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddStatusCheckContexts performs requests for "repos/add-status-check-contexts"

Add status check contexts.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
func (c Client) ReposAddStatusCheckContexts(ctx context.Context, req *ReposAddStatusCheckContextsReq, opt ...RequestOption) (*ReposAddStatusCheckContextsResponse, error) {
	return ReposAddStatusCheckContexts(ctx, req, append(c, opt...)...)
}

/*
ReposAddStatusCheckContextsReq is request data for Client.ReposAddStatusCheckContexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
type ReposAddStatusCheckContextsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposAddStatusCheckContextsReqBody
}

func (r *ReposAddStatusCheckContextsReq) url() string {
	return r._url
}

func (r *ReposAddStatusCheckContextsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddStatusCheckContextsReq) method() string {
	return "POST"
}

func (r *ReposAddStatusCheckContextsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddStatusCheckContextsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddStatusCheckContextsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposAddStatusCheckContextsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposAddStatusCheckContextsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposAddStatusCheckContextsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposAddStatusCheckContextsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddStatusCheckContextsReq) Rel(link RelName, resp *ReposAddStatusCheckContextsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddStatusCheckContextsReqBody is a request body for repos/add-status-check-contexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
type ReposAddStatusCheckContextsReqBody []string

/*
ReposAddStatusCheckContextsResponseBody is a response body for ReposAddStatusCheckContexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
type ReposAddStatusCheckContextsResponseBody []string

/*
ReposAddStatusCheckContextsResponse is a response for ReposAddStatusCheckContexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
type ReposAddStatusCheckContextsResponse struct {
	response
	request *ReposAddStatusCheckContextsReq
	Data    ReposAddStatusCheckContextsResponseBody
}

/*
ReposAddTeamAccessRestrictions performs requests for "repos/add-team-access-restrictions"

Add team access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
func ReposAddTeamAccessRestrictions(ctx context.Context, req *ReposAddTeamAccessRestrictionsReq, opt ...RequestOption) (*ReposAddTeamAccessRestrictionsResponse, error) {
	if req == nil {
		req = new(ReposAddTeamAccessRestrictionsReq)
	}
	resp := &ReposAddTeamAccessRestrictionsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposAddTeamAccessRestrictionsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddTeamAccessRestrictions performs requests for "repos/add-team-access-restrictions"

Add team access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
func (c Client) ReposAddTeamAccessRestrictions(ctx context.Context, req *ReposAddTeamAccessRestrictionsReq, opt ...RequestOption) (*ReposAddTeamAccessRestrictionsResponse, error) {
	return ReposAddTeamAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposAddTeamAccessRestrictionsReq is request data for Client.ReposAddTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
type ReposAddTeamAccessRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposAddTeamAccessRestrictionsReqBody
}

func (r *ReposAddTeamAccessRestrictionsReq) url() string {
	return r._url
}

func (r *ReposAddTeamAccessRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddTeamAccessRestrictionsReq) method() string {
	return "POST"
}

func (r *ReposAddTeamAccessRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddTeamAccessRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddTeamAccessRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposAddTeamAccessRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposAddTeamAccessRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposAddTeamAccessRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposAddTeamAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddTeamAccessRestrictionsReq) Rel(link RelName, resp *ReposAddTeamAccessRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddTeamAccessRestrictionsReqBody is a request body for repos/add-team-access-restrictions

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
type ReposAddTeamAccessRestrictionsReqBody []string

/*
ReposAddTeamAccessRestrictionsResponseBody is a response body for ReposAddTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
type ReposAddTeamAccessRestrictionsResponseBody []components.Team

/*
ReposAddTeamAccessRestrictionsResponse is a response for ReposAddTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
type ReposAddTeamAccessRestrictionsResponse struct {
	response
	request *ReposAddTeamAccessRestrictionsReq
	Data    ReposAddTeamAccessRestrictionsResponseBody
}

/*
ReposAddUserAccessRestrictions performs requests for "repos/add-user-access-restrictions"

Add user access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
func ReposAddUserAccessRestrictions(ctx context.Context, req *ReposAddUserAccessRestrictionsReq, opt ...RequestOption) (*ReposAddUserAccessRestrictionsResponse, error) {
	if req == nil {
		req = new(ReposAddUserAccessRestrictionsReq)
	}
	resp := &ReposAddUserAccessRestrictionsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposAddUserAccessRestrictionsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposAddUserAccessRestrictions performs requests for "repos/add-user-access-restrictions"

Add user access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
func (c Client) ReposAddUserAccessRestrictions(ctx context.Context, req *ReposAddUserAccessRestrictionsReq, opt ...RequestOption) (*ReposAddUserAccessRestrictionsResponse, error) {
	return ReposAddUserAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposAddUserAccessRestrictionsReq is request data for Client.ReposAddUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
type ReposAddUserAccessRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposAddUserAccessRestrictionsReqBody
}

func (r *ReposAddUserAccessRestrictionsReq) url() string {
	return r._url
}

func (r *ReposAddUserAccessRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch)
}

func (r *ReposAddUserAccessRestrictionsReq) method() string {
	return "POST"
}

func (r *ReposAddUserAccessRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposAddUserAccessRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposAddUserAccessRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposAddUserAccessRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposAddUserAccessRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposAddUserAccessRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposAddUserAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposAddUserAccessRestrictionsReq) Rel(link RelName, resp *ReposAddUserAccessRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposAddUserAccessRestrictionsReqBody is a request body for repos/add-user-access-restrictions

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
type ReposAddUserAccessRestrictionsReqBody []string

/*
ReposAddUserAccessRestrictionsResponseBody is a response body for ReposAddUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
type ReposAddUserAccessRestrictionsResponseBody []components.SimpleUser

/*
ReposAddUserAccessRestrictionsResponse is a response for ReposAddUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
type ReposAddUserAccessRestrictionsResponse struct {
	response
	request *ReposAddUserAccessRestrictionsReq
	Data    ReposAddUserAccessRestrictionsResponseBody
}

/*
ReposCheckCollaborator performs requests for "repos/check-collaborator"

Check if a user is a repository collaborator.

  GET /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-repository-collaborator
*/
func ReposCheckCollaborator(ctx context.Context, req *ReposCheckCollaboratorReq, opt ...RequestOption) (*ReposCheckCollaboratorResponse, error) {
	if req == nil {
		req = new(ReposCheckCollaboratorReq)
	}
	resp := &ReposCheckCollaboratorResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCheckCollaborator performs requests for "repos/check-collaborator"

Check if a user is a repository collaborator.

  GET /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-repository-collaborator
*/
func (c Client) ReposCheckCollaborator(ctx context.Context, req *ReposCheckCollaboratorReq, opt ...RequestOption) (*ReposCheckCollaboratorResponse, error) {
	return ReposCheckCollaborator(ctx, req, append(c, opt...)...)
}

/*
ReposCheckCollaboratorReq is request data for Client.ReposCheckCollaborator

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-repository-collaborator
*/
type ReposCheckCollaboratorReq struct {
	_url     string
	Owner    string
	Repo     string
	Username string
}

func (r *ReposCheckCollaboratorReq) url() string {
	return r._url
}

func (r *ReposCheckCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username)
}

func (r *ReposCheckCollaboratorReq) method() string {
	return "GET"
}

func (r *ReposCheckCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCheckCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCheckCollaboratorReq) body() interface{} {
	return nil
}

func (r *ReposCheckCollaboratorReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposCheckCollaboratorReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposCheckCollaboratorReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// HTTPRequest builds an *http.Request
func (r *ReposCheckCollaboratorReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCheckCollaboratorReq) Rel(link RelName, resp *ReposCheckCollaboratorResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCheckCollaboratorResponse is a response for ReposCheckCollaborator

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-repository-collaborator
*/
type ReposCheckCollaboratorResponse struct {
	response
	request *ReposCheckCollaboratorReq
	Data    bool
}

/*
ReposCheckVulnerabilityAlerts performs requests for "repos/check-vulnerability-alerts"

Check if vulnerability alerts are enabled for a repository.

  GET /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
func ReposCheckVulnerabilityAlerts(ctx context.Context, req *ReposCheckVulnerabilityAlertsReq, opt ...RequestOption) (*ReposCheckVulnerabilityAlertsResponse, error) {
	if req == nil {
		req = new(ReposCheckVulnerabilityAlertsReq)
	}
	resp := &ReposCheckVulnerabilityAlertsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCheckVulnerabilityAlerts performs requests for "repos/check-vulnerability-alerts"

Check if vulnerability alerts are enabled for a repository.

  GET /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
func (c Client) ReposCheckVulnerabilityAlerts(ctx context.Context, req *ReposCheckVulnerabilityAlertsReq, opt ...RequestOption) (*ReposCheckVulnerabilityAlertsResponse, error) {
	return ReposCheckVulnerabilityAlerts(ctx, req, append(c, opt...)...)
}

/*
ReposCheckVulnerabilityAlertsReq is request data for Client.ReposCheckVulnerabilityAlerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
type ReposCheckVulnerabilityAlertsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling dependency alerts for a repository using the REST API is
	currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

func (r *ReposCheckVulnerabilityAlertsReq) url() string {
	return r._url
}

func (r *ReposCheckVulnerabilityAlertsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo)
}

func (r *ReposCheckVulnerabilityAlertsReq) method() string {
	return "GET"
}

func (r *ReposCheckVulnerabilityAlertsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCheckVulnerabilityAlertsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"dorian": r.DorianPreview}
	if requiredPreviews {
		previewVals["dorian"] = true
	}
	if allPreviews {
		previewVals["dorian"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCheckVulnerabilityAlertsReq) body() interface{} {
	return nil
}

func (r *ReposCheckVulnerabilityAlertsReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposCheckVulnerabilityAlertsReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposCheckVulnerabilityAlertsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// HTTPRequest builds an *http.Request
func (r *ReposCheckVulnerabilityAlertsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCheckVulnerabilityAlertsReq) Rel(link RelName, resp *ReposCheckVulnerabilityAlertsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCheckVulnerabilityAlertsResponse is a response for ReposCheckVulnerabilityAlerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
type ReposCheckVulnerabilityAlertsResponse struct {
	response
	request *ReposCheckVulnerabilityAlertsReq
	Data    bool
}

/*
ReposCompareCommits performs requests for "repos/compare-commits"

Compare two commits.

  GET /repos/{owner}/{repo}/compare/{base}...{head}

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
func ReposCompareCommits(ctx context.Context, req *ReposCompareCommitsReq, opt ...RequestOption) (*ReposCompareCommitsResponse, error) {
	if req == nil {
		req = new(ReposCompareCommitsReq)
	}
	resp := &ReposCompareCommitsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCompareCommitsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCompareCommits performs requests for "repos/compare-commits"

Compare two commits.

  GET /repos/{owner}/{repo}/compare/{base}...{head}

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
func (c Client) ReposCompareCommits(ctx context.Context, req *ReposCompareCommitsReq, opt ...RequestOption) (*ReposCompareCommitsResponse, error) {
	return ReposCompareCommits(ctx, req, append(c, opt...)...)
}

/*
ReposCompareCommitsReq is request data for Client.ReposCompareCommits

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
type ReposCompareCommitsReq struct {
	_url  string
	Owner string
	Repo  string
	Base  string
	Head  string
}

func (r *ReposCompareCommitsReq) url() string {
	return r._url
}

func (r *ReposCompareCommitsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/compare/%v...%v", r.Owner, r.Repo, r.Base, r.Head)
}

func (r *ReposCompareCommitsReq) method() string {
	return "GET"
}

func (r *ReposCompareCommitsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCompareCommitsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCompareCommitsReq) body() interface{} {
	return nil
}

func (r *ReposCompareCommitsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposCompareCommitsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposCompareCommitsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposCompareCommitsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCompareCommitsReq) Rel(link RelName, resp *ReposCompareCommitsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCompareCommitsResponseBody is a response body for ReposCompareCommits

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
type ReposCompareCommitsResponseBody components.CommitComparison

/*
ReposCompareCommitsResponse is a response for ReposCompareCommits

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
type ReposCompareCommitsResponse struct {
	response
	request *ReposCompareCommitsReq
	Data    ReposCompareCommitsResponseBody
}

/*
ReposCreateCommitComment performs requests for "repos/create-commit-comment"

Create a commit comment.

  POST /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
func ReposCreateCommitComment(ctx context.Context, req *ReposCreateCommitCommentReq, opt ...RequestOption) (*ReposCreateCommitCommentResponse, error) {
	if req == nil {
		req = new(ReposCreateCommitCommentReq)
	}
	resp := &ReposCreateCommitCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreateCommitCommentResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateCommitComment performs requests for "repos/create-commit-comment"

Create a commit comment.

  POST /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
func (c Client) ReposCreateCommitComment(ctx context.Context, req *ReposCreateCommitCommentReq, opt ...RequestOption) (*ReposCreateCommitCommentResponse, error) {
	return ReposCreateCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReposCreateCommitCommentReq is request data for Client.ReposCreateCommitComment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	CommitSha   string
	RequestBody ReposCreateCommitCommentReqBody
}

func (r *ReposCreateCommitCommentReq) url() string {
	return r._url
}

func (r *ReposCreateCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/comments", r.Owner, r.Repo, r.CommitSha)
}

func (r *ReposCreateCommitCommentReq) method() string {
	return "POST"
}

func (r *ReposCreateCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateCommitCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateCommitCommentReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateCommitCommentReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateCommitCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateCommitCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateCommitCommentReq) Rel(link RelName, resp *ReposCreateCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateCommitCommentReqBody is a request body for repos/create-commit-comment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`

	/*
	   **Deprecated**. Use **position** parameter instead. Line number in the file to
	   comment on.
	*/
	Line *int64 `json:"line,omitempty"`

	// Relative path of the file to comment on.
	Path *string `json:"path,omitempty"`

	// Line index in the diff to comment on.
	Position *int64 `json:"position,omitempty"`
}

/*
ReposCreateCommitCommentResponseBody is a response body for ReposCreateCommitComment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentResponseBody components.CommitComment

/*
ReposCreateCommitCommentResponse is a response for ReposCreateCommitComment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type ReposCreateCommitCommentResponse struct {
	response
	request *ReposCreateCommitCommentReq
	Data    ReposCreateCommitCommentResponseBody
}

/*
ReposCreateCommitSignatureProtection performs requests for "repos/create-commit-signature-protection"

Create commit signature protection.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#create-commit-signature-protection
*/
func ReposCreateCommitSignatureProtection(ctx context.Context, req *ReposCreateCommitSignatureProtectionReq, opt ...RequestOption) (*ReposCreateCommitSignatureProtectionResponse, error) {
	if req == nil {
		req = new(ReposCreateCommitSignatureProtectionReq)
	}
	resp := &ReposCreateCommitSignatureProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreateCommitSignatureProtectionResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateCommitSignatureProtection performs requests for "repos/create-commit-signature-protection"

Create commit signature protection.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#create-commit-signature-protection
*/
func (c Client) ReposCreateCommitSignatureProtection(ctx context.Context, req *ReposCreateCommitSignatureProtectionReq, opt ...RequestOption) (*ReposCreateCommitSignatureProtectionResponse, error) {
	return ReposCreateCommitSignatureProtection(ctx, req, append(c, opt...)...)
}

/*
ReposCreateCommitSignatureProtectionReq is request data for Client.ReposCreateCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#create-commit-signature-protection
*/
type ReposCreateCommitSignatureProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

func (r *ReposCreateCommitSignatureProtectionReq) url() string {
	return r._url
}

func (r *ReposCreateCommitSignatureProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch)
}

func (r *ReposCreateCommitSignatureProtectionReq) method() string {
	return "POST"
}

func (r *ReposCreateCommitSignatureProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateCommitSignatureProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"zzzax": r.ZzzaxPreview}
	if requiredPreviews {
		previewVals["zzzax"] = true
	}
	if allPreviews {
		previewVals["zzzax"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateCommitSignatureProtectionReq) body() interface{} {
	return nil
}

func (r *ReposCreateCommitSignatureProtectionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposCreateCommitSignatureProtectionReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposCreateCommitSignatureProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateCommitSignatureProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateCommitSignatureProtectionReq) Rel(link RelName, resp *ReposCreateCommitSignatureProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateCommitSignatureProtectionResponseBody is a response body for ReposCreateCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#create-commit-signature-protection
*/
type ReposCreateCommitSignatureProtectionResponseBody components.ProtectedBranchAdminEnforced

/*
ReposCreateCommitSignatureProtectionResponse is a response for ReposCreateCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#create-commit-signature-protection
*/
type ReposCreateCommitSignatureProtectionResponse struct {
	response
	request *ReposCreateCommitSignatureProtectionReq
	Data    ReposCreateCommitSignatureProtectionResponseBody
}

/*
ReposCreateCommitStatus performs requests for "repos/create-commit-status"

Create a commit status.

  POST /repos/{owner}/{repo}/statuses/{sha}

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
func ReposCreateCommitStatus(ctx context.Context, req *ReposCreateCommitStatusReq, opt ...RequestOption) (*ReposCreateCommitStatusResponse, error) {
	if req == nil {
		req = new(ReposCreateCommitStatusReq)
	}
	resp := &ReposCreateCommitStatusResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreateCommitStatusResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateCommitStatus performs requests for "repos/create-commit-status"

Create a commit status.

  POST /repos/{owner}/{repo}/statuses/{sha}

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
func (c Client) ReposCreateCommitStatus(ctx context.Context, req *ReposCreateCommitStatusReq, opt ...RequestOption) (*ReposCreateCommitStatusResponse, error) {
	return ReposCreateCommitStatus(ctx, req, append(c, opt...)...)
}

/*
ReposCreateCommitStatusReq is request data for Client.ReposCreateCommitStatus

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
type ReposCreateCommitStatusReq struct {
	_url        string
	Owner       string
	Repo        string
	Sha         string
	RequestBody ReposCreateCommitStatusReqBody
}

func (r *ReposCreateCommitStatusReq) url() string {
	return r._url
}

func (r *ReposCreateCommitStatusReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/statuses/%v", r.Owner, r.Repo, r.Sha)
}

func (r *ReposCreateCommitStatusReq) method() string {
	return "POST"
}

func (r *ReposCreateCommitStatusReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateCommitStatusReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateCommitStatusReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateCommitStatusReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateCommitStatusReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateCommitStatusReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateCommitStatusReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateCommitStatusReq) Rel(link RelName, resp *ReposCreateCommitStatusResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateCommitStatusReqBody is a request body for repos/create-commit-status

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
type ReposCreateCommitStatusReqBody struct {

	// A string label to differentiate this status from the status of other systems.
	Context *string `json:"context,omitempty"`

	// A short description of the status.
	Description *string `json:"description,omitempty"`

	/*
	   The state of the status. Can be one of `error`, `failure`, `pending`, or
	   `success`.
	*/
	State *string `json:"state"`

	/*
	   The target URL to associate with this status. This URL will be linked from the
	   GitHub UI to allow users to easily see the source of the status.
	   For example, if your continuous integration system is posting build status, you
	   would want to provide the deep link for the build output for this specific SHA:
	   `http://ci.example.com/user/repo/build/sha`
	*/
	TargetUrl *string `json:"target_url,omitempty"`
}

/*
ReposCreateCommitStatusResponseBody is a response body for ReposCreateCommitStatus

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
type ReposCreateCommitStatusResponseBody components.Status

/*
ReposCreateCommitStatusResponse is a response for ReposCreateCommitStatus

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
type ReposCreateCommitStatusResponse struct {
	response
	request *ReposCreateCommitStatusReq
	Data    ReposCreateCommitStatusResponseBody
}

/*
ReposCreateDeployKey performs requests for "repos/create-deploy-key"

Create a deploy key.

  POST /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
func ReposCreateDeployKey(ctx context.Context, req *ReposCreateDeployKeyReq, opt ...RequestOption) (*ReposCreateDeployKeyResponse, error) {
	if req == nil {
		req = new(ReposCreateDeployKeyReq)
	}
	resp := &ReposCreateDeployKeyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreateDeployKeyResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateDeployKey performs requests for "repos/create-deploy-key"

Create a deploy key.

  POST /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
func (c Client) ReposCreateDeployKey(ctx context.Context, req *ReposCreateDeployKeyReq, opt ...RequestOption) (*ReposCreateDeployKeyResponse, error) {
	return ReposCreateDeployKey(ctx, req, append(c, opt...)...)
}

/*
ReposCreateDeployKeyReq is request data for Client.ReposCreateDeployKey

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
type ReposCreateDeployKeyReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateDeployKeyReqBody
}

func (r *ReposCreateDeployKeyReq) url() string {
	return r._url
}

func (r *ReposCreateDeployKeyReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/keys", r.Owner, r.Repo)
}

func (r *ReposCreateDeployKeyReq) method() string {
	return "POST"
}

func (r *ReposCreateDeployKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateDeployKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateDeployKeyReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateDeployKeyReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateDeployKeyReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateDeployKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateDeployKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateDeployKeyReq) Rel(link RelName, resp *ReposCreateDeployKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateDeployKeyReqBody is a request body for repos/create-deploy-key

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
type ReposCreateDeployKeyReqBody struct {

	// The contents of the key.
	Key *string `json:"key"`

	/*
	   If `true`, the key will only be able to read repository contents. Otherwise, the
	   key will be able to read and write.

	   Deploy keys with write access can perform the same actions as an organization
	   member with admin access, or a collaborator on a personal repository. For more
	   information, see "[Repository permission levels for an
	   organization](https://help.github.com/articles/repository-permission-levels-for-an-organization/)"
	   and "[Permission levels for a user account
	   repository](https://help.github.com/articles/permission-levels-for-a-user-account-repository/)."
	*/
	ReadOnly *bool `json:"read_only,omitempty"`

	// A name for the key.
	Title *string `json:"title,omitempty"`
}

/*
ReposCreateDeployKeyResponseBody is a response body for ReposCreateDeployKey

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
type ReposCreateDeployKeyResponseBody components.DeployKey

/*
ReposCreateDeployKeyResponse is a response for ReposCreateDeployKey

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
type ReposCreateDeployKeyResponse struct {
	response
	request *ReposCreateDeployKeyReq
	Data    ReposCreateDeployKeyResponseBody
}

/*
ReposCreateDeployment performs requests for "repos/create-deployment"

Create a deployment.

  POST /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
func ReposCreateDeployment(ctx context.Context, req *ReposCreateDeploymentReq, opt ...RequestOption) (*ReposCreateDeploymentResponse, error) {
	if req == nil {
		req = new(ReposCreateDeploymentReq)
	}
	resp := &ReposCreateDeploymentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreateDeploymentResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateDeployment performs requests for "repos/create-deployment"

Create a deployment.

  POST /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
func (c Client) ReposCreateDeployment(ctx context.Context, req *ReposCreateDeploymentReq, opt ...RequestOption) (*ReposCreateDeploymentResponse, error) {
	return ReposCreateDeployment(ctx, req, append(c, opt...)...)
}

/*
ReposCreateDeploymentReq is request data for Client.ReposCreateDeployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateDeploymentReqBody

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposCreateDeploymentReq) url() string {
	return r._url
}

func (r *ReposCreateDeploymentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments", r.Owner, r.Repo)
}

func (r *ReposCreateDeploymentReq) method() string {
	return "POST"
}

func (r *ReposCreateDeploymentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateDeploymentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"ant-man": r.AntManPreview}
	if allPreviews {
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateDeploymentReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateDeploymentReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateDeploymentReq) validStatuses() []int {
	return []int{201, 202}
}

func (r *ReposCreateDeploymentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateDeploymentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateDeploymentReq) Rel(link RelName, resp *ReposCreateDeploymentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateDeploymentReqBody is a request body for repos/create-deployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentReqBody struct {

	/*
	   Attempts to automatically merge the default branch into the requested ref, if
	   it's behind the default branch.
	*/
	AutoMerge *bool `json:"auto_merge,omitempty"`

	// Short description of the deployment.
	Description *string `json:"description,omitempty"`

	/*
	   Name for the target deployment environment (e.g., `production`, `staging`,
	   `qa`).
	*/
	Environment *string `json:"environment,omitempty"`

	// JSON payload with extra information about the deployment.
	Payload interface{} `json:"payload,omitempty"`

	/*
	   Specifies if the given environment is one that end-users directly interact with.
	   Default: `true` when `environment` is `production` and `false` otherwise.
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	ProductionEnvironment *bool `json:"production_environment,omitempty"`

	// The ref to deploy. This can be a branch, tag, or SHA.
	Ref *string `json:"ref"`

	/*
	   The [status](https://developer.github.com/v3/repos/statuses/) contexts to verify
	   against commit status checks. If you omit this parameter, GitHub verifies all
	   unique contexts before creating a deployment. To bypass checking entirely, pass
	   an empty array. Defaults to all unique contexts.
	*/
	RequiredContexts []string `json:"required_contexts,omitempty"`

	// Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).
	Task *string `json:"task,omitempty"`

	/*
	   Specifies if the given environment is specific to the deployment and will no
	   longer exist at some point in the future. Default: `false`
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type. **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	TransientEnvironment *bool `json:"transient_environment,omitempty"`
}

/*
ReposCreateDeploymentResponseBody is a response body for ReposCreateDeployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentResponseBody components.Deployment

/*
ReposCreateDeploymentResponse is a response for ReposCreateDeployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type ReposCreateDeploymentResponse struct {
	response
	request *ReposCreateDeploymentReq
	Data    ReposCreateDeploymentResponseBody
}

/*
ReposCreateDeploymentStatus performs requests for "repos/create-deployment-status"

Create a deployment status.

  POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
func ReposCreateDeploymentStatus(ctx context.Context, req *ReposCreateDeploymentStatusReq, opt ...RequestOption) (*ReposCreateDeploymentStatusResponse, error) {
	if req == nil {
		req = new(ReposCreateDeploymentStatusReq)
	}
	resp := &ReposCreateDeploymentStatusResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreateDeploymentStatusResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateDeploymentStatus performs requests for "repos/create-deployment-status"

Create a deployment status.

  POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
func (c Client) ReposCreateDeploymentStatus(ctx context.Context, req *ReposCreateDeploymentStatusReq, opt ...RequestOption) (*ReposCreateDeploymentStatusResponse, error) {
	return ReposCreateDeploymentStatus(ctx, req, append(c, opt...)...)
}

/*
ReposCreateDeploymentStatusReq is request data for Client.ReposCreateDeploymentStatus

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusReq struct {
	_url         string
	Owner        string
	Repo         string
	DeploymentId int64
	RequestBody  ReposCreateDeploymentStatusReqBody

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposCreateDeploymentStatusReq) url() string {
	return r._url
}

func (r *ReposCreateDeploymentStatusReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses", r.Owner, r.Repo, r.DeploymentId)
}

func (r *ReposCreateDeploymentStatusReq) method() string {
	return "POST"
}

func (r *ReposCreateDeploymentStatusReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateDeploymentStatusReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"ant-man": r.AntManPreview,
		"flash":   r.FlashPreview,
	}
	if allPreviews {
		previewVals["flash"] = true
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateDeploymentStatusReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateDeploymentStatusReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateDeploymentStatusReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateDeploymentStatusReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateDeploymentStatusReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateDeploymentStatusReq) Rel(link RelName, resp *ReposCreateDeploymentStatusResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateDeploymentStatusReqBody is a request body for repos/create-deployment-status

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusReqBody struct {

	/*
	   Adds a new `inactive` status to all prior non-transient, non-production
	   environment deployments with the same repository and `environment` name as the
	   created status's deployment. An `inactive` status is only added to deployments
	   that had a `success` state. Default: `true`
	   **Note:** To add an `inactive` status to `production` environments, you must use
	   the
	   [`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	   custom media type.
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	AutoInactive *bool `json:"auto_inactive,omitempty"`

	/*
	   A short description of the status. The maximum description length is 140
	   characters.
	*/
	Description *string `json:"description,omitempty"`

	/*
	   Name for the target deployment environment, which can be changed when setting a
	   deploy status. For example, `production`, `staging`, or `qa`. **Note:** This
	   parameter requires you to use the
	   [`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	   custom media type.
	*/
	Environment *string `json:"environment,omitempty"`

	/*
	   Sets the URL for accessing your environment. Default: `""`
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type. **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	EnvironmentUrl *string `json:"environment_url,omitempty"`

	/*
	   The full URL of the deployment's output. This parameter replaces `target_url`.
	   We will continue to accept `target_url` to support legacy uses, but we recommend
	   replacing `target_url` with `log_url`. Setting `log_url` will automatically set
	   `target_url` to the same value. Default: `""`
	   **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type. **Note:** This parameter requires you to use the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type.
	*/
	LogUrl *string `json:"log_url,omitempty"`

	/*
	   The state of the status. Can be one of `error`, `failure`, `inactive`,
	   `in_progress`, `queued` `pending`, or `success`. **Note:** To use the `inactive`
	   state, you must provide the
	   [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	   custom media type. To use the `in_progress` and `queued` states, you must
	   provide the
	   [`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	   custom media type. When you set a transient deployment to `inactive`, the
	   deployment will be shown as `destroyed` in GitHub.
	*/
	State *string `json:"state"`

	/*
	   The target URL to associate with this status. This URL should contain output to
	   keep the user updated while the task is running or serve as historical
	   information for what happened in the deployment. **Note:** It's recommended to
	   use the `log_url` parameter, which replaces `target_url`.
	*/
	TargetUrl *string `json:"target_url,omitempty"`
}

/*
ReposCreateDeploymentStatusResponseBody is a response body for ReposCreateDeploymentStatus

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusResponseBody components.DeploymentStatus

/*
ReposCreateDeploymentStatusResponse is a response for ReposCreateDeploymentStatus

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type ReposCreateDeploymentStatusResponse struct {
	response
	request *ReposCreateDeploymentStatusReq
	Data    ReposCreateDeploymentStatusResponseBody
}

/*
ReposCreateDispatchEvent performs requests for "repos/create-dispatch-event"

Create a repository dispatch event.

  POST /repos/{owner}/{repo}/dispatches

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
func ReposCreateDispatchEvent(ctx context.Context, req *ReposCreateDispatchEventReq, opt ...RequestOption) (*ReposCreateDispatchEventResponse, error) {
	if req == nil {
		req = new(ReposCreateDispatchEventReq)
	}
	resp := &ReposCreateDispatchEventResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateDispatchEvent performs requests for "repos/create-dispatch-event"

Create a repository dispatch event.

  POST /repos/{owner}/{repo}/dispatches

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
func (c Client) ReposCreateDispatchEvent(ctx context.Context, req *ReposCreateDispatchEventReq, opt ...RequestOption) (*ReposCreateDispatchEventResponse, error) {
	return ReposCreateDispatchEvent(ctx, req, append(c, opt...)...)
}

/*
ReposCreateDispatchEventReq is request data for Client.ReposCreateDispatchEvent

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type ReposCreateDispatchEventReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateDispatchEventReqBody
}

func (r *ReposCreateDispatchEventReq) url() string {
	return r._url
}

func (r *ReposCreateDispatchEventReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/dispatches", r.Owner, r.Repo)
}

func (r *ReposCreateDispatchEventReq) method() string {
	return "POST"
}

func (r *ReposCreateDispatchEventReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateDispatchEventReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateDispatchEventReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateDispatchEventReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposCreateDispatchEventReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposCreateDispatchEventReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateDispatchEventReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateDispatchEventReq) Rel(link RelName, resp *ReposCreateDispatchEventResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateDispatchEventReqBody is a request body for repos/create-dispatch-event

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type ReposCreateDispatchEventReqBody struct {

	/*
	   JSON payload with extra information about the webhook event that your action or
	   worklow may use.
	*/
	ClientPayload interface{} `json:"client_payload,omitempty"`

	// **Required:** A custom webhook event name.
	EventType *string `json:"event_type"`
}

/*
ReposCreateDispatchEventResponse is a response for ReposCreateDispatchEvent

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type ReposCreateDispatchEventResponse struct {
	response
	request *ReposCreateDispatchEventReq
}

/*
ReposCreateForAuthenticatedUser performs requests for "repos/create-for-authenticated-user"

Create a repository for the authenticated user.

  POST /user/repos

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
func ReposCreateForAuthenticatedUser(ctx context.Context, req *ReposCreateForAuthenticatedUserReq, opt ...RequestOption) (*ReposCreateForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(ReposCreateForAuthenticatedUserReq)
	}
	resp := &ReposCreateForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreateForAuthenticatedUserResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateForAuthenticatedUser performs requests for "repos/create-for-authenticated-user"

Create a repository for the authenticated user.

  POST /user/repos

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
func (c Client) ReposCreateForAuthenticatedUser(ctx context.Context, req *ReposCreateForAuthenticatedUserReq, opt ...RequestOption) (*ReposCreateForAuthenticatedUserResponse, error) {
	return ReposCreateForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ReposCreateForAuthenticatedUserReq is request data for Client.ReposCreateForAuthenticatedUser

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserReq struct {
	_url        string
	RequestBody ReposCreateForAuthenticatedUserReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

func (r *ReposCreateForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *ReposCreateForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/repos")
}

func (r *ReposCreateForAuthenticatedUserReq) method() string {
	return "POST"
}

func (r *ReposCreateForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"baptiste": r.BaptistePreview,
		"nebula":   r.NebulaPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateForAuthenticatedUserReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateForAuthenticatedUserReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateForAuthenticatedUserReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateForAuthenticatedUserReq) Rel(link RelName, resp *ReposCreateForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateForAuthenticatedUserReqBody is a request body for repos/create-for-authenticated-user

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserReqBody struct {

	/*
	   Either `true` to allow merging pull requests with a merge commit, or `false` to
	   prevent merging pull requests with merge commits.
	*/
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	/*
	   Either `true` to allow rebase-merging pull requests, or `false` to prevent
	   rebase-merging.
	*/
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	/*
	   Either `true` to allow squash-merging pull requests, or `false` to prevent
	   squash-merging.
	*/
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	// Pass `true` to create an initial commit with empty README.
	AutoInit *bool `json:"auto_init,omitempty"`

	/*
	   Either `true` to allow automatically deleting head branches when pull requests
	   are merged, or `false` to prevent automatic deletion.
	*/
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	/*
	   Desired language or platform [.gitignore
	   template](https://github.com/github/gitignore) to apply. Use the name of the
	   template without the extension. For example, "Haskell".
	*/
	GitignoreTemplate *string `json:"gitignore_template,omitempty"`

	// Either `true` to enable issues for this repository or `false` to disable them.
	HasIssues *bool `json:"has_issues,omitempty"`

	/*
	   Either `true` to enable projects for this repository or `false` to disable them.
	   **Note:** If you're creating a repository in an organization that has disabled
	   repository projects, the default is `false`, and if you pass `true`, the API
	   returns an error.
	*/
	HasProjects *bool `json:"has_projects,omitempty"`

	// Either `true` to enable the wiki for this repository or `false` to disable it.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	/*
	   Either `true` to make this repo available as a template repository or `false` to
	   prevent it.
	*/
	IsTemplate *bool `json:"is_template,omitempty"`

	/*
	   Choose an [open source license template](https://choosealicense.com/) that best
	   suits your needs, and then use the [license
	   keyword](https://help.github.com/articles/licensing-a-repository/#searching-github-by-license-type)
	   as the `license_template` string. For example, "mit" or "mpl-2.0".
	*/
	LicenseTemplate *string `json:"license_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name"`

	// Either `true` to create a private repository or `false` to create a public one.
	Private *bool `json:"private,omitempty"`

	/*
	   The id of the team that will be granted access to this repository. This is only
	   valid when creating a repository in an organization.
	*/
	TeamId *int64 `json:"team_id,omitempty"`

	/*
	   Can be `public` or `private`. If your organization is associated with an
	   enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server
	   2.20+, `visibility` can also be `internal`. For more information, see "[Creating
	   an internal
	   repository](https://help.github.com/github/creating-cloning-and-archiving-repositories/creating-an-internal-repository)".
	   The `visibility` parameter overrides the `private` parameter when you use both
	   parameters with the `nebula-preview` preview header.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ReposCreateForAuthenticatedUserResponseBody is a response body for ReposCreateForAuthenticatedUser

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserResponseBody components.Repository

/*
ReposCreateForAuthenticatedUserResponse is a response for ReposCreateForAuthenticatedUser

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type ReposCreateForAuthenticatedUserResponse struct {
	response
	request *ReposCreateForAuthenticatedUserReq
	Data    ReposCreateForAuthenticatedUserResponseBody
}

/*
ReposCreateFork performs requests for "repos/create-fork"

Create a fork.

  POST /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
func ReposCreateFork(ctx context.Context, req *ReposCreateForkReq, opt ...RequestOption) (*ReposCreateForkResponse, error) {
	if req == nil {
		req = new(ReposCreateForkReq)
	}
	resp := &ReposCreateForkResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreateForkResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateFork performs requests for "repos/create-fork"

Create a fork.

  POST /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
func (c Client) ReposCreateFork(ctx context.Context, req *ReposCreateForkReq, opt ...RequestOption) (*ReposCreateForkResponse, error) {
	return ReposCreateFork(ctx, req, append(c, opt...)...)
}

/*
ReposCreateForkReq is request data for Client.ReposCreateFork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateForkReqBody
}

func (r *ReposCreateForkReq) url() string {
	return r._url
}

func (r *ReposCreateForkReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/forks", r.Owner, r.Repo)
}

func (r *ReposCreateForkReq) method() string {
	return "POST"
}

func (r *ReposCreateForkReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateForkReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateForkReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateForkReq) dataStatuses() []int {
	return []int{202}
}

func (r *ReposCreateForkReq) validStatuses() []int {
	return []int{202}
}

func (r *ReposCreateForkReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateForkReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateForkReq) Rel(link RelName, resp *ReposCreateForkResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateForkReqBody is a request body for repos/create-fork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkReqBody struct {

	/*
	   Optional parameter to specify the organization name if forking into an
	   organization.
	*/
	Organization *string `json:"organization,omitempty"`
}

/*
ReposCreateForkResponseBody is a response body for ReposCreateFork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkResponseBody components.Repository

/*
ReposCreateForkResponse is a response for ReposCreateFork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type ReposCreateForkResponse struct {
	response
	request *ReposCreateForkReq
	Data    ReposCreateForkResponseBody
}

/*
ReposCreateInOrg performs requests for "repos/create-in-org"

Create an organization repository.

  POST /orgs/{org}/repos

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
func ReposCreateInOrg(ctx context.Context, req *ReposCreateInOrgReq, opt ...RequestOption) (*ReposCreateInOrgResponse, error) {
	if req == nil {
		req = new(ReposCreateInOrgReq)
	}
	resp := &ReposCreateInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreateInOrgResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateInOrg performs requests for "repos/create-in-org"

Create an organization repository.

  POST /orgs/{org}/repos

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
func (c Client) ReposCreateInOrg(ctx context.Context, req *ReposCreateInOrgReq, opt ...RequestOption) (*ReposCreateInOrgResponse, error) {
	return ReposCreateInOrg(ctx, req, append(c, opt...)...)
}

/*
ReposCreateInOrgReq is request data for Client.ReposCreateInOrg

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgReq struct {
	_url        string
	Org         string
	RequestBody ReposCreateInOrgReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

func (r *ReposCreateInOrgReq) url() string {
	return r._url
}

func (r *ReposCreateInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/repos", r.Org)
}

func (r *ReposCreateInOrgReq) method() string {
	return "POST"
}

func (r *ReposCreateInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"baptiste": r.BaptistePreview,
		"nebula":   r.NebulaPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateInOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateInOrgReq) Rel(link RelName, resp *ReposCreateInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateInOrgReqBody is a request body for repos/create-in-org

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgReqBody struct {

	/*
	   Either `true` to allow merging pull requests with a merge commit, or `false` to
	   prevent merging pull requests with merge commits.
	*/
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	/*
	   Either `true` to allow rebase-merging pull requests, or `false` to prevent
	   rebase-merging.
	*/
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	/*
	   Either `true` to allow squash-merging pull requests, or `false` to prevent
	   squash-merging.
	*/
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	// Pass `true` to create an initial commit with empty README.
	AutoInit *bool `json:"auto_init,omitempty"`

	/*
	   Either `true` to allow automatically deleting head branches when pull requests
	   are merged, or `false` to prevent automatic deletion.
	*/
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	/*
	   Desired language or platform [.gitignore
	   template](https://github.com/github/gitignore) to apply. Use the name of the
	   template without the extension. For example, "Haskell".
	*/
	GitignoreTemplate *string `json:"gitignore_template,omitempty"`

	// Either `true` to enable issues for this repository or `false` to disable them.
	HasIssues *bool `json:"has_issues,omitempty"`

	/*
	   Either `true` to enable projects for this repository or `false` to disable them.
	   **Note:** If you're creating a repository in an organization that has disabled
	   repository projects, the default is `false`, and if you pass `true`, the API
	   returns an error.
	*/
	HasProjects *bool `json:"has_projects,omitempty"`

	// Either `true` to enable the wiki for this repository or `false` to disable it.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	/*
	   Either `true` to make this repo available as a template repository or `false` to
	   prevent it.
	*/
	IsTemplate *bool `json:"is_template,omitempty"`

	/*
	   Choose an [open source license template](https://choosealicense.com/) that best
	   suits your needs, and then use the [license
	   keyword](https://help.github.com/articles/licensing-a-repository/#searching-github-by-license-type)
	   as the `license_template` string. For example, "mit" or "mpl-2.0".
	*/
	LicenseTemplate *string `json:"license_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name"`

	// Either `true` to create a private repository or `false` to create a public one.
	Private *bool `json:"private,omitempty"`

	/*
	   The id of the team that will be granted access to this repository. This is only
	   valid when creating a repository in an organization.
	*/
	TeamId *int64 `json:"team_id,omitempty"`

	/*
	   Can be `public` or `private`. If your organization is associated with an
	   enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server
	   2.20+, `visibility` can also be `internal`. For more information, see "[Creating
	   an internal
	   repository](https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)".
	   The `visibility` parameter overrides the `private` parameter when you use both
	   parameters with the `nebula-preview` preview header.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ReposCreateInOrgResponseBody is a response body for ReposCreateInOrg

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgResponseBody components.Repository

/*
ReposCreateInOrgResponse is a response for ReposCreateInOrg

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type ReposCreateInOrgResponse struct {
	response
	request *ReposCreateInOrgReq
	Data    ReposCreateInOrgResponseBody
}

/*
ReposCreateOrUpdateFileContents performs requests for "repos/create-or-update-file-contents"

Create or update file contents.

  PUT /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
func ReposCreateOrUpdateFileContents(ctx context.Context, req *ReposCreateOrUpdateFileContentsReq, opt ...RequestOption) (*ReposCreateOrUpdateFileContentsResponse, error) {
	if req == nil {
		req = new(ReposCreateOrUpdateFileContentsReq)
	}
	resp := &ReposCreateOrUpdateFileContentsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreateOrUpdateFileContentsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateOrUpdateFileContents performs requests for "repos/create-or-update-file-contents"

Create or update file contents.

  PUT /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
func (c Client) ReposCreateOrUpdateFileContents(ctx context.Context, req *ReposCreateOrUpdateFileContentsReq, opt ...RequestOption) (*ReposCreateOrUpdateFileContentsResponse, error) {
	return ReposCreateOrUpdateFileContents(ctx, req, append(c, opt...)...)
}

/*
ReposCreateOrUpdateFileContentsReq is request data for Client.ReposCreateOrUpdateFileContents

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
type ReposCreateOrUpdateFileContentsReq struct {
	_url        string
	Owner       string
	Repo        string
	Path        string
	RequestBody ReposCreateOrUpdateFileContentsReqBody
}

func (r *ReposCreateOrUpdateFileContentsReq) url() string {
	return r._url
}

func (r *ReposCreateOrUpdateFileContentsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path)
}

func (r *ReposCreateOrUpdateFileContentsReq) method() string {
	return "PUT"
}

func (r *ReposCreateOrUpdateFileContentsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateOrUpdateFileContentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateOrUpdateFileContentsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateOrUpdateFileContentsReq) dataStatuses() []int {
	return []int{200, 201}
}

func (r *ReposCreateOrUpdateFileContentsReq) validStatuses() []int {
	return []int{200, 201}
}

func (r *ReposCreateOrUpdateFileContentsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateOrUpdateFileContentsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateOrUpdateFileContentsReq) Rel(link RelName, resp *ReposCreateOrUpdateFileContentsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposCreateOrUpdateFileContentsReqBodyAuthor is a value for ReposCreateOrUpdateFileContentsReqBody's Author field
type ReposCreateOrUpdateFileContentsReqBodyAuthor struct {

	/*
	   The email of the author or committer of the commit. You'll receive a `422`
	   status code if `email` is omitted.
	*/
	Email *string `json:"email"`

	/*
	   The name of the author or committer of the commit. You'll receive a `422` status
	   code if `name` is omitted.
	*/
	Name *string `json:"name"`
}

// ReposCreateOrUpdateFileContentsReqBodyCommitter is a value for ReposCreateOrUpdateFileContentsReqBody's Committer field
type ReposCreateOrUpdateFileContentsReqBodyCommitter struct {

	/*
	   The email of the author or committer of the commit. You'll receive a `422`
	   status code if `email` is omitted.
	*/
	Email *string `json:"email"`

	/*
	   The name of the author or committer of the commit. You'll receive a `422` status
	   code if `name` is omitted.
	*/
	Name *string `json:"name"`
}

/*
ReposCreateOrUpdateFileContentsReqBody is a request body for repos/create-or-update-file-contents

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
type ReposCreateOrUpdateFileContentsReqBody struct {

	/*
	   The author of the file. Default: The `committer` or the authenticated user if
	   you omit `committer`.
	*/
	Author *ReposCreateOrUpdateFileContentsReqBodyAuthor `json:"author,omitempty"`

	// The branch name. Default: the repositorys default branch (usually `master`)
	Branch *string `json:"branch,omitempty"`

	// The person that committed the file. Default: the authenticated user.
	Committer *ReposCreateOrUpdateFileContentsReqBodyCommitter `json:"committer,omitempty"`

	// The new file content, using Base64 encoding.
	Content *string `json:"content"`

	// The commit message.
	Message *string `json:"message"`

	/*
	   **Required if you are updating a file**. The blob SHA of the file being
	   replaced.
	*/
	Sha *string `json:"sha,omitempty"`
}

/*
ReposCreateOrUpdateFileContentsResponseBody is a response body for ReposCreateOrUpdateFileContents

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
type ReposCreateOrUpdateFileContentsResponseBody components.FileCommit

/*
ReposCreateOrUpdateFileContentsResponse is a response for ReposCreateOrUpdateFileContents

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
type ReposCreateOrUpdateFileContentsResponse struct {
	response
	request *ReposCreateOrUpdateFileContentsReq
	Data    ReposCreateOrUpdateFileContentsResponseBody
}

/*
ReposCreatePagesSite performs requests for "repos/create-pages-site"

Create a GitHub Pages site.

  POST /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
func ReposCreatePagesSite(ctx context.Context, req *ReposCreatePagesSiteReq, opt ...RequestOption) (*ReposCreatePagesSiteResponse, error) {
	if req == nil {
		req = new(ReposCreatePagesSiteReq)
	}
	resp := &ReposCreatePagesSiteResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreatePagesSiteResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreatePagesSite performs requests for "repos/create-pages-site"

Create a GitHub Pages site.

  POST /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
func (c Client) ReposCreatePagesSite(ctx context.Context, req *ReposCreatePagesSiteReq, opt ...RequestOption) (*ReposCreatePagesSiteResponse, error) {
	return ReposCreatePagesSite(ctx, req, append(c, opt...)...)
}

/*
ReposCreatePagesSiteReq is request data for Client.ReposCreatePagesSite

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
type ReposCreatePagesSiteReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreatePagesSiteReqBody

	/*
	Enabling and disabling Pages in the Pages API is currently available for
	developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-03-14-enabling-disabling-pages/)
	preview for more details. To access the new endpoints during the preview period,
	you must set this to true.
	*/
	SwitcherooPreview bool
}

func (r *ReposCreatePagesSiteReq) url() string {
	return r._url
}

func (r *ReposCreatePagesSiteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo)
}

func (r *ReposCreatePagesSiteReq) method() string {
	return "POST"
}

func (r *ReposCreatePagesSiteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreatePagesSiteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"switcheroo": r.SwitcherooPreview}
	if requiredPreviews {
		previewVals["switcheroo"] = true
	}
	if allPreviews {
		previewVals["switcheroo"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreatePagesSiteReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreatePagesSiteReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreatePagesSiteReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreatePagesSiteReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreatePagesSiteReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreatePagesSiteReq) Rel(link RelName, resp *ReposCreatePagesSiteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposCreatePagesSiteReqBodySource is a value for ReposCreatePagesSiteReqBody's Source field
type ReposCreatePagesSiteReqBodySource struct {

	/*
	   The repository branch used to publish your [site's source
	   files](https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/).
	   Can be either `master` or `gh-pages`.
	*/
	Branch *string `json:"branch,omitempty"`

	/*
	   The repository directory that includes the source files for the Pages site. When
	   `branch` is `master`, you can change `path` to `/docs`. When `branch` is
	   `gh-pages`, you are unable to specify a `path` other than `/`.
	*/
	Path *string `json:"path,omitempty"`
}

/*
ReposCreatePagesSiteReqBody is a request body for repos/create-pages-site

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
type ReposCreatePagesSiteReqBody struct {
	Source *ReposCreatePagesSiteReqBodySource `json:"source,omitempty"`
}

/*
ReposCreatePagesSiteResponseBody is a response body for ReposCreatePagesSite

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
type ReposCreatePagesSiteResponseBody components.Page

/*
ReposCreatePagesSiteResponse is a response for ReposCreatePagesSite

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
type ReposCreatePagesSiteResponse struct {
	response
	request *ReposCreatePagesSiteReq
	Data    ReposCreatePagesSiteResponseBody
}

/*
ReposCreateRelease performs requests for "repos/create-release"

Create a release.

  POST /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#create-a-release
*/
func ReposCreateRelease(ctx context.Context, req *ReposCreateReleaseReq, opt ...RequestOption) (*ReposCreateReleaseResponse, error) {
	if req == nil {
		req = new(ReposCreateReleaseReq)
	}
	resp := &ReposCreateReleaseResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreateReleaseResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateRelease performs requests for "repos/create-release"

Create a release.

  POST /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#create-a-release
*/
func (c Client) ReposCreateRelease(ctx context.Context, req *ReposCreateReleaseReq, opt ...RequestOption) (*ReposCreateReleaseResponse, error) {
	return ReposCreateRelease(ctx, req, append(c, opt...)...)
}

/*
ReposCreateReleaseReq is request data for Client.ReposCreateRelease

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateReleaseReqBody
}

func (r *ReposCreateReleaseReq) url() string {
	return r._url
}

func (r *ReposCreateReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases", r.Owner, r.Repo)
}

func (r *ReposCreateReleaseReq) method() string {
	return "POST"
}

func (r *ReposCreateReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateReleaseReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateReleaseReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateReleaseReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateReleaseReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateReleaseReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateReleaseReq) Rel(link RelName, resp *ReposCreateReleaseResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateReleaseReqBody is a request body for repos/create-release

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseReqBody struct {

	// Text describing the contents of the tag.
	Body *string `json:"body,omitempty"`

	/*
	   `true` to create a draft (unpublished) release, `false` to create a published
	   one.
	*/
	Draft *bool `json:"draft,omitempty"`

	// The name of the release.
	Name *string `json:"name,omitempty"`

	/*
	   `true` to identify the release as a prerelease. `false` to identify the release
	   as a full release.
	*/
	Prerelease *bool `json:"prerelease,omitempty"`

	// The name of the tag.
	TagName *string `json:"tag_name"`

	/*
	   Specifies the commitish value that determines where the Git tag is created from.
	   Can be any branch or commit SHA. Unused if the Git tag already exists. Default:
	   the repository's default branch (usually `master`).
	*/
	TargetCommitish *string `json:"target_commitish,omitempty"`
}

/*
ReposCreateReleaseResponseBody is a response body for ReposCreateRelease

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseResponseBody components.Release

/*
ReposCreateReleaseResponse is a response for ReposCreateRelease

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type ReposCreateReleaseResponse struct {
	response
	request *ReposCreateReleaseReq
	Data    ReposCreateReleaseResponseBody
}

/*
ReposCreateUsingTemplate performs requests for "repos/create-using-template"

Create a repository using a template.

  POST /repos/{template_owner}/{template_repo}/generate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
func ReposCreateUsingTemplate(ctx context.Context, req *ReposCreateUsingTemplateReq, opt ...RequestOption) (*ReposCreateUsingTemplateResponse, error) {
	if req == nil {
		req = new(ReposCreateUsingTemplateReq)
	}
	resp := &ReposCreateUsingTemplateResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreateUsingTemplateResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateUsingTemplate performs requests for "repos/create-using-template"

Create a repository using a template.

  POST /repos/{template_owner}/{template_repo}/generate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
func (c Client) ReposCreateUsingTemplate(ctx context.Context, req *ReposCreateUsingTemplateReq, opt ...RequestOption) (*ReposCreateUsingTemplateResponse, error) {
	return ReposCreateUsingTemplate(ctx, req, append(c, opt...)...)
}

/*
ReposCreateUsingTemplateReq is request data for Client.ReposCreateUsingTemplate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateReq struct {
	_url          string
	TemplateOwner string
	TemplateRepo  string
	RequestBody   ReposCreateUsingTemplateReqBody

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

func (r *ReposCreateUsingTemplateReq) url() string {
	return r._url
}

func (r *ReposCreateUsingTemplateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/generate", r.TemplateOwner, r.TemplateRepo)
}

func (r *ReposCreateUsingTemplateReq) method() string {
	return "POST"
}

func (r *ReposCreateUsingTemplateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateUsingTemplateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"baptiste": r.BaptistePreview}
	if requiredPreviews {
		previewVals["baptiste"] = true
	}
	if allPreviews {
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateUsingTemplateReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateUsingTemplateReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateUsingTemplateReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateUsingTemplateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateUsingTemplateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateUsingTemplateReq) Rel(link RelName, resp *ReposCreateUsingTemplateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposCreateUsingTemplateReqBody is a request body for repos/create-using-template

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateReqBody struct {

	// A short description of the new repository.
	Description *string `json:"description,omitempty"`

	// The name of the new repository.
	Name *string `json:"name"`

	/*
	   The organization or person who will own the new repository. To create a new
	   repository in an organization, the authenticated user must be a member of the
	   specified organization.
	*/
	Owner *string `json:"owner,omitempty"`

	/*
	   Either `true` to create a new private repository or `false` to create a new
	   public one.
	*/
	Private *bool `json:"private,omitempty"`
}

/*
ReposCreateUsingTemplateResponseBody is a response body for ReposCreateUsingTemplate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateResponseBody components.Repository3

/*
ReposCreateUsingTemplateResponse is a response for ReposCreateUsingTemplate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type ReposCreateUsingTemplateResponse struct {
	response
	request *ReposCreateUsingTemplateReq
	Data    ReposCreateUsingTemplateResponseBody
}

/*
ReposCreateWebhook performs requests for "repos/create-webhook"

Create a repository webhook.

  POST /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
func ReposCreateWebhook(ctx context.Context, req *ReposCreateWebhookReq, opt ...RequestOption) (*ReposCreateWebhookResponse, error) {
	if req == nil {
		req = new(ReposCreateWebhookReq)
	}
	resp := &ReposCreateWebhookResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposCreateWebhookResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposCreateWebhook performs requests for "repos/create-webhook"

Create a repository webhook.

  POST /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
func (c Client) ReposCreateWebhook(ctx context.Context, req *ReposCreateWebhookReq, opt ...RequestOption) (*ReposCreateWebhookResponse, error) {
	return ReposCreateWebhook(ctx, req, append(c, opt...)...)
}

/*
ReposCreateWebhookReq is request data for Client.ReposCreateWebhook

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
type ReposCreateWebhookReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposCreateWebhookReqBody
}

func (r *ReposCreateWebhookReq) url() string {
	return r._url
}

func (r *ReposCreateWebhookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks", r.Owner, r.Repo)
}

func (r *ReposCreateWebhookReq) method() string {
	return "POST"
}

func (r *ReposCreateWebhookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposCreateWebhookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposCreateWebhookReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposCreateWebhookReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposCreateWebhookReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposCreateWebhookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposCreateWebhookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposCreateWebhookReq) Rel(link RelName, resp *ReposCreateWebhookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposCreateWebhookReqBodyConfig is a value for ReposCreateWebhookReqBody's Config field
type ReposCreateWebhookReqBodyConfig struct {

	/*
	   The media type used to serialize the payloads. Supported values include `json`
	   and `form`. The default is `form`.
	*/
	ContentType *string `json:"content_type,omitempty"`

	/*
	   Determines whether the SSL certificate of the host for `url` will be verified
	   when delivering payloads. Supported values include `0` (verification is
	   performed) and `1` (verification is not performed). The default is `0`. **We
	   strongly recommend not setting this to `1` as you are subject to
	   man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	   If provided, the `secret` will be used as the `key` to generate the HMAC hex
	   digest value in the
	   [`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	   header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
ReposCreateWebhookReqBody is a request body for repos/create-webhook

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
type ReposCreateWebhookReqBody struct {

	/*
	   Determines if notifications are sent when the webhook is triggered. Set to
	   `true` to send notifications.
	*/
	Active *bool `json:"active,omitempty"`

	/*
	   Key/value pairs to provide settings for this webhook. [These are defined
	   below](https://developer.github.com/v3/repos/hooks/#create-hook-config-params).
	*/
	Config *ReposCreateWebhookReqBodyConfig `json:"config"`

	/*
	   Determines what [events](https://developer.github.com/webhooks/event-payloads)
	   the hook is triggered for.
	*/
	Events []string `json:"events,omitempty"`

	/*
	   Use `web` to create a webhook. Default: `web`. This parameter only accepts the
	   value `web`.
	*/
	Name *string `json:"name,omitempty"`
}

/*
ReposCreateWebhookResponseBody is a response body for ReposCreateWebhook

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
type ReposCreateWebhookResponseBody components.Hook

/*
ReposCreateWebhookResponse is a response for ReposCreateWebhook

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
type ReposCreateWebhookResponse struct {
	response
	request *ReposCreateWebhookReq
	Data    ReposCreateWebhookResponseBody
}

/*
ReposDeclineInvitation performs requests for "repos/decline-invitation"

Decline a repository invitation.

  DELETE /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
func ReposDeclineInvitation(ctx context.Context, req *ReposDeclineInvitationReq, opt ...RequestOption) (*ReposDeclineInvitationResponse, error) {
	if req == nil {
		req = new(ReposDeclineInvitationReq)
	}
	resp := &ReposDeclineInvitationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeclineInvitation performs requests for "repos/decline-invitation"

Decline a repository invitation.

  DELETE /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
func (c Client) ReposDeclineInvitation(ctx context.Context, req *ReposDeclineInvitationReq, opt ...RequestOption) (*ReposDeclineInvitationResponse, error) {
	return ReposDeclineInvitation(ctx, req, append(c, opt...)...)
}

/*
ReposDeclineInvitationReq is request data for Client.ReposDeclineInvitation

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
type ReposDeclineInvitationReq struct {
	_url         string
	InvitationId int64
}

func (r *ReposDeclineInvitationReq) url() string {
	return r._url
}

func (r *ReposDeclineInvitationReq) urlPath() string {
	return fmt.Sprintf("/user/repository_invitations/%v", r.InvitationId)
}

func (r *ReposDeclineInvitationReq) method() string {
	return "DELETE"
}

func (r *ReposDeclineInvitationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeclineInvitationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeclineInvitationReq) body() interface{} {
	return nil
}

func (r *ReposDeclineInvitationReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeclineInvitationReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeclineInvitationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeclineInvitationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeclineInvitationReq) Rel(link RelName, resp *ReposDeclineInvitationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeclineInvitationResponse is a response for ReposDeclineInvitation

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
type ReposDeclineInvitationResponse struct {
	response
	request *ReposDeclineInvitationReq
}

/*
ReposDelete performs requests for "repos/delete"

Delete a repository.

  DELETE /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#delete-a-repository
*/
func ReposDelete(ctx context.Context, req *ReposDeleteReq, opt ...RequestOption) (*ReposDeleteResponse, error) {
	if req == nil {
		req = new(ReposDeleteReq)
	}
	resp := &ReposDeleteResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposDeleteResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDelete performs requests for "repos/delete"

Delete a repository.

  DELETE /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#delete-a-repository
*/
func (c Client) ReposDelete(ctx context.Context, req *ReposDeleteReq, opt ...RequestOption) (*ReposDeleteResponse, error) {
	return ReposDelete(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteReq is request data for Client.ReposDelete

https://developer.github.com/v3/repos/#delete-a-repository
*/
type ReposDeleteReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposDeleteReq) url() string {
	return r._url
}

func (r *ReposDeleteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo)
}

func (r *ReposDeleteReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteReq) body() interface{} {
	return nil
}

func (r *ReposDeleteReq) dataStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteReq) Rel(link RelName, resp *ReposDeleteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteResponseBody is a response body for ReposDelete

https://developer.github.com/v3/repos/#delete-a-repository
*/
type ReposDeleteResponseBody struct {
	DocumentationUrl string `json:"documentation_url,omitempty"`
	Message          string `json:"message,omitempty"`
}

/*
ReposDeleteResponse is a response for ReposDelete

https://developer.github.com/v3/repos/#delete-a-repository
*/
type ReposDeleteResponse struct {
	response
	request *ReposDeleteReq
	Data    ReposDeleteResponseBody
}

/*
ReposDeleteAccessRestrictions performs requests for "repos/delete-access-restrictions"

Delete access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#delete-access-restrictions
*/
func ReposDeleteAccessRestrictions(ctx context.Context, req *ReposDeleteAccessRestrictionsReq, opt ...RequestOption) (*ReposDeleteAccessRestrictionsResponse, error) {
	if req == nil {
		req = new(ReposDeleteAccessRestrictionsReq)
	}
	resp := &ReposDeleteAccessRestrictionsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteAccessRestrictions performs requests for "repos/delete-access-restrictions"

Delete access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#delete-access-restrictions
*/
func (c Client) ReposDeleteAccessRestrictions(ctx context.Context, req *ReposDeleteAccessRestrictionsReq, opt ...RequestOption) (*ReposDeleteAccessRestrictionsResponse, error) {
	return ReposDeleteAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteAccessRestrictionsReq is request data for Client.ReposDeleteAccessRestrictions

https://developer.github.com/v3/repos/branches/#delete-access-restrictions
*/
type ReposDeleteAccessRestrictionsReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposDeleteAccessRestrictionsReq) url() string {
	return r._url
}

func (r *ReposDeleteAccessRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions", r.Owner, r.Repo, r.Branch)
}

func (r *ReposDeleteAccessRestrictionsReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteAccessRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteAccessRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteAccessRestrictionsReq) body() interface{} {
	return nil
}

func (r *ReposDeleteAccessRestrictionsReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteAccessRestrictionsReq) validStatuses() []int {
	return []int{}
}

func (r *ReposDeleteAccessRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteAccessRestrictionsReq) Rel(link RelName, resp *ReposDeleteAccessRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteAccessRestrictionsResponse is a response for ReposDeleteAccessRestrictions

https://developer.github.com/v3/repos/branches/#delete-access-restrictions
*/
type ReposDeleteAccessRestrictionsResponse struct {
	response
	request *ReposDeleteAccessRestrictionsReq
}

/*
ReposDeleteAdminBranchProtection performs requests for "repos/delete-admin-branch-protection"

Delete admin branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#delete-admin-branch-protection
*/
func ReposDeleteAdminBranchProtection(ctx context.Context, req *ReposDeleteAdminBranchProtectionReq, opt ...RequestOption) (*ReposDeleteAdminBranchProtectionResponse, error) {
	if req == nil {
		req = new(ReposDeleteAdminBranchProtectionReq)
	}
	resp := &ReposDeleteAdminBranchProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteAdminBranchProtection performs requests for "repos/delete-admin-branch-protection"

Delete admin branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#delete-admin-branch-protection
*/
func (c Client) ReposDeleteAdminBranchProtection(ctx context.Context, req *ReposDeleteAdminBranchProtectionReq, opt ...RequestOption) (*ReposDeleteAdminBranchProtectionResponse, error) {
	return ReposDeleteAdminBranchProtection(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteAdminBranchProtectionReq is request data for Client.ReposDeleteAdminBranchProtection

https://developer.github.com/v3/repos/branches/#delete-admin-branch-protection
*/
type ReposDeleteAdminBranchProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposDeleteAdminBranchProtectionReq) url() string {
	return r._url
}

func (r *ReposDeleteAdminBranchProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch)
}

func (r *ReposDeleteAdminBranchProtectionReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteAdminBranchProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteAdminBranchProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteAdminBranchProtectionReq) body() interface{} {
	return nil
}

func (r *ReposDeleteAdminBranchProtectionReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteAdminBranchProtectionReq) validStatuses() []int {
	return []int{}
}

func (r *ReposDeleteAdminBranchProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteAdminBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteAdminBranchProtectionReq) Rel(link RelName, resp *ReposDeleteAdminBranchProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteAdminBranchProtectionResponse is a response for ReposDeleteAdminBranchProtection

https://developer.github.com/v3/repos/branches/#delete-admin-branch-protection
*/
type ReposDeleteAdminBranchProtectionResponse struct {
	response
	request *ReposDeleteAdminBranchProtectionReq
}

/*
ReposDeleteBranchProtection performs requests for "repos/delete-branch-protection"

Delete branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#delete-branch-protection
*/
func ReposDeleteBranchProtection(ctx context.Context, req *ReposDeleteBranchProtectionReq, opt ...RequestOption) (*ReposDeleteBranchProtectionResponse, error) {
	if req == nil {
		req = new(ReposDeleteBranchProtectionReq)
	}
	resp := &ReposDeleteBranchProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteBranchProtection performs requests for "repos/delete-branch-protection"

Delete branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#delete-branch-protection
*/
func (c Client) ReposDeleteBranchProtection(ctx context.Context, req *ReposDeleteBranchProtectionReq, opt ...RequestOption) (*ReposDeleteBranchProtectionResponse, error) {
	return ReposDeleteBranchProtection(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteBranchProtectionReq is request data for Client.ReposDeleteBranchProtection

https://developer.github.com/v3/repos/branches/#delete-branch-protection
*/
type ReposDeleteBranchProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposDeleteBranchProtectionReq) url() string {
	return r._url
}

func (r *ReposDeleteBranchProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch)
}

func (r *ReposDeleteBranchProtectionReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteBranchProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteBranchProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteBranchProtectionReq) body() interface{} {
	return nil
}

func (r *ReposDeleteBranchProtectionReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteBranchProtectionReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteBranchProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteBranchProtectionReq) Rel(link RelName, resp *ReposDeleteBranchProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteBranchProtectionResponse is a response for ReposDeleteBranchProtection

https://developer.github.com/v3/repos/branches/#delete-branch-protection
*/
type ReposDeleteBranchProtectionResponse struct {
	response
	request *ReposDeleteBranchProtectionReq
}

/*
ReposDeleteCommitComment performs requests for "repos/delete-commit-comment"

Delete a commit comment.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
func ReposDeleteCommitComment(ctx context.Context, req *ReposDeleteCommitCommentReq, opt ...RequestOption) (*ReposDeleteCommitCommentResponse, error) {
	if req == nil {
		req = new(ReposDeleteCommitCommentReq)
	}
	resp := &ReposDeleteCommitCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteCommitComment performs requests for "repos/delete-commit-comment"

Delete a commit comment.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
func (c Client) ReposDeleteCommitComment(ctx context.Context, req *ReposDeleteCommitCommentReq, opt ...RequestOption) (*ReposDeleteCommitCommentResponse, error) {
	return ReposDeleteCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteCommitCommentReq is request data for Client.ReposDeleteCommitComment

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
type ReposDeleteCommitCommentReq struct {
	_url      string
	Owner     string
	Repo      string
	CommentId int64
}

func (r *ReposDeleteCommitCommentReq) url() string {
	return r._url
}

func (r *ReposDeleteCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *ReposDeleteCommitCommentReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteCommitCommentReq) body() interface{} {
	return nil
}

func (r *ReposDeleteCommitCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteCommitCommentReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteCommitCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteCommitCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteCommitCommentReq) Rel(link RelName, resp *ReposDeleteCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteCommitCommentResponse is a response for ReposDeleteCommitComment

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
type ReposDeleteCommitCommentResponse struct {
	response
	request *ReposDeleteCommitCommentReq
}

/*
ReposDeleteCommitSignatureProtection performs requests for "repos/delete-commit-signature-protection"

Delete commit signature protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#delete-commit-signature-protection
*/
func ReposDeleteCommitSignatureProtection(ctx context.Context, req *ReposDeleteCommitSignatureProtectionReq, opt ...RequestOption) (*ReposDeleteCommitSignatureProtectionResponse, error) {
	if req == nil {
		req = new(ReposDeleteCommitSignatureProtectionReq)
	}
	resp := &ReposDeleteCommitSignatureProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteCommitSignatureProtection performs requests for "repos/delete-commit-signature-protection"

Delete commit signature protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#delete-commit-signature-protection
*/
func (c Client) ReposDeleteCommitSignatureProtection(ctx context.Context, req *ReposDeleteCommitSignatureProtectionReq, opt ...RequestOption) (*ReposDeleteCommitSignatureProtectionResponse, error) {
	return ReposDeleteCommitSignatureProtection(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteCommitSignatureProtectionReq is request data for Client.ReposDeleteCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#delete-commit-signature-protection
*/
type ReposDeleteCommitSignatureProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

func (r *ReposDeleteCommitSignatureProtectionReq) url() string {
	return r._url
}

func (r *ReposDeleteCommitSignatureProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch)
}

func (r *ReposDeleteCommitSignatureProtectionReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteCommitSignatureProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteCommitSignatureProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"zzzax": r.ZzzaxPreview}
	if requiredPreviews {
		previewVals["zzzax"] = true
	}
	if allPreviews {
		previewVals["zzzax"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteCommitSignatureProtectionReq) body() interface{} {
	return nil
}

func (r *ReposDeleteCommitSignatureProtectionReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteCommitSignatureProtectionReq) validStatuses() []int {
	return []int{}
}

func (r *ReposDeleteCommitSignatureProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteCommitSignatureProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteCommitSignatureProtectionReq) Rel(link RelName, resp *ReposDeleteCommitSignatureProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteCommitSignatureProtectionResponse is a response for ReposDeleteCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#delete-commit-signature-protection
*/
type ReposDeleteCommitSignatureProtectionResponse struct {
	response
	request *ReposDeleteCommitSignatureProtectionReq
}

/*
ReposDeleteDeployKey performs requests for "repos/delete-deploy-key"

Delete a deploy key.

  DELETE /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
*/
func ReposDeleteDeployKey(ctx context.Context, req *ReposDeleteDeployKeyReq, opt ...RequestOption) (*ReposDeleteDeployKeyResponse, error) {
	if req == nil {
		req = new(ReposDeleteDeployKeyReq)
	}
	resp := &ReposDeleteDeployKeyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteDeployKey performs requests for "repos/delete-deploy-key"

Delete a deploy key.

  DELETE /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
*/
func (c Client) ReposDeleteDeployKey(ctx context.Context, req *ReposDeleteDeployKeyReq, opt ...RequestOption) (*ReposDeleteDeployKeyResponse, error) {
	return ReposDeleteDeployKey(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteDeployKeyReq is request data for Client.ReposDeleteDeployKey

https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
*/
type ReposDeleteDeployKeyReq struct {
	_url  string
	Owner string
	Repo  string
	KeyId int64
}

func (r *ReposDeleteDeployKeyReq) url() string {
	return r._url
}

func (r *ReposDeleteDeployKeyReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/keys/%v", r.Owner, r.Repo, r.KeyId)
}

func (r *ReposDeleteDeployKeyReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteDeployKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteDeployKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteDeployKeyReq) body() interface{} {
	return nil
}

func (r *ReposDeleteDeployKeyReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteDeployKeyReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteDeployKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteDeployKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteDeployKeyReq) Rel(link RelName, resp *ReposDeleteDeployKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteDeployKeyResponse is a response for ReposDeleteDeployKey

https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
*/
type ReposDeleteDeployKeyResponse struct {
	response
	request *ReposDeleteDeployKeyReq
}

/*
ReposDeleteDeployment performs requests for "repos/delete-deployment"

Delete a deployment.

  DELETE /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
func ReposDeleteDeployment(ctx context.Context, req *ReposDeleteDeploymentReq, opt ...RequestOption) (*ReposDeleteDeploymentResponse, error) {
	if req == nil {
		req = new(ReposDeleteDeploymentReq)
	}
	resp := &ReposDeleteDeploymentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteDeployment performs requests for "repos/delete-deployment"

Delete a deployment.

  DELETE /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
func (c Client) ReposDeleteDeployment(ctx context.Context, req *ReposDeleteDeploymentReq, opt ...RequestOption) (*ReposDeleteDeploymentResponse, error) {
	return ReposDeleteDeployment(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteDeploymentReq is request data for Client.ReposDeleteDeployment

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
type ReposDeleteDeploymentReq struct {
	_url         string
	Owner        string
	Repo         string
	DeploymentId int64
}

func (r *ReposDeleteDeploymentReq) url() string {
	return r._url
}

func (r *ReposDeleteDeploymentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v", r.Owner, r.Repo, r.DeploymentId)
}

func (r *ReposDeleteDeploymentReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteDeploymentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteDeploymentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteDeploymentReq) body() interface{} {
	return nil
}

func (r *ReposDeleteDeploymentReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteDeploymentReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteDeploymentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteDeploymentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteDeploymentReq) Rel(link RelName, resp *ReposDeleteDeploymentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteDeploymentResponse is a response for ReposDeleteDeployment

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
type ReposDeleteDeploymentResponse struct {
	response
	request *ReposDeleteDeploymentReq
}

/*
ReposDeleteFile performs requests for "repos/delete-file"

Delete a file.

  DELETE /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
func ReposDeleteFile(ctx context.Context, req *ReposDeleteFileReq, opt ...RequestOption) (*ReposDeleteFileResponse, error) {
	if req == nil {
		req = new(ReposDeleteFileReq)
	}
	resp := &ReposDeleteFileResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposDeleteFileResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteFile performs requests for "repos/delete-file"

Delete a file.

  DELETE /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
func (c Client) ReposDeleteFile(ctx context.Context, req *ReposDeleteFileReq, opt ...RequestOption) (*ReposDeleteFileResponse, error) {
	return ReposDeleteFile(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteFileReq is request data for Client.ReposDeleteFile

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileReq struct {
	_url        string
	Owner       string
	Repo        string
	Path        string
	RequestBody ReposDeleteFileReqBody
}

func (r *ReposDeleteFileReq) url() string {
	return r._url
}

func (r *ReposDeleteFileReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path)
}

func (r *ReposDeleteFileReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteFileReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteFileReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteFileReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposDeleteFileReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposDeleteFileReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposDeleteFileReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteFileReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteFileReq) Rel(link RelName, resp *ReposDeleteFileResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposDeleteFileReqBodyAuthor is a value for ReposDeleteFileReqBody's Author field
type ReposDeleteFileReqBodyAuthor struct {

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

// ReposDeleteFileReqBodyCommitter is a value for ReposDeleteFileReqBody's Committer field
type ReposDeleteFileReqBodyCommitter struct {

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

/*
ReposDeleteFileReqBody is a request body for repos/delete-file

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileReqBody struct {

	// object containing information about the author.
	Author *ReposDeleteFileReqBodyAuthor `json:"author,omitempty"`

	// The branch name. Default: the repositorys default branch (usually `master`)
	Branch *string `json:"branch,omitempty"`

	// object containing information about the committer.
	Committer *ReposDeleteFileReqBodyCommitter `json:"committer,omitempty"`

	// The commit message.
	Message *string `json:"message"`

	// The blob SHA of the file being replaced.
	Sha *string `json:"sha"`
}

/*
ReposDeleteFileResponseBody is a response body for ReposDeleteFile

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileResponseBody components.FileCommit2

/*
ReposDeleteFileResponse is a response for ReposDeleteFile

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type ReposDeleteFileResponse struct {
	response
	request *ReposDeleteFileReq
	Data    ReposDeleteFileResponseBody
}

/*
ReposDeleteInvitation performs requests for "repos/delete-invitation"

Delete a repository invitation.

  DELETE /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
func ReposDeleteInvitation(ctx context.Context, req *ReposDeleteInvitationReq, opt ...RequestOption) (*ReposDeleteInvitationResponse, error) {
	if req == nil {
		req = new(ReposDeleteInvitationReq)
	}
	resp := &ReposDeleteInvitationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteInvitation performs requests for "repos/delete-invitation"

Delete a repository invitation.

  DELETE /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
func (c Client) ReposDeleteInvitation(ctx context.Context, req *ReposDeleteInvitationReq, opt ...RequestOption) (*ReposDeleteInvitationResponse, error) {
	return ReposDeleteInvitation(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteInvitationReq is request data for Client.ReposDeleteInvitation

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
type ReposDeleteInvitationReq struct {
	_url         string
	Owner        string
	Repo         string
	InvitationId int64
}

func (r *ReposDeleteInvitationReq) url() string {
	return r._url
}

func (r *ReposDeleteInvitationReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/invitations/%v", r.Owner, r.Repo, r.InvitationId)
}

func (r *ReposDeleteInvitationReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteInvitationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteInvitationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteInvitationReq) body() interface{} {
	return nil
}

func (r *ReposDeleteInvitationReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteInvitationReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteInvitationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteInvitationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteInvitationReq) Rel(link RelName, resp *ReposDeleteInvitationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteInvitationResponse is a response for ReposDeleteInvitation

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
type ReposDeleteInvitationResponse struct {
	response
	request *ReposDeleteInvitationReq
}

/*
ReposDeletePagesSite performs requests for "repos/delete-pages-site"

Delete a GitHub Pages site.

  DELETE /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#delete-a-github-pages-site
*/
func ReposDeletePagesSite(ctx context.Context, req *ReposDeletePagesSiteReq, opt ...RequestOption) (*ReposDeletePagesSiteResponse, error) {
	if req == nil {
		req = new(ReposDeletePagesSiteReq)
	}
	resp := &ReposDeletePagesSiteResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeletePagesSite performs requests for "repos/delete-pages-site"

Delete a GitHub Pages site.

  DELETE /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#delete-a-github-pages-site
*/
func (c Client) ReposDeletePagesSite(ctx context.Context, req *ReposDeletePagesSiteReq, opt ...RequestOption) (*ReposDeletePagesSiteResponse, error) {
	return ReposDeletePagesSite(ctx, req, append(c, opt...)...)
}

/*
ReposDeletePagesSiteReq is request data for Client.ReposDeletePagesSite

https://developer.github.com/v3/repos/pages/#delete-a-github-pages-site
*/
type ReposDeletePagesSiteReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling Pages in the Pages API is currently available for
	developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-03-14-enabling-disabling-pages/)
	preview for more details. To access the new endpoints during the preview period,
	you must set this to true.
	*/
	SwitcherooPreview bool
}

func (r *ReposDeletePagesSiteReq) url() string {
	return r._url
}

func (r *ReposDeletePagesSiteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo)
}

func (r *ReposDeletePagesSiteReq) method() string {
	return "DELETE"
}

func (r *ReposDeletePagesSiteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeletePagesSiteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"switcheroo": r.SwitcherooPreview}
	if requiredPreviews {
		previewVals["switcheroo"] = true
	}
	if allPreviews {
		previewVals["switcheroo"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeletePagesSiteReq) body() interface{} {
	return nil
}

func (r *ReposDeletePagesSiteReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeletePagesSiteReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeletePagesSiteReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeletePagesSiteReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeletePagesSiteReq) Rel(link RelName, resp *ReposDeletePagesSiteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeletePagesSiteResponse is a response for ReposDeletePagesSite

https://developer.github.com/v3/repos/pages/#delete-a-github-pages-site
*/
type ReposDeletePagesSiteResponse struct {
	response
	request *ReposDeletePagesSiteReq
}

/*
ReposDeletePullRequestReviewProtection performs requests for "repos/delete-pull-request-review-protection"

Delete pull request review protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#delete-pull-request-review-protection
*/
func ReposDeletePullRequestReviewProtection(ctx context.Context, req *ReposDeletePullRequestReviewProtectionReq, opt ...RequestOption) (*ReposDeletePullRequestReviewProtectionResponse, error) {
	if req == nil {
		req = new(ReposDeletePullRequestReviewProtectionReq)
	}
	resp := &ReposDeletePullRequestReviewProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeletePullRequestReviewProtection performs requests for "repos/delete-pull-request-review-protection"

Delete pull request review protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#delete-pull-request-review-protection
*/
func (c Client) ReposDeletePullRequestReviewProtection(ctx context.Context, req *ReposDeletePullRequestReviewProtectionReq, opt ...RequestOption) (*ReposDeletePullRequestReviewProtectionResponse, error) {
	return ReposDeletePullRequestReviewProtection(ctx, req, append(c, opt...)...)
}

/*
ReposDeletePullRequestReviewProtectionReq is request data for Client.ReposDeletePullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#delete-pull-request-review-protection
*/
type ReposDeletePullRequestReviewProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposDeletePullRequestReviewProtectionReq) url() string {
	return r._url
}

func (r *ReposDeletePullRequestReviewProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch)
}

func (r *ReposDeletePullRequestReviewProtectionReq) method() string {
	return "DELETE"
}

func (r *ReposDeletePullRequestReviewProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeletePullRequestReviewProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeletePullRequestReviewProtectionReq) body() interface{} {
	return nil
}

func (r *ReposDeletePullRequestReviewProtectionReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeletePullRequestReviewProtectionReq) validStatuses() []int {
	return []int{}
}

func (r *ReposDeletePullRequestReviewProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeletePullRequestReviewProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeletePullRequestReviewProtectionReq) Rel(link RelName, resp *ReposDeletePullRequestReviewProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeletePullRequestReviewProtectionResponse is a response for ReposDeletePullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#delete-pull-request-review-protection
*/
type ReposDeletePullRequestReviewProtectionResponse struct {
	response
	request *ReposDeletePullRequestReviewProtectionReq
}

/*
ReposDeleteRelease performs requests for "repos/delete-release"

Delete a release.

  DELETE /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
func ReposDeleteRelease(ctx context.Context, req *ReposDeleteReleaseReq, opt ...RequestOption) (*ReposDeleteReleaseResponse, error) {
	if req == nil {
		req = new(ReposDeleteReleaseReq)
	}
	resp := &ReposDeleteReleaseResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteRelease performs requests for "repos/delete-release"

Delete a release.

  DELETE /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
func (c Client) ReposDeleteRelease(ctx context.Context, req *ReposDeleteReleaseReq, opt ...RequestOption) (*ReposDeleteReleaseResponse, error) {
	return ReposDeleteRelease(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteReleaseReq is request data for Client.ReposDeleteRelease

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
type ReposDeleteReleaseReq struct {
	_url      string
	Owner     string
	Repo      string
	ReleaseId int64
}

func (r *ReposDeleteReleaseReq) url() string {
	return r._url
}

func (r *ReposDeleteReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposDeleteReleaseReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteReleaseReq) body() interface{} {
	return nil
}

func (r *ReposDeleteReleaseReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteReleaseReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteReleaseReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteReleaseReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteReleaseReq) Rel(link RelName, resp *ReposDeleteReleaseResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteReleaseResponse is a response for ReposDeleteRelease

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
type ReposDeleteReleaseResponse struct {
	response
	request *ReposDeleteReleaseReq
}

/*
ReposDeleteReleaseAsset performs requests for "repos/delete-release-asset"

Delete a release asset.

  DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
func ReposDeleteReleaseAsset(ctx context.Context, req *ReposDeleteReleaseAssetReq, opt ...RequestOption) (*ReposDeleteReleaseAssetResponse, error) {
	if req == nil {
		req = new(ReposDeleteReleaseAssetReq)
	}
	resp := &ReposDeleteReleaseAssetResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteReleaseAsset performs requests for "repos/delete-release-asset"

Delete a release asset.

  DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
func (c Client) ReposDeleteReleaseAsset(ctx context.Context, req *ReposDeleteReleaseAssetReq, opt ...RequestOption) (*ReposDeleteReleaseAssetResponse, error) {
	return ReposDeleteReleaseAsset(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteReleaseAssetReq is request data for Client.ReposDeleteReleaseAsset

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
type ReposDeleteReleaseAssetReq struct {
	_url    string
	Owner   string
	Repo    string
	AssetId int64
}

func (r *ReposDeleteReleaseAssetReq) url() string {
	return r._url
}

func (r *ReposDeleteReleaseAssetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId)
}

func (r *ReposDeleteReleaseAssetReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteReleaseAssetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteReleaseAssetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteReleaseAssetReq) body() interface{} {
	return nil
}

func (r *ReposDeleteReleaseAssetReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteReleaseAssetReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteReleaseAssetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteReleaseAssetReq) Rel(link RelName, resp *ReposDeleteReleaseAssetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteReleaseAssetResponse is a response for ReposDeleteReleaseAsset

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
type ReposDeleteReleaseAssetResponse struct {
	response
	request *ReposDeleteReleaseAssetReq
}

/*
ReposDeleteWebhook performs requests for "repos/delete-webhook"

Delete a repository webhook.

  DELETE /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#delete-a-repository-webhook
*/
func ReposDeleteWebhook(ctx context.Context, req *ReposDeleteWebhookReq, opt ...RequestOption) (*ReposDeleteWebhookResponse, error) {
	if req == nil {
		req = new(ReposDeleteWebhookReq)
	}
	resp := &ReposDeleteWebhookResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDeleteWebhook performs requests for "repos/delete-webhook"

Delete a repository webhook.

  DELETE /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#delete-a-repository-webhook
*/
func (c Client) ReposDeleteWebhook(ctx context.Context, req *ReposDeleteWebhookReq, opt ...RequestOption) (*ReposDeleteWebhookResponse, error) {
	return ReposDeleteWebhook(ctx, req, append(c, opt...)...)
}

/*
ReposDeleteWebhookReq is request data for Client.ReposDeleteWebhook

https://developer.github.com/v3/repos/hooks/#delete-a-repository-webhook
*/
type ReposDeleteWebhookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

func (r *ReposDeleteWebhookReq) url() string {
	return r._url
}

func (r *ReposDeleteWebhookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId)
}

func (r *ReposDeleteWebhookReq) method() string {
	return "DELETE"
}

func (r *ReposDeleteWebhookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDeleteWebhookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDeleteWebhookReq) body() interface{} {
	return nil
}

func (r *ReposDeleteWebhookReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDeleteWebhookReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDeleteWebhookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDeleteWebhookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDeleteWebhookReq) Rel(link RelName, resp *ReposDeleteWebhookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDeleteWebhookResponse is a response for ReposDeleteWebhook

https://developer.github.com/v3/repos/hooks/#delete-a-repository-webhook
*/
type ReposDeleteWebhookResponse struct {
	response
	request *ReposDeleteWebhookReq
}

/*
ReposDisableAutomatedSecurityFixes performs requests for "repos/disable-automated-security-fixes"

Disable automated security fixes.

  DELETE /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
func ReposDisableAutomatedSecurityFixes(ctx context.Context, req *ReposDisableAutomatedSecurityFixesReq, opt ...RequestOption) (*ReposDisableAutomatedSecurityFixesResponse, error) {
	if req == nil {
		req = new(ReposDisableAutomatedSecurityFixesReq)
	}
	resp := &ReposDisableAutomatedSecurityFixesResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDisableAutomatedSecurityFixes performs requests for "repos/disable-automated-security-fixes"

Disable automated security fixes.

  DELETE /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
func (c Client) ReposDisableAutomatedSecurityFixes(ctx context.Context, req *ReposDisableAutomatedSecurityFixesReq, opt ...RequestOption) (*ReposDisableAutomatedSecurityFixesResponse, error) {
	return ReposDisableAutomatedSecurityFixes(ctx, req, append(c, opt...)...)
}

/*
ReposDisableAutomatedSecurityFixesReq is request data for Client.ReposDisableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
type ReposDisableAutomatedSecurityFixesReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling or disabling automated security fixes is currently available for
	developers to preview. To access this new endpoint during the preview period,
	you must set this to true.
	*/
	LondonPreview bool
}

func (r *ReposDisableAutomatedSecurityFixesReq) url() string {
	return r._url
}

func (r *ReposDisableAutomatedSecurityFixesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/automated-security-fixes", r.Owner, r.Repo)
}

func (r *ReposDisableAutomatedSecurityFixesReq) method() string {
	return "DELETE"
}

func (r *ReposDisableAutomatedSecurityFixesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDisableAutomatedSecurityFixesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"london": r.LondonPreview}
	if requiredPreviews {
		previewVals["london"] = true
	}
	if allPreviews {
		previewVals["london"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDisableAutomatedSecurityFixesReq) body() interface{} {
	return nil
}

func (r *ReposDisableAutomatedSecurityFixesReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDisableAutomatedSecurityFixesReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDisableAutomatedSecurityFixesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDisableAutomatedSecurityFixesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDisableAutomatedSecurityFixesReq) Rel(link RelName, resp *ReposDisableAutomatedSecurityFixesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDisableAutomatedSecurityFixesResponse is a response for ReposDisableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
type ReposDisableAutomatedSecurityFixesResponse struct {
	response
	request *ReposDisableAutomatedSecurityFixesReq
}

/*
ReposDisableVulnerabilityAlerts performs requests for "repos/disable-vulnerability-alerts"

Disable vulnerability alerts.

  DELETE /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
func ReposDisableVulnerabilityAlerts(ctx context.Context, req *ReposDisableVulnerabilityAlertsReq, opt ...RequestOption) (*ReposDisableVulnerabilityAlertsResponse, error) {
	if req == nil {
		req = new(ReposDisableVulnerabilityAlertsReq)
	}
	resp := &ReposDisableVulnerabilityAlertsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDisableVulnerabilityAlerts performs requests for "repos/disable-vulnerability-alerts"

Disable vulnerability alerts.

  DELETE /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
func (c Client) ReposDisableVulnerabilityAlerts(ctx context.Context, req *ReposDisableVulnerabilityAlertsReq, opt ...RequestOption) (*ReposDisableVulnerabilityAlertsResponse, error) {
	return ReposDisableVulnerabilityAlerts(ctx, req, append(c, opt...)...)
}

/*
ReposDisableVulnerabilityAlertsReq is request data for Client.ReposDisableVulnerabilityAlerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
type ReposDisableVulnerabilityAlertsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling dependency alerts for a repository using the REST API is
	currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

func (r *ReposDisableVulnerabilityAlertsReq) url() string {
	return r._url
}

func (r *ReposDisableVulnerabilityAlertsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo)
}

func (r *ReposDisableVulnerabilityAlertsReq) method() string {
	return "DELETE"
}

func (r *ReposDisableVulnerabilityAlertsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDisableVulnerabilityAlertsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"dorian": r.DorianPreview}
	if requiredPreviews {
		previewVals["dorian"] = true
	}
	if allPreviews {
		previewVals["dorian"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDisableVulnerabilityAlertsReq) body() interface{} {
	return nil
}

func (r *ReposDisableVulnerabilityAlertsReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDisableVulnerabilityAlertsReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposDisableVulnerabilityAlertsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposDisableVulnerabilityAlertsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDisableVulnerabilityAlertsReq) Rel(link RelName, resp *ReposDisableVulnerabilityAlertsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDisableVulnerabilityAlertsResponse is a response for ReposDisableVulnerabilityAlerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
type ReposDisableVulnerabilityAlertsResponse struct {
	response
	request *ReposDisableVulnerabilityAlertsReq
}

/*
ReposDownloadArchive performs requests for "repos/download-archive"

Download a repository archive.

  GET /repos/{owner}/{repo}/{archive_format}/{ref}

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
func ReposDownloadArchive(ctx context.Context, req *ReposDownloadArchiveReq, opt ...RequestOption) (*ReposDownloadArchiveResponse, error) {
	if req == nil {
		req = new(ReposDownloadArchiveReq)
	}
	resp := &ReposDownloadArchiveResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposDownloadArchive performs requests for "repos/download-archive"

Download a repository archive.

  GET /repos/{owner}/{repo}/{archive_format}/{ref}

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
func (c Client) ReposDownloadArchive(ctx context.Context, req *ReposDownloadArchiveReq, opt ...RequestOption) (*ReposDownloadArchiveResponse, error) {
	return ReposDownloadArchive(ctx, req, append(c, opt...)...)
}

/*
ReposDownloadArchiveReq is request data for Client.ReposDownloadArchive

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
type ReposDownloadArchiveReq struct {
	_url          string
	Owner         string
	Repo          string
	ArchiveFormat string
	Ref           string
}

func (r *ReposDownloadArchiveReq) url() string {
	return r._url
}

func (r *ReposDownloadArchiveReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/%v/%v", r.Owner, r.Repo, r.ArchiveFormat, r.Ref)
}

func (r *ReposDownloadArchiveReq) method() string {
	return "GET"
}

func (r *ReposDownloadArchiveReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposDownloadArchiveReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposDownloadArchiveReq) body() interface{} {
	return nil
}

func (r *ReposDownloadArchiveReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposDownloadArchiveReq) validStatuses() []int {
	return []int{302}
}

func (r *ReposDownloadArchiveReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrRedirectOnly}
}

// HTTPRequest builds an *http.Request
func (r *ReposDownloadArchiveReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposDownloadArchiveReq) Rel(link RelName, resp *ReposDownloadArchiveResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposDownloadArchiveResponse is a response for ReposDownloadArchive

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
type ReposDownloadArchiveResponse struct {
	response
	request *ReposDownloadArchiveReq
}

/*
ReposEnableAutomatedSecurityFixes performs requests for "repos/enable-automated-security-fixes"

Enable automated security fixes.

  PUT /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
func ReposEnableAutomatedSecurityFixes(ctx context.Context, req *ReposEnableAutomatedSecurityFixesReq, opt ...RequestOption) (*ReposEnableAutomatedSecurityFixesResponse, error) {
	if req == nil {
		req = new(ReposEnableAutomatedSecurityFixesReq)
	}
	resp := &ReposEnableAutomatedSecurityFixesResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposEnableAutomatedSecurityFixes performs requests for "repos/enable-automated-security-fixes"

Enable automated security fixes.

  PUT /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
func (c Client) ReposEnableAutomatedSecurityFixes(ctx context.Context, req *ReposEnableAutomatedSecurityFixesReq, opt ...RequestOption) (*ReposEnableAutomatedSecurityFixesResponse, error) {
	return ReposEnableAutomatedSecurityFixes(ctx, req, append(c, opt...)...)
}

/*
ReposEnableAutomatedSecurityFixesReq is request data for Client.ReposEnableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
type ReposEnableAutomatedSecurityFixesReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling or disabling automated security fixes is currently available for
	developers to preview. To access this new endpoint during the preview period,
	you must set this to true.
	*/
	LondonPreview bool
}

func (r *ReposEnableAutomatedSecurityFixesReq) url() string {
	return r._url
}

func (r *ReposEnableAutomatedSecurityFixesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/automated-security-fixes", r.Owner, r.Repo)
}

func (r *ReposEnableAutomatedSecurityFixesReq) method() string {
	return "PUT"
}

func (r *ReposEnableAutomatedSecurityFixesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposEnableAutomatedSecurityFixesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"london": r.LondonPreview}
	if requiredPreviews {
		previewVals["london"] = true
	}
	if allPreviews {
		previewVals["london"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposEnableAutomatedSecurityFixesReq) body() interface{} {
	return nil
}

func (r *ReposEnableAutomatedSecurityFixesReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposEnableAutomatedSecurityFixesReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposEnableAutomatedSecurityFixesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposEnableAutomatedSecurityFixesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposEnableAutomatedSecurityFixesReq) Rel(link RelName, resp *ReposEnableAutomatedSecurityFixesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposEnableAutomatedSecurityFixesResponse is a response for ReposEnableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
type ReposEnableAutomatedSecurityFixesResponse struct {
	response
	request *ReposEnableAutomatedSecurityFixesReq
}

/*
ReposEnableVulnerabilityAlerts performs requests for "repos/enable-vulnerability-alerts"

Enable vulnerability alerts.

  PUT /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
func ReposEnableVulnerabilityAlerts(ctx context.Context, req *ReposEnableVulnerabilityAlertsReq, opt ...RequestOption) (*ReposEnableVulnerabilityAlertsResponse, error) {
	if req == nil {
		req = new(ReposEnableVulnerabilityAlertsReq)
	}
	resp := &ReposEnableVulnerabilityAlertsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposEnableVulnerabilityAlerts performs requests for "repos/enable-vulnerability-alerts"

Enable vulnerability alerts.

  PUT /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
func (c Client) ReposEnableVulnerabilityAlerts(ctx context.Context, req *ReposEnableVulnerabilityAlertsReq, opt ...RequestOption) (*ReposEnableVulnerabilityAlertsResponse, error) {
	return ReposEnableVulnerabilityAlerts(ctx, req, append(c, opt...)...)
}

/*
ReposEnableVulnerabilityAlertsReq is request data for Client.ReposEnableVulnerabilityAlerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
type ReposEnableVulnerabilityAlertsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling dependency alerts for a repository using the REST API is
	currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

func (r *ReposEnableVulnerabilityAlertsReq) url() string {
	return r._url
}

func (r *ReposEnableVulnerabilityAlertsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo)
}

func (r *ReposEnableVulnerabilityAlertsReq) method() string {
	return "PUT"
}

func (r *ReposEnableVulnerabilityAlertsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposEnableVulnerabilityAlertsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"dorian": r.DorianPreview}
	if requiredPreviews {
		previewVals["dorian"] = true
	}
	if allPreviews {
		previewVals["dorian"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposEnableVulnerabilityAlertsReq) body() interface{} {
	return nil
}

func (r *ReposEnableVulnerabilityAlertsReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposEnableVulnerabilityAlertsReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposEnableVulnerabilityAlertsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposEnableVulnerabilityAlertsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposEnableVulnerabilityAlertsReq) Rel(link RelName, resp *ReposEnableVulnerabilityAlertsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposEnableVulnerabilityAlertsResponse is a response for ReposEnableVulnerabilityAlerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
type ReposEnableVulnerabilityAlertsResponse struct {
	response
	request *ReposEnableVulnerabilityAlertsReq
}

/*
ReposGet performs requests for "repos/get"

Get a repository.

  GET /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#get-a-repository
*/
func ReposGet(ctx context.Context, req *ReposGetReq, opt ...RequestOption) (*ReposGetResponse, error) {
	if req == nil {
		req = new(ReposGetReq)
	}
	resp := &ReposGetResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGet performs requests for "repos/get"

Get a repository.

  GET /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#get-a-repository
*/
func (c Client) ReposGet(ctx context.Context, req *ReposGetReq, opt ...RequestOption) (*ReposGetResponse, error) {
	return ReposGet(ctx, req, append(c, opt...)...)
}

/*
ReposGetReq is request data for Client.ReposGet

https://developer.github.com/v3/repos/#get-a-repository
*/
type ReposGetReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The Codes of Conduct API is currently available for developers to preview.

	To access the API during the preview period, you must set this to true.
	*/
	ScarletWitchPreview bool
}

func (r *ReposGetReq) url() string {
	return r._url
}

func (r *ReposGetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo)
}

func (r *ReposGetReq) method() string {
	return "GET"
}

func (r *ReposGetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"nebula":        r.NebulaPreview,
		"scarlet-witch": r.ScarletWitchPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["scarlet-witch"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReq) body() interface{} {
	return nil
}

func (r *ReposGetReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReq) Rel(link RelName, resp *ReposGetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetResponseBody is a response body for ReposGet

https://developer.github.com/v3/repos/#get-a-repository
*/
type ReposGetResponseBody components.FullRepository

/*
ReposGetResponse is a response for ReposGet

https://developer.github.com/v3/repos/#get-a-repository
*/
type ReposGetResponse struct {
	response
	request *ReposGetReq
	Data    ReposGetResponseBody
}

/*
ReposGetAccessRestrictions performs requests for "repos/get-access-restrictions"

Get access restrictions.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#get-access-restrictions
*/
func ReposGetAccessRestrictions(ctx context.Context, req *ReposGetAccessRestrictionsReq, opt ...RequestOption) (*ReposGetAccessRestrictionsResponse, error) {
	if req == nil {
		req = new(ReposGetAccessRestrictionsReq)
	}
	resp := &ReposGetAccessRestrictionsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetAccessRestrictionsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetAccessRestrictions performs requests for "repos/get-access-restrictions"

Get access restrictions.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#get-access-restrictions
*/
func (c Client) ReposGetAccessRestrictions(ctx context.Context, req *ReposGetAccessRestrictionsReq, opt ...RequestOption) (*ReposGetAccessRestrictionsResponse, error) {
	return ReposGetAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposGetAccessRestrictionsReq is request data for Client.ReposGetAccessRestrictions

https://developer.github.com/v3/repos/branches/#get-access-restrictions
*/
type ReposGetAccessRestrictionsReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetAccessRestrictionsReq) url() string {
	return r._url
}

func (r *ReposGetAccessRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetAccessRestrictionsReq) method() string {
	return "GET"
}

func (r *ReposGetAccessRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetAccessRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetAccessRestrictionsReq) body() interface{} {
	return nil
}

func (r *ReposGetAccessRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetAccessRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetAccessRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetAccessRestrictionsReq) Rel(link RelName, resp *ReposGetAccessRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetAccessRestrictionsResponseBody is a response body for ReposGetAccessRestrictions

https://developer.github.com/v3/repos/branches/#get-access-restrictions
*/
type ReposGetAccessRestrictionsResponseBody components.BranchRestrictionPolicy

/*
ReposGetAccessRestrictionsResponse is a response for ReposGetAccessRestrictions

https://developer.github.com/v3/repos/branches/#get-access-restrictions
*/
type ReposGetAccessRestrictionsResponse struct {
	response
	request *ReposGetAccessRestrictionsReq
	Data    ReposGetAccessRestrictionsResponseBody
}

/*
ReposGetAdminBranchProtection performs requests for "repos/get-admin-branch-protection"

Get admin branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#get-admin-branch-protection
*/
func ReposGetAdminBranchProtection(ctx context.Context, req *ReposGetAdminBranchProtectionReq, opt ...RequestOption) (*ReposGetAdminBranchProtectionResponse, error) {
	if req == nil {
		req = new(ReposGetAdminBranchProtectionReq)
	}
	resp := &ReposGetAdminBranchProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetAdminBranchProtectionResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetAdminBranchProtection performs requests for "repos/get-admin-branch-protection"

Get admin branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#get-admin-branch-protection
*/
func (c Client) ReposGetAdminBranchProtection(ctx context.Context, req *ReposGetAdminBranchProtectionReq, opt ...RequestOption) (*ReposGetAdminBranchProtectionResponse, error) {
	return ReposGetAdminBranchProtection(ctx, req, append(c, opt...)...)
}

/*
ReposGetAdminBranchProtectionReq is request data for Client.ReposGetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#get-admin-branch-protection
*/
type ReposGetAdminBranchProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetAdminBranchProtectionReq) url() string {
	return r._url
}

func (r *ReposGetAdminBranchProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetAdminBranchProtectionReq) method() string {
	return "GET"
}

func (r *ReposGetAdminBranchProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetAdminBranchProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetAdminBranchProtectionReq) body() interface{} {
	return nil
}

func (r *ReposGetAdminBranchProtectionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetAdminBranchProtectionReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetAdminBranchProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetAdminBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetAdminBranchProtectionReq) Rel(link RelName, resp *ReposGetAdminBranchProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetAdminBranchProtectionResponseBody is a response body for ReposGetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#get-admin-branch-protection
*/
type ReposGetAdminBranchProtectionResponseBody components.ProtectedBranchAdminEnforced

/*
ReposGetAdminBranchProtectionResponse is a response for ReposGetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#get-admin-branch-protection
*/
type ReposGetAdminBranchProtectionResponse struct {
	response
	request *ReposGetAdminBranchProtectionReq
	Data    ReposGetAdminBranchProtectionResponseBody
}

/*
ReposGetAllStatusCheckContexts performs requests for "repos/get-all-status-check-contexts"

Get all status check contexts.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
func ReposGetAllStatusCheckContexts(ctx context.Context, req *ReposGetAllStatusCheckContextsReq, opt ...RequestOption) (*ReposGetAllStatusCheckContextsResponse, error) {
	if req == nil {
		req = new(ReposGetAllStatusCheckContextsReq)
	}
	resp := &ReposGetAllStatusCheckContextsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetAllStatusCheckContextsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetAllStatusCheckContexts performs requests for "repos/get-all-status-check-contexts"

Get all status check contexts.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
func (c Client) ReposGetAllStatusCheckContexts(ctx context.Context, req *ReposGetAllStatusCheckContextsReq, opt ...RequestOption) (*ReposGetAllStatusCheckContextsResponse, error) {
	return ReposGetAllStatusCheckContexts(ctx, req, append(c, opt...)...)
}

/*
ReposGetAllStatusCheckContextsReq is request data for Client.ReposGetAllStatusCheckContexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
type ReposGetAllStatusCheckContextsReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetAllStatusCheckContextsReq) url() string {
	return r._url
}

func (r *ReposGetAllStatusCheckContextsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetAllStatusCheckContextsReq) method() string {
	return "GET"
}

func (r *ReposGetAllStatusCheckContextsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetAllStatusCheckContextsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetAllStatusCheckContextsReq) body() interface{} {
	return nil
}

func (r *ReposGetAllStatusCheckContextsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetAllStatusCheckContextsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetAllStatusCheckContextsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetAllStatusCheckContextsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetAllStatusCheckContextsReq) Rel(link RelName, resp *ReposGetAllStatusCheckContextsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetAllStatusCheckContextsResponseBody is a response body for ReposGetAllStatusCheckContexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
type ReposGetAllStatusCheckContextsResponseBody []string

/*
ReposGetAllStatusCheckContextsResponse is a response for ReposGetAllStatusCheckContexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
type ReposGetAllStatusCheckContextsResponse struct {
	response
	request *ReposGetAllStatusCheckContextsReq
	Data    ReposGetAllStatusCheckContextsResponseBody
}

/*
ReposGetAllTopics performs requests for "repos/get-all-topics"

Get all repository topics.

  GET /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
func ReposGetAllTopics(ctx context.Context, req *ReposGetAllTopicsReq, opt ...RequestOption) (*ReposGetAllTopicsResponse, error) {
	if req == nil {
		req = new(ReposGetAllTopicsReq)
	}
	resp := &ReposGetAllTopicsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetAllTopicsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetAllTopics performs requests for "repos/get-all-topics"

Get all repository topics.

  GET /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
func (c Client) ReposGetAllTopics(ctx context.Context, req *ReposGetAllTopicsReq, opt ...RequestOption) (*ReposGetAllTopicsResponse, error) {
	return ReposGetAllTopics(ctx, req, append(c, opt...)...)
}

/*
ReposGetAllTopicsReq is request data for Client.ReposGetAllTopics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
type ReposGetAllTopicsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

func (r *ReposGetAllTopicsReq) url() string {
	return r._url
}

func (r *ReposGetAllTopicsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/topics", r.Owner, r.Repo)
}

func (r *ReposGetAllTopicsReq) method() string {
	return "GET"
}

func (r *ReposGetAllTopicsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetAllTopicsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"mercy": r.MercyPreview}
	if requiredPreviews {
		previewVals["mercy"] = true
	}
	if allPreviews {
		previewVals["mercy"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetAllTopicsReq) body() interface{} {
	return nil
}

func (r *ReposGetAllTopicsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetAllTopicsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetAllTopicsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetAllTopicsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetAllTopicsReq) Rel(link RelName, resp *ReposGetAllTopicsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetAllTopicsResponseBody is a response body for ReposGetAllTopics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
type ReposGetAllTopicsResponseBody components.Topic

/*
ReposGetAllTopicsResponse is a response for ReposGetAllTopics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
type ReposGetAllTopicsResponse struct {
	response
	request *ReposGetAllTopicsReq
	Data    ReposGetAllTopicsResponseBody
}

/*
ReposGetAppsWithAccessToProtectedBranch performs requests for "repos/get-apps-with-access-to-protected-branch"

Get apps with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-the-protected-branch
*/
func ReposGetAppsWithAccessToProtectedBranch(ctx context.Context, req *ReposGetAppsWithAccessToProtectedBranchReq, opt ...RequestOption) (*ReposGetAppsWithAccessToProtectedBranchResponse, error) {
	if req == nil {
		req = new(ReposGetAppsWithAccessToProtectedBranchReq)
	}
	resp := &ReposGetAppsWithAccessToProtectedBranchResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetAppsWithAccessToProtectedBranchResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetAppsWithAccessToProtectedBranch performs requests for "repos/get-apps-with-access-to-protected-branch"

Get apps with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-the-protected-branch
*/
func (c Client) ReposGetAppsWithAccessToProtectedBranch(ctx context.Context, req *ReposGetAppsWithAccessToProtectedBranchReq, opt ...RequestOption) (*ReposGetAppsWithAccessToProtectedBranchResponse, error) {
	return ReposGetAppsWithAccessToProtectedBranch(ctx, req, append(c, opt...)...)
}

/*
ReposGetAppsWithAccessToProtectedBranchReq is request data for Client.ReposGetAppsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-the-protected-branch
*/
type ReposGetAppsWithAccessToProtectedBranchReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) url() string {
	return r._url
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) method() string {
	return "GET"
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) body() interface{} {
	return nil
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetAppsWithAccessToProtectedBranchReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetAppsWithAccessToProtectedBranchReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetAppsWithAccessToProtectedBranchReq) Rel(link RelName, resp *ReposGetAppsWithAccessToProtectedBranchResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetAppsWithAccessToProtectedBranchResponseBody is a response body for ReposGetAppsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-the-protected-branch
*/
type ReposGetAppsWithAccessToProtectedBranchResponseBody []components.Integration

/*
ReposGetAppsWithAccessToProtectedBranchResponse is a response for ReposGetAppsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-the-protected-branch
*/
type ReposGetAppsWithAccessToProtectedBranchResponse struct {
	response
	request *ReposGetAppsWithAccessToProtectedBranchReq
	Data    ReposGetAppsWithAccessToProtectedBranchResponseBody
}

/*
ReposGetBranch performs requests for "repos/get-branch"

Get a branch.

  GET /repos/{owner}/{repo}/branches/{branch}

https://developer.github.com/v3/repos/branches/#get-a-branch
*/
func ReposGetBranch(ctx context.Context, req *ReposGetBranchReq, opt ...RequestOption) (*ReposGetBranchResponse, error) {
	if req == nil {
		req = new(ReposGetBranchReq)
	}
	resp := &ReposGetBranchResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetBranchResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetBranch performs requests for "repos/get-branch"

Get a branch.

  GET /repos/{owner}/{repo}/branches/{branch}

https://developer.github.com/v3/repos/branches/#get-a-branch
*/
func (c Client) ReposGetBranch(ctx context.Context, req *ReposGetBranchReq, opt ...RequestOption) (*ReposGetBranchResponse, error) {
	return ReposGetBranch(ctx, req, append(c, opt...)...)
}

/*
ReposGetBranchReq is request data for Client.ReposGetBranch

https://developer.github.com/v3/repos/branches/#get-a-branch
*/
type ReposGetBranchReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetBranchReq) url() string {
	return r._url
}

func (r *ReposGetBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetBranchReq) method() string {
	return "GET"
}

func (r *ReposGetBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetBranchReq) body() interface{} {
	return nil
}

func (r *ReposGetBranchReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetBranchReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetBranchReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetBranchReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetBranchReq) Rel(link RelName, resp *ReposGetBranchResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetBranchResponseBody is a response body for ReposGetBranch

https://developer.github.com/v3/repos/branches/#get-a-branch
*/
type ReposGetBranchResponseBody components.BranchWithProtection

/*
ReposGetBranchResponse is a response for ReposGetBranch

https://developer.github.com/v3/repos/branches/#get-a-branch
*/
type ReposGetBranchResponse struct {
	response
	request *ReposGetBranchReq
	Data    ReposGetBranchResponseBody
}

/*
ReposGetBranchProtection performs requests for "repos/get-branch-protection"

Get branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
func ReposGetBranchProtection(ctx context.Context, req *ReposGetBranchProtectionReq, opt ...RequestOption) (*ReposGetBranchProtectionResponse, error) {
	if req == nil {
		req = new(ReposGetBranchProtectionReq)
	}
	resp := &ReposGetBranchProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetBranchProtectionResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetBranchProtection performs requests for "repos/get-branch-protection"

Get branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
func (c Client) ReposGetBranchProtection(ctx context.Context, req *ReposGetBranchProtectionReq, opt ...RequestOption) (*ReposGetBranchProtectionResponse, error) {
	return ReposGetBranchProtection(ctx, req, append(c, opt...)...)
}

/*
ReposGetBranchProtectionReq is request data for Client.ReposGetBranchProtection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
type ReposGetBranchProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

func (r *ReposGetBranchProtectionReq) url() string {
	return r._url
}

func (r *ReposGetBranchProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetBranchProtectionReq) method() string {
	return "GET"
}

func (r *ReposGetBranchProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetBranchProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"luke-cage": r.LukeCagePreview}
	if allPreviews {
		previewVals["luke-cage"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetBranchProtectionReq) body() interface{} {
	return nil
}

func (r *ReposGetBranchProtectionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetBranchProtectionReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetBranchProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetBranchProtectionReq) Rel(link RelName, resp *ReposGetBranchProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetBranchProtectionResponseBody is a response body for ReposGetBranchProtection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
type ReposGetBranchProtectionResponseBody components.BranchProtection

/*
ReposGetBranchProtectionResponse is a response for ReposGetBranchProtection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
type ReposGetBranchProtectionResponse struct {
	response
	request *ReposGetBranchProtectionReq
	Data    ReposGetBranchProtectionResponseBody
}

/*
ReposGetClones performs requests for "repos/get-clones"

Get repository clones.

  GET /repos/{owner}/{repo}/traffic/clones

https://developer.github.com/v3/repos/traffic/#get-repository-clones
*/
func ReposGetClones(ctx context.Context, req *ReposGetClonesReq, opt ...RequestOption) (*ReposGetClonesResponse, error) {
	if req == nil {
		req = new(ReposGetClonesReq)
	}
	resp := &ReposGetClonesResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetClonesResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetClones performs requests for "repos/get-clones"

Get repository clones.

  GET /repos/{owner}/{repo}/traffic/clones

https://developer.github.com/v3/repos/traffic/#get-repository-clones
*/
func (c Client) ReposGetClones(ctx context.Context, req *ReposGetClonesReq, opt ...RequestOption) (*ReposGetClonesResponse, error) {
	return ReposGetClones(ctx, req, append(c, opt...)...)
}

/*
ReposGetClonesReq is request data for Client.ReposGetClones

https://developer.github.com/v3/repos/traffic/#get-repository-clones
*/
type ReposGetClonesReq struct {
	_url  string
	Owner string
	Repo  string

	// Must be one of: `day`, `week`.
	Per *string
}

func (r *ReposGetClonesReq) url() string {
	return r._url
}

func (r *ReposGetClonesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/traffic/clones", r.Owner, r.Repo)
}

func (r *ReposGetClonesReq) method() string {
	return "GET"
}

func (r *ReposGetClonesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Per != nil {
		query.Set("per", *r.Per)
	}
	return query
}

func (r *ReposGetClonesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetClonesReq) body() interface{} {
	return nil
}

func (r *ReposGetClonesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetClonesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetClonesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetClonesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetClonesReq) Rel(link RelName, resp *ReposGetClonesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetClonesResponseBody is a response body for ReposGetClones

https://developer.github.com/v3/repos/traffic/#get-repository-clones
*/
type ReposGetClonesResponseBody components.CloneTraffic

/*
ReposGetClonesResponse is a response for ReposGetClones

https://developer.github.com/v3/repos/traffic/#get-repository-clones
*/
type ReposGetClonesResponse struct {
	response
	request *ReposGetClonesReq
	Data    ReposGetClonesResponseBody
}

/*
ReposGetCodeFrequencyStats performs requests for "repos/get-code-frequency-stats"

Get the weekly commit activity.

  GET /repos/{owner}/{repo}/stats/code_frequency

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-activity
*/
func ReposGetCodeFrequencyStats(ctx context.Context, req *ReposGetCodeFrequencyStatsReq, opt ...RequestOption) (*ReposGetCodeFrequencyStatsResponse, error) {
	if req == nil {
		req = new(ReposGetCodeFrequencyStatsReq)
	}
	resp := &ReposGetCodeFrequencyStatsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetCodeFrequencyStatsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCodeFrequencyStats performs requests for "repos/get-code-frequency-stats"

Get the weekly commit activity.

  GET /repos/{owner}/{repo}/stats/code_frequency

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-activity
*/
func (c Client) ReposGetCodeFrequencyStats(ctx context.Context, req *ReposGetCodeFrequencyStatsReq, opt ...RequestOption) (*ReposGetCodeFrequencyStatsResponse, error) {
	return ReposGetCodeFrequencyStats(ctx, req, append(c, opt...)...)
}

/*
ReposGetCodeFrequencyStatsReq is request data for Client.ReposGetCodeFrequencyStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-activity
*/
type ReposGetCodeFrequencyStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetCodeFrequencyStatsReq) url() string {
	return r._url
}

func (r *ReposGetCodeFrequencyStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/code_frequency", r.Owner, r.Repo)
}

func (r *ReposGetCodeFrequencyStatsReq) method() string {
	return "GET"
}

func (r *ReposGetCodeFrequencyStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCodeFrequencyStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCodeFrequencyStatsReq) body() interface{} {
	return nil
}

func (r *ReposGetCodeFrequencyStatsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCodeFrequencyStatsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCodeFrequencyStatsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCodeFrequencyStatsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCodeFrequencyStatsReq) Rel(link RelName, resp *ReposGetCodeFrequencyStatsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCodeFrequencyStatsResponseBody is a response body for ReposGetCodeFrequencyStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-activity
*/
type ReposGetCodeFrequencyStatsResponseBody []components.CodeFrequencyStat

/*
ReposGetCodeFrequencyStatsResponse is a response for ReposGetCodeFrequencyStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-activity
*/
type ReposGetCodeFrequencyStatsResponse struct {
	response
	request *ReposGetCodeFrequencyStatsReq
	Data    ReposGetCodeFrequencyStatsResponseBody
}

/*
ReposGetCollaboratorPermissionLevel performs requests for "repos/get-collaborator-permission-level"

Get repository permissions for a user.

  GET /repos/{owner}/{repo}/collaborators/{username}/permission

https://developer.github.com/v3/repos/collaborators/#get-repository-permissions-for-a-user
*/
func ReposGetCollaboratorPermissionLevel(ctx context.Context, req *ReposGetCollaboratorPermissionLevelReq, opt ...RequestOption) (*ReposGetCollaboratorPermissionLevelResponse, error) {
	if req == nil {
		req = new(ReposGetCollaboratorPermissionLevelReq)
	}
	resp := &ReposGetCollaboratorPermissionLevelResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetCollaboratorPermissionLevelResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCollaboratorPermissionLevel performs requests for "repos/get-collaborator-permission-level"

Get repository permissions for a user.

  GET /repos/{owner}/{repo}/collaborators/{username}/permission

https://developer.github.com/v3/repos/collaborators/#get-repository-permissions-for-a-user
*/
func (c Client) ReposGetCollaboratorPermissionLevel(ctx context.Context, req *ReposGetCollaboratorPermissionLevelReq, opt ...RequestOption) (*ReposGetCollaboratorPermissionLevelResponse, error) {
	return ReposGetCollaboratorPermissionLevel(ctx, req, append(c, opt...)...)
}

/*
ReposGetCollaboratorPermissionLevelReq is request data for Client.ReposGetCollaboratorPermissionLevel

https://developer.github.com/v3/repos/collaborators/#get-repository-permissions-for-a-user
*/
type ReposGetCollaboratorPermissionLevelReq struct {
	_url     string
	Owner    string
	Repo     string
	Username string
}

func (r *ReposGetCollaboratorPermissionLevelReq) url() string {
	return r._url
}

func (r *ReposGetCollaboratorPermissionLevelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators/%v/permission", r.Owner, r.Repo, r.Username)
}

func (r *ReposGetCollaboratorPermissionLevelReq) method() string {
	return "GET"
}

func (r *ReposGetCollaboratorPermissionLevelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCollaboratorPermissionLevelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCollaboratorPermissionLevelReq) body() interface{} {
	return nil
}

func (r *ReposGetCollaboratorPermissionLevelReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCollaboratorPermissionLevelReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCollaboratorPermissionLevelReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCollaboratorPermissionLevelReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCollaboratorPermissionLevelReq) Rel(link RelName, resp *ReposGetCollaboratorPermissionLevelResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCollaboratorPermissionLevelResponseBody is a response body for ReposGetCollaboratorPermissionLevel

https://developer.github.com/v3/repos/collaborators/#get-repository-permissions-for-a-user
*/
type ReposGetCollaboratorPermissionLevelResponseBody components.RepositoryCollaboratorPermission

/*
ReposGetCollaboratorPermissionLevelResponse is a response for ReposGetCollaboratorPermissionLevel

https://developer.github.com/v3/repos/collaborators/#get-repository-permissions-for-a-user
*/
type ReposGetCollaboratorPermissionLevelResponse struct {
	response
	request *ReposGetCollaboratorPermissionLevelReq
	Data    ReposGetCollaboratorPermissionLevelResponseBody
}

/*
ReposGetCombinedStatusForRef performs requests for "repos/get-combined-status-for-ref"

Get the combined status for a specific reference.

  GET /repos/{owner}/{repo}/commits/{ref}/status

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-reference
*/
func ReposGetCombinedStatusForRef(ctx context.Context, req *ReposGetCombinedStatusForRefReq, opt ...RequestOption) (*ReposGetCombinedStatusForRefResponse, error) {
	if req == nil {
		req = new(ReposGetCombinedStatusForRefReq)
	}
	resp := &ReposGetCombinedStatusForRefResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetCombinedStatusForRefResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCombinedStatusForRef performs requests for "repos/get-combined-status-for-ref"

Get the combined status for a specific reference.

  GET /repos/{owner}/{repo}/commits/{ref}/status

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-reference
*/
func (c Client) ReposGetCombinedStatusForRef(ctx context.Context, req *ReposGetCombinedStatusForRefReq, opt ...RequestOption) (*ReposGetCombinedStatusForRefResponse, error) {
	return ReposGetCombinedStatusForRef(ctx, req, append(c, opt...)...)
}

/*
ReposGetCombinedStatusForRefReq is request data for Client.ReposGetCombinedStatusForRef

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-reference
*/
type ReposGetCombinedStatusForRefReq struct {
	_url  string
	Owner string
	Repo  string
	Ref   string
}

func (r *ReposGetCombinedStatusForRefReq) url() string {
	return r._url
}

func (r *ReposGetCombinedStatusForRefReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/status", r.Owner, r.Repo, r.Ref)
}

func (r *ReposGetCombinedStatusForRefReq) method() string {
	return "GET"
}

func (r *ReposGetCombinedStatusForRefReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCombinedStatusForRefReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCombinedStatusForRefReq) body() interface{} {
	return nil
}

func (r *ReposGetCombinedStatusForRefReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCombinedStatusForRefReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCombinedStatusForRefReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCombinedStatusForRefReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCombinedStatusForRefReq) Rel(link RelName, resp *ReposGetCombinedStatusForRefResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCombinedStatusForRefResponseBody is a response body for ReposGetCombinedStatusForRef

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-reference
*/
type ReposGetCombinedStatusForRefResponseBody components.CombinedCommitStatus

/*
ReposGetCombinedStatusForRefResponse is a response for ReposGetCombinedStatusForRef

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-reference
*/
type ReposGetCombinedStatusForRefResponse struct {
	response
	request *ReposGetCombinedStatusForRefReq
	Data    ReposGetCombinedStatusForRefResponseBody
}

/*
ReposGetCommit performs requests for "repos/get-commit"

Get a commit.

  GET /repos/{owner}/{repo}/commits/{ref}

https://developer.github.com/v3/repos/commits/#get-a-commit
*/
func ReposGetCommit(ctx context.Context, req *ReposGetCommitReq, opt ...RequestOption) (*ReposGetCommitResponse, error) {
	if req == nil {
		req = new(ReposGetCommitReq)
	}
	resp := &ReposGetCommitResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetCommitResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCommit performs requests for "repos/get-commit"

Get a commit.

  GET /repos/{owner}/{repo}/commits/{ref}

https://developer.github.com/v3/repos/commits/#get-a-commit
*/
func (c Client) ReposGetCommit(ctx context.Context, req *ReposGetCommitReq, opt ...RequestOption) (*ReposGetCommitResponse, error) {
	return ReposGetCommit(ctx, req, append(c, opt...)...)
}

/*
ReposGetCommitReq is request data for Client.ReposGetCommit

https://developer.github.com/v3/repos/commits/#get-a-commit
*/
type ReposGetCommitReq struct {
	_url  string
	Owner string
	Repo  string
	Ref   string
}

func (r *ReposGetCommitReq) url() string {
	return r._url
}

func (r *ReposGetCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v", r.Owner, r.Repo, r.Ref)
}

func (r *ReposGetCommitReq) method() string {
	return "GET"
}

func (r *ReposGetCommitReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCommitReq) body() interface{} {
	return nil
}

func (r *ReposGetCommitReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCommitReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCommitReq) Rel(link RelName, resp *ReposGetCommitResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCommitResponseBody is a response body for ReposGetCommit

https://developer.github.com/v3/repos/commits/#get-a-commit
*/
type ReposGetCommitResponseBody components.Commit

/*
ReposGetCommitResponse is a response for ReposGetCommit

https://developer.github.com/v3/repos/commits/#get-a-commit
*/
type ReposGetCommitResponse struct {
	response
	request *ReposGetCommitReq
	Data    ReposGetCommitResponseBody
}

/*
ReposGetCommitActivityStats performs requests for "repos/get-commit-activity-stats"

Get the last year of commit activity.

  GET /repos/{owner}/{repo}/stats/commit_activity

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity
*/
func ReposGetCommitActivityStats(ctx context.Context, req *ReposGetCommitActivityStatsReq, opt ...RequestOption) (*ReposGetCommitActivityStatsResponse, error) {
	if req == nil {
		req = new(ReposGetCommitActivityStatsReq)
	}
	resp := &ReposGetCommitActivityStatsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetCommitActivityStatsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCommitActivityStats performs requests for "repos/get-commit-activity-stats"

Get the last year of commit activity.

  GET /repos/{owner}/{repo}/stats/commit_activity

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity
*/
func (c Client) ReposGetCommitActivityStats(ctx context.Context, req *ReposGetCommitActivityStatsReq, opt ...RequestOption) (*ReposGetCommitActivityStatsResponse, error) {
	return ReposGetCommitActivityStats(ctx, req, append(c, opt...)...)
}

/*
ReposGetCommitActivityStatsReq is request data for Client.ReposGetCommitActivityStats

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity
*/
type ReposGetCommitActivityStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetCommitActivityStatsReq) url() string {
	return r._url
}

func (r *ReposGetCommitActivityStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/commit_activity", r.Owner, r.Repo)
}

func (r *ReposGetCommitActivityStatsReq) method() string {
	return "GET"
}

func (r *ReposGetCommitActivityStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCommitActivityStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCommitActivityStatsReq) body() interface{} {
	return nil
}

func (r *ReposGetCommitActivityStatsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitActivityStatsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitActivityStatsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCommitActivityStatsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCommitActivityStatsReq) Rel(link RelName, resp *ReposGetCommitActivityStatsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCommitActivityStatsResponseBody is a response body for ReposGetCommitActivityStats

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity
*/
type ReposGetCommitActivityStatsResponseBody []components.CommitActivity

/*
ReposGetCommitActivityStatsResponse is a response for ReposGetCommitActivityStats

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity
*/
type ReposGetCommitActivityStatsResponse struct {
	response
	request *ReposGetCommitActivityStatsReq
	Data    ReposGetCommitActivityStatsResponseBody
}

/*
ReposGetCommitComment performs requests for "repos/get-commit-comment"

Get a commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#get-a-commit-comment
*/
func ReposGetCommitComment(ctx context.Context, req *ReposGetCommitCommentReq, opt ...RequestOption) (*ReposGetCommitCommentResponse, error) {
	if req == nil {
		req = new(ReposGetCommitCommentReq)
	}
	resp := &ReposGetCommitCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetCommitCommentResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCommitComment performs requests for "repos/get-commit-comment"

Get a commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#get-a-commit-comment
*/
func (c Client) ReposGetCommitComment(ctx context.Context, req *ReposGetCommitCommentReq, opt ...RequestOption) (*ReposGetCommitCommentResponse, error) {
	return ReposGetCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReposGetCommitCommentReq is request data for Client.ReposGetCommitComment

https://developer.github.com/v3/repos/comments/#get-a-commit-comment
*/
type ReposGetCommitCommentReq struct {
	_url      string
	Owner     string
	Repo      string
	CommentId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReposGetCommitCommentReq) url() string {
	return r._url
}

func (r *ReposGetCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *ReposGetCommitCommentReq) method() string {
	return "GET"
}

func (r *ReposGetCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCommitCommentReq) body() interface{} {
	return nil
}

func (r *ReposGetCommitCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCommitCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCommitCommentReq) Rel(link RelName, resp *ReposGetCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCommitCommentResponseBody is a response body for ReposGetCommitComment

https://developer.github.com/v3/repos/comments/#get-a-commit-comment
*/
type ReposGetCommitCommentResponseBody components.CommitComment

/*
ReposGetCommitCommentResponse is a response for ReposGetCommitComment

https://developer.github.com/v3/repos/comments/#get-a-commit-comment
*/
type ReposGetCommitCommentResponse struct {
	response
	request *ReposGetCommitCommentReq
	Data    ReposGetCommitCommentResponseBody
}

/*
ReposGetCommitSignatureProtection performs requests for "repos/get-commit-signature-protection"

Get commit signature protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#get-commit-signature-protection
*/
func ReposGetCommitSignatureProtection(ctx context.Context, req *ReposGetCommitSignatureProtectionReq, opt ...RequestOption) (*ReposGetCommitSignatureProtectionResponse, error) {
	if req == nil {
		req = new(ReposGetCommitSignatureProtectionReq)
	}
	resp := &ReposGetCommitSignatureProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetCommitSignatureProtectionResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCommitSignatureProtection performs requests for "repos/get-commit-signature-protection"

Get commit signature protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#get-commit-signature-protection
*/
func (c Client) ReposGetCommitSignatureProtection(ctx context.Context, req *ReposGetCommitSignatureProtectionReq, opt ...RequestOption) (*ReposGetCommitSignatureProtectionResponse, error) {
	return ReposGetCommitSignatureProtection(ctx, req, append(c, opt...)...)
}

/*
ReposGetCommitSignatureProtectionReq is request data for Client.ReposGetCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#get-commit-signature-protection
*/
type ReposGetCommitSignatureProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

func (r *ReposGetCommitSignatureProtectionReq) url() string {
	return r._url
}

func (r *ReposGetCommitSignatureProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetCommitSignatureProtectionReq) method() string {
	return "GET"
}

func (r *ReposGetCommitSignatureProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCommitSignatureProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"zzzax": r.ZzzaxPreview}
	if requiredPreviews {
		previewVals["zzzax"] = true
	}
	if allPreviews {
		previewVals["zzzax"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCommitSignatureProtectionReq) body() interface{} {
	return nil
}

func (r *ReposGetCommitSignatureProtectionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitSignatureProtectionReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommitSignatureProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCommitSignatureProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCommitSignatureProtectionReq) Rel(link RelName, resp *ReposGetCommitSignatureProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCommitSignatureProtectionResponseBody is a response body for ReposGetCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#get-commit-signature-protection
*/
type ReposGetCommitSignatureProtectionResponseBody components.ProtectedBranchAdminEnforced

/*
ReposGetCommitSignatureProtectionResponse is a response for ReposGetCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#get-commit-signature-protection
*/
type ReposGetCommitSignatureProtectionResponse struct {
	response
	request *ReposGetCommitSignatureProtectionReq
	Data    ReposGetCommitSignatureProtectionResponseBody
}

/*
ReposGetCommunityProfileMetrics performs requests for "repos/get-community-profile-metrics"

Get community profile metrics.

  GET /repos/{owner}/{repo}/community/profile

https://developer.github.com/v3/repos/community/#get-community-profile-metrics
*/
func ReposGetCommunityProfileMetrics(ctx context.Context, req *ReposGetCommunityProfileMetricsReq, opt ...RequestOption) (*ReposGetCommunityProfileMetricsResponse, error) {
	if req == nil {
		req = new(ReposGetCommunityProfileMetricsReq)
	}
	resp := &ReposGetCommunityProfileMetricsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetCommunityProfileMetricsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetCommunityProfileMetrics performs requests for "repos/get-community-profile-metrics"

Get community profile metrics.

  GET /repos/{owner}/{repo}/community/profile

https://developer.github.com/v3/repos/community/#get-community-profile-metrics
*/
func (c Client) ReposGetCommunityProfileMetrics(ctx context.Context, req *ReposGetCommunityProfileMetricsReq, opt ...RequestOption) (*ReposGetCommunityProfileMetricsResponse, error) {
	return ReposGetCommunityProfileMetrics(ctx, req, append(c, opt...)...)
}

/*
ReposGetCommunityProfileMetricsReq is request data for Client.ReposGetCommunityProfileMetrics

https://developer.github.com/v3/repos/community/#get-community-profile-metrics
*/
type ReposGetCommunityProfileMetricsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	We're currently offering a preview of the Community Profile API (also known as
	community health). To access the API during the preview period, you must provide
	a custom [media type](https://developer.github.com/v3/media) in the  `Accept`
	header.
	*/
	BlackPantherPreview bool
}

func (r *ReposGetCommunityProfileMetricsReq) url() string {
	return r._url
}

func (r *ReposGetCommunityProfileMetricsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/community/profile", r.Owner, r.Repo)
}

func (r *ReposGetCommunityProfileMetricsReq) method() string {
	return "GET"
}

func (r *ReposGetCommunityProfileMetricsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetCommunityProfileMetricsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"black-panther": r.BlackPantherPreview}
	if requiredPreviews {
		previewVals["black-panther"] = true
	}
	if allPreviews {
		previewVals["black-panther"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetCommunityProfileMetricsReq) body() interface{} {
	return nil
}

func (r *ReposGetCommunityProfileMetricsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommunityProfileMetricsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetCommunityProfileMetricsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetCommunityProfileMetricsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetCommunityProfileMetricsReq) Rel(link RelName, resp *ReposGetCommunityProfileMetricsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetCommunityProfileMetricsResponseBody is a response body for ReposGetCommunityProfileMetrics

https://developer.github.com/v3/repos/community/#get-community-profile-metrics
*/
type ReposGetCommunityProfileMetricsResponseBody components.CommunityProfile

/*
ReposGetCommunityProfileMetricsResponse is a response for ReposGetCommunityProfileMetrics

https://developer.github.com/v3/repos/community/#get-community-profile-metrics
*/
type ReposGetCommunityProfileMetricsResponse struct {
	response
	request *ReposGetCommunityProfileMetricsReq
	Data    ReposGetCommunityProfileMetricsResponseBody
}

/*
ReposGetContent performs requests for "repos/get-content"

Get repository content.

  GET /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
func ReposGetContent(ctx context.Context, req *ReposGetContentReq, opt ...RequestOption) (*ReposGetContentResponse, error) {
	if req == nil {
		req = new(ReposGetContentReq)
	}
	resp := &ReposGetContentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetContentResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetContent performs requests for "repos/get-content"

Get repository content.

  GET /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
func (c Client) ReposGetContent(ctx context.Context, req *ReposGetContentReq, opt ...RequestOption) (*ReposGetContentResponse, error) {
	return ReposGetContent(ctx, req, append(c, opt...)...)
}

/*
ReposGetContentReq is request data for Client.ReposGetContent

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
type ReposGetContentReq struct {
	_url  string
	Owner string
	Repo  string
	Path  string

	/*
	The name of the commit/branch/tag. Default: the repositorys default branch
	(usually `master`)
	*/
	Ref *string
}

func (r *ReposGetContentReq) url() string {
	return r._url
}

func (r *ReposGetContentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path)
}

func (r *ReposGetContentReq) method() string {
	return "GET"
}

func (r *ReposGetContentReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}
	return query
}

func (r *ReposGetContentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetContentReq) body() interface{} {
	return nil
}

func (r *ReposGetContentReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetContentReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetContentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrForceArrayResponse}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetContentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetContentReq) Rel(link RelName, resp *ReposGetContentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetContentResponseBody is a response body for ReposGetContent

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
type ReposGetContentResponseBody []components.ContentFile

/*
ReposGetContentResponse is a response for ReposGetContent

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
type ReposGetContentResponse struct {
	response
	request *ReposGetContentReq
	Data    ReposGetContentResponseBody
}

/*
ReposGetContributorsStats performs requests for "repos/get-contributors-stats"

Get all contributor commit activity.

  GET /repos/{owner}/{repo}/stats/contributors

https://developer.github.com/v3/repos/statistics/#get-all-contributor-commit-activity
*/
func ReposGetContributorsStats(ctx context.Context, req *ReposGetContributorsStatsReq, opt ...RequestOption) (*ReposGetContributorsStatsResponse, error) {
	if req == nil {
		req = new(ReposGetContributorsStatsReq)
	}
	resp := &ReposGetContributorsStatsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetContributorsStatsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetContributorsStats performs requests for "repos/get-contributors-stats"

Get all contributor commit activity.

  GET /repos/{owner}/{repo}/stats/contributors

https://developer.github.com/v3/repos/statistics/#get-all-contributor-commit-activity
*/
func (c Client) ReposGetContributorsStats(ctx context.Context, req *ReposGetContributorsStatsReq, opt ...RequestOption) (*ReposGetContributorsStatsResponse, error) {
	return ReposGetContributorsStats(ctx, req, append(c, opt...)...)
}

/*
ReposGetContributorsStatsReq is request data for Client.ReposGetContributorsStats

https://developer.github.com/v3/repos/statistics/#get-all-contributor-commit-activity
*/
type ReposGetContributorsStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetContributorsStatsReq) url() string {
	return r._url
}

func (r *ReposGetContributorsStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/contributors", r.Owner, r.Repo)
}

func (r *ReposGetContributorsStatsReq) method() string {
	return "GET"
}

func (r *ReposGetContributorsStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetContributorsStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetContributorsStatsReq) body() interface{} {
	return nil
}

func (r *ReposGetContributorsStatsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetContributorsStatsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetContributorsStatsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetContributorsStatsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetContributorsStatsReq) Rel(link RelName, resp *ReposGetContributorsStatsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetContributorsStatsResponseBody is a response body for ReposGetContributorsStats

https://developer.github.com/v3/repos/statistics/#get-all-contributor-commit-activity
*/
type ReposGetContributorsStatsResponseBody []components.ContributorActivity

/*
ReposGetContributorsStatsResponse is a response for ReposGetContributorsStats

https://developer.github.com/v3/repos/statistics/#get-all-contributor-commit-activity
*/
type ReposGetContributorsStatsResponse struct {
	response
	request *ReposGetContributorsStatsReq
	Data    ReposGetContributorsStatsResponseBody
}

/*
ReposGetDeployKey performs requests for "repos/get-deploy-key"

Get a deploy key.

  GET /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
func ReposGetDeployKey(ctx context.Context, req *ReposGetDeployKeyReq, opt ...RequestOption) (*ReposGetDeployKeyResponse, error) {
	if req == nil {
		req = new(ReposGetDeployKeyReq)
	}
	resp := &ReposGetDeployKeyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetDeployKeyResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetDeployKey performs requests for "repos/get-deploy-key"

Get a deploy key.

  GET /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
func (c Client) ReposGetDeployKey(ctx context.Context, req *ReposGetDeployKeyReq, opt ...RequestOption) (*ReposGetDeployKeyResponse, error) {
	return ReposGetDeployKey(ctx, req, append(c, opt...)...)
}

/*
ReposGetDeployKeyReq is request data for Client.ReposGetDeployKey

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
type ReposGetDeployKeyReq struct {
	_url  string
	Owner string
	Repo  string
	KeyId int64
}

func (r *ReposGetDeployKeyReq) url() string {
	return r._url
}

func (r *ReposGetDeployKeyReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/keys/%v", r.Owner, r.Repo, r.KeyId)
}

func (r *ReposGetDeployKeyReq) method() string {
	return "GET"
}

func (r *ReposGetDeployKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetDeployKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetDeployKeyReq) body() interface{} {
	return nil
}

func (r *ReposGetDeployKeyReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetDeployKeyReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetDeployKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetDeployKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetDeployKeyReq) Rel(link RelName, resp *ReposGetDeployKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetDeployKeyResponseBody is a response body for ReposGetDeployKey

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
type ReposGetDeployKeyResponseBody components.DeployKey

/*
ReposGetDeployKeyResponse is a response for ReposGetDeployKey

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
type ReposGetDeployKeyResponse struct {
	response
	request *ReposGetDeployKeyReq
	Data    ReposGetDeployKeyResponseBody
}

/*
ReposGetDeployment performs requests for "repos/get-deployment"

Get a deployment.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#get-a-deployment
*/
func ReposGetDeployment(ctx context.Context, req *ReposGetDeploymentReq, opt ...RequestOption) (*ReposGetDeploymentResponse, error) {
	if req == nil {
		req = new(ReposGetDeploymentReq)
	}
	resp := &ReposGetDeploymentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetDeploymentResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetDeployment performs requests for "repos/get-deployment"

Get a deployment.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#get-a-deployment
*/
func (c Client) ReposGetDeployment(ctx context.Context, req *ReposGetDeploymentReq, opt ...RequestOption) (*ReposGetDeploymentResponse, error) {
	return ReposGetDeployment(ctx, req, append(c, opt...)...)
}

/*
ReposGetDeploymentReq is request data for Client.ReposGetDeployment

https://developer.github.com/v3/repos/deployments/#get-a-deployment
*/
type ReposGetDeploymentReq struct {
	_url         string
	Owner        string
	Repo         string
	DeploymentId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposGetDeploymentReq) url() string {
	return r._url
}

func (r *ReposGetDeploymentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v", r.Owner, r.Repo, r.DeploymentId)
}

func (r *ReposGetDeploymentReq) method() string {
	return "GET"
}

func (r *ReposGetDeploymentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetDeploymentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"ant-man":     r.AntManPreview,
		"machine-man": r.MachineManPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetDeploymentReq) body() interface{} {
	return nil
}

func (r *ReposGetDeploymentReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetDeploymentReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetDeploymentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetDeploymentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetDeploymentReq) Rel(link RelName, resp *ReposGetDeploymentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetDeploymentResponseBody is a response body for ReposGetDeployment

https://developer.github.com/v3/repos/deployments/#get-a-deployment
*/
type ReposGetDeploymentResponseBody components.Deployment

/*
ReposGetDeploymentResponse is a response for ReposGetDeployment

https://developer.github.com/v3/repos/deployments/#get-a-deployment
*/
type ReposGetDeploymentResponse struct {
	response
	request *ReposGetDeploymentReq
	Data    ReposGetDeploymentResponseBody
}

/*
ReposGetDeploymentStatus performs requests for "repos/get-deployment-status"

Get a deployment status.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}

https://developer.github.com/v3/repos/deployments/#get-a-deployment-status
*/
func ReposGetDeploymentStatus(ctx context.Context, req *ReposGetDeploymentStatusReq, opt ...RequestOption) (*ReposGetDeploymentStatusResponse, error) {
	if req == nil {
		req = new(ReposGetDeploymentStatusReq)
	}
	resp := &ReposGetDeploymentStatusResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetDeploymentStatusResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetDeploymentStatus performs requests for "repos/get-deployment-status"

Get a deployment status.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}

https://developer.github.com/v3/repos/deployments/#get-a-deployment-status
*/
func (c Client) ReposGetDeploymentStatus(ctx context.Context, req *ReposGetDeploymentStatusReq, opt ...RequestOption) (*ReposGetDeploymentStatusResponse, error) {
	return ReposGetDeploymentStatus(ctx, req, append(c, opt...)...)
}

/*
ReposGetDeploymentStatusReq is request data for Client.ReposGetDeploymentStatus

https://developer.github.com/v3/repos/deployments/#get-a-deployment-status
*/
type ReposGetDeploymentStatusReq struct {
	_url         string
	Owner        string
	Repo         string
	DeploymentId int64
	StatusId     int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposGetDeploymentStatusReq) url() string {
	return r._url
}

func (r *ReposGetDeploymentStatusReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses/%v", r.Owner, r.Repo, r.DeploymentId, r.StatusId)
}

func (r *ReposGetDeploymentStatusReq) method() string {
	return "GET"
}

func (r *ReposGetDeploymentStatusReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetDeploymentStatusReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"ant-man":     r.AntManPreview,
		"flash":       r.FlashPreview,
		"machine-man": r.MachineManPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["flash"] = true
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetDeploymentStatusReq) body() interface{} {
	return nil
}

func (r *ReposGetDeploymentStatusReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetDeploymentStatusReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetDeploymentStatusReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetDeploymentStatusReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetDeploymentStatusReq) Rel(link RelName, resp *ReposGetDeploymentStatusResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetDeploymentStatusResponseBody is a response body for ReposGetDeploymentStatus

https://developer.github.com/v3/repos/deployments/#get-a-deployment-status
*/
type ReposGetDeploymentStatusResponseBody components.DeploymentStatus

/*
ReposGetDeploymentStatusResponse is a response for ReposGetDeploymentStatus

https://developer.github.com/v3/repos/deployments/#get-a-deployment-status
*/
type ReposGetDeploymentStatusResponse struct {
	response
	request *ReposGetDeploymentStatusReq
	Data    ReposGetDeploymentStatusResponseBody
}

/*
ReposGetLatestPagesBuild performs requests for "repos/get-latest-pages-build"

Get latest Pages build.

  GET /repos/{owner}/{repo}/pages/builds/latest

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
func ReposGetLatestPagesBuild(ctx context.Context, req *ReposGetLatestPagesBuildReq, opt ...RequestOption) (*ReposGetLatestPagesBuildResponse, error) {
	if req == nil {
		req = new(ReposGetLatestPagesBuildReq)
	}
	resp := &ReposGetLatestPagesBuildResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetLatestPagesBuildResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetLatestPagesBuild performs requests for "repos/get-latest-pages-build"

Get latest Pages build.

  GET /repos/{owner}/{repo}/pages/builds/latest

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
func (c Client) ReposGetLatestPagesBuild(ctx context.Context, req *ReposGetLatestPagesBuildReq, opt ...RequestOption) (*ReposGetLatestPagesBuildResponse, error) {
	return ReposGetLatestPagesBuild(ctx, req, append(c, opt...)...)
}

/*
ReposGetLatestPagesBuildReq is request data for Client.ReposGetLatestPagesBuild

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
type ReposGetLatestPagesBuildReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetLatestPagesBuildReq) url() string {
	return r._url
}

func (r *ReposGetLatestPagesBuildReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages/builds/latest", r.Owner, r.Repo)
}

func (r *ReposGetLatestPagesBuildReq) method() string {
	return "GET"
}

func (r *ReposGetLatestPagesBuildReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetLatestPagesBuildReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetLatestPagesBuildReq) body() interface{} {
	return nil
}

func (r *ReposGetLatestPagesBuildReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetLatestPagesBuildReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetLatestPagesBuildReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetLatestPagesBuildReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetLatestPagesBuildReq) Rel(link RelName, resp *ReposGetLatestPagesBuildResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetLatestPagesBuildResponseBody is a response body for ReposGetLatestPagesBuild

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
type ReposGetLatestPagesBuildResponseBody components.PageBuild

/*
ReposGetLatestPagesBuildResponse is a response for ReposGetLatestPagesBuild

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
type ReposGetLatestPagesBuildResponse struct {
	response
	request *ReposGetLatestPagesBuildReq
	Data    ReposGetLatestPagesBuildResponseBody
}

/*
ReposGetLatestRelease performs requests for "repos/get-latest-release"

Get the latest release.

  GET /repos/{owner}/{repo}/releases/latest

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
func ReposGetLatestRelease(ctx context.Context, req *ReposGetLatestReleaseReq, opt ...RequestOption) (*ReposGetLatestReleaseResponse, error) {
	if req == nil {
		req = new(ReposGetLatestReleaseReq)
	}
	resp := &ReposGetLatestReleaseResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetLatestReleaseResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetLatestRelease performs requests for "repos/get-latest-release"

Get the latest release.

  GET /repos/{owner}/{repo}/releases/latest

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
func (c Client) ReposGetLatestRelease(ctx context.Context, req *ReposGetLatestReleaseReq, opt ...RequestOption) (*ReposGetLatestReleaseResponse, error) {
	return ReposGetLatestRelease(ctx, req, append(c, opt...)...)
}

/*
ReposGetLatestReleaseReq is request data for Client.ReposGetLatestRelease

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
type ReposGetLatestReleaseReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetLatestReleaseReq) url() string {
	return r._url
}

func (r *ReposGetLatestReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/latest", r.Owner, r.Repo)
}

func (r *ReposGetLatestReleaseReq) method() string {
	return "GET"
}

func (r *ReposGetLatestReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetLatestReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetLatestReleaseReq) body() interface{} {
	return nil
}

func (r *ReposGetLatestReleaseReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetLatestReleaseReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetLatestReleaseReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetLatestReleaseReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetLatestReleaseReq) Rel(link RelName, resp *ReposGetLatestReleaseResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetLatestReleaseResponseBody is a response body for ReposGetLatestRelease

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
type ReposGetLatestReleaseResponseBody components.Release2

/*
ReposGetLatestReleaseResponse is a response for ReposGetLatestRelease

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
type ReposGetLatestReleaseResponse struct {
	response
	request *ReposGetLatestReleaseReq
	Data    ReposGetLatestReleaseResponseBody
}

/*
ReposGetPages performs requests for "repos/get-pages"

Get a GitHub Pages site.

  GET /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#get-a-github-pages-site
*/
func ReposGetPages(ctx context.Context, req *ReposGetPagesReq, opt ...RequestOption) (*ReposGetPagesResponse, error) {
	if req == nil {
		req = new(ReposGetPagesReq)
	}
	resp := &ReposGetPagesResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetPagesResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetPages performs requests for "repos/get-pages"

Get a GitHub Pages site.

  GET /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#get-a-github-pages-site
*/
func (c Client) ReposGetPages(ctx context.Context, req *ReposGetPagesReq, opt ...RequestOption) (*ReposGetPagesResponse, error) {
	return ReposGetPages(ctx, req, append(c, opt...)...)
}

/*
ReposGetPagesReq is request data for Client.ReposGetPages

https://developer.github.com/v3/repos/pages/#get-a-github-pages-site
*/
type ReposGetPagesReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetPagesReq) url() string {
	return r._url
}

func (r *ReposGetPagesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo)
}

func (r *ReposGetPagesReq) method() string {
	return "GET"
}

func (r *ReposGetPagesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetPagesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetPagesReq) body() interface{} {
	return nil
}

func (r *ReposGetPagesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetPagesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetPagesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetPagesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetPagesReq) Rel(link RelName, resp *ReposGetPagesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetPagesResponseBody is a response body for ReposGetPages

https://developer.github.com/v3/repos/pages/#get-a-github-pages-site
*/
type ReposGetPagesResponseBody components.Page

/*
ReposGetPagesResponse is a response for ReposGetPages

https://developer.github.com/v3/repos/pages/#get-a-github-pages-site
*/
type ReposGetPagesResponse struct {
	response
	request *ReposGetPagesReq
	Data    ReposGetPagesResponseBody
}

/*
ReposGetPagesBuild performs requests for "repos/get-pages-build"

Get GitHub Pages build.

  GET /repos/{owner}/{repo}/pages/builds/{build_id}

https://developer.github.com/v3/repos/pages/#get-github-pages-build
*/
func ReposGetPagesBuild(ctx context.Context, req *ReposGetPagesBuildReq, opt ...RequestOption) (*ReposGetPagesBuildResponse, error) {
	if req == nil {
		req = new(ReposGetPagesBuildReq)
	}
	resp := &ReposGetPagesBuildResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetPagesBuildResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetPagesBuild performs requests for "repos/get-pages-build"

Get GitHub Pages build.

  GET /repos/{owner}/{repo}/pages/builds/{build_id}

https://developer.github.com/v3/repos/pages/#get-github-pages-build
*/
func (c Client) ReposGetPagesBuild(ctx context.Context, req *ReposGetPagesBuildReq, opt ...RequestOption) (*ReposGetPagesBuildResponse, error) {
	return ReposGetPagesBuild(ctx, req, append(c, opt...)...)
}

/*
ReposGetPagesBuildReq is request data for Client.ReposGetPagesBuild

https://developer.github.com/v3/repos/pages/#get-github-pages-build
*/
type ReposGetPagesBuildReq struct {
	_url    string
	Owner   string
	Repo    string
	BuildId int64
}

func (r *ReposGetPagesBuildReq) url() string {
	return r._url
}

func (r *ReposGetPagesBuildReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages/builds/%v", r.Owner, r.Repo, r.BuildId)
}

func (r *ReposGetPagesBuildReq) method() string {
	return "GET"
}

func (r *ReposGetPagesBuildReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetPagesBuildReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetPagesBuildReq) body() interface{} {
	return nil
}

func (r *ReposGetPagesBuildReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetPagesBuildReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetPagesBuildReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetPagesBuildReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetPagesBuildReq) Rel(link RelName, resp *ReposGetPagesBuildResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetPagesBuildResponseBody is a response body for ReposGetPagesBuild

https://developer.github.com/v3/repos/pages/#get-github-pages-build
*/
type ReposGetPagesBuildResponseBody components.PageBuild

/*
ReposGetPagesBuildResponse is a response for ReposGetPagesBuild

https://developer.github.com/v3/repos/pages/#get-github-pages-build
*/
type ReposGetPagesBuildResponse struct {
	response
	request *ReposGetPagesBuildReq
	Data    ReposGetPagesBuildResponseBody
}

/*
ReposGetParticipationStats performs requests for "repos/get-participation-stats"

Get the weekly commit count.

  GET /repos/{owner}/{repo}/stats/participation

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count
*/
func ReposGetParticipationStats(ctx context.Context, req *ReposGetParticipationStatsReq, opt ...RequestOption) (*ReposGetParticipationStatsResponse, error) {
	if req == nil {
		req = new(ReposGetParticipationStatsReq)
	}
	resp := &ReposGetParticipationStatsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetParticipationStatsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetParticipationStats performs requests for "repos/get-participation-stats"

Get the weekly commit count.

  GET /repos/{owner}/{repo}/stats/participation

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count
*/
func (c Client) ReposGetParticipationStats(ctx context.Context, req *ReposGetParticipationStatsReq, opt ...RequestOption) (*ReposGetParticipationStatsResponse, error) {
	return ReposGetParticipationStats(ctx, req, append(c, opt...)...)
}

/*
ReposGetParticipationStatsReq is request data for Client.ReposGetParticipationStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count
*/
type ReposGetParticipationStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetParticipationStatsReq) url() string {
	return r._url
}

func (r *ReposGetParticipationStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/participation", r.Owner, r.Repo)
}

func (r *ReposGetParticipationStatsReq) method() string {
	return "GET"
}

func (r *ReposGetParticipationStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetParticipationStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetParticipationStatsReq) body() interface{} {
	return nil
}

func (r *ReposGetParticipationStatsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetParticipationStatsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetParticipationStatsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetParticipationStatsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetParticipationStatsReq) Rel(link RelName, resp *ReposGetParticipationStatsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetParticipationStatsResponseBody is a response body for ReposGetParticipationStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count
*/
type ReposGetParticipationStatsResponseBody components.ParticipationStats

/*
ReposGetParticipationStatsResponse is a response for ReposGetParticipationStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count
*/
type ReposGetParticipationStatsResponse struct {
	response
	request *ReposGetParticipationStatsReq
	Data    ReposGetParticipationStatsResponseBody
}

/*
ReposGetPullRequestReviewProtection performs requests for "repos/get-pull-request-review-protection"

Get pull request review protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#get-pull-request-review-protection
*/
func ReposGetPullRequestReviewProtection(ctx context.Context, req *ReposGetPullRequestReviewProtectionReq, opt ...RequestOption) (*ReposGetPullRequestReviewProtectionResponse, error) {
	if req == nil {
		req = new(ReposGetPullRequestReviewProtectionReq)
	}
	resp := &ReposGetPullRequestReviewProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetPullRequestReviewProtectionResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetPullRequestReviewProtection performs requests for "repos/get-pull-request-review-protection"

Get pull request review protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#get-pull-request-review-protection
*/
func (c Client) ReposGetPullRequestReviewProtection(ctx context.Context, req *ReposGetPullRequestReviewProtectionReq, opt ...RequestOption) (*ReposGetPullRequestReviewProtectionResponse, error) {
	return ReposGetPullRequestReviewProtection(ctx, req, append(c, opt...)...)
}

/*
ReposGetPullRequestReviewProtectionReq is request data for Client.ReposGetPullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#get-pull-request-review-protection
*/
type ReposGetPullRequestReviewProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

func (r *ReposGetPullRequestReviewProtectionReq) url() string {
	return r._url
}

func (r *ReposGetPullRequestReviewProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetPullRequestReviewProtectionReq) method() string {
	return "GET"
}

func (r *ReposGetPullRequestReviewProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetPullRequestReviewProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"luke-cage": r.LukeCagePreview}
	if allPreviews {
		previewVals["luke-cage"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetPullRequestReviewProtectionReq) body() interface{} {
	return nil
}

func (r *ReposGetPullRequestReviewProtectionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetPullRequestReviewProtectionReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetPullRequestReviewProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetPullRequestReviewProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetPullRequestReviewProtectionReq) Rel(link RelName, resp *ReposGetPullRequestReviewProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetPullRequestReviewProtectionResponseBody is a response body for ReposGetPullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#get-pull-request-review-protection
*/
type ReposGetPullRequestReviewProtectionResponseBody components.ProtectedBranchPullRequestReview

/*
ReposGetPullRequestReviewProtectionResponse is a response for ReposGetPullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#get-pull-request-review-protection
*/
type ReposGetPullRequestReviewProtectionResponse struct {
	response
	request *ReposGetPullRequestReviewProtectionReq
	Data    ReposGetPullRequestReviewProtectionResponseBody
}

/*
ReposGetPunchCardStats performs requests for "repos/get-punch-card-stats"

Get the hourly commit count for each day.

  GET /repos/{owner}/{repo}/stats/punch_card

https://developer.github.com/v3/repos/statistics/#get-the-hourly-commit-count-for-each-day
*/
func ReposGetPunchCardStats(ctx context.Context, req *ReposGetPunchCardStatsReq, opt ...RequestOption) (*ReposGetPunchCardStatsResponse, error) {
	if req == nil {
		req = new(ReposGetPunchCardStatsReq)
	}
	resp := &ReposGetPunchCardStatsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetPunchCardStatsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetPunchCardStats performs requests for "repos/get-punch-card-stats"

Get the hourly commit count for each day.

  GET /repos/{owner}/{repo}/stats/punch_card

https://developer.github.com/v3/repos/statistics/#get-the-hourly-commit-count-for-each-day
*/
func (c Client) ReposGetPunchCardStats(ctx context.Context, req *ReposGetPunchCardStatsReq, opt ...RequestOption) (*ReposGetPunchCardStatsResponse, error) {
	return ReposGetPunchCardStats(ctx, req, append(c, opt...)...)
}

/*
ReposGetPunchCardStatsReq is request data for Client.ReposGetPunchCardStats

https://developer.github.com/v3/repos/statistics/#get-the-hourly-commit-count-for-each-day
*/
type ReposGetPunchCardStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetPunchCardStatsReq) url() string {
	return r._url
}

func (r *ReposGetPunchCardStatsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/stats/punch_card", r.Owner, r.Repo)
}

func (r *ReposGetPunchCardStatsReq) method() string {
	return "GET"
}

func (r *ReposGetPunchCardStatsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetPunchCardStatsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetPunchCardStatsReq) body() interface{} {
	return nil
}

func (r *ReposGetPunchCardStatsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetPunchCardStatsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetPunchCardStatsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetPunchCardStatsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetPunchCardStatsReq) Rel(link RelName, resp *ReposGetPunchCardStatsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetPunchCardStatsResponseBody is a response body for ReposGetPunchCardStats

https://developer.github.com/v3/repos/statistics/#get-the-hourly-commit-count-for-each-day
*/
type ReposGetPunchCardStatsResponseBody []components.CodeFrequencyStat

/*
ReposGetPunchCardStatsResponse is a response for ReposGetPunchCardStats

https://developer.github.com/v3/repos/statistics/#get-the-hourly-commit-count-for-each-day
*/
type ReposGetPunchCardStatsResponse struct {
	response
	request *ReposGetPunchCardStatsReq
	Data    ReposGetPunchCardStatsResponseBody
}

/*
ReposGetReadme performs requests for "repos/get-readme"

Get a repository README.

  GET /repos/{owner}/{repo}/readme

https://developer.github.com/v3/repos/contents/#get-a-repository-readme
*/
func ReposGetReadme(ctx context.Context, req *ReposGetReadmeReq, opt ...RequestOption) (*ReposGetReadmeResponse, error) {
	if req == nil {
		req = new(ReposGetReadmeReq)
	}
	resp := &ReposGetReadmeResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetReadmeResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetReadme performs requests for "repos/get-readme"

Get a repository README.

  GET /repos/{owner}/{repo}/readme

https://developer.github.com/v3/repos/contents/#get-a-repository-readme
*/
func (c Client) ReposGetReadme(ctx context.Context, req *ReposGetReadmeReq, opt ...RequestOption) (*ReposGetReadmeResponse, error) {
	return ReposGetReadme(ctx, req, append(c, opt...)...)
}

/*
ReposGetReadmeReq is request data for Client.ReposGetReadme

https://developer.github.com/v3/repos/contents/#get-a-repository-readme
*/
type ReposGetReadmeReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	The name of the commit/branch/tag. Default: the repositorys default branch
	(usually `master`)
	*/
	Ref *string
}

func (r *ReposGetReadmeReq) url() string {
	return r._url
}

func (r *ReposGetReadmeReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/readme", r.Owner, r.Repo)
}

func (r *ReposGetReadmeReq) method() string {
	return "GET"
}

func (r *ReposGetReadmeReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}
	return query
}

func (r *ReposGetReadmeReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReadmeReq) body() interface{} {
	return nil
}

func (r *ReposGetReadmeReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetReadmeReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetReadmeReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetReadmeReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReadmeReq) Rel(link RelName, resp *ReposGetReadmeResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetReadmeResponseBody is a response body for ReposGetReadme

https://developer.github.com/v3/repos/contents/#get-a-repository-readme
*/
type ReposGetReadmeResponseBody components.ContentFile

/*
ReposGetReadmeResponse is a response for ReposGetReadme

https://developer.github.com/v3/repos/contents/#get-a-repository-readme
*/
type ReposGetReadmeResponse struct {
	response
	request *ReposGetReadmeReq
	Data    ReposGetReadmeResponseBody
}

/*
ReposGetRelease performs requests for "repos/get-release"

Get a release.

  GET /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#get-a-release
*/
func ReposGetRelease(ctx context.Context, req *ReposGetReleaseReq, opt ...RequestOption) (*ReposGetReleaseResponse, error) {
	if req == nil {
		req = new(ReposGetReleaseReq)
	}
	resp := &ReposGetReleaseResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetReleaseResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetRelease performs requests for "repos/get-release"

Get a release.

  GET /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#get-a-release
*/
func (c Client) ReposGetRelease(ctx context.Context, req *ReposGetReleaseReq, opt ...RequestOption) (*ReposGetReleaseResponse, error) {
	return ReposGetRelease(ctx, req, append(c, opt...)...)
}

/*
ReposGetReleaseReq is request data for Client.ReposGetRelease

https://developer.github.com/v3/repos/releases/#get-a-release
*/
type ReposGetReleaseReq struct {
	_url      string
	Owner     string
	Repo      string
	ReleaseId int64
}

func (r *ReposGetReleaseReq) url() string {
	return r._url
}

func (r *ReposGetReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposGetReleaseReq) method() string {
	return "GET"
}

func (r *ReposGetReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReleaseReq) body() interface{} {
	return nil
}

func (r *ReposGetReleaseReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetReleaseReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetReleaseReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetReleaseReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReleaseReq) Rel(link RelName, resp *ReposGetReleaseResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetReleaseResponseBody is a response body for ReposGetRelease

https://developer.github.com/v3/repos/releases/#get-a-release
*/
type ReposGetReleaseResponseBody components.Release2

/*
ReposGetReleaseResponse is a response for ReposGetRelease

https://developer.github.com/v3/repos/releases/#get-a-release
*/
type ReposGetReleaseResponse struct {
	response
	request *ReposGetReleaseReq
	Data    ReposGetReleaseResponseBody
}

/*
ReposGetReleaseAsset performs requests for "repos/get-release-asset"

Get a release asset.

  GET /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#get-a-release-asset
*/
func ReposGetReleaseAsset(ctx context.Context, req *ReposGetReleaseAssetReq, opt ...RequestOption) (*ReposGetReleaseAssetResponse, error) {
	if req == nil {
		req = new(ReposGetReleaseAssetReq)
	}
	resp := &ReposGetReleaseAssetResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetReleaseAssetResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetReleaseAsset performs requests for "repos/get-release-asset"

Get a release asset.

  GET /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#get-a-release-asset
*/
func (c Client) ReposGetReleaseAsset(ctx context.Context, req *ReposGetReleaseAssetReq, opt ...RequestOption) (*ReposGetReleaseAssetResponse, error) {
	return ReposGetReleaseAsset(ctx, req, append(c, opt...)...)
}

/*
ReposGetReleaseAssetReq is request data for Client.ReposGetReleaseAsset

https://developer.github.com/v3/repos/releases/#get-a-release-asset
*/
type ReposGetReleaseAssetReq struct {
	_url    string
	Owner   string
	Repo    string
	AssetId int64
}

func (r *ReposGetReleaseAssetReq) url() string {
	return r._url
}

func (r *ReposGetReleaseAssetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId)
}

func (r *ReposGetReleaseAssetReq) method() string {
	return "GET"
}

func (r *ReposGetReleaseAssetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetReleaseAssetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReleaseAssetReq) body() interface{} {
	return nil
}

func (r *ReposGetReleaseAssetReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetReleaseAssetReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetReleaseAssetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReleaseAssetReq) Rel(link RelName, resp *ReposGetReleaseAssetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetReleaseAssetResponseBody is a response body for ReposGetReleaseAsset

https://developer.github.com/v3/repos/releases/#get-a-release-asset
*/
type ReposGetReleaseAssetResponseBody components.ReleaseAsset

/*
ReposGetReleaseAssetResponse is a response for ReposGetReleaseAsset

https://developer.github.com/v3/repos/releases/#get-a-release-asset
*/
type ReposGetReleaseAssetResponse struct {
	response
	request *ReposGetReleaseAssetReq
	Data    ReposGetReleaseAssetResponseBody
}

/*
ReposGetReleaseByTag performs requests for "repos/get-release-by-tag"

Get a release by tag name.

  GET /repos/{owner}/{repo}/releases/tags/{tag}

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
func ReposGetReleaseByTag(ctx context.Context, req *ReposGetReleaseByTagReq, opt ...RequestOption) (*ReposGetReleaseByTagResponse, error) {
	if req == nil {
		req = new(ReposGetReleaseByTagReq)
	}
	resp := &ReposGetReleaseByTagResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetReleaseByTagResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetReleaseByTag performs requests for "repos/get-release-by-tag"

Get a release by tag name.

  GET /repos/{owner}/{repo}/releases/tags/{tag}

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
func (c Client) ReposGetReleaseByTag(ctx context.Context, req *ReposGetReleaseByTagReq, opt ...RequestOption) (*ReposGetReleaseByTagResponse, error) {
	return ReposGetReleaseByTag(ctx, req, append(c, opt...)...)
}

/*
ReposGetReleaseByTagReq is request data for Client.ReposGetReleaseByTag

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
type ReposGetReleaseByTagReq struct {
	_url  string
	Owner string
	Repo  string
	Tag   string
}

func (r *ReposGetReleaseByTagReq) url() string {
	return r._url
}

func (r *ReposGetReleaseByTagReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/tags/%v", r.Owner, r.Repo, r.Tag)
}

func (r *ReposGetReleaseByTagReq) method() string {
	return "GET"
}

func (r *ReposGetReleaseByTagReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetReleaseByTagReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetReleaseByTagReq) body() interface{} {
	return nil
}

func (r *ReposGetReleaseByTagReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetReleaseByTagReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetReleaseByTagReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetReleaseByTagReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetReleaseByTagReq) Rel(link RelName, resp *ReposGetReleaseByTagResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetReleaseByTagResponseBody is a response body for ReposGetReleaseByTag

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
type ReposGetReleaseByTagResponseBody components.Release2

/*
ReposGetReleaseByTagResponse is a response for ReposGetReleaseByTag

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
type ReposGetReleaseByTagResponse struct {
	response
	request *ReposGetReleaseByTagReq
	Data    ReposGetReleaseByTagResponseBody
}

/*
ReposGetStatusChecksProtection performs requests for "repos/get-status-checks-protection"

Get status checks protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#get-status-checks-protection
*/
func ReposGetStatusChecksProtection(ctx context.Context, req *ReposGetStatusChecksProtectionReq, opt ...RequestOption) (*ReposGetStatusChecksProtectionResponse, error) {
	if req == nil {
		req = new(ReposGetStatusChecksProtectionReq)
	}
	resp := &ReposGetStatusChecksProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetStatusChecksProtectionResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetStatusChecksProtection performs requests for "repos/get-status-checks-protection"

Get status checks protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#get-status-checks-protection
*/
func (c Client) ReposGetStatusChecksProtection(ctx context.Context, req *ReposGetStatusChecksProtectionReq, opt ...RequestOption) (*ReposGetStatusChecksProtectionResponse, error) {
	return ReposGetStatusChecksProtection(ctx, req, append(c, opt...)...)
}

/*
ReposGetStatusChecksProtectionReq is request data for Client.ReposGetStatusChecksProtection

https://developer.github.com/v3/repos/branches/#get-status-checks-protection
*/
type ReposGetStatusChecksProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetStatusChecksProtectionReq) url() string {
	return r._url
}

func (r *ReposGetStatusChecksProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetStatusChecksProtectionReq) method() string {
	return "GET"
}

func (r *ReposGetStatusChecksProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetStatusChecksProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetStatusChecksProtectionReq) body() interface{} {
	return nil
}

func (r *ReposGetStatusChecksProtectionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetStatusChecksProtectionReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetStatusChecksProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetStatusChecksProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetStatusChecksProtectionReq) Rel(link RelName, resp *ReposGetStatusChecksProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetStatusChecksProtectionResponseBody is a response body for ReposGetStatusChecksProtection

https://developer.github.com/v3/repos/branches/#get-status-checks-protection
*/
type ReposGetStatusChecksProtectionResponseBody components.StatusCheckPolicy

/*
ReposGetStatusChecksProtectionResponse is a response for ReposGetStatusChecksProtection

https://developer.github.com/v3/repos/branches/#get-status-checks-protection
*/
type ReposGetStatusChecksProtectionResponse struct {
	response
	request *ReposGetStatusChecksProtectionReq
	Data    ReposGetStatusChecksProtectionResponseBody
}

/*
ReposGetTeamsWithAccessToProtectedBranch performs requests for "repos/get-teams-with-access-to-protected-branch"

Get teams with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-the-protected-branch
*/
func ReposGetTeamsWithAccessToProtectedBranch(ctx context.Context, req *ReposGetTeamsWithAccessToProtectedBranchReq, opt ...RequestOption) (*ReposGetTeamsWithAccessToProtectedBranchResponse, error) {
	if req == nil {
		req = new(ReposGetTeamsWithAccessToProtectedBranchReq)
	}
	resp := &ReposGetTeamsWithAccessToProtectedBranchResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetTeamsWithAccessToProtectedBranchResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetTeamsWithAccessToProtectedBranch performs requests for "repos/get-teams-with-access-to-protected-branch"

Get teams with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-the-protected-branch
*/
func (c Client) ReposGetTeamsWithAccessToProtectedBranch(ctx context.Context, req *ReposGetTeamsWithAccessToProtectedBranchReq, opt ...RequestOption) (*ReposGetTeamsWithAccessToProtectedBranchResponse, error) {
	return ReposGetTeamsWithAccessToProtectedBranch(ctx, req, append(c, opt...)...)
}

/*
ReposGetTeamsWithAccessToProtectedBranchReq is request data for Client.ReposGetTeamsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-the-protected-branch
*/
type ReposGetTeamsWithAccessToProtectedBranchReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) url() string {
	return r._url
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) method() string {
	return "GET"
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) body() interface{} {
	return nil
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetTeamsWithAccessToProtectedBranchReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetTeamsWithAccessToProtectedBranchReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetTeamsWithAccessToProtectedBranchReq) Rel(link RelName, resp *ReposGetTeamsWithAccessToProtectedBranchResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetTeamsWithAccessToProtectedBranchResponseBody is a response body for ReposGetTeamsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-the-protected-branch
*/
type ReposGetTeamsWithAccessToProtectedBranchResponseBody []components.Team

/*
ReposGetTeamsWithAccessToProtectedBranchResponse is a response for ReposGetTeamsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-the-protected-branch
*/
type ReposGetTeamsWithAccessToProtectedBranchResponse struct {
	response
	request *ReposGetTeamsWithAccessToProtectedBranchReq
	Data    ReposGetTeamsWithAccessToProtectedBranchResponseBody
}

/*
ReposGetTopPaths performs requests for "repos/get-top-paths"

Get top referral paths.

  GET /repos/{owner}/{repo}/traffic/popular/paths

https://developer.github.com/v3/repos/traffic/#get-top-referral-paths
*/
func ReposGetTopPaths(ctx context.Context, req *ReposGetTopPathsReq, opt ...RequestOption) (*ReposGetTopPathsResponse, error) {
	if req == nil {
		req = new(ReposGetTopPathsReq)
	}
	resp := &ReposGetTopPathsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetTopPathsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetTopPaths performs requests for "repos/get-top-paths"

Get top referral paths.

  GET /repos/{owner}/{repo}/traffic/popular/paths

https://developer.github.com/v3/repos/traffic/#get-top-referral-paths
*/
func (c Client) ReposGetTopPaths(ctx context.Context, req *ReposGetTopPathsReq, opt ...RequestOption) (*ReposGetTopPathsResponse, error) {
	return ReposGetTopPaths(ctx, req, append(c, opt...)...)
}

/*
ReposGetTopPathsReq is request data for Client.ReposGetTopPaths

https://developer.github.com/v3/repos/traffic/#get-top-referral-paths
*/
type ReposGetTopPathsReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetTopPathsReq) url() string {
	return r._url
}

func (r *ReposGetTopPathsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/traffic/popular/paths", r.Owner, r.Repo)
}

func (r *ReposGetTopPathsReq) method() string {
	return "GET"
}

func (r *ReposGetTopPathsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetTopPathsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetTopPathsReq) body() interface{} {
	return nil
}

func (r *ReposGetTopPathsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetTopPathsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetTopPathsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetTopPathsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetTopPathsReq) Rel(link RelName, resp *ReposGetTopPathsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetTopPathsResponseBody is a response body for ReposGetTopPaths

https://developer.github.com/v3/repos/traffic/#get-top-referral-paths
*/
type ReposGetTopPathsResponseBody []components.ContentTraffic

/*
ReposGetTopPathsResponse is a response for ReposGetTopPaths

https://developer.github.com/v3/repos/traffic/#get-top-referral-paths
*/
type ReposGetTopPathsResponse struct {
	response
	request *ReposGetTopPathsReq
	Data    ReposGetTopPathsResponseBody
}

/*
ReposGetTopReferrers performs requests for "repos/get-top-referrers"

Get top referral sources.

  GET /repos/{owner}/{repo}/traffic/popular/referrers

https://developer.github.com/v3/repos/traffic/#get-top-referral-sources
*/
func ReposGetTopReferrers(ctx context.Context, req *ReposGetTopReferrersReq, opt ...RequestOption) (*ReposGetTopReferrersResponse, error) {
	if req == nil {
		req = new(ReposGetTopReferrersReq)
	}
	resp := &ReposGetTopReferrersResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetTopReferrersResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetTopReferrers performs requests for "repos/get-top-referrers"

Get top referral sources.

  GET /repos/{owner}/{repo}/traffic/popular/referrers

https://developer.github.com/v3/repos/traffic/#get-top-referral-sources
*/
func (c Client) ReposGetTopReferrers(ctx context.Context, req *ReposGetTopReferrersReq, opt ...RequestOption) (*ReposGetTopReferrersResponse, error) {
	return ReposGetTopReferrers(ctx, req, append(c, opt...)...)
}

/*
ReposGetTopReferrersReq is request data for Client.ReposGetTopReferrers

https://developer.github.com/v3/repos/traffic/#get-top-referral-sources
*/
type ReposGetTopReferrersReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposGetTopReferrersReq) url() string {
	return r._url
}

func (r *ReposGetTopReferrersReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/traffic/popular/referrers", r.Owner, r.Repo)
}

func (r *ReposGetTopReferrersReq) method() string {
	return "GET"
}

func (r *ReposGetTopReferrersReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetTopReferrersReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetTopReferrersReq) body() interface{} {
	return nil
}

func (r *ReposGetTopReferrersReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetTopReferrersReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetTopReferrersReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetTopReferrersReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetTopReferrersReq) Rel(link RelName, resp *ReposGetTopReferrersResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetTopReferrersResponseBody is a response body for ReposGetTopReferrers

https://developer.github.com/v3/repos/traffic/#get-top-referral-sources
*/
type ReposGetTopReferrersResponseBody []components.ReferrerTraffic

/*
ReposGetTopReferrersResponse is a response for ReposGetTopReferrers

https://developer.github.com/v3/repos/traffic/#get-top-referral-sources
*/
type ReposGetTopReferrersResponse struct {
	response
	request *ReposGetTopReferrersReq
	Data    ReposGetTopReferrersResponseBody
}

/*
ReposGetUsersWithAccessToProtectedBranch performs requests for "repos/get-users-with-access-to-protected-branch"

Get users with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-the-protected-branch
*/
func ReposGetUsersWithAccessToProtectedBranch(ctx context.Context, req *ReposGetUsersWithAccessToProtectedBranchReq, opt ...RequestOption) (*ReposGetUsersWithAccessToProtectedBranchResponse, error) {
	if req == nil {
		req = new(ReposGetUsersWithAccessToProtectedBranchReq)
	}
	resp := &ReposGetUsersWithAccessToProtectedBranchResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetUsersWithAccessToProtectedBranchResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetUsersWithAccessToProtectedBranch performs requests for "repos/get-users-with-access-to-protected-branch"

Get users with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-the-protected-branch
*/
func (c Client) ReposGetUsersWithAccessToProtectedBranch(ctx context.Context, req *ReposGetUsersWithAccessToProtectedBranchReq, opt ...RequestOption) (*ReposGetUsersWithAccessToProtectedBranchResponse, error) {
	return ReposGetUsersWithAccessToProtectedBranch(ctx, req, append(c, opt...)...)
}

/*
ReposGetUsersWithAccessToProtectedBranchReq is request data for Client.ReposGetUsersWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-the-protected-branch
*/
type ReposGetUsersWithAccessToProtectedBranchReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) url() string {
	return r._url
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch)
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) method() string {
	return "GET"
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) body() interface{} {
	return nil
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetUsersWithAccessToProtectedBranchReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetUsersWithAccessToProtectedBranchReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetUsersWithAccessToProtectedBranchReq) Rel(link RelName, resp *ReposGetUsersWithAccessToProtectedBranchResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetUsersWithAccessToProtectedBranchResponseBody is a response body for ReposGetUsersWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-the-protected-branch
*/
type ReposGetUsersWithAccessToProtectedBranchResponseBody []components.SimpleUser

/*
ReposGetUsersWithAccessToProtectedBranchResponse is a response for ReposGetUsersWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-the-protected-branch
*/
type ReposGetUsersWithAccessToProtectedBranchResponse struct {
	response
	request *ReposGetUsersWithAccessToProtectedBranchReq
	Data    ReposGetUsersWithAccessToProtectedBranchResponseBody
}

/*
ReposGetViews performs requests for "repos/get-views"

Get page views.

  GET /repos/{owner}/{repo}/traffic/views

https://developer.github.com/v3/repos/traffic/#get-page-views
*/
func ReposGetViews(ctx context.Context, req *ReposGetViewsReq, opt ...RequestOption) (*ReposGetViewsResponse, error) {
	if req == nil {
		req = new(ReposGetViewsReq)
	}
	resp := &ReposGetViewsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetViewsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetViews performs requests for "repos/get-views"

Get page views.

  GET /repos/{owner}/{repo}/traffic/views

https://developer.github.com/v3/repos/traffic/#get-page-views
*/
func (c Client) ReposGetViews(ctx context.Context, req *ReposGetViewsReq, opt ...RequestOption) (*ReposGetViewsResponse, error) {
	return ReposGetViews(ctx, req, append(c, opt...)...)
}

/*
ReposGetViewsReq is request data for Client.ReposGetViews

https://developer.github.com/v3/repos/traffic/#get-page-views
*/
type ReposGetViewsReq struct {
	_url  string
	Owner string
	Repo  string

	// Must be one of: `day`, `week`.
	Per *string
}

func (r *ReposGetViewsReq) url() string {
	return r._url
}

func (r *ReposGetViewsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/traffic/views", r.Owner, r.Repo)
}

func (r *ReposGetViewsReq) method() string {
	return "GET"
}

func (r *ReposGetViewsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Per != nil {
		query.Set("per", *r.Per)
	}
	return query
}

func (r *ReposGetViewsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetViewsReq) body() interface{} {
	return nil
}

func (r *ReposGetViewsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetViewsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetViewsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetViewsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetViewsReq) Rel(link RelName, resp *ReposGetViewsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetViewsResponseBody is a response body for ReposGetViews

https://developer.github.com/v3/repos/traffic/#get-page-views
*/
type ReposGetViewsResponseBody components.ViewTraffic

/*
ReposGetViewsResponse is a response for ReposGetViews

https://developer.github.com/v3/repos/traffic/#get-page-views
*/
type ReposGetViewsResponse struct {
	response
	request *ReposGetViewsReq
	Data    ReposGetViewsResponseBody
}

/*
ReposGetWebhook performs requests for "repos/get-webhook"

Get a repository webhook.

  GET /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#get-a-repository-webhook
*/
func ReposGetWebhook(ctx context.Context, req *ReposGetWebhookReq, opt ...RequestOption) (*ReposGetWebhookResponse, error) {
	if req == nil {
		req = new(ReposGetWebhookReq)
	}
	resp := &ReposGetWebhookResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposGetWebhookResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposGetWebhook performs requests for "repos/get-webhook"

Get a repository webhook.

  GET /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#get-a-repository-webhook
*/
func (c Client) ReposGetWebhook(ctx context.Context, req *ReposGetWebhookReq, opt ...RequestOption) (*ReposGetWebhookResponse, error) {
	return ReposGetWebhook(ctx, req, append(c, opt...)...)
}

/*
ReposGetWebhookReq is request data for Client.ReposGetWebhook

https://developer.github.com/v3/repos/hooks/#get-a-repository-webhook
*/
type ReposGetWebhookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

func (r *ReposGetWebhookReq) url() string {
	return r._url
}

func (r *ReposGetWebhookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId)
}

func (r *ReposGetWebhookReq) method() string {
	return "GET"
}

func (r *ReposGetWebhookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposGetWebhookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposGetWebhookReq) body() interface{} {
	return nil
}

func (r *ReposGetWebhookReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposGetWebhookReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposGetWebhookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposGetWebhookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposGetWebhookReq) Rel(link RelName, resp *ReposGetWebhookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposGetWebhookResponseBody is a response body for ReposGetWebhook

https://developer.github.com/v3/repos/hooks/#get-a-repository-webhook
*/
type ReposGetWebhookResponseBody components.Hook

/*
ReposGetWebhookResponse is a response for ReposGetWebhook

https://developer.github.com/v3/repos/hooks/#get-a-repository-webhook
*/
type ReposGetWebhookResponse struct {
	response
	request *ReposGetWebhookReq
	Data    ReposGetWebhookResponseBody
}

/*
ReposListBranches performs requests for "repos/list-branches"

List branches.

  GET /repos/{owner}/{repo}/branches

https://developer.github.com/v3/repos/branches/#list-branches
*/
func ReposListBranches(ctx context.Context, req *ReposListBranchesReq, opt ...RequestOption) (*ReposListBranchesResponse, error) {
	if req == nil {
		req = new(ReposListBranchesReq)
	}
	resp := &ReposListBranchesResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListBranchesResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListBranches performs requests for "repos/list-branches"

List branches.

  GET /repos/{owner}/{repo}/branches

https://developer.github.com/v3/repos/branches/#list-branches
*/
func (c Client) ReposListBranches(ctx context.Context, req *ReposListBranchesReq, opt ...RequestOption) (*ReposListBranchesResponse, error) {
	return ReposListBranches(ctx, req, append(c, opt...)...)
}

/*
ReposListBranchesReq is request data for Client.ReposListBranches

https://developer.github.com/v3/repos/branches/#list-branches
*/
type ReposListBranchesReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Setting to `true` returns only protected branches. When set to `false`, only
	unprotected branches are returned. Omitting this parameter returns all branches.
	*/
	Protected *bool

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListBranchesReq) url() string {
	return r._url
}

func (r *ReposListBranchesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches", r.Owner, r.Repo)
}

func (r *ReposListBranchesReq) method() string {
	return "GET"
}

func (r *ReposListBranchesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Protected != nil {
		query.Set("protected", strconv.FormatBool(*r.Protected))
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListBranchesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListBranchesReq) body() interface{} {
	return nil
}

func (r *ReposListBranchesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListBranchesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListBranchesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListBranchesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListBranchesReq) Rel(link RelName, resp *ReposListBranchesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListBranchesResponseBody is a response body for ReposListBranches

https://developer.github.com/v3/repos/branches/#list-branches
*/
type ReposListBranchesResponseBody []components.ShortBranchWithProtection

/*
ReposListBranchesResponse is a response for ReposListBranches

https://developer.github.com/v3/repos/branches/#list-branches
*/
type ReposListBranchesResponse struct {
	response
	request *ReposListBranchesReq
	Data    ReposListBranchesResponseBody
}

/*
ReposListBranchesForHeadCommit performs requests for "repos/list-branches-for-head-commit"

List branches for HEAD commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
func ReposListBranchesForHeadCommit(ctx context.Context, req *ReposListBranchesForHeadCommitReq, opt ...RequestOption) (*ReposListBranchesForHeadCommitResponse, error) {
	if req == nil {
		req = new(ReposListBranchesForHeadCommitReq)
	}
	resp := &ReposListBranchesForHeadCommitResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListBranchesForHeadCommitResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListBranchesForHeadCommit performs requests for "repos/list-branches-for-head-commit"

List branches for HEAD commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
func (c Client) ReposListBranchesForHeadCommit(ctx context.Context, req *ReposListBranchesForHeadCommitReq, opt ...RequestOption) (*ReposListBranchesForHeadCommitResponse, error) {
	return ReposListBranchesForHeadCommit(ctx, req, append(c, opt...)...)
}

/*
ReposListBranchesForHeadCommitReq is request data for Client.ReposListBranchesForHeadCommit

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
type ReposListBranchesForHeadCommitReq struct {
	_url      string
	Owner     string
	Repo      string
	CommitSha string

	/*
	Listing branches or pull requests for a commit in the Commits API is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-04-11-pulls-branches-for-commit/)
	for more details. To access the new endpoints during the preview period, you
	must set this to true.
	*/
	GrootPreview bool
}

func (r *ReposListBranchesForHeadCommitReq) url() string {
	return r._url
}

func (r *ReposListBranchesForHeadCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/branches-where-head", r.Owner, r.Repo, r.CommitSha)
}

func (r *ReposListBranchesForHeadCommitReq) method() string {
	return "GET"
}

func (r *ReposListBranchesForHeadCommitReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposListBranchesForHeadCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"groot": r.GrootPreview}
	if requiredPreviews {
		previewVals["groot"] = true
	}
	if allPreviews {
		previewVals["groot"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListBranchesForHeadCommitReq) body() interface{} {
	return nil
}

func (r *ReposListBranchesForHeadCommitReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListBranchesForHeadCommitReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListBranchesForHeadCommitReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListBranchesForHeadCommitReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListBranchesForHeadCommitReq) Rel(link RelName, resp *ReposListBranchesForHeadCommitResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListBranchesForHeadCommitResponseBody is a response body for ReposListBranchesForHeadCommit

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
type ReposListBranchesForHeadCommitResponseBody []components.BranchShort

/*
ReposListBranchesForHeadCommitResponse is a response for ReposListBranchesForHeadCommit

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
type ReposListBranchesForHeadCommitResponse struct {
	response
	request *ReposListBranchesForHeadCommitReq
	Data    ReposListBranchesForHeadCommitResponseBody
}

/*
ReposListCollaborators performs requests for "repos/list-collaborators"

List repository collaborators.

  GET /repos/{owner}/{repo}/collaborators

https://developer.github.com/v3/repos/collaborators/#list-repository-collaborators
*/
func ReposListCollaborators(ctx context.Context, req *ReposListCollaboratorsReq, opt ...RequestOption) (*ReposListCollaboratorsResponse, error) {
	if req == nil {
		req = new(ReposListCollaboratorsReq)
	}
	resp := &ReposListCollaboratorsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListCollaboratorsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCollaborators performs requests for "repos/list-collaborators"

List repository collaborators.

  GET /repos/{owner}/{repo}/collaborators

https://developer.github.com/v3/repos/collaborators/#list-repository-collaborators
*/
func (c Client) ReposListCollaborators(ctx context.Context, req *ReposListCollaboratorsReq, opt ...RequestOption) (*ReposListCollaboratorsResponse, error) {
	return ReposListCollaborators(ctx, req, append(c, opt...)...)
}

/*
ReposListCollaboratorsReq is request data for Client.ReposListCollaborators

https://developer.github.com/v3/repos/collaborators/#list-repository-collaborators
*/
type ReposListCollaboratorsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Filter collaborators returned by their affiliation. Can be one of:
	\* `outside`: All outside collaborators of an organization-owned repository.
	\* `direct`: All collaborators with permissions to an organization-owned
	repository, regardless of organization membership status.
	\* `all`: All collaborators the authenticated user can see.
	*/
	Affiliation *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListCollaboratorsReq) url() string {
	return r._url
}

func (r *ReposListCollaboratorsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators", r.Owner, r.Repo)
}

func (r *ReposListCollaboratorsReq) method() string {
	return "GET"
}

func (r *ReposListCollaboratorsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListCollaboratorsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListCollaboratorsReq) body() interface{} {
	return nil
}

func (r *ReposListCollaboratorsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListCollaboratorsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListCollaboratorsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListCollaboratorsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCollaboratorsReq) Rel(link RelName, resp *ReposListCollaboratorsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCollaboratorsResponseBody is a response body for ReposListCollaborators

https://developer.github.com/v3/repos/collaborators/#list-repository-collaborators
*/
type ReposListCollaboratorsResponseBody []components.Collaborator

/*
ReposListCollaboratorsResponse is a response for ReposListCollaborators

https://developer.github.com/v3/repos/collaborators/#list-repository-collaborators
*/
type ReposListCollaboratorsResponse struct {
	response
	request *ReposListCollaboratorsReq
	Data    ReposListCollaboratorsResponseBody
}

/*
ReposListCommentsForCommit performs requests for "repos/list-comments-for-commit"

List commit comments.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments
*/
func ReposListCommentsForCommit(ctx context.Context, req *ReposListCommentsForCommitReq, opt ...RequestOption) (*ReposListCommentsForCommitResponse, error) {
	if req == nil {
		req = new(ReposListCommentsForCommitReq)
	}
	resp := &ReposListCommentsForCommitResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListCommentsForCommitResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCommentsForCommit performs requests for "repos/list-comments-for-commit"

List commit comments.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments
*/
func (c Client) ReposListCommentsForCommit(ctx context.Context, req *ReposListCommentsForCommitReq, opt ...RequestOption) (*ReposListCommentsForCommitResponse, error) {
	return ReposListCommentsForCommit(ctx, req, append(c, opt...)...)
}

/*
ReposListCommentsForCommitReq is request data for Client.ReposListCommentsForCommit

https://developer.github.com/v3/repos/comments/#list-commit-comments
*/
type ReposListCommentsForCommitReq struct {
	_url      string
	Owner     string
	Repo      string
	CommitSha string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReposListCommentsForCommitReq) url() string {
	return r._url
}

func (r *ReposListCommentsForCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/comments", r.Owner, r.Repo, r.CommitSha)
}

func (r *ReposListCommentsForCommitReq) method() string {
	return "GET"
}

func (r *ReposListCommentsForCommitReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListCommentsForCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListCommentsForCommitReq) body() interface{} {
	return nil
}

func (r *ReposListCommentsForCommitReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListCommentsForCommitReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListCommentsForCommitReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListCommentsForCommitReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCommentsForCommitReq) Rel(link RelName, resp *ReposListCommentsForCommitResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCommentsForCommitResponseBody is a response body for ReposListCommentsForCommit

https://developer.github.com/v3/repos/comments/#list-commit-comments
*/
type ReposListCommentsForCommitResponseBody []components.CommitComment

/*
ReposListCommentsForCommitResponse is a response for ReposListCommentsForCommit

https://developer.github.com/v3/repos/comments/#list-commit-comments
*/
type ReposListCommentsForCommitResponse struct {
	response
	request *ReposListCommentsForCommitReq
	Data    ReposListCommentsForCommitResponseBody
}

/*
ReposListCommitCommentsForRepo performs requests for "repos/list-commit-comments-for-repo"

List commit comments for a repository.

  GET /repos/{owner}/{repo}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
func ReposListCommitCommentsForRepo(ctx context.Context, req *ReposListCommitCommentsForRepoReq, opt ...RequestOption) (*ReposListCommitCommentsForRepoResponse, error) {
	if req == nil {
		req = new(ReposListCommitCommentsForRepoReq)
	}
	resp := &ReposListCommitCommentsForRepoResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListCommitCommentsForRepoResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCommitCommentsForRepo performs requests for "repos/list-commit-comments-for-repo"

List commit comments for a repository.

  GET /repos/{owner}/{repo}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
func (c Client) ReposListCommitCommentsForRepo(ctx context.Context, req *ReposListCommitCommentsForRepoReq, opt ...RequestOption) (*ReposListCommitCommentsForRepoResponse, error) {
	return ReposListCommitCommentsForRepo(ctx, req, append(c, opt...)...)
}

/*
ReposListCommitCommentsForRepoReq is request data for Client.ReposListCommitCommentsForRepo

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
type ReposListCommitCommentsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *ReposListCommitCommentsForRepoReq) url() string {
	return r._url
}

func (r *ReposListCommitCommentsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments", r.Owner, r.Repo)
}

func (r *ReposListCommitCommentsForRepoReq) method() string {
	return "GET"
}

func (r *ReposListCommitCommentsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListCommitCommentsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListCommitCommentsForRepoReq) body() interface{} {
	return nil
}

func (r *ReposListCommitCommentsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListCommitCommentsForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListCommitCommentsForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListCommitCommentsForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCommitCommentsForRepoReq) Rel(link RelName, resp *ReposListCommitCommentsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCommitCommentsForRepoResponseBody is a response body for ReposListCommitCommentsForRepo

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
type ReposListCommitCommentsForRepoResponseBody []components.CommitComment

/*
ReposListCommitCommentsForRepoResponse is a response for ReposListCommitCommentsForRepo

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
type ReposListCommitCommentsForRepoResponse struct {
	response
	request *ReposListCommitCommentsForRepoReq
	Data    ReposListCommitCommentsForRepoResponseBody
}

/*
ReposListCommitStatusesForRef performs requests for "repos/list-commit-statuses-for-ref"

List commit statuses for a reference.

  GET /repos/{owner}/{repo}/commits/{ref}/statuses

https://developer.github.com/v3/repos/statuses/#list-commit-statuses-for-a-reference
*/
func ReposListCommitStatusesForRef(ctx context.Context, req *ReposListCommitStatusesForRefReq, opt ...RequestOption) (*ReposListCommitStatusesForRefResponse, error) {
	if req == nil {
		req = new(ReposListCommitStatusesForRefReq)
	}
	resp := &ReposListCommitStatusesForRefResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListCommitStatusesForRefResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCommitStatusesForRef performs requests for "repos/list-commit-statuses-for-ref"

List commit statuses for a reference.

  GET /repos/{owner}/{repo}/commits/{ref}/statuses

https://developer.github.com/v3/repos/statuses/#list-commit-statuses-for-a-reference
*/
func (c Client) ReposListCommitStatusesForRef(ctx context.Context, req *ReposListCommitStatusesForRefReq, opt ...RequestOption) (*ReposListCommitStatusesForRefResponse, error) {
	return ReposListCommitStatusesForRef(ctx, req, append(c, opt...)...)
}

/*
ReposListCommitStatusesForRefReq is request data for Client.ReposListCommitStatusesForRef

https://developer.github.com/v3/repos/statuses/#list-commit-statuses-for-a-reference
*/
type ReposListCommitStatusesForRefReq struct {
	_url  string
	Owner string
	Repo  string
	Ref   string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListCommitStatusesForRefReq) url() string {
	return r._url
}

func (r *ReposListCommitStatusesForRefReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/statuses", r.Owner, r.Repo, r.Ref)
}

func (r *ReposListCommitStatusesForRefReq) method() string {
	return "GET"
}

func (r *ReposListCommitStatusesForRefReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListCommitStatusesForRefReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListCommitStatusesForRefReq) body() interface{} {
	return nil
}

func (r *ReposListCommitStatusesForRefReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListCommitStatusesForRefReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListCommitStatusesForRefReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListCommitStatusesForRefReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCommitStatusesForRefReq) Rel(link RelName, resp *ReposListCommitStatusesForRefResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCommitStatusesForRefResponseBody is a response body for ReposListCommitStatusesForRef

https://developer.github.com/v3/repos/statuses/#list-commit-statuses-for-a-reference
*/
type ReposListCommitStatusesForRefResponseBody []components.Status

/*
ReposListCommitStatusesForRefResponse is a response for ReposListCommitStatusesForRef

https://developer.github.com/v3/repos/statuses/#list-commit-statuses-for-a-reference
*/
type ReposListCommitStatusesForRefResponse struct {
	response
	request *ReposListCommitStatusesForRefReq
	Data    ReposListCommitStatusesForRefResponseBody
}

/*
ReposListCommits performs requests for "repos/list-commits"

List commits.

  GET /repos/{owner}/{repo}/commits

https://developer.github.com/v3/repos/commits/#list-commits
*/
func ReposListCommits(ctx context.Context, req *ReposListCommitsReq, opt ...RequestOption) (*ReposListCommitsResponse, error) {
	if req == nil {
		req = new(ReposListCommitsReq)
	}
	resp := &ReposListCommitsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListCommitsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListCommits performs requests for "repos/list-commits"

List commits.

  GET /repos/{owner}/{repo}/commits

https://developer.github.com/v3/repos/commits/#list-commits
*/
func (c Client) ReposListCommits(ctx context.Context, req *ReposListCommitsReq, opt ...RequestOption) (*ReposListCommitsResponse, error) {
	return ReposListCommits(ctx, req, append(c, opt...)...)
}

/*
ReposListCommitsReq is request data for Client.ReposListCommits

https://developer.github.com/v3/repos/commits/#list-commits
*/
type ReposListCommitsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	SHA or branch to start listing commits from. Default: the repositorys default
	branch (usually `master`).
	*/
	Sha *string

	// Only commits containing this file path will be returned.
	Path *string

	// GitHub login or email address by which to filter by commit author.
	Author *string

	/*
	Only commits after this date will be returned. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only commits before this date will be returned. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Until *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListCommitsReq) url() string {
	return r._url
}

func (r *ReposListCommitsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits", r.Owner, r.Repo)
}

func (r *ReposListCommitsReq) method() string {
	return "GET"
}

func (r *ReposListCommitsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sha != nil {
		query.Set("sha", *r.Sha)
	}
	if r.Path != nil {
		query.Set("path", *r.Path)
	}
	if r.Author != nil {
		query.Set("author", *r.Author)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Until != nil {
		query.Set("until", *r.Until)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListCommitsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListCommitsReq) body() interface{} {
	return nil
}

func (r *ReposListCommitsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListCommitsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListCommitsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListCommitsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListCommitsReq) Rel(link RelName, resp *ReposListCommitsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListCommitsResponseBody is a response body for ReposListCommits

https://developer.github.com/v3/repos/commits/#list-commits
*/
type ReposListCommitsResponseBody []components.SimpleCommit

/*
ReposListCommitsResponse is a response for ReposListCommits

https://developer.github.com/v3/repos/commits/#list-commits
*/
type ReposListCommitsResponse struct {
	response
	request *ReposListCommitsReq
	Data    ReposListCommitsResponseBody
}

/*
ReposListContributors performs requests for "repos/list-contributors"

List repository contributors.

  GET /repos/{owner}/{repo}/contributors

https://developer.github.com/v3/repos/#list-repository-contributors
*/
func ReposListContributors(ctx context.Context, req *ReposListContributorsReq, opt ...RequestOption) (*ReposListContributorsResponse, error) {
	if req == nil {
		req = new(ReposListContributorsReq)
	}
	resp := &ReposListContributorsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListContributorsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListContributors performs requests for "repos/list-contributors"

List repository contributors.

  GET /repos/{owner}/{repo}/contributors

https://developer.github.com/v3/repos/#list-repository-contributors
*/
func (c Client) ReposListContributors(ctx context.Context, req *ReposListContributorsReq, opt ...RequestOption) (*ReposListContributorsResponse, error) {
	return ReposListContributors(ctx, req, append(c, opt...)...)
}

/*
ReposListContributorsReq is request data for Client.ReposListContributors

https://developer.github.com/v3/repos/#list-repository-contributors
*/
type ReposListContributorsReq struct {
	_url  string
	Owner string
	Repo  string

	// Set to `1` or `true` to include anonymous contributors in results.
	Anon *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListContributorsReq) url() string {
	return r._url
}

func (r *ReposListContributorsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/contributors", r.Owner, r.Repo)
}

func (r *ReposListContributorsReq) method() string {
	return "GET"
}

func (r *ReposListContributorsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Anon != nil {
		query.Set("anon", *r.Anon)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListContributorsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListContributorsReq) body() interface{} {
	return nil
}

func (r *ReposListContributorsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListContributorsReq) validStatuses() []int {
	return []int{200, 204}
}

func (r *ReposListContributorsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListContributorsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListContributorsReq) Rel(link RelName, resp *ReposListContributorsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListContributorsResponseBody is a response body for ReposListContributors

https://developer.github.com/v3/repos/#list-repository-contributors
*/
type ReposListContributorsResponseBody []components.Contributor

/*
ReposListContributorsResponse is a response for ReposListContributors

https://developer.github.com/v3/repos/#list-repository-contributors
*/
type ReposListContributorsResponse struct {
	response
	request *ReposListContributorsReq
	Data    ReposListContributorsResponseBody
}

/*
ReposListDeployKeys performs requests for "repos/list-deploy-keys"

List deploy keys.

  GET /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
func ReposListDeployKeys(ctx context.Context, req *ReposListDeployKeysReq, opt ...RequestOption) (*ReposListDeployKeysResponse, error) {
	if req == nil {
		req = new(ReposListDeployKeysReq)
	}
	resp := &ReposListDeployKeysResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListDeployKeysResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListDeployKeys performs requests for "repos/list-deploy-keys"

List deploy keys.

  GET /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
func (c Client) ReposListDeployKeys(ctx context.Context, req *ReposListDeployKeysReq, opt ...RequestOption) (*ReposListDeployKeysResponse, error) {
	return ReposListDeployKeys(ctx, req, append(c, opt...)...)
}

/*
ReposListDeployKeysReq is request data for Client.ReposListDeployKeys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
type ReposListDeployKeysReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListDeployKeysReq) url() string {
	return r._url
}

func (r *ReposListDeployKeysReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/keys", r.Owner, r.Repo)
}

func (r *ReposListDeployKeysReq) method() string {
	return "GET"
}

func (r *ReposListDeployKeysReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListDeployKeysReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListDeployKeysReq) body() interface{} {
	return nil
}

func (r *ReposListDeployKeysReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListDeployKeysReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListDeployKeysReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListDeployKeysReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListDeployKeysReq) Rel(link RelName, resp *ReposListDeployKeysResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListDeployKeysResponseBody is a response body for ReposListDeployKeys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
type ReposListDeployKeysResponseBody []components.DeployKey

/*
ReposListDeployKeysResponse is a response for ReposListDeployKeys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
type ReposListDeployKeysResponse struct {
	response
	request *ReposListDeployKeysReq
	Data    ReposListDeployKeysResponseBody
}

/*
ReposListDeploymentStatuses performs requests for "repos/list-deployment-statuses"

List deployment statuses.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
func ReposListDeploymentStatuses(ctx context.Context, req *ReposListDeploymentStatusesReq, opt ...RequestOption) (*ReposListDeploymentStatusesResponse, error) {
	if req == nil {
		req = new(ReposListDeploymentStatusesReq)
	}
	resp := &ReposListDeploymentStatusesResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListDeploymentStatusesResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListDeploymentStatuses performs requests for "repos/list-deployment-statuses"

List deployment statuses.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
func (c Client) ReposListDeploymentStatuses(ctx context.Context, req *ReposListDeploymentStatusesReq, opt ...RequestOption) (*ReposListDeploymentStatusesResponse, error) {
	return ReposListDeploymentStatuses(ctx, req, append(c, opt...)...)
}

/*
ReposListDeploymentStatusesReq is request data for Client.ReposListDeploymentStatuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
type ReposListDeploymentStatusesReq struct {
	_url         string
	Owner        string
	Repo         string
	DeploymentId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposListDeploymentStatusesReq) url() string {
	return r._url
}

func (r *ReposListDeploymentStatusesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses", r.Owner, r.Repo, r.DeploymentId)
}

func (r *ReposListDeploymentStatusesReq) method() string {
	return "GET"
}

func (r *ReposListDeploymentStatusesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListDeploymentStatusesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"ant-man": r.AntManPreview,
		"flash":   r.FlashPreview,
	}
	if allPreviews {
		previewVals["flash"] = true
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListDeploymentStatusesReq) body() interface{} {
	return nil
}

func (r *ReposListDeploymentStatusesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListDeploymentStatusesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListDeploymentStatusesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListDeploymentStatusesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListDeploymentStatusesReq) Rel(link RelName, resp *ReposListDeploymentStatusesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListDeploymentStatusesResponseBody is a response body for ReposListDeploymentStatuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
type ReposListDeploymentStatusesResponseBody []components.DeploymentStatus

/*
ReposListDeploymentStatusesResponse is a response for ReposListDeploymentStatuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
type ReposListDeploymentStatusesResponse struct {
	response
	request *ReposListDeploymentStatusesReq
	Data    ReposListDeploymentStatusesResponseBody
}

/*
ReposListDeployments performs requests for "repos/list-deployments"

List deployments.

  GET /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
func ReposListDeployments(ctx context.Context, req *ReposListDeploymentsReq, opt ...RequestOption) (*ReposListDeploymentsResponse, error) {
	if req == nil {
		req = new(ReposListDeploymentsReq)
	}
	resp := &ReposListDeploymentsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListDeploymentsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListDeployments performs requests for "repos/list-deployments"

List deployments.

  GET /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
func (c Client) ReposListDeployments(ctx context.Context, req *ReposListDeploymentsReq, opt ...RequestOption) (*ReposListDeploymentsResponse, error) {
	return ReposListDeployments(ctx, req, append(c, opt...)...)
}

/*
ReposListDeploymentsReq is request data for Client.ReposListDeployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
type ReposListDeploymentsReq struct {
	_url  string
	Owner string
	Repo  string

	// The SHA recorded at creation time.
	Sha *string

	// The name of the ref. This can be a branch, tag, or SHA.
	Ref *string

	// The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).
	Task *string

	/*
	The name of the environment that was deployed to (e.g., `staging` or
	`production`).
	*/
	Environment *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

func (r *ReposListDeploymentsReq) url() string {
	return r._url
}

func (r *ReposListDeploymentsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/deployments", r.Owner, r.Repo)
}

func (r *ReposListDeploymentsReq) method() string {
	return "GET"
}

func (r *ReposListDeploymentsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sha != nil {
		query.Set("sha", *r.Sha)
	}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}
	if r.Task != nil {
		query.Set("task", *r.Task)
	}
	if r.Environment != nil {
		query.Set("environment", *r.Environment)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListDeploymentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"ant-man": r.AntManPreview}
	if allPreviews {
		previewVals["ant-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListDeploymentsReq) body() interface{} {
	return nil
}

func (r *ReposListDeploymentsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListDeploymentsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListDeploymentsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListDeploymentsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListDeploymentsReq) Rel(link RelName, resp *ReposListDeploymentsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListDeploymentsResponseBody is a response body for ReposListDeployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
type ReposListDeploymentsResponseBody []components.Deployment

/*
ReposListDeploymentsResponse is a response for ReposListDeployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
type ReposListDeploymentsResponse struct {
	response
	request *ReposListDeploymentsReq
	Data    ReposListDeploymentsResponseBody
}

/*
ReposListForAuthenticatedUser performs requests for "repos/list-for-authenticated-user"

List repositories for the authenticated user.

  GET /user/repos

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
func ReposListForAuthenticatedUser(ctx context.Context, req *ReposListForAuthenticatedUserReq, opt ...RequestOption) (*ReposListForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(ReposListForAuthenticatedUserReq)
	}
	resp := &ReposListForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListForAuthenticatedUser performs requests for "repos/list-for-authenticated-user"

List repositories for the authenticated user.

  GET /user/repos

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
func (c Client) ReposListForAuthenticatedUser(ctx context.Context, req *ReposListForAuthenticatedUserReq, opt ...RequestOption) (*ReposListForAuthenticatedUserResponse, error) {
	return ReposListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ReposListForAuthenticatedUserReq is request data for Client.ReposListForAuthenticatedUser

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
type ReposListForAuthenticatedUserReq struct {
	_url string

	// Can be one of `all`, `public`, or `private`.
	Visibility *string

	/*
	Comma-separated list of values. Can include:
	\* `owner`: Repositories that are owned by the authenticated user.
	\* `collaborator`: Repositories that the user has been added to as a
	collaborator.
	\* `organization_member`: Repositories that the user has access to through being
	a member of an organization. This includes every repository on every team that
	the user is on.
	*/
	Affiliation *string

	/*
	Can be one of `all`, `owner`, `public`, `private`, `member`. Default: `all`

	Will cause a `422` error if used in the same request as **visibility** or
	**affiliation**. Will cause a `422` error if used in the same request as
	**visibility** or **affiliation**.
	*/
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *ReposListForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/repos")
}

func (r *ReposListForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ReposListForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Visibility != nil {
		query.Set("visibility", *r.Visibility)
	}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ReposListForAuthenticatedUserReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposListForAuthenticatedUserReq) validStatuses() []int {
	return []int{}
}

func (r *ReposListForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListForAuthenticatedUserReq) Rel(link RelName, resp *ReposListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListForAuthenticatedUserResponse is a response for ReposListForAuthenticatedUser

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
type ReposListForAuthenticatedUserResponse struct {
	response
	request *ReposListForAuthenticatedUserReq
}

/*
ReposListForOrg performs requests for "repos/list-for-org"

List organization repositories.

  GET /orgs/{org}/repos

https://developer.github.com/v3/repos/#list-organization-repositories
*/
func ReposListForOrg(ctx context.Context, req *ReposListForOrgReq, opt ...RequestOption) (*ReposListForOrgResponse, error) {
	if req == nil {
		req = new(ReposListForOrgReq)
	}
	resp := &ReposListForOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListForOrgResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListForOrg performs requests for "repos/list-for-org"

List organization repositories.

  GET /orgs/{org}/repos

https://developer.github.com/v3/repos/#list-organization-repositories
*/
func (c Client) ReposListForOrg(ctx context.Context, req *ReposListForOrgReq, opt ...RequestOption) (*ReposListForOrgResponse, error) {
	return ReposListForOrg(ctx, req, append(c, opt...)...)
}

/*
ReposListForOrgReq is request data for Client.ReposListForOrg

https://developer.github.com/v3/repos/#list-organization-repositories
*/
type ReposListForOrgReq struct {
	_url string
	Org  string

	/*
	Specifies the types of repositories you want returned. Can be one of `all`,
	`public`, `private`, `forks`, `sources`, `member`, `internal`. Default: `all`.
	If your organization is associated with an enterprise account using GitHub
	Enterprise Cloud or GitHub Enterprise Server 2.20+, `type` can also be
	`internal`.
	*/
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: when using `full_name`: `asc`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

func (r *ReposListForOrgReq) url() string {
	return r._url
}

func (r *ReposListForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/repos", r.Org)
}

func (r *ReposListForOrgReq) method() string {
	return "GET"
}

func (r *ReposListForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"baptiste": r.BaptistePreview,
		"nebula":   r.NebulaPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListForOrgReq) body() interface{} {
	return nil
}

func (r *ReposListForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListForOrgReq) Rel(link RelName, resp *ReposListForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListForOrgResponseBody is a response body for ReposListForOrg

https://developer.github.com/v3/repos/#list-organization-repositories
*/
type ReposListForOrgResponseBody []components.MinimalRepository

/*
ReposListForOrgResponse is a response for ReposListForOrg

https://developer.github.com/v3/repos/#list-organization-repositories
*/
type ReposListForOrgResponse struct {
	response
	request *ReposListForOrgReq
	Data    ReposListForOrgResponseBody
}

/*
ReposListForUser performs requests for "repos/list-for-user"

List repositories for a user.

  GET /users/{username}/repos

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
func ReposListForUser(ctx context.Context, req *ReposListForUserReq, opt ...RequestOption) (*ReposListForUserResponse, error) {
	if req == nil {
		req = new(ReposListForUserReq)
	}
	resp := &ReposListForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListForUser performs requests for "repos/list-for-user"

List repositories for a user.

  GET /users/{username}/repos

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
func (c Client) ReposListForUser(ctx context.Context, req *ReposListForUserReq, opt ...RequestOption) (*ReposListForUserResponse, error) {
	return ReposListForUser(ctx, req, append(c, opt...)...)
}

/*
ReposListForUserReq is request data for Client.ReposListForUser

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
type ReposListForUserReq struct {
	_url     string
	Username string

	// Can be one of `all`, `owner`, `member`.
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool
}

func (r *ReposListForUserReq) url() string {
	return r._url
}

func (r *ReposListForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/repos", r.Username)
}

func (r *ReposListForUserReq) method() string {
	return "GET"
}

func (r *ReposListForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"nebula": r.NebulaPreview}
	if allPreviews {
		previewVals["nebula"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListForUserReq) body() interface{} {
	return nil
}

func (r *ReposListForUserReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposListForUserReq) validStatuses() []int {
	return []int{}
}

func (r *ReposListForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListForUserReq) Rel(link RelName, resp *ReposListForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListForUserResponse is a response for ReposListForUser

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
type ReposListForUserResponse struct {
	response
	request *ReposListForUserReq
}

/*
ReposListForks performs requests for "repos/list-forks"

List forks.

  GET /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#list-forks
*/
func ReposListForks(ctx context.Context, req *ReposListForksReq, opt ...RequestOption) (*ReposListForksResponse, error) {
	if req == nil {
		req = new(ReposListForksReq)
	}
	resp := &ReposListForksResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListForksResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListForks performs requests for "repos/list-forks"

List forks.

  GET /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#list-forks
*/
func (c Client) ReposListForks(ctx context.Context, req *ReposListForksReq, opt ...RequestOption) (*ReposListForksResponse, error) {
	return ReposListForks(ctx, req, append(c, opt...)...)
}

/*
ReposListForksReq is request data for Client.ReposListForks

https://developer.github.com/v3/repos/forks/#list-forks
*/
type ReposListForksReq struct {
	_url  string
	Owner string
	Repo  string

	// The sort order. Can be either `newest`, `oldest`, or `stargazers`.
	Sort *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListForksReq) url() string {
	return r._url
}

func (r *ReposListForksReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/forks", r.Owner, r.Repo)
}

func (r *ReposListForksReq) method() string {
	return "GET"
}

func (r *ReposListForksReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListForksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListForksReq) body() interface{} {
	return nil
}

func (r *ReposListForksReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListForksReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListForksReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListForksReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListForksReq) Rel(link RelName, resp *ReposListForksResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListForksResponseBody is a response body for ReposListForks

https://developer.github.com/v3/repos/forks/#list-forks
*/
type ReposListForksResponseBody []components.MinimalRepository

/*
ReposListForksResponse is a response for ReposListForks

https://developer.github.com/v3/repos/forks/#list-forks
*/
type ReposListForksResponse struct {
	response
	request *ReposListForksReq
	Data    ReposListForksResponseBody
}

/*
ReposListInvitations performs requests for "repos/list-invitations"

List repository invitations.

  GET /repos/{owner}/{repo}/invitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations
*/
func ReposListInvitations(ctx context.Context, req *ReposListInvitationsReq, opt ...RequestOption) (*ReposListInvitationsResponse, error) {
	if req == nil {
		req = new(ReposListInvitationsReq)
	}
	resp := &ReposListInvitationsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListInvitationsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListInvitations performs requests for "repos/list-invitations"

List repository invitations.

  GET /repos/{owner}/{repo}/invitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations
*/
func (c Client) ReposListInvitations(ctx context.Context, req *ReposListInvitationsReq, opt ...RequestOption) (*ReposListInvitationsResponse, error) {
	return ReposListInvitations(ctx, req, append(c, opt...)...)
}

/*
ReposListInvitationsReq is request data for Client.ReposListInvitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations
*/
type ReposListInvitationsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListInvitationsReq) url() string {
	return r._url
}

func (r *ReposListInvitationsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/invitations", r.Owner, r.Repo)
}

func (r *ReposListInvitationsReq) method() string {
	return "GET"
}

func (r *ReposListInvitationsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListInvitationsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListInvitationsReq) body() interface{} {
	return nil
}

func (r *ReposListInvitationsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListInvitationsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListInvitationsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListInvitationsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListInvitationsReq) Rel(link RelName, resp *ReposListInvitationsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListInvitationsResponseBody is a response body for ReposListInvitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations
*/
type ReposListInvitationsResponseBody []components.RepositoryInvitation

/*
ReposListInvitationsResponse is a response for ReposListInvitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations
*/
type ReposListInvitationsResponse struct {
	response
	request *ReposListInvitationsReq
	Data    ReposListInvitationsResponseBody
}

/*
ReposListInvitationsForAuthenticatedUser performs requests for "repos/list-invitations-for-authenticated-user"

List repository invitations for the authenticated user.

  GET /user/repository_invitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations-for-the-authenticated-user
*/
func ReposListInvitationsForAuthenticatedUser(ctx context.Context, req *ReposListInvitationsForAuthenticatedUserReq, opt ...RequestOption) (*ReposListInvitationsForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(ReposListInvitationsForAuthenticatedUserReq)
	}
	resp := &ReposListInvitationsForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListInvitationsForAuthenticatedUserResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListInvitationsForAuthenticatedUser performs requests for "repos/list-invitations-for-authenticated-user"

List repository invitations for the authenticated user.

  GET /user/repository_invitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations-for-the-authenticated-user
*/
func (c Client) ReposListInvitationsForAuthenticatedUser(ctx context.Context, req *ReposListInvitationsForAuthenticatedUserReq, opt ...RequestOption) (*ReposListInvitationsForAuthenticatedUserResponse, error) {
	return ReposListInvitationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ReposListInvitationsForAuthenticatedUserReq is request data for Client.ReposListInvitationsForAuthenticatedUser

https://developer.github.com/v3/repos/invitations/#list-repository-invitations-for-the-authenticated-user
*/
type ReposListInvitationsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListInvitationsForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *ReposListInvitationsForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/repository_invitations")
}

func (r *ReposListInvitationsForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *ReposListInvitationsForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListInvitationsForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListInvitationsForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *ReposListInvitationsForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListInvitationsForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListInvitationsForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListInvitationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListInvitationsForAuthenticatedUserReq) Rel(link RelName, resp *ReposListInvitationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListInvitationsForAuthenticatedUserResponseBody is a response body for ReposListInvitationsForAuthenticatedUser

https://developer.github.com/v3/repos/invitations/#list-repository-invitations-for-the-authenticated-user
*/
type ReposListInvitationsForAuthenticatedUserResponseBody []components.RepositoryInvitation

/*
ReposListInvitationsForAuthenticatedUserResponse is a response for ReposListInvitationsForAuthenticatedUser

https://developer.github.com/v3/repos/invitations/#list-repository-invitations-for-the-authenticated-user
*/
type ReposListInvitationsForAuthenticatedUserResponse struct {
	response
	request *ReposListInvitationsForAuthenticatedUserReq
	Data    ReposListInvitationsForAuthenticatedUserResponseBody
}

/*
ReposListLanguages performs requests for "repos/list-languages"

List repository languages.

  GET /repos/{owner}/{repo}/languages

https://developer.github.com/v3/repos/#list-repository-languages
*/
func ReposListLanguages(ctx context.Context, req *ReposListLanguagesReq, opt ...RequestOption) (*ReposListLanguagesResponse, error) {
	if req == nil {
		req = new(ReposListLanguagesReq)
	}
	resp := &ReposListLanguagesResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListLanguagesResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListLanguages performs requests for "repos/list-languages"

List repository languages.

  GET /repos/{owner}/{repo}/languages

https://developer.github.com/v3/repos/#list-repository-languages
*/
func (c Client) ReposListLanguages(ctx context.Context, req *ReposListLanguagesReq, opt ...RequestOption) (*ReposListLanguagesResponse, error) {
	return ReposListLanguages(ctx, req, append(c, opt...)...)
}

/*
ReposListLanguagesReq is request data for Client.ReposListLanguages

https://developer.github.com/v3/repos/#list-repository-languages
*/
type ReposListLanguagesReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposListLanguagesReq) url() string {
	return r._url
}

func (r *ReposListLanguagesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/languages", r.Owner, r.Repo)
}

func (r *ReposListLanguagesReq) method() string {
	return "GET"
}

func (r *ReposListLanguagesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposListLanguagesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListLanguagesReq) body() interface{} {
	return nil
}

func (r *ReposListLanguagesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListLanguagesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListLanguagesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListLanguagesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListLanguagesReq) Rel(link RelName, resp *ReposListLanguagesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListLanguagesResponseBody is a response body for ReposListLanguages

https://developer.github.com/v3/repos/#list-repository-languages
*/
type ReposListLanguagesResponseBody map[string]int64

/*
ReposListLanguagesResponse is a response for ReposListLanguages

https://developer.github.com/v3/repos/#list-repository-languages
*/
type ReposListLanguagesResponse struct {
	response
	request *ReposListLanguagesReq
	Data    ReposListLanguagesResponseBody
}

/*
ReposListPagesBuilds performs requests for "repos/list-pages-builds"

List GitHub Pages builds.

  GET /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#list-github-pages-builds
*/
func ReposListPagesBuilds(ctx context.Context, req *ReposListPagesBuildsReq, opt ...RequestOption) (*ReposListPagesBuildsResponse, error) {
	if req == nil {
		req = new(ReposListPagesBuildsReq)
	}
	resp := &ReposListPagesBuildsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListPagesBuildsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListPagesBuilds performs requests for "repos/list-pages-builds"

List GitHub Pages builds.

  GET /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#list-github-pages-builds
*/
func (c Client) ReposListPagesBuilds(ctx context.Context, req *ReposListPagesBuildsReq, opt ...RequestOption) (*ReposListPagesBuildsResponse, error) {
	return ReposListPagesBuilds(ctx, req, append(c, opt...)...)
}

/*
ReposListPagesBuildsReq is request data for Client.ReposListPagesBuilds

https://developer.github.com/v3/repos/pages/#list-github-pages-builds
*/
type ReposListPagesBuildsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListPagesBuildsReq) url() string {
	return r._url
}

func (r *ReposListPagesBuildsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages/builds", r.Owner, r.Repo)
}

func (r *ReposListPagesBuildsReq) method() string {
	return "GET"
}

func (r *ReposListPagesBuildsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListPagesBuildsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListPagesBuildsReq) body() interface{} {
	return nil
}

func (r *ReposListPagesBuildsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListPagesBuildsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListPagesBuildsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListPagesBuildsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListPagesBuildsReq) Rel(link RelName, resp *ReposListPagesBuildsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListPagesBuildsResponseBody is a response body for ReposListPagesBuilds

https://developer.github.com/v3/repos/pages/#list-github-pages-builds
*/
type ReposListPagesBuildsResponseBody []components.PageBuild

/*
ReposListPagesBuildsResponse is a response for ReposListPagesBuilds

https://developer.github.com/v3/repos/pages/#list-github-pages-builds
*/
type ReposListPagesBuildsResponse struct {
	response
	request *ReposListPagesBuildsReq
	Data    ReposListPagesBuildsResponseBody
}

/*
ReposListPublic performs requests for "repos/list-public"

List public repositories.

  GET /repositories

https://developer.github.com/v3/repos/#list-public-repositories
*/
func ReposListPublic(ctx context.Context, req *ReposListPublicReq, opt ...RequestOption) (*ReposListPublicResponse, error) {
	if req == nil {
		req = new(ReposListPublicReq)
	}
	resp := &ReposListPublicResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListPublicResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListPublic performs requests for "repos/list-public"

List public repositories.

  GET /repositories

https://developer.github.com/v3/repos/#list-public-repositories
*/
func (c Client) ReposListPublic(ctx context.Context, req *ReposListPublicReq, opt ...RequestOption) (*ReposListPublicResponse, error) {
	return ReposListPublic(ctx, req, append(c, opt...)...)
}

/*
ReposListPublicReq is request data for Client.ReposListPublic

https://developer.github.com/v3/repos/#list-public-repositories
*/
type ReposListPublicReq struct {
	_url string

	// The integer ID of the last repository that you've seen.
	Since *int64
}

func (r *ReposListPublicReq) url() string {
	return r._url
}

func (r *ReposListPublicReq) urlPath() string {
	return fmt.Sprintf("/repositories")
}

func (r *ReposListPublicReq) method() string {
	return "GET"
}

func (r *ReposListPublicReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", strconv.FormatInt(*r.Since, 10))
	}
	return query
}

func (r *ReposListPublicReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListPublicReq) body() interface{} {
	return nil
}

func (r *ReposListPublicReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListPublicReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListPublicReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListPublicReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListPublicReq) Rel(link RelName, resp *ReposListPublicResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListPublicResponseBody is a response body for ReposListPublic

https://developer.github.com/v3/repos/#list-public-repositories
*/
type ReposListPublicResponseBody []components.PublicRepository

/*
ReposListPublicResponse is a response for ReposListPublic

https://developer.github.com/v3/repos/#list-public-repositories
*/
type ReposListPublicResponse struct {
	response
	request *ReposListPublicReq
	Data    ReposListPublicResponseBody
}

/*
ReposListPullRequestsAssociatedWithCommit performs requests for "repos/list-pull-requests-associated-with-commit"

List pull requests associated with a commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-a-commit
*/
func ReposListPullRequestsAssociatedWithCommit(ctx context.Context, req *ReposListPullRequestsAssociatedWithCommitReq, opt ...RequestOption) (*ReposListPullRequestsAssociatedWithCommitResponse, error) {
	if req == nil {
		req = new(ReposListPullRequestsAssociatedWithCommitReq)
	}
	resp := &ReposListPullRequestsAssociatedWithCommitResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListPullRequestsAssociatedWithCommitResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListPullRequestsAssociatedWithCommit performs requests for "repos/list-pull-requests-associated-with-commit"

List pull requests associated with a commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-a-commit
*/
func (c Client) ReposListPullRequestsAssociatedWithCommit(ctx context.Context, req *ReposListPullRequestsAssociatedWithCommitReq, opt ...RequestOption) (*ReposListPullRequestsAssociatedWithCommitResponse, error) {
	return ReposListPullRequestsAssociatedWithCommit(ctx, req, append(c, opt...)...)
}

/*
ReposListPullRequestsAssociatedWithCommitReq is request data for Client.ReposListPullRequestsAssociatedWithCommit

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-a-commit
*/
type ReposListPullRequestsAssociatedWithCommitReq struct {
	_url      string
	Owner     string
	Repo      string
	CommitSha string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Listing branches or pull requests for a commit in the Commits API is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-04-11-pulls-branches-for-commit/)
	for more details. To access the new endpoints during the preview period, you
	must set this to true.
	*/
	GrootPreview bool
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) url() string {
	return r._url
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/commits/%v/pulls", r.Owner, r.Repo, r.CommitSha)
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) method() string {
	return "GET"
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"groot": r.GrootPreview}
	if requiredPreviews {
		previewVals["groot"] = true
	}
	if allPreviews {
		previewVals["groot"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) body() interface{} {
	return nil
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListPullRequestsAssociatedWithCommitReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListPullRequestsAssociatedWithCommitReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListPullRequestsAssociatedWithCommitReq) Rel(link RelName, resp *ReposListPullRequestsAssociatedWithCommitResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListPullRequestsAssociatedWithCommitResponseBody is a response body for ReposListPullRequestsAssociatedWithCommit

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-a-commit
*/
type ReposListPullRequestsAssociatedWithCommitResponseBody []components.PullRequestSimple

/*
ReposListPullRequestsAssociatedWithCommitResponse is a response for ReposListPullRequestsAssociatedWithCommit

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-a-commit
*/
type ReposListPullRequestsAssociatedWithCommitResponse struct {
	response
	request *ReposListPullRequestsAssociatedWithCommitReq
	Data    ReposListPullRequestsAssociatedWithCommitResponseBody
}

/*
ReposListReleaseAssets performs requests for "repos/list-release-assets"

List release assets.

  GET /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#list-release-assets
*/
func ReposListReleaseAssets(ctx context.Context, req *ReposListReleaseAssetsReq, opt ...RequestOption) (*ReposListReleaseAssetsResponse, error) {
	if req == nil {
		req = new(ReposListReleaseAssetsReq)
	}
	resp := &ReposListReleaseAssetsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListReleaseAssetsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListReleaseAssets performs requests for "repos/list-release-assets"

List release assets.

  GET /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#list-release-assets
*/
func (c Client) ReposListReleaseAssets(ctx context.Context, req *ReposListReleaseAssetsReq, opt ...RequestOption) (*ReposListReleaseAssetsResponse, error) {
	return ReposListReleaseAssets(ctx, req, append(c, opt...)...)
}

/*
ReposListReleaseAssetsReq is request data for Client.ReposListReleaseAssets

https://developer.github.com/v3/repos/releases/#list-release-assets
*/
type ReposListReleaseAssetsReq struct {
	_url      string
	Owner     string
	Repo      string
	ReleaseId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListReleaseAssetsReq) url() string {
	return r._url
}

func (r *ReposListReleaseAssetsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v/assets", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposListReleaseAssetsReq) method() string {
	return "GET"
}

func (r *ReposListReleaseAssetsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListReleaseAssetsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListReleaseAssetsReq) body() interface{} {
	return nil
}

func (r *ReposListReleaseAssetsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListReleaseAssetsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListReleaseAssetsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListReleaseAssetsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListReleaseAssetsReq) Rel(link RelName, resp *ReposListReleaseAssetsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListReleaseAssetsResponseBody is a response body for ReposListReleaseAssets

https://developer.github.com/v3/repos/releases/#list-release-assets
*/
type ReposListReleaseAssetsResponseBody []components.ReleaseAsset

/*
ReposListReleaseAssetsResponse is a response for ReposListReleaseAssets

https://developer.github.com/v3/repos/releases/#list-release-assets
*/
type ReposListReleaseAssetsResponse struct {
	response
	request *ReposListReleaseAssetsReq
	Data    ReposListReleaseAssetsResponseBody
}

/*
ReposListReleases performs requests for "repos/list-releases"

List releases.

  GET /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#list-releases
*/
func ReposListReleases(ctx context.Context, req *ReposListReleasesReq, opt ...RequestOption) (*ReposListReleasesResponse, error) {
	if req == nil {
		req = new(ReposListReleasesReq)
	}
	resp := &ReposListReleasesResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListReleasesResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListReleases performs requests for "repos/list-releases"

List releases.

  GET /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#list-releases
*/
func (c Client) ReposListReleases(ctx context.Context, req *ReposListReleasesReq, opt ...RequestOption) (*ReposListReleasesResponse, error) {
	return ReposListReleases(ctx, req, append(c, opt...)...)
}

/*
ReposListReleasesReq is request data for Client.ReposListReleases

https://developer.github.com/v3/repos/releases/#list-releases
*/
type ReposListReleasesReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListReleasesReq) url() string {
	return r._url
}

func (r *ReposListReleasesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases", r.Owner, r.Repo)
}

func (r *ReposListReleasesReq) method() string {
	return "GET"
}

func (r *ReposListReleasesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListReleasesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListReleasesReq) body() interface{} {
	return nil
}

func (r *ReposListReleasesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListReleasesReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListReleasesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListReleasesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListReleasesReq) Rel(link RelName, resp *ReposListReleasesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListReleasesResponseBody is a response body for ReposListReleases

https://developer.github.com/v3/repos/releases/#list-releases
*/
type ReposListReleasesResponseBody []components.Release2

/*
ReposListReleasesResponse is a response for ReposListReleases

https://developer.github.com/v3/repos/releases/#list-releases
*/
type ReposListReleasesResponse struct {
	response
	request *ReposListReleasesReq
	Data    ReposListReleasesResponseBody
}

/*
ReposListTags performs requests for "repos/list-tags"

List repository tags.

  GET /repos/{owner}/{repo}/tags

https://developer.github.com/v3/repos/#list-repository-tags
*/
func ReposListTags(ctx context.Context, req *ReposListTagsReq, opt ...RequestOption) (*ReposListTagsResponse, error) {
	if req == nil {
		req = new(ReposListTagsReq)
	}
	resp := &ReposListTagsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListTagsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListTags performs requests for "repos/list-tags"

List repository tags.

  GET /repos/{owner}/{repo}/tags

https://developer.github.com/v3/repos/#list-repository-tags
*/
func (c Client) ReposListTags(ctx context.Context, req *ReposListTagsReq, opt ...RequestOption) (*ReposListTagsResponse, error) {
	return ReposListTags(ctx, req, append(c, opt...)...)
}

/*
ReposListTagsReq is request data for Client.ReposListTags

https://developer.github.com/v3/repos/#list-repository-tags
*/
type ReposListTagsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListTagsReq) url() string {
	return r._url
}

func (r *ReposListTagsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/tags", r.Owner, r.Repo)
}

func (r *ReposListTagsReq) method() string {
	return "GET"
}

func (r *ReposListTagsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListTagsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListTagsReq) body() interface{} {
	return nil
}

func (r *ReposListTagsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListTagsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListTagsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListTagsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListTagsReq) Rel(link RelName, resp *ReposListTagsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListTagsResponseBody is a response body for ReposListTags

https://developer.github.com/v3/repos/#list-repository-tags
*/
type ReposListTagsResponseBody []components.Tag

/*
ReposListTagsResponse is a response for ReposListTags

https://developer.github.com/v3/repos/#list-repository-tags
*/
type ReposListTagsResponse struct {
	response
	request *ReposListTagsReq
	Data    ReposListTagsResponseBody
}

/*
ReposListTeams performs requests for "repos/list-teams"

List repository teams.

  GET /repos/{owner}/{repo}/teams

https://developer.github.com/v3/repos/#list-repository-teams
*/
func ReposListTeams(ctx context.Context, req *ReposListTeamsReq, opt ...RequestOption) (*ReposListTeamsResponse, error) {
	if req == nil {
		req = new(ReposListTeamsReq)
	}
	resp := &ReposListTeamsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListTeamsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListTeams performs requests for "repos/list-teams"

List repository teams.

  GET /repos/{owner}/{repo}/teams

https://developer.github.com/v3/repos/#list-repository-teams
*/
func (c Client) ReposListTeams(ctx context.Context, req *ReposListTeamsReq, opt ...RequestOption) (*ReposListTeamsResponse, error) {
	return ReposListTeams(ctx, req, append(c, opt...)...)
}

/*
ReposListTeamsReq is request data for Client.ReposListTeams

https://developer.github.com/v3/repos/#list-repository-teams
*/
type ReposListTeamsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListTeamsReq) url() string {
	return r._url
}

func (r *ReposListTeamsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/teams", r.Owner, r.Repo)
}

func (r *ReposListTeamsReq) method() string {
	return "GET"
}

func (r *ReposListTeamsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListTeamsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListTeamsReq) body() interface{} {
	return nil
}

func (r *ReposListTeamsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListTeamsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListTeamsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListTeamsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListTeamsReq) Rel(link RelName, resp *ReposListTeamsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListTeamsResponseBody is a response body for ReposListTeams

https://developer.github.com/v3/repos/#list-repository-teams
*/
type ReposListTeamsResponseBody []components.Team

/*
ReposListTeamsResponse is a response for ReposListTeams

https://developer.github.com/v3/repos/#list-repository-teams
*/
type ReposListTeamsResponse struct {
	response
	request *ReposListTeamsReq
	Data    ReposListTeamsResponseBody
}

/*
ReposListWebhooks performs requests for "repos/list-webhooks"

List repository webhooks.

  GET /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#list-repository-webhooks
*/
func ReposListWebhooks(ctx context.Context, req *ReposListWebhooksReq, opt ...RequestOption) (*ReposListWebhooksResponse, error) {
	if req == nil {
		req = new(ReposListWebhooksReq)
	}
	resp := &ReposListWebhooksResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposListWebhooksResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposListWebhooks performs requests for "repos/list-webhooks"

List repository webhooks.

  GET /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#list-repository-webhooks
*/
func (c Client) ReposListWebhooks(ctx context.Context, req *ReposListWebhooksReq, opt ...RequestOption) (*ReposListWebhooksResponse, error) {
	return ReposListWebhooks(ctx, req, append(c, opt...)...)
}

/*
ReposListWebhooksReq is request data for Client.ReposListWebhooks

https://developer.github.com/v3/repos/hooks/#list-repository-webhooks
*/
type ReposListWebhooksReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ReposListWebhooksReq) url() string {
	return r._url
}

func (r *ReposListWebhooksReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks", r.Owner, r.Repo)
}

func (r *ReposListWebhooksReq) method() string {
	return "GET"
}

func (r *ReposListWebhooksReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ReposListWebhooksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposListWebhooksReq) body() interface{} {
	return nil
}

func (r *ReposListWebhooksReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposListWebhooksReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposListWebhooksReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposListWebhooksReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposListWebhooksReq) Rel(link RelName, resp *ReposListWebhooksResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposListWebhooksResponseBody is a response body for ReposListWebhooks

https://developer.github.com/v3/repos/hooks/#list-repository-webhooks
*/
type ReposListWebhooksResponseBody []components.Hook

/*
ReposListWebhooksResponse is a response for ReposListWebhooks

https://developer.github.com/v3/repos/hooks/#list-repository-webhooks
*/
type ReposListWebhooksResponse struct {
	response
	request *ReposListWebhooksReq
	Data    ReposListWebhooksResponseBody
}

/*
ReposMerge performs requests for "repos/merge"

Merge a branch.

  POST /repos/{owner}/{repo}/merges

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
func ReposMerge(ctx context.Context, req *ReposMergeReq, opt ...RequestOption) (*ReposMergeResponse, error) {
	if req == nil {
		req = new(ReposMergeReq)
	}
	resp := &ReposMergeResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposMergeResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposMerge performs requests for "repos/merge"

Merge a branch.

  POST /repos/{owner}/{repo}/merges

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
func (c Client) ReposMerge(ctx context.Context, req *ReposMergeReq, opt ...RequestOption) (*ReposMergeResponse, error) {
	return ReposMerge(ctx, req, append(c, opt...)...)
}

/*
ReposMergeReq is request data for Client.ReposMerge

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
type ReposMergeReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposMergeReqBody
}

func (r *ReposMergeReq) url() string {
	return r._url
}

func (r *ReposMergeReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/merges", r.Owner, r.Repo)
}

func (r *ReposMergeReq) method() string {
	return "POST"
}

func (r *ReposMergeReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposMergeReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposMergeReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposMergeReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposMergeReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposMergeReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposMergeReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposMergeReq) Rel(link RelName, resp *ReposMergeResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposMergeReqBody is a request body for repos/merge

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
type ReposMergeReqBody struct {

	// The name of the base branch that the head will be merged into.
	Base *string `json:"base"`

	/*
	   Commit message to use for the merge commit. If omitted, a default message will
	   be used.
	*/
	CommitMessage *string `json:"commit_message,omitempty"`

	// The head to merge. This can be a branch name or a commit SHA1.
	Head *string `json:"head"`
}

/*
ReposMergeResponseBody is a response body for ReposMerge

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
type ReposMergeResponseBody components.SimpleCommit2

/*
ReposMergeResponse is a response for ReposMerge

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
type ReposMergeResponse struct {
	response
	request *ReposMergeReq
	Data    ReposMergeResponseBody
}

/*
ReposPingWebhook performs requests for "repos/ping-webhook"

Ping a repository webhook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/pings

https://developer.github.com/v3/repos/hooks/#ping-a-repository-webhook
*/
func ReposPingWebhook(ctx context.Context, req *ReposPingWebhookReq, opt ...RequestOption) (*ReposPingWebhookResponse, error) {
	if req == nil {
		req = new(ReposPingWebhookReq)
	}
	resp := &ReposPingWebhookResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposPingWebhook performs requests for "repos/ping-webhook"

Ping a repository webhook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/pings

https://developer.github.com/v3/repos/hooks/#ping-a-repository-webhook
*/
func (c Client) ReposPingWebhook(ctx context.Context, req *ReposPingWebhookReq, opt ...RequestOption) (*ReposPingWebhookResponse, error) {
	return ReposPingWebhook(ctx, req, append(c, opt...)...)
}

/*
ReposPingWebhookReq is request data for Client.ReposPingWebhook

https://developer.github.com/v3/repos/hooks/#ping-a-repository-webhook
*/
type ReposPingWebhookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

func (r *ReposPingWebhookReq) url() string {
	return r._url
}

func (r *ReposPingWebhookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v/pings", r.Owner, r.Repo, r.HookId)
}

func (r *ReposPingWebhookReq) method() string {
	return "POST"
}

func (r *ReposPingWebhookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposPingWebhookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposPingWebhookReq) body() interface{} {
	return nil
}

func (r *ReposPingWebhookReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposPingWebhookReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposPingWebhookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposPingWebhookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposPingWebhookReq) Rel(link RelName, resp *ReposPingWebhookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposPingWebhookResponse is a response for ReposPingWebhook

https://developer.github.com/v3/repos/hooks/#ping-a-repository-webhook
*/
type ReposPingWebhookResponse struct {
	response
	request *ReposPingWebhookReq
}

/*
ReposRemoveAppAccessRestrictions performs requests for "repos/remove-app-access-restrictions"

Remove app access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
func ReposRemoveAppAccessRestrictions(ctx context.Context, req *ReposRemoveAppAccessRestrictionsReq, opt ...RequestOption) (*ReposRemoveAppAccessRestrictionsResponse, error) {
	if req == nil {
		req = new(ReposRemoveAppAccessRestrictionsReq)
	}
	resp := &ReposRemoveAppAccessRestrictionsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposRemoveAppAccessRestrictionsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveAppAccessRestrictions performs requests for "repos/remove-app-access-restrictions"

Remove app access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
func (c Client) ReposRemoveAppAccessRestrictions(ctx context.Context, req *ReposRemoveAppAccessRestrictionsReq, opt ...RequestOption) (*ReposRemoveAppAccessRestrictionsResponse, error) {
	return ReposRemoveAppAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposRemoveAppAccessRestrictionsReq is request data for Client.ReposRemoveAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
type ReposRemoveAppAccessRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposRemoveAppAccessRestrictionsReqBody
}

func (r *ReposRemoveAppAccessRestrictionsReq) url() string {
	return r._url
}

func (r *ReposRemoveAppAccessRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveAppAccessRestrictionsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveAppAccessRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveAppAccessRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveAppAccessRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposRemoveAppAccessRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveAppAccessRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveAppAccessRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposRemoveAppAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveAppAccessRestrictionsReq) Rel(link RelName, resp *ReposRemoveAppAccessRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveAppAccessRestrictionsReqBody is a request body for repos/remove-app-access-restrictions

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
type ReposRemoveAppAccessRestrictionsReqBody []string

/*
ReposRemoveAppAccessRestrictionsResponseBody is a response body for ReposRemoveAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
type ReposRemoveAppAccessRestrictionsResponseBody []components.Integration

/*
ReposRemoveAppAccessRestrictionsResponse is a response for ReposRemoveAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
type ReposRemoveAppAccessRestrictionsResponse struct {
	response
	request *ReposRemoveAppAccessRestrictionsReq
	Data    ReposRemoveAppAccessRestrictionsResponseBody
}

/*
ReposRemoveCollaborator performs requests for "repos/remove-collaborator"

Remove a repository collaborator.

  DELETE /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#remove-a-repository-collaborator
*/
func ReposRemoveCollaborator(ctx context.Context, req *ReposRemoveCollaboratorReq, opt ...RequestOption) (*ReposRemoveCollaboratorResponse, error) {
	if req == nil {
		req = new(ReposRemoveCollaboratorReq)
	}
	resp := &ReposRemoveCollaboratorResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveCollaborator performs requests for "repos/remove-collaborator"

Remove a repository collaborator.

  DELETE /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#remove-a-repository-collaborator
*/
func (c Client) ReposRemoveCollaborator(ctx context.Context, req *ReposRemoveCollaboratorReq, opt ...RequestOption) (*ReposRemoveCollaboratorResponse, error) {
	return ReposRemoveCollaborator(ctx, req, append(c, opt...)...)
}

/*
ReposRemoveCollaboratorReq is request data for Client.ReposRemoveCollaborator

https://developer.github.com/v3/repos/collaborators/#remove-a-repository-collaborator
*/
type ReposRemoveCollaboratorReq struct {
	_url     string
	Owner    string
	Repo     string
	Username string
}

func (r *ReposRemoveCollaboratorReq) url() string {
	return r._url
}

func (r *ReposRemoveCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username)
}

func (r *ReposRemoveCollaboratorReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveCollaboratorReq) body() interface{} {
	return nil
}

func (r *ReposRemoveCollaboratorReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposRemoveCollaboratorReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposRemoveCollaboratorReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposRemoveCollaboratorReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveCollaboratorReq) Rel(link RelName, resp *ReposRemoveCollaboratorResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveCollaboratorResponse is a response for ReposRemoveCollaborator

https://developer.github.com/v3/repos/collaborators/#remove-a-repository-collaborator
*/
type ReposRemoveCollaboratorResponse struct {
	response
	request *ReposRemoveCollaboratorReq
}

/*
ReposRemoveStatusCheckContexts performs requests for "repos/remove-status-check-contexts"

Remove status check contexts.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
func ReposRemoveStatusCheckContexts(ctx context.Context, req *ReposRemoveStatusCheckContextsReq, opt ...RequestOption) (*ReposRemoveStatusCheckContextsResponse, error) {
	if req == nil {
		req = new(ReposRemoveStatusCheckContextsReq)
	}
	resp := &ReposRemoveStatusCheckContextsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposRemoveStatusCheckContextsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveStatusCheckContexts performs requests for "repos/remove-status-check-contexts"

Remove status check contexts.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
func (c Client) ReposRemoveStatusCheckContexts(ctx context.Context, req *ReposRemoveStatusCheckContextsReq, opt ...RequestOption) (*ReposRemoveStatusCheckContextsResponse, error) {
	return ReposRemoveStatusCheckContexts(ctx, req, append(c, opt...)...)
}

/*
ReposRemoveStatusCheckContextsReq is request data for Client.ReposRemoveStatusCheckContexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
type ReposRemoveStatusCheckContextsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposRemoveStatusCheckContextsReqBody
}

func (r *ReposRemoveStatusCheckContextsReq) url() string {
	return r._url
}

func (r *ReposRemoveStatusCheckContextsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveStatusCheckContextsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveStatusCheckContextsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveStatusCheckContextsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveStatusCheckContextsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposRemoveStatusCheckContextsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveStatusCheckContextsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveStatusCheckContextsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposRemoveStatusCheckContextsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveStatusCheckContextsReq) Rel(link RelName, resp *ReposRemoveStatusCheckContextsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveStatusCheckContextsReqBody is a request body for repos/remove-status-check-contexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
type ReposRemoveStatusCheckContextsReqBody []string

/*
ReposRemoveStatusCheckContextsResponseBody is a response body for ReposRemoveStatusCheckContexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
type ReposRemoveStatusCheckContextsResponseBody []string

/*
ReposRemoveStatusCheckContextsResponse is a response for ReposRemoveStatusCheckContexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
type ReposRemoveStatusCheckContextsResponse struct {
	response
	request *ReposRemoveStatusCheckContextsReq
	Data    ReposRemoveStatusCheckContextsResponseBody
}

/*
ReposRemoveStatusCheckProtection performs requests for "repos/remove-status-check-protection"

Remove status check protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#remove-status-check-protection
*/
func ReposRemoveStatusCheckProtection(ctx context.Context, req *ReposRemoveStatusCheckProtectionReq, opt ...RequestOption) (*ReposRemoveStatusCheckProtectionResponse, error) {
	if req == nil {
		req = new(ReposRemoveStatusCheckProtectionReq)
	}
	resp := &ReposRemoveStatusCheckProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveStatusCheckProtection performs requests for "repos/remove-status-check-protection"

Remove status check protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#remove-status-check-protection
*/
func (c Client) ReposRemoveStatusCheckProtection(ctx context.Context, req *ReposRemoveStatusCheckProtectionReq, opt ...RequestOption) (*ReposRemoveStatusCheckProtectionResponse, error) {
	return ReposRemoveStatusCheckProtection(ctx, req, append(c, opt...)...)
}

/*
ReposRemoveStatusCheckProtectionReq is request data for Client.ReposRemoveStatusCheckProtection

https://developer.github.com/v3/repos/branches/#remove-status-check-protection
*/
type ReposRemoveStatusCheckProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposRemoveStatusCheckProtectionReq) url() string {
	return r._url
}

func (r *ReposRemoveStatusCheckProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveStatusCheckProtectionReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveStatusCheckProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveStatusCheckProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveStatusCheckProtectionReq) body() interface{} {
	return nil
}

func (r *ReposRemoveStatusCheckProtectionReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposRemoveStatusCheckProtectionReq) validStatuses() []int {
	return []int{}
}

func (r *ReposRemoveStatusCheckProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposRemoveStatusCheckProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveStatusCheckProtectionReq) Rel(link RelName, resp *ReposRemoveStatusCheckProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveStatusCheckProtectionResponse is a response for ReposRemoveStatusCheckProtection

https://developer.github.com/v3/repos/branches/#remove-status-check-protection
*/
type ReposRemoveStatusCheckProtectionResponse struct {
	response
	request *ReposRemoveStatusCheckProtectionReq
}

/*
ReposRemoveTeamAccessRestrictions performs requests for "repos/remove-team-access-restrictions"

Remove team access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
func ReposRemoveTeamAccessRestrictions(ctx context.Context, req *ReposRemoveTeamAccessRestrictionsReq, opt ...RequestOption) (*ReposRemoveTeamAccessRestrictionsResponse, error) {
	if req == nil {
		req = new(ReposRemoveTeamAccessRestrictionsReq)
	}
	resp := &ReposRemoveTeamAccessRestrictionsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposRemoveTeamAccessRestrictionsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveTeamAccessRestrictions performs requests for "repos/remove-team-access-restrictions"

Remove team access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
func (c Client) ReposRemoveTeamAccessRestrictions(ctx context.Context, req *ReposRemoveTeamAccessRestrictionsReq, opt ...RequestOption) (*ReposRemoveTeamAccessRestrictionsResponse, error) {
	return ReposRemoveTeamAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposRemoveTeamAccessRestrictionsReq is request data for Client.ReposRemoveTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
type ReposRemoveTeamAccessRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposRemoveTeamAccessRestrictionsReqBody
}

func (r *ReposRemoveTeamAccessRestrictionsReq) url() string {
	return r._url
}

func (r *ReposRemoveTeamAccessRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveTeamAccessRestrictionsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveTeamAccessRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveTeamAccessRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveTeamAccessRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposRemoveTeamAccessRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveTeamAccessRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveTeamAccessRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposRemoveTeamAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveTeamAccessRestrictionsReq) Rel(link RelName, resp *ReposRemoveTeamAccessRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveTeamAccessRestrictionsReqBody is a request body for repos/remove-team-access-restrictions

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
type ReposRemoveTeamAccessRestrictionsReqBody []string

/*
ReposRemoveTeamAccessRestrictionsResponseBody is a response body for ReposRemoveTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
type ReposRemoveTeamAccessRestrictionsResponseBody []components.Team

/*
ReposRemoveTeamAccessRestrictionsResponse is a response for ReposRemoveTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
type ReposRemoveTeamAccessRestrictionsResponse struct {
	response
	request *ReposRemoveTeamAccessRestrictionsReq
	Data    ReposRemoveTeamAccessRestrictionsResponseBody
}

/*
ReposRemoveUserAccessRestrictions performs requests for "repos/remove-user-access-restrictions"

Remove user access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
func ReposRemoveUserAccessRestrictions(ctx context.Context, req *ReposRemoveUserAccessRestrictionsReq, opt ...RequestOption) (*ReposRemoveUserAccessRestrictionsResponse, error) {
	if req == nil {
		req = new(ReposRemoveUserAccessRestrictionsReq)
	}
	resp := &ReposRemoveUserAccessRestrictionsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposRemoveUserAccessRestrictionsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRemoveUserAccessRestrictions performs requests for "repos/remove-user-access-restrictions"

Remove user access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
func (c Client) ReposRemoveUserAccessRestrictions(ctx context.Context, req *ReposRemoveUserAccessRestrictionsReq, opt ...RequestOption) (*ReposRemoveUserAccessRestrictionsResponse, error) {
	return ReposRemoveUserAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposRemoveUserAccessRestrictionsReq is request data for Client.ReposRemoveUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
type ReposRemoveUserAccessRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposRemoveUserAccessRestrictionsReqBody
}

func (r *ReposRemoveUserAccessRestrictionsReq) url() string {
	return r._url
}

func (r *ReposRemoveUserAccessRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch)
}

func (r *ReposRemoveUserAccessRestrictionsReq) method() string {
	return "DELETE"
}

func (r *ReposRemoveUserAccessRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRemoveUserAccessRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRemoveUserAccessRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposRemoveUserAccessRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveUserAccessRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposRemoveUserAccessRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposRemoveUserAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRemoveUserAccessRestrictionsReq) Rel(link RelName, resp *ReposRemoveUserAccessRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRemoveUserAccessRestrictionsReqBody is a request body for repos/remove-user-access-restrictions

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
type ReposRemoveUserAccessRestrictionsReqBody []string

/*
ReposRemoveUserAccessRestrictionsResponseBody is a response body for ReposRemoveUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
type ReposRemoveUserAccessRestrictionsResponseBody []components.SimpleUser

/*
ReposRemoveUserAccessRestrictionsResponse is a response for ReposRemoveUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
type ReposRemoveUserAccessRestrictionsResponse struct {
	response
	request *ReposRemoveUserAccessRestrictionsReq
	Data    ReposRemoveUserAccessRestrictionsResponseBody
}

/*
ReposReplaceAllTopics performs requests for "repos/replace-all-topics"

Replace all repository topics.

  PUT /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
func ReposReplaceAllTopics(ctx context.Context, req *ReposReplaceAllTopicsReq, opt ...RequestOption) (*ReposReplaceAllTopicsResponse, error) {
	if req == nil {
		req = new(ReposReplaceAllTopicsReq)
	}
	resp := &ReposReplaceAllTopicsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposReplaceAllTopicsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposReplaceAllTopics performs requests for "repos/replace-all-topics"

Replace all repository topics.

  PUT /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
func (c Client) ReposReplaceAllTopics(ctx context.Context, req *ReposReplaceAllTopicsReq, opt ...RequestOption) (*ReposReplaceAllTopicsResponse, error) {
	return ReposReplaceAllTopics(ctx, req, append(c, opt...)...)
}

/*
ReposReplaceAllTopicsReq is request data for Client.ReposReplaceAllTopics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposReplaceAllTopicsReqBody

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

func (r *ReposReplaceAllTopicsReq) url() string {
	return r._url
}

func (r *ReposReplaceAllTopicsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/topics", r.Owner, r.Repo)
}

func (r *ReposReplaceAllTopicsReq) method() string {
	return "PUT"
}

func (r *ReposReplaceAllTopicsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposReplaceAllTopicsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"mercy": r.MercyPreview}
	if requiredPreviews {
		previewVals["mercy"] = true
	}
	if allPreviews {
		previewVals["mercy"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposReplaceAllTopicsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposReplaceAllTopicsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposReplaceAllTopicsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposReplaceAllTopicsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposReplaceAllTopicsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposReplaceAllTopicsReq) Rel(link RelName, resp *ReposReplaceAllTopicsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposReplaceAllTopicsReqBody is a request body for repos/replace-all-topics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsReqBody struct {

	/*
	   An array of topics to add to the repository. Pass one or more topics to
	   _replace_ the set of existing topics. Send an empty array (`[]`) to clear all
	   topics from the repository. **Note:** Topic `names` cannot contain uppercase
	   letters.
	*/
	Names []string `json:"names"`
}

/*
ReposReplaceAllTopicsResponseBody is a response body for ReposReplaceAllTopics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsResponseBody components.Topic

/*
ReposReplaceAllTopicsResponse is a response for ReposReplaceAllTopics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReposReplaceAllTopicsResponse struct {
	response
	request *ReposReplaceAllTopicsReq
	Data    ReposReplaceAllTopicsResponseBody
}

/*
ReposRequestPagesBuild performs requests for "repos/request-pages-build"

Request a GitHub Pages build.

  POST /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#request-a-github-pages-build
*/
func ReposRequestPagesBuild(ctx context.Context, req *ReposRequestPagesBuildReq, opt ...RequestOption) (*ReposRequestPagesBuildResponse, error) {
	if req == nil {
		req = new(ReposRequestPagesBuildReq)
	}
	resp := &ReposRequestPagesBuildResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposRequestPagesBuildResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposRequestPagesBuild performs requests for "repos/request-pages-build"

Request a GitHub Pages build.

  POST /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#request-a-github-pages-build
*/
func (c Client) ReposRequestPagesBuild(ctx context.Context, req *ReposRequestPagesBuildReq, opt ...RequestOption) (*ReposRequestPagesBuildResponse, error) {
	return ReposRequestPagesBuild(ctx, req, append(c, opt...)...)
}

/*
ReposRequestPagesBuildReq is request data for Client.ReposRequestPagesBuild

https://developer.github.com/v3/repos/pages/#request-a-github-pages-build
*/
type ReposRequestPagesBuildReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ReposRequestPagesBuildReq) url() string {
	return r._url
}

func (r *ReposRequestPagesBuildReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages/builds", r.Owner, r.Repo)
}

func (r *ReposRequestPagesBuildReq) method() string {
	return "POST"
}

func (r *ReposRequestPagesBuildReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposRequestPagesBuildReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposRequestPagesBuildReq) body() interface{} {
	return nil
}

func (r *ReposRequestPagesBuildReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposRequestPagesBuildReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposRequestPagesBuildReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposRequestPagesBuildReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposRequestPagesBuildReq) Rel(link RelName, resp *ReposRequestPagesBuildResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposRequestPagesBuildResponseBody is a response body for ReposRequestPagesBuild

https://developer.github.com/v3/repos/pages/#request-a-github-pages-build
*/
type ReposRequestPagesBuildResponseBody components.PageBuildStatus

/*
ReposRequestPagesBuildResponse is a response for ReposRequestPagesBuild

https://developer.github.com/v3/repos/pages/#request-a-github-pages-build
*/
type ReposRequestPagesBuildResponse struct {
	response
	request *ReposRequestPagesBuildReq
	Data    ReposRequestPagesBuildResponseBody
}

/*
ReposSetAdminBranchProtection performs requests for "repos/set-admin-branch-protection"

Set admin branch protection.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#set-admin-branch-protection
*/
func ReposSetAdminBranchProtection(ctx context.Context, req *ReposSetAdminBranchProtectionReq, opt ...RequestOption) (*ReposSetAdminBranchProtectionResponse, error) {
	if req == nil {
		req = new(ReposSetAdminBranchProtectionReq)
	}
	resp := &ReposSetAdminBranchProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposSetAdminBranchProtectionResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposSetAdminBranchProtection performs requests for "repos/set-admin-branch-protection"

Set admin branch protection.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#set-admin-branch-protection
*/
func (c Client) ReposSetAdminBranchProtection(ctx context.Context, req *ReposSetAdminBranchProtectionReq, opt ...RequestOption) (*ReposSetAdminBranchProtectionResponse, error) {
	return ReposSetAdminBranchProtection(ctx, req, append(c, opt...)...)
}

/*
ReposSetAdminBranchProtectionReq is request data for Client.ReposSetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#set-admin-branch-protection
*/
type ReposSetAdminBranchProtectionReq struct {
	_url   string
	Owner  string
	Repo   string
	Branch string
}

func (r *ReposSetAdminBranchProtectionReq) url() string {
	return r._url
}

func (r *ReposSetAdminBranchProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch)
}

func (r *ReposSetAdminBranchProtectionReq) method() string {
	return "POST"
}

func (r *ReposSetAdminBranchProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposSetAdminBranchProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposSetAdminBranchProtectionReq) body() interface{} {
	return nil
}

func (r *ReposSetAdminBranchProtectionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposSetAdminBranchProtectionReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposSetAdminBranchProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposSetAdminBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposSetAdminBranchProtectionReq) Rel(link RelName, resp *ReposSetAdminBranchProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposSetAdminBranchProtectionResponseBody is a response body for ReposSetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#set-admin-branch-protection
*/
type ReposSetAdminBranchProtectionResponseBody components.ProtectedBranchAdminEnforced

/*
ReposSetAdminBranchProtectionResponse is a response for ReposSetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#set-admin-branch-protection
*/
type ReposSetAdminBranchProtectionResponse struct {
	response
	request *ReposSetAdminBranchProtectionReq
	Data    ReposSetAdminBranchProtectionResponseBody
}

/*
ReposSetAppAccessRestrictions performs requests for "repos/set-app-access-restrictions"

Set app access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
func ReposSetAppAccessRestrictions(ctx context.Context, req *ReposSetAppAccessRestrictionsReq, opt ...RequestOption) (*ReposSetAppAccessRestrictionsResponse, error) {
	if req == nil {
		req = new(ReposSetAppAccessRestrictionsReq)
	}
	resp := &ReposSetAppAccessRestrictionsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposSetAppAccessRestrictionsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposSetAppAccessRestrictions performs requests for "repos/set-app-access-restrictions"

Set app access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
func (c Client) ReposSetAppAccessRestrictions(ctx context.Context, req *ReposSetAppAccessRestrictionsReq, opt ...RequestOption) (*ReposSetAppAccessRestrictionsResponse, error) {
	return ReposSetAppAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposSetAppAccessRestrictionsReq is request data for Client.ReposSetAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
type ReposSetAppAccessRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposSetAppAccessRestrictionsReqBody
}

func (r *ReposSetAppAccessRestrictionsReq) url() string {
	return r._url
}

func (r *ReposSetAppAccessRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch)
}

func (r *ReposSetAppAccessRestrictionsReq) method() string {
	return "PUT"
}

func (r *ReposSetAppAccessRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposSetAppAccessRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposSetAppAccessRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposSetAppAccessRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposSetAppAccessRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposSetAppAccessRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposSetAppAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposSetAppAccessRestrictionsReq) Rel(link RelName, resp *ReposSetAppAccessRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposSetAppAccessRestrictionsReqBody is a request body for repos/set-app-access-restrictions

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
type ReposSetAppAccessRestrictionsReqBody []string

/*
ReposSetAppAccessRestrictionsResponseBody is a response body for ReposSetAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
type ReposSetAppAccessRestrictionsResponseBody []components.Integration

/*
ReposSetAppAccessRestrictionsResponse is a response for ReposSetAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
type ReposSetAppAccessRestrictionsResponse struct {
	response
	request *ReposSetAppAccessRestrictionsReq
	Data    ReposSetAppAccessRestrictionsResponseBody
}

/*
ReposSetStatusCheckContexts performs requests for "repos/set-status-check-contexts"

Set status check contexts.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
func ReposSetStatusCheckContexts(ctx context.Context, req *ReposSetStatusCheckContextsReq, opt ...RequestOption) (*ReposSetStatusCheckContextsResponse, error) {
	if req == nil {
		req = new(ReposSetStatusCheckContextsReq)
	}
	resp := &ReposSetStatusCheckContextsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposSetStatusCheckContextsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposSetStatusCheckContexts performs requests for "repos/set-status-check-contexts"

Set status check contexts.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
func (c Client) ReposSetStatusCheckContexts(ctx context.Context, req *ReposSetStatusCheckContextsReq, opt ...RequestOption) (*ReposSetStatusCheckContextsResponse, error) {
	return ReposSetStatusCheckContexts(ctx, req, append(c, opt...)...)
}

/*
ReposSetStatusCheckContextsReq is request data for Client.ReposSetStatusCheckContexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
type ReposSetStatusCheckContextsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposSetStatusCheckContextsReqBody
}

func (r *ReposSetStatusCheckContextsReq) url() string {
	return r._url
}

func (r *ReposSetStatusCheckContextsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch)
}

func (r *ReposSetStatusCheckContextsReq) method() string {
	return "PUT"
}

func (r *ReposSetStatusCheckContextsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposSetStatusCheckContextsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposSetStatusCheckContextsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposSetStatusCheckContextsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposSetStatusCheckContextsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposSetStatusCheckContextsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposSetStatusCheckContextsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposSetStatusCheckContextsReq) Rel(link RelName, resp *ReposSetStatusCheckContextsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposSetStatusCheckContextsReqBody is a request body for repos/set-status-check-contexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
type ReposSetStatusCheckContextsReqBody []string

/*
ReposSetStatusCheckContextsResponseBody is a response body for ReposSetStatusCheckContexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
type ReposSetStatusCheckContextsResponseBody []string

/*
ReposSetStatusCheckContextsResponse is a response for ReposSetStatusCheckContexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
type ReposSetStatusCheckContextsResponse struct {
	response
	request *ReposSetStatusCheckContextsReq
	Data    ReposSetStatusCheckContextsResponseBody
}

/*
ReposSetTeamAccessRestrictions performs requests for "repos/set-team-access-restrictions"

Set team access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
func ReposSetTeamAccessRestrictions(ctx context.Context, req *ReposSetTeamAccessRestrictionsReq, opt ...RequestOption) (*ReposSetTeamAccessRestrictionsResponse, error) {
	if req == nil {
		req = new(ReposSetTeamAccessRestrictionsReq)
	}
	resp := &ReposSetTeamAccessRestrictionsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposSetTeamAccessRestrictionsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposSetTeamAccessRestrictions performs requests for "repos/set-team-access-restrictions"

Set team access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
func (c Client) ReposSetTeamAccessRestrictions(ctx context.Context, req *ReposSetTeamAccessRestrictionsReq, opt ...RequestOption) (*ReposSetTeamAccessRestrictionsResponse, error) {
	return ReposSetTeamAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposSetTeamAccessRestrictionsReq is request data for Client.ReposSetTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
type ReposSetTeamAccessRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposSetTeamAccessRestrictionsReqBody
}

func (r *ReposSetTeamAccessRestrictionsReq) url() string {
	return r._url
}

func (r *ReposSetTeamAccessRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch)
}

func (r *ReposSetTeamAccessRestrictionsReq) method() string {
	return "PUT"
}

func (r *ReposSetTeamAccessRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposSetTeamAccessRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposSetTeamAccessRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposSetTeamAccessRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposSetTeamAccessRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposSetTeamAccessRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposSetTeamAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposSetTeamAccessRestrictionsReq) Rel(link RelName, resp *ReposSetTeamAccessRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposSetTeamAccessRestrictionsReqBody is a request body for repos/set-team-access-restrictions

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
type ReposSetTeamAccessRestrictionsReqBody []string

/*
ReposSetTeamAccessRestrictionsResponseBody is a response body for ReposSetTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
type ReposSetTeamAccessRestrictionsResponseBody []components.Team

/*
ReposSetTeamAccessRestrictionsResponse is a response for ReposSetTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
type ReposSetTeamAccessRestrictionsResponse struct {
	response
	request *ReposSetTeamAccessRestrictionsReq
	Data    ReposSetTeamAccessRestrictionsResponseBody
}

/*
ReposSetUserAccessRestrictions performs requests for "repos/set-user-access-restrictions"

Set user access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
func ReposSetUserAccessRestrictions(ctx context.Context, req *ReposSetUserAccessRestrictionsReq, opt ...RequestOption) (*ReposSetUserAccessRestrictionsResponse, error) {
	if req == nil {
		req = new(ReposSetUserAccessRestrictionsReq)
	}
	resp := &ReposSetUserAccessRestrictionsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposSetUserAccessRestrictionsResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposSetUserAccessRestrictions performs requests for "repos/set-user-access-restrictions"

Set user access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
func (c Client) ReposSetUserAccessRestrictions(ctx context.Context, req *ReposSetUserAccessRestrictionsReq, opt ...RequestOption) (*ReposSetUserAccessRestrictionsResponse, error) {
	return ReposSetUserAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
ReposSetUserAccessRestrictionsReq is request data for Client.ReposSetUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
type ReposSetUserAccessRestrictionsReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposSetUserAccessRestrictionsReqBody
}

func (r *ReposSetUserAccessRestrictionsReq) url() string {
	return r._url
}

func (r *ReposSetUserAccessRestrictionsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch)
}

func (r *ReposSetUserAccessRestrictionsReq) method() string {
	return "PUT"
}

func (r *ReposSetUserAccessRestrictionsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposSetUserAccessRestrictionsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposSetUserAccessRestrictionsReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposSetUserAccessRestrictionsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposSetUserAccessRestrictionsReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposSetUserAccessRestrictionsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposSetUserAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposSetUserAccessRestrictionsReq) Rel(link RelName, resp *ReposSetUserAccessRestrictionsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposSetUserAccessRestrictionsReqBody is a request body for repos/set-user-access-restrictions

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
type ReposSetUserAccessRestrictionsReqBody []string

/*
ReposSetUserAccessRestrictionsResponseBody is a response body for ReposSetUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
type ReposSetUserAccessRestrictionsResponseBody []components.SimpleUser

/*
ReposSetUserAccessRestrictionsResponse is a response for ReposSetUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
type ReposSetUserAccessRestrictionsResponse struct {
	response
	request *ReposSetUserAccessRestrictionsReq
	Data    ReposSetUserAccessRestrictionsResponseBody
}

/*
ReposTestPushWebhook performs requests for "repos/test-push-webhook"

Test the push repository webhook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/tests

https://developer.github.com/v3/repos/hooks/#test-the-push-repository-webhook
*/
func ReposTestPushWebhook(ctx context.Context, req *ReposTestPushWebhookReq, opt ...RequestOption) (*ReposTestPushWebhookResponse, error) {
	if req == nil {
		req = new(ReposTestPushWebhookReq)
	}
	resp := &ReposTestPushWebhookResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposTestPushWebhook performs requests for "repos/test-push-webhook"

Test the push repository webhook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/tests

https://developer.github.com/v3/repos/hooks/#test-the-push-repository-webhook
*/
func (c Client) ReposTestPushWebhook(ctx context.Context, req *ReposTestPushWebhookReq, opt ...RequestOption) (*ReposTestPushWebhookResponse, error) {
	return ReposTestPushWebhook(ctx, req, append(c, opt...)...)
}

/*
ReposTestPushWebhookReq is request data for Client.ReposTestPushWebhook

https://developer.github.com/v3/repos/hooks/#test-the-push-repository-webhook
*/
type ReposTestPushWebhookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

func (r *ReposTestPushWebhookReq) url() string {
	return r._url
}

func (r *ReposTestPushWebhookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v/tests", r.Owner, r.Repo, r.HookId)
}

func (r *ReposTestPushWebhookReq) method() string {
	return "POST"
}

func (r *ReposTestPushWebhookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposTestPushWebhookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposTestPushWebhookReq) body() interface{} {
	return nil
}

func (r *ReposTestPushWebhookReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposTestPushWebhookReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposTestPushWebhookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *ReposTestPushWebhookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposTestPushWebhookReq) Rel(link RelName, resp *ReposTestPushWebhookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposTestPushWebhookResponse is a response for ReposTestPushWebhook

https://developer.github.com/v3/repos/hooks/#test-the-push-repository-webhook
*/
type ReposTestPushWebhookResponse struct {
	response
	request *ReposTestPushWebhookReq
}

/*
ReposTransfer performs requests for "repos/transfer"

Transfer a repository.

  POST /repos/{owner}/{repo}/transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
func ReposTransfer(ctx context.Context, req *ReposTransferReq, opt ...RequestOption) (*ReposTransferResponse, error) {
	if req == nil {
		req = new(ReposTransferReq)
	}
	resp := &ReposTransferResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposTransferResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposTransfer performs requests for "repos/transfer"

Transfer a repository.

  POST /repos/{owner}/{repo}/transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
func (c Client) ReposTransfer(ctx context.Context, req *ReposTransferReq, opt ...RequestOption) (*ReposTransferResponse, error) {
	return ReposTransfer(ctx, req, append(c, opt...)...)
}

/*
ReposTransferReq is request data for Client.ReposTransfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposTransferReqBody
}

func (r *ReposTransferReq) url() string {
	return r._url
}

func (r *ReposTransferReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/transfer", r.Owner, r.Repo)
}

func (r *ReposTransferReq) method() string {
	return "POST"
}

func (r *ReposTransferReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposTransferReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposTransferReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposTransferReq) dataStatuses() []int {
	return []int{202}
}

func (r *ReposTransferReq) validStatuses() []int {
	return []int{202}
}

func (r *ReposTransferReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposTransferReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposTransferReq) Rel(link RelName, resp *ReposTransferResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposTransferReqBody is a request body for repos/transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferReqBody struct {

	/*
	   **Required:** The username or organization name the repository will be
	   transferred to.
	*/
	NewOwner *string `json:"new_owner,omitempty"`

	/*
	   ID of the team or teams to add to the repository. Teams can only be added to
	   organization-owned repositories.
	*/
	TeamIds []int64 `json:"team_ids,omitempty"`
}

/*
ReposTransferResponseBody is a response body for ReposTransfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferResponseBody components.Repository

/*
ReposTransferResponse is a response for ReposTransfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type ReposTransferResponse struct {
	response
	request *ReposTransferReq
	Data    ReposTransferResponseBody
}

/*
ReposUpdate performs requests for "repos/update"

Update a repository.

  PATCH /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#update-a-repository
*/
func ReposUpdate(ctx context.Context, req *ReposUpdateReq, opt ...RequestOption) (*ReposUpdateResponse, error) {
	if req == nil {
		req = new(ReposUpdateReq)
	}
	resp := &ReposUpdateResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposUpdateResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdate performs requests for "repos/update"

Update a repository.

  PATCH /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#update-a-repository
*/
func (c Client) ReposUpdate(ctx context.Context, req *ReposUpdateReq, opt ...RequestOption) (*ReposUpdateResponse, error) {
	return ReposUpdate(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateReq is request data for Client.ReposUpdate

https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposUpdateReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

func (r *ReposUpdateReq) url() string {
	return r._url
}

func (r *ReposUpdateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo)
}

func (r *ReposUpdateReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"baptiste": r.BaptistePreview,
		"nebula":   r.NebulaPreview,
	}
	if allPreviews {
		previewVals["nebula"] = true
		previewVals["baptiste"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateReq) Rel(link RelName, resp *ReposUpdateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateReqBody is a request body for repos/update

https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateReqBody struct {

	/*
	   Either `true` to allow merging pull requests with a merge commit, or `false` to
	   prevent merging pull requests with merge commits.
	*/
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	/*
	   Either `true` to allow rebase-merging pull requests, or `false` to prevent
	   rebase-merging.
	*/
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	/*
	   Either `true` to allow squash-merging pull requests, or `false` to prevent
	   squash-merging.
	*/
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	/*
	   `true` to archive this repository. **Note**: You cannot unarchive repositories
	   through the API.
	*/
	Archived *bool `json:"archived,omitempty"`

	// Updates the default branch for this repository.
	DefaultBranch *string `json:"default_branch,omitempty"`

	/*
	   Either `true` to allow automatically deleting head branches when pull requests
	   are merged, or `false` to prevent automatic deletion.
	*/
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	// Either `true` to enable issues for this repository or `false` to disable them.
	HasIssues *bool `json:"has_issues,omitempty"`

	/*
	   Either `true` to enable projects for this repository or `false` to disable them.
	   **Note:** If you're creating a repository in an organization that has disabled
	   repository projects, the default is `false`, and if you pass `true`, the API
	   returns an error.
	*/
	HasProjects *bool `json:"has_projects,omitempty"`

	// Either `true` to enable the wiki for this repository or `false` to disable it.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	/*
	   Either `true` to make this repo available as a template repository or `false` to
	   prevent it.
	*/
	IsTemplate *bool `json:"is_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name,omitempty"`

	/*
	   Either `true` to make the repository private or `false` to make it public.
	   Default: `false`.
	   **Note**: You will get a `422` error if the organization restricts [changing
	   repository
	   visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories)
	   to organization owners and a non-owner tries to change the value of private.
	   **Note**: You will get a `422` error if the organization restricts [changing
	   repository
	   visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories)
	   to organization owners and a non-owner tries to change the value of private.
	*/
	Private *bool `json:"private,omitempty"`

	/*
	   Can be `public` or `private`. If your organization is associated with an
	   enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server
	   2.20+, `visibility` can also be `internal`. The `visibility` parameter overrides
	   the `private` parameter when you use both along with the `nebula-preview`
	   preview header.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ReposUpdateResponseBody is a response body for ReposUpdate

https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateResponseBody components.FullRepository2

/*
ReposUpdateResponse is a response for ReposUpdate

https://developer.github.com/v3/repos/#update-a-repository
*/
type ReposUpdateResponse struct {
	response
	request *ReposUpdateReq
	Data    ReposUpdateResponseBody
}

/*
ReposUpdateBranchProtection performs requests for "repos/update-branch-protection"

Update branch protection.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
func ReposUpdateBranchProtection(ctx context.Context, req *ReposUpdateBranchProtectionReq, opt ...RequestOption) (*ReposUpdateBranchProtectionResponse, error) {
	if req == nil {
		req = new(ReposUpdateBranchProtectionReq)
	}
	resp := &ReposUpdateBranchProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposUpdateBranchProtectionResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateBranchProtection performs requests for "repos/update-branch-protection"

Update branch protection.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
func (c Client) ReposUpdateBranchProtection(ctx context.Context, req *ReposUpdateBranchProtectionReq, opt ...RequestOption) (*ReposUpdateBranchProtectionResponse, error) {
	return ReposUpdateBranchProtection(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateBranchProtectionReq is request data for Client.ReposUpdateBranchProtection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposUpdateBranchProtectionReqBody

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

func (r *ReposUpdateBranchProtectionReq) url() string {
	return r._url
}

func (r *ReposUpdateBranchProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch)
}

func (r *ReposUpdateBranchProtectionReq) method() string {
	return "PUT"
}

func (r *ReposUpdateBranchProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateBranchProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"luke-cage": r.LukeCagePreview}
	if allPreviews {
		previewVals["luke-cage"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateBranchProtectionReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateBranchProtectionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateBranchProtectionReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateBranchProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateBranchProtectionReq) Rel(link RelName, resp *ReposUpdateBranchProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews is a value for ReposUpdateBranchProtectionReqBody's RequiredPullRequestReviews field
type ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews struct {

	/*
	   Set to `true` if you want to automatically dismiss approving reviews when
	   someone pushes a new commit.
	*/
	DismissStaleReviews *bool `json:"dismiss_stale_reviews,omitempty"`

	/*
	   Specify which users and teams can dismiss pull request reviews. Pass an empty
	   `dismissal_restrictions` object to disable. User and team
	   `dismissal_restrictions` are only available for organization-owned repositories.
	   Omit this parameter for personal repositories.
	*/
	DismissalRestrictions *ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions `json:"dismissal_restrictions,omitempty"`

	/*
	   Blocks merging pull requests until [code
	   owners](https://help.github.com/articles/about-code-owners/) review them.
	*/
	RequireCodeOwnerReviews *bool `json:"require_code_owner_reviews,omitempty"`

	/*
	   Specify the number of reviewers required to approve pull requests. Use a number
	   between 1 and 6.
	*/
	RequiredApprovingReviewCount *int64 `json:"required_approving_review_count,omitempty"`
}

// ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions is a value for ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews's DismissalRestrictions field
type ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions struct {

	// The list of team `slug`s with dismissal access
	Teams []string `json:"teams,omitempty"`

	// The list of user `login`s with dismissal access
	Users []string `json:"users,omitempty"`
}

// ReposUpdateBranchProtectionReqBodyRequiredStatusChecks is a value for ReposUpdateBranchProtectionReqBody's RequiredStatusChecks field
type ReposUpdateBranchProtectionReqBodyRequiredStatusChecks struct {

	// The list of status checks to require in order to merge into this branch
	Contexts []string `json:"contexts"`

	// Require branches to be up to date before merging.
	Strict *bool `json:"strict"`
}

// ReposUpdateBranchProtectionReqBodyRestrictions is a value for ReposUpdateBranchProtectionReqBody's Restrictions field
type ReposUpdateBranchProtectionReqBodyRestrictions struct {

	// The list of app `slug`s with push access
	Apps []string `json:"apps,omitempty"`

	// The list of team `slug`s with push access
	Teams []string `json:"teams"`

	// The list of user `login`s with push access
	Users []string `json:"users"`
}

/*
ReposUpdateBranchProtectionReqBody is a request body for repos/update-branch-protection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionReqBody struct {

	/*
	   Allows deletion of the protected branch by anyone with write access to the
	   repository. Set to `false` to prevent deletion of the protected branch. Default:
	   `false`. For more information, see "[Enabling force pushes to a protected
	   branch](https://help.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)".
	*/
	AllowDeletions *bool `json:"allow_deletions,omitempty"`

	/*
	   Permits force pushes to the protected branch by anyone with write access to the
	   repository. Set to `true` to allow force pushes. Set to `false` or `null` to
	   block force pushes. Default: `false`. For more information, see "[Enabling force
	   pushes to a protected
	   branch](https://help.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)".
	*/
	AllowForcePushes *bool `json:"allow_force_pushes,omitempty"`

	/*
	   Enforce all configured restrictions for administrators. Set to `true` to enforce
	   required status checks for repository administrators. Set to `null` to disable.
	*/
	EnforceAdmins *bool `json:"enforce_admins"`

	/*
	   Enforces a linear commit Git history, which prevents anyone from pushing merge
	   commits to a branch. Set to `true` to enforce a linear commit history. Set to
	   `false` to disable a linear commit Git history. Your repository must allow
	   squash merging or rebase merging before you can enable a linear commit history.
	   Default: `false`. For more information, see "[Requiring a linear commit
	   history](https://help.github.com/github/administering-a-repository/requiring-a-linear-commit-history)".
	*/
	RequiredLinearHistory *bool `json:"required_linear_history,omitempty"`

	/*
	   Require at least one approving review on a pull request, before merging. Set to
	   `null` to disable.
	*/
	RequiredPullRequestReviews *ReposUpdateBranchProtectionReqBodyRequiredPullRequestReviews `json:"required_pull_request_reviews"`

	// Require status checks to pass before merging. Set to `null` to disable.
	RequiredStatusChecks *ReposUpdateBranchProtectionReqBodyRequiredStatusChecks `json:"required_status_checks"`

	/*
	   Restrict who can push to the protected branch. User, app, and team
	   `restrictions` are only available for organization-owned repositories. Set to
	   `null` to disable.
	*/
	Restrictions *ReposUpdateBranchProtectionReqBodyRestrictions `json:"restrictions"`
}

/*
ReposUpdateBranchProtectionResponseBody is a response body for ReposUpdateBranchProtection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionResponseBody components.BranchProtection

/*
ReposUpdateBranchProtectionResponse is a response for ReposUpdateBranchProtection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type ReposUpdateBranchProtectionResponse struct {
	response
	request *ReposUpdateBranchProtectionReq
	Data    ReposUpdateBranchProtectionResponseBody
}

/*
ReposUpdateCommitComment performs requests for "repos/update-commit-comment"

Update a commit comment.

  PATCH /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
func ReposUpdateCommitComment(ctx context.Context, req *ReposUpdateCommitCommentReq, opt ...RequestOption) (*ReposUpdateCommitCommentResponse, error) {
	if req == nil {
		req = new(ReposUpdateCommitCommentReq)
	}
	resp := &ReposUpdateCommitCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposUpdateCommitCommentResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateCommitComment performs requests for "repos/update-commit-comment"

Update a commit comment.

  PATCH /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
func (c Client) ReposUpdateCommitComment(ctx context.Context, req *ReposUpdateCommitCommentReq, opt ...RequestOption) (*ReposUpdateCommitCommentResponse, error) {
	return ReposUpdateCommitComment(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateCommitCommentReq is request data for Client.ReposUpdateCommitComment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	CommentId   int64
	RequestBody ReposUpdateCommitCommentReqBody
}

func (r *ReposUpdateCommitCommentReq) url() string {
	return r._url
}

func (r *ReposUpdateCommitCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *ReposUpdateCommitCommentReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateCommitCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateCommitCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateCommitCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateCommitCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateCommitCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateCommitCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateCommitCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateCommitCommentReq) Rel(link RelName, resp *ReposUpdateCommitCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateCommitCommentReqBody is a request body for repos/update-commit-comment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentReqBody struct {

	// The contents of the comment
	Body *string `json:"body"`
}

/*
ReposUpdateCommitCommentResponseBody is a response body for ReposUpdateCommitComment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentResponseBody components.CommitComment

/*
ReposUpdateCommitCommentResponse is a response for ReposUpdateCommitComment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type ReposUpdateCommitCommentResponse struct {
	response
	request *ReposUpdateCommitCommentReq
	Data    ReposUpdateCommitCommentResponseBody
}

/*
ReposUpdateInformationAboutPagesSite performs requests for "repos/update-information-about-pages-site"

Update information about a GitHub Pages site.

  PUT /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
func ReposUpdateInformationAboutPagesSite(ctx context.Context, req *ReposUpdateInformationAboutPagesSiteReq, opt ...RequestOption) (*ReposUpdateInformationAboutPagesSiteResponse, error) {
	if req == nil {
		req = new(ReposUpdateInformationAboutPagesSiteReq)
	}
	resp := &ReposUpdateInformationAboutPagesSiteResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateInformationAboutPagesSite performs requests for "repos/update-information-about-pages-site"

Update information about a GitHub Pages site.

  PUT /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
func (c Client) ReposUpdateInformationAboutPagesSite(ctx context.Context, req *ReposUpdateInformationAboutPagesSiteReq, opt ...RequestOption) (*ReposUpdateInformationAboutPagesSiteResponse, error) {
	return ReposUpdateInformationAboutPagesSite(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateInformationAboutPagesSiteReq is request data for Client.ReposUpdateInformationAboutPagesSite

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
type ReposUpdateInformationAboutPagesSiteReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReposUpdateInformationAboutPagesSiteReqBody
}

func (r *ReposUpdateInformationAboutPagesSiteReq) url() string {
	return r._url
}

func (r *ReposUpdateInformationAboutPagesSiteReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo)
}

func (r *ReposUpdateInformationAboutPagesSiteReq) method() string {
	return "PUT"
}

func (r *ReposUpdateInformationAboutPagesSiteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateInformationAboutPagesSiteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateInformationAboutPagesSiteReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateInformationAboutPagesSiteReq) dataStatuses() []int {
	return []int{}
}

func (r *ReposUpdateInformationAboutPagesSiteReq) validStatuses() []int {
	return []int{204}
}

func (r *ReposUpdateInformationAboutPagesSiteReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateInformationAboutPagesSiteReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateInformationAboutPagesSiteReq) Rel(link RelName, resp *ReposUpdateInformationAboutPagesSiteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateInformationAboutPagesSiteReqBody is a request body for repos/update-information-about-pages-site

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
type ReposUpdateInformationAboutPagesSiteReqBody struct {

	/*
	   Specify a custom domain for the repository. Sending a `null` value will remove
	   the custom domain. For more about custom domains, see "[Using a custom domain
	   with GitHub
	   Pages](https://help.github.com/articles/using-a-custom-domain-with-github-pages/)."
	*/
	Cname *string `json:"cname,omitempty"`

	/*
	   Update the source for the repository. Must include the branch name, and may
	   optionally specify the subdirectory `/docs`. Possible values are `"gh-pages"`,
	   `"master"`, and `"master /docs"`.
	*/
	Source *string `json:"source,omitempty"`
}

/*
ReposUpdateInformationAboutPagesSiteResponse is a response for ReposUpdateInformationAboutPagesSite

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
type ReposUpdateInformationAboutPagesSiteResponse struct {
	response
	request *ReposUpdateInformationAboutPagesSiteReq
}

/*
ReposUpdateInvitation performs requests for "repos/update-invitation"

Update a repository invitation.

  PATCH /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
func ReposUpdateInvitation(ctx context.Context, req *ReposUpdateInvitationReq, opt ...RequestOption) (*ReposUpdateInvitationResponse, error) {
	if req == nil {
		req = new(ReposUpdateInvitationReq)
	}
	resp := &ReposUpdateInvitationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposUpdateInvitationResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateInvitation performs requests for "repos/update-invitation"

Update a repository invitation.

  PATCH /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
func (c Client) ReposUpdateInvitation(ctx context.Context, req *ReposUpdateInvitationReq, opt ...RequestOption) (*ReposUpdateInvitationResponse, error) {
	return ReposUpdateInvitation(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateInvitationReq is request data for Client.ReposUpdateInvitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationReq struct {
	_url         string
	Owner        string
	Repo         string
	InvitationId int64
	RequestBody  ReposUpdateInvitationReqBody
}

func (r *ReposUpdateInvitationReq) url() string {
	return r._url
}

func (r *ReposUpdateInvitationReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/invitations/%v", r.Owner, r.Repo, r.InvitationId)
}

func (r *ReposUpdateInvitationReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateInvitationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateInvitationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateInvitationReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateInvitationReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateInvitationReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateInvitationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateInvitationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateInvitationReq) Rel(link RelName, resp *ReposUpdateInvitationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateInvitationReqBody is a request body for repos/update-invitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationReqBody struct {

	/*
	   The permissions that the associated user will have on the repository. Valid
	   values are `read`, `write`, `maintain`, `triage`, and `admin`.
	*/
	Permissions *string `json:"permissions,omitempty"`
}

/*
ReposUpdateInvitationResponseBody is a response body for ReposUpdateInvitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationResponseBody components.RepositoryInvitation

/*
ReposUpdateInvitationResponse is a response for ReposUpdateInvitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type ReposUpdateInvitationResponse struct {
	response
	request *ReposUpdateInvitationReq
	Data    ReposUpdateInvitationResponseBody
}

/*
ReposUpdatePullRequestReviewProtection performs requests for "repos/update-pull-request-review-protection"

Update pull request review protection.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
func ReposUpdatePullRequestReviewProtection(ctx context.Context, req *ReposUpdatePullRequestReviewProtectionReq, opt ...RequestOption) (*ReposUpdatePullRequestReviewProtectionResponse, error) {
	if req == nil {
		req = new(ReposUpdatePullRequestReviewProtectionReq)
	}
	resp := &ReposUpdatePullRequestReviewProtectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposUpdatePullRequestReviewProtectionResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdatePullRequestReviewProtection performs requests for "repos/update-pull-request-review-protection"

Update pull request review protection.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
func (c Client) ReposUpdatePullRequestReviewProtection(ctx context.Context, req *ReposUpdatePullRequestReviewProtectionReq, opt ...RequestOption) (*ReposUpdatePullRequestReviewProtectionResponse, error) {
	return ReposUpdatePullRequestReviewProtection(ctx, req, append(c, opt...)...)
}

/*
ReposUpdatePullRequestReviewProtectionReq is request data for Client.ReposUpdatePullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
type ReposUpdatePullRequestReviewProtectionReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposUpdatePullRequestReviewProtectionReqBody

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

func (r *ReposUpdatePullRequestReviewProtectionReq) url() string {
	return r._url
}

func (r *ReposUpdatePullRequestReviewProtectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch)
}

func (r *ReposUpdatePullRequestReviewProtectionReq) method() string {
	return "PATCH"
}

func (r *ReposUpdatePullRequestReviewProtectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdatePullRequestReviewProtectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"luke-cage": r.LukeCagePreview}
	if allPreviews {
		previewVals["luke-cage"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdatePullRequestReviewProtectionReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdatePullRequestReviewProtectionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdatePullRequestReviewProtectionReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdatePullRequestReviewProtectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdatePullRequestReviewProtectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdatePullRequestReviewProtectionReq) Rel(link RelName, resp *ReposUpdatePullRequestReviewProtectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposUpdatePullRequestReviewProtectionReqBodyDismissalRestrictions is a value for ReposUpdatePullRequestReviewProtectionReqBody's DismissalRestrictions field
type ReposUpdatePullRequestReviewProtectionReqBodyDismissalRestrictions struct {

	// The list of team `slug`s with dismissal access
	Teams []string `json:"teams,omitempty"`

	// The list of user `login`s with dismissal access
	Users []string `json:"users,omitempty"`
}

/*
ReposUpdatePullRequestReviewProtectionReqBody is a request body for repos/update-pull-request-review-protection

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
type ReposUpdatePullRequestReviewProtectionReqBody struct {

	/*
	   Set to `true` if you want to automatically dismiss approving reviews when
	   someone pushes a new commit.
	*/
	DismissStaleReviews *bool `json:"dismiss_stale_reviews,omitempty"`

	/*
	   Specify which users and teams can dismiss pull request reviews. Pass an empty
	   `dismissal_restrictions` object to disable. User and team
	   `dismissal_restrictions` are only available for organization-owned repositories.
	   Omit this parameter for personal repositories.
	*/
	DismissalRestrictions *ReposUpdatePullRequestReviewProtectionReqBodyDismissalRestrictions `json:"dismissal_restrictions,omitempty"`

	/*
	   Blocks merging pull requests until [code
	   owners](https://help.github.com/articles/about-code-owners/) have reviewed.
	*/
	RequireCodeOwnerReviews *bool `json:"require_code_owner_reviews,omitempty"`

	/*
	   Specifies the number of reviewers required to approve pull requests. Use a
	   number between 1 and 6.
	*/
	RequiredApprovingReviewCount *int64 `json:"required_approving_review_count,omitempty"`
}

/*
ReposUpdatePullRequestReviewProtectionResponseBody is a response body for ReposUpdatePullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
type ReposUpdatePullRequestReviewProtectionResponseBody components.ProtectedBranchPullRequestReview

/*
ReposUpdatePullRequestReviewProtectionResponse is a response for ReposUpdatePullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
type ReposUpdatePullRequestReviewProtectionResponse struct {
	response
	request *ReposUpdatePullRequestReviewProtectionReq
	Data    ReposUpdatePullRequestReviewProtectionResponseBody
}

/*
ReposUpdateRelease performs requests for "repos/update-release"

Update a release.

  PATCH /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#update-a-release
*/
func ReposUpdateRelease(ctx context.Context, req *ReposUpdateReleaseReq, opt ...RequestOption) (*ReposUpdateReleaseResponse, error) {
	if req == nil {
		req = new(ReposUpdateReleaseReq)
	}
	resp := &ReposUpdateReleaseResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposUpdateReleaseResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateRelease performs requests for "repos/update-release"

Update a release.

  PATCH /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#update-a-release
*/
func (c Client) ReposUpdateRelease(ctx context.Context, req *ReposUpdateReleaseReq, opt ...RequestOption) (*ReposUpdateReleaseResponse, error) {
	return ReposUpdateRelease(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateReleaseReq is request data for Client.ReposUpdateRelease

https://developer.github.com/v3/repos/releases/#update-a-release
*/
type ReposUpdateReleaseReq struct {
	_url        string
	Owner       string
	Repo        string
	ReleaseId   int64
	RequestBody ReposUpdateReleaseReqBody
}

func (r *ReposUpdateReleaseReq) url() string {
	return r._url
}

func (r *ReposUpdateReleaseReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId)
}

func (r *ReposUpdateReleaseReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateReleaseReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateReleaseReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateReleaseReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateReleaseReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateReleaseReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateReleaseReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateReleaseReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateReleaseReq) Rel(link RelName, resp *ReposUpdateReleaseResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateReleaseReqBody is a request body for repos/update-release

https://developer.github.com/v3/repos/releases/#update-a-release
*/
type ReposUpdateReleaseReqBody struct {

	// Text describing the contents of the tag.
	Body *string `json:"body,omitempty"`

	// `true` makes the release a draft, and `false` publishes the release.
	Draft *bool `json:"draft,omitempty"`

	// The name of the release.
	Name *string `json:"name,omitempty"`

	/*
	   `true` to identify the release as a prerelease, `false` to identify the release
	   as a full release.
	*/
	Prerelease *bool `json:"prerelease,omitempty"`

	// The name of the tag.
	TagName *string `json:"tag_name,omitempty"`

	/*
	   Specifies the commitish value that determines where the Git tag is created from.
	   Can be any branch or commit SHA. Unused if the Git tag already exists. Default:
	   the repository's default branch (usually `master`).
	*/
	TargetCommitish *string `json:"target_commitish,omitempty"`
}

/*
ReposUpdateReleaseResponseBody is a response body for ReposUpdateRelease

https://developer.github.com/v3/repos/releases/#update-a-release
*/
type ReposUpdateReleaseResponseBody components.Release2

/*
ReposUpdateReleaseResponse is a response for ReposUpdateRelease

https://developer.github.com/v3/repos/releases/#update-a-release
*/
type ReposUpdateReleaseResponse struct {
	response
	request *ReposUpdateReleaseReq
	Data    ReposUpdateReleaseResponseBody
}

/*
ReposUpdateReleaseAsset performs requests for "repos/update-release-asset"

Update a release asset.

  PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
func ReposUpdateReleaseAsset(ctx context.Context, req *ReposUpdateReleaseAssetReq, opt ...RequestOption) (*ReposUpdateReleaseAssetResponse, error) {
	if req == nil {
		req = new(ReposUpdateReleaseAssetReq)
	}
	resp := &ReposUpdateReleaseAssetResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposUpdateReleaseAssetResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateReleaseAsset performs requests for "repos/update-release-asset"

Update a release asset.

  PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
func (c Client) ReposUpdateReleaseAsset(ctx context.Context, req *ReposUpdateReleaseAssetReq, opt ...RequestOption) (*ReposUpdateReleaseAssetResponse, error) {
	return ReposUpdateReleaseAsset(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateReleaseAssetReq is request data for Client.ReposUpdateReleaseAsset

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
type ReposUpdateReleaseAssetReq struct {
	_url        string
	Owner       string
	Repo        string
	AssetId     int64
	RequestBody ReposUpdateReleaseAssetReqBody
}

func (r *ReposUpdateReleaseAssetReq) url() string {
	return r._url
}

func (r *ReposUpdateReleaseAssetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId)
}

func (r *ReposUpdateReleaseAssetReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateReleaseAssetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateReleaseAssetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateReleaseAssetReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateReleaseAssetReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateReleaseAssetReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateReleaseAssetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateReleaseAssetReq) Rel(link RelName, resp *ReposUpdateReleaseAssetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateReleaseAssetReqBody is a request body for repos/update-release-asset

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
type ReposUpdateReleaseAssetReqBody struct {

	// An alternate short description of the asset. Used in place of the filename.
	Label *string `json:"label,omitempty"`

	// The file name of the asset.
	Name *string `json:"name,omitempty"`
}

/*
ReposUpdateReleaseAssetResponseBody is a response body for ReposUpdateReleaseAsset

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
type ReposUpdateReleaseAssetResponseBody components.ReleaseAsset

/*
ReposUpdateReleaseAssetResponse is a response for ReposUpdateReleaseAsset

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
type ReposUpdateReleaseAssetResponse struct {
	response
	request *ReposUpdateReleaseAssetReq
	Data    ReposUpdateReleaseAssetResponseBody
}

/*
ReposUpdateStatusCheckPotection performs requests for "repos/update-status-check-potection"

Update status check potection.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
func ReposUpdateStatusCheckPotection(ctx context.Context, req *ReposUpdateStatusCheckPotectionReq, opt ...RequestOption) (*ReposUpdateStatusCheckPotectionResponse, error) {
	if req == nil {
		req = new(ReposUpdateStatusCheckPotectionReq)
	}
	resp := &ReposUpdateStatusCheckPotectionResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposUpdateStatusCheckPotectionResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateStatusCheckPotection performs requests for "repos/update-status-check-potection"

Update status check potection.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
func (c Client) ReposUpdateStatusCheckPotection(ctx context.Context, req *ReposUpdateStatusCheckPotectionReq, opt ...RequestOption) (*ReposUpdateStatusCheckPotectionResponse, error) {
	return ReposUpdateStatusCheckPotection(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateStatusCheckPotectionReq is request data for Client.ReposUpdateStatusCheckPotection

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
type ReposUpdateStatusCheckPotectionReq struct {
	_url        string
	Owner       string
	Repo        string
	Branch      string
	RequestBody ReposUpdateStatusCheckPotectionReqBody
}

func (r *ReposUpdateStatusCheckPotectionReq) url() string {
	return r._url
}

func (r *ReposUpdateStatusCheckPotectionReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch)
}

func (r *ReposUpdateStatusCheckPotectionReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateStatusCheckPotectionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateStatusCheckPotectionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateStatusCheckPotectionReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateStatusCheckPotectionReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateStatusCheckPotectionReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateStatusCheckPotectionReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateStatusCheckPotectionReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateStatusCheckPotectionReq) Rel(link RelName, resp *ReposUpdateStatusCheckPotectionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUpdateStatusCheckPotectionReqBody is a request body for repos/update-status-check-potection

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
type ReposUpdateStatusCheckPotectionReqBody struct {

	// The list of status checks to require in order to merge into this branch
	Contexts []string `json:"contexts,omitempty"`

	// Require branches to be up to date before merging.
	Strict *bool `json:"strict,omitempty"`
}

/*
ReposUpdateStatusCheckPotectionResponseBody is a response body for ReposUpdateStatusCheckPotection

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
type ReposUpdateStatusCheckPotectionResponseBody components.StatusCheckPolicy

/*
ReposUpdateStatusCheckPotectionResponse is a response for ReposUpdateStatusCheckPotection

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
type ReposUpdateStatusCheckPotectionResponse struct {
	response
	request *ReposUpdateStatusCheckPotectionReq
	Data    ReposUpdateStatusCheckPotectionResponseBody
}

/*
ReposUpdateWebhook performs requests for "repos/update-webhook"

Update a repository webhook.

  PATCH /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
func ReposUpdateWebhook(ctx context.Context, req *ReposUpdateWebhookReq, opt ...RequestOption) (*ReposUpdateWebhookResponse, error) {
	if req == nil {
		req = new(ReposUpdateWebhookReq)
	}
	resp := &ReposUpdateWebhookResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposUpdateWebhookResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUpdateWebhook performs requests for "repos/update-webhook"

Update a repository webhook.

  PATCH /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
func (c Client) ReposUpdateWebhook(ctx context.Context, req *ReposUpdateWebhookReq, opt ...RequestOption) (*ReposUpdateWebhookResponse, error) {
	return ReposUpdateWebhook(ctx, req, append(c, opt...)...)
}

/*
ReposUpdateWebhookReq is request data for Client.ReposUpdateWebhook

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
type ReposUpdateWebhookReq struct {
	_url        string
	Owner       string
	Repo        string
	HookId      int64
	RequestBody ReposUpdateWebhookReqBody
}

func (r *ReposUpdateWebhookReq) url() string {
	return r._url
}

func (r *ReposUpdateWebhookReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId)
}

func (r *ReposUpdateWebhookReq) method() string {
	return "PATCH"
}

func (r *ReposUpdateWebhookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ReposUpdateWebhookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUpdateWebhookReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUpdateWebhookReq) dataStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateWebhookReq) validStatuses() []int {
	return []int{200}
}

func (r *ReposUpdateWebhookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *ReposUpdateWebhookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUpdateWebhookReq) Rel(link RelName, resp *ReposUpdateWebhookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ReposUpdateWebhookReqBodyConfig is a value for ReposUpdateWebhookReqBody's Config field
type ReposUpdateWebhookReqBodyConfig struct {

	/*
	   The media type used to serialize the payloads. Supported values include `json`
	   and `form`. The default is `form`.
	*/
	ContentType *string `json:"content_type,omitempty"`

	/*
	   Determines whether the SSL certificate of the host for `url` will be verified
	   when delivering payloads. Supported values include `0` (verification is
	   performed) and `1` (verification is not performed). The default is `0`. **We
	   strongly recommend not setting this to `1` as you are subject to
	   man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	   If provided, the `secret` will be used as the `key` to generate the HMAC hex
	   digest value in the
	   [`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	   header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
ReposUpdateWebhookReqBody is a request body for repos/update-webhook

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
type ReposUpdateWebhookReqBody struct {

	/*
	   Determines if notifications are sent when the webhook is triggered. Set to
	   `true` to send notifications.
	*/
	Active *bool `json:"active,omitempty"`

	/*
	   Determines a list of events to be added to the list of events that the Hook
	   triggers for.
	*/
	AddEvents []string `json:"add_events,omitempty"`

	/*
	   Key/value pairs to provide settings for this webhook. [These are defined
	   below](https://developer.github.com/v3/repos/hooks/#create-hook-config-params).
	*/
	Config *ReposUpdateWebhookReqBodyConfig `json:"config,omitempty"`

	/*
	   Determines what [events](https://developer.github.com/webhooks/event-payloads)
	   the hook is triggered for. This replaces the entire array of events.
	*/
	Events []string `json:"events,omitempty"`

	/*
	   Determines a list of events to be removed from the list of events that the Hook
	   triggers for.
	*/
	RemoveEvents []string `json:"remove_events,omitempty"`
}

/*
ReposUpdateWebhookResponseBody is a response body for ReposUpdateWebhook

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
type ReposUpdateWebhookResponseBody components.Hook

/*
ReposUpdateWebhookResponse is a response for ReposUpdateWebhook

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
type ReposUpdateWebhookResponse struct {
	response
	request *ReposUpdateWebhookReq
	Data    ReposUpdateWebhookResponseBody
}

/*
ReposUploadReleaseAsset performs requests for "repos/upload-release-asset"

Upload a release asset.

  POST /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
func ReposUploadReleaseAsset(ctx context.Context, req *ReposUploadReleaseAssetReq, opt ...RequestOption) (*ReposUploadReleaseAssetResponse, error) {
	if req == nil {
		req = new(ReposUploadReleaseAssetReq)
	}
	resp := &ReposUploadReleaseAssetResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ReposUploadReleaseAssetResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReposUploadReleaseAsset performs requests for "repos/upload-release-asset"

Upload a release asset.

  POST /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
func (c Client) ReposUploadReleaseAsset(ctx context.Context, req *ReposUploadReleaseAssetReq, opt ...RequestOption) (*ReposUploadReleaseAssetResponse, error) {
	return ReposUploadReleaseAsset(ctx, req, append(c, opt...)...)
}

/*
ReposUploadReleaseAssetReq is request data for Client.ReposUploadReleaseAsset

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
type ReposUploadReleaseAssetReq struct {
	_url string

	// URL to query. This must be explicitly set for this endpoint and any base URL set in options will be ignored.
	URL string

	// name parameter
	Name *string

	// label parameter
	Label *string

	// http request's body
	RequestBody io.Reader

	/*
	Size of the asset in bytes. Most libraries will calculate the header
	automatically
	*/
	ContentLengthHeader *string

	/*
	Media Type of the asset. For a list of media types, see
	https://www.iana.org/assignments/media-types/media-types.xhtml
	*/
	ContentTypeHeader *string
}

func (r *ReposUploadReleaseAssetReq) url() string {
	if r._url != "" {
		return r._url
	}
	return r.URL
}

func (r *ReposUploadReleaseAssetReq) urlPath() string {
	return ""
}

func (r *ReposUploadReleaseAssetReq) method() string {
	return "POST"
}

func (r *ReposUploadReleaseAssetReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Name != nil {
		query.Set("name", *r.Name)
	}
	if r.Label != nil {
		query.Set("label", *r.Label)
	}
	return query
}

func (r *ReposUploadReleaseAssetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"content-length": r.ContentLengthHeader,
		"content-type":   r.ContentTypeHeader,
	}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ReposUploadReleaseAssetReq) body() interface{} {
	return r.RequestBody
}

func (r *ReposUploadReleaseAssetReq) dataStatuses() []int {
	return []int{201}
}

func (r *ReposUploadReleaseAssetReq) validStatuses() []int {
	return []int{201}
}

func (r *ReposUploadReleaseAssetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBodyUploader, attrExplicitURL}
}

// HTTPRequest builds an *http.Request
func (r *ReposUploadReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposUploadReleaseAssetReq) Rel(link RelName, resp *ReposUploadReleaseAssetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposUploadReleaseAssetResponseBody is a response body for ReposUploadReleaseAsset

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
type ReposUploadReleaseAssetResponseBody components.ReleaseAsset

/*
ReposUploadReleaseAssetResponse is a response for ReposUploadReleaseAsset

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
type ReposUploadReleaseAssetResponse struct {
	response
	request *ReposUploadReleaseAssetReq
	Data    ReposUploadReleaseAssetResponseBody
}
