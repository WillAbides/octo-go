// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
GistsCheckIsStarred performs requests for "gists/check-is-starred"

Check if a gist is starred.

  GET /gists/{gist_id}/star

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
func (c *Client) GistsCheckIsStarred(ctx context.Context, req *GistsCheckIsStarredReq, opt ...RequestOption) (*GistsCheckIsStarredResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsCheckIsStarredResponse{
		request:  req,
		response: *r,
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsCheckIsStarredReq is request data for Client.GistsCheckIsStarred

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
type GistsCheckIsStarredReq struct {
	pgURL  string
	GistId string
}

func (r *GistsCheckIsStarredReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsCheckIsStarredReq) urlPath() string {
	return fmt.Sprintf("/gists/%v/star", r.GistId)
}

func (r *GistsCheckIsStarredReq) method() string {
	return "GET"
}

func (r *GistsCheckIsStarredReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GistsCheckIsStarredReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsCheckIsStarredReq) body() interface{} {
	return nil
}

func (r *GistsCheckIsStarredReq) dataStatuses() []int {
	return []int{}
}

func (r *GistsCheckIsStarredReq) validStatuses() []int {
	return []int{204}
}

func (r *GistsCheckIsStarredReq) endpointType() endpointType {
	return endpointTypeBoolean
}

// httpRequest creates an http request
func (r *GistsCheckIsStarredReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsCheckIsStarredReq) Rel(link RelName, resp *GistsCheckIsStarredResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsCheckIsStarredResponse is a response for GistsCheckIsStarred

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
type GistsCheckIsStarredResponse struct {
	response
	request *GistsCheckIsStarredReq
	Data    bool
}

/*
GistsCreate performs requests for "gists/create"

Create a gist.

  POST /gists

https://developer.github.com/v3/gists/#create-a-gist
*/
func (c *Client) GistsCreate(ctx context.Context, req *GistsCreateReq, opt ...RequestOption) (*GistsCreateResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsCreateResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsCreateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsCreateReq is request data for Client.GistsCreate

https://developer.github.com/v3/gists/#create-a-gist
*/
type GistsCreateReq struct {
	pgURL       string
	RequestBody GistsCreateReqBody
}

func (r *GistsCreateReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsCreateReq) urlPath() string {
	return fmt.Sprintf("/gists")
}

func (r *GistsCreateReq) method() string {
	return "POST"
}

func (r *GistsCreateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GistsCreateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsCreateReq) body() interface{} {
	return r.RequestBody
}

func (r *GistsCreateReq) dataStatuses() []int {
	return []int{201}
}

func (r *GistsCreateReq) validStatuses() []int {
	return []int{201}
}

func (r *GistsCreateReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsCreateReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsCreateReq) Rel(link RelName, resp *GistsCreateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

// GistsCreateReqBodyFiles is a value for GistsCreateReqBody's Files field
type GistsCreateReqBodyFiles struct {

	// The content of the file.
	Content *string `json:"content,omitempty"`
}

/*
GistsCreateReqBody is a request body for gists/create

https://developer.github.com/v3/gists/#create-a-gist
*/
type GistsCreateReqBody struct {

	// A descriptive name for this gist.
	Description *string `json:"description,omitempty"`

	/*
	   The filenames and content of each file in the gist. The keys in the `files`
	   object represent the filename and have the type `string`.
	*/
	Files map[string]*GistsCreateReqBodyFiles `json:"files"`

	// When `true`, the gist will be public and available for anyone to see.
	Public *bool `json:"public,omitempty"`
}

/*
GistsCreateResponseBody is a response body for GistsCreate

https://developer.github.com/v3/gists/#create-a-gist
*/
type GistsCreateResponseBody struct {
	components.Gist
}

/*
GistsCreateResponse is a response for GistsCreate

https://developer.github.com/v3/gists/#create-a-gist
*/
type GistsCreateResponse struct {
	response
	request *GistsCreateReq
	Data    *GistsCreateResponseBody
}

/*
GistsCreateComment performs requests for "gists/create-comment"

Create a comment.

  POST /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#create-a-comment
*/
func (c *Client) GistsCreateComment(ctx context.Context, req *GistsCreateCommentReq, opt ...RequestOption) (*GistsCreateCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsCreateCommentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsCreateCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsCreateCommentReq is request data for Client.GistsCreateComment

https://developer.github.com/v3/gists/comments/#create-a-comment
*/
type GistsCreateCommentReq struct {
	pgURL       string
	GistId      string
	RequestBody GistsCreateCommentReqBody
}

func (r *GistsCreateCommentReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsCreateCommentReq) urlPath() string {
	return fmt.Sprintf("/gists/%v/comments", r.GistId)
}

func (r *GistsCreateCommentReq) method() string {
	return "POST"
}

func (r *GistsCreateCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GistsCreateCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsCreateCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *GistsCreateCommentReq) dataStatuses() []int {
	return []int{201}
}

func (r *GistsCreateCommentReq) validStatuses() []int {
	return []int{201}
}

func (r *GistsCreateCommentReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsCreateCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsCreateCommentReq) Rel(link RelName, resp *GistsCreateCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsCreateCommentReqBody is a request body for gists/create-comment

https://developer.github.com/v3/gists/comments/#create-a-comment
*/
type GistsCreateCommentReqBody struct {

	// The comment text.
	Body *string `json:"body"`
}

/*
GistsCreateCommentResponseBody is a response body for GistsCreateComment

https://developer.github.com/v3/gists/comments/#create-a-comment
*/
type GistsCreateCommentResponseBody struct {
	components.GistComment
}

/*
GistsCreateCommentResponse is a response for GistsCreateComment

https://developer.github.com/v3/gists/comments/#create-a-comment
*/
type GistsCreateCommentResponse struct {
	response
	request *GistsCreateCommentReq
	Data    *GistsCreateCommentResponseBody
}

/*
GistsDelete performs requests for "gists/delete"

Delete a gist.

  DELETE /gists/{gist_id}

https://developer.github.com/v3/gists/#delete-a-gist
*/
func (c *Client) GistsDelete(ctx context.Context, req *GistsDeleteReq, opt ...RequestOption) (*GistsDeleteResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsDeleteResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsDeleteReq is request data for Client.GistsDelete

https://developer.github.com/v3/gists/#delete-a-gist
*/
type GistsDeleteReq struct {
	pgURL  string
	GistId string
}

func (r *GistsDeleteReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsDeleteReq) urlPath() string {
	return fmt.Sprintf("/gists/%v", r.GistId)
}

func (r *GistsDeleteReq) method() string {
	return "DELETE"
}

func (r *GistsDeleteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GistsDeleteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsDeleteReq) body() interface{} {
	return nil
}

func (r *GistsDeleteReq) dataStatuses() []int {
	return []int{}
}

func (r *GistsDeleteReq) validStatuses() []int {
	return []int{204}
}

func (r *GistsDeleteReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsDeleteReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsDeleteReq) Rel(link RelName, resp *GistsDeleteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsDeleteResponse is a response for GistsDelete

https://developer.github.com/v3/gists/#delete-a-gist
*/
type GistsDeleteResponse struct {
	response
	request *GistsDeleteReq
}

/*
GistsDeleteComment performs requests for "gists/delete-comment"

Delete a comment.

  DELETE /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#delete-a-comment
*/
func (c *Client) GistsDeleteComment(ctx context.Context, req *GistsDeleteCommentReq, opt ...RequestOption) (*GistsDeleteCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsDeleteCommentResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsDeleteCommentReq is request data for Client.GistsDeleteComment

https://developer.github.com/v3/gists/comments/#delete-a-comment
*/
type GistsDeleteCommentReq struct {
	pgURL     string
	GistId    string
	CommentId int64
}

func (r *GistsDeleteCommentReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsDeleteCommentReq) urlPath() string {
	return fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId)
}

func (r *GistsDeleteCommentReq) method() string {
	return "DELETE"
}

func (r *GistsDeleteCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GistsDeleteCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsDeleteCommentReq) body() interface{} {
	return nil
}

func (r *GistsDeleteCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *GistsDeleteCommentReq) validStatuses() []int {
	return []int{204}
}

func (r *GistsDeleteCommentReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsDeleteCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsDeleteCommentReq) Rel(link RelName, resp *GistsDeleteCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsDeleteCommentResponse is a response for GistsDeleteComment

https://developer.github.com/v3/gists/comments/#delete-a-comment
*/
type GistsDeleteCommentResponse struct {
	response
	request *GistsDeleteCommentReq
}

/*
GistsFork performs requests for "gists/fork"

Fork a gist.

  POST /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#fork-a-gist
*/
func (c *Client) GistsFork(ctx context.Context, req *GistsForkReq, opt ...RequestOption) (*GistsForkResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsForkResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsForkResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsForkReq is request data for Client.GistsFork

https://developer.github.com/v3/gists/#fork-a-gist
*/
type GistsForkReq struct {
	pgURL  string
	GistId string
}

func (r *GistsForkReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsForkReq) urlPath() string {
	return fmt.Sprintf("/gists/%v/forks", r.GistId)
}

func (r *GistsForkReq) method() string {
	return "POST"
}

func (r *GistsForkReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GistsForkReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsForkReq) body() interface{} {
	return nil
}

func (r *GistsForkReq) dataStatuses() []int {
	return []int{201}
}

func (r *GistsForkReq) validStatuses() []int {
	return []int{201}
}

func (r *GistsForkReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsForkReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsForkReq) Rel(link RelName, resp *GistsForkResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsForkResponseBody is a response body for GistsFork

https://developer.github.com/v3/gists/#fork-a-gist
*/
type GistsForkResponseBody struct {
	components.BaseGist
}

/*
GistsForkResponse is a response for GistsFork

https://developer.github.com/v3/gists/#fork-a-gist
*/
type GistsForkResponse struct {
	response
	request *GistsForkReq
	Data    *GistsForkResponseBody
}

/*
GistsGet performs requests for "gists/get"

Get a gist.

  GET /gists/{gist_id}

https://developer.github.com/v3/gists/#get-a-gist
*/
func (c *Client) GistsGet(ctx context.Context, req *GistsGetReq, opt ...RequestOption) (*GistsGetResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsGetResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsGetResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsGetReq is request data for Client.GistsGet

https://developer.github.com/v3/gists/#get-a-gist
*/
type GistsGetReq struct {
	pgURL  string
	GistId string
}

func (r *GistsGetReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsGetReq) urlPath() string {
	return fmt.Sprintf("/gists/%v", r.GistId)
}

func (r *GistsGetReq) method() string {
	return "GET"
}

func (r *GistsGetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GistsGetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsGetReq) body() interface{} {
	return nil
}

func (r *GistsGetReq) dataStatuses() []int {
	return []int{200}
}

func (r *GistsGetReq) validStatuses() []int {
	return []int{200}
}

func (r *GistsGetReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsGetReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsGetReq) Rel(link RelName, resp *GistsGetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsGetResponseBody is a response body for GistsGet

https://developer.github.com/v3/gists/#get-a-gist
*/
type GistsGetResponseBody struct {
	components.Gist
}

/*
GistsGetResponse is a response for GistsGet

https://developer.github.com/v3/gists/#get-a-gist
*/
type GistsGetResponse struct {
	response
	request *GistsGetReq
	Data    *GistsGetResponseBody
}

/*
GistsGetComment performs requests for "gists/get-comment"

Get a single comment.

  GET /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#get-a-single-comment
*/
func (c *Client) GistsGetComment(ctx context.Context, req *GistsGetCommentReq, opt ...RequestOption) (*GistsGetCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsGetCommentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsGetCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsGetCommentReq is request data for Client.GistsGetComment

https://developer.github.com/v3/gists/comments/#get-a-single-comment
*/
type GistsGetCommentReq struct {
	pgURL     string
	GistId    string
	CommentId int64
}

func (r *GistsGetCommentReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsGetCommentReq) urlPath() string {
	return fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId)
}

func (r *GistsGetCommentReq) method() string {
	return "GET"
}

func (r *GistsGetCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GistsGetCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsGetCommentReq) body() interface{} {
	return nil
}

func (r *GistsGetCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *GistsGetCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *GistsGetCommentReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsGetCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsGetCommentReq) Rel(link RelName, resp *GistsGetCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsGetCommentResponseBody is a response body for GistsGetComment

https://developer.github.com/v3/gists/comments/#get-a-single-comment
*/
type GistsGetCommentResponseBody struct {
	components.GistComment
}

/*
GistsGetCommentResponse is a response for GistsGetComment

https://developer.github.com/v3/gists/comments/#get-a-single-comment
*/
type GistsGetCommentResponse struct {
	response
	request *GistsGetCommentReq
	Data    *GistsGetCommentResponseBody
}

/*
GistsGetRevision performs requests for "gists/get-revision"

Get a specific revision of a gist.

  GET /gists/{gist_id}/{sha}

https://developer.github.com/v3/gists/#get-a-specific-revision-of-a-gist
*/
func (c *Client) GistsGetRevision(ctx context.Context, req *GistsGetRevisionReq, opt ...RequestOption) (*GistsGetRevisionResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsGetRevisionResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsGetRevisionResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsGetRevisionReq is request data for Client.GistsGetRevision

https://developer.github.com/v3/gists/#get-a-specific-revision-of-a-gist
*/
type GistsGetRevisionReq struct {
	pgURL  string
	GistId string
	Sha    string
}

func (r *GistsGetRevisionReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsGetRevisionReq) urlPath() string {
	return fmt.Sprintf("/gists/%v/%v", r.GistId, r.Sha)
}

func (r *GistsGetRevisionReq) method() string {
	return "GET"
}

func (r *GistsGetRevisionReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GistsGetRevisionReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsGetRevisionReq) body() interface{} {
	return nil
}

func (r *GistsGetRevisionReq) dataStatuses() []int {
	return []int{200}
}

func (r *GistsGetRevisionReq) validStatuses() []int {
	return []int{200}
}

func (r *GistsGetRevisionReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsGetRevisionReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsGetRevisionReq) Rel(link RelName, resp *GistsGetRevisionResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsGetRevisionResponseBody is a response body for GistsGetRevision

https://developer.github.com/v3/gists/#get-a-specific-revision-of-a-gist
*/
type GistsGetRevisionResponseBody struct {
	components.Gist
}

/*
GistsGetRevisionResponse is a response for GistsGetRevision

https://developer.github.com/v3/gists/#get-a-specific-revision-of-a-gist
*/
type GistsGetRevisionResponse struct {
	response
	request *GistsGetRevisionReq
	Data    *GistsGetRevisionResponseBody
}

/*
GistsList performs requests for "gists/list"

List gists for the authenticated user.

  GET /gists

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
func (c *Client) GistsList(ctx context.Context, req *GistsListReq, opt ...RequestOption) (*GistsListResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsListResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsListResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsListReq is request data for Client.GistsList

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
type GistsListReq struct {
	pgURL string

	/*
	This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
	format: `YYYY-MM-DDTHH:MM:SSZ`. Only gists updated at or after this time are
	returned.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *GistsListReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsListReq) urlPath() string {
	return fmt.Sprintf("/gists")
}

func (r *GistsListReq) method() string {
	return "GET"
}

func (r *GistsListReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *GistsListReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsListReq) body() interface{} {
	return nil
}

func (r *GistsListReq) dataStatuses() []int {
	return []int{200}
}

func (r *GistsListReq) validStatuses() []int {
	return []int{200}
}

func (r *GistsListReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsListReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListReq) Rel(link RelName, resp *GistsListResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsListResponseBody is a response body for GistsList

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
type GistsListResponseBody []struct {
	components.BaseGist
}

/*
GistsListResponse is a response for GistsList

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
type GistsListResponse struct {
	response
	request *GistsListReq
	Data    *GistsListResponseBody
}

/*
GistsListComments performs requests for "gists/list-comments"

List comments on a gist.

  GET /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#list-comments-on-a-gist
*/
func (c *Client) GistsListComments(ctx context.Context, req *GistsListCommentsReq, opt ...RequestOption) (*GistsListCommentsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsListCommentsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsListCommentsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsListCommentsReq is request data for Client.GistsListComments

https://developer.github.com/v3/gists/comments/#list-comments-on-a-gist
*/
type GistsListCommentsReq struct {
	pgURL  string
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *GistsListCommentsReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsListCommentsReq) urlPath() string {
	return fmt.Sprintf("/gists/%v/comments", r.GistId)
}

func (r *GistsListCommentsReq) method() string {
	return "GET"
}

func (r *GistsListCommentsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *GistsListCommentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsListCommentsReq) body() interface{} {
	return nil
}

func (r *GistsListCommentsReq) dataStatuses() []int {
	return []int{200}
}

func (r *GistsListCommentsReq) validStatuses() []int {
	return []int{200}
}

func (r *GistsListCommentsReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsListCommentsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListCommentsReq) Rel(link RelName, resp *GistsListCommentsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsListCommentsResponseBody is a response body for GistsListComments

https://developer.github.com/v3/gists/comments/#list-comments-on-a-gist
*/
type GistsListCommentsResponseBody []struct {
	components.GistComment
}

/*
GistsListCommentsResponse is a response for GistsListComments

https://developer.github.com/v3/gists/comments/#list-comments-on-a-gist
*/
type GistsListCommentsResponse struct {
	response
	request *GistsListCommentsReq
	Data    *GistsListCommentsResponseBody
}

/*
GistsListCommits performs requests for "gists/list-commits"

List gist commits.

  GET /gists/{gist_id}/commits

https://developer.github.com/v3/gists/#list-gist-commits
*/
func (c *Client) GistsListCommits(ctx context.Context, req *GistsListCommitsReq, opt ...RequestOption) (*GistsListCommitsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsListCommitsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsListCommitsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsListCommitsReq is request data for Client.GistsListCommits

https://developer.github.com/v3/gists/#list-gist-commits
*/
type GistsListCommitsReq struct {
	pgURL  string
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *GistsListCommitsReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsListCommitsReq) urlPath() string {
	return fmt.Sprintf("/gists/%v/commits", r.GistId)
}

func (r *GistsListCommitsReq) method() string {
	return "GET"
}

func (r *GistsListCommitsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *GistsListCommitsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsListCommitsReq) body() interface{} {
	return nil
}

func (r *GistsListCommitsReq) dataStatuses() []int {
	return []int{200}
}

func (r *GistsListCommitsReq) validStatuses() []int {
	return []int{200}
}

func (r *GistsListCommitsReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsListCommitsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListCommitsReq) Rel(link RelName, resp *GistsListCommitsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsListCommitsResponseBody is a response body for GistsListCommits

https://developer.github.com/v3/gists/#list-gist-commits
*/
type GistsListCommitsResponseBody []struct {
	components.GistCommit
}

/*
GistsListCommitsResponse is a response for GistsListCommits

https://developer.github.com/v3/gists/#list-gist-commits
*/
type GistsListCommitsResponse struct {
	response
	request *GistsListCommitsReq
	Data    *GistsListCommitsResponseBody
}

/*
GistsListForUser performs requests for "gists/list-for-user"

List gists for a user.

  GET /users/{username}/gists

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
func (c *Client) GistsListForUser(ctx context.Context, req *GistsListForUserReq, opt ...RequestOption) (*GistsListForUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsListForUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsListForUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsListForUserReq is request data for Client.GistsListForUser

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
type GistsListForUserReq struct {
	pgURL    string
	Username string

	/*
	This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
	format: `YYYY-MM-DDTHH:MM:SSZ`. Only gists updated at or after this time are
	returned.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *GistsListForUserReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsListForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/gists", r.Username)
}

func (r *GistsListForUserReq) method() string {
	return "GET"
}

func (r *GistsListForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *GistsListForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsListForUserReq) body() interface{} {
	return nil
}

func (r *GistsListForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *GistsListForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *GistsListForUserReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsListForUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListForUserReq) Rel(link RelName, resp *GistsListForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsListForUserResponseBody is a response body for GistsListForUser

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
type GistsListForUserResponseBody []struct {
	components.BaseGist
}

/*
GistsListForUserResponse is a response for GistsListForUser

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
type GistsListForUserResponse struct {
	response
	request *GistsListForUserReq
	Data    *GistsListForUserResponseBody
}

/*
GistsListForks performs requests for "gists/list-forks"

List gist forks.

  GET /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#list-gist-forks
*/
func (c *Client) GistsListForks(ctx context.Context, req *GistsListForksReq, opt ...RequestOption) (*GistsListForksResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsListForksResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsListForksResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsListForksReq is request data for Client.GistsListForks

https://developer.github.com/v3/gists/#list-gist-forks
*/
type GistsListForksReq struct {
	pgURL  string
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *GistsListForksReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsListForksReq) urlPath() string {
	return fmt.Sprintf("/gists/%v/forks", r.GistId)
}

func (r *GistsListForksReq) method() string {
	return "GET"
}

func (r *GistsListForksReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *GistsListForksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsListForksReq) body() interface{} {
	return nil
}

func (r *GistsListForksReq) dataStatuses() []int {
	return []int{200}
}

func (r *GistsListForksReq) validStatuses() []int {
	return []int{200}
}

func (r *GistsListForksReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsListForksReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListForksReq) Rel(link RelName, resp *GistsListForksResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsListForksResponseBody is a response body for GistsListForks

https://developer.github.com/v3/gists/#list-gist-forks
*/
type GistsListForksResponseBody []struct {
	components.GistFork
}

/*
GistsListForksResponse is a response for GistsListForks

https://developer.github.com/v3/gists/#list-gist-forks
*/
type GistsListForksResponse struct {
	response
	request *GistsListForksReq
	Data    *GistsListForksResponseBody
}

/*
GistsListPublic performs requests for "gists/list-public"

List public gists.

  GET /gists/public

https://developer.github.com/v3/gists/#list-public-gists
*/
func (c *Client) GistsListPublic(ctx context.Context, req *GistsListPublicReq, opt ...RequestOption) (*GistsListPublicResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsListPublicResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsListPublicResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsListPublicReq is request data for Client.GistsListPublic

https://developer.github.com/v3/gists/#list-public-gists
*/
type GistsListPublicReq struct {
	pgURL string

	/*
	This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
	format: `YYYY-MM-DDTHH:MM:SSZ`. Only gists updated at or after this time are
	returned.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *GistsListPublicReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsListPublicReq) urlPath() string {
	return fmt.Sprintf("/gists/public")
}

func (r *GistsListPublicReq) method() string {
	return "GET"
}

func (r *GistsListPublicReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *GistsListPublicReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsListPublicReq) body() interface{} {
	return nil
}

func (r *GistsListPublicReq) dataStatuses() []int {
	return []int{200}
}

func (r *GistsListPublicReq) validStatuses() []int {
	return []int{200}
}

func (r *GistsListPublicReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsListPublicReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListPublicReq) Rel(link RelName, resp *GistsListPublicResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsListPublicResponseBody is a response body for GistsListPublic

https://developer.github.com/v3/gists/#list-public-gists
*/
type GistsListPublicResponseBody []struct {
	components.BaseGist
}

/*
GistsListPublicResponse is a response for GistsListPublic

https://developer.github.com/v3/gists/#list-public-gists
*/
type GistsListPublicResponse struct {
	response
	request *GistsListPublicReq
	Data    *GistsListPublicResponseBody
}

/*
GistsListStarred performs requests for "gists/list-starred"

List starred gists.

  GET /gists/starred

https://developer.github.com/v3/gists/#list-starred-gists
*/
func (c *Client) GistsListStarred(ctx context.Context, req *GistsListStarredReq, opt ...RequestOption) (*GistsListStarredResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsListStarredResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsListStarredResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsListStarredReq is request data for Client.GistsListStarred

https://developer.github.com/v3/gists/#list-starred-gists
*/
type GistsListStarredReq struct {
	pgURL string

	/*
	This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
	format: `YYYY-MM-DDTHH:MM:SSZ`. Only gists updated at or after this time are
	returned.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *GistsListStarredReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsListStarredReq) urlPath() string {
	return fmt.Sprintf("/gists/starred")
}

func (r *GistsListStarredReq) method() string {
	return "GET"
}

func (r *GistsListStarredReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *GistsListStarredReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsListStarredReq) body() interface{} {
	return nil
}

func (r *GistsListStarredReq) dataStatuses() []int {
	return []int{200}
}

func (r *GistsListStarredReq) validStatuses() []int {
	return []int{200}
}

func (r *GistsListStarredReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsListStarredReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListStarredReq) Rel(link RelName, resp *GistsListStarredResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsListStarredResponseBody is a response body for GistsListStarred

https://developer.github.com/v3/gists/#list-starred-gists
*/
type GistsListStarredResponseBody []struct {
	components.BaseGist
}

/*
GistsListStarredResponse is a response for GistsListStarred

https://developer.github.com/v3/gists/#list-starred-gists
*/
type GistsListStarredResponse struct {
	response
	request *GistsListStarredReq
	Data    *GistsListStarredResponseBody
}

/*
GistsStar performs requests for "gists/star"

Star a gist.

  PUT /gists/{gist_id}/star

https://developer.github.com/v3/gists/#star-a-gist
*/
func (c *Client) GistsStar(ctx context.Context, req *GistsStarReq, opt ...RequestOption) (*GistsStarResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsStarResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsStarReq is request data for Client.GistsStar

https://developer.github.com/v3/gists/#star-a-gist
*/
type GistsStarReq struct {
	pgURL  string
	GistId string
}

func (r *GistsStarReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsStarReq) urlPath() string {
	return fmt.Sprintf("/gists/%v/star", r.GistId)
}

func (r *GistsStarReq) method() string {
	return "PUT"
}

func (r *GistsStarReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GistsStarReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsStarReq) body() interface{} {
	return nil
}

func (r *GistsStarReq) dataStatuses() []int {
	return []int{}
}

func (r *GistsStarReq) validStatuses() []int {
	return []int{204}
}

func (r *GistsStarReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsStarReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsStarReq) Rel(link RelName, resp *GistsStarResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsStarResponse is a response for GistsStar

https://developer.github.com/v3/gists/#star-a-gist
*/
type GistsStarResponse struct {
	response
	request *GistsStarReq
}

/*
GistsUnstar performs requests for "gists/unstar"

Unstar a gist.

  DELETE /gists/{gist_id}/star

https://developer.github.com/v3/gists/#unstar-a-gist
*/
func (c *Client) GistsUnstar(ctx context.Context, req *GistsUnstarReq, opt ...RequestOption) (*GistsUnstarResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsUnstarResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsUnstarReq is request data for Client.GistsUnstar

https://developer.github.com/v3/gists/#unstar-a-gist
*/
type GistsUnstarReq struct {
	pgURL  string
	GistId string
}

func (r *GistsUnstarReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsUnstarReq) urlPath() string {
	return fmt.Sprintf("/gists/%v/star", r.GistId)
}

func (r *GistsUnstarReq) method() string {
	return "DELETE"
}

func (r *GistsUnstarReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GistsUnstarReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsUnstarReq) body() interface{} {
	return nil
}

func (r *GistsUnstarReq) dataStatuses() []int {
	return []int{}
}

func (r *GistsUnstarReq) validStatuses() []int {
	return []int{204}
}

func (r *GistsUnstarReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsUnstarReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsUnstarReq) Rel(link RelName, resp *GistsUnstarResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsUnstarResponse is a response for GistsUnstar

https://developer.github.com/v3/gists/#unstar-a-gist
*/
type GistsUnstarResponse struct {
	response
	request *GistsUnstarReq
}

/*
GistsUpdate performs requests for "gists/update"

Update a gist.

  PATCH /gists/{gist_id}

https://developer.github.com/v3/gists/#update-a-gist
*/
func (c *Client) GistsUpdate(ctx context.Context, req *GistsUpdateReq, opt ...RequestOption) (*GistsUpdateResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsUpdateResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsUpdateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsUpdateReq is request data for Client.GistsUpdate

https://developer.github.com/v3/gists/#update-a-gist
*/
type GistsUpdateReq struct {
	pgURL       string
	GistId      string
	RequestBody GistsUpdateReqBody
}

func (r *GistsUpdateReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsUpdateReq) urlPath() string {
	return fmt.Sprintf("/gists/%v", r.GistId)
}

func (r *GistsUpdateReq) method() string {
	return "PATCH"
}

func (r *GistsUpdateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GistsUpdateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsUpdateReq) body() interface{} {
	return r.RequestBody
}

func (r *GistsUpdateReq) dataStatuses() []int {
	return []int{200}
}

func (r *GistsUpdateReq) validStatuses() []int {
	return []int{200}
}

func (r *GistsUpdateReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsUpdateReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsUpdateReq) Rel(link RelName, resp *GistsUpdateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

// GistsUpdateReqBodyFiles is a value for GistsUpdateReqBody's Files field
type GistsUpdateReqBodyFiles struct {

	// The updated content of the file.
	Content *string `json:"content,omitempty"`

	/*
	   The new name for this file. To delete a file, set the value of the filename to
	   `null`.
	*/
	Filename *string `json:"filename,omitempty"`
}

/*
GistsUpdateReqBody is a request body for gists/update

https://developer.github.com/v3/gists/#update-a-gist
*/
type GistsUpdateReqBody struct {

	// A descriptive name for this gist.
	Description *string `json:"description,omitempty"`

	// The filenames and content that make up this gist.
	Files map[string]*GistsUpdateReqBodyFiles `json:"files,omitempty"`
}

/*
GistsUpdateResponseBody is a response body for GistsUpdate

https://developer.github.com/v3/gists/#update-a-gist
*/
type GistsUpdateResponseBody struct {
	components.Gist
}

/*
GistsUpdateResponse is a response for GistsUpdate

https://developer.github.com/v3/gists/#update-a-gist
*/
type GistsUpdateResponse struct {
	response
	request *GistsUpdateReq
	Data    *GistsUpdateResponseBody
}

/*
GistsUpdateComment performs requests for "gists/update-comment"

Edit a comment.

  PATCH /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#edit-a-comment
*/
func (c *Client) GistsUpdateComment(ctx context.Context, req *GistsUpdateCommentReq, opt ...RequestOption) (*GistsUpdateCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &GistsUpdateCommentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(GistsUpdateCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsUpdateCommentReq is request data for Client.GistsUpdateComment

https://developer.github.com/v3/gists/comments/#edit-a-comment
*/
type GistsUpdateCommentReq struct {
	pgURL       string
	GistId      string
	CommentId   int64
	RequestBody GistsUpdateCommentReqBody
}

func (r *GistsUpdateCommentReq) pagingURL() string {
	return r.pgURL
}

func (r *GistsUpdateCommentReq) urlPath() string {
	return fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId)
}

func (r *GistsUpdateCommentReq) method() string {
	return "PATCH"
}

func (r *GistsUpdateCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GistsUpdateCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GistsUpdateCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *GistsUpdateCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *GistsUpdateCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *GistsUpdateCommentReq) endpointType() endpointType {
	return endpointTypeRegular
}

// httpRequest creates an http request
func (r *GistsUpdateCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsUpdateCommentReq) Rel(link RelName, resp *GistsUpdateCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
GistsUpdateCommentReqBody is a request body for gists/update-comment

https://developer.github.com/v3/gists/comments/#edit-a-comment
*/
type GistsUpdateCommentReqBody struct {

	// The comment text.
	Body *string `json:"body"`
}

/*
GistsUpdateCommentResponseBody is a response body for GistsUpdateComment

https://developer.github.com/v3/gists/comments/#edit-a-comment
*/
type GistsUpdateCommentResponseBody struct {
	components.GistComment
}

/*
GistsUpdateCommentResponse is a response for GistsUpdateComment

https://developer.github.com/v3/gists/comments/#edit-a-comment
*/
type GistsUpdateCommentResponse struct {
	response
	request *GistsUpdateCommentReq
	Data    *GistsUpdateCommentResponseBody
}
