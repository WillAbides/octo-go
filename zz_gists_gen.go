// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
GistsCheckIsStarred performs requests for "gists/check-is-starred"

Check if a gist is starred.

  GET /gists/{gist_id}/star

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
func GistsCheckIsStarred(ctx context.Context, req *GistsCheckIsStarredReq, opt ...options.Option) (*GistsCheckIsStarredResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsCheckIsStarredReq)
	}
	resp := &GistsCheckIsStarredResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsCheckIsStarred performs requests for "gists/check-is-starred"

Check if a gist is starred.

  GET /gists/{gist_id}/star

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
func (c Client) GistsCheckIsStarred(ctx context.Context, req *GistsCheckIsStarredReq, opt ...options.Option) (*GistsCheckIsStarredResponse, error) {
	return GistsCheckIsStarred(ctx, req, append(c, opt...)...)
}

/*
GistsCheckIsStarredReq is request data for Client.GistsCheckIsStarred

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
type GistsCheckIsStarredReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *GistsCheckIsStarredReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsCheckIsStarredReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "gists/check-is-starred",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/star", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsCheckIsStarredReq) Rel(link RelName, resp *GistsCheckIsStarredResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsCheckIsStarredResponse is a response for GistsCheckIsStarred

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
type GistsCheckIsStarredResponse struct {
	internal.Response
	request *GistsCheckIsStarredReq
}

/*
GistsCreate performs requests for "gists/create"

Create a gist.

  POST /gists

https://developer.github.com/v3/gists/#create-a-gist
*/
func GistsCreate(ctx context.Context, req *GistsCreateReq, opt ...options.Option) (*GistsCreateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsCreateReq)
	}
	resp := &GistsCreateResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistFull{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsCreate performs requests for "gists/create"

Create a gist.

  POST /gists

https://developer.github.com/v3/gists/#create-a-gist
*/
func (c Client) GistsCreate(ctx context.Context, req *GistsCreateReq, opt ...options.Option) (*GistsCreateResponse, error) {
	return GistsCreate(ctx, req, append(c, opt...)...)
}

/*
GistsCreateReq is request data for Client.GistsCreate

https://developer.github.com/v3/gists/#create-a-gist
*/
type GistsCreateReq struct {
	_url        string
	RequestBody GistsCreateReqBody
}

// HTTPRequest builds an *http.Request
func (r *GistsCreateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsCreateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "gists/create",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsCreateReq) Rel(link RelName, resp *GistsCreateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// GistsCreateReqBodyFiles is a value for GistsCreateReqBody's Files field
type GistsCreateReqBodyFiles struct {

	// Content of the file
	Content *string `json:"content"`
}

/*
GistsCreateReqBody is a request body for gists/create

https://developer.github.com/v3/gists/#create-a-gist
*/
type GistsCreateReqBody struct {

	// Description of the gist
	Description *string `json:"description,omitempty"`

	// Names and content for the files that make up the gist
	Files map[string]GistsCreateReqBodyFiles `json:"files"`

	// Flag indicating whether the gist is public
	Public *bool `json:"public,omitempty"`
}

/*
GistsCreateResponse is a response for GistsCreate

https://developer.github.com/v3/gists/#create-a-gist
*/
type GistsCreateResponse struct {
	internal.Response
	request *GistsCreateReq
	Data    components.GistFull
}

/*
GistsCreateComment performs requests for "gists/create-comment"

Create a gist comment.

  POST /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
func GistsCreateComment(ctx context.Context, req *GistsCreateCommentReq, opt ...options.Option) (*GistsCreateCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsCreateCommentReq)
	}
	resp := &GistsCreateCommentResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistComment{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsCreateComment performs requests for "gists/create-comment"

Create a gist comment.

  POST /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
func (c Client) GistsCreateComment(ctx context.Context, req *GistsCreateCommentReq, opt ...options.Option) (*GistsCreateCommentResponse, error) {
	return GistsCreateComment(ctx, req, append(c, opt...)...)
}

/*
GistsCreateCommentReq is request data for Client.GistsCreateComment

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
type GistsCreateCommentReq struct {
	_url string

	// gist_id parameter
	GistId      string
	RequestBody GistsCreateCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *GistsCreateCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsCreateCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "gists/create-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/comments", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsCreateCommentReq) Rel(link RelName, resp *GistsCreateCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsCreateCommentReqBody is a request body for gists/create-comment

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
type GistsCreateCommentReqBody struct {

	// The comment text.
	Body *string `json:"body"`
}

/*
GistsCreateCommentResponse is a response for GistsCreateComment

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
type GistsCreateCommentResponse struct {
	internal.Response
	request *GistsCreateCommentReq
	Data    components.GistComment
}

/*
GistsDelete performs requests for "gists/delete"

Delete a gist.

  DELETE /gists/{gist_id}

https://developer.github.com/v3/gists/#delete-a-gist
*/
func GistsDelete(ctx context.Context, req *GistsDeleteReq, opt ...options.Option) (*GistsDeleteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsDeleteReq)
	}
	resp := &GistsDeleteResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsDelete performs requests for "gists/delete"

Delete a gist.

  DELETE /gists/{gist_id}

https://developer.github.com/v3/gists/#delete-a-gist
*/
func (c Client) GistsDelete(ctx context.Context, req *GistsDeleteReq, opt ...options.Option) (*GistsDeleteResponse, error) {
	return GistsDelete(ctx, req, append(c, opt...)...)
}

/*
GistsDeleteReq is request data for Client.GistsDelete

https://developer.github.com/v3/gists/#delete-a-gist
*/
type GistsDeleteReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *GistsDeleteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsDeleteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "gists/delete",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsDeleteReq) Rel(link RelName, resp *GistsDeleteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsDeleteResponse is a response for GistsDelete

https://developer.github.com/v3/gists/#delete-a-gist
*/
type GistsDeleteResponse struct {
	internal.Response
	request *GistsDeleteReq
}

/*
GistsDeleteComment performs requests for "gists/delete-comment"

Delete a gist comment.

  DELETE /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
func GistsDeleteComment(ctx context.Context, req *GistsDeleteCommentReq, opt ...options.Option) (*GistsDeleteCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsDeleteCommentReq)
	}
	resp := &GistsDeleteCommentResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsDeleteComment performs requests for "gists/delete-comment"

Delete a gist comment.

  DELETE /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
func (c Client) GistsDeleteComment(ctx context.Context, req *GistsDeleteCommentReq, opt ...options.Option) (*GistsDeleteCommentResponse, error) {
	return GistsDeleteComment(ctx, req, append(c, opt...)...)
}

/*
GistsDeleteCommentReq is request data for Client.GistsDeleteComment

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
type GistsDeleteCommentReq struct {
	_url string

	// gist_id parameter
	GistId string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request
func (r *GistsDeleteCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsDeleteCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "gists/delete-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsDeleteCommentReq) Rel(link RelName, resp *GistsDeleteCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsDeleteCommentResponse is a response for GistsDeleteComment

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
type GistsDeleteCommentResponse struct {
	internal.Response
	request *GistsDeleteCommentReq
}

/*
GistsFork performs requests for "gists/fork"

Fork a gist.

  POST /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#fork-a-gist
*/
func GistsFork(ctx context.Context, req *GistsForkReq, opt ...options.Option) (*GistsForkResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsForkReq)
	}
	resp := &GistsForkResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.BaseGist{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsFork performs requests for "gists/fork"

Fork a gist.

  POST /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#fork-a-gist
*/
func (c Client) GistsFork(ctx context.Context, req *GistsForkReq, opt ...options.Option) (*GistsForkResponse, error) {
	return GistsFork(ctx, req, append(c, opt...)...)
}

/*
GistsForkReq is request data for Client.GistsFork

https://developer.github.com/v3/gists/#fork-a-gist
*/
type GistsForkReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *GistsForkReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsForkReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{201},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "POST",
		OperationID:      "gists/fork",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/forks", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsForkReq) Rel(link RelName, resp *GistsForkResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsForkResponse is a response for GistsFork

https://developer.github.com/v3/gists/#fork-a-gist
*/
type GistsForkResponse struct {
	internal.Response
	request *GistsForkReq
	Data    components.BaseGist
}

/*
GistsGet performs requests for "gists/get"

Get a gist.

  GET /gists/{gist_id}

https://developer.github.com/v3/gists/#get-a-gist
*/
func GistsGet(ctx context.Context, req *GistsGetReq, opt ...options.Option) (*GistsGetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsGetReq)
	}
	resp := &GistsGetResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistFull{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsGet performs requests for "gists/get"

Get a gist.

  GET /gists/{gist_id}

https://developer.github.com/v3/gists/#get-a-gist
*/
func (c Client) GistsGet(ctx context.Context, req *GistsGetReq, opt ...options.Option) (*GistsGetResponse, error) {
	return GistsGet(ctx, req, append(c, opt...)...)
}

/*
GistsGetReq is request data for Client.GistsGet

https://developer.github.com/v3/gists/#get-a-gist
*/
type GistsGetReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *GistsGetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsGetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "gists/get",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsGetReq) Rel(link RelName, resp *GistsGetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsGetResponse is a response for GistsGet

https://developer.github.com/v3/gists/#get-a-gist
*/
type GistsGetResponse struct {
	internal.Response
	request *GistsGetReq
	Data    components.GistFull
}

/*
GistsGetComment performs requests for "gists/get-comment"

Get a gist comment.

  GET /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
func GistsGetComment(ctx context.Context, req *GistsGetCommentReq, opt ...options.Option) (*GistsGetCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsGetCommentReq)
	}
	resp := &GistsGetCommentResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistComment{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsGetComment performs requests for "gists/get-comment"

Get a gist comment.

  GET /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
func (c Client) GistsGetComment(ctx context.Context, req *GistsGetCommentReq, opt ...options.Option) (*GistsGetCommentResponse, error) {
	return GistsGetComment(ctx, req, append(c, opt...)...)
}

/*
GistsGetCommentReq is request data for Client.GistsGetComment

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
type GistsGetCommentReq struct {
	_url string

	// gist_id parameter
	GistId string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request
func (r *GistsGetCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsGetCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "gists/get-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsGetCommentReq) Rel(link RelName, resp *GistsGetCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsGetCommentResponse is a response for GistsGetComment

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
type GistsGetCommentResponse struct {
	internal.Response
	request *GistsGetCommentReq
	Data    components.GistComment
}

/*
GistsGetRevision performs requests for "gists/get-revision"

Get a gist revision.

  GET /gists/{gist_id}/{sha}

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
func GistsGetRevision(ctx context.Context, req *GistsGetRevisionReq, opt ...options.Option) (*GistsGetRevisionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsGetRevisionReq)
	}
	resp := &GistsGetRevisionResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistFull{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsGetRevision performs requests for "gists/get-revision"

Get a gist revision.

  GET /gists/{gist_id}/{sha}

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
func (c Client) GistsGetRevision(ctx context.Context, req *GistsGetRevisionReq, opt ...options.Option) (*GistsGetRevisionResponse, error) {
	return GistsGetRevision(ctx, req, append(c, opt...)...)
}

/*
GistsGetRevisionReq is request data for Client.GistsGetRevision

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
type GistsGetRevisionReq struct {
	_url string

	// gist_id parameter
	GistId string

	// sha parameter
	Sha string
}

// HTTPRequest builds an *http.Request
func (r *GistsGetRevisionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsGetRevisionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "gists/get-revision",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/%v", r.GistId, r.Sha),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsGetRevisionReq) Rel(link RelName, resp *GistsGetRevisionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsGetRevisionResponse is a response for GistsGetRevision

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
type GistsGetRevisionResponse struct {
	internal.Response
	request *GistsGetRevisionReq
	Data    components.GistFull
}

/*
GistsList performs requests for "gists/list"

List gists for the authenticated user.

  GET /gists

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
func GistsList(ctx context.Context, req *GistsListReq, opt ...options.Option) (*GistsListResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsListReq)
	}
	resp := &GistsListResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.BaseGist{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsList performs requests for "gists/list"

List gists for the authenticated user.

  GET /gists

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
func (c Client) GistsList(ctx context.Context, req *GistsListReq, opt ...options.Option) (*GistsListResponse, error) {
	return GistsList(ctx, req, append(c, opt...)...)
}

/*
GistsListReq is request data for Client.GistsList

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
type GistsListReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *GistsListReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListReq) Rel(link RelName, resp *GistsListResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsListResponse is a response for GistsList

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
type GistsListResponse struct {
	internal.Response
	request *GistsListReq
	Data    []components.BaseGist
}

/*
GistsListComments performs requests for "gists/list-comments"

List gist comments.

  GET /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
func GistsListComments(ctx context.Context, req *GistsListCommentsReq, opt ...options.Option) (*GistsListCommentsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsListCommentsReq)
	}
	resp := &GistsListCommentsResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.GistComment{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsListComments performs requests for "gists/list-comments"

List gist comments.

  GET /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
func (c Client) GistsListComments(ctx context.Context, req *GistsListCommentsReq, opt ...options.Option) (*GistsListCommentsResponse, error) {
	return GistsListComments(ctx, req, append(c, opt...)...)
}

/*
GistsListCommentsReq is request data for Client.GistsListComments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
type GistsListCommentsReq struct {
	_url string

	// gist_id parameter
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *GistsListCommentsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsListCommentsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list-comments",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/comments", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListCommentsReq) Rel(link RelName, resp *GistsListCommentsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsListCommentsResponse is a response for GistsListComments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
type GistsListCommentsResponse struct {
	internal.Response
	request *GistsListCommentsReq
	Data    []components.GistComment
}

/*
GistsListCommits performs requests for "gists/list-commits"

List gist commits.

  GET /gists/{gist_id}/commits

https://developer.github.com/v3/gists/#list-gist-commits
*/
func GistsListCommits(ctx context.Context, req *GistsListCommitsReq, opt ...options.Option) (*GistsListCommitsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsListCommitsReq)
	}
	resp := &GistsListCommitsResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.GistCommit{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsListCommits performs requests for "gists/list-commits"

List gist commits.

  GET /gists/{gist_id}/commits

https://developer.github.com/v3/gists/#list-gist-commits
*/
func (c Client) GistsListCommits(ctx context.Context, req *GistsListCommitsReq, opt ...options.Option) (*GistsListCommitsResponse, error) {
	return GistsListCommits(ctx, req, append(c, opt...)...)
}

/*
GistsListCommitsReq is request data for Client.GistsListCommits

https://developer.github.com/v3/gists/#list-gist-commits
*/
type GistsListCommitsReq struct {
	_url string

	// gist_id parameter
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *GistsListCommitsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsListCommitsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list-commits",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/commits", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListCommitsReq) Rel(link RelName, resp *GistsListCommitsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsListCommitsResponse is a response for GistsListCommits

https://developer.github.com/v3/gists/#list-gist-commits
*/
type GistsListCommitsResponse struct {
	internal.Response
	request *GistsListCommitsReq
	Data    []components.GistCommit
}

/*
GistsListForUser performs requests for "gists/list-for-user"

List gists for a user.

  GET /users/{username}/gists

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
func GistsListForUser(ctx context.Context, req *GistsListForUserReq, opt ...options.Option) (*GistsListForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsListForUserReq)
	}
	resp := &GistsListForUserResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.BaseGist{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsListForUser performs requests for "gists/list-for-user"

List gists for a user.

  GET /users/{username}/gists

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
func (c Client) GistsListForUser(ctx context.Context, req *GistsListForUserReq, opt ...options.Option) (*GistsListForUserResponse, error) {
	return GistsListForUser(ctx, req, append(c, opt...)...)
}

/*
GistsListForUserReq is request data for Client.GistsListForUser

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
type GistsListForUserReq struct {
	_url     string
	Username string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *GistsListForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsListForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/gists", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListForUserReq) Rel(link RelName, resp *GistsListForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsListForUserResponse is a response for GistsListForUser

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
type GistsListForUserResponse struct {
	internal.Response
	request *GistsListForUserReq
	Data    []components.BaseGist
}

/*
GistsListForks performs requests for "gists/list-forks"

List gist forks.

  GET /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#list-gist-forks
*/
func GistsListForks(ctx context.Context, req *GistsListForksReq, opt ...options.Option) (*GistsListForksResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsListForksReq)
	}
	resp := &GistsListForksResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.GistFull{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsListForks performs requests for "gists/list-forks"

List gist forks.

  GET /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#list-gist-forks
*/
func (c Client) GistsListForks(ctx context.Context, req *GistsListForksReq, opt ...options.Option) (*GistsListForksResponse, error) {
	return GistsListForks(ctx, req, append(c, opt...)...)
}

/*
GistsListForksReq is request data for Client.GistsListForks

https://developer.github.com/v3/gists/#list-gist-forks
*/
type GistsListForksReq struct {
	_url string

	// gist_id parameter
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *GistsListForksReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsListForksReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list-forks",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/forks", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListForksReq) Rel(link RelName, resp *GistsListForksResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsListForksResponse is a response for GistsListForks

https://developer.github.com/v3/gists/#list-gist-forks
*/
type GistsListForksResponse struct {
	internal.Response
	request *GistsListForksReq
	Data    []components.GistFull
}

/*
GistsListPublic performs requests for "gists/list-public"

List public gists.

  GET /gists/public

https://developer.github.com/v3/gists/#list-public-gists
*/
func GistsListPublic(ctx context.Context, req *GistsListPublicReq, opt ...options.Option) (*GistsListPublicResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsListPublicReq)
	}
	resp := &GistsListPublicResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.BaseGist{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsListPublic performs requests for "gists/list-public"

List public gists.

  GET /gists/public

https://developer.github.com/v3/gists/#list-public-gists
*/
func (c Client) GistsListPublic(ctx context.Context, req *GistsListPublicReq, opt ...options.Option) (*GistsListPublicResponse, error) {
	return GistsListPublic(ctx, req, append(c, opt...)...)
}

/*
GistsListPublicReq is request data for Client.GistsListPublic

https://developer.github.com/v3/gists/#list-public-gists
*/
type GistsListPublicReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *GistsListPublicReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsListPublicReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list-public",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/public"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListPublicReq) Rel(link RelName, resp *GistsListPublicResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsListPublicResponse is a response for GistsListPublic

https://developer.github.com/v3/gists/#list-public-gists
*/
type GistsListPublicResponse struct {
	internal.Response
	request *GistsListPublicReq
	Data    []components.BaseGist
}

/*
GistsListStarred performs requests for "gists/list-starred"

List starred gists.

  GET /gists/starred

https://developer.github.com/v3/gists/#list-starred-gists
*/
func GistsListStarred(ctx context.Context, req *GistsListStarredReq, opt ...options.Option) (*GistsListStarredResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsListStarredReq)
	}
	resp := &GistsListStarredResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.BaseGist{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsListStarred performs requests for "gists/list-starred"

List starred gists.

  GET /gists/starred

https://developer.github.com/v3/gists/#list-starred-gists
*/
func (c Client) GistsListStarred(ctx context.Context, req *GistsListStarredReq, opt ...options.Option) (*GistsListStarredResponse, error) {
	return GistsListStarred(ctx, req, append(c, opt...)...)
}

/*
GistsListStarredReq is request data for Client.GistsListStarred

https://developer.github.com/v3/gists/#list-starred-gists
*/
type GistsListStarredReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *GistsListStarredReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsListStarredReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list-starred",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/starred"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsListStarredReq) Rel(link RelName, resp *GistsListStarredResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsListStarredResponse is a response for GistsListStarred

https://developer.github.com/v3/gists/#list-starred-gists
*/
type GistsListStarredResponse struct {
	internal.Response
	request *GistsListStarredReq
	Data    []components.BaseGist
}

/*
GistsStar performs requests for "gists/star"

Star a gist.

  PUT /gists/{gist_id}/star

https://developer.github.com/v3/gists/#star-a-gist
*/
func GistsStar(ctx context.Context, req *GistsStarReq, opt ...options.Option) (*GistsStarResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsStarReq)
	}
	resp := &GistsStarResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsStar performs requests for "gists/star"

Star a gist.

  PUT /gists/{gist_id}/star

https://developer.github.com/v3/gists/#star-a-gist
*/
func (c Client) GistsStar(ctx context.Context, req *GistsStarReq, opt ...options.Option) (*GistsStarResponse, error) {
	return GistsStar(ctx, req, append(c, opt...)...)
}

/*
GistsStarReq is request data for Client.GistsStar

https://developer.github.com/v3/gists/#star-a-gist
*/
type GistsStarReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *GistsStarReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsStarReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "gists/star",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/star", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsStarReq) Rel(link RelName, resp *GistsStarResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsStarResponse is a response for GistsStar

https://developer.github.com/v3/gists/#star-a-gist
*/
type GistsStarResponse struct {
	internal.Response
	request *GistsStarReq
}

/*
GistsUnstar performs requests for "gists/unstar"

Unstar a gist.

  DELETE /gists/{gist_id}/star

https://developer.github.com/v3/gists/#unstar-a-gist
*/
func GistsUnstar(ctx context.Context, req *GistsUnstarReq, opt ...options.Option) (*GistsUnstarResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsUnstarReq)
	}
	resp := &GistsUnstarResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsUnstar performs requests for "gists/unstar"

Unstar a gist.

  DELETE /gists/{gist_id}/star

https://developer.github.com/v3/gists/#unstar-a-gist
*/
func (c Client) GistsUnstar(ctx context.Context, req *GistsUnstarReq, opt ...options.Option) (*GistsUnstarResponse, error) {
	return GistsUnstar(ctx, req, append(c, opt...)...)
}

/*
GistsUnstarReq is request data for Client.GistsUnstar

https://developer.github.com/v3/gists/#unstar-a-gist
*/
type GistsUnstarReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *GistsUnstarReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsUnstarReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "gists/unstar",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/star", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsUnstarReq) Rel(link RelName, resp *GistsUnstarResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsUnstarResponse is a response for GistsUnstar

https://developer.github.com/v3/gists/#unstar-a-gist
*/
type GistsUnstarResponse struct {
	internal.Response
	request *GistsUnstarReq
}

/*
GistsUpdate performs requests for "gists/update"

Update a gist.

  PATCH /gists/{gist_id}

https://developer.github.com/v3/gists/#update-a-gist
*/
func GistsUpdate(ctx context.Context, req *GistsUpdateReq, opt ...options.Option) (*GistsUpdateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsUpdateReq)
	}
	resp := &GistsUpdateResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistFull{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsUpdate performs requests for "gists/update"

Update a gist.

  PATCH /gists/{gist_id}

https://developer.github.com/v3/gists/#update-a-gist
*/
func (c Client) GistsUpdate(ctx context.Context, req *GistsUpdateReq, opt ...options.Option) (*GistsUpdateResponse, error) {
	return GistsUpdate(ctx, req, append(c, opt...)...)
}

/*
GistsUpdateReq is request data for Client.GistsUpdate

https://developer.github.com/v3/gists/#update-a-gist
*/
type GistsUpdateReq struct {
	_url string

	// gist_id parameter
	GistId      string
	RequestBody GistsUpdateReqBody
}

// HTTPRequest builds an *http.Request
func (r *GistsUpdateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsUpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "gists/update",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsUpdateReq) Rel(link RelName, resp *GistsUpdateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// GistsUpdateReqBodyFiles is a value for GistsUpdateReqBody's Files field
type GistsUpdateReqBodyFiles struct {

	// The new content of the file
	Content *string `json:"content,omitempty"`

	// The new filename for the file
	Filename *string `json:"filename,omitempty"`
}

/*
GistsUpdateReqBody is a request body for gists/update

https://developer.github.com/v3/gists/#update-a-gist
*/
type GistsUpdateReqBody struct {

	// Description of the gist
	Description *string `json:"description,omitempty"`

	// Names of files to be updated
	Files map[string]GistsUpdateReqBodyFiles `json:"files,omitempty"`
}

/*
GistsUpdateResponse is a response for GistsUpdate

https://developer.github.com/v3/gists/#update-a-gist
*/
type GistsUpdateResponse struct {
	internal.Response
	request *GistsUpdateReq
	Data    components.GistFull
}

/*
GistsUpdateComment performs requests for "gists/update-comment"

Update a gist comment.

  PATCH /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
func GistsUpdateComment(ctx context.Context, req *GistsUpdateCommentReq, opt ...options.Option) (*GistsUpdateCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GistsUpdateCommentReq)
	}
	resp := &GistsUpdateCommentResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistComment{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GistsUpdateComment performs requests for "gists/update-comment"

Update a gist comment.

  PATCH /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
func (c Client) GistsUpdateComment(ctx context.Context, req *GistsUpdateCommentReq, opt ...options.Option) (*GistsUpdateCommentResponse, error) {
	return GistsUpdateComment(ctx, req, append(c, opt...)...)
}

/*
GistsUpdateCommentReq is request data for Client.GistsUpdateComment

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
type GistsUpdateCommentReq struct {
	_url string

	// gist_id parameter
	GistId string

	// comment_id parameter
	CommentId   int64
	RequestBody GistsUpdateCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *GistsUpdateCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GistsUpdateCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "gists/update-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GistsUpdateCommentReq) Rel(link RelName, resp *GistsUpdateCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GistsUpdateCommentReqBody is a request body for gists/update-comment

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
type GistsUpdateCommentReqBody struct {

	// The comment text.
	Body *string `json:"body"`
}

/*
GistsUpdateCommentResponse is a response for GistsUpdateComment

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
type GistsUpdateCommentResponse struct {
	internal.Response
	request *GistsUpdateCommentReq
	Data    components.GistComment
}
