// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
AppsAddRepoToInstallation performs requests for "apps/add-repo-to-installation"

Add a repository to an app installation.

  PUT /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
func AppsAddRepoToInstallation(ctx context.Context, req *AppsAddRepoToInstallationReq, opt ...options.Option) (*AppsAddRepoToInstallationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsAddRepoToInstallationReq)
	}
	resp := &AppsAddRepoToInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsAddRepoToInstallation performs requests for "apps/add-repo-to-installation"

Add a repository to an app installation.

  PUT /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
func (c Client) AppsAddRepoToInstallation(ctx context.Context, req *AppsAddRepoToInstallationReq, opt ...options.Option) (*AppsAddRepoToInstallationResponse, error) {
	return AppsAddRepoToInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsAddRepoToInstallationReq is request data for Client.AppsAddRepoToInstallation

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
type AppsAddRepoToInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	// repository_id parameter
	RepositoryId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsAddRepoToInstallationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsAddRepoToInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "apps/add-repo-to-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsAddRepoToInstallationReq) Rel(link RelName, resp *AppsAddRepoToInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsAddRepoToInstallationResponse is a response for AppsAddRepoToInstallation

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
type AppsAddRepoToInstallationResponse struct {
	common.Response
	request *AppsAddRepoToInstallationReq
}

/*
AppsCheckAuthorization performs requests for "apps/check-authorization"

Check an authorization.

  GET /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
func AppsCheckAuthorization(ctx context.Context, req *AppsCheckAuthorizationReq, opt ...options.Option) (*AppsCheckAuthorizationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsCheckAuthorizationReq)
	}
	resp := &AppsCheckAuthorizationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = AppsCheckAuthorizationResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCheckAuthorization performs requests for "apps/check-authorization"

Check an authorization.

  GET /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
func (c Client) AppsCheckAuthorization(ctx context.Context, req *AppsCheckAuthorizationReq, opt ...options.Option) (*AppsCheckAuthorizationResponse, error) {
	return AppsCheckAuthorization(ctx, req, append(c, opt...)...)
}

/*
AppsCheckAuthorizationReq is request data for Client.AppsCheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type AppsCheckAuthorizationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request
func (r *AppsCheckAuthorizationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsCheckAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/check-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCheckAuthorizationReq) Rel(link RelName, resp *AppsCheckAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCheckAuthorizationResponseBody is a response body for AppsCheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type AppsCheckAuthorizationResponseBody struct {
	App struct {
		ClientId string `json:"client_id"`
		Name     string `json:"name"`
		Url      string `json:"url"`
	} `json:"app,omitempty"`
	CreatedAt    string `json:"created_at,omitempty"`
	Fingerprint  string `json:"fingerprint,omitempty"`
	HashedToken  string `json:"hashed_token,omitempty"`
	Id           int64  `json:"id,omitempty"`
	Installation *struct {

		// Simple User
		Account         *components.SimpleUser `json:"account,omitempty"`
		Permissions     interface{}            `json:"permissions,omitempty"`
		RepositoriesUrl string                 `json:"repositories_url,omitempty"`

		// Describe whether all repositories have been selected or there's a selection involved
		RepositorySelection string `json:"repository_selection,omitempty"`
		SingleFileName      string `json:"single_file_name,omitempty"`
	} `json:"installation,omitempty"`
	Note    string `json:"note,omitempty"`
	NoteUrl string `json:"note_url,omitempty"`

	// A list of scopes that this authorization is in.
	Scopes         []string `json:"scopes,omitempty"`
	Token          string   `json:"token,omitempty"`
	TokenLastEight string   `json:"token_last_eight,omitempty"`
	UpdatedAt      string   `json:"updated_at,omitempty"`
	Url            string   `json:"url,omitempty"`
	User           *struct {
		AvatarUrl         string `json:"avatar_url,omitempty"`
		EventsUrl         string `json:"events_url,omitempty"`
		FollowersUrl      string `json:"followers_url,omitempty"`
		FollowingUrl      string `json:"following_url,omitempty"`
		GistsUrl          string `json:"gists_url,omitempty"`
		GravatarId        string `json:"gravatar_id,omitempty"`
		HtmlUrl           string `json:"html_url,omitempty"`
		Id                int64  `json:"id,omitempty"`
		Login             string `json:"login,omitempty"`
		NodeId            string `json:"node_id,omitempty"`
		OrganizationsUrl  string `json:"organizations_url,omitempty"`
		ReceivedEventsUrl string `json:"received_events_url,omitempty"`
		ReposUrl          string `json:"repos_url,omitempty"`
		SiteAdmin         bool   `json:"site_admin,omitempty"`
		StarredAt         string `json:"starred_at,omitempty"`
		StarredUrl        string `json:"starred_url,omitempty"`
		SubscriptionsUrl  string `json:"subscriptions_url,omitempty"`
		Type              string `json:"type,omitempty"`
		Url               string `json:"url,omitempty"`
	} `json:"user,omitempty"`
}

/*
AppsCheckAuthorizationResponse is a response for AppsCheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type AppsCheckAuthorizationResponse struct {
	common.Response
	request *AppsCheckAuthorizationReq
	Data    AppsCheckAuthorizationResponseBody
}

/*
AppsCheckToken performs requests for "apps/check-token"

Check a token.

  POST /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
func AppsCheckToken(ctx context.Context, req *AppsCheckTokenReq, opt ...options.Option) (*AppsCheckTokenResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsCheckTokenReq)
	}
	resp := &AppsCheckTokenResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCheckToken performs requests for "apps/check-token"

Check a token.

  POST /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
func (c Client) AppsCheckToken(ctx context.Context, req *AppsCheckTokenReq, opt ...options.Option) (*AppsCheckTokenResponse, error) {
	return AppsCheckToken(ctx, req, append(c, opt...)...)
}

/*
AppsCheckTokenReq is request data for Client.AppsCheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenReq struct {
	_url        string
	ClientId    string
	RequestBody AppsCheckTokenReqBody
}

// HTTPRequest builds an *http.Request
func (r *AppsCheckTokenReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsCheckTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "apps/check-token",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/token", r.ClientId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCheckTokenReq) Rel(link RelName, resp *AppsCheckTokenResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCheckTokenReqBody is a request body for apps/check-token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenReqBody struct {

	// The access_token of the OAuth application.
	AccessToken *string `json:"access_token"`
}

/*
AppsCheckTokenResponse is a response for AppsCheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenResponse struct {
	common.Response
	request *AppsCheckTokenReq
	Data    components.Authorization
}

/*
AppsCreateContentAttachment performs requests for "apps/create-content-attachment"

Create a content attachment.

  POST /content_references/{content_reference_id}/attachments

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
func AppsCreateContentAttachment(ctx context.Context, req *AppsCreateContentAttachmentReq, opt ...options.Option) (*AppsCreateContentAttachmentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsCreateContentAttachmentReq)
	}
	resp := &AppsCreateContentAttachmentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ContentReferenceAttachment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCreateContentAttachment performs requests for "apps/create-content-attachment"

Create a content attachment.

  POST /content_references/{content_reference_id}/attachments

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
func (c Client) AppsCreateContentAttachment(ctx context.Context, req *AppsCreateContentAttachmentReq, opt ...options.Option) (*AppsCreateContentAttachmentResponse, error) {
	return AppsCreateContentAttachment(ctx, req, append(c, opt...)...)
}

/*
AppsCreateContentAttachmentReq is request data for Client.AppsCreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentReq struct {
	_url string

	// content_reference_id parameter
	ContentReferenceId int64
	RequestBody        AppsCreateContentAttachmentReqBody

	/*
	To access the Content Attachments API during the preview period, you must set
	this to true.
	*/
	CorsairPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsCreateContentAttachmentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsCreateContentAttachmentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"corsair"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "apps/create-content-attachment",
		Previews:         map[string]bool{"corsair": r.CorsairPreview},
		RequiredPreviews: []string{"corsair"},
		URLPath:          fmt.Sprintf("/content_references/%v/attachments", r.ContentReferenceId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCreateContentAttachmentReq) Rel(link RelName, resp *AppsCreateContentAttachmentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCreateContentAttachmentReqBody is a request body for apps/create-content-attachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentReqBody struct {

	// The body of the attachment
	Body *string `json:"body"`

	// The title of the attachment
	Title *string `json:"title"`
}

/*
AppsCreateContentAttachmentResponse is a response for AppsCreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentResponse struct {
	common.Response
	request *AppsCreateContentAttachmentReq
	Data    components.ContentReferenceAttachment
}

/*
AppsCreateFromManifest performs requests for "apps/create-from-manifest"

Create a GitHub App from a manifest.

  POST /app-manifests/{code}/conversions

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
func AppsCreateFromManifest(ctx context.Context, req *AppsCreateFromManifestReq, opt ...options.Option) (*AppsCreateFromManifestResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsCreateFromManifestReq)
	}
	resp := &AppsCreateFromManifestResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = AppsCreateFromManifestResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCreateFromManifest performs requests for "apps/create-from-manifest"

Create a GitHub App from a manifest.

  POST /app-manifests/{code}/conversions

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
func (c Client) AppsCreateFromManifest(ctx context.Context, req *AppsCreateFromManifestReq, opt ...options.Option) (*AppsCreateFromManifestResponse, error) {
	return AppsCreateFromManifest(ctx, req, append(c, opt...)...)
}

/*
AppsCreateFromManifestReq is request data for Client.AppsCreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type AppsCreateFromManifestReq struct {
	_url string

	// code parameter
	Code string
}

// HTTPRequest builds an *http.Request
func (r *AppsCreateFromManifestReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsCreateFromManifestReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{201},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "POST",
		OperationID:      "apps/create-from-manifest",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/app-manifests/%v/conversions", r.Code),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCreateFromManifestReq) Rel(link RelName, resp *AppsCreateFromManifestResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCreateFromManifestResponseBody is a response body for AppsCreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type AppsCreateFromManifestResponseBody struct {
	ClientId     string `json:"client_id,omitempty"`
	ClientSecret string `json:"client_secret,omitempty"`
	CreatedAt    string `json:"created_at,omitempty"`
	Description  string `json:"description,omitempty"`

	// The list of events for the GitHub app
	Events      []string `json:"events,omitempty"`
	ExternalUrl string   `json:"external_url,omitempty"`
	HtmlUrl     string   `json:"html_url,omitempty"`

	// Unique identifier of the GitHub app
	Id int64 `json:"id,omitempty"`

	// The number of installations associated with the GitHub app
	InstallationsCount int64 `json:"installations_count,omitempty"`

	// The name of the GitHub app
	Name   string `json:"name,omitempty"`
	NodeId string `json:"node_id,omitempty"`
	Owner  *struct {
		AvatarUrl         string `json:"avatar_url,omitempty"`
		EventsUrl         string `json:"events_url,omitempty"`
		FollowersUrl      string `json:"followers_url,omitempty"`
		FollowingUrl      string `json:"following_url,omitempty"`
		GistsUrl          string `json:"gists_url,omitempty"`
		GravatarId        string `json:"gravatar_id,omitempty"`
		HtmlUrl           string `json:"html_url,omitempty"`
		Id                int64  `json:"id,omitempty"`
		Login             string `json:"login,omitempty"`
		NodeId            string `json:"node_id,omitempty"`
		OrganizationsUrl  string `json:"organizations_url,omitempty"`
		ReceivedEventsUrl string `json:"received_events_url,omitempty"`
		ReposUrl          string `json:"repos_url,omitempty"`
		SiteAdmin         bool   `json:"site_admin,omitempty"`
		StarredAt         string `json:"starred_at,omitempty"`
		StarredUrl        string `json:"starred_url,omitempty"`
		SubscriptionsUrl  string `json:"subscriptions_url,omitempty"`
		Type              string `json:"type,omitempty"`
		Url               string `json:"url,omitempty"`
	} `json:"owner,omitempty"`
	Pem string `json:"pem,omitempty"`

	// The set of permissions for the GitHub app
	Permissions map[string]string `json:"permissions,omitempty"`

	// The slug name of the GitHub app
	Slug          string `json:"slug,omitempty"`
	UpdatedAt     string `json:"updated_at,omitempty"`
	WebhookSecret string `json:"webhook_secret,omitempty"`
}

/*
AppsCreateFromManifestResponse is a response for AppsCreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type AppsCreateFromManifestResponse struct {
	common.Response
	request *AppsCreateFromManifestReq
	Data    AppsCreateFromManifestResponseBody
}

/*
AppsCreateInstallationAccessToken performs requests for "apps/create-installation-access-token"

Create an installation access token for an app.

  POST /app/installations/{installation_id}/access_tokens

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
func AppsCreateInstallationAccessToken(ctx context.Context, req *AppsCreateInstallationAccessTokenReq, opt ...options.Option) (*AppsCreateInstallationAccessTokenResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsCreateInstallationAccessTokenReq)
	}
	resp := &AppsCreateInstallationAccessTokenResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.InstallationToken{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCreateInstallationAccessToken performs requests for "apps/create-installation-access-token"

Create an installation access token for an app.

  POST /app/installations/{installation_id}/access_tokens

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
func (c Client) AppsCreateInstallationAccessToken(ctx context.Context, req *AppsCreateInstallationAccessTokenReq, opt ...options.Option) (*AppsCreateInstallationAccessTokenResponse, error) {
	return AppsCreateInstallationAccessToken(ctx, req, append(c, opt...)...)
}

/*
AppsCreateInstallationAccessTokenReq is request data for Client.AppsCreateInstallationAccessToken

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
type AppsCreateInstallationAccessTokenReq struct {
	_url string

	// installation_id parameter
	InstallationId int64
	RequestBody    AppsCreateInstallationAccessTokenReqBody

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsCreateInstallationAccessTokenReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsCreateInstallationAccessTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "apps/create-installation-access-token",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app/installations/%v/access_tokens", r.InstallationId),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCreateInstallationAccessTokenReq) Rel(link RelName, resp *AppsCreateInstallationAccessTokenResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// AppsCreateInstallationAccessTokenReqBodyPermissions is a value for AppsCreateInstallationAccessTokenReqBody's Permissions field
type AppsCreateInstallationAccessTokenReqBodyPermissions map[string]string

/*
AppsCreateInstallationAccessTokenReqBody is a request body for apps/create-installation-access-token

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
type AppsCreateInstallationAccessTokenReqBody struct {
	Permissions map[string]string `json:"permissions,omitempty"`

	// List of repository names that the token should have access to
	Repositories []string `json:"repositories,omitempty"`

	// List of repository IDs that the token should have access to
	RepositoryIds []int64 `json:"repository_ids,omitempty"`
}

/*
AppsCreateInstallationAccessTokenResponse is a response for AppsCreateInstallationAccessToken

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
type AppsCreateInstallationAccessTokenResponse struct {
	common.Response
	request *AppsCreateInstallationAccessTokenReq
	Data    components.InstallationToken
}

/*
AppsDeleteAuthorization performs requests for "apps/delete-authorization"

Delete an app authorization.

  DELETE /applications/{client_id}/grant

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
func AppsDeleteAuthorization(ctx context.Context, req *AppsDeleteAuthorizationReq, opt ...options.Option) (*AppsDeleteAuthorizationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsDeleteAuthorizationReq)
	}
	resp := &AppsDeleteAuthorizationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsDeleteAuthorization performs requests for "apps/delete-authorization"

Delete an app authorization.

  DELETE /applications/{client_id}/grant

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
func (c Client) AppsDeleteAuthorization(ctx context.Context, req *AppsDeleteAuthorizationReq, opt ...options.Option) (*AppsDeleteAuthorizationResponse, error) {
	return AppsDeleteAuthorization(ctx, req, append(c, opt...)...)
}

/*
AppsDeleteAuthorizationReq is request data for Client.AppsDeleteAuthorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type AppsDeleteAuthorizationReq struct {
	_url        string
	ClientId    string
	RequestBody AppsDeleteAuthorizationReqBody
}

// HTTPRequest builds an *http.Request
func (r *AppsDeleteAuthorizationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsDeleteAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "DELETE",
		OperationID:      "apps/delete-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/grant", r.ClientId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsDeleteAuthorizationReq) Rel(link RelName, resp *AppsDeleteAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsDeleteAuthorizationReqBody is a request body for apps/delete-authorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type AppsDeleteAuthorizationReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsDeleteAuthorizationResponse is a response for AppsDeleteAuthorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type AppsDeleteAuthorizationResponse struct {
	common.Response
	request *AppsDeleteAuthorizationReq
}

/*
AppsDeleteInstallation performs requests for "apps/delete-installation"

Delete an installation for the authenticated app.

  DELETE /app/installations/{installation_id}

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
func AppsDeleteInstallation(ctx context.Context, req *AppsDeleteInstallationReq, opt ...options.Option) (*AppsDeleteInstallationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsDeleteInstallationReq)
	}
	resp := &AppsDeleteInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsDeleteInstallation performs requests for "apps/delete-installation"

Delete an installation for the authenticated app.

  DELETE /app/installations/{installation_id}

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
func (c Client) AppsDeleteInstallation(ctx context.Context, req *AppsDeleteInstallationReq, opt ...options.Option) (*AppsDeleteInstallationResponse, error) {
	return AppsDeleteInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsDeleteInstallationReq is request data for Client.AppsDeleteInstallation

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
type AppsDeleteInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsDeleteInstallationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsDeleteInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "apps/delete-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app/installations/%v", r.InstallationId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsDeleteInstallationReq) Rel(link RelName, resp *AppsDeleteInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsDeleteInstallationResponse is a response for AppsDeleteInstallation

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
type AppsDeleteInstallationResponse struct {
	common.Response
	request *AppsDeleteInstallationReq
	Data    bool
}

/*
AppsDeleteToken performs requests for "apps/delete-token"

Delete an app token.

  DELETE /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
func AppsDeleteToken(ctx context.Context, req *AppsDeleteTokenReq, opt ...options.Option) (*AppsDeleteTokenResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsDeleteTokenReq)
	}
	resp := &AppsDeleteTokenResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsDeleteToken performs requests for "apps/delete-token"

Delete an app token.

  DELETE /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
func (c Client) AppsDeleteToken(ctx context.Context, req *AppsDeleteTokenReq, opt ...options.Option) (*AppsDeleteTokenResponse, error) {
	return AppsDeleteToken(ctx, req, append(c, opt...)...)
}

/*
AppsDeleteTokenReq is request data for Client.AppsDeleteToken

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type AppsDeleteTokenReq struct {
	_url        string
	ClientId    string
	RequestBody AppsDeleteTokenReqBody
}

// HTTPRequest builds an *http.Request
func (r *AppsDeleteTokenReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsDeleteTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "DELETE",
		OperationID:      "apps/delete-token",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/token", r.ClientId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsDeleteTokenReq) Rel(link RelName, resp *AppsDeleteTokenResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsDeleteTokenReqBody is a request body for apps/delete-token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type AppsDeleteTokenReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsDeleteTokenResponse is a response for AppsDeleteToken

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type AppsDeleteTokenResponse struct {
	common.Response
	request *AppsDeleteTokenReq
}

/*
AppsGetAuthenticated performs requests for "apps/get-authenticated"

Get the authenticated app.

  GET /app

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
func AppsGetAuthenticated(ctx context.Context, req *AppsGetAuthenticatedReq, opt ...options.Option) (*AppsGetAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsGetAuthenticatedReq)
	}
	resp := &AppsGetAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Integration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetAuthenticated performs requests for "apps/get-authenticated"

Get the authenticated app.

  GET /app

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
func (c Client) AppsGetAuthenticated(ctx context.Context, req *AppsGetAuthenticatedReq, opt ...options.Option) (*AppsGetAuthenticatedResponse, error) {
	return AppsGetAuthenticated(ctx, req, append(c, opt...)...)
}

/*
AppsGetAuthenticatedReq is request data for Client.AppsGetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
type AppsGetAuthenticatedReq struct {
	_url string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsGetAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsGetAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-authenticated",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app"),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetAuthenticatedReq) Rel(link RelName, resp *AppsGetAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetAuthenticatedResponse is a response for AppsGetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
type AppsGetAuthenticatedResponse struct {
	common.Response
	request *AppsGetAuthenticatedReq
	Data    components.Integration
}

/*
AppsGetBySlug performs requests for "apps/get-by-slug"

Get an app.

  GET /apps/{app_slug}

https://developer.github.com/v3/apps/#get-an-app
*/
func AppsGetBySlug(ctx context.Context, req *AppsGetBySlugReq, opt ...options.Option) (*AppsGetBySlugResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsGetBySlugReq)
	}
	resp := &AppsGetBySlugResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Integration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetBySlug performs requests for "apps/get-by-slug"

Get an app.

  GET /apps/{app_slug}

https://developer.github.com/v3/apps/#get-an-app
*/
func (c Client) AppsGetBySlug(ctx context.Context, req *AppsGetBySlugReq, opt ...options.Option) (*AppsGetBySlugResponse, error) {
	return AppsGetBySlug(ctx, req, append(c, opt...)...)
}

/*
AppsGetBySlugReq is request data for Client.AppsGetBySlug

https://developer.github.com/v3/apps/#get-an-app
*/
type AppsGetBySlugReq struct {
	_url string

	// app_slug parameter
	AppSlug string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsGetBySlugReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsGetBySlugReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-by-slug",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/apps/%v", r.AppSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetBySlugReq) Rel(link RelName, resp *AppsGetBySlugResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetBySlugResponse is a response for AppsGetBySlug

https://developer.github.com/v3/apps/#get-an-app
*/
type AppsGetBySlugResponse struct {
	common.Response
	request *AppsGetBySlugReq
	Data    components.Integration
}

/*
AppsGetInstallation performs requests for "apps/get-installation"

Get an installation for the authenticated app.

  GET /app/installations/{installation_id}

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
func AppsGetInstallation(ctx context.Context, req *AppsGetInstallationReq, opt ...options.Option) (*AppsGetInstallationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsGetInstallationReq)
	}
	resp := &AppsGetInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Installation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetInstallation performs requests for "apps/get-installation"

Get an installation for the authenticated app.

  GET /app/installations/{installation_id}

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
func (c Client) AppsGetInstallation(ctx context.Context, req *AppsGetInstallationReq, opt ...options.Option) (*AppsGetInstallationResponse, error) {
	return AppsGetInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsGetInstallationReq is request data for Client.AppsGetInstallation

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
type AppsGetInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsGetInstallationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsGetInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app/installations/%v", r.InstallationId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetInstallationReq) Rel(link RelName, resp *AppsGetInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetInstallationResponse is a response for AppsGetInstallation

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
type AppsGetInstallationResponse struct {
	common.Response
	request *AppsGetInstallationReq
	Data    components.Installation
}

/*
AppsGetOrgInstallation performs requests for "apps/get-org-installation"

Get an organization installation for the authenticated app.

  GET /orgs/{org}/installation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
func AppsGetOrgInstallation(ctx context.Context, req *AppsGetOrgInstallationReq, opt ...options.Option) (*AppsGetOrgInstallationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsGetOrgInstallationReq)
	}
	resp := &AppsGetOrgInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Installation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetOrgInstallation performs requests for "apps/get-org-installation"

Get an organization installation for the authenticated app.

  GET /orgs/{org}/installation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
func (c Client) AppsGetOrgInstallation(ctx context.Context, req *AppsGetOrgInstallationReq, opt ...options.Option) (*AppsGetOrgInstallationResponse, error) {
	return AppsGetOrgInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsGetOrgInstallationReq is request data for Client.AppsGetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
type AppsGetOrgInstallationReq struct {
	_url string
	Org  string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsGetOrgInstallationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsGetOrgInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-org-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/orgs/%v/installation", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetOrgInstallationReq) Rel(link RelName, resp *AppsGetOrgInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetOrgInstallationResponse is a response for AppsGetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
type AppsGetOrgInstallationResponse struct {
	common.Response
	request *AppsGetOrgInstallationReq
	Data    components.Installation
}

/*
AppsGetRepoInstallation performs requests for "apps/get-repo-installation"

Get a repository installation for the authenticated app.

  GET /repos/{owner}/{repo}/installation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
func AppsGetRepoInstallation(ctx context.Context, req *AppsGetRepoInstallationReq, opt ...options.Option) (*AppsGetRepoInstallationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsGetRepoInstallationReq)
	}
	resp := &AppsGetRepoInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Installation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetRepoInstallation performs requests for "apps/get-repo-installation"

Get a repository installation for the authenticated app.

  GET /repos/{owner}/{repo}/installation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
func (c Client) AppsGetRepoInstallation(ctx context.Context, req *AppsGetRepoInstallationReq, opt ...options.Option) (*AppsGetRepoInstallationResponse, error) {
	return AppsGetRepoInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsGetRepoInstallationReq is request data for Client.AppsGetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
type AppsGetRepoInstallationReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsGetRepoInstallationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsGetRepoInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-repo-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/installation", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 301},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetRepoInstallationReq) Rel(link RelName, resp *AppsGetRepoInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetRepoInstallationResponse is a response for AppsGetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
type AppsGetRepoInstallationResponse struct {
	common.Response
	request *AppsGetRepoInstallationReq
	Data    components.Installation
}

/*
AppsGetSubscriptionPlanForAccount performs requests for "apps/get-subscription-plan-for-account"

Get a subscription plan for an account.

  GET /marketplace_listing/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
func AppsGetSubscriptionPlanForAccount(ctx context.Context, req *AppsGetSubscriptionPlanForAccountReq, opt ...options.Option) (*AppsGetSubscriptionPlanForAccountResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsGetSubscriptionPlanForAccountReq)
	}
	resp := &AppsGetSubscriptionPlanForAccountResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.MarketplacePurchase{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetSubscriptionPlanForAccount performs requests for "apps/get-subscription-plan-for-account"

Get a subscription plan for an account.

  GET /marketplace_listing/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
func (c Client) AppsGetSubscriptionPlanForAccount(ctx context.Context, req *AppsGetSubscriptionPlanForAccountReq, opt ...options.Option) (*AppsGetSubscriptionPlanForAccountResponse, error) {
	return AppsGetSubscriptionPlanForAccount(ctx, req, append(c, opt...)...)
}

/*
AppsGetSubscriptionPlanForAccountReq is request data for Client.AppsGetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type AppsGetSubscriptionPlanForAccountReq struct {
	_url string

	// account_id parameter
	AccountId int64
}

// HTTPRequest builds an *http.Request
func (r *AppsGetSubscriptionPlanForAccountReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsGetSubscriptionPlanForAccountReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-subscription-plan-for-account",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/marketplace_listing/accounts/%v", r.AccountId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetSubscriptionPlanForAccountReq) Rel(link RelName, resp *AppsGetSubscriptionPlanForAccountResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetSubscriptionPlanForAccountResponse is a response for AppsGetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type AppsGetSubscriptionPlanForAccountResponse struct {
	common.Response
	request *AppsGetSubscriptionPlanForAccountReq
	Data    components.MarketplacePurchase
}

/*
AppsGetSubscriptionPlanForAccountStubbed performs requests for "apps/get-subscription-plan-for-account-stubbed"

Get a subscription plan for an account (stubbed).

  GET /marketplace_listing/stubbed/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
func AppsGetSubscriptionPlanForAccountStubbed(ctx context.Context, req *AppsGetSubscriptionPlanForAccountStubbedReq, opt ...options.Option) (*AppsGetSubscriptionPlanForAccountStubbedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsGetSubscriptionPlanForAccountStubbedReq)
	}
	resp := &AppsGetSubscriptionPlanForAccountStubbedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.MarketplacePurchase{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetSubscriptionPlanForAccountStubbed performs requests for "apps/get-subscription-plan-for-account-stubbed"

Get a subscription plan for an account (stubbed).

  GET /marketplace_listing/stubbed/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
func (c Client) AppsGetSubscriptionPlanForAccountStubbed(ctx context.Context, req *AppsGetSubscriptionPlanForAccountStubbedReq, opt ...options.Option) (*AppsGetSubscriptionPlanForAccountStubbedResponse, error) {
	return AppsGetSubscriptionPlanForAccountStubbed(ctx, req, append(c, opt...)...)
}

/*
AppsGetSubscriptionPlanForAccountStubbedReq is request data for Client.AppsGetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type AppsGetSubscriptionPlanForAccountStubbedReq struct {
	_url string

	// account_id parameter
	AccountId int64
}

// HTTPRequest builds an *http.Request
func (r *AppsGetSubscriptionPlanForAccountStubbedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-subscription-plan-for-account-stubbed",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/marketplace_listing/stubbed/accounts/%v", r.AccountId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetSubscriptionPlanForAccountStubbedReq) Rel(link RelName, resp *AppsGetSubscriptionPlanForAccountStubbedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetSubscriptionPlanForAccountStubbedResponse is a response for AppsGetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type AppsGetSubscriptionPlanForAccountStubbedResponse struct {
	common.Response
	request *AppsGetSubscriptionPlanForAccountStubbedReq
	Data    components.MarketplacePurchase
}

/*
AppsGetUserInstallation performs requests for "apps/get-user-installation"

Get a user installation for the authenticated app.

  GET /users/{username}/installation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
func AppsGetUserInstallation(ctx context.Context, req *AppsGetUserInstallationReq, opt ...options.Option) (*AppsGetUserInstallationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsGetUserInstallationReq)
	}
	resp := &AppsGetUserInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Installation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetUserInstallation performs requests for "apps/get-user-installation"

Get a user installation for the authenticated app.

  GET /users/{username}/installation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
func (c Client) AppsGetUserInstallation(ctx context.Context, req *AppsGetUserInstallationReq, opt ...options.Option) (*AppsGetUserInstallationResponse, error) {
	return AppsGetUserInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsGetUserInstallationReq is request data for Client.AppsGetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
type AppsGetUserInstallationReq struct {
	_url     string
	Username string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsGetUserInstallationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsGetUserInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-user-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/users/%v/installation", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetUserInstallationReq) Rel(link RelName, resp *AppsGetUserInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetUserInstallationResponse is a response for AppsGetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
type AppsGetUserInstallationResponse struct {
	common.Response
	request *AppsGetUserInstallationReq
	Data    components.Installation
}

/*
AppsListAccountsForPlan performs requests for "apps/list-accounts-for-plan"

List accounts for a plan.

  GET /marketplace_listing/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
func AppsListAccountsForPlan(ctx context.Context, req *AppsListAccountsForPlanReq, opt ...options.Option) (*AppsListAccountsForPlanResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsListAccountsForPlanReq)
	}
	resp := &AppsListAccountsForPlanResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MarketplacePurchase{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListAccountsForPlan performs requests for "apps/list-accounts-for-plan"

List accounts for a plan.

  GET /marketplace_listing/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
func (c Client) AppsListAccountsForPlan(ctx context.Context, req *AppsListAccountsForPlanReq, opt ...options.Option) (*AppsListAccountsForPlanResponse, error) {
	return AppsListAccountsForPlan(ctx, req, append(c, opt...)...)
}

/*
AppsListAccountsForPlanReq is request data for Client.AppsListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type AppsListAccountsForPlanReq struct {
	_url string

	// plan_id parameter
	PlanId int64

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *AppsListAccountsForPlanReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsListAccountsForPlanReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-accounts-for-plan",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/marketplace_listing/plans/%v/accounts", r.PlanId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListAccountsForPlanReq) Rel(link RelName, resp *AppsListAccountsForPlanResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListAccountsForPlanResponse is a response for AppsListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type AppsListAccountsForPlanResponse struct {
	common.Response
	request *AppsListAccountsForPlanReq
	Data    []components.MarketplacePurchase
}

/*
AppsListAccountsForPlanStubbed performs requests for "apps/list-accounts-for-plan-stubbed"

List accounts for a plan (stubbed).

  GET /marketplace_listing/stubbed/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
func AppsListAccountsForPlanStubbed(ctx context.Context, req *AppsListAccountsForPlanStubbedReq, opt ...options.Option) (*AppsListAccountsForPlanStubbedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsListAccountsForPlanStubbedReq)
	}
	resp := &AppsListAccountsForPlanStubbedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MarketplacePurchase{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListAccountsForPlanStubbed performs requests for "apps/list-accounts-for-plan-stubbed"

List accounts for a plan (stubbed).

  GET /marketplace_listing/stubbed/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
func (c Client) AppsListAccountsForPlanStubbed(ctx context.Context, req *AppsListAccountsForPlanStubbedReq, opt ...options.Option) (*AppsListAccountsForPlanStubbedResponse, error) {
	return AppsListAccountsForPlanStubbed(ctx, req, append(c, opt...)...)
}

/*
AppsListAccountsForPlanStubbedReq is request data for Client.AppsListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type AppsListAccountsForPlanStubbedReq struct {
	_url string

	// plan_id parameter
	PlanId int64

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *AppsListAccountsForPlanStubbedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsListAccountsForPlanStubbedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-accounts-for-plan-stubbed",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/marketplace_listing/stubbed/plans/%v/accounts", r.PlanId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListAccountsForPlanStubbedReq) Rel(link RelName, resp *AppsListAccountsForPlanStubbedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListAccountsForPlanStubbedResponse is a response for AppsListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type AppsListAccountsForPlanStubbedResponse struct {
	common.Response
	request *AppsListAccountsForPlanStubbedReq
	Data    []components.MarketplacePurchase
}

/*
AppsListInstallationReposForAuthenticatedUser performs requests for "apps/list-installation-repos-for-authenticated-user"

List repositories accessible to the user access token.

  GET /user/installations/{installation_id}/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
func AppsListInstallationReposForAuthenticatedUser(ctx context.Context, req *AppsListInstallationReposForAuthenticatedUserReq, opt ...options.Option) (*AppsListInstallationReposForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsListInstallationReposForAuthenticatedUserReq)
	}
	resp := &AppsListInstallationReposForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = AppsListInstallationReposForAuthenticatedUserResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListInstallationReposForAuthenticatedUser performs requests for "apps/list-installation-repos-for-authenticated-user"

List repositories accessible to the user access token.

  GET /user/installations/{installation_id}/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
func (c Client) AppsListInstallationReposForAuthenticatedUser(ctx context.Context, req *AppsListInstallationReposForAuthenticatedUserReq, opt ...options.Option) (*AppsListInstallationReposForAuthenticatedUserResponse, error) {
	return AppsListInstallationReposForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
AppsListInstallationReposForAuthenticatedUserReq is request data for Client.AppsListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
type AppsListInstallationReposForAuthenticatedUserReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsListInstallationReposForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man", "mercy"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "apps/list-installation-repos-for-authenticated-user",
		Previews: map[string]bool{
			"machine-man": r.MachineManPreview,
			"mercy":       r.MercyPreview,
		},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/user/installations/%v/repositories", r.InstallationId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListInstallationReposForAuthenticatedUserReq) Rel(link RelName, resp *AppsListInstallationReposForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListInstallationReposForAuthenticatedUserResponseBody is a response body for AppsListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
type AppsListInstallationReposForAuthenticatedUserResponseBody struct {
	Repositories        []components.Repository `json:"repositories,omitempty"`
	RepositorySelection string                  `json:"repository_selection,omitempty"`
	TotalCount          int64                   `json:"total_count,omitempty"`
}

/*
AppsListInstallationReposForAuthenticatedUserResponse is a response for AppsListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
type AppsListInstallationReposForAuthenticatedUserResponse struct {
	common.Response
	request *AppsListInstallationReposForAuthenticatedUserReq
	Data    AppsListInstallationReposForAuthenticatedUserResponseBody
}

/*
AppsListInstallations performs requests for "apps/list-installations"

List installations for the authenticated app.

  GET /app/installations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
func AppsListInstallations(ctx context.Context, req *AppsListInstallationsReq, opt ...options.Option) (*AppsListInstallationsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsListInstallationsReq)
	}
	resp := &AppsListInstallationsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Installation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListInstallations performs requests for "apps/list-installations"

List installations for the authenticated app.

  GET /app/installations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
func (c Client) AppsListInstallations(ctx context.Context, req *AppsListInstallationsReq, opt ...options.Option) (*AppsListInstallationsResponse, error) {
	return AppsListInstallations(ctx, req, append(c, opt...)...)
}

/*
AppsListInstallationsReq is request data for Client.AppsListInstallations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
type AppsListInstallationsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since    *string
	Outdated *string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsListInstallationsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsListInstallationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Outdated != nil {
		query.Set("outdated", *r.Outdated)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-installations",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app/installations"),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListInstallationsReq) Rel(link RelName, resp *AppsListInstallationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListInstallationsResponse is a response for AppsListInstallations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
type AppsListInstallationsResponse struct {
	common.Response
	request *AppsListInstallationsReq
	Data    []components.Installation
}

/*
AppsListInstallationsForAuthenticatedUser performs requests for "apps/list-installations-for-authenticated-user"

List app installations accessible to the user access token.

  GET /user/installations

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
func AppsListInstallationsForAuthenticatedUser(ctx context.Context, req *AppsListInstallationsForAuthenticatedUserReq, opt ...options.Option) (*AppsListInstallationsForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsListInstallationsForAuthenticatedUserReq)
	}
	resp := &AppsListInstallationsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = AppsListInstallationsForAuthenticatedUserResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListInstallationsForAuthenticatedUser performs requests for "apps/list-installations-for-authenticated-user"

List app installations accessible to the user access token.

  GET /user/installations

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
func (c Client) AppsListInstallationsForAuthenticatedUser(ctx context.Context, req *AppsListInstallationsForAuthenticatedUserReq, opt ...options.Option) (*AppsListInstallationsForAuthenticatedUserResponse, error) {
	return AppsListInstallationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
AppsListInstallationsForAuthenticatedUserReq is request data for Client.AppsListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
type AppsListInstallationsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsListInstallationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsListInstallationsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-installations-for-authenticated-user",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/user/installations"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListInstallationsForAuthenticatedUserReq) Rel(link RelName, resp *AppsListInstallationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListInstallationsForAuthenticatedUserResponseBody is a response body for AppsListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
type AppsListInstallationsForAuthenticatedUserResponseBody struct {
	Installations []components.Installation `json:"installations,omitempty"`
	TotalCount    int64                     `json:"total_count,omitempty"`
}

/*
AppsListInstallationsForAuthenticatedUserResponse is a response for AppsListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
type AppsListInstallationsForAuthenticatedUserResponse struct {
	common.Response
	request *AppsListInstallationsForAuthenticatedUserReq
	Data    AppsListInstallationsForAuthenticatedUserResponseBody
}

/*
AppsListPlans performs requests for "apps/list-plans"

List plans.

  GET /marketplace_listing/plans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
func AppsListPlans(ctx context.Context, req *AppsListPlansReq, opt ...options.Option) (*AppsListPlansResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsListPlansReq)
	}
	resp := &AppsListPlansResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MarketplaceListingPlan{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListPlans performs requests for "apps/list-plans"

List plans.

  GET /marketplace_listing/plans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
func (c Client) AppsListPlans(ctx context.Context, req *AppsListPlansReq, opt ...options.Option) (*AppsListPlansResponse, error) {
	return AppsListPlans(ctx, req, append(c, opt...)...)
}

/*
AppsListPlansReq is request data for Client.AppsListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type AppsListPlansReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *AppsListPlansReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsListPlansReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-plans",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/marketplace_listing/plans"),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListPlansReq) Rel(link RelName, resp *AppsListPlansResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListPlansResponse is a response for AppsListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type AppsListPlansResponse struct {
	common.Response
	request *AppsListPlansReq
	Data    []components.MarketplaceListingPlan
}

/*
AppsListPlansStubbed performs requests for "apps/list-plans-stubbed"

List plans (stubbed).

  GET /marketplace_listing/stubbed/plans

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
func AppsListPlansStubbed(ctx context.Context, req *AppsListPlansStubbedReq, opt ...options.Option) (*AppsListPlansStubbedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsListPlansStubbedReq)
	}
	resp := &AppsListPlansStubbedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MarketplaceListingPlan{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListPlansStubbed performs requests for "apps/list-plans-stubbed"

List plans (stubbed).

  GET /marketplace_listing/stubbed/plans

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
func (c Client) AppsListPlansStubbed(ctx context.Context, req *AppsListPlansStubbedReq, opt ...options.Option) (*AppsListPlansStubbedResponse, error) {
	return AppsListPlansStubbed(ctx, req, append(c, opt...)...)
}

/*
AppsListPlansStubbedReq is request data for Client.AppsListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type AppsListPlansStubbedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *AppsListPlansStubbedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsListPlansStubbedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-plans-stubbed",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/marketplace_listing/stubbed/plans"),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListPlansStubbedReq) Rel(link RelName, resp *AppsListPlansStubbedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListPlansStubbedResponse is a response for AppsListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type AppsListPlansStubbedResponse struct {
	common.Response
	request *AppsListPlansStubbedReq
	Data    []components.MarketplaceListingPlan
}

/*
AppsListReposAccessibleToInstallation performs requests for "apps/list-repos-accessible-to-installation"

List repositories accessible to the app installation.

  GET /installation/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
func AppsListReposAccessibleToInstallation(ctx context.Context, req *AppsListReposAccessibleToInstallationReq, opt ...options.Option) (*AppsListReposAccessibleToInstallationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsListReposAccessibleToInstallationReq)
	}
	resp := &AppsListReposAccessibleToInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = AppsListReposAccessibleToInstallationResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListReposAccessibleToInstallation performs requests for "apps/list-repos-accessible-to-installation"

List repositories accessible to the app installation.

  GET /installation/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
func (c Client) AppsListReposAccessibleToInstallation(ctx context.Context, req *AppsListReposAccessibleToInstallationReq, opt ...options.Option) (*AppsListReposAccessibleToInstallationResponse, error) {
	return AppsListReposAccessibleToInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsListReposAccessibleToInstallationReq is request data for Client.AppsListReposAccessibleToInstallation

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
type AppsListReposAccessibleToInstallationReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsListReposAccessibleToInstallationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsListReposAccessibleToInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man", "mercy"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "apps/list-repos-accessible-to-installation",
		Previews: map[string]bool{
			"machine-man": r.MachineManPreview,
			"mercy":       r.MercyPreview,
		},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/installation/repositories"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListReposAccessibleToInstallationReq) Rel(link RelName, resp *AppsListReposAccessibleToInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListReposAccessibleToInstallationResponseBody is a response body for AppsListReposAccessibleToInstallation

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
type AppsListReposAccessibleToInstallationResponseBody struct {
	Repositories        []components.Repository `json:"repositories,omitempty"`
	RepositorySelection string                  `json:"repository_selection,omitempty"`
	TotalCount          int64                   `json:"total_count,omitempty"`
}

/*
AppsListReposAccessibleToInstallationResponse is a response for AppsListReposAccessibleToInstallation

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
type AppsListReposAccessibleToInstallationResponse struct {
	common.Response
	request *AppsListReposAccessibleToInstallationReq
	Data    AppsListReposAccessibleToInstallationResponseBody
}

/*
AppsListSubscriptionsForAuthenticatedUser performs requests for "apps/list-subscriptions-for-authenticated-user"

List subscriptions for the authenticated user.

  GET /user/marketplace_purchases

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
func AppsListSubscriptionsForAuthenticatedUser(ctx context.Context, req *AppsListSubscriptionsForAuthenticatedUserReq, opt ...options.Option) (*AppsListSubscriptionsForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsListSubscriptionsForAuthenticatedUserReq)
	}
	resp := &AppsListSubscriptionsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.UserMarketplacePurchase{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListSubscriptionsForAuthenticatedUser performs requests for "apps/list-subscriptions-for-authenticated-user"

List subscriptions for the authenticated user.

  GET /user/marketplace_purchases

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
func (c Client) AppsListSubscriptionsForAuthenticatedUser(ctx context.Context, req *AppsListSubscriptionsForAuthenticatedUserReq, opt ...options.Option) (*AppsListSubscriptionsForAuthenticatedUserResponse, error) {
	return AppsListSubscriptionsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
AppsListSubscriptionsForAuthenticatedUserReq is request data for Client.AppsListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type AppsListSubscriptionsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *AppsListSubscriptionsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-subscriptions-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/marketplace_purchases"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListSubscriptionsForAuthenticatedUserReq) Rel(link RelName, resp *AppsListSubscriptionsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListSubscriptionsForAuthenticatedUserResponse is a response for AppsListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type AppsListSubscriptionsForAuthenticatedUserResponse struct {
	common.Response
	request *AppsListSubscriptionsForAuthenticatedUserReq
	Data    []components.UserMarketplacePurchase
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbed performs requests for "apps/list-subscriptions-for-authenticated-user-stubbed"

List subscriptions for the authenticated user (stubbed).

  GET /user/marketplace_purchases/stubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
func AppsListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, req *AppsListSubscriptionsForAuthenticatedUserStubbedReq, opt ...options.Option) (*AppsListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsListSubscriptionsForAuthenticatedUserStubbedReq)
	}
	resp := &AppsListSubscriptionsForAuthenticatedUserStubbedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.UserMarketplacePurchase{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbed performs requests for "apps/list-subscriptions-for-authenticated-user-stubbed"

List subscriptions for the authenticated user (stubbed).

  GET /user/marketplace_purchases/stubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
func (c Client) AppsListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, req *AppsListSubscriptionsForAuthenticatedUserStubbedReq, opt ...options.Option) (*AppsListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	return AppsListSubscriptionsForAuthenticatedUserStubbed(ctx, req, append(c, opt...)...)
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbedReq is request data for Client.AppsListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type AppsListSubscriptionsForAuthenticatedUserStubbedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-subscriptions-for-authenticated-user-stubbed",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/marketplace_purchases/stubbed"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) Rel(link RelName, resp *AppsListSubscriptionsForAuthenticatedUserStubbedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbedResponse is a response for AppsListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type AppsListSubscriptionsForAuthenticatedUserStubbedResponse struct {
	common.Response
	request *AppsListSubscriptionsForAuthenticatedUserStubbedReq
	Data    []components.UserMarketplacePurchase
}

/*
AppsRemoveRepoFromInstallation performs requests for "apps/remove-repo-from-installation"

Remove a repository from an app installation.

  DELETE /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
func AppsRemoveRepoFromInstallation(ctx context.Context, req *AppsRemoveRepoFromInstallationReq, opt ...options.Option) (*AppsRemoveRepoFromInstallationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsRemoveRepoFromInstallationReq)
	}
	resp := &AppsRemoveRepoFromInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsRemoveRepoFromInstallation performs requests for "apps/remove-repo-from-installation"

Remove a repository from an app installation.

  DELETE /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
func (c Client) AppsRemoveRepoFromInstallation(ctx context.Context, req *AppsRemoveRepoFromInstallationReq, opt ...options.Option) (*AppsRemoveRepoFromInstallationResponse, error) {
	return AppsRemoveRepoFromInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsRemoveRepoFromInstallationReq is request data for Client.AppsRemoveRepoFromInstallation

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
type AppsRemoveRepoFromInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	// repository_id parameter
	RepositoryId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AppsRemoveRepoFromInstallationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsRemoveRepoFromInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "apps/remove-repo-from-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsRemoveRepoFromInstallationReq) Rel(link RelName, resp *AppsRemoveRepoFromInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsRemoveRepoFromInstallationResponse is a response for AppsRemoveRepoFromInstallation

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
type AppsRemoveRepoFromInstallationResponse struct {
	common.Response
	request *AppsRemoveRepoFromInstallationReq
}

/*
AppsResetAuthorization performs requests for "apps/reset-authorization"

Reset an authorization.

  POST /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
func AppsResetAuthorization(ctx context.Context, req *AppsResetAuthorizationReq, opt ...options.Option) (*AppsResetAuthorizationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsResetAuthorizationReq)
	}
	resp := &AppsResetAuthorizationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsResetAuthorization performs requests for "apps/reset-authorization"

Reset an authorization.

  POST /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
func (c Client) AppsResetAuthorization(ctx context.Context, req *AppsResetAuthorizationReq, opt ...options.Option) (*AppsResetAuthorizationResponse, error) {
	return AppsResetAuthorization(ctx, req, append(c, opt...)...)
}

/*
AppsResetAuthorizationReq is request data for Client.AppsResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type AppsResetAuthorizationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request
func (r *AppsResetAuthorizationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsResetAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "POST",
		OperationID:      "apps/reset-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsResetAuthorizationReq) Rel(link RelName, resp *AppsResetAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsResetAuthorizationResponse is a response for AppsResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type AppsResetAuthorizationResponse struct {
	common.Response
	request *AppsResetAuthorizationReq
	Data    components.Authorization
}

/*
AppsResetToken performs requests for "apps/reset-token"

Reset a token.

  PATCH /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
func AppsResetToken(ctx context.Context, req *AppsResetTokenReq, opt ...options.Option) (*AppsResetTokenResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsResetTokenReq)
	}
	resp := &AppsResetTokenResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsResetToken performs requests for "apps/reset-token"

Reset a token.

  PATCH /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
func (c Client) AppsResetToken(ctx context.Context, req *AppsResetTokenReq, opt ...options.Option) (*AppsResetTokenResponse, error) {
	return AppsResetToken(ctx, req, append(c, opt...)...)
}

/*
AppsResetTokenReq is request data for Client.AppsResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenReq struct {
	_url        string
	ClientId    string
	RequestBody AppsResetTokenReqBody
}

// HTTPRequest builds an *http.Request
func (r *AppsResetTokenReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsResetTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "apps/reset-token",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/token", r.ClientId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsResetTokenReq) Rel(link RelName, resp *AppsResetTokenResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsResetTokenReqBody is a request body for apps/reset-token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenReqBody struct {

	// The access_token of the OAuth application.
	AccessToken *string `json:"access_token"`
}

/*
AppsResetTokenResponse is a response for AppsResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenResponse struct {
	common.Response
	request *AppsResetTokenReq
	Data    components.Authorization
}

/*
AppsRevokeAuthorizationForApplication performs requests for "apps/revoke-authorization-for-application"

Revoke an authorization for an application.

  DELETE /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
func AppsRevokeAuthorizationForApplication(ctx context.Context, req *AppsRevokeAuthorizationForApplicationReq, opt ...options.Option) (*AppsRevokeAuthorizationForApplicationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsRevokeAuthorizationForApplicationReq)
	}
	resp := &AppsRevokeAuthorizationForApplicationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsRevokeAuthorizationForApplication performs requests for "apps/revoke-authorization-for-application"

Revoke an authorization for an application.

  DELETE /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
func (c Client) AppsRevokeAuthorizationForApplication(ctx context.Context, req *AppsRevokeAuthorizationForApplicationReq, opt ...options.Option) (*AppsRevokeAuthorizationForApplicationResponse, error) {
	return AppsRevokeAuthorizationForApplication(ctx, req, append(c, opt...)...)
}

/*
AppsRevokeAuthorizationForApplicationReq is request data for Client.AppsRevokeAuthorizationForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
type AppsRevokeAuthorizationForApplicationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request
func (r *AppsRevokeAuthorizationForApplicationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsRevokeAuthorizationForApplicationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "apps/revoke-authorization-for-application",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsRevokeAuthorizationForApplicationReq) Rel(link RelName, resp *AppsRevokeAuthorizationForApplicationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsRevokeAuthorizationForApplicationResponse is a response for AppsRevokeAuthorizationForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
type AppsRevokeAuthorizationForApplicationResponse struct {
	common.Response
	request *AppsRevokeAuthorizationForApplicationReq
}

/*
AppsRevokeGrantForApplication performs requests for "apps/revoke-grant-for-application"

Revoke a grant for an application.

  DELETE /applications/{client_id}/grants/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
func AppsRevokeGrantForApplication(ctx context.Context, req *AppsRevokeGrantForApplicationReq, opt ...options.Option) (*AppsRevokeGrantForApplicationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsRevokeGrantForApplicationReq)
	}
	resp := &AppsRevokeGrantForApplicationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsRevokeGrantForApplication performs requests for "apps/revoke-grant-for-application"

Revoke a grant for an application.

  DELETE /applications/{client_id}/grants/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
func (c Client) AppsRevokeGrantForApplication(ctx context.Context, req *AppsRevokeGrantForApplicationReq, opt ...options.Option) (*AppsRevokeGrantForApplicationResponse, error) {
	return AppsRevokeGrantForApplication(ctx, req, append(c, opt...)...)
}

/*
AppsRevokeGrantForApplicationReq is request data for Client.AppsRevokeGrantForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
type AppsRevokeGrantForApplicationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request
func (r *AppsRevokeGrantForApplicationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsRevokeGrantForApplicationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "apps/revoke-grant-for-application",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/grants/%v", r.ClientId, r.AccessToken),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsRevokeGrantForApplicationReq) Rel(link RelName, resp *AppsRevokeGrantForApplicationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsRevokeGrantForApplicationResponse is a response for AppsRevokeGrantForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
type AppsRevokeGrantForApplicationResponse struct {
	common.Response
	request *AppsRevokeGrantForApplicationReq
}

/*
AppsRevokeInstallationAccessToken performs requests for "apps/revoke-installation-access-token"

Revoke an installation access token.

  DELETE /installation/token

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
func AppsRevokeInstallationAccessToken(ctx context.Context, req *AppsRevokeInstallationAccessTokenReq, opt ...options.Option) (*AppsRevokeInstallationAccessTokenResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsRevokeInstallationAccessTokenReq)
	}
	resp := &AppsRevokeInstallationAccessTokenResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsRevokeInstallationAccessToken performs requests for "apps/revoke-installation-access-token"

Revoke an installation access token.

  DELETE /installation/token

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
func (c Client) AppsRevokeInstallationAccessToken(ctx context.Context, req *AppsRevokeInstallationAccessTokenReq, opt ...options.Option) (*AppsRevokeInstallationAccessTokenResponse, error) {
	return AppsRevokeInstallationAccessToken(ctx, req, append(c, opt...)...)
}

/*
AppsRevokeInstallationAccessTokenReq is request data for Client.AppsRevokeInstallationAccessToken

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
type AppsRevokeInstallationAccessTokenReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *AppsRevokeInstallationAccessTokenReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsRevokeInstallationAccessTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "apps/revoke-installation-access-token",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/installation/token"),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsRevokeInstallationAccessTokenReq) Rel(link RelName, resp *AppsRevokeInstallationAccessTokenResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsRevokeInstallationAccessTokenResponse is a response for AppsRevokeInstallationAccessToken

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
type AppsRevokeInstallationAccessTokenResponse struct {
	common.Response
	request *AppsRevokeInstallationAccessTokenReq
}

/*
AppsSuspendInstallation performs requests for "apps/suspend-installation"

Suspend an app installation.

  PUT /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
func AppsSuspendInstallation(ctx context.Context, req *AppsSuspendInstallationReq, opt ...options.Option) (*AppsSuspendInstallationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsSuspendInstallationReq)
	}
	resp := &AppsSuspendInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsSuspendInstallation performs requests for "apps/suspend-installation"

Suspend an app installation.

  PUT /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
func (c Client) AppsSuspendInstallation(ctx context.Context, req *AppsSuspendInstallationReq, opt ...options.Option) (*AppsSuspendInstallationResponse, error) {
	return AppsSuspendInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsSuspendInstallationReq is request data for Client.AppsSuspendInstallation

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
type AppsSuspendInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64
}

// HTTPRequest builds an *http.Request
func (r *AppsSuspendInstallationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsSuspendInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "apps/suspend-installation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsSuspendInstallationReq) Rel(link RelName, resp *AppsSuspendInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsSuspendInstallationResponse is a response for AppsSuspendInstallation

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
type AppsSuspendInstallationResponse struct {
	common.Response
	request *AppsSuspendInstallationReq
	Data    bool
}

/*
AppsUnsuspendInstallation performs requests for "apps/unsuspend-installation"

Unsuspend an app installation.

  DELETE /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
func AppsUnsuspendInstallation(ctx context.Context, req *AppsUnsuspendInstallationReq, opt ...options.Option) (*AppsUnsuspendInstallationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AppsUnsuspendInstallationReq)
	}
	resp := &AppsUnsuspendInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsUnsuspendInstallation performs requests for "apps/unsuspend-installation"

Unsuspend an app installation.

  DELETE /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
func (c Client) AppsUnsuspendInstallation(ctx context.Context, req *AppsUnsuspendInstallationReq, opt ...options.Option) (*AppsUnsuspendInstallationResponse, error) {
	return AppsUnsuspendInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsUnsuspendInstallationReq is request data for Client.AppsUnsuspendInstallation

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
type AppsUnsuspendInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64
}

// HTTPRequest builds an *http.Request
func (r *AppsUnsuspendInstallationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AppsUnsuspendInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "apps/unsuspend-installation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsUnsuspendInstallationReq) Rel(link RelName, resp *AppsUnsuspendInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsUnsuspendInstallationResponse is a response for AppsUnsuspendInstallation

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
type AppsUnsuspendInstallationResponse struct {
	common.Response
	request *AppsUnsuspendInstallationReq
	Data    bool
}
