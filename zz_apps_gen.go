// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
AppsAddRepoToInstallation performs requests for "apps/add-repo-to-installation"

Add repository to installation.

  PUT /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#add-repository-to-installation
*/
func (c *Client) AppsAddRepoToInstallation(ctx context.Context, req *AppsAddRepoToInstallationReq, opt ...RequestOption) (*AppsAddRepoToInstallationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsAddRepoToInstallationResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsAddRepoToInstallationReq is request data for Client.AppsAddRepoToInstallation

https://developer.github.com/v3/apps/installations/#add-repository-to-installation
*/
type AppsAddRepoToInstallationReq struct {
	_url           string
	InstallationId int64
	RepositoryId   int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsAddRepoToInstallationReq) url() string {
	return r._url
}

func (r *AppsAddRepoToInstallationReq) urlPath() string {
	return fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId)
}

func (r *AppsAddRepoToInstallationReq) method() string {
	return "PUT"
}

func (r *AppsAddRepoToInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsAddRepoToInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsAddRepoToInstallationReq) body() interface{} {
	return nil
}

func (r *AppsAddRepoToInstallationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsAddRepoToInstallationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsAddRepoToInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsAddRepoToInstallationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsAddRepoToInstallationReq) Rel(link RelName, resp *AppsAddRepoToInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsAddRepoToInstallationResponse is a response for AppsAddRepoToInstallation

https://developer.github.com/v3/apps/installations/#add-repository-to-installation
*/
type AppsAddRepoToInstallationResponse struct {
	response
	request *AppsAddRepoToInstallationReq
}

/*
AppsCheckAuthorization performs requests for "apps/check-authorization"

Check an authorization.

  GET /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
func (c *Client) AppsCheckAuthorization(ctx context.Context, req *AppsCheckAuthorizationReq, opt ...RequestOption) (*AppsCheckAuthorizationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsCheckAuthorizationResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsCheckAuthorizationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCheckAuthorizationReq is request data for Client.AppsCheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type AppsCheckAuthorizationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

func (r *AppsCheckAuthorizationReq) url() string {
	return r._url
}

func (r *AppsCheckAuthorizationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken)
}

func (r *AppsCheckAuthorizationReq) method() string {
	return "GET"
}

func (r *AppsCheckAuthorizationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCheckAuthorizationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCheckAuthorizationReq) body() interface{} {
	return nil
}

func (r *AppsCheckAuthorizationReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsCheckAuthorizationReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsCheckAuthorizationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsCheckAuthorizationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCheckAuthorizationReq) Rel(link RelName, resp *AppsCheckAuthorizationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCheckAuthorizationResponseBody is a response body for AppsCheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type AppsCheckAuthorizationResponseBody struct {
	components.AuthorizationWithUser
}

/*
AppsCheckAuthorizationResponse is a response for AppsCheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type AppsCheckAuthorizationResponse struct {
	response
	request *AppsCheckAuthorizationReq
	Data    *AppsCheckAuthorizationResponseBody
}

/*
AppsCheckToken performs requests for "apps/check-token"

Check a token.

  POST /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
func (c *Client) AppsCheckToken(ctx context.Context, req *AppsCheckTokenReq, opt ...RequestOption) (*AppsCheckTokenResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsCheckTokenResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsCheckTokenResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCheckTokenReq is request data for Client.AppsCheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenReq struct {
	_url        string
	ClientId    string
	RequestBody AppsCheckTokenReqBody
}

func (r *AppsCheckTokenReq) url() string {
	return r._url
}

func (r *AppsCheckTokenReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/token", r.ClientId)
}

func (r *AppsCheckTokenReq) method() string {
	return "POST"
}

func (r *AppsCheckTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCheckTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCheckTokenReq) body() interface{} {
	return r.RequestBody
}

func (r *AppsCheckTokenReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsCheckTokenReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsCheckTokenReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *AppsCheckTokenReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCheckTokenReq) Rel(link RelName, resp *AppsCheckTokenResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCheckTokenReqBody is a request body for apps/check-token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsCheckTokenResponseBody is a response body for AppsCheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenResponseBody struct {
	components.AuthorizationWithUser
}

/*
AppsCheckTokenResponse is a response for AppsCheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenResponse struct {
	response
	request *AppsCheckTokenReq
	Data    *AppsCheckTokenResponseBody
}

/*
AppsCreateContentAttachment performs requests for "apps/create-content-attachment"

Create a content attachment.

  POST /content_references/{content_reference_id}/attachments

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
func (c *Client) AppsCreateContentAttachment(ctx context.Context, req *AppsCreateContentAttachmentReq, opt ...RequestOption) (*AppsCreateContentAttachmentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsCreateContentAttachmentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsCreateContentAttachmentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCreateContentAttachmentReq is request data for Client.AppsCreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentReq struct {
	_url               string
	ContentReferenceId int64
	RequestBody        AppsCreateContentAttachmentReqBody

	/*
	To access the Content Attachments API during the preview period, you must set
	this to true.
	*/
	CorsairPreview bool
}

func (r *AppsCreateContentAttachmentReq) url() string {
	return r._url
}

func (r *AppsCreateContentAttachmentReq) urlPath() string {
	return fmt.Sprintf("/content_references/%v/attachments", r.ContentReferenceId)
}

func (r *AppsCreateContentAttachmentReq) method() string {
	return "POST"
}

func (r *AppsCreateContentAttachmentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCreateContentAttachmentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"corsair": r.CorsairPreview}
	if requiredPreviews {
		previewVals["corsair"] = true
	}
	if allPreviews {
		previewVals["corsair"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCreateContentAttachmentReq) body() interface{} {
	return r.RequestBody
}

func (r *AppsCreateContentAttachmentReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsCreateContentAttachmentReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsCreateContentAttachmentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *AppsCreateContentAttachmentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCreateContentAttachmentReq) Rel(link RelName, resp *AppsCreateContentAttachmentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCreateContentAttachmentReqBody is a request body for apps/create-content-attachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentReqBody struct {

	/*
	   The body text of the content attachment displayed in the body or comment of an
	   issue or pull request. This parameter supports markdown.
	*/
	Body *string `json:"body"`

	/*
	   The title of the content attachment displayed in the body or comment of an issue
	   or pull request.
	*/
	Title *string `json:"title"`
}

/*
AppsCreateContentAttachmentResponseBody is a response body for AppsCreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentResponseBody struct {
	components.ContentReferenceAttachment
}

/*
AppsCreateContentAttachmentResponse is a response for AppsCreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentResponse struct {
	response
	request *AppsCreateContentAttachmentReq
	Data    *AppsCreateContentAttachmentResponseBody
}

/*
AppsCreateFromManifest performs requests for "apps/create-from-manifest"

Create a GitHub App from a manifest.

  POST /app-manifests/{code}/conversions

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
func (c *Client) AppsCreateFromManifest(ctx context.Context, req *AppsCreateFromManifestReq, opt ...RequestOption) (*AppsCreateFromManifestResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsCreateFromManifestResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsCreateFromManifestResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCreateFromManifestReq is request data for Client.AppsCreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type AppsCreateFromManifestReq struct {
	_url string
	Code string
}

func (r *AppsCreateFromManifestReq) url() string {
	return r._url
}

func (r *AppsCreateFromManifestReq) urlPath() string {
	return fmt.Sprintf("/app-manifests/%v/conversions", r.Code)
}

func (r *AppsCreateFromManifestReq) method() string {
	return "POST"
}

func (r *AppsCreateFromManifestReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCreateFromManifestReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCreateFromManifestReq) body() interface{} {
	return nil
}

func (r *AppsCreateFromManifestReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsCreateFromManifestReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsCreateFromManifestReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsCreateFromManifestReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCreateFromManifestReq) Rel(link RelName, resp *AppsCreateFromManifestResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCreateFromManifestResponseBody is a response body for AppsCreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type AppsCreateFromManifestResponseBody struct {
	components.IntegrationFromManifest
}

/*
AppsCreateFromManifestResponse is a response for AppsCreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type AppsCreateFromManifestResponse struct {
	response
	request *AppsCreateFromManifestReq
	Data    *AppsCreateFromManifestResponseBody
}

/*
AppsCreateInstallationToken performs requests for "apps/create-installation-token"

Create a new installation token.

  POST /app/installations/{installation_id}/access_tokens

https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
func (c *Client) AppsCreateInstallationToken(ctx context.Context, req *AppsCreateInstallationTokenReq, opt ...RequestOption) (*AppsCreateInstallationTokenResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsCreateInstallationTokenResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsCreateInstallationTokenResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCreateInstallationTokenReq is request data for Client.AppsCreateInstallationToken

https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
type AppsCreateInstallationTokenReq struct {
	_url           string
	InstallationId int64
	RequestBody    AppsCreateInstallationTokenReqBody

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsCreateInstallationTokenReq) url() string {
	return r._url
}

func (r *AppsCreateInstallationTokenReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v/access_tokens", r.InstallationId)
}

func (r *AppsCreateInstallationTokenReq) method() string {
	return "POST"
}

func (r *AppsCreateInstallationTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCreateInstallationTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCreateInstallationTokenReq) body() interface{} {
	return r.RequestBody
}

func (r *AppsCreateInstallationTokenReq) dataStatuses() []int {
	return []int{201}
}

func (r *AppsCreateInstallationTokenReq) validStatuses() []int {
	return []int{201}
}

func (r *AppsCreateInstallationTokenReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *AppsCreateInstallationTokenReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCreateInstallationTokenReq) Rel(link RelName, resp *AppsCreateInstallationTokenResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCreateInstallationTokenReqBody is a request body for apps/create-installation-token

https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
type AppsCreateInstallationTokenReqBody struct {

	/*
	   The permissions granted to the access token. The permissions object includes the
	   permission names and their access type. For a complete list of permissions and
	   allowable values, see "[GitHub App
	   permissions](https://developer.github.com/apps/building-github-apps/creating-github-apps-using-url-parameters/#github-app-permissions)."
	*/
	Permissions interface{} `json:"permissions,omitempty"`

	/*
	   The `id`s of the repositories that the installation token can access. Providing
	   repository `id`s restricts the access of an installation token to specific
	   repositories. You can use the "[List
	   repositories](https://developer.github.com/v3/apps/installations/#list-repositories)"
	   endpoint to get the `id` of all repositories that an installation can access.
	   For example, you can select specific repositories when creating an installation
	   token to restrict the number of repositories that can be cloned using the token.
	*/
	RepositoryIds []int64 `json:"repository_ids,omitempty"`
}

/*
AppsCreateInstallationTokenResponseBody is a response body for AppsCreateInstallationToken

https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
type AppsCreateInstallationTokenResponseBody struct {
	components.InstallationToken
}

/*
AppsCreateInstallationTokenResponse is a response for AppsCreateInstallationToken

https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
type AppsCreateInstallationTokenResponse struct {
	response
	request *AppsCreateInstallationTokenReq
	Data    *AppsCreateInstallationTokenResponseBody
}

/*
AppsDeleteAuthorization performs requests for "apps/delete-authorization"

Delete an app authorization.

  DELETE /applications/{client_id}/grant

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
func (c *Client) AppsDeleteAuthorization(ctx context.Context, req *AppsDeleteAuthorizationReq, opt ...RequestOption) (*AppsDeleteAuthorizationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsDeleteAuthorizationResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsDeleteAuthorizationReq is request data for Client.AppsDeleteAuthorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type AppsDeleteAuthorizationReq struct {
	_url        string
	ClientId    string
	RequestBody AppsDeleteAuthorizationReqBody
}

func (r *AppsDeleteAuthorizationReq) url() string {
	return r._url
}

func (r *AppsDeleteAuthorizationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/grant", r.ClientId)
}

func (r *AppsDeleteAuthorizationReq) method() string {
	return "DELETE"
}

func (r *AppsDeleteAuthorizationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsDeleteAuthorizationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsDeleteAuthorizationReq) body() interface{} {
	return r.RequestBody
}

func (r *AppsDeleteAuthorizationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsDeleteAuthorizationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsDeleteAuthorizationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *AppsDeleteAuthorizationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsDeleteAuthorizationReq) Rel(link RelName, resp *AppsDeleteAuthorizationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsDeleteAuthorizationReqBody is a request body for apps/delete-authorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type AppsDeleteAuthorizationReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsDeleteAuthorizationResponse is a response for AppsDeleteAuthorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type AppsDeleteAuthorizationResponse struct {
	response
	request *AppsDeleteAuthorizationReq
}

/*
AppsDeleteInstallation performs requests for "apps/delete-installation"

Delete an installation.

  DELETE /app/installations/{installation_id}

https://developer.github.com/v3/apps/#delete-an-installation
*/
func (c *Client) AppsDeleteInstallation(ctx context.Context, req *AppsDeleteInstallationReq, opt ...RequestOption) (*AppsDeleteInstallationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsDeleteInstallationResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsDeleteInstallationReq is request data for Client.AppsDeleteInstallation

https://developer.github.com/v3/apps/#delete-an-installation
*/
type AppsDeleteInstallationReq struct {
	_url           string
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsDeleteInstallationReq) url() string {
	return r._url
}

func (r *AppsDeleteInstallationReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v", r.InstallationId)
}

func (r *AppsDeleteInstallationReq) method() string {
	return "DELETE"
}

func (r *AppsDeleteInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsDeleteInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsDeleteInstallationReq) body() interface{} {
	return nil
}

func (r *AppsDeleteInstallationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsDeleteInstallationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsDeleteInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsDeleteInstallationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsDeleteInstallationReq) Rel(link RelName, resp *AppsDeleteInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsDeleteInstallationResponse is a response for AppsDeleteInstallation

https://developer.github.com/v3/apps/#delete-an-installation
*/
type AppsDeleteInstallationResponse struct {
	response
	request *AppsDeleteInstallationReq
}

/*
AppsDeleteToken performs requests for "apps/delete-token"

Delete an app token.

  DELETE /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
func (c *Client) AppsDeleteToken(ctx context.Context, req *AppsDeleteTokenReq, opt ...RequestOption) (*AppsDeleteTokenResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsDeleteTokenResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsDeleteTokenReq is request data for Client.AppsDeleteToken

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type AppsDeleteTokenReq struct {
	_url        string
	ClientId    string
	RequestBody AppsDeleteTokenReqBody
}

func (r *AppsDeleteTokenReq) url() string {
	return r._url
}

func (r *AppsDeleteTokenReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/token", r.ClientId)
}

func (r *AppsDeleteTokenReq) method() string {
	return "DELETE"
}

func (r *AppsDeleteTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsDeleteTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsDeleteTokenReq) body() interface{} {
	return r.RequestBody
}

func (r *AppsDeleteTokenReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsDeleteTokenReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsDeleteTokenReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *AppsDeleteTokenReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsDeleteTokenReq) Rel(link RelName, resp *AppsDeleteTokenResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsDeleteTokenReqBody is a request body for apps/delete-token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type AppsDeleteTokenReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsDeleteTokenResponse is a response for AppsDeleteToken

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type AppsDeleteTokenResponse struct {
	response
	request *AppsDeleteTokenReq
}

/*
AppsGetAuthenticated performs requests for "apps/get-authenticated"

Get the authenticated GitHub App.

  GET /app

https://developer.github.com/v3/apps/#get-the-authenticated-github-app
*/
func (c *Client) AppsGetAuthenticated(ctx context.Context, req *AppsGetAuthenticatedReq, opt ...RequestOption) (*AppsGetAuthenticatedResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsGetAuthenticatedResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsGetAuthenticatedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetAuthenticatedReq is request data for Client.AppsGetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-github-app
*/
type AppsGetAuthenticatedReq struct {
	_url string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetAuthenticatedReq) url() string {
	return r._url
}

func (r *AppsGetAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/app")
}

func (r *AppsGetAuthenticatedReq) method() string {
	return "GET"
}

func (r *AppsGetAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetAuthenticatedReq) body() interface{} {
	return nil
}

func (r *AppsGetAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetAuthenticatedReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsGetAuthenticatedReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetAuthenticatedReq) Rel(link RelName, resp *AppsGetAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetAuthenticatedResponseBody is a response body for AppsGetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-github-app
*/
type AppsGetAuthenticatedResponseBody struct {
	components.Integration
}

/*
AppsGetAuthenticatedResponse is a response for AppsGetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-github-app
*/
type AppsGetAuthenticatedResponse struct {
	response
	request *AppsGetAuthenticatedReq
	Data    *AppsGetAuthenticatedResponseBody
}

/*
AppsGetBySlug performs requests for "apps/get-by-slug"

Get a single GitHub App.

  GET /apps/{app_slug}

https://developer.github.com/v3/apps/#get-a-single-github-app
*/
func (c *Client) AppsGetBySlug(ctx context.Context, req *AppsGetBySlugReq, opt ...RequestOption) (*AppsGetBySlugResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsGetBySlugResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsGetBySlugResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetBySlugReq is request data for Client.AppsGetBySlug

https://developer.github.com/v3/apps/#get-a-single-github-app
*/
type AppsGetBySlugReq struct {
	_url    string
	AppSlug string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetBySlugReq) url() string {
	return r._url
}

func (r *AppsGetBySlugReq) urlPath() string {
	return fmt.Sprintf("/apps/%v", r.AppSlug)
}

func (r *AppsGetBySlugReq) method() string {
	return "GET"
}

func (r *AppsGetBySlugReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetBySlugReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetBySlugReq) body() interface{} {
	return nil
}

func (r *AppsGetBySlugReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetBySlugReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetBySlugReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsGetBySlugReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetBySlugReq) Rel(link RelName, resp *AppsGetBySlugResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetBySlugResponseBody is a response body for AppsGetBySlug

https://developer.github.com/v3/apps/#get-a-single-github-app
*/
type AppsGetBySlugResponseBody struct {
	components.Integration2
}

/*
AppsGetBySlugResponse is a response for AppsGetBySlug

https://developer.github.com/v3/apps/#get-a-single-github-app
*/
type AppsGetBySlugResponse struct {
	response
	request *AppsGetBySlugReq
	Data    *AppsGetBySlugResponseBody
}

/*
AppsGetInstallation performs requests for "apps/get-installation"

Get an installation.

  GET /app/installations/{installation_id}

https://developer.github.com/v3/apps/#get-an-installation
*/
func (c *Client) AppsGetInstallation(ctx context.Context, req *AppsGetInstallationReq, opt ...RequestOption) (*AppsGetInstallationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsGetInstallationResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsGetInstallationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetInstallationReq is request data for Client.AppsGetInstallation

https://developer.github.com/v3/apps/#get-an-installation
*/
type AppsGetInstallationReq struct {
	_url           string
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetInstallationReq) url() string {
	return r._url
}

func (r *AppsGetInstallationReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v", r.InstallationId)
}

func (r *AppsGetInstallationReq) method() string {
	return "GET"
}

func (r *AppsGetInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetInstallationReq) body() interface{} {
	return nil
}

func (r *AppsGetInstallationReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetInstallationReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsGetInstallationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetInstallationReq) Rel(link RelName, resp *AppsGetInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetInstallationResponseBody is a response body for AppsGetInstallation

https://developer.github.com/v3/apps/#get-an-installation
*/
type AppsGetInstallationResponseBody struct {
	components.BaseInstallation
}

/*
AppsGetInstallationResponse is a response for AppsGetInstallation

https://developer.github.com/v3/apps/#get-an-installation
*/
type AppsGetInstallationResponse struct {
	response
	request *AppsGetInstallationReq
	Data    *AppsGetInstallationResponseBody
}

/*
AppsGetOrgInstallation performs requests for "apps/get-org-installation"

Get an organization installation.

  GET /orgs/{org}/installation

https://developer.github.com/v3/apps/#get-an-organization-installation
*/
func (c *Client) AppsGetOrgInstallation(ctx context.Context, req *AppsGetOrgInstallationReq, opt ...RequestOption) (*AppsGetOrgInstallationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsGetOrgInstallationResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsGetOrgInstallationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetOrgInstallationReq is request data for Client.AppsGetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation
*/
type AppsGetOrgInstallationReq struct {
	_url string
	Org  string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetOrgInstallationReq) url() string {
	return r._url
}

func (r *AppsGetOrgInstallationReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/installation", r.Org)
}

func (r *AppsGetOrgInstallationReq) method() string {
	return "GET"
}

func (r *AppsGetOrgInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetOrgInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetOrgInstallationReq) body() interface{} {
	return nil
}

func (r *AppsGetOrgInstallationReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetOrgInstallationReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetOrgInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsGetOrgInstallationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetOrgInstallationReq) Rel(link RelName, resp *AppsGetOrgInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetOrgInstallationResponseBody is a response body for AppsGetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation
*/
type AppsGetOrgInstallationResponseBody struct {
	components.Installation
}

/*
AppsGetOrgInstallationResponse is a response for AppsGetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation
*/
type AppsGetOrgInstallationResponse struct {
	response
	request *AppsGetOrgInstallationReq
	Data    *AppsGetOrgInstallationResponseBody
}

/*
AppsGetRepoInstallation performs requests for "apps/get-repo-installation"

Get a repository installation.

  GET /repos/{owner}/{repo}/installation

https://developer.github.com/v3/apps/#get-a-repository-installation
*/
func (c *Client) AppsGetRepoInstallation(ctx context.Context, req *AppsGetRepoInstallationReq, opt ...RequestOption) (*AppsGetRepoInstallationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsGetRepoInstallationResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsGetRepoInstallationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetRepoInstallationReq is request data for Client.AppsGetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation
*/
type AppsGetRepoInstallationReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetRepoInstallationReq) url() string {
	return r._url
}

func (r *AppsGetRepoInstallationReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/installation", r.Owner, r.Repo)
}

func (r *AppsGetRepoInstallationReq) method() string {
	return "GET"
}

func (r *AppsGetRepoInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetRepoInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetRepoInstallationReq) body() interface{} {
	return nil
}

func (r *AppsGetRepoInstallationReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetRepoInstallationReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetRepoInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsGetRepoInstallationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetRepoInstallationReq) Rel(link RelName, resp *AppsGetRepoInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetRepoInstallationResponseBody is a response body for AppsGetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation
*/
type AppsGetRepoInstallationResponseBody struct {
	components.Installation
}

/*
AppsGetRepoInstallationResponse is a response for AppsGetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation
*/
type AppsGetRepoInstallationResponse struct {
	response
	request *AppsGetRepoInstallationReq
	Data    *AppsGetRepoInstallationResponseBody
}

/*
AppsGetSubscriptionPlanForAccount performs requests for "apps/get-subscription-plan-for-account"

Get a subscription plan for an account.

  GET /marketplace_listing/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
func (c *Client) AppsGetSubscriptionPlanForAccount(ctx context.Context, req *AppsGetSubscriptionPlanForAccountReq, opt ...RequestOption) (*AppsGetSubscriptionPlanForAccountResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsGetSubscriptionPlanForAccountResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsGetSubscriptionPlanForAccountResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetSubscriptionPlanForAccountReq is request data for Client.AppsGetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type AppsGetSubscriptionPlanForAccountReq struct {
	_url      string
	AccountId int64
}

func (r *AppsGetSubscriptionPlanForAccountReq) url() string {
	return r._url
}

func (r *AppsGetSubscriptionPlanForAccountReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/accounts/%v", r.AccountId)
}

func (r *AppsGetSubscriptionPlanForAccountReq) method() string {
	return "GET"
}

func (r *AppsGetSubscriptionPlanForAccountReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetSubscriptionPlanForAccountReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetSubscriptionPlanForAccountReq) body() interface{} {
	return nil
}

func (r *AppsGetSubscriptionPlanForAccountReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetSubscriptionPlanForAccountReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetSubscriptionPlanForAccountReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsGetSubscriptionPlanForAccountReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetSubscriptionPlanForAccountReq) Rel(link RelName, resp *AppsGetSubscriptionPlanForAccountResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetSubscriptionPlanForAccountResponseBody is a response body for AppsGetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type AppsGetSubscriptionPlanForAccountResponseBody struct {
	components.MarketplacePurchase
}

/*
AppsGetSubscriptionPlanForAccountResponse is a response for AppsGetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type AppsGetSubscriptionPlanForAccountResponse struct {
	response
	request *AppsGetSubscriptionPlanForAccountReq
	Data    *AppsGetSubscriptionPlanForAccountResponseBody
}

/*
AppsGetSubscriptionPlanForAccountStubbed performs requests for "apps/get-subscription-plan-for-account-stubbed"

Get a subscription plan for an account (stubbed).

  GET /marketplace_listing/stubbed/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
func (c *Client) AppsGetSubscriptionPlanForAccountStubbed(ctx context.Context, req *AppsGetSubscriptionPlanForAccountStubbedReq, opt ...RequestOption) (*AppsGetSubscriptionPlanForAccountStubbedResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsGetSubscriptionPlanForAccountStubbedResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsGetSubscriptionPlanForAccountStubbedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetSubscriptionPlanForAccountStubbedReq is request data for Client.AppsGetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type AppsGetSubscriptionPlanForAccountStubbedReq struct {
	_url      string
	AccountId int64
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) url() string {
	return r._url
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/stubbed/accounts/%v", r.AccountId)
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) method() string {
	return "GET"
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) body() interface{} {
	return nil
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsGetSubscriptionPlanForAccountStubbedReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetSubscriptionPlanForAccountStubbedReq) Rel(link RelName, resp *AppsGetSubscriptionPlanForAccountStubbedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetSubscriptionPlanForAccountStubbedResponseBody is a response body for AppsGetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type AppsGetSubscriptionPlanForAccountStubbedResponseBody struct {
	components.MarketplacePurchase
}

/*
AppsGetSubscriptionPlanForAccountStubbedResponse is a response for AppsGetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type AppsGetSubscriptionPlanForAccountStubbedResponse struct {
	response
	request *AppsGetSubscriptionPlanForAccountStubbedReq
	Data    *AppsGetSubscriptionPlanForAccountStubbedResponseBody
}

/*
AppsGetUserInstallation performs requests for "apps/get-user-installation"

Get a user installation.

  GET /users/{username}/installation

https://developer.github.com/v3/apps/#get-a-user-installation
*/
func (c *Client) AppsGetUserInstallation(ctx context.Context, req *AppsGetUserInstallationReq, opt ...RequestOption) (*AppsGetUserInstallationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsGetUserInstallationResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsGetUserInstallationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetUserInstallationReq is request data for Client.AppsGetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation
*/
type AppsGetUserInstallationReq struct {
	_url     string
	Username string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetUserInstallationReq) url() string {
	return r._url
}

func (r *AppsGetUserInstallationReq) urlPath() string {
	return fmt.Sprintf("/users/%v/installation", r.Username)
}

func (r *AppsGetUserInstallationReq) method() string {
	return "GET"
}

func (r *AppsGetUserInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetUserInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetUserInstallationReq) body() interface{} {
	return nil
}

func (r *AppsGetUserInstallationReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetUserInstallationReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetUserInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsGetUserInstallationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetUserInstallationReq) Rel(link RelName, resp *AppsGetUserInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetUserInstallationResponseBody is a response body for AppsGetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation
*/
type AppsGetUserInstallationResponseBody struct {
	components.Installation2
}

/*
AppsGetUserInstallationResponse is a response for AppsGetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation
*/
type AppsGetUserInstallationResponse struct {
	response
	request *AppsGetUserInstallationReq
	Data    *AppsGetUserInstallationResponseBody
}

/*
AppsListAccountsForPlan performs requests for "apps/list-accounts-for-plan"

List accounts for a plan.

  GET /marketplace_listing/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
func (c *Client) AppsListAccountsForPlan(ctx context.Context, req *AppsListAccountsForPlanReq, opt ...RequestOption) (*AppsListAccountsForPlanResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsListAccountsForPlanResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsListAccountsForPlanResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListAccountsForPlanReq is request data for Client.AppsListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type AppsListAccountsForPlanReq struct {
	_url   string
	PlanId int64

	/*
	Sorts the GitHub accounts by the date they were created or last updated. Can be
	one of `created` or `updated`.
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListAccountsForPlanReq) url() string {
	return r._url
}

func (r *AppsListAccountsForPlanReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/plans/%v/accounts", r.PlanId)
}

func (r *AppsListAccountsForPlanReq) method() string {
	return "GET"
}

func (r *AppsListAccountsForPlanReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListAccountsForPlanReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListAccountsForPlanReq) body() interface{} {
	return nil
}

func (r *AppsListAccountsForPlanReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListAccountsForPlanReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListAccountsForPlanReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsListAccountsForPlanReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListAccountsForPlanReq) Rel(link RelName, resp *AppsListAccountsForPlanResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListAccountsForPlanResponseBody is a response body for AppsListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type AppsListAccountsForPlanResponseBody []struct {
	components.MarketplacePurchase
}

/*
AppsListAccountsForPlanResponse is a response for AppsListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type AppsListAccountsForPlanResponse struct {
	response
	request *AppsListAccountsForPlanReq
	Data    *AppsListAccountsForPlanResponseBody
}

/*
AppsListAccountsForPlanStubbed performs requests for "apps/list-accounts-for-plan-stubbed"

List accounts for a plan (stubbed).

  GET /marketplace_listing/stubbed/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
func (c *Client) AppsListAccountsForPlanStubbed(ctx context.Context, req *AppsListAccountsForPlanStubbedReq, opt ...RequestOption) (*AppsListAccountsForPlanStubbedResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsListAccountsForPlanStubbedResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsListAccountsForPlanStubbedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListAccountsForPlanStubbedReq is request data for Client.AppsListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type AppsListAccountsForPlanStubbedReq struct {
	_url   string
	PlanId int64

	/*
	Sorts the GitHub accounts by the date they were created or last updated. Can be
	one of `created` or `updated`.
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListAccountsForPlanStubbedReq) url() string {
	return r._url
}

func (r *AppsListAccountsForPlanStubbedReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/stubbed/plans/%v/accounts", r.PlanId)
}

func (r *AppsListAccountsForPlanStubbedReq) method() string {
	return "GET"
}

func (r *AppsListAccountsForPlanStubbedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListAccountsForPlanStubbedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListAccountsForPlanStubbedReq) body() interface{} {
	return nil
}

func (r *AppsListAccountsForPlanStubbedReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListAccountsForPlanStubbedReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListAccountsForPlanStubbedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsListAccountsForPlanStubbedReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListAccountsForPlanStubbedReq) Rel(link RelName, resp *AppsListAccountsForPlanStubbedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListAccountsForPlanStubbedResponseBody is a response body for AppsListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type AppsListAccountsForPlanStubbedResponseBody []struct {
	components.MarketplacePurchase
}

/*
AppsListAccountsForPlanStubbedResponse is a response for AppsListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type AppsListAccountsForPlanStubbedResponse struct {
	response
	request *AppsListAccountsForPlanStubbedReq
	Data    *AppsListAccountsForPlanStubbedResponseBody
}

/*
AppsListInstallationReposForAuthenticatedUser performs requests for "apps/list-installation-repos-for-authenticated-user"

List repositories accessible to the user for an installation.

  GET /user/installations/{installation_id}/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-for-an-installation
*/
func (c *Client) AppsListInstallationReposForAuthenticatedUser(ctx context.Context, req *AppsListInstallationReposForAuthenticatedUserReq, opt ...RequestOption) (*AppsListInstallationReposForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsListInstallationReposForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsListInstallationReposForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListInstallationReposForAuthenticatedUserReq is request data for Client.AppsListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-for-an-installation
*/
type AppsListInstallationReposForAuthenticatedUserReq struct {
	_url           string
	InstallationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/installations/%v/repositories", r.InstallationId)
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man": r.MachineManPreview,
		"mercy":       r.MercyPreview,
	}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["mercy"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsListInstallationReposForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListInstallationReposForAuthenticatedUserReq) Rel(link RelName, resp *AppsListInstallationReposForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListInstallationReposForAuthenticatedUserResponseBody is a response body for AppsListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-for-an-installation
*/
type AppsListInstallationReposForAuthenticatedUserResponseBody struct {
	Repositories []struct {
		components.Repository
	} `json:"repositories,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
AppsListInstallationReposForAuthenticatedUserResponse is a response for AppsListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-for-an-installation
*/
type AppsListInstallationReposForAuthenticatedUserResponse struct {
	response
	request *AppsListInstallationReposForAuthenticatedUserReq
	Data    *AppsListInstallationReposForAuthenticatedUserResponseBody
}

/*
AppsListInstallations performs requests for "apps/list-installations"

List installations.

  GET /app/installations

https://developer.github.com/v3/apps/#list-installations
*/
func (c *Client) AppsListInstallations(ctx context.Context, req *AppsListInstallationsReq, opt ...RequestOption) (*AppsListInstallationsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsListInstallationsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsListInstallationsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListInstallationsReq is request data for Client.AppsListInstallations

https://developer.github.com/v3/apps/#list-installations
*/
type AppsListInstallationsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsListInstallationsReq) url() string {
	return r._url
}

func (r *AppsListInstallationsReq) urlPath() string {
	return fmt.Sprintf("/app/installations")
}

func (r *AppsListInstallationsReq) method() string {
	return "GET"
}

func (r *AppsListInstallationsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListInstallationsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListInstallationsReq) body() interface{} {
	return nil
}

func (r *AppsListInstallationsReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListInstallationsReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListInstallationsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsListInstallationsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListInstallationsReq) Rel(link RelName, resp *AppsListInstallationsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListInstallationsResponseBody is a response body for AppsListInstallations

https://developer.github.com/v3/apps/#list-installations
*/
type AppsListInstallationsResponseBody []struct {
	components.BaseInstallation
}

/*
AppsListInstallationsResponse is a response for AppsListInstallations

https://developer.github.com/v3/apps/#list-installations
*/
type AppsListInstallationsResponse struct {
	response
	request *AppsListInstallationsReq
	Data    *AppsListInstallationsResponseBody
}

/*
AppsListInstallationsForAuthenticatedUser performs requests for "apps/list-installations-for-authenticated-user"

List installations for a user.

  GET /user/installations

https://developer.github.com/v3/apps/installations/#list-installations-for-a-user
*/
func (c *Client) AppsListInstallationsForAuthenticatedUser(ctx context.Context, req *AppsListInstallationsForAuthenticatedUserReq, opt ...RequestOption) (*AppsListInstallationsForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsListInstallationsForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsListInstallationsForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListInstallationsForAuthenticatedUserReq is request data for Client.AppsListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-installations-for-a-user
*/
type AppsListInstallationsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsListInstallationsForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *AppsListInstallationsForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/installations")
}

func (r *AppsListInstallationsForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *AppsListInstallationsForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListInstallationsForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListInstallationsForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *AppsListInstallationsForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListInstallationsForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListInstallationsForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsListInstallationsForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListInstallationsForAuthenticatedUserReq) Rel(link RelName, resp *AppsListInstallationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListInstallationsForAuthenticatedUserResponseBody is a response body for AppsListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-installations-for-a-user
*/
type AppsListInstallationsForAuthenticatedUserResponseBody struct {
	Installations []struct {
		components.BaseInstallationForAuthUser
	} `json:"installations,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
AppsListInstallationsForAuthenticatedUserResponse is a response for AppsListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-installations-for-a-user
*/
type AppsListInstallationsForAuthenticatedUserResponse struct {
	response
	request *AppsListInstallationsForAuthenticatedUserReq
	Data    *AppsListInstallationsForAuthenticatedUserResponseBody
}

/*
AppsListPlans performs requests for "apps/list-plans"

List plans.

  GET /marketplace_listing/plans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
func (c *Client) AppsListPlans(ctx context.Context, req *AppsListPlansReq, opt ...RequestOption) (*AppsListPlansResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsListPlansResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsListPlansResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListPlansReq is request data for Client.AppsListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type AppsListPlansReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListPlansReq) url() string {
	return r._url
}

func (r *AppsListPlansReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/plans")
}

func (r *AppsListPlansReq) method() string {
	return "GET"
}

func (r *AppsListPlansReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListPlansReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListPlansReq) body() interface{} {
	return nil
}

func (r *AppsListPlansReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListPlansReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListPlansReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsListPlansReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListPlansReq) Rel(link RelName, resp *AppsListPlansResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListPlansResponseBody is a response body for AppsListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type AppsListPlansResponseBody []struct {
	components.MarketplaceListingPlan
}

/*
AppsListPlansResponse is a response for AppsListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type AppsListPlansResponse struct {
	response
	request *AppsListPlansReq
	Data    *AppsListPlansResponseBody
}

/*
AppsListPlansStubbed performs requests for "apps/list-plans-stubbed"

List plans (stubbed).

  GET /marketplace_listing/stubbed/plans

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
func (c *Client) AppsListPlansStubbed(ctx context.Context, req *AppsListPlansStubbedReq, opt ...RequestOption) (*AppsListPlansStubbedResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsListPlansStubbedResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsListPlansStubbedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListPlansStubbedReq is request data for Client.AppsListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type AppsListPlansStubbedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListPlansStubbedReq) url() string {
	return r._url
}

func (r *AppsListPlansStubbedReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/stubbed/plans")
}

func (r *AppsListPlansStubbedReq) method() string {
	return "GET"
}

func (r *AppsListPlansStubbedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListPlansStubbedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListPlansStubbedReq) body() interface{} {
	return nil
}

func (r *AppsListPlansStubbedReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListPlansStubbedReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListPlansStubbedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsListPlansStubbedReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListPlansStubbedReq) Rel(link RelName, resp *AppsListPlansStubbedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListPlansStubbedResponseBody is a response body for AppsListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type AppsListPlansStubbedResponseBody []struct {
	components.MarketplaceListingPlan
}

/*
AppsListPlansStubbedResponse is a response for AppsListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type AppsListPlansStubbedResponse struct {
	response
	request *AppsListPlansStubbedReq
	Data    *AppsListPlansStubbedResponseBody
}

/*
AppsListRepos performs requests for "apps/list-repos"

List repositories.

  GET /installation/repositories

https://developer.github.com/v3/apps/installations/#list-repositories
*/
func (c *Client) AppsListRepos(ctx context.Context, req *AppsListReposReq, opt ...RequestOption) (*AppsListReposResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsListReposResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsListReposResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListReposReq is request data for Client.AppsListRepos

https://developer.github.com/v3/apps/installations/#list-repositories
*/
type AppsListReposReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

func (r *AppsListReposReq) url() string {
	return r._url
}

func (r *AppsListReposReq) urlPath() string {
	return fmt.Sprintf("/installation/repositories")
}

func (r *AppsListReposReq) method() string {
	return "GET"
}

func (r *AppsListReposReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListReposReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man": r.MachineManPreview,
		"mercy":       r.MercyPreview,
	}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["mercy"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListReposReq) body() interface{} {
	return nil
}

func (r *AppsListReposReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListReposReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListReposReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsListReposReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListReposReq) Rel(link RelName, resp *AppsListReposResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListReposResponseBody is a response body for AppsListRepos

https://developer.github.com/v3/apps/installations/#list-repositories
*/
type AppsListReposResponseBody struct {
	Repositories []struct {
		components.Repository2
	} `json:"repositories,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
AppsListReposResponse is a response for AppsListRepos

https://developer.github.com/v3/apps/installations/#list-repositories
*/
type AppsListReposResponse struct {
	response
	request *AppsListReposReq
	Data    *AppsListReposResponseBody
}

/*
AppsListSubscriptionsForAuthenticatedUser performs requests for "apps/list-subscriptions-for-authenticated-user"

List subscriptions for the authenticated user.

  GET /user/marketplace_purchases

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
func (c *Client) AppsListSubscriptionsForAuthenticatedUser(ctx context.Context, req *AppsListSubscriptionsForAuthenticatedUserReq, opt ...RequestOption) (*AppsListSubscriptionsForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsListSubscriptionsForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsListSubscriptionsForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListSubscriptionsForAuthenticatedUserReq is request data for Client.AppsListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type AppsListSubscriptionsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/marketplace_purchases")
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsListSubscriptionsForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListSubscriptionsForAuthenticatedUserReq) Rel(link RelName, resp *AppsListSubscriptionsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListSubscriptionsForAuthenticatedUserResponseBody is a response body for AppsListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type AppsListSubscriptionsForAuthenticatedUserResponseBody []struct {
	components.UserMarketplacePurchase
}

/*
AppsListSubscriptionsForAuthenticatedUserResponse is a response for AppsListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type AppsListSubscriptionsForAuthenticatedUserResponse struct {
	response
	request *AppsListSubscriptionsForAuthenticatedUserReq
	Data    *AppsListSubscriptionsForAuthenticatedUserResponseBody
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbed performs requests for "apps/list-subscriptions-for-authenticated-user-stubbed"

List subscriptions for the authenticated user (stubbed).

  GET /user/marketplace_purchases/stubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
func (c *Client) AppsListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, req *AppsListSubscriptionsForAuthenticatedUserStubbedReq, opt ...RequestOption) (*AppsListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsListSubscriptionsForAuthenticatedUserStubbedResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsListSubscriptionsForAuthenticatedUserStubbedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbedReq is request data for Client.AppsListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type AppsListSubscriptionsForAuthenticatedUserStubbedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) url() string {
	return r._url
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) urlPath() string {
	return fmt.Sprintf("/user/marketplace_purchases/stubbed")
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) method() string {
	return "GET"
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) body() interface{} {
	return nil
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) Rel(link RelName, resp *AppsListSubscriptionsForAuthenticatedUserStubbedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbedResponseBody is a response body for AppsListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type AppsListSubscriptionsForAuthenticatedUserStubbedResponseBody []struct {
	components.UserMarketplacePurchase
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbedResponse is a response for AppsListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type AppsListSubscriptionsForAuthenticatedUserStubbedResponse struct {
	response
	request *AppsListSubscriptionsForAuthenticatedUserStubbedReq
	Data    *AppsListSubscriptionsForAuthenticatedUserStubbedResponseBody
}

/*
AppsRemoveRepoFromInstallation performs requests for "apps/remove-repo-from-installation"

Remove repository from installation.

  DELETE /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#remove-repository-from-installation
*/
func (c *Client) AppsRemoveRepoFromInstallation(ctx context.Context, req *AppsRemoveRepoFromInstallationReq, opt ...RequestOption) (*AppsRemoveRepoFromInstallationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsRemoveRepoFromInstallationResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsRemoveRepoFromInstallationReq is request data for Client.AppsRemoveRepoFromInstallation

https://developer.github.com/v3/apps/installations/#remove-repository-from-installation
*/
type AppsRemoveRepoFromInstallationReq struct {
	_url           string
	InstallationId int64
	RepositoryId   int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsRemoveRepoFromInstallationReq) url() string {
	return r._url
}

func (r *AppsRemoveRepoFromInstallationReq) urlPath() string {
	return fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId)
}

func (r *AppsRemoveRepoFromInstallationReq) method() string {
	return "DELETE"
}

func (r *AppsRemoveRepoFromInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsRemoveRepoFromInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsRemoveRepoFromInstallationReq) body() interface{} {
	return nil
}

func (r *AppsRemoveRepoFromInstallationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsRemoveRepoFromInstallationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsRemoveRepoFromInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsRemoveRepoFromInstallationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsRemoveRepoFromInstallationReq) Rel(link RelName, resp *AppsRemoveRepoFromInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsRemoveRepoFromInstallationResponse is a response for AppsRemoveRepoFromInstallation

https://developer.github.com/v3/apps/installations/#remove-repository-from-installation
*/
type AppsRemoveRepoFromInstallationResponse struct {
	response
	request *AppsRemoveRepoFromInstallationReq
}

/*
AppsResetAuthorization performs requests for "apps/reset-authorization"

Reset an authorization.

  POST /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
func (c *Client) AppsResetAuthorization(ctx context.Context, req *AppsResetAuthorizationReq, opt ...RequestOption) (*AppsResetAuthorizationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsResetAuthorizationResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsResetAuthorizationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsResetAuthorizationReq is request data for Client.AppsResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type AppsResetAuthorizationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

func (r *AppsResetAuthorizationReq) url() string {
	return r._url
}

func (r *AppsResetAuthorizationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken)
}

func (r *AppsResetAuthorizationReq) method() string {
	return "POST"
}

func (r *AppsResetAuthorizationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsResetAuthorizationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsResetAuthorizationReq) body() interface{} {
	return nil
}

func (r *AppsResetAuthorizationReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsResetAuthorizationReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsResetAuthorizationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsResetAuthorizationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsResetAuthorizationReq) Rel(link RelName, resp *AppsResetAuthorizationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsResetAuthorizationResponseBody is a response body for AppsResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type AppsResetAuthorizationResponseBody struct {
	components.AuthorizationWithUser
}

/*
AppsResetAuthorizationResponse is a response for AppsResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type AppsResetAuthorizationResponse struct {
	response
	request *AppsResetAuthorizationReq
	Data    *AppsResetAuthorizationResponseBody
}

/*
AppsResetToken performs requests for "apps/reset-token"

Reset a token.

  PATCH /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
func (c *Client) AppsResetToken(ctx context.Context, req *AppsResetTokenReq, opt ...RequestOption) (*AppsResetTokenResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsResetTokenResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(AppsResetTokenResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsResetTokenReq is request data for Client.AppsResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenReq struct {
	_url        string
	ClientId    string
	RequestBody AppsResetTokenReqBody
}

func (r *AppsResetTokenReq) url() string {
	return r._url
}

func (r *AppsResetTokenReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/token", r.ClientId)
}

func (r *AppsResetTokenReq) method() string {
	return "PATCH"
}

func (r *AppsResetTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsResetTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsResetTokenReq) body() interface{} {
	return r.RequestBody
}

func (r *AppsResetTokenReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsResetTokenReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsResetTokenReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *AppsResetTokenReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsResetTokenReq) Rel(link RelName, resp *AppsResetTokenResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsResetTokenReqBody is a request body for apps/reset-token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsResetTokenResponseBody is a response body for AppsResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenResponseBody struct {
	components.AuthorizationWithUser
}

/*
AppsResetTokenResponse is a response for AppsResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenResponse struct {
	response
	request *AppsResetTokenReq
	Data    *AppsResetTokenResponseBody
}

/*
AppsRevokeAuthorizationForApplication performs requests for "apps/revoke-authorization-for-application"

Revoke an authorization for an application.

  DELETE /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
func (c *Client) AppsRevokeAuthorizationForApplication(ctx context.Context, req *AppsRevokeAuthorizationForApplicationReq, opt ...RequestOption) (*AppsRevokeAuthorizationForApplicationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsRevokeAuthorizationForApplicationResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsRevokeAuthorizationForApplicationReq is request data for Client.AppsRevokeAuthorizationForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
type AppsRevokeAuthorizationForApplicationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

func (r *AppsRevokeAuthorizationForApplicationReq) url() string {
	return r._url
}

func (r *AppsRevokeAuthorizationForApplicationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken)
}

func (r *AppsRevokeAuthorizationForApplicationReq) method() string {
	return "DELETE"
}

func (r *AppsRevokeAuthorizationForApplicationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsRevokeAuthorizationForApplicationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsRevokeAuthorizationForApplicationReq) body() interface{} {
	return nil
}

func (r *AppsRevokeAuthorizationForApplicationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsRevokeAuthorizationForApplicationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsRevokeAuthorizationForApplicationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsRevokeAuthorizationForApplicationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsRevokeAuthorizationForApplicationReq) Rel(link RelName, resp *AppsRevokeAuthorizationForApplicationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsRevokeAuthorizationForApplicationResponse is a response for AppsRevokeAuthorizationForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
type AppsRevokeAuthorizationForApplicationResponse struct {
	response
	request *AppsRevokeAuthorizationForApplicationReq
}

/*
AppsRevokeGrantForApplication performs requests for "apps/revoke-grant-for-application"

Revoke a grant for an application.

  DELETE /applications/{client_id}/grants/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
func (c *Client) AppsRevokeGrantForApplication(ctx context.Context, req *AppsRevokeGrantForApplicationReq, opt ...RequestOption) (*AppsRevokeGrantForApplicationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsRevokeGrantForApplicationResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsRevokeGrantForApplicationReq is request data for Client.AppsRevokeGrantForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
type AppsRevokeGrantForApplicationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

func (r *AppsRevokeGrantForApplicationReq) url() string {
	return r._url
}

func (r *AppsRevokeGrantForApplicationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/grants/%v", r.ClientId, r.AccessToken)
}

func (r *AppsRevokeGrantForApplicationReq) method() string {
	return "DELETE"
}

func (r *AppsRevokeGrantForApplicationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsRevokeGrantForApplicationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsRevokeGrantForApplicationReq) body() interface{} {
	return nil
}

func (r *AppsRevokeGrantForApplicationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsRevokeGrantForApplicationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsRevokeGrantForApplicationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsRevokeGrantForApplicationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsRevokeGrantForApplicationReq) Rel(link RelName, resp *AppsRevokeGrantForApplicationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsRevokeGrantForApplicationResponse is a response for AppsRevokeGrantForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
type AppsRevokeGrantForApplicationResponse struct {
	response
	request *AppsRevokeGrantForApplicationReq
}

/*
AppsRevokeInstallationToken performs requests for "apps/revoke-installation-token"

Revoke an installation token.

  DELETE /installation/token

https://developer.github.com/v3/apps/installations/#revoke-an-installation-token
*/
func (c *Client) AppsRevokeInstallationToken(ctx context.Context, req *AppsRevokeInstallationTokenReq, opt ...RequestOption) (*AppsRevokeInstallationTokenResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsRevokeInstallationTokenResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsRevokeInstallationTokenReq is request data for Client.AppsRevokeInstallationToken

https://developer.github.com/v3/apps/installations/#revoke-an-installation-token
*/
type AppsRevokeInstallationTokenReq struct {
	_url string
}

func (r *AppsRevokeInstallationTokenReq) url() string {
	return r._url
}

func (r *AppsRevokeInstallationTokenReq) urlPath() string {
	return fmt.Sprintf("/installation/token")
}

func (r *AppsRevokeInstallationTokenReq) method() string {
	return "DELETE"
}

func (r *AppsRevokeInstallationTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsRevokeInstallationTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsRevokeInstallationTokenReq) body() interface{} {
	return nil
}

func (r *AppsRevokeInstallationTokenReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsRevokeInstallationTokenReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsRevokeInstallationTokenReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsRevokeInstallationTokenReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsRevokeInstallationTokenReq) Rel(link RelName, resp *AppsRevokeInstallationTokenResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsRevokeInstallationTokenResponse is a response for AppsRevokeInstallationToken

https://developer.github.com/v3/apps/installations/#revoke-an-installation-token
*/
type AppsRevokeInstallationTokenResponse struct {
	response
	request *AppsRevokeInstallationTokenReq
}

/*
AppsSuspendInstallation performs requests for "apps/suspend-installation"

Suspend an installation.

  PUT /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#suspend-an-installation
*/
func (c *Client) AppsSuspendInstallation(ctx context.Context, req *AppsSuspendInstallationReq, opt ...RequestOption) (*AppsSuspendInstallationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsSuspendInstallationResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsSuspendInstallationReq is request data for Client.AppsSuspendInstallation

https://developer.github.com/v3/apps/#suspend-an-installation
*/
type AppsSuspendInstallationReq struct {
	_url           string
	InstallationId int64
}

func (r *AppsSuspendInstallationReq) url() string {
	return r._url
}

func (r *AppsSuspendInstallationReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId)
}

func (r *AppsSuspendInstallationReq) method() string {
	return "PUT"
}

func (r *AppsSuspendInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsSuspendInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsSuspendInstallationReq) body() interface{} {
	return nil
}

func (r *AppsSuspendInstallationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsSuspendInstallationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsSuspendInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsSuspendInstallationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsSuspendInstallationReq) Rel(link RelName, resp *AppsSuspendInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsSuspendInstallationResponse is a response for AppsSuspendInstallation

https://developer.github.com/v3/apps/#suspend-an-installation
*/
type AppsSuspendInstallationResponse struct {
	response
	request *AppsSuspendInstallationReq
}

/*
AppsUnsuspendInstallation performs requests for "apps/unsuspend-installation"

Unsuspend an installation.

  DELETE /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#unsuspend-an-installation
*/
func (c *Client) AppsUnsuspendInstallation(ctx context.Context, req *AppsUnsuspendInstallationReq, opt ...RequestOption) (*AppsUnsuspendInstallationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &AppsUnsuspendInstallationResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsUnsuspendInstallationReq is request data for Client.AppsUnsuspendInstallation

https://developer.github.com/v3/apps/#unsuspend-an-installation
*/
type AppsUnsuspendInstallationReq struct {
	_url           string
	InstallationId int64
}

func (r *AppsUnsuspendInstallationReq) url() string {
	return r._url
}

func (r *AppsUnsuspendInstallationReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId)
}

func (r *AppsUnsuspendInstallationReq) method() string {
	return "DELETE"
}

func (r *AppsUnsuspendInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsUnsuspendInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsUnsuspendInstallationReq) body() interface{} {
	return nil
}

func (r *AppsUnsuspendInstallationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsUnsuspendInstallationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsUnsuspendInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *AppsUnsuspendInstallationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsUnsuspendInstallationReq) Rel(link RelName, resp *AppsUnsuspendInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsUnsuspendInstallationResponse is a response for AppsUnsuspendInstallation

https://developer.github.com/v3/apps/#unsuspend-an-installation
*/
type AppsUnsuspendInstallationResponse struct {
	response
	request *AppsUnsuspendInstallationReq
}
