// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
AppsAddRepoToInstallationReq builds requests for "apps/add-repo-to-installation"

Add repository to installation.

  PUT /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#add-repository-to-installation
*/
type AppsAddRepoToInstallationReq struct {
	InstallationId int64
	RepositoryId   int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsAddRepoToInstallationReq) urlPath() string {
	return fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId)
}

func (r *AppsAddRepoToInstallationReq) method() string {
	return "PUT"
}

func (r *AppsAddRepoToInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsAddRepoToInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsAddRepoToInstallationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsAddRepoToInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsCheckAuthorizationReq builds requests for "apps/check-authorization"

Check an authorization.

  GET /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type AppsCheckAuthorizationReq struct {
	ClientId    string
	AccessToken string
}

func (r *AppsCheckAuthorizationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken)
}

func (r *AppsCheckAuthorizationReq) method() string {
	return "GET"
}

func (r *AppsCheckAuthorizationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCheckAuthorizationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCheckAuthorizationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsCheckAuthorizationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsCheckAuthorizationResponseBody200 is a response body for apps/check-authorization

API documentation: https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type AppsCheckAuthorizationResponseBody200 struct {
	components.AuthorizationWithUser
}

/*
AppsCheckTokenReq builds requests for "apps/check-token"

Check a token.

  POST /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenReq struct {
	ClientId    string
	RequestBody AppsCheckTokenReqBody
}

func (r *AppsCheckTokenReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/token", r.ClientId)
}

func (r *AppsCheckTokenReq) method() string {
	return "POST"
}

func (r *AppsCheckTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCheckTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCheckTokenReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *AppsCheckTokenReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsCheckTokenReqBody is a request body for apps/check-token

API documentation: https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsCheckTokenResponseBody200 is a response body for apps/check-token

API documentation: https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenResponseBody200 struct {
	components.AuthorizationWithUser
}

/*
AppsCreateContentAttachmentReq builds requests for "apps/create-content-attachment"

Create a content attachment.

  POST /content_references/{content_reference_id}/attachments

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentReq struct {
	ContentReferenceId int64
	RequestBody        AppsCreateContentAttachmentReqBody

	/*
	To access the Content Attachments API during the preview period, you must set
	this to true.
	*/
	CorsairPreview bool
}

func (r *AppsCreateContentAttachmentReq) urlPath() string {
	return fmt.Sprintf("/content_references/%v/attachments", r.ContentReferenceId)
}

func (r *AppsCreateContentAttachmentReq) method() string {
	return "POST"
}

func (r *AppsCreateContentAttachmentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCreateContentAttachmentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"corsair": r.CorsairPreview}
	if requiredPreviews {
		previewVals["corsair"] = true
	}
	if allPreviews {
		previewVals["corsair"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCreateContentAttachmentReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *AppsCreateContentAttachmentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsCreateContentAttachmentReqBody is a request body for apps/create-content-attachment

API documentation: https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentReqBody struct {

	/*
	   The body text of the content attachment displayed in the body or comment of an
	   issue or pull request. This parameter supports markdown.
	*/
	Body *string `json:"body"`

	/*
	   The title of the content attachment displayed in the body or comment of an issue
	   or pull request.
	*/
	Title *string `json:"title"`
}

/*
AppsCreateContentAttachmentResponseBody200 is a response body for apps/create-content-attachment

API documentation: https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentResponseBody200 struct {
	components.ContentReferenceAttachment
}

/*
AppsCreateFromManifestReq builds requests for "apps/create-from-manifest"

Create a GitHub App from a manifest.

  POST /app-manifests/{code}/conversions

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type AppsCreateFromManifestReq struct {
	Code string
}

func (r *AppsCreateFromManifestReq) urlPath() string {
	return fmt.Sprintf("/app-manifests/%v/conversions", r.Code)
}

func (r *AppsCreateFromManifestReq) method() string {
	return "POST"
}

func (r *AppsCreateFromManifestReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCreateFromManifestReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCreateFromManifestReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsCreateFromManifestReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsCreateFromManifestResponseBody200 is a response body for apps/create-from-manifest

API documentation: https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type AppsCreateFromManifestResponseBody200 struct {
	components.IntegrationFromManifest
}

/*
AppsCreateInstallationTokenReq builds requests for "apps/create-installation-token"

Create a new installation token.

  POST /app/installations/{installation_id}/access_tokens

https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
type AppsCreateInstallationTokenReq struct {
	InstallationId int64
	RequestBody    AppsCreateInstallationTokenReqBody

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsCreateInstallationTokenReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v/access_tokens", r.InstallationId)
}

func (r *AppsCreateInstallationTokenReq) method() string {
	return "POST"
}

func (r *AppsCreateInstallationTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCreateInstallationTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCreateInstallationTokenReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *AppsCreateInstallationTokenReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsCreateInstallationTokenReqBody is a request body for apps/create-installation-token

API documentation: https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
type AppsCreateInstallationTokenReqBody struct {

	/*
	   The permissions granted to the access token. The permissions object includes the
	   permission names and their access type. For a complete list of permissions and
	   allowable values, see "[GitHub App
	   permissions](https://developer.github.com/apps/building-github-apps/creating-github-apps-using-url-parameters/#github-app-permissions)."
	*/
	Permissions interface{} `json:"permissions,omitempty"`

	/*
	   The `id`s of the repositories that the installation token can access. Providing
	   repository `id`s restricts the access of an installation token to specific
	   repositories. You can use the "[List
	   repositories](https://developer.github.com/v3/apps/installations/#list-repositories)"
	   endpoint to get the `id` of all repositories that an installation can access.
	   For example, you can select specific repositories when creating an installation
	   token to restrict the number of repositories that can be cloned using the token.
	*/
	RepositoryIds []int64 `json:"repository_ids,omitempty"`
}

/*
AppsCreateInstallationTokenResponseBody201 is a response body for apps/create-installation-token

API documentation: https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
type AppsCreateInstallationTokenResponseBody201 struct {
	components.InstallationToken
}

/*
AppsDeleteAuthorizationReq builds requests for "apps/delete-authorization"

Delete an app authorization.

  DELETE /applications/{client_id}/grant

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type AppsDeleteAuthorizationReq struct {
	ClientId    string
	RequestBody AppsDeleteAuthorizationReqBody
}

func (r *AppsDeleteAuthorizationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/grant", r.ClientId)
}

func (r *AppsDeleteAuthorizationReq) method() string {
	return "DELETE"
}

func (r *AppsDeleteAuthorizationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsDeleteAuthorizationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsDeleteAuthorizationReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *AppsDeleteAuthorizationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsDeleteAuthorizationReqBody is a request body for apps/delete-authorization

API documentation: https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type AppsDeleteAuthorizationReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsDeleteInstallationReq builds requests for "apps/delete-installation"

Delete an installation.

  DELETE /app/installations/{installation_id}

https://developer.github.com/v3/apps/#delete-an-installation
*/
type AppsDeleteInstallationReq struct {
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsDeleteInstallationReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v", r.InstallationId)
}

func (r *AppsDeleteInstallationReq) method() string {
	return "DELETE"
}

func (r *AppsDeleteInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsDeleteInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsDeleteInstallationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsDeleteInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsDeleteTokenReq builds requests for "apps/delete-token"

Delete an app token.

  DELETE /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type AppsDeleteTokenReq struct {
	ClientId    string
	RequestBody AppsDeleteTokenReqBody
}

func (r *AppsDeleteTokenReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/token", r.ClientId)
}

func (r *AppsDeleteTokenReq) method() string {
	return "DELETE"
}

func (r *AppsDeleteTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsDeleteTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsDeleteTokenReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *AppsDeleteTokenReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsDeleteTokenReqBody is a request body for apps/delete-token

API documentation: https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type AppsDeleteTokenReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsGetAuthenticatedReq builds requests for "apps/get-authenticated"

Get the authenticated GitHub App.

  GET /app

https://developer.github.com/v3/apps/#get-the-authenticated-github-app
*/
type AppsGetAuthenticatedReq struct {

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/app")
}

func (r *AppsGetAuthenticatedReq) method() string {
	return "GET"
}

func (r *AppsGetAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetAuthenticatedReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsGetAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsGetAuthenticatedResponseBody200 is a response body for apps/get-authenticated

API documentation: https://developer.github.com/v3/apps/#get-the-authenticated-github-app
*/
type AppsGetAuthenticatedResponseBody200 struct {
	components.Integration
}

/*
AppsGetBySlugReq builds requests for "apps/get-by-slug"

Get a single GitHub App.

  GET /apps/{app_slug}

https://developer.github.com/v3/apps/#get-a-single-github-app
*/
type AppsGetBySlugReq struct {
	AppSlug string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetBySlugReq) urlPath() string {
	return fmt.Sprintf("/apps/%v", r.AppSlug)
}

func (r *AppsGetBySlugReq) method() string {
	return "GET"
}

func (r *AppsGetBySlugReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetBySlugReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetBySlugReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsGetBySlugReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsGetBySlugResponseBody200 is a response body for apps/get-by-slug

API documentation: https://developer.github.com/v3/apps/#get-a-single-github-app
*/
type AppsGetBySlugResponseBody200 struct {
	components.Integration2
}

/*
AppsGetInstallationReq builds requests for "apps/get-installation"

Get an installation.

  GET /app/installations/{installation_id}

https://developer.github.com/v3/apps/#get-an-installation
*/
type AppsGetInstallationReq struct {
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetInstallationReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v", r.InstallationId)
}

func (r *AppsGetInstallationReq) method() string {
	return "GET"
}

func (r *AppsGetInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetInstallationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsGetInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsGetInstallationResponseBody200 is a response body for apps/get-installation

API documentation: https://developer.github.com/v3/apps/#get-an-installation
*/
type AppsGetInstallationResponseBody200 struct {
	components.BaseInstallation
}

/*
AppsGetOrgInstallationReq builds requests for "apps/get-org-installation"

Get an organization installation.

  GET /orgs/{org}/installation

https://developer.github.com/v3/apps/#get-an-organization-installation
*/
type AppsGetOrgInstallationReq struct {
	Org string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetOrgInstallationReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/installation", r.Org)
}

func (r *AppsGetOrgInstallationReq) method() string {
	return "GET"
}

func (r *AppsGetOrgInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetOrgInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetOrgInstallationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsGetOrgInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsGetOrgInstallationResponseBody200 is a response body for apps/get-org-installation

API documentation: https://developer.github.com/v3/apps/#get-an-organization-installation
*/
type AppsGetOrgInstallationResponseBody200 struct {
	components.Installation
}

/*
AppsGetRepoInstallationReq builds requests for "apps/get-repo-installation"

Get a repository installation.

  GET /repos/{owner}/{repo}/installation

https://developer.github.com/v3/apps/#get-a-repository-installation
*/
type AppsGetRepoInstallationReq struct {
	Owner string
	Repo  string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetRepoInstallationReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/installation", r.Owner, r.Repo)
}

func (r *AppsGetRepoInstallationReq) method() string {
	return "GET"
}

func (r *AppsGetRepoInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetRepoInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetRepoInstallationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsGetRepoInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsGetRepoInstallationResponseBody200 is a response body for apps/get-repo-installation

API documentation: https://developer.github.com/v3/apps/#get-a-repository-installation
*/
type AppsGetRepoInstallationResponseBody200 struct {
	components.Installation
}

/*
AppsGetSubscriptionPlanForAccountReq builds requests for "apps/get-subscription-plan-for-account"

Get a subscription plan for an account.

  GET /marketplace_listing/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type AppsGetSubscriptionPlanForAccountReq struct {
	AccountId int64
}

func (r *AppsGetSubscriptionPlanForAccountReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/accounts/%v", r.AccountId)
}

func (r *AppsGetSubscriptionPlanForAccountReq) method() string {
	return "GET"
}

func (r *AppsGetSubscriptionPlanForAccountReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetSubscriptionPlanForAccountReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetSubscriptionPlanForAccountReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsGetSubscriptionPlanForAccountReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsGetSubscriptionPlanForAccountResponseBody200 is a response body for apps/get-subscription-plan-for-account

API documentation: https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type AppsGetSubscriptionPlanForAccountResponseBody200 struct {
	components.MarketplacePurchase
}

/*
AppsGetSubscriptionPlanForAccountStubbedReq builds requests for "apps/get-subscription-plan-for-account-stubbed"

Get a subscription plan for an account (stubbed).

  GET /marketplace_listing/stubbed/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type AppsGetSubscriptionPlanForAccountStubbedReq struct {
	AccountId int64
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/stubbed/accounts/%v", r.AccountId)
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) method() string {
	return "GET"
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsGetSubscriptionPlanForAccountStubbedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsGetSubscriptionPlanForAccountStubbedResponseBody200 is a response body for apps/get-subscription-plan-for-account-stubbed

API documentation: https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type AppsGetSubscriptionPlanForAccountStubbedResponseBody200 struct {
	components.MarketplacePurchase
}

/*
AppsGetUserInstallationReq builds requests for "apps/get-user-installation"

Get a user installation.

  GET /users/{username}/installation

https://developer.github.com/v3/apps/#get-a-user-installation
*/
type AppsGetUserInstallationReq struct {
	Username string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetUserInstallationReq) urlPath() string {
	return fmt.Sprintf("/users/%v/installation", r.Username)
}

func (r *AppsGetUserInstallationReq) method() string {
	return "GET"
}

func (r *AppsGetUserInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetUserInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetUserInstallationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsGetUserInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsGetUserInstallationResponseBody200 is a response body for apps/get-user-installation

API documentation: https://developer.github.com/v3/apps/#get-a-user-installation
*/
type AppsGetUserInstallationResponseBody200 struct {
	components.Installation2
}

/*
AppsListAccountsForPlanReq builds requests for "apps/list-accounts-for-plan"

List accounts for a plan.

  GET /marketplace_listing/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type AppsListAccountsForPlanReq struct {
	PlanId int64

	/*
	Sorts the GitHub accounts by the date they were created or last updated. Can be
	one of `created` or `updated`.
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListAccountsForPlanReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/plans/%v/accounts", r.PlanId)
}

func (r *AppsListAccountsForPlanReq) method() string {
	return "GET"
}

func (r *AppsListAccountsForPlanReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListAccountsForPlanReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListAccountsForPlanReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsListAccountsForPlanReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsListAccountsForPlanResponseBody200 is a response body for apps/list-accounts-for-plan

API documentation: https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type AppsListAccountsForPlanResponseBody200 []struct {
	components.MarketplacePurchase
}

/*
AppsListAccountsForPlanStubbedReq builds requests for "apps/list-accounts-for-plan-stubbed"

List accounts for a plan (stubbed).

  GET /marketplace_listing/stubbed/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type AppsListAccountsForPlanStubbedReq struct {
	PlanId int64

	/*
	Sorts the GitHub accounts by the date they were created or last updated. Can be
	one of `created` or `updated`.
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListAccountsForPlanStubbedReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/stubbed/plans/%v/accounts", r.PlanId)
}

func (r *AppsListAccountsForPlanStubbedReq) method() string {
	return "GET"
}

func (r *AppsListAccountsForPlanStubbedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListAccountsForPlanStubbedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListAccountsForPlanStubbedReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsListAccountsForPlanStubbedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsListAccountsForPlanStubbedResponseBody200 is a response body for apps/list-accounts-for-plan-stubbed

API documentation: https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type AppsListAccountsForPlanStubbedResponseBody200 []struct {
	components.MarketplacePurchase
}

/*
AppsListInstallationReposForAuthenticatedUserReq builds requests for "apps/list-installation-repos-for-authenticated-user"

List repositories accessible to the user for an installation.

  GET /user/installations/{installation_id}/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-for-an-installation
*/
type AppsListInstallationReposForAuthenticatedUserReq struct {
	InstallationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/installations/%v/repositories", r.InstallationId)
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man": r.MachineManPreview,
		"mercy":       r.MercyPreview,
	}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["mercy"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsListInstallationReposForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsListInstallationReposForAuthenticatedUserResponseBody200 is a response body for apps/list-installation-repos-for-authenticated-user

API documentation: https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-for-an-installation
*/
type AppsListInstallationReposForAuthenticatedUserResponseBody200 struct {
	Repositories []struct {
		components.Repository
	} `json:"repositories,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
AppsListInstallationsReq builds requests for "apps/list-installations"

List installations.

  GET /app/installations

https://developer.github.com/v3/apps/#list-installations
*/
type AppsListInstallationsReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsListInstallationsReq) urlPath() string {
	return fmt.Sprintf("/app/installations")
}

func (r *AppsListInstallationsReq) method() string {
	return "GET"
}

func (r *AppsListInstallationsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListInstallationsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListInstallationsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsListInstallationsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsListInstallationsResponseBody200 is a response body for apps/list-installations

API documentation: https://developer.github.com/v3/apps/#list-installations
*/
type AppsListInstallationsResponseBody200 []struct {
	components.BaseInstallation
}

/*
AppsListInstallationsForAuthenticatedUserReq builds requests for "apps/list-installations-for-authenticated-user"

List installations for a user.

  GET /user/installations

https://developer.github.com/v3/apps/installations/#list-installations-for-a-user
*/
type AppsListInstallationsForAuthenticatedUserReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsListInstallationsForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/installations")
}

func (r *AppsListInstallationsForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *AppsListInstallationsForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListInstallationsForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListInstallationsForAuthenticatedUserReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsListInstallationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsListInstallationsForAuthenticatedUserResponseBody200 is a response body for apps/list-installations-for-authenticated-user

API documentation: https://developer.github.com/v3/apps/installations/#list-installations-for-a-user
*/
type AppsListInstallationsForAuthenticatedUserResponseBody200 struct {
	Installations []struct {
		components.BaseInstallationForAuthUser
	} `json:"installations,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
AppsListPlansReq builds requests for "apps/list-plans"

List plans.

  GET /marketplace_listing/plans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type AppsListPlansReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListPlansReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/plans")
}

func (r *AppsListPlansReq) method() string {
	return "GET"
}

func (r *AppsListPlansReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListPlansReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListPlansReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsListPlansReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsListPlansResponseBody200 is a response body for apps/list-plans

API documentation: https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type AppsListPlansResponseBody200 []struct {
	components.MarketplaceListingPlan
}

/*
AppsListPlansStubbedReq builds requests for "apps/list-plans-stubbed"

List plans (stubbed).

  GET /marketplace_listing/stubbed/plans

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type AppsListPlansStubbedReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListPlansStubbedReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/stubbed/plans")
}

func (r *AppsListPlansStubbedReq) method() string {
	return "GET"
}

func (r *AppsListPlansStubbedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListPlansStubbedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListPlansStubbedReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsListPlansStubbedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsListPlansStubbedResponseBody200 is a response body for apps/list-plans-stubbed

API documentation: https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type AppsListPlansStubbedResponseBody200 []struct {
	components.MarketplaceListingPlan
}

/*
AppsListReposReq builds requests for "apps/list-repos"

List repositories.

  GET /installation/repositories

https://developer.github.com/v3/apps/installations/#list-repositories
*/
type AppsListReposReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

func (r *AppsListReposReq) urlPath() string {
	return fmt.Sprintf("/installation/repositories")
}

func (r *AppsListReposReq) method() string {
	return "GET"
}

func (r *AppsListReposReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListReposReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man": r.MachineManPreview,
		"mercy":       r.MercyPreview,
	}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["mercy"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListReposReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsListReposReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsListReposResponseBody200 is a response body for apps/list-repos

API documentation: https://developer.github.com/v3/apps/installations/#list-repositories
*/
type AppsListReposResponseBody200 struct {
	Repositories []struct {
		components.Repository2
	} `json:"repositories,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
AppsListSubscriptionsForAuthenticatedUserReq builds requests for "apps/list-subscriptions-for-authenticated-user"

List subscriptions for the authenticated user.

  GET /user/marketplace_purchases

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type AppsListSubscriptionsForAuthenticatedUserReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/marketplace_purchases")
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsListSubscriptionsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsListSubscriptionsForAuthenticatedUserResponseBody200 is a response body for apps/list-subscriptions-for-authenticated-user

API documentation: https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type AppsListSubscriptionsForAuthenticatedUserResponseBody200 []struct {
	components.UserMarketplacePurchase
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbedReq builds requests for "apps/list-subscriptions-for-authenticated-user-stubbed"

List subscriptions for the authenticated user (stubbed).

  GET /user/marketplace_purchases/stubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type AppsListSubscriptionsForAuthenticatedUserStubbedReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) urlPath() string {
	return fmt.Sprintf("/user/marketplace_purchases/stubbed")
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) method() string {
	return "GET"
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbedResponseBody200 is a response body for apps/list-subscriptions-for-authenticated-user-stubbed

API documentation: https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type AppsListSubscriptionsForAuthenticatedUserStubbedResponseBody200 []struct {
	components.UserMarketplacePurchase
}

/*
AppsRemoveRepoFromInstallationReq builds requests for "apps/remove-repo-from-installation"

Remove repository from installation.

  DELETE /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#remove-repository-from-installation
*/
type AppsRemoveRepoFromInstallationReq struct {
	InstallationId int64
	RepositoryId   int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsRemoveRepoFromInstallationReq) urlPath() string {
	return fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId)
}

func (r *AppsRemoveRepoFromInstallationReq) method() string {
	return "DELETE"
}

func (r *AppsRemoveRepoFromInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsRemoveRepoFromInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsRemoveRepoFromInstallationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsRemoveRepoFromInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsResetAuthorizationReq builds requests for "apps/reset-authorization"

Reset an authorization.

  POST /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type AppsResetAuthorizationReq struct {
	ClientId    string
	AccessToken string
}

func (r *AppsResetAuthorizationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken)
}

func (r *AppsResetAuthorizationReq) method() string {
	return "POST"
}

func (r *AppsResetAuthorizationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsResetAuthorizationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsResetAuthorizationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsResetAuthorizationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsResetAuthorizationResponseBody200 is a response body for apps/reset-authorization

API documentation: https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type AppsResetAuthorizationResponseBody200 struct {
	components.AuthorizationWithUser
}

/*
AppsResetTokenReq builds requests for "apps/reset-token"

Reset a token.

  PATCH /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenReq struct {
	ClientId    string
	RequestBody AppsResetTokenReqBody
}

func (r *AppsResetTokenReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/token", r.ClientId)
}

func (r *AppsResetTokenReq) method() string {
	return "PATCH"
}

func (r *AppsResetTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsResetTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsResetTokenReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *AppsResetTokenReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsResetTokenReqBody is a request body for apps/reset-token

API documentation: https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsResetTokenResponseBody200 is a response body for apps/reset-token

API documentation: https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenResponseBody200 struct {
	components.AuthorizationWithUser
}

/*
AppsRevokeAuthorizationForApplicationReq builds requests for "apps/revoke-authorization-for-application"

Revoke an authorization for an application.

  DELETE /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
type AppsRevokeAuthorizationForApplicationReq struct {
	ClientId    string
	AccessToken string
}

func (r *AppsRevokeAuthorizationForApplicationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken)
}

func (r *AppsRevokeAuthorizationForApplicationReq) method() string {
	return "DELETE"
}

func (r *AppsRevokeAuthorizationForApplicationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsRevokeAuthorizationForApplicationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsRevokeAuthorizationForApplicationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsRevokeAuthorizationForApplicationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsRevokeGrantForApplicationReq builds requests for "apps/revoke-grant-for-application"

Revoke a grant for an application.

  DELETE /applications/{client_id}/grants/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
type AppsRevokeGrantForApplicationReq struct {
	ClientId    string
	AccessToken string
}

func (r *AppsRevokeGrantForApplicationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/grants/%v", r.ClientId, r.AccessToken)
}

func (r *AppsRevokeGrantForApplicationReq) method() string {
	return "DELETE"
}

func (r *AppsRevokeGrantForApplicationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsRevokeGrantForApplicationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsRevokeGrantForApplicationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsRevokeGrantForApplicationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsRevokeInstallationTokenReq builds requests for "apps/revoke-installation-token"

Revoke an installation token.

  DELETE /installation/token

https://developer.github.com/v3/apps/installations/#revoke-an-installation-token
*/
type AppsRevokeInstallationTokenReq struct{}

func (r *AppsRevokeInstallationTokenReq) urlPath() string {
	return fmt.Sprintf("/installation/token")
}

func (r *AppsRevokeInstallationTokenReq) method() string {
	return "DELETE"
}

func (r *AppsRevokeInstallationTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsRevokeInstallationTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsRevokeInstallationTokenReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsRevokeInstallationTokenReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsSuspendInstallationReq builds requests for "apps/suspend-installation"

Suspend an installation.

  PUT /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#suspend-an-installation
*/
type AppsSuspendInstallationReq struct {
	InstallationId int64
}

func (r *AppsSuspendInstallationReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId)
}

func (r *AppsSuspendInstallationReq) method() string {
	return "PUT"
}

func (r *AppsSuspendInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsSuspendInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsSuspendInstallationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsSuspendInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
AppsUnsuspendInstallationReq builds requests for "apps/unsuspend-installation"

Unsuspend an installation.

  DELETE /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#unsuspend-an-installation
*/
type AppsUnsuspendInstallationReq struct {
	InstallationId int64
}

func (r *AppsUnsuspendInstallationReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId)
}

func (r *AppsUnsuspendInstallationReq) method() string {
	return "DELETE"
}

func (r *AppsUnsuspendInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsUnsuspendInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsUnsuspendInstallationReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *AppsUnsuspendInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}
