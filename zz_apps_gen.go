// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
AppsAddRepoToInstallation performs requests for "apps/add-repo-to-installation"

Add repository to installation.

  PUT /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#add-repository-to-installation
*/
func AppsAddRepoToInstallation(ctx context.Context, req *AppsAddRepoToInstallationReq, opt ...RequestOption) (*AppsAddRepoToInstallationResponse, error) {
	if req == nil {
		req = new(AppsAddRepoToInstallationReq)
	}
	resp := &AppsAddRepoToInstallationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsAddRepoToInstallation performs requests for "apps/add-repo-to-installation"

Add repository to installation.

  PUT /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#add-repository-to-installation
*/
func (c Client) AppsAddRepoToInstallation(ctx context.Context, req *AppsAddRepoToInstallationReq, opt ...RequestOption) (*AppsAddRepoToInstallationResponse, error) {
	return AppsAddRepoToInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsAddRepoToInstallationReq is request data for Client.AppsAddRepoToInstallation

https://developer.github.com/v3/apps/installations/#add-repository-to-installation
*/
type AppsAddRepoToInstallationReq struct {
	_url           string
	InstallationId int64
	RepositoryId   int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsAddRepoToInstallationReq) url() string {
	return r._url
}

func (r *AppsAddRepoToInstallationReq) urlPath() string {
	return fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId)
}

func (r *AppsAddRepoToInstallationReq) method() string {
	return "PUT"
}

func (r *AppsAddRepoToInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsAddRepoToInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsAddRepoToInstallationReq) body() interface{} {
	return nil
}

func (r *AppsAddRepoToInstallationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsAddRepoToInstallationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsAddRepoToInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsAddRepoToInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsAddRepoToInstallationReq) Rel(link RelName, resp *AppsAddRepoToInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsAddRepoToInstallationResponse is a response for AppsAddRepoToInstallation

https://developer.github.com/v3/apps/installations/#add-repository-to-installation
*/
type AppsAddRepoToInstallationResponse struct {
	response
	request *AppsAddRepoToInstallationReq
}

/*
AppsCheckAuthorization performs requests for "apps/check-authorization"

Check an authorization.

  GET /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
func AppsCheckAuthorization(ctx context.Context, req *AppsCheckAuthorizationReq, opt ...RequestOption) (*AppsCheckAuthorizationResponse, error) {
	if req == nil {
		req = new(AppsCheckAuthorizationReq)
	}
	resp := &AppsCheckAuthorizationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsCheckAuthorizationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCheckAuthorization performs requests for "apps/check-authorization"

Check an authorization.

  GET /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
func (c Client) AppsCheckAuthorization(ctx context.Context, req *AppsCheckAuthorizationReq, opt ...RequestOption) (*AppsCheckAuthorizationResponse, error) {
	return AppsCheckAuthorization(ctx, req, append(c, opt...)...)
}

/*
AppsCheckAuthorizationReq is request data for Client.AppsCheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type AppsCheckAuthorizationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

func (r *AppsCheckAuthorizationReq) url() string {
	return r._url
}

func (r *AppsCheckAuthorizationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken)
}

func (r *AppsCheckAuthorizationReq) method() string {
	return "GET"
}

func (r *AppsCheckAuthorizationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCheckAuthorizationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCheckAuthorizationReq) body() interface{} {
	return nil
}

func (r *AppsCheckAuthorizationReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsCheckAuthorizationReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsCheckAuthorizationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsCheckAuthorizationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCheckAuthorizationReq) Rel(link RelName, resp *AppsCheckAuthorizationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCheckAuthorizationResponseBody is a response body for AppsCheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type AppsCheckAuthorizationResponseBody struct {
	components.AuthorizationWithUser
}

/*
AppsCheckAuthorizationResponse is a response for AppsCheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type AppsCheckAuthorizationResponse struct {
	response
	request *AppsCheckAuthorizationReq
	Data    *AppsCheckAuthorizationResponseBody
}

/*
AppsCheckToken performs requests for "apps/check-token"

Check a token.

  POST /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
func AppsCheckToken(ctx context.Context, req *AppsCheckTokenReq, opt ...RequestOption) (*AppsCheckTokenResponse, error) {
	if req == nil {
		req = new(AppsCheckTokenReq)
	}
	resp := &AppsCheckTokenResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsCheckTokenResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCheckToken performs requests for "apps/check-token"

Check a token.

  POST /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
func (c Client) AppsCheckToken(ctx context.Context, req *AppsCheckTokenReq, opt ...RequestOption) (*AppsCheckTokenResponse, error) {
	return AppsCheckToken(ctx, req, append(c, opt...)...)
}

/*
AppsCheckTokenReq is request data for Client.AppsCheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenReq struct {
	_url        string
	ClientId    string
	RequestBody AppsCheckTokenReqBody
}

func (r *AppsCheckTokenReq) url() string {
	return r._url
}

func (r *AppsCheckTokenReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/token", r.ClientId)
}

func (r *AppsCheckTokenReq) method() string {
	return "POST"
}

func (r *AppsCheckTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCheckTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCheckTokenReq) body() interface{} {
	return r.RequestBody
}

func (r *AppsCheckTokenReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsCheckTokenReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsCheckTokenReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *AppsCheckTokenReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCheckTokenReq) Rel(link RelName, resp *AppsCheckTokenResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCheckTokenReqBody is a request body for apps/check-token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsCheckTokenResponseBody is a response body for AppsCheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenResponseBody struct {
	components.AuthorizationWithUser
}

/*
AppsCheckTokenResponse is a response for AppsCheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type AppsCheckTokenResponse struct {
	response
	request *AppsCheckTokenReq
	Data    *AppsCheckTokenResponseBody
}

/*
AppsCreateContentAttachment performs requests for "apps/create-content-attachment"

Create a content attachment.

  POST /content_references/{content_reference_id}/attachments

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
func AppsCreateContentAttachment(ctx context.Context, req *AppsCreateContentAttachmentReq, opt ...RequestOption) (*AppsCreateContentAttachmentResponse, error) {
	if req == nil {
		req = new(AppsCreateContentAttachmentReq)
	}
	resp := &AppsCreateContentAttachmentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsCreateContentAttachmentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCreateContentAttachment performs requests for "apps/create-content-attachment"

Create a content attachment.

  POST /content_references/{content_reference_id}/attachments

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
func (c Client) AppsCreateContentAttachment(ctx context.Context, req *AppsCreateContentAttachmentReq, opt ...RequestOption) (*AppsCreateContentAttachmentResponse, error) {
	return AppsCreateContentAttachment(ctx, req, append(c, opt...)...)
}

/*
AppsCreateContentAttachmentReq is request data for Client.AppsCreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentReq struct {
	_url               string
	ContentReferenceId int64
	RequestBody        AppsCreateContentAttachmentReqBody

	/*
	To access the Content Attachments API during the preview period, you must set
	this to true.
	*/
	CorsairPreview bool
}

func (r *AppsCreateContentAttachmentReq) url() string {
	return r._url
}

func (r *AppsCreateContentAttachmentReq) urlPath() string {
	return fmt.Sprintf("/content_references/%v/attachments", r.ContentReferenceId)
}

func (r *AppsCreateContentAttachmentReq) method() string {
	return "POST"
}

func (r *AppsCreateContentAttachmentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCreateContentAttachmentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"corsair": r.CorsairPreview}
	if requiredPreviews {
		previewVals["corsair"] = true
	}
	if allPreviews {
		previewVals["corsair"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCreateContentAttachmentReq) body() interface{} {
	return r.RequestBody
}

func (r *AppsCreateContentAttachmentReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsCreateContentAttachmentReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsCreateContentAttachmentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *AppsCreateContentAttachmentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCreateContentAttachmentReq) Rel(link RelName, resp *AppsCreateContentAttachmentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCreateContentAttachmentReqBody is a request body for apps/create-content-attachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentReqBody struct {

	/*
	   The body text of the content attachment displayed in the body or comment of an
	   issue or pull request. This parameter supports markdown.
	*/
	Body *string `json:"body"`

	/*
	   The title of the content attachment displayed in the body or comment of an issue
	   or pull request.
	*/
	Title *string `json:"title"`
}

/*
AppsCreateContentAttachmentResponseBody is a response body for AppsCreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentResponseBody struct {
	components.ContentReferenceAttachment
}

/*
AppsCreateContentAttachmentResponse is a response for AppsCreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type AppsCreateContentAttachmentResponse struct {
	response
	request *AppsCreateContentAttachmentReq
	Data    *AppsCreateContentAttachmentResponseBody
}

/*
AppsCreateFromManifest performs requests for "apps/create-from-manifest"

Create a GitHub App from a manifest.

  POST /app-manifests/{code}/conversions

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
func AppsCreateFromManifest(ctx context.Context, req *AppsCreateFromManifestReq, opt ...RequestOption) (*AppsCreateFromManifestResponse, error) {
	if req == nil {
		req = new(AppsCreateFromManifestReq)
	}
	resp := &AppsCreateFromManifestResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsCreateFromManifestResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCreateFromManifest performs requests for "apps/create-from-manifest"

Create a GitHub App from a manifest.

  POST /app-manifests/{code}/conversions

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
func (c Client) AppsCreateFromManifest(ctx context.Context, req *AppsCreateFromManifestReq, opt ...RequestOption) (*AppsCreateFromManifestResponse, error) {
	return AppsCreateFromManifest(ctx, req, append(c, opt...)...)
}

/*
AppsCreateFromManifestReq is request data for Client.AppsCreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type AppsCreateFromManifestReq struct {
	_url string
	Code string
}

func (r *AppsCreateFromManifestReq) url() string {
	return r._url
}

func (r *AppsCreateFromManifestReq) urlPath() string {
	return fmt.Sprintf("/app-manifests/%v/conversions", r.Code)
}

func (r *AppsCreateFromManifestReq) method() string {
	return "POST"
}

func (r *AppsCreateFromManifestReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCreateFromManifestReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCreateFromManifestReq) body() interface{} {
	return nil
}

func (r *AppsCreateFromManifestReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsCreateFromManifestReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsCreateFromManifestReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsCreateFromManifestReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCreateFromManifestReq) Rel(link RelName, resp *AppsCreateFromManifestResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCreateFromManifestResponseBody is a response body for AppsCreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type AppsCreateFromManifestResponseBody struct {
	components.IntegrationFromManifest
}

/*
AppsCreateFromManifestResponse is a response for AppsCreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type AppsCreateFromManifestResponse struct {
	response
	request *AppsCreateFromManifestReq
	Data    *AppsCreateFromManifestResponseBody
}

/*
AppsCreateInstallationToken performs requests for "apps/create-installation-token"

Create a new installation token.

  POST /app/installations/{installation_id}/access_tokens

https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
func AppsCreateInstallationToken(ctx context.Context, req *AppsCreateInstallationTokenReq, opt ...RequestOption) (*AppsCreateInstallationTokenResponse, error) {
	if req == nil {
		req = new(AppsCreateInstallationTokenReq)
	}
	resp := &AppsCreateInstallationTokenResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsCreateInstallationTokenResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsCreateInstallationToken performs requests for "apps/create-installation-token"

Create a new installation token.

  POST /app/installations/{installation_id}/access_tokens

https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
func (c Client) AppsCreateInstallationToken(ctx context.Context, req *AppsCreateInstallationTokenReq, opt ...RequestOption) (*AppsCreateInstallationTokenResponse, error) {
	return AppsCreateInstallationToken(ctx, req, append(c, opt...)...)
}

/*
AppsCreateInstallationTokenReq is request data for Client.AppsCreateInstallationToken

https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
type AppsCreateInstallationTokenReq struct {
	_url           string
	InstallationId int64
	RequestBody    AppsCreateInstallationTokenReqBody

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsCreateInstallationTokenReq) url() string {
	return r._url
}

func (r *AppsCreateInstallationTokenReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v/access_tokens", r.InstallationId)
}

func (r *AppsCreateInstallationTokenReq) method() string {
	return "POST"
}

func (r *AppsCreateInstallationTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsCreateInstallationTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsCreateInstallationTokenReq) body() interface{} {
	return r.RequestBody
}

func (r *AppsCreateInstallationTokenReq) dataStatuses() []int {
	return []int{201}
}

func (r *AppsCreateInstallationTokenReq) validStatuses() []int {
	return []int{201}
}

func (r *AppsCreateInstallationTokenReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *AppsCreateInstallationTokenReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsCreateInstallationTokenReq) Rel(link RelName, resp *AppsCreateInstallationTokenResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsCreateInstallationTokenReqBody is a request body for apps/create-installation-token

https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
type AppsCreateInstallationTokenReqBody struct {

	/*
	   The permissions granted to the access token. The permissions object includes the
	   permission names and their access type. For a complete list of permissions and
	   allowable values, see "[GitHub App
	   permissions](https://developer.github.com/apps/building-github-apps/creating-github-apps-using-url-parameters/#github-app-permissions)."
	*/
	Permissions map[string]string `json:"permissions,omitempty"`

	/*
	   The `id`s of the repositories that the installation token can access. Providing
	   repository `id`s restricts the access of an installation token to specific
	   repositories. You can use the "[List
	   repositories](https://developer.github.com/v3/apps/installations/#list-repositories)"
	   endpoint to get the `id` of all repositories that an installation can access.
	   For example, you can select specific repositories when creating an installation
	   token to restrict the number of repositories that can be cloned using the token.
	*/
	RepositoryIds []int64 `json:"repository_ids,omitempty"`
}

/*
AppsCreateInstallationTokenResponseBody is a response body for AppsCreateInstallationToken

https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
type AppsCreateInstallationTokenResponseBody struct {
	components.InstallationToken
}

/*
AppsCreateInstallationTokenResponse is a response for AppsCreateInstallationToken

https://developer.github.com/v3/apps/#create-a-new-installation-token
*/
type AppsCreateInstallationTokenResponse struct {
	response
	request *AppsCreateInstallationTokenReq
	Data    *AppsCreateInstallationTokenResponseBody
}

/*
AppsDeleteAuthorization performs requests for "apps/delete-authorization"

Delete an app authorization.

  DELETE /applications/{client_id}/grant

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
func AppsDeleteAuthorization(ctx context.Context, req *AppsDeleteAuthorizationReq, opt ...RequestOption) (*AppsDeleteAuthorizationResponse, error) {
	if req == nil {
		req = new(AppsDeleteAuthorizationReq)
	}
	resp := &AppsDeleteAuthorizationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsDeleteAuthorization performs requests for "apps/delete-authorization"

Delete an app authorization.

  DELETE /applications/{client_id}/grant

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
func (c Client) AppsDeleteAuthorization(ctx context.Context, req *AppsDeleteAuthorizationReq, opt ...RequestOption) (*AppsDeleteAuthorizationResponse, error) {
	return AppsDeleteAuthorization(ctx, req, append(c, opt...)...)
}

/*
AppsDeleteAuthorizationReq is request data for Client.AppsDeleteAuthorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type AppsDeleteAuthorizationReq struct {
	_url        string
	ClientId    string
	RequestBody AppsDeleteAuthorizationReqBody
}

func (r *AppsDeleteAuthorizationReq) url() string {
	return r._url
}

func (r *AppsDeleteAuthorizationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/grant", r.ClientId)
}

func (r *AppsDeleteAuthorizationReq) method() string {
	return "DELETE"
}

func (r *AppsDeleteAuthorizationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsDeleteAuthorizationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsDeleteAuthorizationReq) body() interface{} {
	return r.RequestBody
}

func (r *AppsDeleteAuthorizationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsDeleteAuthorizationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsDeleteAuthorizationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *AppsDeleteAuthorizationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsDeleteAuthorizationReq) Rel(link RelName, resp *AppsDeleteAuthorizationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsDeleteAuthorizationReqBody is a request body for apps/delete-authorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type AppsDeleteAuthorizationReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsDeleteAuthorizationResponse is a response for AppsDeleteAuthorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type AppsDeleteAuthorizationResponse struct {
	response
	request *AppsDeleteAuthorizationReq
}

/*
AppsDeleteInstallation performs requests for "apps/delete-installation"

Delete an installation.

  DELETE /app/installations/{installation_id}

https://developer.github.com/v3/apps/#delete-an-installation
*/
func AppsDeleteInstallation(ctx context.Context, req *AppsDeleteInstallationReq, opt ...RequestOption) (*AppsDeleteInstallationResponse, error) {
	if req == nil {
		req = new(AppsDeleteInstallationReq)
	}
	resp := &AppsDeleteInstallationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsDeleteInstallation performs requests for "apps/delete-installation"

Delete an installation.

  DELETE /app/installations/{installation_id}

https://developer.github.com/v3/apps/#delete-an-installation
*/
func (c Client) AppsDeleteInstallation(ctx context.Context, req *AppsDeleteInstallationReq, opt ...RequestOption) (*AppsDeleteInstallationResponse, error) {
	return AppsDeleteInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsDeleteInstallationReq is request data for Client.AppsDeleteInstallation

https://developer.github.com/v3/apps/#delete-an-installation
*/
type AppsDeleteInstallationReq struct {
	_url           string
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsDeleteInstallationReq) url() string {
	return r._url
}

func (r *AppsDeleteInstallationReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v", r.InstallationId)
}

func (r *AppsDeleteInstallationReq) method() string {
	return "DELETE"
}

func (r *AppsDeleteInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsDeleteInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsDeleteInstallationReq) body() interface{} {
	return nil
}

func (r *AppsDeleteInstallationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsDeleteInstallationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsDeleteInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsDeleteInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsDeleteInstallationReq) Rel(link RelName, resp *AppsDeleteInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsDeleteInstallationResponse is a response for AppsDeleteInstallation

https://developer.github.com/v3/apps/#delete-an-installation
*/
type AppsDeleteInstallationResponse struct {
	response
	request *AppsDeleteInstallationReq
}

/*
AppsDeleteToken performs requests for "apps/delete-token"

Delete an app token.

  DELETE /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
func AppsDeleteToken(ctx context.Context, req *AppsDeleteTokenReq, opt ...RequestOption) (*AppsDeleteTokenResponse, error) {
	if req == nil {
		req = new(AppsDeleteTokenReq)
	}
	resp := &AppsDeleteTokenResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsDeleteToken performs requests for "apps/delete-token"

Delete an app token.

  DELETE /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
func (c Client) AppsDeleteToken(ctx context.Context, req *AppsDeleteTokenReq, opt ...RequestOption) (*AppsDeleteTokenResponse, error) {
	return AppsDeleteToken(ctx, req, append(c, opt...)...)
}

/*
AppsDeleteTokenReq is request data for Client.AppsDeleteToken

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type AppsDeleteTokenReq struct {
	_url        string
	ClientId    string
	RequestBody AppsDeleteTokenReqBody
}

func (r *AppsDeleteTokenReq) url() string {
	return r._url
}

func (r *AppsDeleteTokenReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/token", r.ClientId)
}

func (r *AppsDeleteTokenReq) method() string {
	return "DELETE"
}

func (r *AppsDeleteTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsDeleteTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsDeleteTokenReq) body() interface{} {
	return r.RequestBody
}

func (r *AppsDeleteTokenReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsDeleteTokenReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsDeleteTokenReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *AppsDeleteTokenReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsDeleteTokenReq) Rel(link RelName, resp *AppsDeleteTokenResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsDeleteTokenReqBody is a request body for apps/delete-token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type AppsDeleteTokenReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsDeleteTokenResponse is a response for AppsDeleteToken

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type AppsDeleteTokenResponse struct {
	response
	request *AppsDeleteTokenReq
}

/*
AppsGetAuthenticated performs requests for "apps/get-authenticated"

Get the authenticated GitHub App.

  GET /app

https://developer.github.com/v3/apps/#get-the-authenticated-github-app
*/
func AppsGetAuthenticated(ctx context.Context, req *AppsGetAuthenticatedReq, opt ...RequestOption) (*AppsGetAuthenticatedResponse, error) {
	if req == nil {
		req = new(AppsGetAuthenticatedReq)
	}
	resp := &AppsGetAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsGetAuthenticatedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetAuthenticated performs requests for "apps/get-authenticated"

Get the authenticated GitHub App.

  GET /app

https://developer.github.com/v3/apps/#get-the-authenticated-github-app
*/
func (c Client) AppsGetAuthenticated(ctx context.Context, req *AppsGetAuthenticatedReq, opt ...RequestOption) (*AppsGetAuthenticatedResponse, error) {
	return AppsGetAuthenticated(ctx, req, append(c, opt...)...)
}

/*
AppsGetAuthenticatedReq is request data for Client.AppsGetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-github-app
*/
type AppsGetAuthenticatedReq struct {
	_url string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetAuthenticatedReq) url() string {
	return r._url
}

func (r *AppsGetAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/app")
}

func (r *AppsGetAuthenticatedReq) method() string {
	return "GET"
}

func (r *AppsGetAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetAuthenticatedReq) body() interface{} {
	return nil
}

func (r *AppsGetAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetAuthenticatedReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsGetAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetAuthenticatedReq) Rel(link RelName, resp *AppsGetAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetAuthenticatedResponseBody is a response body for AppsGetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-github-app
*/
type AppsGetAuthenticatedResponseBody struct {
	components.Integration
}

/*
AppsGetAuthenticatedResponse is a response for AppsGetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-github-app
*/
type AppsGetAuthenticatedResponse struct {
	response
	request *AppsGetAuthenticatedReq
	Data    *AppsGetAuthenticatedResponseBody
}

/*
AppsGetBySlug performs requests for "apps/get-by-slug"

Get a single GitHub App.

  GET /apps/{app_slug}

https://developer.github.com/v3/apps/#get-a-single-github-app
*/
func AppsGetBySlug(ctx context.Context, req *AppsGetBySlugReq, opt ...RequestOption) (*AppsGetBySlugResponse, error) {
	if req == nil {
		req = new(AppsGetBySlugReq)
	}
	resp := &AppsGetBySlugResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsGetBySlugResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetBySlug performs requests for "apps/get-by-slug"

Get a single GitHub App.

  GET /apps/{app_slug}

https://developer.github.com/v3/apps/#get-a-single-github-app
*/
func (c Client) AppsGetBySlug(ctx context.Context, req *AppsGetBySlugReq, opt ...RequestOption) (*AppsGetBySlugResponse, error) {
	return AppsGetBySlug(ctx, req, append(c, opt...)...)
}

/*
AppsGetBySlugReq is request data for Client.AppsGetBySlug

https://developer.github.com/v3/apps/#get-a-single-github-app
*/
type AppsGetBySlugReq struct {
	_url    string
	AppSlug string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetBySlugReq) url() string {
	return r._url
}

func (r *AppsGetBySlugReq) urlPath() string {
	return fmt.Sprintf("/apps/%v", r.AppSlug)
}

func (r *AppsGetBySlugReq) method() string {
	return "GET"
}

func (r *AppsGetBySlugReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetBySlugReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetBySlugReq) body() interface{} {
	return nil
}

func (r *AppsGetBySlugReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetBySlugReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetBySlugReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsGetBySlugReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetBySlugReq) Rel(link RelName, resp *AppsGetBySlugResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetBySlugResponseBody is a response body for AppsGetBySlug

https://developer.github.com/v3/apps/#get-a-single-github-app
*/
type AppsGetBySlugResponseBody struct {
	components.Integration2
}

/*
AppsGetBySlugResponse is a response for AppsGetBySlug

https://developer.github.com/v3/apps/#get-a-single-github-app
*/
type AppsGetBySlugResponse struct {
	response
	request *AppsGetBySlugReq
	Data    *AppsGetBySlugResponseBody
}

/*
AppsGetInstallation performs requests for "apps/get-installation"

Get an installation.

  GET /app/installations/{installation_id}

https://developer.github.com/v3/apps/#get-an-installation
*/
func AppsGetInstallation(ctx context.Context, req *AppsGetInstallationReq, opt ...RequestOption) (*AppsGetInstallationResponse, error) {
	if req == nil {
		req = new(AppsGetInstallationReq)
	}
	resp := &AppsGetInstallationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsGetInstallationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetInstallation performs requests for "apps/get-installation"

Get an installation.

  GET /app/installations/{installation_id}

https://developer.github.com/v3/apps/#get-an-installation
*/
func (c Client) AppsGetInstallation(ctx context.Context, req *AppsGetInstallationReq, opt ...RequestOption) (*AppsGetInstallationResponse, error) {
	return AppsGetInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsGetInstallationReq is request data for Client.AppsGetInstallation

https://developer.github.com/v3/apps/#get-an-installation
*/
type AppsGetInstallationReq struct {
	_url           string
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetInstallationReq) url() string {
	return r._url
}

func (r *AppsGetInstallationReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v", r.InstallationId)
}

func (r *AppsGetInstallationReq) method() string {
	return "GET"
}

func (r *AppsGetInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetInstallationReq) body() interface{} {
	return nil
}

func (r *AppsGetInstallationReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetInstallationReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsGetInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetInstallationReq) Rel(link RelName, resp *AppsGetInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetInstallationResponseBody is a response body for AppsGetInstallation

https://developer.github.com/v3/apps/#get-an-installation
*/
type AppsGetInstallationResponseBody struct {
	components.BaseInstallation
}

/*
AppsGetInstallationResponse is a response for AppsGetInstallation

https://developer.github.com/v3/apps/#get-an-installation
*/
type AppsGetInstallationResponse struct {
	response
	request *AppsGetInstallationReq
	Data    *AppsGetInstallationResponseBody
}

/*
AppsGetOrgInstallation performs requests for "apps/get-org-installation"

Get an organization installation.

  GET /orgs/{org}/installation

https://developer.github.com/v3/apps/#get-an-organization-installation
*/
func AppsGetOrgInstallation(ctx context.Context, req *AppsGetOrgInstallationReq, opt ...RequestOption) (*AppsGetOrgInstallationResponse, error) {
	if req == nil {
		req = new(AppsGetOrgInstallationReq)
	}
	resp := &AppsGetOrgInstallationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsGetOrgInstallationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetOrgInstallation performs requests for "apps/get-org-installation"

Get an organization installation.

  GET /orgs/{org}/installation

https://developer.github.com/v3/apps/#get-an-organization-installation
*/
func (c Client) AppsGetOrgInstallation(ctx context.Context, req *AppsGetOrgInstallationReq, opt ...RequestOption) (*AppsGetOrgInstallationResponse, error) {
	return AppsGetOrgInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsGetOrgInstallationReq is request data for Client.AppsGetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation
*/
type AppsGetOrgInstallationReq struct {
	_url string
	Org  string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetOrgInstallationReq) url() string {
	return r._url
}

func (r *AppsGetOrgInstallationReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/installation", r.Org)
}

func (r *AppsGetOrgInstallationReq) method() string {
	return "GET"
}

func (r *AppsGetOrgInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetOrgInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetOrgInstallationReq) body() interface{} {
	return nil
}

func (r *AppsGetOrgInstallationReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetOrgInstallationReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetOrgInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsGetOrgInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetOrgInstallationReq) Rel(link RelName, resp *AppsGetOrgInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetOrgInstallationResponseBody is a response body for AppsGetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation
*/
type AppsGetOrgInstallationResponseBody struct {
	components.Installation
}

/*
AppsGetOrgInstallationResponse is a response for AppsGetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation
*/
type AppsGetOrgInstallationResponse struct {
	response
	request *AppsGetOrgInstallationReq
	Data    *AppsGetOrgInstallationResponseBody
}

/*
AppsGetRepoInstallation performs requests for "apps/get-repo-installation"

Get a repository installation.

  GET /repos/{owner}/{repo}/installation

https://developer.github.com/v3/apps/#get-a-repository-installation
*/
func AppsGetRepoInstallation(ctx context.Context, req *AppsGetRepoInstallationReq, opt ...RequestOption) (*AppsGetRepoInstallationResponse, error) {
	if req == nil {
		req = new(AppsGetRepoInstallationReq)
	}
	resp := &AppsGetRepoInstallationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsGetRepoInstallationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetRepoInstallation performs requests for "apps/get-repo-installation"

Get a repository installation.

  GET /repos/{owner}/{repo}/installation

https://developer.github.com/v3/apps/#get-a-repository-installation
*/
func (c Client) AppsGetRepoInstallation(ctx context.Context, req *AppsGetRepoInstallationReq, opt ...RequestOption) (*AppsGetRepoInstallationResponse, error) {
	return AppsGetRepoInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsGetRepoInstallationReq is request data for Client.AppsGetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation
*/
type AppsGetRepoInstallationReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetRepoInstallationReq) url() string {
	return r._url
}

func (r *AppsGetRepoInstallationReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/installation", r.Owner, r.Repo)
}

func (r *AppsGetRepoInstallationReq) method() string {
	return "GET"
}

func (r *AppsGetRepoInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetRepoInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetRepoInstallationReq) body() interface{} {
	return nil
}

func (r *AppsGetRepoInstallationReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetRepoInstallationReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetRepoInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsGetRepoInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetRepoInstallationReq) Rel(link RelName, resp *AppsGetRepoInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetRepoInstallationResponseBody is a response body for AppsGetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation
*/
type AppsGetRepoInstallationResponseBody struct {
	components.Installation
}

/*
AppsGetRepoInstallationResponse is a response for AppsGetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation
*/
type AppsGetRepoInstallationResponse struct {
	response
	request *AppsGetRepoInstallationReq
	Data    *AppsGetRepoInstallationResponseBody
}

/*
AppsGetSubscriptionPlanForAccount performs requests for "apps/get-subscription-plan-for-account"

Get a subscription plan for an account.

  GET /marketplace_listing/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
func AppsGetSubscriptionPlanForAccount(ctx context.Context, req *AppsGetSubscriptionPlanForAccountReq, opt ...RequestOption) (*AppsGetSubscriptionPlanForAccountResponse, error) {
	if req == nil {
		req = new(AppsGetSubscriptionPlanForAccountReq)
	}
	resp := &AppsGetSubscriptionPlanForAccountResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsGetSubscriptionPlanForAccountResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetSubscriptionPlanForAccount performs requests for "apps/get-subscription-plan-for-account"

Get a subscription plan for an account.

  GET /marketplace_listing/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
func (c Client) AppsGetSubscriptionPlanForAccount(ctx context.Context, req *AppsGetSubscriptionPlanForAccountReq, opt ...RequestOption) (*AppsGetSubscriptionPlanForAccountResponse, error) {
	return AppsGetSubscriptionPlanForAccount(ctx, req, append(c, opt...)...)
}

/*
AppsGetSubscriptionPlanForAccountReq is request data for Client.AppsGetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type AppsGetSubscriptionPlanForAccountReq struct {
	_url      string
	AccountId int64
}

func (r *AppsGetSubscriptionPlanForAccountReq) url() string {
	return r._url
}

func (r *AppsGetSubscriptionPlanForAccountReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/accounts/%v", r.AccountId)
}

func (r *AppsGetSubscriptionPlanForAccountReq) method() string {
	return "GET"
}

func (r *AppsGetSubscriptionPlanForAccountReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetSubscriptionPlanForAccountReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetSubscriptionPlanForAccountReq) body() interface{} {
	return nil
}

func (r *AppsGetSubscriptionPlanForAccountReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetSubscriptionPlanForAccountReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetSubscriptionPlanForAccountReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsGetSubscriptionPlanForAccountReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetSubscriptionPlanForAccountReq) Rel(link RelName, resp *AppsGetSubscriptionPlanForAccountResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetSubscriptionPlanForAccountResponseBody is a response body for AppsGetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type AppsGetSubscriptionPlanForAccountResponseBody struct {
	components.MarketplacePurchase
}

/*
AppsGetSubscriptionPlanForAccountResponse is a response for AppsGetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type AppsGetSubscriptionPlanForAccountResponse struct {
	response
	request *AppsGetSubscriptionPlanForAccountReq
	Data    *AppsGetSubscriptionPlanForAccountResponseBody
}

/*
AppsGetSubscriptionPlanForAccountStubbed performs requests for "apps/get-subscription-plan-for-account-stubbed"

Get a subscription plan for an account (stubbed).

  GET /marketplace_listing/stubbed/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
func AppsGetSubscriptionPlanForAccountStubbed(ctx context.Context, req *AppsGetSubscriptionPlanForAccountStubbedReq, opt ...RequestOption) (*AppsGetSubscriptionPlanForAccountStubbedResponse, error) {
	if req == nil {
		req = new(AppsGetSubscriptionPlanForAccountStubbedReq)
	}
	resp := &AppsGetSubscriptionPlanForAccountStubbedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsGetSubscriptionPlanForAccountStubbedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetSubscriptionPlanForAccountStubbed performs requests for "apps/get-subscription-plan-for-account-stubbed"

Get a subscription plan for an account (stubbed).

  GET /marketplace_listing/stubbed/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
func (c Client) AppsGetSubscriptionPlanForAccountStubbed(ctx context.Context, req *AppsGetSubscriptionPlanForAccountStubbedReq, opt ...RequestOption) (*AppsGetSubscriptionPlanForAccountStubbedResponse, error) {
	return AppsGetSubscriptionPlanForAccountStubbed(ctx, req, append(c, opt...)...)
}

/*
AppsGetSubscriptionPlanForAccountStubbedReq is request data for Client.AppsGetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type AppsGetSubscriptionPlanForAccountStubbedReq struct {
	_url      string
	AccountId int64
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) url() string {
	return r._url
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/stubbed/accounts/%v", r.AccountId)
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) method() string {
	return "GET"
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) body() interface{} {
	return nil
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetSubscriptionPlanForAccountStubbedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsGetSubscriptionPlanForAccountStubbedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetSubscriptionPlanForAccountStubbedReq) Rel(link RelName, resp *AppsGetSubscriptionPlanForAccountStubbedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetSubscriptionPlanForAccountStubbedResponseBody is a response body for AppsGetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type AppsGetSubscriptionPlanForAccountStubbedResponseBody struct {
	components.MarketplacePurchase
}

/*
AppsGetSubscriptionPlanForAccountStubbedResponse is a response for AppsGetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type AppsGetSubscriptionPlanForAccountStubbedResponse struct {
	response
	request *AppsGetSubscriptionPlanForAccountStubbedReq
	Data    *AppsGetSubscriptionPlanForAccountStubbedResponseBody
}

/*
AppsGetUserInstallation performs requests for "apps/get-user-installation"

Get a user installation.

  GET /users/{username}/installation

https://developer.github.com/v3/apps/#get-a-user-installation
*/
func AppsGetUserInstallation(ctx context.Context, req *AppsGetUserInstallationReq, opt ...RequestOption) (*AppsGetUserInstallationResponse, error) {
	if req == nil {
		req = new(AppsGetUserInstallationReq)
	}
	resp := &AppsGetUserInstallationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsGetUserInstallationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsGetUserInstallation performs requests for "apps/get-user-installation"

Get a user installation.

  GET /users/{username}/installation

https://developer.github.com/v3/apps/#get-a-user-installation
*/
func (c Client) AppsGetUserInstallation(ctx context.Context, req *AppsGetUserInstallationReq, opt ...RequestOption) (*AppsGetUserInstallationResponse, error) {
	return AppsGetUserInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsGetUserInstallationReq is request data for Client.AppsGetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation
*/
type AppsGetUserInstallationReq struct {
	_url     string
	Username string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsGetUserInstallationReq) url() string {
	return r._url
}

func (r *AppsGetUserInstallationReq) urlPath() string {
	return fmt.Sprintf("/users/%v/installation", r.Username)
}

func (r *AppsGetUserInstallationReq) method() string {
	return "GET"
}

func (r *AppsGetUserInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsGetUserInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsGetUserInstallationReq) body() interface{} {
	return nil
}

func (r *AppsGetUserInstallationReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsGetUserInstallationReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsGetUserInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsGetUserInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsGetUserInstallationReq) Rel(link RelName, resp *AppsGetUserInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsGetUserInstallationResponseBody is a response body for AppsGetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation
*/
type AppsGetUserInstallationResponseBody struct {
	components.Installation2
}

/*
AppsGetUserInstallationResponse is a response for AppsGetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation
*/
type AppsGetUserInstallationResponse struct {
	response
	request *AppsGetUserInstallationReq
	Data    *AppsGetUserInstallationResponseBody
}

/*
AppsListAccountsForPlan performs requests for "apps/list-accounts-for-plan"

List accounts for a plan.

  GET /marketplace_listing/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
func AppsListAccountsForPlan(ctx context.Context, req *AppsListAccountsForPlanReq, opt ...RequestOption) (*AppsListAccountsForPlanResponse, error) {
	if req == nil {
		req = new(AppsListAccountsForPlanReq)
	}
	resp := &AppsListAccountsForPlanResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsListAccountsForPlanResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListAccountsForPlan performs requests for "apps/list-accounts-for-plan"

List accounts for a plan.

  GET /marketplace_listing/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
func (c Client) AppsListAccountsForPlan(ctx context.Context, req *AppsListAccountsForPlanReq, opt ...RequestOption) (*AppsListAccountsForPlanResponse, error) {
	return AppsListAccountsForPlan(ctx, req, append(c, opt...)...)
}

/*
AppsListAccountsForPlanReq is request data for Client.AppsListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type AppsListAccountsForPlanReq struct {
	_url   string
	PlanId int64

	/*
	Sorts the GitHub accounts by the date they were created or last updated. Can be
	one of `created` or `updated`.
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListAccountsForPlanReq) url() string {
	return r._url
}

func (r *AppsListAccountsForPlanReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/plans/%v/accounts", r.PlanId)
}

func (r *AppsListAccountsForPlanReq) method() string {
	return "GET"
}

func (r *AppsListAccountsForPlanReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListAccountsForPlanReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListAccountsForPlanReq) body() interface{} {
	return nil
}

func (r *AppsListAccountsForPlanReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListAccountsForPlanReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListAccountsForPlanReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsListAccountsForPlanReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListAccountsForPlanReq) Rel(link RelName, resp *AppsListAccountsForPlanResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListAccountsForPlanResponseBody is a response body for AppsListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type AppsListAccountsForPlanResponseBody []struct {
	components.MarketplacePurchase
}

/*
AppsListAccountsForPlanResponse is a response for AppsListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type AppsListAccountsForPlanResponse struct {
	response
	request *AppsListAccountsForPlanReq
	Data    *AppsListAccountsForPlanResponseBody
}

/*
AppsListAccountsForPlanStubbed performs requests for "apps/list-accounts-for-plan-stubbed"

List accounts for a plan (stubbed).

  GET /marketplace_listing/stubbed/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
func AppsListAccountsForPlanStubbed(ctx context.Context, req *AppsListAccountsForPlanStubbedReq, opt ...RequestOption) (*AppsListAccountsForPlanStubbedResponse, error) {
	if req == nil {
		req = new(AppsListAccountsForPlanStubbedReq)
	}
	resp := &AppsListAccountsForPlanStubbedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsListAccountsForPlanStubbedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListAccountsForPlanStubbed performs requests for "apps/list-accounts-for-plan-stubbed"

List accounts for a plan (stubbed).

  GET /marketplace_listing/stubbed/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
func (c Client) AppsListAccountsForPlanStubbed(ctx context.Context, req *AppsListAccountsForPlanStubbedReq, opt ...RequestOption) (*AppsListAccountsForPlanStubbedResponse, error) {
	return AppsListAccountsForPlanStubbed(ctx, req, append(c, opt...)...)
}

/*
AppsListAccountsForPlanStubbedReq is request data for Client.AppsListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type AppsListAccountsForPlanStubbedReq struct {
	_url   string
	PlanId int64

	/*
	Sorts the GitHub accounts by the date they were created or last updated. Can be
	one of `created` or `updated`.
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListAccountsForPlanStubbedReq) url() string {
	return r._url
}

func (r *AppsListAccountsForPlanStubbedReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/stubbed/plans/%v/accounts", r.PlanId)
}

func (r *AppsListAccountsForPlanStubbedReq) method() string {
	return "GET"
}

func (r *AppsListAccountsForPlanStubbedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListAccountsForPlanStubbedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListAccountsForPlanStubbedReq) body() interface{} {
	return nil
}

func (r *AppsListAccountsForPlanStubbedReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListAccountsForPlanStubbedReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListAccountsForPlanStubbedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsListAccountsForPlanStubbedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListAccountsForPlanStubbedReq) Rel(link RelName, resp *AppsListAccountsForPlanStubbedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListAccountsForPlanStubbedResponseBody is a response body for AppsListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type AppsListAccountsForPlanStubbedResponseBody []struct {
	components.MarketplacePurchase
}

/*
AppsListAccountsForPlanStubbedResponse is a response for AppsListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type AppsListAccountsForPlanStubbedResponse struct {
	response
	request *AppsListAccountsForPlanStubbedReq
	Data    *AppsListAccountsForPlanStubbedResponseBody
}

/*
AppsListInstallationReposForAuthenticatedUser performs requests for "apps/list-installation-repos-for-authenticated-user"

List repositories accessible to the user for an installation.

  GET /user/installations/{installation_id}/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-for-an-installation
*/
func AppsListInstallationReposForAuthenticatedUser(ctx context.Context, req *AppsListInstallationReposForAuthenticatedUserReq, opt ...RequestOption) (*AppsListInstallationReposForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(AppsListInstallationReposForAuthenticatedUserReq)
	}
	resp := &AppsListInstallationReposForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsListInstallationReposForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListInstallationReposForAuthenticatedUser performs requests for "apps/list-installation-repos-for-authenticated-user"

List repositories accessible to the user for an installation.

  GET /user/installations/{installation_id}/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-for-an-installation
*/
func (c Client) AppsListInstallationReposForAuthenticatedUser(ctx context.Context, req *AppsListInstallationReposForAuthenticatedUserReq, opt ...RequestOption) (*AppsListInstallationReposForAuthenticatedUserResponse, error) {
	return AppsListInstallationReposForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
AppsListInstallationReposForAuthenticatedUserReq is request data for Client.AppsListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-for-an-installation
*/
type AppsListInstallationReposForAuthenticatedUserReq struct {
	_url           string
	InstallationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/installations/%v/repositories", r.InstallationId)
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man": r.MachineManPreview,
		"mercy":       r.MercyPreview,
	}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["mercy"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListInstallationReposForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsListInstallationReposForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListInstallationReposForAuthenticatedUserReq) Rel(link RelName, resp *AppsListInstallationReposForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListInstallationReposForAuthenticatedUserResponseBody is a response body for AppsListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-for-an-installation
*/
type AppsListInstallationReposForAuthenticatedUserResponseBody struct {
	Repositories []struct {
		components.Repository
	} `json:"repositories,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
AppsListInstallationReposForAuthenticatedUserResponse is a response for AppsListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-for-an-installation
*/
type AppsListInstallationReposForAuthenticatedUserResponse struct {
	response
	request *AppsListInstallationReposForAuthenticatedUserReq
	Data    *AppsListInstallationReposForAuthenticatedUserResponseBody
}

/*
AppsListInstallations performs requests for "apps/list-installations"

List installations.

  GET /app/installations

https://developer.github.com/v3/apps/#list-installations
*/
func AppsListInstallations(ctx context.Context, req *AppsListInstallationsReq, opt ...RequestOption) (*AppsListInstallationsResponse, error) {
	if req == nil {
		req = new(AppsListInstallationsReq)
	}
	resp := &AppsListInstallationsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsListInstallationsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListInstallations performs requests for "apps/list-installations"

List installations.

  GET /app/installations

https://developer.github.com/v3/apps/#list-installations
*/
func (c Client) AppsListInstallations(ctx context.Context, req *AppsListInstallationsReq, opt ...RequestOption) (*AppsListInstallationsResponse, error) {
	return AppsListInstallations(ctx, req, append(c, opt...)...)
}

/*
AppsListInstallationsReq is request data for Client.AppsListInstallations

https://developer.github.com/v3/apps/#list-installations
*/
type AppsListInstallationsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsListInstallationsReq) url() string {
	return r._url
}

func (r *AppsListInstallationsReq) urlPath() string {
	return fmt.Sprintf("/app/installations")
}

func (r *AppsListInstallationsReq) method() string {
	return "GET"
}

func (r *AppsListInstallationsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListInstallationsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListInstallationsReq) body() interface{} {
	return nil
}

func (r *AppsListInstallationsReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListInstallationsReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListInstallationsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsListInstallationsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListInstallationsReq) Rel(link RelName, resp *AppsListInstallationsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListInstallationsResponseBody is a response body for AppsListInstallations

https://developer.github.com/v3/apps/#list-installations
*/
type AppsListInstallationsResponseBody []struct {
	components.BaseInstallation
}

/*
AppsListInstallationsResponse is a response for AppsListInstallations

https://developer.github.com/v3/apps/#list-installations
*/
type AppsListInstallationsResponse struct {
	response
	request *AppsListInstallationsReq
	Data    *AppsListInstallationsResponseBody
}

/*
AppsListInstallationsForAuthenticatedUser performs requests for "apps/list-installations-for-authenticated-user"

List installations for a user.

  GET /user/installations

https://developer.github.com/v3/apps/installations/#list-installations-for-a-user
*/
func AppsListInstallationsForAuthenticatedUser(ctx context.Context, req *AppsListInstallationsForAuthenticatedUserReq, opt ...RequestOption) (*AppsListInstallationsForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(AppsListInstallationsForAuthenticatedUserReq)
	}
	resp := &AppsListInstallationsForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsListInstallationsForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListInstallationsForAuthenticatedUser performs requests for "apps/list-installations-for-authenticated-user"

List installations for a user.

  GET /user/installations

https://developer.github.com/v3/apps/installations/#list-installations-for-a-user
*/
func (c Client) AppsListInstallationsForAuthenticatedUser(ctx context.Context, req *AppsListInstallationsForAuthenticatedUserReq, opt ...RequestOption) (*AppsListInstallationsForAuthenticatedUserResponse, error) {
	return AppsListInstallationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
AppsListInstallationsForAuthenticatedUserReq is request data for Client.AppsListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-installations-for-a-user
*/
type AppsListInstallationsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsListInstallationsForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *AppsListInstallationsForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/installations")
}

func (r *AppsListInstallationsForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *AppsListInstallationsForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListInstallationsForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListInstallationsForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *AppsListInstallationsForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListInstallationsForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListInstallationsForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsListInstallationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListInstallationsForAuthenticatedUserReq) Rel(link RelName, resp *AppsListInstallationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListInstallationsForAuthenticatedUserResponseBody is a response body for AppsListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-installations-for-a-user
*/
type AppsListInstallationsForAuthenticatedUserResponseBody struct {
	Installations []struct {
		components.BaseInstallationForAuthUser
	} `json:"installations,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
AppsListInstallationsForAuthenticatedUserResponse is a response for AppsListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-installations-for-a-user
*/
type AppsListInstallationsForAuthenticatedUserResponse struct {
	response
	request *AppsListInstallationsForAuthenticatedUserReq
	Data    *AppsListInstallationsForAuthenticatedUserResponseBody
}

/*
AppsListPlans performs requests for "apps/list-plans"

List plans.

  GET /marketplace_listing/plans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
func AppsListPlans(ctx context.Context, req *AppsListPlansReq, opt ...RequestOption) (*AppsListPlansResponse, error) {
	if req == nil {
		req = new(AppsListPlansReq)
	}
	resp := &AppsListPlansResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsListPlansResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListPlans performs requests for "apps/list-plans"

List plans.

  GET /marketplace_listing/plans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
func (c Client) AppsListPlans(ctx context.Context, req *AppsListPlansReq, opt ...RequestOption) (*AppsListPlansResponse, error) {
	return AppsListPlans(ctx, req, append(c, opt...)...)
}

/*
AppsListPlansReq is request data for Client.AppsListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type AppsListPlansReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListPlansReq) url() string {
	return r._url
}

func (r *AppsListPlansReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/plans")
}

func (r *AppsListPlansReq) method() string {
	return "GET"
}

func (r *AppsListPlansReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListPlansReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListPlansReq) body() interface{} {
	return nil
}

func (r *AppsListPlansReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListPlansReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListPlansReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsListPlansReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListPlansReq) Rel(link RelName, resp *AppsListPlansResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListPlansResponseBody is a response body for AppsListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type AppsListPlansResponseBody []struct {
	components.MarketplaceListingPlan
}

/*
AppsListPlansResponse is a response for AppsListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type AppsListPlansResponse struct {
	response
	request *AppsListPlansReq
	Data    *AppsListPlansResponseBody
}

/*
AppsListPlansStubbed performs requests for "apps/list-plans-stubbed"

List plans (stubbed).

  GET /marketplace_listing/stubbed/plans

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
func AppsListPlansStubbed(ctx context.Context, req *AppsListPlansStubbedReq, opt ...RequestOption) (*AppsListPlansStubbedResponse, error) {
	if req == nil {
		req = new(AppsListPlansStubbedReq)
	}
	resp := &AppsListPlansStubbedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsListPlansStubbedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListPlansStubbed performs requests for "apps/list-plans-stubbed"

List plans (stubbed).

  GET /marketplace_listing/stubbed/plans

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
func (c Client) AppsListPlansStubbed(ctx context.Context, req *AppsListPlansStubbedReq, opt ...RequestOption) (*AppsListPlansStubbedResponse, error) {
	return AppsListPlansStubbed(ctx, req, append(c, opt...)...)
}

/*
AppsListPlansStubbedReq is request data for Client.AppsListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type AppsListPlansStubbedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListPlansStubbedReq) url() string {
	return r._url
}

func (r *AppsListPlansStubbedReq) urlPath() string {
	return fmt.Sprintf("/marketplace_listing/stubbed/plans")
}

func (r *AppsListPlansStubbedReq) method() string {
	return "GET"
}

func (r *AppsListPlansStubbedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListPlansStubbedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListPlansStubbedReq) body() interface{} {
	return nil
}

func (r *AppsListPlansStubbedReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListPlansStubbedReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListPlansStubbedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsListPlansStubbedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListPlansStubbedReq) Rel(link RelName, resp *AppsListPlansStubbedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListPlansStubbedResponseBody is a response body for AppsListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type AppsListPlansStubbedResponseBody []struct {
	components.MarketplaceListingPlan
}

/*
AppsListPlansStubbedResponse is a response for AppsListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type AppsListPlansStubbedResponse struct {
	response
	request *AppsListPlansStubbedReq
	Data    *AppsListPlansStubbedResponseBody
}

/*
AppsListRepos performs requests for "apps/list-repos"

List repositories.

  GET /installation/repositories

https://developer.github.com/v3/apps/installations/#list-repositories
*/
func AppsListRepos(ctx context.Context, req *AppsListReposReq, opt ...RequestOption) (*AppsListReposResponse, error) {
	if req == nil {
		req = new(AppsListReposReq)
	}
	resp := &AppsListReposResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsListReposResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListRepos performs requests for "apps/list-repos"

List repositories.

  GET /installation/repositories

https://developer.github.com/v3/apps/installations/#list-repositories
*/
func (c Client) AppsListRepos(ctx context.Context, req *AppsListReposReq, opt ...RequestOption) (*AppsListReposResponse, error) {
	return AppsListRepos(ctx, req, append(c, opt...)...)
}

/*
AppsListReposReq is request data for Client.AppsListRepos

https://developer.github.com/v3/apps/installations/#list-repositories
*/
type AppsListReposReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

func (r *AppsListReposReq) url() string {
	return r._url
}

func (r *AppsListReposReq) urlPath() string {
	return fmt.Sprintf("/installation/repositories")
}

func (r *AppsListReposReq) method() string {
	return "GET"
}

func (r *AppsListReposReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListReposReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man": r.MachineManPreview,
		"mercy":       r.MercyPreview,
	}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["mercy"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListReposReq) body() interface{} {
	return nil
}

func (r *AppsListReposReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListReposReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListReposReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsListReposReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListReposReq) Rel(link RelName, resp *AppsListReposResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListReposResponseBody is a response body for AppsListRepos

https://developer.github.com/v3/apps/installations/#list-repositories
*/
type AppsListReposResponseBody struct {
	Repositories []struct {
		components.Repository2
	} `json:"repositories,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
AppsListReposResponse is a response for AppsListRepos

https://developer.github.com/v3/apps/installations/#list-repositories
*/
type AppsListReposResponse struct {
	response
	request *AppsListReposReq
	Data    *AppsListReposResponseBody
}

/*
AppsListSubscriptionsForAuthenticatedUser performs requests for "apps/list-subscriptions-for-authenticated-user"

List subscriptions for the authenticated user.

  GET /user/marketplace_purchases

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
func AppsListSubscriptionsForAuthenticatedUser(ctx context.Context, req *AppsListSubscriptionsForAuthenticatedUserReq, opt ...RequestOption) (*AppsListSubscriptionsForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(AppsListSubscriptionsForAuthenticatedUserReq)
	}
	resp := &AppsListSubscriptionsForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsListSubscriptionsForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListSubscriptionsForAuthenticatedUser performs requests for "apps/list-subscriptions-for-authenticated-user"

List subscriptions for the authenticated user.

  GET /user/marketplace_purchases

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
func (c Client) AppsListSubscriptionsForAuthenticatedUser(ctx context.Context, req *AppsListSubscriptionsForAuthenticatedUserReq, opt ...RequestOption) (*AppsListSubscriptionsForAuthenticatedUserResponse, error) {
	return AppsListSubscriptionsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
AppsListSubscriptionsForAuthenticatedUserReq is request data for Client.AppsListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type AppsListSubscriptionsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/marketplace_purchases")
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListSubscriptionsForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsListSubscriptionsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListSubscriptionsForAuthenticatedUserReq) Rel(link RelName, resp *AppsListSubscriptionsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListSubscriptionsForAuthenticatedUserResponseBody is a response body for AppsListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type AppsListSubscriptionsForAuthenticatedUserResponseBody []struct {
	components.UserMarketplacePurchase
}

/*
AppsListSubscriptionsForAuthenticatedUserResponse is a response for AppsListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type AppsListSubscriptionsForAuthenticatedUserResponse struct {
	response
	request *AppsListSubscriptionsForAuthenticatedUserReq
	Data    *AppsListSubscriptionsForAuthenticatedUserResponseBody
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbed performs requests for "apps/list-subscriptions-for-authenticated-user-stubbed"

List subscriptions for the authenticated user (stubbed).

  GET /user/marketplace_purchases/stubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
func AppsListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, req *AppsListSubscriptionsForAuthenticatedUserStubbedReq, opt ...RequestOption) (*AppsListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	if req == nil {
		req = new(AppsListSubscriptionsForAuthenticatedUserStubbedReq)
	}
	resp := &AppsListSubscriptionsForAuthenticatedUserStubbedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsListSubscriptionsForAuthenticatedUserStubbedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbed performs requests for "apps/list-subscriptions-for-authenticated-user-stubbed"

List subscriptions for the authenticated user (stubbed).

  GET /user/marketplace_purchases/stubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
func (c Client) AppsListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, req *AppsListSubscriptionsForAuthenticatedUserStubbedReq, opt ...RequestOption) (*AppsListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	return AppsListSubscriptionsForAuthenticatedUserStubbed(ctx, req, append(c, opt...)...)
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbedReq is request data for Client.AppsListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type AppsListSubscriptionsForAuthenticatedUserStubbedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) url() string {
	return r._url
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) urlPath() string {
	return fmt.Sprintf("/user/marketplace_purchases/stubbed")
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) method() string {
	return "GET"
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) body() interface{} {
	return nil
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsListSubscriptionsForAuthenticatedUserStubbedReq) Rel(link RelName, resp *AppsListSubscriptionsForAuthenticatedUserStubbedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbedResponseBody is a response body for AppsListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type AppsListSubscriptionsForAuthenticatedUserStubbedResponseBody []struct {
	components.UserMarketplacePurchase
}

/*
AppsListSubscriptionsForAuthenticatedUserStubbedResponse is a response for AppsListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type AppsListSubscriptionsForAuthenticatedUserStubbedResponse struct {
	response
	request *AppsListSubscriptionsForAuthenticatedUserStubbedReq
	Data    *AppsListSubscriptionsForAuthenticatedUserStubbedResponseBody
}

/*
AppsRemoveRepoFromInstallation performs requests for "apps/remove-repo-from-installation"

Remove repository from installation.

  DELETE /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#remove-repository-from-installation
*/
func AppsRemoveRepoFromInstallation(ctx context.Context, req *AppsRemoveRepoFromInstallationReq, opt ...RequestOption) (*AppsRemoveRepoFromInstallationResponse, error) {
	if req == nil {
		req = new(AppsRemoveRepoFromInstallationReq)
	}
	resp := &AppsRemoveRepoFromInstallationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsRemoveRepoFromInstallation performs requests for "apps/remove-repo-from-installation"

Remove repository from installation.

  DELETE /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#remove-repository-from-installation
*/
func (c Client) AppsRemoveRepoFromInstallation(ctx context.Context, req *AppsRemoveRepoFromInstallationReq, opt ...RequestOption) (*AppsRemoveRepoFromInstallationResponse, error) {
	return AppsRemoveRepoFromInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsRemoveRepoFromInstallationReq is request data for Client.AppsRemoveRepoFromInstallation

https://developer.github.com/v3/apps/installations/#remove-repository-from-installation
*/
type AppsRemoveRepoFromInstallationReq struct {
	_url           string
	InstallationId int64
	RepositoryId   int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *AppsRemoveRepoFromInstallationReq) url() string {
	return r._url
}

func (r *AppsRemoveRepoFromInstallationReq) urlPath() string {
	return fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId)
}

func (r *AppsRemoveRepoFromInstallationReq) method() string {
	return "DELETE"
}

func (r *AppsRemoveRepoFromInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsRemoveRepoFromInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsRemoveRepoFromInstallationReq) body() interface{} {
	return nil
}

func (r *AppsRemoveRepoFromInstallationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsRemoveRepoFromInstallationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsRemoveRepoFromInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsRemoveRepoFromInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsRemoveRepoFromInstallationReq) Rel(link RelName, resp *AppsRemoveRepoFromInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsRemoveRepoFromInstallationResponse is a response for AppsRemoveRepoFromInstallation

https://developer.github.com/v3/apps/installations/#remove-repository-from-installation
*/
type AppsRemoveRepoFromInstallationResponse struct {
	response
	request *AppsRemoveRepoFromInstallationReq
}

/*
AppsResetAuthorization performs requests for "apps/reset-authorization"

Reset an authorization.

  POST /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
func AppsResetAuthorization(ctx context.Context, req *AppsResetAuthorizationReq, opt ...RequestOption) (*AppsResetAuthorizationResponse, error) {
	if req == nil {
		req = new(AppsResetAuthorizationReq)
	}
	resp := &AppsResetAuthorizationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsResetAuthorizationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsResetAuthorization performs requests for "apps/reset-authorization"

Reset an authorization.

  POST /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
func (c Client) AppsResetAuthorization(ctx context.Context, req *AppsResetAuthorizationReq, opt ...RequestOption) (*AppsResetAuthorizationResponse, error) {
	return AppsResetAuthorization(ctx, req, append(c, opt...)...)
}

/*
AppsResetAuthorizationReq is request data for Client.AppsResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type AppsResetAuthorizationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

func (r *AppsResetAuthorizationReq) url() string {
	return r._url
}

func (r *AppsResetAuthorizationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken)
}

func (r *AppsResetAuthorizationReq) method() string {
	return "POST"
}

func (r *AppsResetAuthorizationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsResetAuthorizationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsResetAuthorizationReq) body() interface{} {
	return nil
}

func (r *AppsResetAuthorizationReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsResetAuthorizationReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsResetAuthorizationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsResetAuthorizationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsResetAuthorizationReq) Rel(link RelName, resp *AppsResetAuthorizationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsResetAuthorizationResponseBody is a response body for AppsResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type AppsResetAuthorizationResponseBody struct {
	components.AuthorizationWithUser
}

/*
AppsResetAuthorizationResponse is a response for AppsResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type AppsResetAuthorizationResponse struct {
	response
	request *AppsResetAuthorizationReq
	Data    *AppsResetAuthorizationResponseBody
}

/*
AppsResetToken performs requests for "apps/reset-token"

Reset a token.

  PATCH /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
func AppsResetToken(ctx context.Context, req *AppsResetTokenReq, opt ...RequestOption) (*AppsResetTokenResponse, error) {
	if req == nil {
		req = new(AppsResetTokenReq)
	}
	resp := &AppsResetTokenResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(AppsResetTokenResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsResetToken performs requests for "apps/reset-token"

Reset a token.

  PATCH /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
func (c Client) AppsResetToken(ctx context.Context, req *AppsResetTokenReq, opt ...RequestOption) (*AppsResetTokenResponse, error) {
	return AppsResetToken(ctx, req, append(c, opt...)...)
}

/*
AppsResetTokenReq is request data for Client.AppsResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenReq struct {
	_url        string
	ClientId    string
	RequestBody AppsResetTokenReqBody
}

func (r *AppsResetTokenReq) url() string {
	return r._url
}

func (r *AppsResetTokenReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/token", r.ClientId)
}

func (r *AppsResetTokenReq) method() string {
	return "PATCH"
}

func (r *AppsResetTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsResetTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsResetTokenReq) body() interface{} {
	return r.RequestBody
}

func (r *AppsResetTokenReq) dataStatuses() []int {
	return []int{200}
}

func (r *AppsResetTokenReq) validStatuses() []int {
	return []int{200}
}

func (r *AppsResetTokenReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *AppsResetTokenReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsResetTokenReq) Rel(link RelName, resp *AppsResetTokenResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsResetTokenReqBody is a request body for apps/reset-token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
AppsResetTokenResponseBody is a response body for AppsResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenResponseBody struct {
	components.AuthorizationWithUser
}

/*
AppsResetTokenResponse is a response for AppsResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type AppsResetTokenResponse struct {
	response
	request *AppsResetTokenReq
	Data    *AppsResetTokenResponseBody
}

/*
AppsRevokeAuthorizationForApplication performs requests for "apps/revoke-authorization-for-application"

Revoke an authorization for an application.

  DELETE /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
func AppsRevokeAuthorizationForApplication(ctx context.Context, req *AppsRevokeAuthorizationForApplicationReq, opt ...RequestOption) (*AppsRevokeAuthorizationForApplicationResponse, error) {
	if req == nil {
		req = new(AppsRevokeAuthorizationForApplicationReq)
	}
	resp := &AppsRevokeAuthorizationForApplicationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsRevokeAuthorizationForApplication performs requests for "apps/revoke-authorization-for-application"

Revoke an authorization for an application.

  DELETE /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
func (c Client) AppsRevokeAuthorizationForApplication(ctx context.Context, req *AppsRevokeAuthorizationForApplicationReq, opt ...RequestOption) (*AppsRevokeAuthorizationForApplicationResponse, error) {
	return AppsRevokeAuthorizationForApplication(ctx, req, append(c, opt...)...)
}

/*
AppsRevokeAuthorizationForApplicationReq is request data for Client.AppsRevokeAuthorizationForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
type AppsRevokeAuthorizationForApplicationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

func (r *AppsRevokeAuthorizationForApplicationReq) url() string {
	return r._url
}

func (r *AppsRevokeAuthorizationForApplicationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken)
}

func (r *AppsRevokeAuthorizationForApplicationReq) method() string {
	return "DELETE"
}

func (r *AppsRevokeAuthorizationForApplicationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsRevokeAuthorizationForApplicationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsRevokeAuthorizationForApplicationReq) body() interface{} {
	return nil
}

func (r *AppsRevokeAuthorizationForApplicationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsRevokeAuthorizationForApplicationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsRevokeAuthorizationForApplicationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsRevokeAuthorizationForApplicationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsRevokeAuthorizationForApplicationReq) Rel(link RelName, resp *AppsRevokeAuthorizationForApplicationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsRevokeAuthorizationForApplicationResponse is a response for AppsRevokeAuthorizationForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
type AppsRevokeAuthorizationForApplicationResponse struct {
	response
	request *AppsRevokeAuthorizationForApplicationReq
}

/*
AppsRevokeGrantForApplication performs requests for "apps/revoke-grant-for-application"

Revoke a grant for an application.

  DELETE /applications/{client_id}/grants/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
func AppsRevokeGrantForApplication(ctx context.Context, req *AppsRevokeGrantForApplicationReq, opt ...RequestOption) (*AppsRevokeGrantForApplicationResponse, error) {
	if req == nil {
		req = new(AppsRevokeGrantForApplicationReq)
	}
	resp := &AppsRevokeGrantForApplicationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsRevokeGrantForApplication performs requests for "apps/revoke-grant-for-application"

Revoke a grant for an application.

  DELETE /applications/{client_id}/grants/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
func (c Client) AppsRevokeGrantForApplication(ctx context.Context, req *AppsRevokeGrantForApplicationReq, opt ...RequestOption) (*AppsRevokeGrantForApplicationResponse, error) {
	return AppsRevokeGrantForApplication(ctx, req, append(c, opt...)...)
}

/*
AppsRevokeGrantForApplicationReq is request data for Client.AppsRevokeGrantForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
type AppsRevokeGrantForApplicationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

func (r *AppsRevokeGrantForApplicationReq) url() string {
	return r._url
}

func (r *AppsRevokeGrantForApplicationReq) urlPath() string {
	return fmt.Sprintf("/applications/%v/grants/%v", r.ClientId, r.AccessToken)
}

func (r *AppsRevokeGrantForApplicationReq) method() string {
	return "DELETE"
}

func (r *AppsRevokeGrantForApplicationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsRevokeGrantForApplicationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsRevokeGrantForApplicationReq) body() interface{} {
	return nil
}

func (r *AppsRevokeGrantForApplicationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsRevokeGrantForApplicationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsRevokeGrantForApplicationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsRevokeGrantForApplicationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsRevokeGrantForApplicationReq) Rel(link RelName, resp *AppsRevokeGrantForApplicationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsRevokeGrantForApplicationResponse is a response for AppsRevokeGrantForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
type AppsRevokeGrantForApplicationResponse struct {
	response
	request *AppsRevokeGrantForApplicationReq
}

/*
AppsRevokeInstallationToken performs requests for "apps/revoke-installation-token"

Revoke an installation token.

  DELETE /installation/token

https://developer.github.com/v3/apps/installations/#revoke-an-installation-token
*/
func AppsRevokeInstallationToken(ctx context.Context, req *AppsRevokeInstallationTokenReq, opt ...RequestOption) (*AppsRevokeInstallationTokenResponse, error) {
	if req == nil {
		req = new(AppsRevokeInstallationTokenReq)
	}
	resp := &AppsRevokeInstallationTokenResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsRevokeInstallationToken performs requests for "apps/revoke-installation-token"

Revoke an installation token.

  DELETE /installation/token

https://developer.github.com/v3/apps/installations/#revoke-an-installation-token
*/
func (c Client) AppsRevokeInstallationToken(ctx context.Context, req *AppsRevokeInstallationTokenReq, opt ...RequestOption) (*AppsRevokeInstallationTokenResponse, error) {
	return AppsRevokeInstallationToken(ctx, req, append(c, opt...)...)
}

/*
AppsRevokeInstallationTokenReq is request data for Client.AppsRevokeInstallationToken

https://developer.github.com/v3/apps/installations/#revoke-an-installation-token
*/
type AppsRevokeInstallationTokenReq struct {
	_url string
}

func (r *AppsRevokeInstallationTokenReq) url() string {
	return r._url
}

func (r *AppsRevokeInstallationTokenReq) urlPath() string {
	return fmt.Sprintf("/installation/token")
}

func (r *AppsRevokeInstallationTokenReq) method() string {
	return "DELETE"
}

func (r *AppsRevokeInstallationTokenReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsRevokeInstallationTokenReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsRevokeInstallationTokenReq) body() interface{} {
	return nil
}

func (r *AppsRevokeInstallationTokenReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsRevokeInstallationTokenReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsRevokeInstallationTokenReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsRevokeInstallationTokenReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsRevokeInstallationTokenReq) Rel(link RelName, resp *AppsRevokeInstallationTokenResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsRevokeInstallationTokenResponse is a response for AppsRevokeInstallationToken

https://developer.github.com/v3/apps/installations/#revoke-an-installation-token
*/
type AppsRevokeInstallationTokenResponse struct {
	response
	request *AppsRevokeInstallationTokenReq
}

/*
AppsSuspendInstallation performs requests for "apps/suspend-installation"

Suspend an installation.

  PUT /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#suspend-an-installation
*/
func AppsSuspendInstallation(ctx context.Context, req *AppsSuspendInstallationReq, opt ...RequestOption) (*AppsSuspendInstallationResponse, error) {
	if req == nil {
		req = new(AppsSuspendInstallationReq)
	}
	resp := &AppsSuspendInstallationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsSuspendInstallation performs requests for "apps/suspend-installation"

Suspend an installation.

  PUT /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#suspend-an-installation
*/
func (c Client) AppsSuspendInstallation(ctx context.Context, req *AppsSuspendInstallationReq, opt ...RequestOption) (*AppsSuspendInstallationResponse, error) {
	return AppsSuspendInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsSuspendInstallationReq is request data for Client.AppsSuspendInstallation

https://developer.github.com/v3/apps/#suspend-an-installation
*/
type AppsSuspendInstallationReq struct {
	_url           string
	InstallationId int64
}

func (r *AppsSuspendInstallationReq) url() string {
	return r._url
}

func (r *AppsSuspendInstallationReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId)
}

func (r *AppsSuspendInstallationReq) method() string {
	return "PUT"
}

func (r *AppsSuspendInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsSuspendInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsSuspendInstallationReq) body() interface{} {
	return nil
}

func (r *AppsSuspendInstallationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsSuspendInstallationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsSuspendInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsSuspendInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsSuspendInstallationReq) Rel(link RelName, resp *AppsSuspendInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsSuspendInstallationResponse is a response for AppsSuspendInstallation

https://developer.github.com/v3/apps/#suspend-an-installation
*/
type AppsSuspendInstallationResponse struct {
	response
	request *AppsSuspendInstallationReq
}

/*
AppsUnsuspendInstallation performs requests for "apps/unsuspend-installation"

Unsuspend an installation.

  DELETE /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#unsuspend-an-installation
*/
func AppsUnsuspendInstallation(ctx context.Context, req *AppsUnsuspendInstallationReq, opt ...RequestOption) (*AppsUnsuspendInstallationResponse, error) {
	if req == nil {
		req = new(AppsUnsuspendInstallationReq)
	}
	resp := &AppsUnsuspendInstallationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AppsUnsuspendInstallation performs requests for "apps/unsuspend-installation"

Unsuspend an installation.

  DELETE /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#unsuspend-an-installation
*/
func (c Client) AppsUnsuspendInstallation(ctx context.Context, req *AppsUnsuspendInstallationReq, opt ...RequestOption) (*AppsUnsuspendInstallationResponse, error) {
	return AppsUnsuspendInstallation(ctx, req, append(c, opt...)...)
}

/*
AppsUnsuspendInstallationReq is request data for Client.AppsUnsuspendInstallation

https://developer.github.com/v3/apps/#unsuspend-an-installation
*/
type AppsUnsuspendInstallationReq struct {
	_url           string
	InstallationId int64
}

func (r *AppsUnsuspendInstallationReq) url() string {
	return r._url
}

func (r *AppsUnsuspendInstallationReq) urlPath() string {
	return fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId)
}

func (r *AppsUnsuspendInstallationReq) method() string {
	return "DELETE"
}

func (r *AppsUnsuspendInstallationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *AppsUnsuspendInstallationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *AppsUnsuspendInstallationReq) body() interface{} {
	return nil
}

func (r *AppsUnsuspendInstallationReq) dataStatuses() []int {
	return []int{}
}

func (r *AppsUnsuspendInstallationReq) validStatuses() []int {
	return []int{204}
}

func (r *AppsUnsuspendInstallationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *AppsUnsuspendInstallationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AppsUnsuspendInstallationReq) Rel(link RelName, resp *AppsUnsuspendInstallationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AppsUnsuspendInstallationResponse is a response for AppsUnsuspendInstallation

https://developer.github.com/v3/apps/#unsuspend-an-installation
*/
type AppsUnsuspendInstallationResponse struct {
	response
	request *AppsUnsuspendInstallationReq
}
