// Code generated by octo-go; DO NOT EDIT.

package projects

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
AddCollaborator performs requests for "projects/add-collaborator"

Add project collaborator.

  PUT /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
func AddCollaborator(ctx context.Context, req *AddCollaboratorReq, opt ...requests.Option) (*AddCollaboratorResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddCollaboratorReq)
	}
	resp := &AddCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddCollaborator performs requests for "projects/add-collaborator"

Add project collaborator.

  PUT /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
func (c Client) AddCollaborator(ctx context.Context, req *AddCollaboratorReq, opt ...requests.Option) (*AddCollaboratorResponse, error) {
	return AddCollaborator(ctx, req, append(c, opt...)...)
}

/*
AddCollaboratorReq is request data for Client.AddCollaborator

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
type AddCollaboratorReq struct {
	_url        string
	ProjectId   int64
	Username    string
	RequestBody AddCollaboratorReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AddCollaboratorReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": internal.String("application/json")},
		Method:           "PUT",
		OperationID:      "projects/add-collaborator",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v/collaborators/%v", r.ProjectId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddCollaboratorReq) Rel(link string, resp *AddCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddCollaboratorReqBody is a request body for projects/add-collaborator

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
type AddCollaboratorReqBody struct {

	// The permission to grant the collaborator.
	Permission *string `json:"permission,omitempty"`
}

/*
AddCollaboratorResponse is a response for AddCollaborator

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
type AddCollaboratorResponse struct {
	requests.Response
	request *AddCollaboratorReq
}

/*
CreateCard performs requests for "projects/create-card"

Create a project card.

  POST /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
func CreateCard(ctx context.Context, req *CreateCardReq, opt ...requests.Option) (*CreateCardResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateCardReq)
	}
	resp := &CreateCardResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProjectCard{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateCard performs requests for "projects/create-card"

Create a project card.

  POST /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
func (c Client) CreateCard(ctx context.Context, req *CreateCardReq, opt ...requests.Option) (*CreateCardResponse, error) {
	return CreateCard(ctx, req, append(c, opt...)...)
}

/*
CreateCardReq is request data for Client.CreateCard

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
type CreateCardReq struct {
	_url string

	// column_id parameter
	ColumnId    int64
	RequestBody CreateCardReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateCardReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateCardReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/create-card",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/%v/cards", r.ColumnId),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateCardReq) Rel(link string, resp *CreateCardResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateCardReqBody is a request body for projects/create-card

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
type CreateCardReqBody struct {

	// The unique identifier of the content associated with the card
	ContentId *int64 `json:"content_id"`

	// The piece of content associated with the card
	ContentType *string `json:"content_type"`
}

/*
CreateCardResponse is a response for CreateCard

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
type CreateCardResponse struct {
	requests.Response
	request *CreateCardReq
	Data    components.ProjectCard
}

/*
CreateColumn performs requests for "projects/create-column"

Create a project column.

  POST /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
func CreateColumn(ctx context.Context, req *CreateColumnReq, opt ...requests.Option) (*CreateColumnResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateColumnReq)
	}
	resp := &CreateColumnResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProjectColumn{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateColumn performs requests for "projects/create-column"

Create a project column.

  POST /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
func (c Client) CreateColumn(ctx context.Context, req *CreateColumnReq, opt ...requests.Option) (*CreateColumnResponse, error) {
	return CreateColumn(ctx, req, append(c, opt...)...)
}

/*
CreateColumnReq is request data for Client.CreateColumn

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
type CreateColumnReq struct {
	_url        string
	ProjectId   int64
	RequestBody CreateColumnReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateColumnReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateColumnReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/create-column",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v/columns", r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateColumnReq) Rel(link string, resp *CreateColumnResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateColumnReqBody is a request body for projects/create-column

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
type CreateColumnReqBody struct {

	// Name of the project column
	Name *string `json:"name"`
}

/*
CreateColumnResponse is a response for CreateColumn

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
type CreateColumnResponse struct {
	requests.Response
	request *CreateColumnReq
	Data    components.ProjectColumn
}

/*
CreateForAuthenticatedUser performs requests for "projects/create-for-authenticated-user"

Create a user project.

  POST /user/projects

https://developer.github.com/v3/projects/#create-a-user-project
*/
func CreateForAuthenticatedUser(ctx context.Context, req *CreateForAuthenticatedUserReq, opt ...requests.Option) (*CreateForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateForAuthenticatedUserReq)
	}
	resp := &CreateForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateForAuthenticatedUser performs requests for "projects/create-for-authenticated-user"

Create a user project.

  POST /user/projects

https://developer.github.com/v3/projects/#create-a-user-project
*/
func (c Client) CreateForAuthenticatedUser(ctx context.Context, req *CreateForAuthenticatedUserReq, opt ...requests.Option) (*CreateForAuthenticatedUserResponse, error) {
	return CreateForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
CreateForAuthenticatedUserReq is request data for Client.CreateForAuthenticatedUser

https://developer.github.com/v3/projects/#create-a-user-project
*/
type CreateForAuthenticatedUserReq struct {
	_url        string
	RequestBody CreateForAuthenticatedUserReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/create-for-authenticated-user",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/user/projects"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateForAuthenticatedUserReq) Rel(link string, resp *CreateForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateForAuthenticatedUserReqBody is a request body for projects/create-for-authenticated-user

https://developer.github.com/v3/projects/#create-a-user-project
*/
type CreateForAuthenticatedUserReqBody struct {

	// Body of the project
	Body *string `json:"body,omitempty"`

	// Name of the project
	Name *string `json:"name"`
}

/*
CreateForAuthenticatedUserResponse is a response for CreateForAuthenticatedUser

https://developer.github.com/v3/projects/#create-a-user-project
*/
type CreateForAuthenticatedUserResponse struct {
	requests.Response
	request *CreateForAuthenticatedUserReq
	Data    components.Project
}

/*
CreateForOrg performs requests for "projects/create-for-org"

Create an organization project.

  POST /orgs/{org}/projects

https://developer.github.com/v3/projects/#create-an-organization-project
*/
func CreateForOrg(ctx context.Context, req *CreateForOrgReq, opt ...requests.Option) (*CreateForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateForOrgReq)
	}
	resp := &CreateForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateForOrg performs requests for "projects/create-for-org"

Create an organization project.

  POST /orgs/{org}/projects

https://developer.github.com/v3/projects/#create-an-organization-project
*/
func (c Client) CreateForOrg(ctx context.Context, req *CreateForOrgReq, opt ...requests.Option) (*CreateForOrgResponse, error) {
	return CreateForOrg(ctx, req, append(c, opt...)...)
}

/*
CreateForOrgReq is request data for Client.CreateForOrg

https://developer.github.com/v3/projects/#create-an-organization-project
*/
type CreateForOrgReq struct {
	_url        string
	Org         string
	RequestBody CreateForOrgReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/create-for-org",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/orgs/%v/projects", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateForOrgReq) Rel(link string, resp *CreateForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateForOrgReqBody is a request body for projects/create-for-org

https://developer.github.com/v3/projects/#create-an-organization-project
*/
type CreateForOrgReqBody struct {

	// The description of the project.
	Body *string `json:"body,omitempty"`

	// The name of the project.
	Name *string `json:"name"`
}

/*
CreateForOrgResponse is a response for CreateForOrg

https://developer.github.com/v3/projects/#create-an-organization-project
*/
type CreateForOrgResponse struct {
	requests.Response
	request *CreateForOrgReq
	Data    components.Project
}

/*
CreateForRepo performs requests for "projects/create-for-repo"

Create a repository project.

  POST /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#create-a-repository-project
*/
func CreateForRepo(ctx context.Context, req *CreateForRepoReq, opt ...requests.Option) (*CreateForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateForRepoReq)
	}
	resp := &CreateForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateForRepo performs requests for "projects/create-for-repo"

Create a repository project.

  POST /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#create-a-repository-project
*/
func (c Client) CreateForRepo(ctx context.Context, req *CreateForRepoReq, opt ...requests.Option) (*CreateForRepoResponse, error) {
	return CreateForRepo(ctx, req, append(c, opt...)...)
}

/*
CreateForRepoReq is request data for Client.CreateForRepo

https://developer.github.com/v3/projects/#create-a-repository-project
*/
type CreateForRepoReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateForRepoReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/create-for-repo",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/projects", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateForRepoReq) Rel(link string, resp *CreateForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateForRepoReqBody is a request body for projects/create-for-repo

https://developer.github.com/v3/projects/#create-a-repository-project
*/
type CreateForRepoReqBody struct {

	// The description of the project.
	Body *string `json:"body,omitempty"`

	// The name of the project.
	Name *string `json:"name"`
}

/*
CreateForRepoResponse is a response for CreateForRepo

https://developer.github.com/v3/projects/#create-a-repository-project
*/
type CreateForRepoResponse struct {
	requests.Response
	request *CreateForRepoReq
	Data    components.Project
}

/*
Delete performs requests for "projects/delete"

Delete a project.

  DELETE /projects/{project_id}

https://developer.github.com/v3/projects/#delete-a-project
*/
func Delete(ctx context.Context, req *DeleteReq, opt ...requests.Option) (*DeleteResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteReq)
	}
	resp := &DeleteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Delete performs requests for "projects/delete"

Delete a project.

  DELETE /projects/{project_id}

https://developer.github.com/v3/projects/#delete-a-project
*/
func (c Client) Delete(ctx context.Context, req *DeleteReq, opt ...requests.Option) (*DeleteResponse, error) {
	return Delete(ctx, req, append(c, opt...)...)
}

/*
DeleteReq is request data for Client.Delete

https://developer.github.com/v3/projects/#delete-a-project
*/
type DeleteReq struct {
	_url      string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "projects/delete",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v", r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteReq) Rel(link string, resp *DeleteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteResponse is a response for Delete

https://developer.github.com/v3/projects/#delete-a-project
*/
type DeleteResponse struct {
	requests.Response
	request *DeleteReq
}

/*
DeleteCard performs requests for "projects/delete-card"

Delete a project card.

  DELETE /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
func DeleteCard(ctx context.Context, req *DeleteCardReq, opt ...requests.Option) (*DeleteCardResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteCardReq)
	}
	resp := &DeleteCardResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteCard performs requests for "projects/delete-card"

Delete a project card.

  DELETE /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
func (c Client) DeleteCard(ctx context.Context, req *DeleteCardReq, opt ...requests.Option) (*DeleteCardResponse, error) {
	return DeleteCard(ctx, req, append(c, opt...)...)
}

/*
DeleteCardReq is request data for Client.DeleteCard

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
type DeleteCardReq struct {
	_url string

	// card_id parameter
	CardId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteCardReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteCardReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "projects/delete-card",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/cards/%v", r.CardId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteCardReq) Rel(link string, resp *DeleteCardResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteCardResponse is a response for DeleteCard

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
type DeleteCardResponse struct {
	requests.Response
	request *DeleteCardReq
}

/*
DeleteColumn performs requests for "projects/delete-column"

Delete a project column.

  DELETE /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
func DeleteColumn(ctx context.Context, req *DeleteColumnReq, opt ...requests.Option) (*DeleteColumnResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteColumnReq)
	}
	resp := &DeleteColumnResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteColumn performs requests for "projects/delete-column"

Delete a project column.

  DELETE /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
func (c Client) DeleteColumn(ctx context.Context, req *DeleteColumnReq, opt ...requests.Option) (*DeleteColumnResponse, error) {
	return DeleteColumn(ctx, req, append(c, opt...)...)
}

/*
DeleteColumnReq is request data for Client.DeleteColumn

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
type DeleteColumnReq struct {
	_url string

	// column_id parameter
	ColumnId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteColumnReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteColumnReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "projects/delete-column",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/%v", r.ColumnId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteColumnReq) Rel(link string, resp *DeleteColumnResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteColumnResponse is a response for DeleteColumn

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
type DeleteColumnResponse struct {
	requests.Response
	request *DeleteColumnReq
}

/*
Get performs requests for "projects/get"

Get a project.

  GET /projects/{project_id}

https://developer.github.com/v3/projects/#get-a-project
*/
func Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetReq)
	}
	resp := &GetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Get performs requests for "projects/get"

Get a project.

  GET /projects/{project_id}

https://developer.github.com/v3/projects/#get-a-project
*/
func (c Client) Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	return Get(ctx, req, append(c, opt...)...)
}

/*
GetReq is request data for Client.Get

https://developer.github.com/v3/projects/#get-a-project
*/
type GetReq struct {
	_url      string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "projects/get",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v", r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReq) Rel(link string, resp *GetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetResponse is a response for Get

https://developer.github.com/v3/projects/#get-a-project
*/
type GetResponse struct {
	requests.Response
	request *GetReq
	Data    components.Project
}

/*
GetCard performs requests for "projects/get-card"

Get a project card.

  GET /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
func GetCard(ctx context.Context, req *GetCardReq, opt ...requests.Option) (*GetCardResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCardReq)
	}
	resp := &GetCardResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProjectCard{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetCard performs requests for "projects/get-card"

Get a project card.

  GET /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
func (c Client) GetCard(ctx context.Context, req *GetCardReq, opt ...requests.Option) (*GetCardResponse, error) {
	return GetCard(ctx, req, append(c, opt...)...)
}

/*
GetCardReq is request data for Client.GetCard

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
type GetCardReq struct {
	_url string

	// card_id parameter
	CardId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetCardReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCardReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "projects/get-card",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/cards/%v", r.CardId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCardReq) Rel(link string, resp *GetCardResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCardResponse is a response for GetCard

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
type GetCardResponse struct {
	requests.Response
	request *GetCardReq
	Data    components.ProjectCard
}

/*
GetColumn performs requests for "projects/get-column"

Get a project column.

  GET /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
func GetColumn(ctx context.Context, req *GetColumnReq, opt ...requests.Option) (*GetColumnResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetColumnReq)
	}
	resp := &GetColumnResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProjectColumn{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetColumn performs requests for "projects/get-column"

Get a project column.

  GET /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
func (c Client) GetColumn(ctx context.Context, req *GetColumnReq, opt ...requests.Option) (*GetColumnResponse, error) {
	return GetColumn(ctx, req, append(c, opt...)...)
}

/*
GetColumnReq is request data for Client.GetColumn

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
type GetColumnReq struct {
	_url string

	// column_id parameter
	ColumnId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetColumnReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetColumnReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "projects/get-column",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/%v", r.ColumnId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetColumnReq) Rel(link string, resp *GetColumnResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetColumnResponse is a response for GetColumn

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
type GetColumnResponse struct {
	requests.Response
	request *GetColumnReq
	Data    components.ProjectColumn
}

/*
GetPermissionForUser performs requests for "projects/get-permission-for-user"

Get project permission for a user.

  GET /projects/{project_id}/collaborators/{username}/permission

https://developer.github.com/v3/projects/collaborators/#get-project-permission-for-a-user
*/
func GetPermissionForUser(ctx context.Context, req *GetPermissionForUserReq, opt ...requests.Option) (*GetPermissionForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetPermissionForUserReq)
	}
	resp := &GetPermissionForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.RepositoryCollaboratorPermission{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetPermissionForUser performs requests for "projects/get-permission-for-user"

Get project permission for a user.

  GET /projects/{project_id}/collaborators/{username}/permission

https://developer.github.com/v3/projects/collaborators/#get-project-permission-for-a-user
*/
func (c Client) GetPermissionForUser(ctx context.Context, req *GetPermissionForUserReq, opt ...requests.Option) (*GetPermissionForUserResponse, error) {
	return GetPermissionForUser(ctx, req, append(c, opt...)...)
}

/*
GetPermissionForUserReq is request data for Client.GetPermissionForUser

https://developer.github.com/v3/projects/collaborators/#get-project-permission-for-a-user
*/
type GetPermissionForUserReq struct {
	_url      string
	ProjectId int64
	Username  string

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetPermissionForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetPermissionForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "projects/get-permission-for-user",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v/collaborators/%v/permission", r.ProjectId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetPermissionForUserReq) Rel(link string, resp *GetPermissionForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetPermissionForUserResponse is a response for GetPermissionForUser

https://developer.github.com/v3/projects/collaborators/#get-project-permission-for-a-user
*/
type GetPermissionForUserResponse struct {
	requests.Response
	request *GetPermissionForUserReq
	Data    components.RepositoryCollaboratorPermission
}

/*
ListCards performs requests for "projects/list-cards"

List project cards.

  GET /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
func ListCards(ctx context.Context, req *ListCardsReq, opt ...requests.Option) (*ListCardsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListCardsReq)
	}
	resp := &ListCardsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ProjectCard{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListCards performs requests for "projects/list-cards"

List project cards.

  GET /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
func (c Client) ListCards(ctx context.Context, req *ListCardsReq, opt ...requests.Option) (*ListCardsResponse, error) {
	return ListCards(ctx, req, append(c, opt...)...)
}

/*
ListCardsReq is request data for Client.ListCards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
type ListCardsReq struct {
	_url string

	// column_id parameter
	ColumnId int64

	/*
	Filters the project cards that are returned by the card's state. Can be one of
	`all`,`archived`, or `not_archived`.
	*/
	ArchivedState *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListCardsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListCardsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.ArchivedState != nil {
		query.Set("archived_state", *r.ArchivedState)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "projects/list-cards",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/%v/cards", r.ColumnId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCardsReq) Rel(link string, resp *ListCardsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCardsResponse is a response for ListCards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
type ListCardsResponse struct {
	requests.Response
	request *ListCardsReq
	Data    []components.ProjectCard
}

/*
ListCollaborators performs requests for "projects/list-collaborators"

List project collaborators.

  GET /projects/{project_id}/collaborators

https://developer.github.com/v3/projects/collaborators/#list-project-collaborators
*/
func ListCollaborators(ctx context.Context, req *ListCollaboratorsReq, opt ...requests.Option) (*ListCollaboratorsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListCollaboratorsReq)
	}
	resp := &ListCollaboratorsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListCollaborators performs requests for "projects/list-collaborators"

List project collaborators.

  GET /projects/{project_id}/collaborators

https://developer.github.com/v3/projects/collaborators/#list-project-collaborators
*/
func (c Client) ListCollaborators(ctx context.Context, req *ListCollaboratorsReq, opt ...requests.Option) (*ListCollaboratorsResponse, error) {
	return ListCollaborators(ctx, req, append(c, opt...)...)
}

/*
ListCollaboratorsReq is request data for Client.ListCollaborators

https://developer.github.com/v3/projects/collaborators/#list-project-collaborators
*/
type ListCollaboratorsReq struct {
	_url      string
	ProjectId int64

	/*
	Filters the collaborators by their affiliation. Can be one of:
	\* `outside`: Outside collaborators of a project that are not a member of the
	project's organization.
	\* `direct`: Collaborators with permissions to a project, regardless of
	organization membership status.
	\* `all`: All collaborators the authenticated user can see.
	*/
	Affiliation *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListCollaboratorsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListCollaboratorsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "projects/list-collaborators",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v/collaborators", r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCollaboratorsReq) Rel(link string, resp *ListCollaboratorsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCollaboratorsResponse is a response for ListCollaborators

https://developer.github.com/v3/projects/collaborators/#list-project-collaborators
*/
type ListCollaboratorsResponse struct {
	requests.Response
	request *ListCollaboratorsReq
	Data    []components.SimpleUser
}

/*
ListColumns performs requests for "projects/list-columns"

List project columns.

  GET /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
func ListColumns(ctx context.Context, req *ListColumnsReq, opt ...requests.Option) (*ListColumnsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListColumnsReq)
	}
	resp := &ListColumnsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ProjectColumn{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListColumns performs requests for "projects/list-columns"

List project columns.

  GET /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
func (c Client) ListColumns(ctx context.Context, req *ListColumnsReq, opt ...requests.Option) (*ListColumnsResponse, error) {
	return ListColumns(ctx, req, append(c, opt...)...)
}

/*
ListColumnsReq is request data for Client.ListColumns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
type ListColumnsReq struct {
	_url      string
	ProjectId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListColumnsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListColumnsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "projects/list-columns",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v/columns", r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListColumnsReq) Rel(link string, resp *ListColumnsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListColumnsResponse is a response for ListColumns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
type ListColumnsResponse struct {
	requests.Response
	request *ListColumnsReq
	Data    []components.ProjectColumn
}

/*
ListForOrg performs requests for "projects/list-for-org"

List organization projects.

  GET /orgs/{org}/projects

https://developer.github.com/v3/projects/#list-organization-projects
*/
func ListForOrg(ctx context.Context, req *ListForOrgReq, opt ...requests.Option) (*ListForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForOrgReq)
	}
	resp := &ListForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForOrg performs requests for "projects/list-for-org"

List organization projects.

  GET /orgs/{org}/projects

https://developer.github.com/v3/projects/#list-organization-projects
*/
func (c Client) ListForOrg(ctx context.Context, req *ListForOrgReq, opt ...requests.Option) (*ListForOrgResponse, error) {
	return ListForOrg(ctx, req, append(c, opt...)...)
}

/*
ListForOrgReq is request data for Client.ListForOrg

https://developer.github.com/v3/projects/#list-organization-projects
*/
type ListForOrgReq struct {
	_url string
	Org  string

	/*
	Indicates the state of the projects to return. Can be either `open`, `closed`,
	or `all`.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "projects/list-for-org",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/orgs/%v/projects", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForOrgReq) Rel(link string, resp *ListForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForOrgResponse is a response for ListForOrg

https://developer.github.com/v3/projects/#list-organization-projects
*/
type ListForOrgResponse struct {
	requests.Response
	request *ListForOrgReq
	Data    []components.Project
}

/*
ListForRepo performs requests for "projects/list-for-repo"

List repository projects.

  GET /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#list-repository-projects
*/
func ListForRepo(ctx context.Context, req *ListForRepoReq, opt ...requests.Option) (*ListForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForRepoReq)
	}
	resp := &ListForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForRepo performs requests for "projects/list-for-repo"

List repository projects.

  GET /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#list-repository-projects
*/
func (c Client) ListForRepo(ctx context.Context, req *ListForRepoReq, opt ...requests.Option) (*ListForRepoResponse, error) {
	return ListForRepo(ctx, req, append(c, opt...)...)
}

/*
ListForRepoReq is request data for Client.ListForRepo

https://developer.github.com/v3/projects/#list-repository-projects
*/
type ListForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Indicates the state of the projects to return. Can be either `open`, `closed`,
	or `all`.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "projects/list-for-repo",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/projects", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForRepoReq) Rel(link string, resp *ListForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForRepoResponse is a response for ListForRepo

https://developer.github.com/v3/projects/#list-repository-projects
*/
type ListForRepoResponse struct {
	requests.Response
	request *ListForRepoReq
	Data    []components.Project
}

/*
ListForUser performs requests for "projects/list-for-user"

List user projects.

  GET /users/{username}/projects

https://developer.github.com/v3/projects/#list-user-projects
*/
func ListForUser(ctx context.Context, req *ListForUserReq, opt ...requests.Option) (*ListForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForUserReq)
	}
	resp := &ListForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForUser performs requests for "projects/list-for-user"

List user projects.

  GET /users/{username}/projects

https://developer.github.com/v3/projects/#list-user-projects
*/
func (c Client) ListForUser(ctx context.Context, req *ListForUserReq, opt ...requests.Option) (*ListForUserResponse, error) {
	return ListForUser(ctx, req, append(c, opt...)...)
}

/*
ListForUserReq is request data for Client.ListForUser

https://developer.github.com/v3/projects/#list-user-projects
*/
type ListForUserReq struct {
	_url     string
	Username string

	/*
	Indicates the state of the projects to return. Can be either `open`, `closed`,
	or `all`.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "projects/list-for-user",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/users/%v/projects", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForUserReq) Rel(link string, resp *ListForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForUserResponse is a response for ListForUser

https://developer.github.com/v3/projects/#list-user-projects
*/
type ListForUserResponse struct {
	requests.Response
	request *ListForUserReq
	Data    []components.Project
}

/*
MoveCard performs requests for "projects/move-card"

Move a project card.

  POST /projects/columns/cards/{card_id}/moves

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
func MoveCard(ctx context.Context, req *MoveCardReq, opt ...requests.Option) (*MoveCardResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MoveCardReq)
	}
	resp := &MoveCardResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MoveCard performs requests for "projects/move-card"

Move a project card.

  POST /projects/columns/cards/{card_id}/moves

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
func (c Client) MoveCard(ctx context.Context, req *MoveCardReq, opt ...requests.Option) (*MoveCardResponse, error) {
	return MoveCard(ctx, req, append(c, opt...)...)
}

/*
MoveCardReq is request data for Client.MoveCard

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
type MoveCardReq struct {
	_url string

	// card_id parameter
	CardId      int64
	RequestBody MoveCardReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *MoveCardReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MoveCardReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/move-card",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/cards/%v/moves", r.CardId),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MoveCardReq) Rel(link string, resp *MoveCardResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MoveCardReqBody is a request body for projects/move-card

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
type MoveCardReqBody struct {

	// The unique identifier of the column the card should be moved to
	ColumnId *int64 `json:"column_id,omitempty"`

	// The position of the card in a column
	Position *string `json:"position"`
}

/*
MoveCardResponse is a response for MoveCard

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
type MoveCardResponse struct {
	requests.Response
	request *MoveCardReq
}

/*
MoveColumn performs requests for "projects/move-column"

Move a project column.

  POST /projects/columns/{column_id}/moves

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
func MoveColumn(ctx context.Context, req *MoveColumnReq, opt ...requests.Option) (*MoveColumnResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MoveColumnReq)
	}
	resp := &MoveColumnResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MoveColumn performs requests for "projects/move-column"

Move a project column.

  POST /projects/columns/{column_id}/moves

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
func (c Client) MoveColumn(ctx context.Context, req *MoveColumnReq, opt ...requests.Option) (*MoveColumnResponse, error) {
	return MoveColumn(ctx, req, append(c, opt...)...)
}

/*
MoveColumnReq is request data for Client.MoveColumn

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
type MoveColumnReq struct {
	_url string

	// column_id parameter
	ColumnId    int64
	RequestBody MoveColumnReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *MoveColumnReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MoveColumnReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/move-column",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/%v/moves", r.ColumnId),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MoveColumnReq) Rel(link string, resp *MoveColumnResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MoveColumnReqBody is a request body for projects/move-column

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
type MoveColumnReqBody struct {

	// The position of the column in a project
	Position *string `json:"position"`
}

/*
MoveColumnResponse is a response for MoveColumn

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
type MoveColumnResponse struct {
	requests.Response
	request *MoveColumnReq
}

/*
RemoveCollaborator performs requests for "projects/remove-collaborator"

Remove user as a collaborator.

  DELETE /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#remove-project-collaborator
*/
func RemoveCollaborator(ctx context.Context, req *RemoveCollaboratorReq, opt ...requests.Option) (*RemoveCollaboratorResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveCollaboratorReq)
	}
	resp := &RemoveCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveCollaborator performs requests for "projects/remove-collaborator"

Remove user as a collaborator.

  DELETE /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#remove-project-collaborator
*/
func (c Client) RemoveCollaborator(ctx context.Context, req *RemoveCollaboratorReq, opt ...requests.Option) (*RemoveCollaboratorResponse, error) {
	return RemoveCollaborator(ctx, req, append(c, opt...)...)
}

/*
RemoveCollaboratorReq is request data for Client.RemoveCollaborator

https://developer.github.com/v3/projects/collaborators/#remove-project-collaborator
*/
type RemoveCollaboratorReq struct {
	_url      string
	ProjectId int64
	Username  string

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *RemoveCollaboratorReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "projects/remove-collaborator",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v/collaborators/%v", r.ProjectId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveCollaboratorReq) Rel(link string, resp *RemoveCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveCollaboratorResponse is a response for RemoveCollaborator

https://developer.github.com/v3/projects/collaborators/#remove-project-collaborator
*/
type RemoveCollaboratorResponse struct {
	requests.Response
	request *RemoveCollaboratorReq
}

/*
Update performs requests for "projects/update"

Update a project.

  PATCH /projects/{project_id}

https://developer.github.com/v3/projects/#update-a-project
*/
func Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateReq)
	}
	resp := &UpdateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Update performs requests for "projects/update"

Update a project.

  PATCH /projects/{project_id}

https://developer.github.com/v3/projects/#update-a-project
*/
func (c Client) Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	return Update(ctx, req, append(c, opt...)...)
}

/*
UpdateReq is request data for Client.Update

https://developer.github.com/v3/projects/#update-a-project
*/
type UpdateReq struct {
	_url        string
	ProjectId   int64
	RequestBody UpdateReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "projects/update",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v", r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReq) Rel(link string, resp *UpdateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateReqBody is a request body for projects/update

https://developer.github.com/v3/projects/#update-a-project
*/
type UpdateReqBody struct {

	// Body of the project
	Body *string `json:"body,omitempty"`

	// Name of the project
	Name *string `json:"name,omitempty"`

	// The baseline permission that all organization members have on this project
	OrganizationPermission *string `json:"organization_permission,omitempty"`

	// Whether or not this project can be seen by everyone.
	Private *bool `json:"private,omitempty"`

	// State of the project; either 'open' or 'closed'
	State *string `json:"state,omitempty"`
}

/*
UpdateResponse is a response for Update

https://developer.github.com/v3/projects/#update-a-project
*/
type UpdateResponse struct {
	requests.Response
	request *UpdateReq
	Data    components.Project
}

/*
UpdateCard performs requests for "projects/update-card"

Update an existing project card.

  PATCH /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
func UpdateCard(ctx context.Context, req *UpdateCardReq, opt ...requests.Option) (*UpdateCardResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateCardReq)
	}
	resp := &UpdateCardResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProjectCard{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateCard performs requests for "projects/update-card"

Update an existing project card.

  PATCH /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
func (c Client) UpdateCard(ctx context.Context, req *UpdateCardReq, opt ...requests.Option) (*UpdateCardResponse, error) {
	return UpdateCard(ctx, req, append(c, opt...)...)
}

/*
UpdateCardReq is request data for Client.UpdateCard

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
type UpdateCardReq struct {
	_url string

	// card_id parameter
	CardId      int64
	RequestBody UpdateCardReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateCardReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateCardReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "projects/update-card",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/cards/%v", r.CardId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateCardReq) Rel(link string, resp *UpdateCardResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateCardReqBody is a request body for projects/update-card

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
type UpdateCardReqBody struct {

	// Whether or not the card is archived
	Archived *bool `json:"archived,omitempty"`

	// The project card's note
	Note *string `json:"note,omitempty"`
}

/*
UpdateCardResponse is a response for UpdateCard

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
type UpdateCardResponse struct {
	requests.Response
	request *UpdateCardReq
	Data    components.ProjectCard
}

/*
UpdateColumn performs requests for "projects/update-column"

Update an existing project column.

  PATCH /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
func UpdateColumn(ctx context.Context, req *UpdateColumnReq, opt ...requests.Option) (*UpdateColumnResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateColumnReq)
	}
	resp := &UpdateColumnResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProjectColumn{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateColumn performs requests for "projects/update-column"

Update an existing project column.

  PATCH /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
func (c Client) UpdateColumn(ctx context.Context, req *UpdateColumnReq, opt ...requests.Option) (*UpdateColumnResponse, error) {
	return UpdateColumn(ctx, req, append(c, opt...)...)
}

/*
UpdateColumnReq is request data for Client.UpdateColumn

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
type UpdateColumnReq struct {
	_url string

	// column_id parameter
	ColumnId    int64
	RequestBody UpdateColumnReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateColumnReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateColumnReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "projects/update-column",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/%v", r.ColumnId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateColumnReq) Rel(link string, resp *UpdateColumnResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateColumnReqBody is a request body for projects/update-column

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
type UpdateColumnReqBody struct {

	// Name of the project column
	Name *string `json:"name"`
}

/*
UpdateColumnResponse is a response for UpdateColumn

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
type UpdateColumnResponse struct {
	requests.Response
	request *UpdateColumnReq
	Data    components.ProjectColumn
}
