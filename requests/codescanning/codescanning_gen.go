// Code generated by octo-go; DO NOT EDIT.

package codescanning

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
)

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
GetAlert performs requests for "code-scanning/get-alert"

Get a code scanning alert.

  GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_id}

https://developer.github.com/v3/code-scanning/#get-a-code-scanning-alert
*/
func GetAlert(ctx context.Context, req *GetAlertReq, opt ...requests.Option) (*GetAlertResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetAlertReq)
	}
	resp := &GetAlertResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetAlert performs requests for "code-scanning/get-alert"

Get a code scanning alert.

  GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_id}

https://developer.github.com/v3/code-scanning/#get-a-code-scanning-alert

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetAlert(ctx context.Context, req *GetAlertReq, opt ...requests.Option) (*GetAlertResponse, error) {
	return GetAlert(ctx, req, append(c, opt...)...)
}

/*
GetAlertReq is request data for Client.GetAlert

https://developer.github.com/v3/code-scanning/#get-a-code-scanning-alert

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetAlertReq struct {
	_url  string
	Owner string
	Repo  string

	// alert_id parameter
	AlertId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetAlertReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/code-scanning/alerts/%v", r.Owner, r.Repo, r.AlertId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetAlertReq) Rel(link string, resp *GetAlertResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetAlertResponse is a response for GetAlert

https://developer.github.com/v3/code-scanning/#get-a-code-scanning-alert
*/
type GetAlertResponse struct {
	httpResponse *http.Response
	Data         components.CodeScanningAlert
}

// HTTPResponse returns the *http.Response
func (r *GetAlertResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetAlertResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListAlertsForRepo performs requests for "code-scanning/list-alerts-for-repo"

List code scanning alerts for a repository.

  GET /repos/{owner}/{repo}/code-scanning/alerts

https://developer.github.com/v3/code-scanning/#list-code-scanning-alerts-for-a-repository
*/
func ListAlertsForRepo(ctx context.Context, req *ListAlertsForRepoReq, opt ...requests.Option) (*ListAlertsForRepoResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListAlertsForRepoReq)
	}
	resp := &ListAlertsForRepoResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListAlertsForRepo performs requests for "code-scanning/list-alerts-for-repo"

List code scanning alerts for a repository.

  GET /repos/{owner}/{repo}/code-scanning/alerts

https://developer.github.com/v3/code-scanning/#list-code-scanning-alerts-for-a-repository

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListAlertsForRepo(ctx context.Context, req *ListAlertsForRepoReq, opt ...requests.Option) (*ListAlertsForRepoResponse, error) {
	return ListAlertsForRepo(ctx, req, append(c, opt...)...)
}

/*
ListAlertsForRepoReq is request data for Client.ListAlertsForRepo

https://developer.github.com/v3/code-scanning/#list-code-scanning-alerts-for-a-repository

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListAlertsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Set to `closed` to list only closed code scanning alerts.
	State *string

	/*
	Returns a list of code scanning alerts for a specific brach reference. The `ref`
	must be formatted as `heads/<branch name>`.
	*/
	Ref *string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListAlertsForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/code-scanning/alerts", r.Owner, r.Repo),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListAlertsForRepoReq) Rel(link string, resp *ListAlertsForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListAlertsForRepoResponse is a response for ListAlertsForRepo

https://developer.github.com/v3/code-scanning/#list-code-scanning-alerts-for-a-repository
*/
type ListAlertsForRepoResponse struct {
	httpResponse *http.Response
	Data         []components.CodeScanningAlert
}

// HTTPResponse returns the *http.Response
func (r *ListAlertsForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListAlertsForRepoResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}
