// Code generated by octo-go; DO NOT EDIT.

package actions

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
AddSelectedRepoToOrgSecret performs requests for "actions/add-selected-repo-to-org-secret"

Add selected repository to an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
func AddSelectedRepoToOrgSecret(ctx context.Context, req *AddSelectedRepoToOrgSecretReq, opt ...requests.Option) (*AddSelectedRepoToOrgSecretResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddSelectedRepoToOrgSecretReq)
	}
	resp := &AddSelectedRepoToOrgSecretResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewAddSelectedRepoToOrgSecretResponse(r, opts.PreserveResponseBody())
}

// NewAddSelectedRepoToOrgSecretResponse builds a new *AddSelectedRepoToOrgSecretResponse from an *http.Response
func NewAddSelectedRepoToOrgSecretResponse(resp *http.Response, preserveBody bool) (*AddSelectedRepoToOrgSecretResponse, error) {
	var result AddSelectedRepoToOrgSecretResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
AddSelectedRepoToOrgSecret performs requests for "actions/add-selected-repo-to-org-secret"

Add selected repository to an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
func (c Client) AddSelectedRepoToOrgSecret(ctx context.Context, req *AddSelectedRepoToOrgSecretReq, opt ...requests.Option) (*AddSelectedRepoToOrgSecretResponse, error) {
	return AddSelectedRepoToOrgSecret(ctx, req, append(c, opt...)...)
}

/*
AddSelectedRepoToOrgSecretReq is request data for Client.AddSelectedRepoToOrgSecret

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
type AddSelectedRepoToOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string

	// repository_id parameter
	RepositoryId int64
}

// HTTPRequest builds an *http.Request
func (r *AddSelectedRepoToOrgSecretReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddSelectedRepoToOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "actions/add-selected-repo-to-org-secret",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories/%v", r.Org, r.SecretName, r.RepositoryId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddSelectedRepoToOrgSecretReq) Rel(link string, resp *AddSelectedRepoToOrgSecretResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddSelectedRepoToOrgSecretResponse is a response for AddSelectedRepoToOrgSecret

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
type AddSelectedRepoToOrgSecretResponse struct {
	httpResponse *http.Response
}

func (r *AddSelectedRepoToOrgSecretResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CancelWorkflowRun performs requests for "actions/cancel-workflow-run"

Cancel a workflow run.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
func CancelWorkflowRun(ctx context.Context, req *CancelWorkflowRunReq, opt ...requests.Option) (*CancelWorkflowRunResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CancelWorkflowRunReq)
	}
	resp := &CancelWorkflowRunResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCancelWorkflowRunResponse(r, opts.PreserveResponseBody())
}

// NewCancelWorkflowRunResponse builds a new *CancelWorkflowRunResponse from an *http.Response
func NewCancelWorkflowRunResponse(resp *http.Response, preserveBody bool) (*CancelWorkflowRunResponse, error) {
	var result CancelWorkflowRunResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{202})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CancelWorkflowRun performs requests for "actions/cancel-workflow-run"

Cancel a workflow run.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
func (c Client) CancelWorkflowRun(ctx context.Context, req *CancelWorkflowRunReq, opt ...requests.Option) (*CancelWorkflowRunResponse, error) {
	return CancelWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
CancelWorkflowRunReq is request data for Client.CancelWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
type CancelWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *CancelWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CancelWorkflowRunReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "POST",
		OperationID:        "actions/cancel-workflow-run",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runs/%v/cancel", r.Owner, r.Repo, r.RunId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CancelWorkflowRunReq) Rel(link string, resp *CancelWorkflowRunResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CancelWorkflowRunResponse is a response for CancelWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
type CancelWorkflowRunResponse struct {
	httpResponse *http.Response
}

func (r *CancelWorkflowRunResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateOrUpdateOrgSecret performs requests for "actions/create-or-update-org-secret"

Create or update an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
func CreateOrUpdateOrgSecret(ctx context.Context, req *CreateOrUpdateOrgSecretReq, opt ...requests.Option) (*CreateOrUpdateOrgSecretResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateOrUpdateOrgSecretReq)
	}
	resp := &CreateOrUpdateOrgSecretResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateOrUpdateOrgSecretResponse(r, opts.PreserveResponseBody())
}

// NewCreateOrUpdateOrgSecretResponse builds a new *CreateOrUpdateOrgSecretResponse from an *http.Response
func NewCreateOrUpdateOrgSecretResponse(resp *http.Response, preserveBody bool) (*CreateOrUpdateOrgSecretResponse, error) {
	var result CreateOrUpdateOrgSecretResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201, 204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CreateOrUpdateOrgSecret performs requests for "actions/create-or-update-org-secret"

Create or update an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
func (c Client) CreateOrUpdateOrgSecret(ctx context.Context, req *CreateOrUpdateOrgSecretReq, opt ...requests.Option) (*CreateOrUpdateOrgSecretResponse, error) {
	return CreateOrUpdateOrgSecret(ctx, req, append(c, opt...)...)
}

/*
CreateOrUpdateOrgSecretReq is request data for Client.CreateOrUpdateOrgSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
type CreateOrUpdateOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName  string
	RequestBody CreateOrUpdateOrgSecretReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateOrUpdateOrgSecretReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateOrUpdateOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "PUT",
		OperationID:        "actions/create-or-update-org-secret",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/secrets/%v", r.Org, r.SecretName),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateOrUpdateOrgSecretReq) Rel(link string, resp *CreateOrUpdateOrgSecretResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateOrUpdateOrgSecretReqBody is a request body for actions/create-or-update-org-secret

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
type CreateOrUpdateOrgSecretReqBody struct {

	/*
	Value for your secret, encrypted with
	[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using
	the public key retrieved from the [Get an organization public
	key](https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key)
	endpoint.
	*/
	EncryptedValue *string `json:"encrypted_value,omitempty"`

	// ID of the key you used to encrypt the secret.
	KeyId *string `json:"key_id,omitempty"`

	/*
	An array of repository ids that can access the organization secret. You can only
	provide a list of repository ids when the `visibility` is set to `selected`. You
	can manage the list of selected repositories using the [List selected
	repositories for an organization
	secret](https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret),
	[Set selected repositories for an organization
	secret](https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret),
	and [Remove selected repository from an organization
	secret](https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret)
	endpoints.
	*/
	SelectedRepositoryIds []string `json:"selected_repository_ids,omitempty"`

	/*
	Configures the access that repositories have to the organization secret. Can be
	one of:
	\- `all` - All repositories in an organization can access the secret.
	\- `private` - Private repositories in an organization can access the secret.
	\- `selected` - Only specific repositories can access the secret.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
CreateOrUpdateOrgSecretResponse is a response for CreateOrUpdateOrgSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
type CreateOrUpdateOrgSecretResponse struct {
	httpResponse *http.Response
}

func (r *CreateOrUpdateOrgSecretResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateOrUpdateRepoSecret performs requests for "actions/create-or-update-repo-secret"

Create or update a repository secret.

  PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
func CreateOrUpdateRepoSecret(ctx context.Context, req *CreateOrUpdateRepoSecretReq, opt ...requests.Option) (*CreateOrUpdateRepoSecretResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateOrUpdateRepoSecretReq)
	}
	resp := &CreateOrUpdateRepoSecretResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateOrUpdateRepoSecretResponse(r, opts.PreserveResponseBody())
}

// NewCreateOrUpdateRepoSecretResponse builds a new *CreateOrUpdateRepoSecretResponse from an *http.Response
func NewCreateOrUpdateRepoSecretResponse(resp *http.Response, preserveBody bool) (*CreateOrUpdateRepoSecretResponse, error) {
	var result CreateOrUpdateRepoSecretResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201, 204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CreateOrUpdateRepoSecret performs requests for "actions/create-or-update-repo-secret"

Create or update a repository secret.

  PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
func (c Client) CreateOrUpdateRepoSecret(ctx context.Context, req *CreateOrUpdateRepoSecretReq, opt ...requests.Option) (*CreateOrUpdateRepoSecretResponse, error) {
	return CreateOrUpdateRepoSecret(ctx, req, append(c, opt...)...)
}

/*
CreateOrUpdateRepoSecretReq is request data for Client.CreateOrUpdateRepoSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
type CreateOrUpdateRepoSecretReq struct {
	_url  string
	Owner string
	Repo  string

	// secret_name parameter
	SecretName  string
	RequestBody CreateOrUpdateRepoSecretReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateOrUpdateRepoSecretReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateOrUpdateRepoSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "PUT",
		OperationID:        "actions/create-or-update-repo-secret",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/secrets/%v", r.Owner, r.Repo, r.SecretName),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateOrUpdateRepoSecretReq) Rel(link string, resp *CreateOrUpdateRepoSecretResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateOrUpdateRepoSecretReqBody is a request body for actions/create-or-update-repo-secret

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
type CreateOrUpdateRepoSecretReqBody struct {

	/*
	Value for your secret, encrypted with
	[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using
	the public key retrieved from the [Get a repository public
	key](https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key)
	endpoint.
	*/
	EncryptedValue *string `json:"encrypted_value,omitempty"`

	// ID of the key you used to encrypt the secret.
	KeyId *string `json:"key_id,omitempty"`
}

/*
CreateOrUpdateRepoSecretResponse is a response for CreateOrUpdateRepoSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
type CreateOrUpdateRepoSecretResponse struct {
	httpResponse *http.Response
}

func (r *CreateOrUpdateRepoSecretResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateRegistrationTokenForOrg performs requests for "actions/create-registration-token-for-org"

Create a registration token for an organization.

  POST /orgs/{org}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
func CreateRegistrationTokenForOrg(ctx context.Context, req *CreateRegistrationTokenForOrgReq, opt ...requests.Option) (*CreateRegistrationTokenForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateRegistrationTokenForOrgReq)
	}
	resp := &CreateRegistrationTokenForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateRegistrationTokenForOrgResponse(r, opts.PreserveResponseBody())
}

// NewCreateRegistrationTokenForOrgResponse builds a new *CreateRegistrationTokenForOrgResponse from an *http.Response
func NewCreateRegistrationTokenForOrgResponse(resp *http.Response, preserveBody bool) (*CreateRegistrationTokenForOrgResponse, error) {
	var result CreateRegistrationTokenForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateRegistrationTokenForOrg performs requests for "actions/create-registration-token-for-org"

Create a registration token for an organization.

  POST /orgs/{org}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
func (c Client) CreateRegistrationTokenForOrg(ctx context.Context, req *CreateRegistrationTokenForOrgReq, opt ...requests.Option) (*CreateRegistrationTokenForOrgResponse, error) {
	return CreateRegistrationTokenForOrg(ctx, req, append(c, opt...)...)
}

/*
CreateRegistrationTokenForOrgReq is request data for Client.CreateRegistrationTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
type CreateRegistrationTokenForOrgReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *CreateRegistrationTokenForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateRegistrationTokenForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "POST",
		OperationID:        "actions/create-registration-token-for-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/runners/registration-token", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateRegistrationTokenForOrgReq) Rel(link string, resp *CreateRegistrationTokenForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateRegistrationTokenForOrgResponse is a response for CreateRegistrationTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
type CreateRegistrationTokenForOrgResponse struct {
	httpResponse *http.Response
	Data         components.AuthenticationToken
}

func (r *CreateRegistrationTokenForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateRegistrationTokenForRepo performs requests for "actions/create-registration-token-for-repo"

Create a registration token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
func CreateRegistrationTokenForRepo(ctx context.Context, req *CreateRegistrationTokenForRepoReq, opt ...requests.Option) (*CreateRegistrationTokenForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateRegistrationTokenForRepoReq)
	}
	resp := &CreateRegistrationTokenForRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateRegistrationTokenForRepoResponse(r, opts.PreserveResponseBody())
}

// NewCreateRegistrationTokenForRepoResponse builds a new *CreateRegistrationTokenForRepoResponse from an *http.Response
func NewCreateRegistrationTokenForRepoResponse(resp *http.Response, preserveBody bool) (*CreateRegistrationTokenForRepoResponse, error) {
	var result CreateRegistrationTokenForRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateRegistrationTokenForRepo performs requests for "actions/create-registration-token-for-repo"

Create a registration token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
func (c Client) CreateRegistrationTokenForRepo(ctx context.Context, req *CreateRegistrationTokenForRepoReq, opt ...requests.Option) (*CreateRegistrationTokenForRepoResponse, error) {
	return CreateRegistrationTokenForRepo(ctx, req, append(c, opt...)...)
}

/*
CreateRegistrationTokenForRepoReq is request data for Client.CreateRegistrationTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
type CreateRegistrationTokenForRepoReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *CreateRegistrationTokenForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateRegistrationTokenForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "POST",
		OperationID:        "actions/create-registration-token-for-repo",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runners/registration-token", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateRegistrationTokenForRepoReq) Rel(link string, resp *CreateRegistrationTokenForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateRegistrationTokenForRepoResponse is a response for CreateRegistrationTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
type CreateRegistrationTokenForRepoResponse struct {
	httpResponse *http.Response
	Data         components.AuthenticationToken
}

func (r *CreateRegistrationTokenForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateRemoveTokenForOrg performs requests for "actions/create-remove-token-for-org"

Create a remove token for an organization.

  POST /orgs/{org}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
func CreateRemoveTokenForOrg(ctx context.Context, req *CreateRemoveTokenForOrgReq, opt ...requests.Option) (*CreateRemoveTokenForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateRemoveTokenForOrgReq)
	}
	resp := &CreateRemoveTokenForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateRemoveTokenForOrgResponse(r, opts.PreserveResponseBody())
}

// NewCreateRemoveTokenForOrgResponse builds a new *CreateRemoveTokenForOrgResponse from an *http.Response
func NewCreateRemoveTokenForOrgResponse(resp *http.Response, preserveBody bool) (*CreateRemoveTokenForOrgResponse, error) {
	var result CreateRemoveTokenForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateRemoveTokenForOrg performs requests for "actions/create-remove-token-for-org"

Create a remove token for an organization.

  POST /orgs/{org}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
func (c Client) CreateRemoveTokenForOrg(ctx context.Context, req *CreateRemoveTokenForOrgReq, opt ...requests.Option) (*CreateRemoveTokenForOrgResponse, error) {
	return CreateRemoveTokenForOrg(ctx, req, append(c, opt...)...)
}

/*
CreateRemoveTokenForOrgReq is request data for Client.CreateRemoveTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
type CreateRemoveTokenForOrgReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *CreateRemoveTokenForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateRemoveTokenForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "POST",
		OperationID:        "actions/create-remove-token-for-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/runners/remove-token", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateRemoveTokenForOrgReq) Rel(link string, resp *CreateRemoveTokenForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateRemoveTokenForOrgResponse is a response for CreateRemoveTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
type CreateRemoveTokenForOrgResponse struct {
	httpResponse *http.Response
	Data         components.AuthenticationToken
}

func (r *CreateRemoveTokenForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateRemoveTokenForRepo performs requests for "actions/create-remove-token-for-repo"

Create a remove token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
func CreateRemoveTokenForRepo(ctx context.Context, req *CreateRemoveTokenForRepoReq, opt ...requests.Option) (*CreateRemoveTokenForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateRemoveTokenForRepoReq)
	}
	resp := &CreateRemoveTokenForRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateRemoveTokenForRepoResponse(r, opts.PreserveResponseBody())
}

// NewCreateRemoveTokenForRepoResponse builds a new *CreateRemoveTokenForRepoResponse from an *http.Response
func NewCreateRemoveTokenForRepoResponse(resp *http.Response, preserveBody bool) (*CreateRemoveTokenForRepoResponse, error) {
	var result CreateRemoveTokenForRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateRemoveTokenForRepo performs requests for "actions/create-remove-token-for-repo"

Create a remove token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
func (c Client) CreateRemoveTokenForRepo(ctx context.Context, req *CreateRemoveTokenForRepoReq, opt ...requests.Option) (*CreateRemoveTokenForRepoResponse, error) {
	return CreateRemoveTokenForRepo(ctx, req, append(c, opt...)...)
}

/*
CreateRemoveTokenForRepoReq is request data for Client.CreateRemoveTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
type CreateRemoveTokenForRepoReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *CreateRemoveTokenForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateRemoveTokenForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "POST",
		OperationID:        "actions/create-remove-token-for-repo",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runners/remove-token", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateRemoveTokenForRepoReq) Rel(link string, resp *CreateRemoveTokenForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateRemoveTokenForRepoResponse is a response for CreateRemoveTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
type CreateRemoveTokenForRepoResponse struct {
	httpResponse *http.Response
	Data         components.AuthenticationToken
}

func (r *CreateRemoveTokenForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateWorkflowDispatch performs requests for "actions/create-workflow-dispatch"

Create a workflow dispatch event.

  POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
func CreateWorkflowDispatch(ctx context.Context, req *CreateWorkflowDispatchReq, opt ...requests.Option) (*CreateWorkflowDispatchResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateWorkflowDispatchReq)
	}
	resp := &CreateWorkflowDispatchResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateWorkflowDispatchResponse(r, opts.PreserveResponseBody())
}

// NewCreateWorkflowDispatchResponse builds a new *CreateWorkflowDispatchResponse from an *http.Response
func NewCreateWorkflowDispatchResponse(resp *http.Response, preserveBody bool) (*CreateWorkflowDispatchResponse, error) {
	var result CreateWorkflowDispatchResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CreateWorkflowDispatch performs requests for "actions/create-workflow-dispatch"

Create a workflow dispatch event.

  POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
func (c Client) CreateWorkflowDispatch(ctx context.Context, req *CreateWorkflowDispatchReq, opt ...requests.Option) (*CreateWorkflowDispatchResponse, error) {
	return CreateWorkflowDispatch(ctx, req, append(c, opt...)...)
}

/*
CreateWorkflowDispatchReq is request data for Client.CreateWorkflowDispatch

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
type CreateWorkflowDispatchReq struct {
	_url        string
	Owner       string
	Repo        string
	WorkflowId  int64
	RequestBody CreateWorkflowDispatchReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateWorkflowDispatchReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateWorkflowDispatchReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "POST",
		OperationID:        "actions/create-workflow-dispatch",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/workflows/%v/dispatches", r.Owner, r.Repo, r.WorkflowId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateWorkflowDispatchReq) Rel(link string, resp *CreateWorkflowDispatchResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateWorkflowDispatchReqBody is a request body for actions/create-workflow-dispatch

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
type CreateWorkflowDispatchReqBody struct {

	/*
	Input keys and values configured in the workflow file. The maximum number of
	properties is 10. Any default properties configured in the workflow file will be
	used when `inputs` are omitted.
	*/
	Inputs map[string]string `json:"inputs,omitempty"`

	// The reference of the workflow run. The reference can be a branch, tag, or a commit SHA.
	Ref *string `json:"ref"`
}

/*
CreateWorkflowDispatchResponse is a response for CreateWorkflowDispatch

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
type CreateWorkflowDispatchResponse struct {
	httpResponse *http.Response
}

func (r *CreateWorkflowDispatchResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteArtifact performs requests for "actions/delete-artifact"

Delete an artifact.

  DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
func DeleteArtifact(ctx context.Context, req *DeleteArtifactReq, opt ...requests.Option) (*DeleteArtifactResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteArtifactReq)
	}
	resp := &DeleteArtifactResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteArtifactResponse(r, opts.PreserveResponseBody())
}

// NewDeleteArtifactResponse builds a new *DeleteArtifactResponse from an *http.Response
func NewDeleteArtifactResponse(resp *http.Response, preserveBody bool) (*DeleteArtifactResponse, error) {
	var result DeleteArtifactResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteArtifact performs requests for "actions/delete-artifact"

Delete an artifact.

  DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
func (c Client) DeleteArtifact(ctx context.Context, req *DeleteArtifactReq, opt ...requests.Option) (*DeleteArtifactResponse, error) {
	return DeleteArtifact(ctx, req, append(c, opt...)...)
}

/*
DeleteArtifactReq is request data for Client.DeleteArtifact

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
type DeleteArtifactReq struct {
	_url  string
	Owner string
	Repo  string

	// artifact_id parameter
	ArtifactId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteArtifactReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteArtifactReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "actions/delete-artifact",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/artifacts/%v", r.Owner, r.Repo, r.ArtifactId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteArtifactReq) Rel(link string, resp *DeleteArtifactResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteArtifactResponse is a response for DeleteArtifact

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
type DeleteArtifactResponse struct {
	httpResponse *http.Response
}

func (r *DeleteArtifactResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteOrgSecret performs requests for "actions/delete-org-secret"

Delete an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
func DeleteOrgSecret(ctx context.Context, req *DeleteOrgSecretReq, opt ...requests.Option) (*DeleteOrgSecretResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteOrgSecretReq)
	}
	resp := &DeleteOrgSecretResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteOrgSecretResponse(r, opts.PreserveResponseBody())
}

// NewDeleteOrgSecretResponse builds a new *DeleteOrgSecretResponse from an *http.Response
func NewDeleteOrgSecretResponse(resp *http.Response, preserveBody bool) (*DeleteOrgSecretResponse, error) {
	var result DeleteOrgSecretResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteOrgSecret performs requests for "actions/delete-org-secret"

Delete an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
func (c Client) DeleteOrgSecret(ctx context.Context, req *DeleteOrgSecretReq, opt ...requests.Option) (*DeleteOrgSecretResponse, error) {
	return DeleteOrgSecret(ctx, req, append(c, opt...)...)
}

/*
DeleteOrgSecretReq is request data for Client.DeleteOrgSecret

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
type DeleteOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string
}

// HTTPRequest builds an *http.Request
func (r *DeleteOrgSecretReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "actions/delete-org-secret",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/secrets/%v", r.Org, r.SecretName),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteOrgSecretReq) Rel(link string, resp *DeleteOrgSecretResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteOrgSecretResponse is a response for DeleteOrgSecret

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
type DeleteOrgSecretResponse struct {
	httpResponse *http.Response
}

func (r *DeleteOrgSecretResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteRepoSecret performs requests for "actions/delete-repo-secret"

Delete a repository secret.

  DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
func DeleteRepoSecret(ctx context.Context, req *DeleteRepoSecretReq, opt ...requests.Option) (*DeleteRepoSecretResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteRepoSecretReq)
	}
	resp := &DeleteRepoSecretResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteRepoSecretResponse(r, opts.PreserveResponseBody())
}

// NewDeleteRepoSecretResponse builds a new *DeleteRepoSecretResponse from an *http.Response
func NewDeleteRepoSecretResponse(resp *http.Response, preserveBody bool) (*DeleteRepoSecretResponse, error) {
	var result DeleteRepoSecretResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteRepoSecret performs requests for "actions/delete-repo-secret"

Delete a repository secret.

  DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
func (c Client) DeleteRepoSecret(ctx context.Context, req *DeleteRepoSecretReq, opt ...requests.Option) (*DeleteRepoSecretResponse, error) {
	return DeleteRepoSecret(ctx, req, append(c, opt...)...)
}

/*
DeleteRepoSecretReq is request data for Client.DeleteRepoSecret

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
type DeleteRepoSecretReq struct {
	_url  string
	Owner string
	Repo  string

	// secret_name parameter
	SecretName string
}

// HTTPRequest builds an *http.Request
func (r *DeleteRepoSecretReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteRepoSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "actions/delete-repo-secret",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/secrets/%v", r.Owner, r.Repo, r.SecretName),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteRepoSecretReq) Rel(link string, resp *DeleteRepoSecretResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteRepoSecretResponse is a response for DeleteRepoSecret

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
type DeleteRepoSecretResponse struct {
	httpResponse *http.Response
}

func (r *DeleteRepoSecretResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteSelfHostedRunnerFromOrg performs requests for "actions/delete-self-hosted-runner-from-org"

Delete a self-hosted runner from an organization.

  DELETE /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
func DeleteSelfHostedRunnerFromOrg(ctx context.Context, req *DeleteSelfHostedRunnerFromOrgReq, opt ...requests.Option) (*DeleteSelfHostedRunnerFromOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteSelfHostedRunnerFromOrgReq)
	}
	resp := &DeleteSelfHostedRunnerFromOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteSelfHostedRunnerFromOrgResponse(r, opts.PreserveResponseBody())
}

// NewDeleteSelfHostedRunnerFromOrgResponse builds a new *DeleteSelfHostedRunnerFromOrgResponse from an *http.Response
func NewDeleteSelfHostedRunnerFromOrgResponse(resp *http.Response, preserveBody bool) (*DeleteSelfHostedRunnerFromOrgResponse, error) {
	var result DeleteSelfHostedRunnerFromOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteSelfHostedRunnerFromOrg performs requests for "actions/delete-self-hosted-runner-from-org"

Delete a self-hosted runner from an organization.

  DELETE /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
func (c Client) DeleteSelfHostedRunnerFromOrg(ctx context.Context, req *DeleteSelfHostedRunnerFromOrgReq, opt ...requests.Option) (*DeleteSelfHostedRunnerFromOrgResponse, error) {
	return DeleteSelfHostedRunnerFromOrg(ctx, req, append(c, opt...)...)
}

/*
DeleteSelfHostedRunnerFromOrgReq is request data for Client.DeleteSelfHostedRunnerFromOrg

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
type DeleteSelfHostedRunnerFromOrgReq struct {
	_url string
	Org  string

	// runner_id parameter
	RunnerId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteSelfHostedRunnerFromOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteSelfHostedRunnerFromOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "actions/delete-self-hosted-runner-from-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/runners/%v", r.Org, r.RunnerId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteSelfHostedRunnerFromOrgReq) Rel(link string, resp *DeleteSelfHostedRunnerFromOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteSelfHostedRunnerFromOrgResponse is a response for DeleteSelfHostedRunnerFromOrg

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
type DeleteSelfHostedRunnerFromOrgResponse struct {
	httpResponse *http.Response
}

func (r *DeleteSelfHostedRunnerFromOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteSelfHostedRunnerFromRepo performs requests for "actions/delete-self-hosted-runner-from-repo"

Delete a self-hosted runner from a repository.

  DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
func DeleteSelfHostedRunnerFromRepo(ctx context.Context, req *DeleteSelfHostedRunnerFromRepoReq, opt ...requests.Option) (*DeleteSelfHostedRunnerFromRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteSelfHostedRunnerFromRepoReq)
	}
	resp := &DeleteSelfHostedRunnerFromRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteSelfHostedRunnerFromRepoResponse(r, opts.PreserveResponseBody())
}

// NewDeleteSelfHostedRunnerFromRepoResponse builds a new *DeleteSelfHostedRunnerFromRepoResponse from an *http.Response
func NewDeleteSelfHostedRunnerFromRepoResponse(resp *http.Response, preserveBody bool) (*DeleteSelfHostedRunnerFromRepoResponse, error) {
	var result DeleteSelfHostedRunnerFromRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteSelfHostedRunnerFromRepo performs requests for "actions/delete-self-hosted-runner-from-repo"

Delete a self-hosted runner from a repository.

  DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
func (c Client) DeleteSelfHostedRunnerFromRepo(ctx context.Context, req *DeleteSelfHostedRunnerFromRepoReq, opt ...requests.Option) (*DeleteSelfHostedRunnerFromRepoResponse, error) {
	return DeleteSelfHostedRunnerFromRepo(ctx, req, append(c, opt...)...)
}

/*
DeleteSelfHostedRunnerFromRepoReq is request data for Client.DeleteSelfHostedRunnerFromRepo

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
type DeleteSelfHostedRunnerFromRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// runner_id parameter
	RunnerId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteSelfHostedRunnerFromRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteSelfHostedRunnerFromRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "actions/delete-self-hosted-runner-from-repo",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runners/%v", r.Owner, r.Repo, r.RunnerId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteSelfHostedRunnerFromRepoReq) Rel(link string, resp *DeleteSelfHostedRunnerFromRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteSelfHostedRunnerFromRepoResponse is a response for DeleteSelfHostedRunnerFromRepo

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
type DeleteSelfHostedRunnerFromRepoResponse struct {
	httpResponse *http.Response
}

func (r *DeleteSelfHostedRunnerFromRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteWorkflowRun performs requests for "actions/delete-workflow-run"

Delete a workflow run.

  DELETE /repos/{owner}/{repo}/actions/runs/{run_id}

https://developer.github.com/v3/actions/workflow-runs/#delete-a-workflow-run
*/
func DeleteWorkflowRun(ctx context.Context, req *DeleteWorkflowRunReq, opt ...requests.Option) (*DeleteWorkflowRunResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteWorkflowRunReq)
	}
	resp := &DeleteWorkflowRunResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteWorkflowRunResponse(r, opts.PreserveResponseBody())
}

// NewDeleteWorkflowRunResponse builds a new *DeleteWorkflowRunResponse from an *http.Response
func NewDeleteWorkflowRunResponse(resp *http.Response, preserveBody bool) (*DeleteWorkflowRunResponse, error) {
	var result DeleteWorkflowRunResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteWorkflowRun performs requests for "actions/delete-workflow-run"

Delete a workflow run.

  DELETE /repos/{owner}/{repo}/actions/runs/{run_id}

https://developer.github.com/v3/actions/workflow-runs/#delete-a-workflow-run
*/
func (c Client) DeleteWorkflowRun(ctx context.Context, req *DeleteWorkflowRunReq, opt ...requests.Option) (*DeleteWorkflowRunResponse, error) {
	return DeleteWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
DeleteWorkflowRunReq is request data for Client.DeleteWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#delete-a-workflow-run
*/
type DeleteWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteWorkflowRunReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "actions/delete-workflow-run",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runs/%v", r.Owner, r.Repo, r.RunId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteWorkflowRunReq) Rel(link string, resp *DeleteWorkflowRunResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteWorkflowRunResponse is a response for DeleteWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#delete-a-workflow-run
*/
type DeleteWorkflowRunResponse struct {
	httpResponse *http.Response
}

func (r *DeleteWorkflowRunResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteWorkflowRunLogs performs requests for "actions/delete-workflow-run-logs"

Delete workflow run logs.

  DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
func DeleteWorkflowRunLogs(ctx context.Context, req *DeleteWorkflowRunLogsReq, opt ...requests.Option) (*DeleteWorkflowRunLogsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteWorkflowRunLogsReq)
	}
	resp := &DeleteWorkflowRunLogsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteWorkflowRunLogsResponse(r, opts.PreserveResponseBody())
}

// NewDeleteWorkflowRunLogsResponse builds a new *DeleteWorkflowRunLogsResponse from an *http.Response
func NewDeleteWorkflowRunLogsResponse(resp *http.Response, preserveBody bool) (*DeleteWorkflowRunLogsResponse, error) {
	var result DeleteWorkflowRunLogsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteWorkflowRunLogs performs requests for "actions/delete-workflow-run-logs"

Delete workflow run logs.

  DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
func (c Client) DeleteWorkflowRunLogs(ctx context.Context, req *DeleteWorkflowRunLogsReq, opt ...requests.Option) (*DeleteWorkflowRunLogsResponse, error) {
	return DeleteWorkflowRunLogs(ctx, req, append(c, opt...)...)
}

/*
DeleteWorkflowRunLogsReq is request data for Client.DeleteWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
type DeleteWorkflowRunLogsReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteWorkflowRunLogsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteWorkflowRunLogsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "actions/delete-workflow-run-logs",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runs/%v/logs", r.Owner, r.Repo, r.RunId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteWorkflowRunLogsReq) Rel(link string, resp *DeleteWorkflowRunLogsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteWorkflowRunLogsResponse is a response for DeleteWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
type DeleteWorkflowRunLogsResponse struct {
	httpResponse *http.Response
}

func (r *DeleteWorkflowRunLogsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DownloadArtifact performs requests for "actions/download-artifact"

Download an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
func DownloadArtifact(ctx context.Context, req *DownloadArtifactReq, opt ...requests.Option) (*DownloadArtifactResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DownloadArtifactReq)
	}
	resp := &DownloadArtifactResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDownloadArtifactResponse(r, opts.PreserveResponseBody())
}

// NewDownloadArtifactResponse builds a new *DownloadArtifactResponse from an *http.Response
func NewDownloadArtifactResponse(resp *http.Response, preserveBody bool) (*DownloadArtifactResponse, error) {
	var result DownloadArtifactResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{302})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DownloadArtifact performs requests for "actions/download-artifact"

Download an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
func (c Client) DownloadArtifact(ctx context.Context, req *DownloadArtifactReq, opt ...requests.Option) (*DownloadArtifactResponse, error) {
	return DownloadArtifact(ctx, req, append(c, opt...)...)
}

/*
DownloadArtifactReq is request data for Client.DownloadArtifact

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
type DownloadArtifactReq struct {
	_url  string
	Owner string
	Repo  string

	// artifact_id parameter
	ArtifactId int64

	// archive_format parameter
	ArchiveFormat string
}

// HTTPRequest builds an *http.Request
func (r *DownloadArtifactReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DownloadArtifactReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrRedirectOnly},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "actions/download-artifact",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/artifacts/%v/%v", r.Owner, r.Repo, r.ArtifactId, r.ArchiveFormat),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DownloadArtifactReq) Rel(link string, resp *DownloadArtifactResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DownloadArtifactResponse is a response for DownloadArtifact

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
type DownloadArtifactResponse struct {
	httpResponse *http.Response
}

func (r *DownloadArtifactResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DownloadJobLogsForWorkflowRun performs requests for "actions/download-job-logs-for-workflow-run"

Download job logs for a workflow run.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs

https://developer.github.com/v3/actions/workflow-jobs/#download-job-logs-for-a-workflow-run
*/
func DownloadJobLogsForWorkflowRun(ctx context.Context, req *DownloadJobLogsForWorkflowRunReq, opt ...requests.Option) (*DownloadJobLogsForWorkflowRunResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DownloadJobLogsForWorkflowRunReq)
	}
	resp := &DownloadJobLogsForWorkflowRunResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDownloadJobLogsForWorkflowRunResponse(r, opts.PreserveResponseBody())
}

// NewDownloadJobLogsForWorkflowRunResponse builds a new *DownloadJobLogsForWorkflowRunResponse from an *http.Response
func NewDownloadJobLogsForWorkflowRunResponse(resp *http.Response, preserveBody bool) (*DownloadJobLogsForWorkflowRunResponse, error) {
	var result DownloadJobLogsForWorkflowRunResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{302})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DownloadJobLogsForWorkflowRun performs requests for "actions/download-job-logs-for-workflow-run"

Download job logs for a workflow run.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs

https://developer.github.com/v3/actions/workflow-jobs/#download-job-logs-for-a-workflow-run
*/
func (c Client) DownloadJobLogsForWorkflowRun(ctx context.Context, req *DownloadJobLogsForWorkflowRunReq, opt ...requests.Option) (*DownloadJobLogsForWorkflowRunResponse, error) {
	return DownloadJobLogsForWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
DownloadJobLogsForWorkflowRunReq is request data for Client.DownloadJobLogsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#download-job-logs-for-a-workflow-run
*/
type DownloadJobLogsForWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string

	// job_id parameter
	JobId int64
}

// HTTPRequest builds an *http.Request
func (r *DownloadJobLogsForWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DownloadJobLogsForWorkflowRunReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrRedirectOnly},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "actions/download-job-logs-for-workflow-run",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/jobs/%v/logs", r.Owner, r.Repo, r.JobId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DownloadJobLogsForWorkflowRunReq) Rel(link string, resp *DownloadJobLogsForWorkflowRunResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DownloadJobLogsForWorkflowRunResponse is a response for DownloadJobLogsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#download-job-logs-for-a-workflow-run
*/
type DownloadJobLogsForWorkflowRunResponse struct {
	httpResponse *http.Response
}

func (r *DownloadJobLogsForWorkflowRunResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DownloadWorkflowRunLogs performs requests for "actions/download-workflow-run-logs"

Download workflow run logs.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
func DownloadWorkflowRunLogs(ctx context.Context, req *DownloadWorkflowRunLogsReq, opt ...requests.Option) (*DownloadWorkflowRunLogsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DownloadWorkflowRunLogsReq)
	}
	resp := &DownloadWorkflowRunLogsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDownloadWorkflowRunLogsResponse(r, opts.PreserveResponseBody())
}

// NewDownloadWorkflowRunLogsResponse builds a new *DownloadWorkflowRunLogsResponse from an *http.Response
func NewDownloadWorkflowRunLogsResponse(resp *http.Response, preserveBody bool) (*DownloadWorkflowRunLogsResponse, error) {
	var result DownloadWorkflowRunLogsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{302})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DownloadWorkflowRunLogs performs requests for "actions/download-workflow-run-logs"

Download workflow run logs.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
func (c Client) DownloadWorkflowRunLogs(ctx context.Context, req *DownloadWorkflowRunLogsReq, opt ...requests.Option) (*DownloadWorkflowRunLogsResponse, error) {
	return DownloadWorkflowRunLogs(ctx, req, append(c, opt...)...)
}

/*
DownloadWorkflowRunLogsReq is request data for Client.DownloadWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
type DownloadWorkflowRunLogsReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *DownloadWorkflowRunLogsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DownloadWorkflowRunLogsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrRedirectOnly},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "actions/download-workflow-run-logs",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runs/%v/logs", r.Owner, r.Repo, r.RunId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DownloadWorkflowRunLogsReq) Rel(link string, resp *DownloadWorkflowRunLogsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DownloadWorkflowRunLogsResponse is a response for DownloadWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
type DownloadWorkflowRunLogsResponse struct {
	httpResponse *http.Response
}

func (r *DownloadWorkflowRunLogsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetArtifact performs requests for "actions/get-artifact"

Get an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
func GetArtifact(ctx context.Context, req *GetArtifactReq, opt ...requests.Option) (*GetArtifactResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetArtifactReq)
	}
	resp := &GetArtifactResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetArtifactResponse(r, opts.PreserveResponseBody())
}

// NewGetArtifactResponse builds a new *GetArtifactResponse from an *http.Response
func NewGetArtifactResponse(resp *http.Response, preserveBody bool) (*GetArtifactResponse, error) {
	var result GetArtifactResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetArtifact performs requests for "actions/get-artifact"

Get an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
func (c Client) GetArtifact(ctx context.Context, req *GetArtifactReq, opt ...requests.Option) (*GetArtifactResponse, error) {
	return GetArtifact(ctx, req, append(c, opt...)...)
}

/*
GetArtifactReq is request data for Client.GetArtifact

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
type GetArtifactReq struct {
	_url  string
	Owner string
	Repo  string

	// artifact_id parameter
	ArtifactId int64
}

// HTTPRequest builds an *http.Request
func (r *GetArtifactReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetArtifactReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/get-artifact",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/artifacts/%v", r.Owner, r.Repo, r.ArtifactId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetArtifactReq) Rel(link string, resp *GetArtifactResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetArtifactResponse is a response for GetArtifact

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
type GetArtifactResponse struct {
	httpResponse *http.Response
	Data         components.Artifact
}

func (r *GetArtifactResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetJobForWorkflowRun performs requests for "actions/get-job-for-workflow-run"

Get a job for a workflow run.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}

https://developer.github.com/v3/actions/workflow-jobs/#get-a-job-for-a-workflow-run
*/
func GetJobForWorkflowRun(ctx context.Context, req *GetJobForWorkflowRunReq, opt ...requests.Option) (*GetJobForWorkflowRunResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetJobForWorkflowRunReq)
	}
	resp := &GetJobForWorkflowRunResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetJobForWorkflowRunResponse(r, opts.PreserveResponseBody())
}

// NewGetJobForWorkflowRunResponse builds a new *GetJobForWorkflowRunResponse from an *http.Response
func NewGetJobForWorkflowRunResponse(resp *http.Response, preserveBody bool) (*GetJobForWorkflowRunResponse, error) {
	var result GetJobForWorkflowRunResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{202})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{202}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetJobForWorkflowRun performs requests for "actions/get-job-for-workflow-run"

Get a job for a workflow run.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}

https://developer.github.com/v3/actions/workflow-jobs/#get-a-job-for-a-workflow-run
*/
func (c Client) GetJobForWorkflowRun(ctx context.Context, req *GetJobForWorkflowRunReq, opt ...requests.Option) (*GetJobForWorkflowRunResponse, error) {
	return GetJobForWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
GetJobForWorkflowRunReq is request data for Client.GetJobForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#get-a-job-for-a-workflow-run
*/
type GetJobForWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string

	// job_id parameter
	JobId int64
}

// HTTPRequest builds an *http.Request
func (r *GetJobForWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetJobForWorkflowRunReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/get-job-for-workflow-run",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/jobs/%v", r.Owner, r.Repo, r.JobId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetJobForWorkflowRunReq) Rel(link string, resp *GetJobForWorkflowRunResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetJobForWorkflowRunResponse is a response for GetJobForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#get-a-job-for-a-workflow-run
*/
type GetJobForWorkflowRunResponse struct {
	httpResponse *http.Response
	Data         components.Job
}

func (r *GetJobForWorkflowRunResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetOrgPublicKey performs requests for "actions/get-org-public-key"

Get an organization public key.

  GET /orgs/{org}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
func GetOrgPublicKey(ctx context.Context, req *GetOrgPublicKeyReq, opt ...requests.Option) (*GetOrgPublicKeyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetOrgPublicKeyReq)
	}
	resp := &GetOrgPublicKeyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetOrgPublicKeyResponse(r, opts.PreserveResponseBody())
}

// NewGetOrgPublicKeyResponse builds a new *GetOrgPublicKeyResponse from an *http.Response
func NewGetOrgPublicKeyResponse(resp *http.Response, preserveBody bool) (*GetOrgPublicKeyResponse, error) {
	var result GetOrgPublicKeyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetOrgPublicKey performs requests for "actions/get-org-public-key"

Get an organization public key.

  GET /orgs/{org}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
func (c Client) GetOrgPublicKey(ctx context.Context, req *GetOrgPublicKeyReq, opt ...requests.Option) (*GetOrgPublicKeyResponse, error) {
	return GetOrgPublicKey(ctx, req, append(c, opt...)...)
}

/*
GetOrgPublicKeyReq is request data for Client.GetOrgPublicKey

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
type GetOrgPublicKeyReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *GetOrgPublicKeyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetOrgPublicKeyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/get-org-public-key",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/secrets/public-key", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetOrgPublicKeyReq) Rel(link string, resp *GetOrgPublicKeyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetOrgPublicKeyResponse is a response for GetOrgPublicKey

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
type GetOrgPublicKeyResponse struct {
	httpResponse *http.Response
	Data         components.ActionsPublicKey
}

func (r *GetOrgPublicKeyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetOrgSecret performs requests for "actions/get-org-secret"

Get an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
func GetOrgSecret(ctx context.Context, req *GetOrgSecretReq, opt ...requests.Option) (*GetOrgSecretResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetOrgSecretReq)
	}
	resp := &GetOrgSecretResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetOrgSecretResponse(r, opts.PreserveResponseBody())
}

// NewGetOrgSecretResponse builds a new *GetOrgSecretResponse from an *http.Response
func NewGetOrgSecretResponse(resp *http.Response, preserveBody bool) (*GetOrgSecretResponse, error) {
	var result GetOrgSecretResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetOrgSecret performs requests for "actions/get-org-secret"

Get an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
func (c Client) GetOrgSecret(ctx context.Context, req *GetOrgSecretReq, opt ...requests.Option) (*GetOrgSecretResponse, error) {
	return GetOrgSecret(ctx, req, append(c, opt...)...)
}

/*
GetOrgSecretReq is request data for Client.GetOrgSecret

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
type GetOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string
}

// HTTPRequest builds an *http.Request
func (r *GetOrgSecretReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/get-org-secret",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/secrets/%v", r.Org, r.SecretName),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetOrgSecretReq) Rel(link string, resp *GetOrgSecretResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetOrgSecretResponse is a response for GetOrgSecret

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
type GetOrgSecretResponse struct {
	httpResponse *http.Response
	Data         components.OrganizationActionsSecret
}

func (r *GetOrgSecretResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetRepoPublicKey performs requests for "actions/get-repo-public-key"

Get a repository public key.

  GET /repos/{owner}/{repo}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
func GetRepoPublicKey(ctx context.Context, req *GetRepoPublicKeyReq, opt ...requests.Option) (*GetRepoPublicKeyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetRepoPublicKeyReq)
	}
	resp := &GetRepoPublicKeyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetRepoPublicKeyResponse(r, opts.PreserveResponseBody())
}

// NewGetRepoPublicKeyResponse builds a new *GetRepoPublicKeyResponse from an *http.Response
func NewGetRepoPublicKeyResponse(resp *http.Response, preserveBody bool) (*GetRepoPublicKeyResponse, error) {
	var result GetRepoPublicKeyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetRepoPublicKey performs requests for "actions/get-repo-public-key"

Get a repository public key.

  GET /repos/{owner}/{repo}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
func (c Client) GetRepoPublicKey(ctx context.Context, req *GetRepoPublicKeyReq, opt ...requests.Option) (*GetRepoPublicKeyResponse, error) {
	return GetRepoPublicKey(ctx, req, append(c, opt...)...)
}

/*
GetRepoPublicKeyReq is request data for Client.GetRepoPublicKey

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
type GetRepoPublicKeyReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetRepoPublicKeyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetRepoPublicKeyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/get-repo-public-key",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/secrets/public-key", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetRepoPublicKeyReq) Rel(link string, resp *GetRepoPublicKeyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetRepoPublicKeyResponse is a response for GetRepoPublicKey

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
type GetRepoPublicKeyResponse struct {
	httpResponse *http.Response
	Data         components.ActionsPublicKey
}

func (r *GetRepoPublicKeyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetRepoSecret performs requests for "actions/get-repo-secret"

Get a repository secret.

  GET /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
func GetRepoSecret(ctx context.Context, req *GetRepoSecretReq, opt ...requests.Option) (*GetRepoSecretResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetRepoSecretReq)
	}
	resp := &GetRepoSecretResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetRepoSecretResponse(r, opts.PreserveResponseBody())
}

// NewGetRepoSecretResponse builds a new *GetRepoSecretResponse from an *http.Response
func NewGetRepoSecretResponse(resp *http.Response, preserveBody bool) (*GetRepoSecretResponse, error) {
	var result GetRepoSecretResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetRepoSecret performs requests for "actions/get-repo-secret"

Get a repository secret.

  GET /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
func (c Client) GetRepoSecret(ctx context.Context, req *GetRepoSecretReq, opt ...requests.Option) (*GetRepoSecretResponse, error) {
	return GetRepoSecret(ctx, req, append(c, opt...)...)
}

/*
GetRepoSecretReq is request data for Client.GetRepoSecret

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
type GetRepoSecretReq struct {
	_url  string
	Owner string
	Repo  string

	// secret_name parameter
	SecretName string
}

// HTTPRequest builds an *http.Request
func (r *GetRepoSecretReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetRepoSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/get-repo-secret",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/secrets/%v", r.Owner, r.Repo, r.SecretName),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetRepoSecretReq) Rel(link string, resp *GetRepoSecretResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetRepoSecretResponse is a response for GetRepoSecret

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
type GetRepoSecretResponse struct {
	httpResponse *http.Response
	Data         components.ActionsSecret
}

func (r *GetRepoSecretResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetSelfHostedRunnerForOrg performs requests for "actions/get-self-hosted-runner-for-org"

Get a self-hosted runner for an organization.

  GET /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
func GetSelfHostedRunnerForOrg(ctx context.Context, req *GetSelfHostedRunnerForOrgReq, opt ...requests.Option) (*GetSelfHostedRunnerForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetSelfHostedRunnerForOrgReq)
	}
	resp := &GetSelfHostedRunnerForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetSelfHostedRunnerForOrgResponse(r, opts.PreserveResponseBody())
}

// NewGetSelfHostedRunnerForOrgResponse builds a new *GetSelfHostedRunnerForOrgResponse from an *http.Response
func NewGetSelfHostedRunnerForOrgResponse(resp *http.Response, preserveBody bool) (*GetSelfHostedRunnerForOrgResponse, error) {
	var result GetSelfHostedRunnerForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetSelfHostedRunnerForOrg performs requests for "actions/get-self-hosted-runner-for-org"

Get a self-hosted runner for an organization.

  GET /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
func (c Client) GetSelfHostedRunnerForOrg(ctx context.Context, req *GetSelfHostedRunnerForOrgReq, opt ...requests.Option) (*GetSelfHostedRunnerForOrgResponse, error) {
	return GetSelfHostedRunnerForOrg(ctx, req, append(c, opt...)...)
}

/*
GetSelfHostedRunnerForOrgReq is request data for Client.GetSelfHostedRunnerForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
type GetSelfHostedRunnerForOrgReq struct {
	_url string
	Org  string

	// runner_id parameter
	RunnerId int64
}

// HTTPRequest builds an *http.Request
func (r *GetSelfHostedRunnerForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetSelfHostedRunnerForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/get-self-hosted-runner-for-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/runners/%v", r.Org, r.RunnerId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetSelfHostedRunnerForOrgReq) Rel(link string, resp *GetSelfHostedRunnerForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetSelfHostedRunnerForOrgResponse is a response for GetSelfHostedRunnerForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
type GetSelfHostedRunnerForOrgResponse struct {
	httpResponse *http.Response
	Data         components.Runner
}

func (r *GetSelfHostedRunnerForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetSelfHostedRunnerForRepo performs requests for "actions/get-self-hosted-runner-for-repo"

Get a self-hosted runner for a repository.

  GET /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
func GetSelfHostedRunnerForRepo(ctx context.Context, req *GetSelfHostedRunnerForRepoReq, opt ...requests.Option) (*GetSelfHostedRunnerForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetSelfHostedRunnerForRepoReq)
	}
	resp := &GetSelfHostedRunnerForRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetSelfHostedRunnerForRepoResponse(r, opts.PreserveResponseBody())
}

// NewGetSelfHostedRunnerForRepoResponse builds a new *GetSelfHostedRunnerForRepoResponse from an *http.Response
func NewGetSelfHostedRunnerForRepoResponse(resp *http.Response, preserveBody bool) (*GetSelfHostedRunnerForRepoResponse, error) {
	var result GetSelfHostedRunnerForRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetSelfHostedRunnerForRepo performs requests for "actions/get-self-hosted-runner-for-repo"

Get a self-hosted runner for a repository.

  GET /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
func (c Client) GetSelfHostedRunnerForRepo(ctx context.Context, req *GetSelfHostedRunnerForRepoReq, opt ...requests.Option) (*GetSelfHostedRunnerForRepoResponse, error) {
	return GetSelfHostedRunnerForRepo(ctx, req, append(c, opt...)...)
}

/*
GetSelfHostedRunnerForRepoReq is request data for Client.GetSelfHostedRunnerForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
type GetSelfHostedRunnerForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// runner_id parameter
	RunnerId int64
}

// HTTPRequest builds an *http.Request
func (r *GetSelfHostedRunnerForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetSelfHostedRunnerForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/get-self-hosted-runner-for-repo",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runners/%v", r.Owner, r.Repo, r.RunnerId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetSelfHostedRunnerForRepoReq) Rel(link string, resp *GetSelfHostedRunnerForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetSelfHostedRunnerForRepoResponse is a response for GetSelfHostedRunnerForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
type GetSelfHostedRunnerForRepoResponse struct {
	httpResponse *http.Response
	Data         components.Runner
}

func (r *GetSelfHostedRunnerForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetWorkflow performs requests for "actions/get-workflow"

Get a workflow.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
func GetWorkflow(ctx context.Context, req *GetWorkflowReq, opt ...requests.Option) (*GetWorkflowResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetWorkflowReq)
	}
	resp := &GetWorkflowResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetWorkflowResponse(r, opts.PreserveResponseBody())
}

// NewGetWorkflowResponse builds a new *GetWorkflowResponse from an *http.Response
func NewGetWorkflowResponse(resp *http.Response, preserveBody bool) (*GetWorkflowResponse, error) {
	var result GetWorkflowResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetWorkflow performs requests for "actions/get-workflow"

Get a workflow.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
func (c Client) GetWorkflow(ctx context.Context, req *GetWorkflowReq, opt ...requests.Option) (*GetWorkflowResponse, error) {
	return GetWorkflow(ctx, req, append(c, opt...)...)
}

/*
GetWorkflowReq is request data for Client.GetWorkflow

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
type GetWorkflowReq struct {
	_url       string
	Owner      string
	Repo       string
	WorkflowId int64
}

// HTTPRequest builds an *http.Request
func (r *GetWorkflowReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetWorkflowReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/get-workflow",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/workflows/%v", r.Owner, r.Repo, r.WorkflowId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetWorkflowReq) Rel(link string, resp *GetWorkflowResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetWorkflowResponse is a response for GetWorkflow

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
type GetWorkflowResponse struct {
	httpResponse *http.Response
	Data         components.Workflow
}

func (r *GetWorkflowResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetWorkflowRun performs requests for "actions/get-workflow-run"

Get a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
func GetWorkflowRun(ctx context.Context, req *GetWorkflowRunReq, opt ...requests.Option) (*GetWorkflowRunResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetWorkflowRunReq)
	}
	resp := &GetWorkflowRunResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetWorkflowRunResponse(r, opts.PreserveResponseBody())
}

// NewGetWorkflowRunResponse builds a new *GetWorkflowRunResponse from an *http.Response
func NewGetWorkflowRunResponse(resp *http.Response, preserveBody bool) (*GetWorkflowRunResponse, error) {
	var result GetWorkflowRunResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetWorkflowRun performs requests for "actions/get-workflow-run"

Get a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
func (c Client) GetWorkflowRun(ctx context.Context, req *GetWorkflowRunReq, opt ...requests.Option) (*GetWorkflowRunResponse, error) {
	return GetWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
GetWorkflowRunReq is request data for Client.GetWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
type GetWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *GetWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetWorkflowRunReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/get-workflow-run",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runs/%v", r.Owner, r.Repo, r.RunId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetWorkflowRunReq) Rel(link string, resp *GetWorkflowRunResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetWorkflowRunResponse is a response for GetWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
type GetWorkflowRunResponse struct {
	httpResponse *http.Response
	Data         components.WorkflowRun
}

func (r *GetWorkflowRunResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetWorkflowRunUsage performs requests for "actions/get-workflow-run-usage"

Get workflow run usage.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
func GetWorkflowRunUsage(ctx context.Context, req *GetWorkflowRunUsageReq, opt ...requests.Option) (*GetWorkflowRunUsageResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetWorkflowRunUsageReq)
	}
	resp := &GetWorkflowRunUsageResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetWorkflowRunUsageResponse(r, opts.PreserveResponseBody())
}

// NewGetWorkflowRunUsageResponse builds a new *GetWorkflowRunUsageResponse from an *http.Response
func NewGetWorkflowRunUsageResponse(resp *http.Response, preserveBody bool) (*GetWorkflowRunUsageResponse, error) {
	var result GetWorkflowRunUsageResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetWorkflowRunUsage performs requests for "actions/get-workflow-run-usage"

Get workflow run usage.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
func (c Client) GetWorkflowRunUsage(ctx context.Context, req *GetWorkflowRunUsageReq, opt ...requests.Option) (*GetWorkflowRunUsageResponse, error) {
	return GetWorkflowRunUsage(ctx, req, append(c, opt...)...)
}

/*
GetWorkflowRunUsageReq is request data for Client.GetWorkflowRunUsage

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
type GetWorkflowRunUsageReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *GetWorkflowRunUsageReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetWorkflowRunUsageReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/get-workflow-run-usage",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runs/%v/timing", r.Owner, r.Repo, r.RunId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetWorkflowRunUsageReq) Rel(link string, resp *GetWorkflowRunUsageResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetWorkflowRunUsageResponse is a response for GetWorkflowRunUsage

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
type GetWorkflowRunUsageResponse struct {
	httpResponse *http.Response
	Data         components.WorkflowRunUsage
}

func (r *GetWorkflowRunUsageResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetWorkflowUsage performs requests for "actions/get-workflow-usage"

Get workflow usage.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
func GetWorkflowUsage(ctx context.Context, req *GetWorkflowUsageReq, opt ...requests.Option) (*GetWorkflowUsageResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetWorkflowUsageReq)
	}
	resp := &GetWorkflowUsageResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetWorkflowUsageResponse(r, opts.PreserveResponseBody())
}

// NewGetWorkflowUsageResponse builds a new *GetWorkflowUsageResponse from an *http.Response
func NewGetWorkflowUsageResponse(resp *http.Response, preserveBody bool) (*GetWorkflowUsageResponse, error) {
	var result GetWorkflowUsageResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetWorkflowUsage performs requests for "actions/get-workflow-usage"

Get workflow usage.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
func (c Client) GetWorkflowUsage(ctx context.Context, req *GetWorkflowUsageReq, opt ...requests.Option) (*GetWorkflowUsageResponse, error) {
	return GetWorkflowUsage(ctx, req, append(c, opt...)...)
}

/*
GetWorkflowUsageReq is request data for Client.GetWorkflowUsage

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
type GetWorkflowUsageReq struct {
	_url       string
	Owner      string
	Repo       string
	WorkflowId int64
}

// HTTPRequest builds an *http.Request
func (r *GetWorkflowUsageReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetWorkflowUsageReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/get-workflow-usage",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/workflows/%v/timing", r.Owner, r.Repo, r.WorkflowId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetWorkflowUsageReq) Rel(link string, resp *GetWorkflowUsageResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetWorkflowUsageResponse is a response for GetWorkflowUsage

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
type GetWorkflowUsageResponse struct {
	httpResponse *http.Response
	Data         components.WorkflowUsage
}

func (r *GetWorkflowUsageResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListArtifactsForRepo performs requests for "actions/list-artifacts-for-repo"

List artifacts for a repository.

  GET /repos/{owner}/{repo}/actions/artifacts

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
func ListArtifactsForRepo(ctx context.Context, req *ListArtifactsForRepoReq, opt ...requests.Option) (*ListArtifactsForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListArtifactsForRepoReq)
	}
	resp := &ListArtifactsForRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListArtifactsForRepoResponse(r, opts.PreserveResponseBody())
}

// NewListArtifactsForRepoResponse builds a new *ListArtifactsForRepoResponse from an *http.Response
func NewListArtifactsForRepoResponse(resp *http.Response, preserveBody bool) (*ListArtifactsForRepoResponse, error) {
	var result ListArtifactsForRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListArtifactsForRepo performs requests for "actions/list-artifacts-for-repo"

List artifacts for a repository.

  GET /repos/{owner}/{repo}/actions/artifacts

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
func (c Client) ListArtifactsForRepo(ctx context.Context, req *ListArtifactsForRepoReq, opt ...requests.Option) (*ListArtifactsForRepoResponse, error) {
	return ListArtifactsForRepo(ctx, req, append(c, opt...)...)
}

/*
ListArtifactsForRepoReq is request data for Client.ListArtifactsForRepo

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
type ListArtifactsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListArtifactsForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListArtifactsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/list-artifacts-for-repo",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/artifacts", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListArtifactsForRepoReq) Rel(link string, resp *ListArtifactsForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListArtifactsForRepoResponseBody is a response body for ListArtifactsForRepo

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
type ListArtifactsForRepoResponseBody struct {
	Artifacts  []components.Artifact `json:"artifacts,omitempty"`
	TotalCount int64                 `json:"total_count,omitempty"`
}

/*
ListArtifactsForRepoResponse is a response for ListArtifactsForRepo

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
type ListArtifactsForRepoResponse struct {
	httpResponse *http.Response
	Data         ListArtifactsForRepoResponseBody
}

func (r *ListArtifactsForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListJobsForWorkflowRun performs requests for "actions/list-jobs-for-workflow-run"

List jobs for a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
func ListJobsForWorkflowRun(ctx context.Context, req *ListJobsForWorkflowRunReq, opt ...requests.Option) (*ListJobsForWorkflowRunResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListJobsForWorkflowRunReq)
	}
	resp := &ListJobsForWorkflowRunResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListJobsForWorkflowRunResponse(r, opts.PreserveResponseBody())
}

// NewListJobsForWorkflowRunResponse builds a new *ListJobsForWorkflowRunResponse from an *http.Response
func NewListJobsForWorkflowRunResponse(resp *http.Response, preserveBody bool) (*ListJobsForWorkflowRunResponse, error) {
	var result ListJobsForWorkflowRunResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListJobsForWorkflowRun performs requests for "actions/list-jobs-for-workflow-run"

List jobs for a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
func (c Client) ListJobsForWorkflowRun(ctx context.Context, req *ListJobsForWorkflowRunReq, opt ...requests.Option) (*ListJobsForWorkflowRunResponse, error) {
	return ListJobsForWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
ListJobsForWorkflowRunReq is request data for Client.ListJobsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
type ListJobsForWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64

	/*
	Filters jobs by their `completed_at` timestamp. Can be one of:
	\* `latest`: Returns jobs from the most recent execution of the workflow run.
	\* `all`: Returns all jobs for a workflow run, including from old executions of
	the workflow run.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListJobsForWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListJobsForWorkflowRunReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/list-jobs-for-workflow-run",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runs/%v/jobs", r.Owner, r.Repo, r.RunId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListJobsForWorkflowRunReq) Rel(link string, resp *ListJobsForWorkflowRunResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListJobsForWorkflowRunResponseBody is a response body for ListJobsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
type ListJobsForWorkflowRunResponseBody struct {
	Jobs       []components.Job `json:"jobs,omitempty"`
	TotalCount int64            `json:"total_count,omitempty"`
}

/*
ListJobsForWorkflowRunResponse is a response for ListJobsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
type ListJobsForWorkflowRunResponse struct {
	httpResponse *http.Response
	Data         ListJobsForWorkflowRunResponseBody
}

func (r *ListJobsForWorkflowRunResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListOrgSecrets performs requests for "actions/list-org-secrets"

List organization secrets.

  GET /orgs/{org}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
func ListOrgSecrets(ctx context.Context, req *ListOrgSecretsReq, opt ...requests.Option) (*ListOrgSecretsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListOrgSecretsReq)
	}
	resp := &ListOrgSecretsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListOrgSecretsResponse(r, opts.PreserveResponseBody())
}

// NewListOrgSecretsResponse builds a new *ListOrgSecretsResponse from an *http.Response
func NewListOrgSecretsResponse(resp *http.Response, preserveBody bool) (*ListOrgSecretsResponse, error) {
	var result ListOrgSecretsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListOrgSecrets performs requests for "actions/list-org-secrets"

List organization secrets.

  GET /orgs/{org}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
func (c Client) ListOrgSecrets(ctx context.Context, req *ListOrgSecretsReq, opt ...requests.Option) (*ListOrgSecretsResponse, error) {
	return ListOrgSecrets(ctx, req, append(c, opt...)...)
}

/*
ListOrgSecretsReq is request data for Client.ListOrgSecrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
type ListOrgSecretsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListOrgSecretsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListOrgSecretsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/list-org-secrets",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/secrets", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListOrgSecretsReq) Rel(link string, resp *ListOrgSecretsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListOrgSecretsResponseBody is a response body for ListOrgSecrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
type ListOrgSecretsResponseBody struct {
	Secrets    []components.OrganizationActionsSecret `json:"secrets,omitempty"`
	TotalCount int64                                  `json:"total_count,omitempty"`
}

/*
ListOrgSecretsResponse is a response for ListOrgSecrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
type ListOrgSecretsResponse struct {
	httpResponse *http.Response
	Data         ListOrgSecretsResponseBody
}

func (r *ListOrgSecretsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListRepoSecrets performs requests for "actions/list-repo-secrets"

List repository secrets.

  GET /repos/{owner}/{repo}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
func ListRepoSecrets(ctx context.Context, req *ListRepoSecretsReq, opt ...requests.Option) (*ListRepoSecretsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListRepoSecretsReq)
	}
	resp := &ListRepoSecretsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListRepoSecretsResponse(r, opts.PreserveResponseBody())
}

// NewListRepoSecretsResponse builds a new *ListRepoSecretsResponse from an *http.Response
func NewListRepoSecretsResponse(resp *http.Response, preserveBody bool) (*ListRepoSecretsResponse, error) {
	var result ListRepoSecretsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListRepoSecrets performs requests for "actions/list-repo-secrets"

List repository secrets.

  GET /repos/{owner}/{repo}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
func (c Client) ListRepoSecrets(ctx context.Context, req *ListRepoSecretsReq, opt ...requests.Option) (*ListRepoSecretsResponse, error) {
	return ListRepoSecrets(ctx, req, append(c, opt...)...)
}

/*
ListRepoSecretsReq is request data for Client.ListRepoSecrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
type ListRepoSecretsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListRepoSecretsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListRepoSecretsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/list-repo-secrets",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/secrets", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListRepoSecretsReq) Rel(link string, resp *ListRepoSecretsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListRepoSecretsResponseBody is a response body for ListRepoSecrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
type ListRepoSecretsResponseBody struct {
	Secrets    []components.ActionsSecret `json:"secrets,omitempty"`
	TotalCount int64                      `json:"total_count,omitempty"`
}

/*
ListRepoSecretsResponse is a response for ListRepoSecrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
type ListRepoSecretsResponse struct {
	httpResponse *http.Response
	Data         ListRepoSecretsResponseBody
}

func (r *ListRepoSecretsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListRepoWorkflows performs requests for "actions/list-repo-workflows"

List repository workflows.

  GET /repos/{owner}/{repo}/actions/workflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
func ListRepoWorkflows(ctx context.Context, req *ListRepoWorkflowsReq, opt ...requests.Option) (*ListRepoWorkflowsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListRepoWorkflowsReq)
	}
	resp := &ListRepoWorkflowsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListRepoWorkflowsResponse(r, opts.PreserveResponseBody())
}

// NewListRepoWorkflowsResponse builds a new *ListRepoWorkflowsResponse from an *http.Response
func NewListRepoWorkflowsResponse(resp *http.Response, preserveBody bool) (*ListRepoWorkflowsResponse, error) {
	var result ListRepoWorkflowsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListRepoWorkflows performs requests for "actions/list-repo-workflows"

List repository workflows.

  GET /repos/{owner}/{repo}/actions/workflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
func (c Client) ListRepoWorkflows(ctx context.Context, req *ListRepoWorkflowsReq, opt ...requests.Option) (*ListRepoWorkflowsResponse, error) {
	return ListRepoWorkflows(ctx, req, append(c, opt...)...)
}

/*
ListRepoWorkflowsReq is request data for Client.ListRepoWorkflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
type ListRepoWorkflowsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListRepoWorkflowsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListRepoWorkflowsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/list-repo-workflows",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/workflows", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListRepoWorkflowsReq) Rel(link string, resp *ListRepoWorkflowsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListRepoWorkflowsResponseBody is a response body for ListRepoWorkflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
type ListRepoWorkflowsResponseBody struct {
	TotalCount int64                 `json:"total_count,omitempty"`
	Workflows  []components.Workflow `json:"workflows,omitempty"`
}

/*
ListRepoWorkflowsResponse is a response for ListRepoWorkflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
type ListRepoWorkflowsResponse struct {
	httpResponse *http.Response
	Data         ListRepoWorkflowsResponseBody
}

func (r *ListRepoWorkflowsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListRunnerApplicationsForOrg performs requests for "actions/list-runner-applications-for-org"

List runner applications for an organization.

  GET /orgs/{org}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
func ListRunnerApplicationsForOrg(ctx context.Context, req *ListRunnerApplicationsForOrgReq, opt ...requests.Option) (*ListRunnerApplicationsForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListRunnerApplicationsForOrgReq)
	}
	resp := &ListRunnerApplicationsForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListRunnerApplicationsForOrgResponse(r, opts.PreserveResponseBody())
}

// NewListRunnerApplicationsForOrgResponse builds a new *ListRunnerApplicationsForOrgResponse from an *http.Response
func NewListRunnerApplicationsForOrgResponse(resp *http.Response, preserveBody bool) (*ListRunnerApplicationsForOrgResponse, error) {
	var result ListRunnerApplicationsForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListRunnerApplicationsForOrg performs requests for "actions/list-runner-applications-for-org"

List runner applications for an organization.

  GET /orgs/{org}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
func (c Client) ListRunnerApplicationsForOrg(ctx context.Context, req *ListRunnerApplicationsForOrgReq, opt ...requests.Option) (*ListRunnerApplicationsForOrgResponse, error) {
	return ListRunnerApplicationsForOrg(ctx, req, append(c, opt...)...)
}

/*
ListRunnerApplicationsForOrgReq is request data for Client.ListRunnerApplicationsForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
type ListRunnerApplicationsForOrgReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *ListRunnerApplicationsForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListRunnerApplicationsForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/list-runner-applications-for-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/runners/downloads", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListRunnerApplicationsForOrgReq) Rel(link string, resp *ListRunnerApplicationsForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListRunnerApplicationsForOrgResponse is a response for ListRunnerApplicationsForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
type ListRunnerApplicationsForOrgResponse struct {
	httpResponse *http.Response
	Data         []components.RunnerApplication
}

func (r *ListRunnerApplicationsForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListRunnerApplicationsForRepo performs requests for "actions/list-runner-applications-for-repo"

List runner applications for a repository.

  GET /repos/{owner}/{repo}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
func ListRunnerApplicationsForRepo(ctx context.Context, req *ListRunnerApplicationsForRepoReq, opt ...requests.Option) (*ListRunnerApplicationsForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListRunnerApplicationsForRepoReq)
	}
	resp := &ListRunnerApplicationsForRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListRunnerApplicationsForRepoResponse(r, opts.PreserveResponseBody())
}

// NewListRunnerApplicationsForRepoResponse builds a new *ListRunnerApplicationsForRepoResponse from an *http.Response
func NewListRunnerApplicationsForRepoResponse(resp *http.Response, preserveBody bool) (*ListRunnerApplicationsForRepoResponse, error) {
	var result ListRunnerApplicationsForRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListRunnerApplicationsForRepo performs requests for "actions/list-runner-applications-for-repo"

List runner applications for a repository.

  GET /repos/{owner}/{repo}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
func (c Client) ListRunnerApplicationsForRepo(ctx context.Context, req *ListRunnerApplicationsForRepoReq, opt ...requests.Option) (*ListRunnerApplicationsForRepoResponse, error) {
	return ListRunnerApplicationsForRepo(ctx, req, append(c, opt...)...)
}

/*
ListRunnerApplicationsForRepoReq is request data for Client.ListRunnerApplicationsForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
type ListRunnerApplicationsForRepoReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ListRunnerApplicationsForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListRunnerApplicationsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/list-runner-applications-for-repo",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runners/downloads", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListRunnerApplicationsForRepoReq) Rel(link string, resp *ListRunnerApplicationsForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListRunnerApplicationsForRepoResponse is a response for ListRunnerApplicationsForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
type ListRunnerApplicationsForRepoResponse struct {
	httpResponse *http.Response
	Data         []components.RunnerApplication
}

func (r *ListRunnerApplicationsForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListSelectedReposForOrgSecret performs requests for "actions/list-selected-repos-for-org-secret"

List selected repositories for an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
func ListSelectedReposForOrgSecret(ctx context.Context, req *ListSelectedReposForOrgSecretReq, opt ...requests.Option) (*ListSelectedReposForOrgSecretResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListSelectedReposForOrgSecretReq)
	}
	resp := &ListSelectedReposForOrgSecretResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListSelectedReposForOrgSecretResponse(r, opts.PreserveResponseBody())
}

// NewListSelectedReposForOrgSecretResponse builds a new *ListSelectedReposForOrgSecretResponse from an *http.Response
func NewListSelectedReposForOrgSecretResponse(resp *http.Response, preserveBody bool) (*ListSelectedReposForOrgSecretResponse, error) {
	var result ListSelectedReposForOrgSecretResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListSelectedReposForOrgSecret performs requests for "actions/list-selected-repos-for-org-secret"

List selected repositories for an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
func (c Client) ListSelectedReposForOrgSecret(ctx context.Context, req *ListSelectedReposForOrgSecretReq, opt ...requests.Option) (*ListSelectedReposForOrgSecretResponse, error) {
	return ListSelectedReposForOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ListSelectedReposForOrgSecretReq is request data for Client.ListSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
type ListSelectedReposForOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string
}

// HTTPRequest builds an *http.Request
func (r *ListSelectedReposForOrgSecretReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListSelectedReposForOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/list-selected-repos-for-org-secret",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories", r.Org, r.SecretName),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListSelectedReposForOrgSecretReq) Rel(link string, resp *ListSelectedReposForOrgSecretResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListSelectedReposForOrgSecretResponseBody is a response body for ListSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
type ListSelectedReposForOrgSecretResponseBody struct {
	Repositories []components.MinimalRepository `json:"repositories,omitempty"`
	TotalCount   int64                          `json:"total_count,omitempty"`
}

/*
ListSelectedReposForOrgSecretResponse is a response for ListSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
type ListSelectedReposForOrgSecretResponse struct {
	httpResponse *http.Response
	Data         ListSelectedReposForOrgSecretResponseBody
}

func (r *ListSelectedReposForOrgSecretResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListSelfHostedRunnersForOrg performs requests for "actions/list-self-hosted-runners-for-org"

List self-hosted runners for an organization.

  GET /orgs/{org}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
func ListSelfHostedRunnersForOrg(ctx context.Context, req *ListSelfHostedRunnersForOrgReq, opt ...requests.Option) (*ListSelfHostedRunnersForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListSelfHostedRunnersForOrgReq)
	}
	resp := &ListSelfHostedRunnersForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListSelfHostedRunnersForOrgResponse(r, opts.PreserveResponseBody())
}

// NewListSelfHostedRunnersForOrgResponse builds a new *ListSelfHostedRunnersForOrgResponse from an *http.Response
func NewListSelfHostedRunnersForOrgResponse(resp *http.Response, preserveBody bool) (*ListSelfHostedRunnersForOrgResponse, error) {
	var result ListSelfHostedRunnersForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListSelfHostedRunnersForOrg performs requests for "actions/list-self-hosted-runners-for-org"

List self-hosted runners for an organization.

  GET /orgs/{org}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
func (c Client) ListSelfHostedRunnersForOrg(ctx context.Context, req *ListSelfHostedRunnersForOrgReq, opt ...requests.Option) (*ListSelfHostedRunnersForOrgResponse, error) {
	return ListSelfHostedRunnersForOrg(ctx, req, append(c, opt...)...)
}

/*
ListSelfHostedRunnersForOrgReq is request data for Client.ListSelfHostedRunnersForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
type ListSelfHostedRunnersForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListSelfHostedRunnersForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListSelfHostedRunnersForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/list-self-hosted-runners-for-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/runners", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListSelfHostedRunnersForOrgReq) Rel(link string, resp *ListSelfHostedRunnersForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListSelfHostedRunnersForOrgResponseBody is a response body for ListSelfHostedRunnersForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
type ListSelfHostedRunnersForOrgResponseBody struct {
	Runners    []components.Runner `json:"runners,omitempty"`
	TotalCount int64               `json:"total_count,omitempty"`
}

/*
ListSelfHostedRunnersForOrgResponse is a response for ListSelfHostedRunnersForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
type ListSelfHostedRunnersForOrgResponse struct {
	httpResponse *http.Response
	Data         ListSelfHostedRunnersForOrgResponseBody
}

func (r *ListSelfHostedRunnersForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListSelfHostedRunnersForRepo performs requests for "actions/list-self-hosted-runners-for-repo"

List self-hosted runners for a repository.

  GET /repos/{owner}/{repo}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
func ListSelfHostedRunnersForRepo(ctx context.Context, req *ListSelfHostedRunnersForRepoReq, opt ...requests.Option) (*ListSelfHostedRunnersForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListSelfHostedRunnersForRepoReq)
	}
	resp := &ListSelfHostedRunnersForRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListSelfHostedRunnersForRepoResponse(r, opts.PreserveResponseBody())
}

// NewListSelfHostedRunnersForRepoResponse builds a new *ListSelfHostedRunnersForRepoResponse from an *http.Response
func NewListSelfHostedRunnersForRepoResponse(resp *http.Response, preserveBody bool) (*ListSelfHostedRunnersForRepoResponse, error) {
	var result ListSelfHostedRunnersForRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListSelfHostedRunnersForRepo performs requests for "actions/list-self-hosted-runners-for-repo"

List self-hosted runners for a repository.

  GET /repos/{owner}/{repo}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
func (c Client) ListSelfHostedRunnersForRepo(ctx context.Context, req *ListSelfHostedRunnersForRepoReq, opt ...requests.Option) (*ListSelfHostedRunnersForRepoResponse, error) {
	return ListSelfHostedRunnersForRepo(ctx, req, append(c, opt...)...)
}

/*
ListSelfHostedRunnersForRepoReq is request data for Client.ListSelfHostedRunnersForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
type ListSelfHostedRunnersForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListSelfHostedRunnersForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListSelfHostedRunnersForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/list-self-hosted-runners-for-repo",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runners", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListSelfHostedRunnersForRepoReq) Rel(link string, resp *ListSelfHostedRunnersForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListSelfHostedRunnersForRepoResponseBody is a response body for ListSelfHostedRunnersForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
type ListSelfHostedRunnersForRepoResponseBody struct {
	Runners    []components.Runner `json:"runners,omitempty"`
	TotalCount int64               `json:"total_count,omitempty"`
}

/*
ListSelfHostedRunnersForRepoResponse is a response for ListSelfHostedRunnersForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
type ListSelfHostedRunnersForRepoResponse struct {
	httpResponse *http.Response
	Data         ListSelfHostedRunnersForRepoResponseBody
}

func (r *ListSelfHostedRunnersForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListWorkflowRunArtifacts performs requests for "actions/list-workflow-run-artifacts"

List workflow run artifacts.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
func ListWorkflowRunArtifacts(ctx context.Context, req *ListWorkflowRunArtifactsReq, opt ...requests.Option) (*ListWorkflowRunArtifactsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListWorkflowRunArtifactsReq)
	}
	resp := &ListWorkflowRunArtifactsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListWorkflowRunArtifactsResponse(r, opts.PreserveResponseBody())
}

// NewListWorkflowRunArtifactsResponse builds a new *ListWorkflowRunArtifactsResponse from an *http.Response
func NewListWorkflowRunArtifactsResponse(resp *http.Response, preserveBody bool) (*ListWorkflowRunArtifactsResponse, error) {
	var result ListWorkflowRunArtifactsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListWorkflowRunArtifacts performs requests for "actions/list-workflow-run-artifacts"

List workflow run artifacts.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
func (c Client) ListWorkflowRunArtifacts(ctx context.Context, req *ListWorkflowRunArtifactsReq, opt ...requests.Option) (*ListWorkflowRunArtifactsResponse, error) {
	return ListWorkflowRunArtifacts(ctx, req, append(c, opt...)...)
}

/*
ListWorkflowRunArtifactsReq is request data for Client.ListWorkflowRunArtifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
type ListWorkflowRunArtifactsReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListWorkflowRunArtifactsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListWorkflowRunArtifactsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/list-workflow-run-artifacts",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runs/%v/artifacts", r.Owner, r.Repo, r.RunId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListWorkflowRunArtifactsReq) Rel(link string, resp *ListWorkflowRunArtifactsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListWorkflowRunArtifactsResponseBody is a response body for ListWorkflowRunArtifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
type ListWorkflowRunArtifactsResponseBody struct {
	Artifacts  []components.Artifact `json:"artifacts,omitempty"`
	TotalCount int64                 `json:"total_count,omitempty"`
}

/*
ListWorkflowRunArtifactsResponse is a response for ListWorkflowRunArtifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
type ListWorkflowRunArtifactsResponse struct {
	httpResponse *http.Response
	Data         ListWorkflowRunArtifactsResponseBody
}

func (r *ListWorkflowRunArtifactsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListWorkflowRuns performs requests for "actions/list-workflow-runs"

List workflow runs.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
func ListWorkflowRuns(ctx context.Context, req *ListWorkflowRunsReq, opt ...requests.Option) (*ListWorkflowRunsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListWorkflowRunsReq)
	}
	resp := &ListWorkflowRunsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListWorkflowRunsResponse(r, opts.PreserveResponseBody())
}

// NewListWorkflowRunsResponse builds a new *ListWorkflowRunsResponse from an *http.Response
func NewListWorkflowRunsResponse(resp *http.Response, preserveBody bool) (*ListWorkflowRunsResponse, error) {
	var result ListWorkflowRunsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListWorkflowRuns performs requests for "actions/list-workflow-runs"

List workflow runs.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
func (c Client) ListWorkflowRuns(ctx context.Context, req *ListWorkflowRunsReq, opt ...requests.Option) (*ListWorkflowRunsResponse, error) {
	return ListWorkflowRuns(ctx, req, append(c, opt...)...)
}

/*
ListWorkflowRunsReq is request data for Client.ListWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
type ListWorkflowRunsReq struct {
	_url       string
	Owner      string
	Repo       string
	WorkflowId int64

	/*
	Returns someone's workflow runs. Use the login for the user who created the
	`push` associated with the check suite or workflow run.
	*/
	Actor *string

	/*
	Returns workflow runs associated with a branch. Use the name of the branch of
	the `push`.
	*/
	Branch *string

	/*
	Returns workflow run triggered by the event you specify. For example, `push`,
	`pull_request` or `issue`. For more information, see "[Events that trigger
	workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
	*/
	Event *string

	/*
	Returns workflow runs associated with the check run `status` or `conclusion` you
	specify. For example, a conclusion can be `success` or a status can be
	`completed`. For more information, see the `status` and `conclusion` options
	available in "[Create a check
	run](https://developer.github.com/v3/checks/runs/#create-a-check-run)."
	*/
	Status *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListWorkflowRunsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListWorkflowRunsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Actor != nil {
		query.Set("actor", *r.Actor)
	}
	if r.Branch != nil {
		query.Set("branch", *r.Branch)
	}
	if r.Event != nil {
		query.Set("event", *r.Event)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/list-workflow-runs",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/workflows/%v/runs", r.Owner, r.Repo, r.WorkflowId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListWorkflowRunsReq) Rel(link string, resp *ListWorkflowRunsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListWorkflowRunsResponseBody is a response body for ListWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
type ListWorkflowRunsResponseBody struct {
	TotalCount   int64                    `json:"total_count,omitempty"`
	WorkflowRuns []components.WorkflowRun `json:"workflow_runs,omitempty"`
}

/*
ListWorkflowRunsResponse is a response for ListWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
type ListWorkflowRunsResponse struct {
	httpResponse *http.Response
	Data         ListWorkflowRunsResponseBody
}

func (r *ListWorkflowRunsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListWorkflowRunsForRepo performs requests for "actions/list-workflow-runs-for-repo"

List workflow runs for a repository.

  GET /repos/{owner}/{repo}/actions/runs

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
func ListWorkflowRunsForRepo(ctx context.Context, req *ListWorkflowRunsForRepoReq, opt ...requests.Option) (*ListWorkflowRunsForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListWorkflowRunsForRepoReq)
	}
	resp := &ListWorkflowRunsForRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListWorkflowRunsForRepoResponse(r, opts.PreserveResponseBody())
}

// NewListWorkflowRunsForRepoResponse builds a new *ListWorkflowRunsForRepoResponse from an *http.Response
func NewListWorkflowRunsForRepoResponse(resp *http.Response, preserveBody bool) (*ListWorkflowRunsForRepoResponse, error) {
	var result ListWorkflowRunsForRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListWorkflowRunsForRepo performs requests for "actions/list-workflow-runs-for-repo"

List workflow runs for a repository.

  GET /repos/{owner}/{repo}/actions/runs

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
func (c Client) ListWorkflowRunsForRepo(ctx context.Context, req *ListWorkflowRunsForRepoReq, opt ...requests.Option) (*ListWorkflowRunsForRepoResponse, error) {
	return ListWorkflowRunsForRepo(ctx, req, append(c, opt...)...)
}

/*
ListWorkflowRunsForRepoReq is request data for Client.ListWorkflowRunsForRepo

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
type ListWorkflowRunsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Returns someone's workflow runs. Use the login for the user who created the
	`push` associated with the check suite or workflow run.
	*/
	Actor *string

	/*
	Returns workflow runs associated with a branch. Use the name of the branch of
	the `push`.
	*/
	Branch *string

	/*
	Returns workflow run triggered by the event you specify. For example, `push`,
	`pull_request` or `issue`. For more information, see "[Events that trigger
	workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
	*/
	Event *string

	/*
	Returns workflow runs associated with the check run `status` or `conclusion` you
	specify. For example, a conclusion can be `success` or a status can be
	`completed`. For more information, see the `status` and `conclusion` options
	available in "[Create a check
	run](https://developer.github.com/v3/checks/runs/#create-a-check-run)."
	*/
	Status *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListWorkflowRunsForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListWorkflowRunsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Actor != nil {
		query.Set("actor", *r.Actor)
	}
	if r.Branch != nil {
		query.Set("branch", *r.Branch)
	}
	if r.Event != nil {
		query.Set("event", *r.Event)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "actions/list-workflow-runs-for-repo",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runs", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListWorkflowRunsForRepoReq) Rel(link string, resp *ListWorkflowRunsForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListWorkflowRunsForRepoResponseBody is a response body for ListWorkflowRunsForRepo

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
type ListWorkflowRunsForRepoResponseBody struct {
	TotalCount   int64                    `json:"total_count,omitempty"`
	WorkflowRuns []components.WorkflowRun `json:"workflow_runs,omitempty"`
}

/*
ListWorkflowRunsForRepoResponse is a response for ListWorkflowRunsForRepo

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
type ListWorkflowRunsForRepoResponse struct {
	httpResponse *http.Response
	Data         ListWorkflowRunsForRepoResponseBody
}

func (r *ListWorkflowRunsForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ReRunWorkflow performs requests for "actions/re-run-workflow"

Re-run a workflow.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
func ReRunWorkflow(ctx context.Context, req *ReRunWorkflowReq, opt ...requests.Option) (*ReRunWorkflowResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReRunWorkflowReq)
	}
	resp := &ReRunWorkflowResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewReRunWorkflowResponse(r, opts.PreserveResponseBody())
}

// NewReRunWorkflowResponse builds a new *ReRunWorkflowResponse from an *http.Response
func NewReRunWorkflowResponse(resp *http.Response, preserveBody bool) (*ReRunWorkflowResponse, error) {
	var result ReRunWorkflowResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
ReRunWorkflow performs requests for "actions/re-run-workflow"

Re-run a workflow.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
func (c Client) ReRunWorkflow(ctx context.Context, req *ReRunWorkflowReq, opt ...requests.Option) (*ReRunWorkflowResponse, error) {
	return ReRunWorkflow(ctx, req, append(c, opt...)...)
}

/*
ReRunWorkflowReq is request data for Client.ReRunWorkflow

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
type ReRunWorkflowReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *ReRunWorkflowReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReRunWorkflowReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "POST",
		OperationID:        "actions/re-run-workflow",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/actions/runs/%v/rerun", r.Owner, r.Repo, r.RunId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReRunWorkflowReq) Rel(link string, resp *ReRunWorkflowResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReRunWorkflowResponse is a response for ReRunWorkflow

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
type ReRunWorkflowResponse struct {
	httpResponse *http.Response
}

func (r *ReRunWorkflowResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveSelectedRepoFromOrgSecret performs requests for "actions/remove-selected-repo-from-org-secret"

Remove selected repository from an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
func RemoveSelectedRepoFromOrgSecret(ctx context.Context, req *RemoveSelectedRepoFromOrgSecretReq, opt ...requests.Option) (*RemoveSelectedRepoFromOrgSecretResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveSelectedRepoFromOrgSecretReq)
	}
	resp := &RemoveSelectedRepoFromOrgSecretResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveSelectedRepoFromOrgSecretResponse(r, opts.PreserveResponseBody())
}

// NewRemoveSelectedRepoFromOrgSecretResponse builds a new *RemoveSelectedRepoFromOrgSecretResponse from an *http.Response
func NewRemoveSelectedRepoFromOrgSecretResponse(resp *http.Response, preserveBody bool) (*RemoveSelectedRepoFromOrgSecretResponse, error) {
	var result RemoveSelectedRepoFromOrgSecretResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveSelectedRepoFromOrgSecret performs requests for "actions/remove-selected-repo-from-org-secret"

Remove selected repository from an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
func (c Client) RemoveSelectedRepoFromOrgSecret(ctx context.Context, req *RemoveSelectedRepoFromOrgSecretReq, opt ...requests.Option) (*RemoveSelectedRepoFromOrgSecretResponse, error) {
	return RemoveSelectedRepoFromOrgSecret(ctx, req, append(c, opt...)...)
}

/*
RemoveSelectedRepoFromOrgSecretReq is request data for Client.RemoveSelectedRepoFromOrgSecret

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
type RemoveSelectedRepoFromOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string

	// repository_id parameter
	RepositoryId int64
}

// HTTPRequest builds an *http.Request
func (r *RemoveSelectedRepoFromOrgSecretReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveSelectedRepoFromOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "actions/remove-selected-repo-from-org-secret",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories/%v", r.Org, r.SecretName, r.RepositoryId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveSelectedRepoFromOrgSecretReq) Rel(link string, resp *RemoveSelectedRepoFromOrgSecretResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveSelectedRepoFromOrgSecretResponse is a response for RemoveSelectedRepoFromOrgSecret

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
type RemoveSelectedRepoFromOrgSecretResponse struct {
	httpResponse *http.Response
}

func (r *RemoveSelectedRepoFromOrgSecretResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
SetSelectedReposForOrgSecret performs requests for "actions/set-selected-repos-for-org-secret"

Set selected repositories for an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
func SetSelectedReposForOrgSecret(ctx context.Context, req *SetSelectedReposForOrgSecretReq, opt ...requests.Option) (*SetSelectedReposForOrgSecretResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetSelectedReposForOrgSecretReq)
	}
	resp := &SetSelectedReposForOrgSecretResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewSetSelectedReposForOrgSecretResponse(r, opts.PreserveResponseBody())
}

// NewSetSelectedReposForOrgSecretResponse builds a new *SetSelectedReposForOrgSecretResponse from an *http.Response
func NewSetSelectedReposForOrgSecretResponse(resp *http.Response, preserveBody bool) (*SetSelectedReposForOrgSecretResponse, error) {
	var result SetSelectedReposForOrgSecretResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
SetSelectedReposForOrgSecret performs requests for "actions/set-selected-repos-for-org-secret"

Set selected repositories for an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
func (c Client) SetSelectedReposForOrgSecret(ctx context.Context, req *SetSelectedReposForOrgSecretReq, opt ...requests.Option) (*SetSelectedReposForOrgSecretResponse, error) {
	return SetSelectedReposForOrgSecret(ctx, req, append(c, opt...)...)
}

/*
SetSelectedReposForOrgSecretReq is request data for Client.SetSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
type SetSelectedReposForOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName  string
	RequestBody SetSelectedReposForOrgSecretReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetSelectedReposForOrgSecretReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetSelectedReposForOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "PUT",
		OperationID:        "actions/set-selected-repos-for-org-secret",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories", r.Org, r.SecretName),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetSelectedReposForOrgSecretReq) Rel(link string, resp *SetSelectedReposForOrgSecretResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetSelectedReposForOrgSecretReqBody is a request body for actions/set-selected-repos-for-org-secret

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
type SetSelectedReposForOrgSecretReqBody struct {

	/*
	An array of repository ids that can access the organization secret. You can only
	provide a list of repository ids when the `visibility` is set to `selected`. You
	can add and remove individual repositories using the [Set selected repositories
	for an organization
	secret](https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret)
	and [Remove selected repository from an organization
	secret](https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret)
	endpoints.
	*/
	SelectedRepositoryIds []int64 `json:"selected_repository_ids,omitempty"`
}

/*
SetSelectedReposForOrgSecretResponse is a response for SetSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
type SetSelectedReposForOrgSecretResponse struct {
	httpResponse *http.Response
}

func (r *SetSelectedReposForOrgSecretResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}
