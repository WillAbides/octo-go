// Code generated by octo-go; DO NOT EDIT.

package orgs

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
BlockUser performs requests for "orgs/block-user"

Block a user from an organization.

  PUT /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
func BlockUser(ctx context.Context, req *BlockUserReq, opt ...requests.Option) (*BlockUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(BlockUserReq)
	}
	resp := &BlockUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
BlockUser performs requests for "orgs/block-user"

Block a user from an organization.

  PUT /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
func (c Client) BlockUser(ctx context.Context, req *BlockUserReq, opt ...requests.Option) (*BlockUserResponse, error) {
	return BlockUser(ctx, req, append(c, opt...)...)
}

/*
BlockUserReq is request data for Client.BlockUser

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
type BlockUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *BlockUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *BlockUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "orgs/block-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BlockUserReq) Rel(link string, resp *BlockUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BlockUserResponse is a response for BlockUser

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
type BlockUserResponse struct {
	requests.Response
	request *BlockUserReq
}

/*
CheckBlockedUser performs requests for "orgs/check-blocked-user"

Check if a user is blocked by an organization.

  GET /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
func CheckBlockedUser(ctx context.Context, req *CheckBlockedUserReq, opt ...requests.Option) (*CheckBlockedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckBlockedUserReq)
	}
	resp := &CheckBlockedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckBlockedUser performs requests for "orgs/check-blocked-user"

Check if a user is blocked by an organization.

  GET /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
func (c Client) CheckBlockedUser(ctx context.Context, req *CheckBlockedUserReq, opt ...requests.Option) (*CheckBlockedUserResponse, error) {
	return CheckBlockedUser(ctx, req, append(c, opt...)...)
}

/*
CheckBlockedUserReq is request data for Client.CheckBlockedUser

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
type CheckBlockedUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *CheckBlockedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckBlockedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "orgs/check-blocked-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckBlockedUserReq) Rel(link string, resp *CheckBlockedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckBlockedUserResponse is a response for CheckBlockedUser

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
type CheckBlockedUserResponse struct {
	requests.Response
	request *CheckBlockedUserReq
	Data    bool
}

/*
CheckMembershipForUser performs requests for "orgs/check-membership-for-user"

Check organization membership for a user.

  GET /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
func CheckMembershipForUser(ctx context.Context, req *CheckMembershipForUserReq, opt ...requests.Option) (*CheckMembershipForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckMembershipForUserReq)
	}
	resp := &CheckMembershipForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckMembershipForUser performs requests for "orgs/check-membership-for-user"

Check organization membership for a user.

  GET /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
func (c Client) CheckMembershipForUser(ctx context.Context, req *CheckMembershipForUserReq, opt ...requests.Option) (*CheckMembershipForUserResponse, error) {
	return CheckMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
CheckMembershipForUserReq is request data for Client.CheckMembershipForUser

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
type CheckMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *CheckMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "orgs/check-membership-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/members/%v", r.Org, r.Username),
		URLQuery:           query,
		ValidStatuses:      []int{204, 302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckMembershipForUserReq) Rel(link string, resp *CheckMembershipForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckMembershipForUserResponse is a response for CheckMembershipForUser

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
type CheckMembershipForUserResponse struct {
	requests.Response
	request *CheckMembershipForUserReq
}

/*
CheckPublicMembershipForUser performs requests for "orgs/check-public-membership-for-user"

Check public organization membership for a user.

  GET /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
func CheckPublicMembershipForUser(ctx context.Context, req *CheckPublicMembershipForUserReq, opt ...requests.Option) (*CheckPublicMembershipForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckPublicMembershipForUserReq)
	}
	resp := &CheckPublicMembershipForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckPublicMembershipForUser performs requests for "orgs/check-public-membership-for-user"

Check public organization membership for a user.

  GET /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
func (c Client) CheckPublicMembershipForUser(ctx context.Context, req *CheckPublicMembershipForUserReq, opt ...requests.Option) (*CheckPublicMembershipForUserResponse, error) {
	return CheckPublicMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
CheckPublicMembershipForUserReq is request data for Client.CheckPublicMembershipForUser

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
type CheckPublicMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *CheckPublicMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckPublicMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "orgs/check-public-membership-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckPublicMembershipForUserReq) Rel(link string, resp *CheckPublicMembershipForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckPublicMembershipForUserResponse is a response for CheckPublicMembershipForUser

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
type CheckPublicMembershipForUserResponse struct {
	requests.Response
	request *CheckPublicMembershipForUserReq
	Data    bool
}

/*
ConvertMemberToOutsideCollaborator performs requests for "orgs/convert-member-to-outside-collaborator"

Convert an organization member to outside collaborator.

  PUT /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
func ConvertMemberToOutsideCollaborator(ctx context.Context, req *ConvertMemberToOutsideCollaboratorReq, opt ...requests.Option) (*ConvertMemberToOutsideCollaboratorResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ConvertMemberToOutsideCollaboratorReq)
	}
	resp := &ConvertMemberToOutsideCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ConvertMemberToOutsideCollaborator performs requests for "orgs/convert-member-to-outside-collaborator"

Convert an organization member to outside collaborator.

  PUT /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
func (c Client) ConvertMemberToOutsideCollaborator(ctx context.Context, req *ConvertMemberToOutsideCollaboratorReq, opt ...requests.Option) (*ConvertMemberToOutsideCollaboratorResponse, error) {
	return ConvertMemberToOutsideCollaborator(ctx, req, append(c, opt...)...)
}

/*
ConvertMemberToOutsideCollaboratorReq is request data for Client.ConvertMemberToOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
type ConvertMemberToOutsideCollaboratorReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *ConvertMemberToOutsideCollaboratorReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ConvertMemberToOutsideCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "orgs/convert-member-to-outside-collaborator",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/outside_collaborators/%v", r.Org, r.Username),
		URLQuery:           query,
		ValidStatuses:      []int{202, 204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ConvertMemberToOutsideCollaboratorReq) Rel(link string, resp *ConvertMemberToOutsideCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ConvertMemberToOutsideCollaboratorResponse is a response for ConvertMemberToOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
type ConvertMemberToOutsideCollaboratorResponse struct {
	requests.Response
	request *ConvertMemberToOutsideCollaboratorReq
}

/*
CreateInvitation performs requests for "orgs/create-invitation"

Create an organization invitation.

  POST /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
func CreateInvitation(ctx context.Context, req *CreateInvitationReq, opt ...requests.Option) (*CreateInvitationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateInvitationReq)
	}
	resp := &CreateInvitationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrganizationInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateInvitation performs requests for "orgs/create-invitation"

Create an organization invitation.

  POST /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
func (c Client) CreateInvitation(ctx context.Context, req *CreateInvitationReq, opt ...requests.Option) (*CreateInvitationResponse, error) {
	return CreateInvitation(ctx, req, append(c, opt...)...)
}

/*
CreateInvitationReq is request data for Client.CreateInvitation

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
type CreateInvitationReq struct {
	_url        string
	Org         string
	RequestBody CreateInvitationReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateInvitationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateInvitationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		DataStatuses:       []int{201},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "orgs/create-invitation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/invitations", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateInvitationReq) Rel(link string, resp *CreateInvitationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateInvitationReqBody is a request body for orgs/create-invitation

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
type CreateInvitationReqBody struct {

	/*
	**Required unless you provide `invitee_id`**. Email address of the person you
	are inviting, which can be an existing GitHub user.
	*/
	Email *string `json:"email,omitempty"`

	// **Required unless you provide `email`**. GitHub user ID for the person you are inviting.
	InviteeId *int64 `json:"invitee_id,omitempty"`

	/*
	Specify role for new member. Can be one of:
	\* `admin` - Organization owners with full administrative rights to the
	organization and complete access to all repositories and teams.
	\* `direct_member` - Non-owner organization members with ability to see other
	members and join teams by invitation.
	\* `billing_manager` - Non-owner organization members with ability to manage the
	billing settings of your organization.
	*/
	Role *string `json:"role,omitempty"`

	// Specify IDs for the teams you want to invite new members to.
	TeamIds []int64 `json:"team_ids,omitempty"`
}

/*
CreateInvitationResponse is a response for CreateInvitation

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
type CreateInvitationResponse struct {
	requests.Response
	request *CreateInvitationReq
	Data    components.OrganizationInvitation
}

/*
CreateWebhook performs requests for "orgs/create-webhook"

Create an organization webhook.

  POST /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
func CreateWebhook(ctx context.Context, req *CreateWebhookReq, opt ...requests.Option) (*CreateWebhookResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateWebhookReq)
	}
	resp := &CreateWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgHook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateWebhook performs requests for "orgs/create-webhook"

Create an organization webhook.

  POST /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
func (c Client) CreateWebhook(ctx context.Context, req *CreateWebhookReq, opt ...requests.Option) (*CreateWebhookResponse, error) {
	return CreateWebhook(ctx, req, append(c, opt...)...)
}

/*
CreateWebhookReq is request data for Client.CreateWebhook

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
type CreateWebhookReq struct {
	_url        string
	Org         string
	RequestBody CreateWebhookReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		DataStatuses:       []int{201},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "orgs/create-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/hooks", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateWebhookReq) Rel(link string, resp *CreateWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateWebhookReqBodyConfig is a value for CreateWebhookReqBody's Config field
type CreateWebhookReqBodyConfig struct {

	// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
	ContentType *string `json:"content_type,omitempty"`

	/*
	Determines whether the SSL certificate of the host for `url` will be verified
	when delivering payloads. Supported values include `0` (verification is
	performed) and `1` (verification is not performed). The default is `0`. **We
	strongly recommend not setting this to `1` as you are subject to
	man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`
	Password    *string `json:"password,omitempty"`

	/*
	If provided, the `secret` will be used as the `key` to generate the HMAC hex
	digest value in the
	[`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url      *string `json:"url"`
	Username *string `json:"username,omitempty"`
}

/*
CreateWebhookReqBody is a request body for orgs/create-webhook

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
type CreateWebhookReqBody struct {

	// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
	Active *bool `json:"active,omitempty"`

	/*
	Key/value pairs to provide settings for this webhook. [These are defined
	below](https://developer.github.com/v3/orgs/hooks/#create-hook-config-params).
	*/
	Config *CreateWebhookReqBodyConfig `json:"config"`

	// Determines what [events](https://developer.github.com/webhooks/event-payloads) the hook is triggered for.
	Events []string `json:"events,omitempty"`

	// Must be passed as "web".
	Name *string `json:"name"`
}

/*
CreateWebhookResponse is a response for CreateWebhook

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
type CreateWebhookResponse struct {
	requests.Response
	request *CreateWebhookReq
	Data    components.OrgHook
}

/*
DeleteWebhook performs requests for "orgs/delete-webhook"

Delete an organization webhook.

  DELETE /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
func DeleteWebhook(ctx context.Context, req *DeleteWebhookReq, opt ...requests.Option) (*DeleteWebhookResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteWebhookReq)
	}
	resp := &DeleteWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteWebhook performs requests for "orgs/delete-webhook"

Delete an organization webhook.

  DELETE /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
func (c Client) DeleteWebhook(ctx context.Context, req *DeleteWebhookReq, opt ...requests.Option) (*DeleteWebhookResponse, error) {
	return DeleteWebhook(ctx, req, append(c, opt...)...)
}

/*
DeleteWebhookReq is request data for Client.DeleteWebhook

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
type DeleteWebhookReq struct {
	_url   string
	Org    string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/delete-webhook",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteWebhookReq) Rel(link string, resp *DeleteWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteWebhookResponse is a response for DeleteWebhook

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
type DeleteWebhookResponse struct {
	requests.Response
	request *DeleteWebhookReq
	Data    bool
}

/*
Get performs requests for "orgs/get"

Get an organization.

  GET /orgs/{org}

https://developer.github.com/v3/orgs/#get-an-organization
*/
func Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetReq)
	}
	resp := &GetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrganizationFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Get performs requests for "orgs/get"

Get an organization.

  GET /orgs/{org}

https://developer.github.com/v3/orgs/#get-an-organization
*/
func (c Client) Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	return Get(ctx, req, append(c, opt...)...)
}

/*
GetReq is request data for Client.Get

https://developer.github.com/v3/orgs/#get-an-organization
*/
type GetReq struct {
	_url string
	Org  string

	/*
	New repository creation permissions are available to preview. You can now use
	`members_can_create_public_repositories`,
	`members_can_create_private_repositories`, and
	`members_can_create_internal_repositories`. You can only allow members to create
	internal repositories if your organization is associated with an enterprise
	account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. These
	parameters provide more granular permissions to configure the type of
	repositories organization members can create.

	To access these new parameters during the preview period, you must set this to
	true.
	*/
	SurturPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"surtur"},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/get",
		Previews:           map[string]bool{"surtur": r.SurturPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v", r.Org),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReq) Rel(link string, resp *GetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetResponse is a response for Get

https://developer.github.com/v3/orgs/#get-an-organization
*/
type GetResponse struct {
	requests.Response
	request *GetReq
	Data    components.OrganizationFull
}

/*
GetMembershipForAuthenticatedUser performs requests for "orgs/get-membership-for-authenticated-user"

Get an organization membership for the authenticated user.

  GET /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
func GetMembershipForAuthenticatedUser(ctx context.Context, req *GetMembershipForAuthenticatedUserReq, opt ...requests.Option) (*GetMembershipForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetMembershipForAuthenticatedUserReq)
	}
	resp := &GetMembershipForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetMembershipForAuthenticatedUser performs requests for "orgs/get-membership-for-authenticated-user"

Get an organization membership for the authenticated user.

  GET /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
func (c Client) GetMembershipForAuthenticatedUser(ctx context.Context, req *GetMembershipForAuthenticatedUserReq, opt ...requests.Option) (*GetMembershipForAuthenticatedUserResponse, error) {
	return GetMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
GetMembershipForAuthenticatedUserReq is request data for Client.GetMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
type GetMembershipForAuthenticatedUserReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *GetMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetMembershipForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/get-membership-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/memberships/orgs/%v", r.Org),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetMembershipForAuthenticatedUserReq) Rel(link string, resp *GetMembershipForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetMembershipForAuthenticatedUserResponse is a response for GetMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
type GetMembershipForAuthenticatedUserResponse struct {
	requests.Response
	request *GetMembershipForAuthenticatedUserReq
	Data    components.OrgMembership
}

/*
GetMembershipForUser performs requests for "orgs/get-membership-for-user"

Get organization membership for a user.

  GET /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
func GetMembershipForUser(ctx context.Context, req *GetMembershipForUserReq, opt ...requests.Option) (*GetMembershipForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetMembershipForUserReq)
	}
	resp := &GetMembershipForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetMembershipForUser performs requests for "orgs/get-membership-for-user"

Get organization membership for a user.

  GET /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
func (c Client) GetMembershipForUser(ctx context.Context, req *GetMembershipForUserReq, opt ...requests.Option) (*GetMembershipForUserResponse, error) {
	return GetMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
GetMembershipForUserReq is request data for Client.GetMembershipForUser

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
type GetMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/get-membership-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetMembershipForUserReq) Rel(link string, resp *GetMembershipForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetMembershipForUserResponse is a response for GetMembershipForUser

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
type GetMembershipForUserResponse struct {
	requests.Response
	request *GetMembershipForUserReq
	Data    components.OrgMembership
}

/*
GetWebhook performs requests for "orgs/get-webhook"

Get an organization webhook.

  GET /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
func GetWebhook(ctx context.Context, req *GetWebhookReq, opt ...requests.Option) (*GetWebhookResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetWebhookReq)
	}
	resp := &GetWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgHook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetWebhook performs requests for "orgs/get-webhook"

Get an organization webhook.

  GET /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
func (c Client) GetWebhook(ctx context.Context, req *GetWebhookReq, opt ...requests.Option) (*GetWebhookResponse, error) {
	return GetWebhook(ctx, req, append(c, opt...)...)
}

/*
GetWebhookReq is request data for Client.GetWebhook

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
type GetWebhookReq struct {
	_url   string
	Org    string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *GetWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/get-webhook",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetWebhookReq) Rel(link string, resp *GetWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetWebhookResponse is a response for GetWebhook

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
type GetWebhookResponse struct {
	requests.Response
	request *GetWebhookReq
	Data    components.OrgHook
}

/*
List performs requests for "orgs/list"

List organizations.

  GET /organizations

https://developer.github.com/v3/orgs/#list-organizations
*/
func List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReq)
	}
	resp := &ListResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrganizationSimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
List performs requests for "orgs/list"

List organizations.

  GET /organizations

https://developer.github.com/v3/orgs/#list-organizations
*/
func (c Client) List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	return List(ctx, req, append(c, opt...)...)
}

/*
ListReq is request data for Client.List

https://developer.github.com/v3/orgs/#list-organizations
*/
type ListReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/organizations"),
		URLQuery:           query,
		ValidStatuses:      []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReq) Rel(link string, resp *ListResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListResponse is a response for List

https://developer.github.com/v3/orgs/#list-organizations
*/
type ListResponse struct {
	requests.Response
	request *ListReq
	Data    []components.OrganizationSimple
}

/*
ListAppInstallations performs requests for "orgs/list-app-installations"

List app installations for an organization.

  GET /orgs/{org}/installations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
func ListAppInstallations(ctx context.Context, req *ListAppInstallationsReq, opt ...requests.Option) (*ListAppInstallationsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListAppInstallationsReq)
	}
	resp := &ListAppInstallationsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ListAppInstallationsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListAppInstallations performs requests for "orgs/list-app-installations"

List app installations for an organization.

  GET /orgs/{org}/installations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
func (c Client) ListAppInstallations(ctx context.Context, req *ListAppInstallationsReq, opt ...requests.Option) (*ListAppInstallationsResponse, error) {
	return ListAppInstallations(ctx, req, append(c, opt...)...)
}

/*
ListAppInstallationsReq is request data for Client.ListAppInstallations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
type ListAppInstallationsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListAppInstallationsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListAppInstallationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-app-installations",
		Previews:           map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews:   []string{"machine-man"},
		URLPath:            fmt.Sprintf("/orgs/%v/installations", r.Org),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListAppInstallationsReq) Rel(link string, resp *ListAppInstallationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListAppInstallationsResponseBody is a response body for ListAppInstallations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
type ListAppInstallationsResponseBody struct {
	Installations []components.Installation `json:"installations,omitempty"`
	TotalCount    int64                     `json:"total_count,omitempty"`
}

/*
ListAppInstallationsResponse is a response for ListAppInstallations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
type ListAppInstallationsResponse struct {
	requests.Response
	request *ListAppInstallationsReq
	Data    ListAppInstallationsResponseBody
}

/*
ListBlockedUsers performs requests for "orgs/list-blocked-users"

List users blocked by an organization.

  GET /orgs/{org}/blocks

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
func ListBlockedUsers(ctx context.Context, req *ListBlockedUsersReq, opt ...requests.Option) (*ListBlockedUsersResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListBlockedUsersReq)
	}
	resp := &ListBlockedUsersResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListBlockedUsers performs requests for "orgs/list-blocked-users"

List users blocked by an organization.

  GET /orgs/{org}/blocks

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
func (c Client) ListBlockedUsers(ctx context.Context, req *ListBlockedUsersReq, opt ...requests.Option) (*ListBlockedUsersResponse, error) {
	return ListBlockedUsers(ctx, req, append(c, opt...)...)
}

/*
ListBlockedUsersReq is request data for Client.ListBlockedUsers

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
type ListBlockedUsersReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *ListBlockedUsersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListBlockedUsersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-blocked-users",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/blocks", r.Org),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListBlockedUsersReq) Rel(link string, resp *ListBlockedUsersResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListBlockedUsersResponse is a response for ListBlockedUsers

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
type ListBlockedUsersResponse struct {
	requests.Response
	request *ListBlockedUsersReq
	Data    []components.SimpleUser
}

/*
ListForAuthenticatedUser performs requests for "orgs/list-for-authenticated-user"

List organizations for the authenticated user.

  GET /user/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
func ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForAuthenticatedUserReq)
	}
	resp := &ListForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrganizationSimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForAuthenticatedUser performs requests for "orgs/list-for-authenticated-user"

List organizations for the authenticated user.

  GET /user/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
func (c Client) ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	return ListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListForAuthenticatedUserReq is request data for Client.ListForAuthenticatedUser

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
type ListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/orgs"),
		URLQuery:           query,
		ValidStatuses:      []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForAuthenticatedUserReq) Rel(link string, resp *ListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForAuthenticatedUserResponse is a response for ListForAuthenticatedUser

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
type ListForAuthenticatedUserResponse struct {
	requests.Response
	request *ListForAuthenticatedUserReq
	Data    []components.OrganizationSimple
}

/*
ListForUser performs requests for "orgs/list-for-user"

List organizations for a user.

  GET /users/{username}/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
func ListForUser(ctx context.Context, req *ListForUserReq, opt ...requests.Option) (*ListForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForUserReq)
	}
	resp := &ListForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrganizationSimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForUser performs requests for "orgs/list-for-user"

List organizations for a user.

  GET /users/{username}/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
func (c Client) ListForUser(ctx context.Context, req *ListForUserReq, opt ...requests.Option) (*ListForUserResponse, error) {
	return ListForUser(ctx, req, append(c, opt...)...)
}

/*
ListForUserReq is request data for Client.ListForUser

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
type ListForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/orgs", r.Username),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForUserReq) Rel(link string, resp *ListForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForUserResponse is a response for ListForUser

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
type ListForUserResponse struct {
	requests.Response
	request *ListForUserReq
	Data    []components.OrganizationSimple
}

/*
ListInvitationTeams performs requests for "orgs/list-invitation-teams"

List organization invitation teams.

  GET /orgs/{org}/invitations/{invitation_id}/teams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
func ListInvitationTeams(ctx context.Context, req *ListInvitationTeamsReq, opt ...requests.Option) (*ListInvitationTeamsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListInvitationTeamsReq)
	}
	resp := &ListInvitationTeamsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListInvitationTeams performs requests for "orgs/list-invitation-teams"

List organization invitation teams.

  GET /orgs/{org}/invitations/{invitation_id}/teams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
func (c Client) ListInvitationTeams(ctx context.Context, req *ListInvitationTeamsReq, opt ...requests.Option) (*ListInvitationTeamsResponse, error) {
	return ListInvitationTeams(ctx, req, append(c, opt...)...)
}

/*
ListInvitationTeamsReq is request data for Client.ListInvitationTeams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
type ListInvitationTeamsReq struct {
	_url string
	Org  string

	// invitation_id parameter
	InvitationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListInvitationTeamsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListInvitationTeamsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-invitation-teams",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/invitations/%v/teams", r.Org, r.InvitationId),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInvitationTeamsReq) Rel(link string, resp *ListInvitationTeamsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInvitationTeamsResponse is a response for ListInvitationTeams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
type ListInvitationTeamsResponse struct {
	requests.Response
	request *ListInvitationTeamsReq
	Data    []components.Team
}

/*
ListMembers performs requests for "orgs/list-members"

List organization members.

  GET /orgs/{org}/members

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
func ListMembers(ctx context.Context, req *ListMembersReq, opt ...requests.Option) (*ListMembersResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListMembersReq)
	}
	resp := &ListMembersResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListMembers performs requests for "orgs/list-members"

List organization members.

  GET /orgs/{org}/members

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
func (c Client) ListMembers(ctx context.Context, req *ListMembersReq, opt ...requests.Option) (*ListMembersResponse, error) {
	return ListMembers(ctx, req, append(c, opt...)...)
}

/*
ListMembersReq is request data for Client.ListMembers

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
type ListMembersReq struct {
	_url string
	Org  string

	/*
	Filter members returned in the list. Can be one of:
	\* `2fa_disabled` - Members without [two-factor
	authentication](https://github.com/blog/1614-two-factor-authentication) enabled.
	Available for organization owners.
	\* `all` - All members the authenticated user can see.
	*/
	Filter *string

	/*
	Filter members returned by their role. Can be one of:
	\* `all` - All members of the organization, regardless of role.
	\* `admin` - Organization owners.
	\* `member` - Non-owner organization members.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListMembersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListMembersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-members",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/members", r.Org),
		URLQuery:           query,
		ValidStatuses:      []int{200, 302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListMembersReq) Rel(link string, resp *ListMembersResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListMembersResponse is a response for ListMembers

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
type ListMembersResponse struct {
	requests.Response
	request *ListMembersReq
	Data    []components.SimpleUser
}

/*
ListMembershipsForAuthenticatedUser performs requests for "orgs/list-memberships-for-authenticated-user"

List organization memberships for the authenticated user.

  GET /user/memberships/orgs

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
func ListMembershipsForAuthenticatedUser(ctx context.Context, req *ListMembershipsForAuthenticatedUserReq, opt ...requests.Option) (*ListMembershipsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListMembershipsForAuthenticatedUserReq)
	}
	resp := &ListMembershipsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrgMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListMembershipsForAuthenticatedUser performs requests for "orgs/list-memberships-for-authenticated-user"

List organization memberships for the authenticated user.

  GET /user/memberships/orgs

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
func (c Client) ListMembershipsForAuthenticatedUser(ctx context.Context, req *ListMembershipsForAuthenticatedUserReq, opt ...requests.Option) (*ListMembershipsForAuthenticatedUserResponse, error) {
	return ListMembershipsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListMembershipsForAuthenticatedUserReq is request data for Client.ListMembershipsForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
type ListMembershipsForAuthenticatedUserReq struct {
	_url string

	/*
	Indicates the state of the memberships to return. Can be either `active` or
	`pending`. If not specified, the API returns both active and pending
	memberships.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListMembershipsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListMembershipsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-memberships-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/memberships/orgs"),
		URLQuery:           query,
		ValidStatuses:      []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListMembershipsForAuthenticatedUserReq) Rel(link string, resp *ListMembershipsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListMembershipsForAuthenticatedUserResponse is a response for ListMembershipsForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
type ListMembershipsForAuthenticatedUserResponse struct {
	requests.Response
	request *ListMembershipsForAuthenticatedUserReq
	Data    []components.OrgMembership
}

/*
ListOutsideCollaborators performs requests for "orgs/list-outside-collaborators"

List outside collaborators for an organization.

  GET /orgs/{org}/outside_collaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
func ListOutsideCollaborators(ctx context.Context, req *ListOutsideCollaboratorsReq, opt ...requests.Option) (*ListOutsideCollaboratorsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListOutsideCollaboratorsReq)
	}
	resp := &ListOutsideCollaboratorsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListOutsideCollaborators performs requests for "orgs/list-outside-collaborators"

List outside collaborators for an organization.

  GET /orgs/{org}/outside_collaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
func (c Client) ListOutsideCollaborators(ctx context.Context, req *ListOutsideCollaboratorsReq, opt ...requests.Option) (*ListOutsideCollaboratorsResponse, error) {
	return ListOutsideCollaborators(ctx, req, append(c, opt...)...)
}

/*
ListOutsideCollaboratorsReq is request data for Client.ListOutsideCollaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
type ListOutsideCollaboratorsReq struct {
	_url string
	Org  string

	/*
	Filter the list of outside collaborators. Can be one of:
	\* `2fa_disabled`: Outside collaborators without [two-factor
	authentication](https://github.com/blog/1614-two-factor-authentication) enabled.
	\* `all`: All outside collaborators.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListOutsideCollaboratorsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListOutsideCollaboratorsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-outside-collaborators",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/outside_collaborators", r.Org),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListOutsideCollaboratorsReq) Rel(link string, resp *ListOutsideCollaboratorsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListOutsideCollaboratorsResponse is a response for ListOutsideCollaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
type ListOutsideCollaboratorsResponse struct {
	requests.Response
	request *ListOutsideCollaboratorsReq
	Data    []components.SimpleUser
}

/*
ListPendingInvitations performs requests for "orgs/list-pending-invitations"

List pending organization invitations.

  GET /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
func ListPendingInvitations(ctx context.Context, req *ListPendingInvitationsReq, opt ...requests.Option) (*ListPendingInvitationsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPendingInvitationsReq)
	}
	resp := &ListPendingInvitationsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrganizationInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPendingInvitations performs requests for "orgs/list-pending-invitations"

List pending organization invitations.

  GET /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
func (c Client) ListPendingInvitations(ctx context.Context, req *ListPendingInvitationsReq, opt ...requests.Option) (*ListPendingInvitationsResponse, error) {
	return ListPendingInvitations(ctx, req, append(c, opt...)...)
}

/*
ListPendingInvitationsReq is request data for Client.ListPendingInvitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
type ListPendingInvitationsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPendingInvitationsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPendingInvitationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-pending-invitations",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/invitations", r.Org),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPendingInvitationsReq) Rel(link string, resp *ListPendingInvitationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPendingInvitationsResponse is a response for ListPendingInvitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
type ListPendingInvitationsResponse struct {
	requests.Response
	request *ListPendingInvitationsReq
	Data    []components.OrganizationInvitation
}

/*
ListPublicMembers performs requests for "orgs/list-public-members"

List public organization members.

  GET /orgs/{org}/public_members

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
func ListPublicMembers(ctx context.Context, req *ListPublicMembersReq, opt ...requests.Option) (*ListPublicMembersResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicMembersReq)
	}
	resp := &ListPublicMembersResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublicMembers performs requests for "orgs/list-public-members"

List public organization members.

  GET /orgs/{org}/public_members

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
func (c Client) ListPublicMembers(ctx context.Context, req *ListPublicMembersReq, opt ...requests.Option) (*ListPublicMembersResponse, error) {
	return ListPublicMembers(ctx, req, append(c, opt...)...)
}

/*
ListPublicMembersReq is request data for Client.ListPublicMembers

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
type ListPublicMembersReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicMembersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicMembersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-public-members",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/public_members", r.Org),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicMembersReq) Rel(link string, resp *ListPublicMembersResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicMembersResponse is a response for ListPublicMembers

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
type ListPublicMembersResponse struct {
	requests.Response
	request *ListPublicMembersReq
	Data    []components.SimpleUser
}

/*
ListSamlSsoAuthorizations performs requests for "orgs/list-saml-sso-authorizations"

List SAML SSO authorizations for an organization.

  GET /orgs/{org}/credential-authorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
func ListSamlSsoAuthorizations(ctx context.Context, req *ListSamlSsoAuthorizationsReq, opt ...requests.Option) (*ListSamlSsoAuthorizationsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListSamlSsoAuthorizationsReq)
	}
	resp := &ListSamlSsoAuthorizationsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CredentialAuthorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListSamlSsoAuthorizations performs requests for "orgs/list-saml-sso-authorizations"

List SAML SSO authorizations for an organization.

  GET /orgs/{org}/credential-authorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
func (c Client) ListSamlSsoAuthorizations(ctx context.Context, req *ListSamlSsoAuthorizationsReq, opt ...requests.Option) (*ListSamlSsoAuthorizationsResponse, error) {
	return ListSamlSsoAuthorizations(ctx, req, append(c, opt...)...)
}

/*
ListSamlSsoAuthorizationsReq is request data for Client.ListSamlSsoAuthorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
type ListSamlSsoAuthorizationsReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *ListSamlSsoAuthorizationsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListSamlSsoAuthorizationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-saml-sso-authorizations",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/credential-authorizations", r.Org),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListSamlSsoAuthorizationsReq) Rel(link string, resp *ListSamlSsoAuthorizationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListSamlSsoAuthorizationsResponse is a response for ListSamlSsoAuthorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
type ListSamlSsoAuthorizationsResponse struct {
	requests.Response
	request *ListSamlSsoAuthorizationsReq
	Data    []components.CredentialAuthorization
}

/*
ListWebhooks performs requests for "orgs/list-webhooks"

List organization webhooks.

  GET /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
func ListWebhooks(ctx context.Context, req *ListWebhooksReq, opt ...requests.Option) (*ListWebhooksResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListWebhooksReq)
	}
	resp := &ListWebhooksResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrgHook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListWebhooks performs requests for "orgs/list-webhooks"

List organization webhooks.

  GET /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
func (c Client) ListWebhooks(ctx context.Context, req *ListWebhooksReq, opt ...requests.Option) (*ListWebhooksResponse, error) {
	return ListWebhooks(ctx, req, append(c, opt...)...)
}

/*
ListWebhooksReq is request data for Client.ListWebhooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
type ListWebhooksReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListWebhooksReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListWebhooksReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-webhooks",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/hooks", r.Org),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListWebhooksReq) Rel(link string, resp *ListWebhooksResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListWebhooksResponse is a response for ListWebhooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
type ListWebhooksResponse struct {
	requests.Response
	request *ListWebhooksReq
	Data    []components.OrgHook
}

/*
PingWebhook performs requests for "orgs/ping-webhook"

Ping an organization webhook.

  POST /orgs/{org}/hooks/{hook_id}/pings

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
func PingWebhook(ctx context.Context, req *PingWebhookReq, opt ...requests.Option) (*PingWebhookResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PingWebhookReq)
	}
	resp := &PingWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PingWebhook performs requests for "orgs/ping-webhook"

Ping an organization webhook.

  POST /orgs/{org}/hooks/{hook_id}/pings

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
func (c Client) PingWebhook(ctx context.Context, req *PingWebhookReq, opt ...requests.Option) (*PingWebhookResponse, error) {
	return PingWebhook(ctx, req, append(c, opt...)...)
}

/*
PingWebhookReq is request data for Client.PingWebhook

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
type PingWebhookReq struct {
	_url   string
	Org    string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *PingWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PingWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "POST",
		OperationID:        "orgs/ping-webhook",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/hooks/%v/pings", r.Org, r.HookId),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PingWebhookReq) Rel(link string, resp *PingWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PingWebhookResponse is a response for PingWebhook

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
type PingWebhookResponse struct {
	requests.Response
	request *PingWebhookReq
	Data    bool
}

/*
RemoveMember performs requests for "orgs/remove-member"

Remove an organization member.

  DELETE /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
func RemoveMember(ctx context.Context, req *RemoveMemberReq, opt ...requests.Option) (*RemoveMemberResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveMemberReq)
	}
	resp := &RemoveMemberResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveMember performs requests for "orgs/remove-member"

Remove an organization member.

  DELETE /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
func (c Client) RemoveMember(ctx context.Context, req *RemoveMemberReq, opt ...requests.Option) (*RemoveMemberResponse, error) {
	return RemoveMember(ctx, req, append(c, opt...)...)
}

/*
RemoveMemberReq is request data for Client.RemoveMember

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
type RemoveMemberReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemoveMemberReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveMemberReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/remove-member",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/members/%v", r.Org, r.Username),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveMemberReq) Rel(link string, resp *RemoveMemberResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveMemberResponse is a response for RemoveMember

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
type RemoveMemberResponse struct {
	requests.Response
	request *RemoveMemberReq
}

/*
RemoveMembershipForUser performs requests for "orgs/remove-membership-for-user"

Remove organization membership for a user.

  DELETE /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
func RemoveMembershipForUser(ctx context.Context, req *RemoveMembershipForUserReq, opt ...requests.Option) (*RemoveMembershipForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveMembershipForUserReq)
	}
	resp := &RemoveMembershipForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveMembershipForUser performs requests for "orgs/remove-membership-for-user"

Remove organization membership for a user.

  DELETE /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
func (c Client) RemoveMembershipForUser(ctx context.Context, req *RemoveMembershipForUserReq, opt ...requests.Option) (*RemoveMembershipForUserResponse, error) {
	return RemoveMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
RemoveMembershipForUserReq is request data for Client.RemoveMembershipForUser

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
type RemoveMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemoveMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/remove-membership-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveMembershipForUserReq) Rel(link string, resp *RemoveMembershipForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveMembershipForUserResponse is a response for RemoveMembershipForUser

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
type RemoveMembershipForUserResponse struct {
	requests.Response
	request *RemoveMembershipForUserReq
}

/*
RemoveOutsideCollaborator performs requests for "orgs/remove-outside-collaborator"

Remove outside collaborator from an organization.

  DELETE /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
func RemoveOutsideCollaborator(ctx context.Context, req *RemoveOutsideCollaboratorReq, opt ...requests.Option) (*RemoveOutsideCollaboratorResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveOutsideCollaboratorReq)
	}
	resp := &RemoveOutsideCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveOutsideCollaborator performs requests for "orgs/remove-outside-collaborator"

Remove outside collaborator from an organization.

  DELETE /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
func (c Client) RemoveOutsideCollaborator(ctx context.Context, req *RemoveOutsideCollaboratorReq, opt ...requests.Option) (*RemoveOutsideCollaboratorResponse, error) {
	return RemoveOutsideCollaborator(ctx, req, append(c, opt...)...)
}

/*
RemoveOutsideCollaboratorReq is request data for Client.RemoveOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
type RemoveOutsideCollaboratorReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemoveOutsideCollaboratorReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveOutsideCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/remove-outside-collaborator",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/outside_collaborators/%v", r.Org, r.Username),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveOutsideCollaboratorReq) Rel(link string, resp *RemoveOutsideCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveOutsideCollaboratorResponse is a response for RemoveOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
type RemoveOutsideCollaboratorResponse struct {
	requests.Response
	request *RemoveOutsideCollaboratorReq
}

/*
RemovePublicMembershipForAuthenticatedUser performs requests for "orgs/remove-public-membership-for-authenticated-user"

Remove public organization membership for the authenticated user.

  DELETE /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
func RemovePublicMembershipForAuthenticatedUser(ctx context.Context, req *RemovePublicMembershipForAuthenticatedUserReq, opt ...requests.Option) (*RemovePublicMembershipForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemovePublicMembershipForAuthenticatedUserReq)
	}
	resp := &RemovePublicMembershipForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemovePublicMembershipForAuthenticatedUser performs requests for "orgs/remove-public-membership-for-authenticated-user"

Remove public organization membership for the authenticated user.

  DELETE /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
func (c Client) RemovePublicMembershipForAuthenticatedUser(ctx context.Context, req *RemovePublicMembershipForAuthenticatedUserReq, opt ...requests.Option) (*RemovePublicMembershipForAuthenticatedUserResponse, error) {
	return RemovePublicMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
RemovePublicMembershipForAuthenticatedUserReq is request data for Client.RemovePublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
type RemovePublicMembershipForAuthenticatedUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemovePublicMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemovePublicMembershipForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/remove-public-membership-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemovePublicMembershipForAuthenticatedUserReq) Rel(link string, resp *RemovePublicMembershipForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemovePublicMembershipForAuthenticatedUserResponse is a response for RemovePublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
type RemovePublicMembershipForAuthenticatedUserResponse struct {
	requests.Response
	request *RemovePublicMembershipForAuthenticatedUserReq
}

/*
RemoveSamlSsoAuthorization performs requests for "orgs/remove-saml-sso-authorization"

Remove a SAML SSO authorization for an organization.

  DELETE /orgs/{org}/credential-authorizations/{credential_id}

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
func RemoveSamlSsoAuthorization(ctx context.Context, req *RemoveSamlSsoAuthorizationReq, opt ...requests.Option) (*RemoveSamlSsoAuthorizationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveSamlSsoAuthorizationReq)
	}
	resp := &RemoveSamlSsoAuthorizationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveSamlSsoAuthorization performs requests for "orgs/remove-saml-sso-authorization"

Remove a SAML SSO authorization for an organization.

  DELETE /orgs/{org}/credential-authorizations/{credential_id}

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
func (c Client) RemoveSamlSsoAuthorization(ctx context.Context, req *RemoveSamlSsoAuthorizationReq, opt ...requests.Option) (*RemoveSamlSsoAuthorizationResponse, error) {
	return RemoveSamlSsoAuthorization(ctx, req, append(c, opt...)...)
}

/*
RemoveSamlSsoAuthorizationReq is request data for Client.RemoveSamlSsoAuthorization

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
type RemoveSamlSsoAuthorizationReq struct {
	_url string
	Org  string

	// credential_id parameter
	CredentialId int64
}

// HTTPRequest builds an *http.Request
func (r *RemoveSamlSsoAuthorizationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveSamlSsoAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/remove-saml-sso-authorization",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/credential-authorizations/%v", r.Org, r.CredentialId),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveSamlSsoAuthorizationReq) Rel(link string, resp *RemoveSamlSsoAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveSamlSsoAuthorizationResponse is a response for RemoveSamlSsoAuthorization

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
type RemoveSamlSsoAuthorizationResponse struct {
	requests.Response
	request *RemoveSamlSsoAuthorizationReq
	Data    bool
}

/*
SetMembershipForUser performs requests for "orgs/set-membership-for-user"

Set organization membership for a user.

  PUT /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
func SetMembershipForUser(ctx context.Context, req *SetMembershipForUserReq, opt ...requests.Option) (*SetMembershipForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetMembershipForUserReq)
	}
	resp := &SetMembershipForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetMembershipForUser performs requests for "orgs/set-membership-for-user"

Set organization membership for a user.

  PUT /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
func (c Client) SetMembershipForUser(ctx context.Context, req *SetMembershipForUserReq, opt ...requests.Option) (*SetMembershipForUserResponse, error) {
	return SetMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
SetMembershipForUserReq is request data for Client.SetMembershipForUser

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
type SetMembershipForUserReq struct {
	_url        string
	Org         string
	Username    string
	RequestBody SetMembershipForUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "orgs/set-membership-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetMembershipForUserReq) Rel(link string, resp *SetMembershipForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetMembershipForUserReqBody is a request body for orgs/set-membership-for-user

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
type SetMembershipForUserReqBody struct {

	/*
	The role to give the user in the organization. Can be one of:
	\* `admin` - The user will become an owner of the organization.
	\* `member` - The user will become a non-owner member of the organization.
	*/
	Role *string `json:"role,omitempty"`
}

/*
SetMembershipForUserResponse is a response for SetMembershipForUser

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
type SetMembershipForUserResponse struct {
	requests.Response
	request *SetMembershipForUserReq
	Data    components.OrgMembership
}

/*
SetPublicMembershipForAuthenticatedUser performs requests for "orgs/set-public-membership-for-authenticated-user"

Set public organization membership for the authenticated user.

  PUT /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
func SetPublicMembershipForAuthenticatedUser(ctx context.Context, req *SetPublicMembershipForAuthenticatedUserReq, opt ...requests.Option) (*SetPublicMembershipForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetPublicMembershipForAuthenticatedUserReq)
	}
	resp := &SetPublicMembershipForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetPublicMembershipForAuthenticatedUser performs requests for "orgs/set-public-membership-for-authenticated-user"

Set public organization membership for the authenticated user.

  PUT /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
func (c Client) SetPublicMembershipForAuthenticatedUser(ctx context.Context, req *SetPublicMembershipForAuthenticatedUserReq, opt ...requests.Option) (*SetPublicMembershipForAuthenticatedUserResponse, error) {
	return SetPublicMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
SetPublicMembershipForAuthenticatedUserReq is request data for Client.SetPublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
type SetPublicMembershipForAuthenticatedUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *SetPublicMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetPublicMembershipForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "orgs/set-public-membership-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetPublicMembershipForAuthenticatedUserReq) Rel(link string, resp *SetPublicMembershipForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetPublicMembershipForAuthenticatedUserResponse is a response for SetPublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
type SetPublicMembershipForAuthenticatedUserResponse struct {
	requests.Response
	request *SetPublicMembershipForAuthenticatedUserReq
}

/*
UnblockUser performs requests for "orgs/unblock-user"

Unblock a user from an organization.

  DELETE /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
func UnblockUser(ctx context.Context, req *UnblockUserReq, opt ...requests.Option) (*UnblockUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnblockUserReq)
	}
	resp := &UnblockUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UnblockUser performs requests for "orgs/unblock-user"

Unblock a user from an organization.

  DELETE /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
func (c Client) UnblockUser(ctx context.Context, req *UnblockUserReq, opt ...requests.Option) (*UnblockUserResponse, error) {
	return UnblockUser(ctx, req, append(c, opt...)...)
}

/*
UnblockUserReq is request data for Client.UnblockUser

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
type UnblockUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *UnblockUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnblockUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/unblock-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnblockUserReq) Rel(link string, resp *UnblockUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnblockUserResponse is a response for UnblockUser

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
type UnblockUserResponse struct {
	requests.Response
	request *UnblockUserReq
}

/*
Update performs requests for "orgs/update"

Update an organization.

  PATCH /orgs/{org}

https://developer.github.com/v3/orgs/#update-an-organization
*/
func Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateReq)
	}
	resp := &UpdateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrganizationFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Update performs requests for "orgs/update"

Update an organization.

  PATCH /orgs/{org}

https://developer.github.com/v3/orgs/#update-an-organization
*/
func (c Client) Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	return Update(ctx, req, append(c, opt...)...)
}

/*
UpdateReq is request data for Client.Update

https://developer.github.com/v3/orgs/#update-an-organization
*/
type UpdateReq struct {
	_url        string
	Org         string
	RequestBody UpdateReqBody

	/*
	New repository creation permissions are available to preview. You can now use
	`members_can_create_public_repositories`,
	`members_can_create_private_repositories`, and
	`members_can_create_internal_repositories`. You can only allow members to create
	internal repositories if your organization is associated with an enterprise
	account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. These
	parameters provide more granular permissions to configure the type of
	repositories organization members can create.

	To access these new parameters during the preview period, you must set this to
	true.
	*/
	SurturPreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"surtur"},
		Body:               r.RequestBody,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "orgs/update",
		Previews:         map[string]bool{"surtur": r.SurturPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReq) Rel(link string, resp *UpdateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateReqBody is a request body for orgs/update

https://developer.github.com/v3/orgs/#update-an-organization
*/
type UpdateReqBody struct {

	// Billing email address. This address is not publicized.
	BillingEmail *string `json:"billing_email,omitempty"`
	Blog         *string `json:"blog,omitempty"`

	// The company name.
	Company *string `json:"company,omitempty"`

	/*
	Default permission level members have for organization repositories:
	\* `read` - can pull, but not push to or administer this repository.
	\* `write` - can pull and push, but not administer this repository.
	\* `admin` - can pull, push, and administer this repository.
	\* `none` - no permissions granted by default.
	*/
	DefaultRepositoryPermission *string `json:"default_repository_permission,omitempty"`

	// The description of the company.
	Description *string `json:"description,omitempty"`

	// The publicly visible email address.
	Email *string `json:"email,omitempty"`

	// Toggles whether an organization can use organization projects.
	HasOrganizationProjects *bool `json:"has_organization_projects,omitempty"`

	// Toggles whether repositories that belong to the organization can use repository projects.
	HasRepositoryProjects *bool `json:"has_repository_projects,omitempty"`

	// The location.
	Location *string `json:"location,omitempty"`

	/*
	Specifies which types of repositories non-admin organization members can create.
	Can be one of:
	\* `all` - all organization members can create public and private repositories.
	\* `private` - members can create private repositories. This option is only
	available to repositories that are part of an organization on GitHub Enterprise
	Cloud.
	\* `none` - only admin members can create repositories.
	**Note:** This parameter is deprecated and will be removed in the future. Its
	return value ignores internal repositories. Using this parameter overrides
	values set in `members_can_create_repositories`. See [this
	note](https://developer.github.com/v3/orgs/#members_can_create_repositories) for
	details.
	*/
	MembersAllowedRepositoryCreationType *string `json:"members_allowed_repository_creation_type,omitempty"`

	/*
	Toggles whether organization members can create internal repositories, which are
	visible to all enterprise members. You can only allow members to create internal
	repositories if your organization is associated with an enterprise account using
	GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. Can be one of:
	\* `true` - all organization members can create internal repositories.
	\* `false` - only organization owners can create internal repositories.
	Default: `true`. For more information, see "[Restricting repository creation in
	your
	organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	in the GitHub Help documentation.
	*/
	MembersCanCreateInternalRepositories *bool `json:"members_can_create_internal_repositories,omitempty"`

	/*
	Toggles whether organization members can create private repositories, which are
	visible to organization members with permission. Can be one of:
	\* `true` - all organization members can create private repositories.
	\* `false` - only organization owners can create private repositories.
	Default: `true`. For more information, see "[Restricting repository creation in
	your
	organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	in the GitHub Help documentation.
	*/
	MembersCanCreatePrivateRepositories *bool `json:"members_can_create_private_repositories,omitempty"`

	/*
	Toggles whether organization members can create public repositories, which are
	visible to anyone. Can be one of:
	\* `true` - all organization members can create public repositories.
	\* `false` - only organization owners can create public repositories.
	Default: `true`. For more information, see "[Restricting repository creation in
	your
	organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	in the GitHub Help documentation.
	*/
	MembersCanCreatePublicRepositories *bool `json:"members_can_create_public_repositories,omitempty"`

	/*
	Toggles the ability of non-admin organization members to create repositories.
	Can be one of:
	\* `true` - all organization members can create repositories.
	\* `false` - only organization owners can create repositories.
	Default: `true`
	**Note:** A parameter can override this parameter. See
	`members_allowed_repository_creation_type` in this table for details. **Note:**
	A parameter can override this parameter. See
	`members_allowed_repository_creation_type` in this table for details.
	*/
	MembersCanCreateRepositories *bool `json:"members_can_create_repositories,omitempty"`

	// The shorthand name of the company.
	Name *string `json:"name,omitempty"`

	// The Twitter username of the company.
	TwitterUsername *string `json:"twitter_username,omitempty"`
}

/*
UpdateResponse is a response for Update

https://developer.github.com/v3/orgs/#update-an-organization
*/
type UpdateResponse struct {
	requests.Response
	request *UpdateReq
	Data    components.OrganizationFull
}

/*
UpdateMembershipForAuthenticatedUser performs requests for "orgs/update-membership-for-authenticated-user"

Update an organization membership for the authenticated user.

  PATCH /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
func UpdateMembershipForAuthenticatedUser(ctx context.Context, req *UpdateMembershipForAuthenticatedUserReq, opt ...requests.Option) (*UpdateMembershipForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateMembershipForAuthenticatedUserReq)
	}
	resp := &UpdateMembershipForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateMembershipForAuthenticatedUser performs requests for "orgs/update-membership-for-authenticated-user"

Update an organization membership for the authenticated user.

  PATCH /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
func (c Client) UpdateMembershipForAuthenticatedUser(ctx context.Context, req *UpdateMembershipForAuthenticatedUserReq, opt ...requests.Option) (*UpdateMembershipForAuthenticatedUserResponse, error) {
	return UpdateMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
UpdateMembershipForAuthenticatedUserReq is request data for Client.UpdateMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
type UpdateMembershipForAuthenticatedUserReq struct {
	_url        string
	Org         string
	RequestBody UpdateMembershipForAuthenticatedUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateMembershipForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "orgs/update-membership-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/memberships/orgs/%v", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateMembershipForAuthenticatedUserReq) Rel(link string, resp *UpdateMembershipForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateMembershipForAuthenticatedUserReqBody is a request body for orgs/update-membership-for-authenticated-user

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
type UpdateMembershipForAuthenticatedUserReqBody struct {

	// The state that the membership should be in. Only `"active"` will be accepted.
	State *string `json:"state"`
}

/*
UpdateMembershipForAuthenticatedUserResponse is a response for UpdateMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
type UpdateMembershipForAuthenticatedUserResponse struct {
	requests.Response
	request *UpdateMembershipForAuthenticatedUserReq
	Data    components.OrgMembership
}

/*
UpdateWebhook performs requests for "orgs/update-webhook"

Update an organization webhook.

  PATCH /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
func UpdateWebhook(ctx context.Context, req *UpdateWebhookReq, opt ...requests.Option) (*UpdateWebhookResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateWebhookReq)
	}
	resp := &UpdateWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgHook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateWebhook performs requests for "orgs/update-webhook"

Update an organization webhook.

  PATCH /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
func (c Client) UpdateWebhook(ctx context.Context, req *UpdateWebhookReq, opt ...requests.Option) (*UpdateWebhookResponse, error) {
	return UpdateWebhook(ctx, req, append(c, opt...)...)
}

/*
UpdateWebhookReq is request data for Client.UpdateWebhook

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
type UpdateWebhookReq struct {
	_url        string
	Org         string
	HookId      int64
	RequestBody UpdateWebhookReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "orgs/update-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateWebhookReq) Rel(link string, resp *UpdateWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// UpdateWebhookReqBodyConfig is a value for UpdateWebhookReqBody's Config field
type UpdateWebhookReqBodyConfig struct {

	// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
	ContentType *string `json:"content_type,omitempty"`

	/*
	Determines whether the SSL certificate of the host for `url` will be verified
	when delivering payloads. Supported values include `0` (verification is
	performed) and `1` (verification is not performed). The default is `0`. **We
	strongly recommend not setting this to `1` as you are subject to
	man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	If provided, the `secret` will be used as the `key` to generate the HMAC hex
	digest value in the
	[`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
UpdateWebhookReqBody is a request body for orgs/update-webhook

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
type UpdateWebhookReqBody struct {

	// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
	Active *bool `json:"active,omitempty"`

	/*
	Key/value pairs to provide settings for this webhook. [These are defined
	below](https://developer.github.com/v3/orgs/hooks/#update-hook-config-params).
	*/
	Config *UpdateWebhookReqBodyConfig `json:"config,omitempty"`

	// Determines what [events](https://developer.github.com/webhooks/event-payloads) the hook is triggered for.
	Events []string `json:"events,omitempty"`
	Name   *string  `json:"name,omitempty"`
}

/*
UpdateWebhookResponse is a response for UpdateWebhook

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
type UpdateWebhookResponse struct {
	requests.Response
	request *UpdateWebhookReq
	Data    components.OrgHook
}
