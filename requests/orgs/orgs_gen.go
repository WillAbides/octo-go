// Code generated by octo-go; DO NOT EDIT.

package orgs

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
BlockUser performs requests for "orgs/block-user"

Block a user from an organization.

  PUT /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
func BlockUser(ctx context.Context, req *BlockUserReq, opt ...requests.Option) (*BlockUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(BlockUserReq)
	}
	resp := &BlockUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewBlockUserResponse(r, opts.PreserveResponseBody())
}

// NewBlockUserResponse builds a new *BlockUserResponse from an *http.Response
func NewBlockUserResponse(resp *http.Response, preserveBody bool) (*BlockUserResponse, error) {
	var result BlockUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
BlockUser performs requests for "orgs/block-user"

Block a user from an organization.

  PUT /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
func (c Client) BlockUser(ctx context.Context, req *BlockUserReq, opt ...requests.Option) (*BlockUserResponse, error) {
	return BlockUser(ctx, req, append(c, opt...)...)
}

/*
BlockUserReq is request data for Client.BlockUser

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
type BlockUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *BlockUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *BlockUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "orgs/block-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BlockUserReq) Rel(link string, resp *BlockUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BlockUserResponse is a response for BlockUser

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
type BlockUserResponse struct {
	httpResponse *http.Response
}

func (r *BlockUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CheckBlockedUser performs requests for "orgs/check-blocked-user"

Check if a user is blocked by an organization.

  GET /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
func CheckBlockedUser(ctx context.Context, req *CheckBlockedUserReq, opt ...requests.Option) (*CheckBlockedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckBlockedUserReq)
	}
	resp := &CheckBlockedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckBlockedUserResponse(r, opts.PreserveResponseBody())
}

// NewCheckBlockedUserResponse builds a new *CheckBlockedUserResponse from an *http.Response
func NewCheckBlockedUserResponse(resp *http.Response, preserveBody bool) (*CheckBlockedUserResponse, error) {
	var result CheckBlockedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CheckBlockedUser performs requests for "orgs/check-blocked-user"

Check if a user is blocked by an organization.

  GET /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
func (c Client) CheckBlockedUser(ctx context.Context, req *CheckBlockedUserReq, opt ...requests.Option) (*CheckBlockedUserResponse, error) {
	return CheckBlockedUser(ctx, req, append(c, opt...)...)
}

/*
CheckBlockedUserReq is request data for Client.CheckBlockedUser

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
type CheckBlockedUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *CheckBlockedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckBlockedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "orgs/check-blocked-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckBlockedUserReq) Rel(link string, resp *CheckBlockedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckBlockedUserResponse is a response for CheckBlockedUser

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
type CheckBlockedUserResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *CheckBlockedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CheckMembershipForUser performs requests for "orgs/check-membership-for-user"

Check organization membership for a user.

  GET /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
func CheckMembershipForUser(ctx context.Context, req *CheckMembershipForUserReq, opt ...requests.Option) (*CheckMembershipForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckMembershipForUserReq)
	}
	resp := &CheckMembershipForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckMembershipForUserResponse(r, opts.PreserveResponseBody())
}

// NewCheckMembershipForUserResponse builds a new *CheckMembershipForUserResponse from an *http.Response
func NewCheckMembershipForUserResponse(resp *http.Response, preserveBody bool) (*CheckMembershipForUserResponse, error) {
	var result CheckMembershipForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 302})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CheckMembershipForUser performs requests for "orgs/check-membership-for-user"

Check organization membership for a user.

  GET /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
func (c Client) CheckMembershipForUser(ctx context.Context, req *CheckMembershipForUserReq, opt ...requests.Option) (*CheckMembershipForUserResponse, error) {
	return CheckMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
CheckMembershipForUserReq is request data for Client.CheckMembershipForUser

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
type CheckMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *CheckMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "orgs/check-membership-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/members/%v", r.Org, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckMembershipForUserReq) Rel(link string, resp *CheckMembershipForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckMembershipForUserResponse is a response for CheckMembershipForUser

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
type CheckMembershipForUserResponse struct {
	httpResponse *http.Response
}

func (r *CheckMembershipForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CheckPublicMembershipForUser performs requests for "orgs/check-public-membership-for-user"

Check public organization membership for a user.

  GET /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
func CheckPublicMembershipForUser(ctx context.Context, req *CheckPublicMembershipForUserReq, opt ...requests.Option) (*CheckPublicMembershipForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckPublicMembershipForUserReq)
	}
	resp := &CheckPublicMembershipForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckPublicMembershipForUserResponse(r, opts.PreserveResponseBody())
}

// NewCheckPublicMembershipForUserResponse builds a new *CheckPublicMembershipForUserResponse from an *http.Response
func NewCheckPublicMembershipForUserResponse(resp *http.Response, preserveBody bool) (*CheckPublicMembershipForUserResponse, error) {
	var result CheckPublicMembershipForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CheckPublicMembershipForUser performs requests for "orgs/check-public-membership-for-user"

Check public organization membership for a user.

  GET /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
func (c Client) CheckPublicMembershipForUser(ctx context.Context, req *CheckPublicMembershipForUserReq, opt ...requests.Option) (*CheckPublicMembershipForUserResponse, error) {
	return CheckPublicMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
CheckPublicMembershipForUserReq is request data for Client.CheckPublicMembershipForUser

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
type CheckPublicMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *CheckPublicMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckPublicMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "orgs/check-public-membership-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckPublicMembershipForUserReq) Rel(link string, resp *CheckPublicMembershipForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckPublicMembershipForUserResponse is a response for CheckPublicMembershipForUser

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
type CheckPublicMembershipForUserResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *CheckPublicMembershipForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ConvertMemberToOutsideCollaborator performs requests for "orgs/convert-member-to-outside-collaborator"

Convert an organization member to outside collaborator.

  PUT /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
func ConvertMemberToOutsideCollaborator(ctx context.Context, req *ConvertMemberToOutsideCollaboratorReq, opt ...requests.Option) (*ConvertMemberToOutsideCollaboratorResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ConvertMemberToOutsideCollaboratorReq)
	}
	resp := &ConvertMemberToOutsideCollaboratorResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewConvertMemberToOutsideCollaboratorResponse(r, opts.PreserveResponseBody())
}

// NewConvertMemberToOutsideCollaboratorResponse builds a new *ConvertMemberToOutsideCollaboratorResponse from an *http.Response
func NewConvertMemberToOutsideCollaboratorResponse(resp *http.Response, preserveBody bool) (*ConvertMemberToOutsideCollaboratorResponse, error) {
	var result ConvertMemberToOutsideCollaboratorResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{202, 204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
ConvertMemberToOutsideCollaborator performs requests for "orgs/convert-member-to-outside-collaborator"

Convert an organization member to outside collaborator.

  PUT /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
func (c Client) ConvertMemberToOutsideCollaborator(ctx context.Context, req *ConvertMemberToOutsideCollaboratorReq, opt ...requests.Option) (*ConvertMemberToOutsideCollaboratorResponse, error) {
	return ConvertMemberToOutsideCollaborator(ctx, req, append(c, opt...)...)
}

/*
ConvertMemberToOutsideCollaboratorReq is request data for Client.ConvertMemberToOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
type ConvertMemberToOutsideCollaboratorReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *ConvertMemberToOutsideCollaboratorReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ConvertMemberToOutsideCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "orgs/convert-member-to-outside-collaborator",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/outside_collaborators/%v", r.Org, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ConvertMemberToOutsideCollaboratorReq) Rel(link string, resp *ConvertMemberToOutsideCollaboratorResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ConvertMemberToOutsideCollaboratorResponse is a response for ConvertMemberToOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
type ConvertMemberToOutsideCollaboratorResponse struct {
	httpResponse *http.Response
}

func (r *ConvertMemberToOutsideCollaboratorResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateInvitation performs requests for "orgs/create-invitation"

Create an organization invitation.

  POST /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
func CreateInvitation(ctx context.Context, req *CreateInvitationReq, opt ...requests.Option) (*CreateInvitationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateInvitationReq)
	}
	resp := &CreateInvitationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateInvitationResponse(r, opts.PreserveResponseBody())
}

// NewCreateInvitationResponse builds a new *CreateInvitationResponse from an *http.Response
func NewCreateInvitationResponse(resp *http.Response, preserveBody bool) (*CreateInvitationResponse, error) {
	var result CreateInvitationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateInvitation performs requests for "orgs/create-invitation"

Create an organization invitation.

  POST /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
func (c Client) CreateInvitation(ctx context.Context, req *CreateInvitationReq, opt ...requests.Option) (*CreateInvitationResponse, error) {
	return CreateInvitation(ctx, req, append(c, opt...)...)
}

/*
CreateInvitationReq is request data for Client.CreateInvitation

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
type CreateInvitationReq struct {
	_url        string
	Org         string
	RequestBody CreateInvitationReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateInvitationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateInvitationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "orgs/create-invitation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/invitations", r.Org),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateInvitationReq) Rel(link string, resp *CreateInvitationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateInvitationReqBody is a request body for orgs/create-invitation

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
type CreateInvitationReqBody struct {

	/*
	**Required unless you provide `invitee_id`**. Email address of the person you
	are inviting, which can be an existing GitHub user.
	*/
	Email *string `json:"email,omitempty"`

	// **Required unless you provide `email`**. GitHub user ID for the person you are inviting.
	InviteeId *int64 `json:"invitee_id,omitempty"`

	/*
	Specify role for new member. Can be one of:
	\* `admin` - Organization owners with full administrative rights to the
	organization and complete access to all repositories and teams.
	\* `direct_member` - Non-owner organization members with ability to see other
	members and join teams by invitation.
	\* `billing_manager` - Non-owner organization members with ability to manage the
	billing settings of your organization.
	*/
	Role *string `json:"role,omitempty"`

	// Specify IDs for the teams you want to invite new members to.
	TeamIds []int64 `json:"team_ids,omitempty"`
}

/*
CreateInvitationResponse is a response for CreateInvitation

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
type CreateInvitationResponse struct {
	httpResponse *http.Response
	Data         components.OrganizationInvitation
}

func (r *CreateInvitationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateWebhook performs requests for "orgs/create-webhook"

Create an organization webhook.

  POST /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
func CreateWebhook(ctx context.Context, req *CreateWebhookReq, opt ...requests.Option) (*CreateWebhookResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateWebhookReq)
	}
	resp := &CreateWebhookResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateWebhookResponse(r, opts.PreserveResponseBody())
}

// NewCreateWebhookResponse builds a new *CreateWebhookResponse from an *http.Response
func NewCreateWebhookResponse(resp *http.Response, preserveBody bool) (*CreateWebhookResponse, error) {
	var result CreateWebhookResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateWebhook performs requests for "orgs/create-webhook"

Create an organization webhook.

  POST /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
func (c Client) CreateWebhook(ctx context.Context, req *CreateWebhookReq, opt ...requests.Option) (*CreateWebhookResponse, error) {
	return CreateWebhook(ctx, req, append(c, opt...)...)
}

/*
CreateWebhookReq is request data for Client.CreateWebhook

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
type CreateWebhookReq struct {
	_url        string
	Org         string
	RequestBody CreateWebhookReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "orgs/create-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/hooks", r.Org),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateWebhookReq) Rel(link string, resp *CreateWebhookResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateWebhookReqBodyConfig is a value for CreateWebhookReqBody's Config field
type CreateWebhookReqBodyConfig struct {

	// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
	ContentType *string `json:"content_type,omitempty"`

	/*
	Determines whether the SSL certificate of the host for `url` will be verified
	when delivering payloads. Supported values include `0` (verification is
	performed) and `1` (verification is not performed). The default is `0`. **We
	strongly recommend not setting this to `1` as you are subject to
	man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`
	Password    *string `json:"password,omitempty"`

	/*
	If provided, the `secret` will be used as the `key` to generate the HMAC hex
	digest value in the
	[`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url      *string `json:"url"`
	Username *string `json:"username,omitempty"`
}

/*
CreateWebhookReqBody is a request body for orgs/create-webhook

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
type CreateWebhookReqBody struct {

	// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
	Active *bool `json:"active,omitempty"`

	/*
	Key/value pairs to provide settings for this webhook. [These are defined
	below](https://developer.github.com/v3/orgs/hooks/#create-hook-config-params).
	*/
	Config *CreateWebhookReqBodyConfig `json:"config"`

	// Determines what [events](https://developer.github.com/webhooks/event-payloads) the hook is triggered for.
	Events []string `json:"events,omitempty"`

	// Must be passed as "web".
	Name *string `json:"name"`
}

/*
CreateWebhookResponse is a response for CreateWebhook

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
type CreateWebhookResponse struct {
	httpResponse *http.Response
	Data         components.OrgHook
}

func (r *CreateWebhookResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteWebhook performs requests for "orgs/delete-webhook"

Delete an organization webhook.

  DELETE /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
func DeleteWebhook(ctx context.Context, req *DeleteWebhookReq, opt ...requests.Option) (*DeleteWebhookResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteWebhookReq)
	}
	resp := &DeleteWebhookResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteWebhookResponse(r, opts.PreserveResponseBody())
}

// NewDeleteWebhookResponse builds a new *DeleteWebhookResponse from an *http.Response
func NewDeleteWebhookResponse(resp *http.Response, preserveBody bool) (*DeleteWebhookResponse, error) {
	var result DeleteWebhookResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteWebhook performs requests for "orgs/delete-webhook"

Delete an organization webhook.

  DELETE /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
func (c Client) DeleteWebhook(ctx context.Context, req *DeleteWebhookReq, opt ...requests.Option) (*DeleteWebhookResponse, error) {
	return DeleteWebhook(ctx, req, append(c, opt...)...)
}

/*
DeleteWebhookReq is request data for Client.DeleteWebhook

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
type DeleteWebhookReq struct {
	_url   string
	Org    string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/delete-webhook",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteWebhookReq) Rel(link string, resp *DeleteWebhookResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteWebhookResponse is a response for DeleteWebhook

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
type DeleteWebhookResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *DeleteWebhookResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Get performs requests for "orgs/get"

Get an organization.

  GET /orgs/{org}

https://developer.github.com/v3/orgs/#get-an-organization
*/
func Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetReq)
	}
	resp := &GetResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetResponse(r, opts.PreserveResponseBody())
}

// NewGetResponse builds a new *GetResponse from an *http.Response
func NewGetResponse(resp *http.Response, preserveBody bool) (*GetResponse, error) {
	var result GetResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
Get performs requests for "orgs/get"

Get an organization.

  GET /orgs/{org}

https://developer.github.com/v3/orgs/#get-an-organization
*/
func (c Client) Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	return Get(ctx, req, append(c, opt...)...)
}

/*
GetReq is request data for Client.Get

https://developer.github.com/v3/orgs/#get-an-organization
*/
type GetReq struct {
	_url string
	Org  string

	/*
	New repository creation permissions are available to preview. You can now use
	`members_can_create_public_repositories`,
	`members_can_create_private_repositories`, and
	`members_can_create_internal_repositories`. You can only allow members to create
	internal repositories if your organization is associated with an enterprise
	account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. These
	parameters provide more granular permissions to configure the type of
	repositories organization members can create.

	To access these new parameters during the preview period, you must set this to
	true.
	*/
	SurturPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"surtur"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/get",
		Previews:           map[string]bool{"surtur": r.SurturPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReq) Rel(link string, resp *GetResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetResponse is a response for Get

https://developer.github.com/v3/orgs/#get-an-organization
*/
type GetResponse struct {
	httpResponse *http.Response
	Data         components.OrganizationFull
}

func (r *GetResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetMembershipForAuthenticatedUser performs requests for "orgs/get-membership-for-authenticated-user"

Get an organization membership for the authenticated user.

  GET /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
func GetMembershipForAuthenticatedUser(ctx context.Context, req *GetMembershipForAuthenticatedUserReq, opt ...requests.Option) (*GetMembershipForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetMembershipForAuthenticatedUserReq)
	}
	resp := &GetMembershipForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetMembershipForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewGetMembershipForAuthenticatedUserResponse builds a new *GetMembershipForAuthenticatedUserResponse from an *http.Response
func NewGetMembershipForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*GetMembershipForAuthenticatedUserResponse, error) {
	var result GetMembershipForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetMembershipForAuthenticatedUser performs requests for "orgs/get-membership-for-authenticated-user"

Get an organization membership for the authenticated user.

  GET /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
func (c Client) GetMembershipForAuthenticatedUser(ctx context.Context, req *GetMembershipForAuthenticatedUserReq, opt ...requests.Option) (*GetMembershipForAuthenticatedUserResponse, error) {
	return GetMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
GetMembershipForAuthenticatedUserReq is request data for Client.GetMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
type GetMembershipForAuthenticatedUserReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *GetMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetMembershipForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/get-membership-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/memberships/orgs/%v", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetMembershipForAuthenticatedUserReq) Rel(link string, resp *GetMembershipForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetMembershipForAuthenticatedUserResponse is a response for GetMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
type GetMembershipForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         components.OrgMembership
}

func (r *GetMembershipForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetMembershipForUser performs requests for "orgs/get-membership-for-user"

Get organization membership for a user.

  GET /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
func GetMembershipForUser(ctx context.Context, req *GetMembershipForUserReq, opt ...requests.Option) (*GetMembershipForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetMembershipForUserReq)
	}
	resp := &GetMembershipForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetMembershipForUserResponse(r, opts.PreserveResponseBody())
}

// NewGetMembershipForUserResponse builds a new *GetMembershipForUserResponse from an *http.Response
func NewGetMembershipForUserResponse(resp *http.Response, preserveBody bool) (*GetMembershipForUserResponse, error) {
	var result GetMembershipForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetMembershipForUser performs requests for "orgs/get-membership-for-user"

Get organization membership for a user.

  GET /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
func (c Client) GetMembershipForUser(ctx context.Context, req *GetMembershipForUserReq, opt ...requests.Option) (*GetMembershipForUserResponse, error) {
	return GetMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
GetMembershipForUserReq is request data for Client.GetMembershipForUser

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
type GetMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/get-membership-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetMembershipForUserReq) Rel(link string, resp *GetMembershipForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetMembershipForUserResponse is a response for GetMembershipForUser

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
type GetMembershipForUserResponse struct {
	httpResponse *http.Response
	Data         components.OrgMembership
}

func (r *GetMembershipForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetWebhook performs requests for "orgs/get-webhook"

Get an organization webhook.

  GET /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
func GetWebhook(ctx context.Context, req *GetWebhookReq, opt ...requests.Option) (*GetWebhookResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetWebhookReq)
	}
	resp := &GetWebhookResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetWebhookResponse(r, opts.PreserveResponseBody())
}

// NewGetWebhookResponse builds a new *GetWebhookResponse from an *http.Response
func NewGetWebhookResponse(resp *http.Response, preserveBody bool) (*GetWebhookResponse, error) {
	var result GetWebhookResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetWebhook performs requests for "orgs/get-webhook"

Get an organization webhook.

  GET /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
func (c Client) GetWebhook(ctx context.Context, req *GetWebhookReq, opt ...requests.Option) (*GetWebhookResponse, error) {
	return GetWebhook(ctx, req, append(c, opt...)...)
}

/*
GetWebhookReq is request data for Client.GetWebhook

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
type GetWebhookReq struct {
	_url   string
	Org    string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *GetWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/get-webhook",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetWebhookReq) Rel(link string, resp *GetWebhookResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetWebhookResponse is a response for GetWebhook

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
type GetWebhookResponse struct {
	httpResponse *http.Response
	Data         components.OrgHook
}

func (r *GetWebhookResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
List performs requests for "orgs/list"

List organizations.

  GET /organizations

https://developer.github.com/v3/orgs/#list-organizations
*/
func List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReq)
	}
	resp := &ListResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListResponse(r, opts.PreserveResponseBody())
}

// NewListResponse builds a new *ListResponse from an *http.Response
func NewListResponse(resp *http.Response, preserveBody bool) (*ListResponse, error) {
	var result ListResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
List performs requests for "orgs/list"

List organizations.

  GET /organizations

https://developer.github.com/v3/orgs/#list-organizations
*/
func (c Client) List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	return List(ctx, req, append(c, opt...)...)
}

/*
ListReq is request data for Client.List

https://developer.github.com/v3/orgs/#list-organizations
*/
type ListReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/organizations"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReq) Rel(link string, resp *ListResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListResponse is a response for List

https://developer.github.com/v3/orgs/#list-organizations
*/
type ListResponse struct {
	httpResponse *http.Response
	Data         []components.OrganizationSimple
}

func (r *ListResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListAppInstallations performs requests for "orgs/list-app-installations"

List app installations for an organization.

  GET /orgs/{org}/installations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
func ListAppInstallations(ctx context.Context, req *ListAppInstallationsReq, opt ...requests.Option) (*ListAppInstallationsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListAppInstallationsReq)
	}
	resp := &ListAppInstallationsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListAppInstallationsResponse(r, opts.PreserveResponseBody())
}

// NewListAppInstallationsResponse builds a new *ListAppInstallationsResponse from an *http.Response
func NewListAppInstallationsResponse(resp *http.Response, preserveBody bool) (*ListAppInstallationsResponse, error) {
	var result ListAppInstallationsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListAppInstallations performs requests for "orgs/list-app-installations"

List app installations for an organization.

  GET /orgs/{org}/installations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
func (c Client) ListAppInstallations(ctx context.Context, req *ListAppInstallationsReq, opt ...requests.Option) (*ListAppInstallationsResponse, error) {
	return ListAppInstallations(ctx, req, append(c, opt...)...)
}

/*
ListAppInstallationsReq is request data for Client.ListAppInstallations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
type ListAppInstallationsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListAppInstallationsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListAppInstallationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-app-installations",
		Previews:           map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews:   []string{"machine-man"},
		URLPath:            fmt.Sprintf("/orgs/%v/installations", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListAppInstallationsReq) Rel(link string, resp *ListAppInstallationsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListAppInstallationsResponseBody is a response body for ListAppInstallations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
type ListAppInstallationsResponseBody struct {
	Installations []components.Installation `json:"installations,omitempty"`
	TotalCount    int64                     `json:"total_count,omitempty"`
}

/*
ListAppInstallationsResponse is a response for ListAppInstallations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
type ListAppInstallationsResponse struct {
	httpResponse *http.Response
	Data         ListAppInstallationsResponseBody
}

func (r *ListAppInstallationsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListBlockedUsers performs requests for "orgs/list-blocked-users"

List users blocked by an organization.

  GET /orgs/{org}/blocks

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
func ListBlockedUsers(ctx context.Context, req *ListBlockedUsersReq, opt ...requests.Option) (*ListBlockedUsersResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListBlockedUsersReq)
	}
	resp := &ListBlockedUsersResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListBlockedUsersResponse(r, opts.PreserveResponseBody())
}

// NewListBlockedUsersResponse builds a new *ListBlockedUsersResponse from an *http.Response
func NewListBlockedUsersResponse(resp *http.Response, preserveBody bool) (*ListBlockedUsersResponse, error) {
	var result ListBlockedUsersResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListBlockedUsers performs requests for "orgs/list-blocked-users"

List users blocked by an organization.

  GET /orgs/{org}/blocks

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
func (c Client) ListBlockedUsers(ctx context.Context, req *ListBlockedUsersReq, opt ...requests.Option) (*ListBlockedUsersResponse, error) {
	return ListBlockedUsers(ctx, req, append(c, opt...)...)
}

/*
ListBlockedUsersReq is request data for Client.ListBlockedUsers

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
type ListBlockedUsersReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *ListBlockedUsersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListBlockedUsersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-blocked-users",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/blocks", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListBlockedUsersReq) Rel(link string, resp *ListBlockedUsersResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListBlockedUsersResponse is a response for ListBlockedUsers

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
type ListBlockedUsersResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListBlockedUsersResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListForAuthenticatedUser performs requests for "orgs/list-for-authenticated-user"

List organizations for the authenticated user.

  GET /user/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
func ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForAuthenticatedUserReq)
	}
	resp := &ListForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListForAuthenticatedUserResponse builds a new *ListForAuthenticatedUserResponse from an *http.Response
func NewListForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListForAuthenticatedUserResponse, error) {
	var result ListForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListForAuthenticatedUser performs requests for "orgs/list-for-authenticated-user"

List organizations for the authenticated user.

  GET /user/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
func (c Client) ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	return ListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListForAuthenticatedUserReq is request data for Client.ListForAuthenticatedUser

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
type ListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/orgs"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForAuthenticatedUserReq) Rel(link string, resp *ListForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForAuthenticatedUserResponse is a response for ListForAuthenticatedUser

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
type ListForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.OrganizationSimple
}

func (r *ListForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListForUser performs requests for "orgs/list-for-user"

List organizations for a user.

  GET /users/{username}/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
func ListForUser(ctx context.Context, req *ListForUserReq, opt ...requests.Option) (*ListForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForUserReq)
	}
	resp := &ListForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListForUserResponse(r, opts.PreserveResponseBody())
}

// NewListForUserResponse builds a new *ListForUserResponse from an *http.Response
func NewListForUserResponse(resp *http.Response, preserveBody bool) (*ListForUserResponse, error) {
	var result ListForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListForUser performs requests for "orgs/list-for-user"

List organizations for a user.

  GET /users/{username}/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
func (c Client) ListForUser(ctx context.Context, req *ListForUserReq, opt ...requests.Option) (*ListForUserResponse, error) {
	return ListForUser(ctx, req, append(c, opt...)...)
}

/*
ListForUserReq is request data for Client.ListForUser

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
type ListForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/orgs", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForUserReq) Rel(link string, resp *ListForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForUserResponse is a response for ListForUser

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
type ListForUserResponse struct {
	httpResponse *http.Response
	Data         []components.OrganizationSimple
}

func (r *ListForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListInvitationTeams performs requests for "orgs/list-invitation-teams"

List organization invitation teams.

  GET /orgs/{org}/invitations/{invitation_id}/teams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
func ListInvitationTeams(ctx context.Context, req *ListInvitationTeamsReq, opt ...requests.Option) (*ListInvitationTeamsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListInvitationTeamsReq)
	}
	resp := &ListInvitationTeamsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListInvitationTeamsResponse(r, opts.PreserveResponseBody())
}

// NewListInvitationTeamsResponse builds a new *ListInvitationTeamsResponse from an *http.Response
func NewListInvitationTeamsResponse(resp *http.Response, preserveBody bool) (*ListInvitationTeamsResponse, error) {
	var result ListInvitationTeamsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListInvitationTeams performs requests for "orgs/list-invitation-teams"

List organization invitation teams.

  GET /orgs/{org}/invitations/{invitation_id}/teams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
func (c Client) ListInvitationTeams(ctx context.Context, req *ListInvitationTeamsReq, opt ...requests.Option) (*ListInvitationTeamsResponse, error) {
	return ListInvitationTeams(ctx, req, append(c, opt...)...)
}

/*
ListInvitationTeamsReq is request data for Client.ListInvitationTeams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
type ListInvitationTeamsReq struct {
	_url string
	Org  string

	// invitation_id parameter
	InvitationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListInvitationTeamsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListInvitationTeamsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-invitation-teams",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/invitations/%v/teams", r.Org, r.InvitationId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInvitationTeamsReq) Rel(link string, resp *ListInvitationTeamsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInvitationTeamsResponse is a response for ListInvitationTeams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
type ListInvitationTeamsResponse struct {
	httpResponse *http.Response
	Data         []components.Team
}

func (r *ListInvitationTeamsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListMembers performs requests for "orgs/list-members"

List organization members.

  GET /orgs/{org}/members

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
func ListMembers(ctx context.Context, req *ListMembersReq, opt ...requests.Option) (*ListMembersResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListMembersReq)
	}
	resp := &ListMembersResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListMembersResponse(r, opts.PreserveResponseBody())
}

// NewListMembersResponse builds a new *ListMembersResponse from an *http.Response
func NewListMembersResponse(resp *http.Response, preserveBody bool) (*ListMembersResponse, error) {
	var result ListMembersResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 302})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListMembers performs requests for "orgs/list-members"

List organization members.

  GET /orgs/{org}/members

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
func (c Client) ListMembers(ctx context.Context, req *ListMembersReq, opt ...requests.Option) (*ListMembersResponse, error) {
	return ListMembers(ctx, req, append(c, opt...)...)
}

/*
ListMembersReq is request data for Client.ListMembers

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
type ListMembersReq struct {
	_url string
	Org  string

	/*
	Filter members returned in the list. Can be one of:
	\* `2fa_disabled` - Members without [two-factor
	authentication](https://github.com/blog/1614-two-factor-authentication) enabled.
	Available for organization owners.
	\* `all` - All members the authenticated user can see.
	*/
	Filter *string

	/*
	Filter members returned by their role. Can be one of:
	\* `all` - All members of the organization, regardless of role.
	\* `admin` - Organization owners.
	\* `member` - Non-owner organization members.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListMembersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListMembersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-members",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/members", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListMembersReq) Rel(link string, resp *ListMembersResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListMembersResponse is a response for ListMembers

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
type ListMembersResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListMembersResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListMembershipsForAuthenticatedUser performs requests for "orgs/list-memberships-for-authenticated-user"

List organization memberships for the authenticated user.

  GET /user/memberships/orgs

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
func ListMembershipsForAuthenticatedUser(ctx context.Context, req *ListMembershipsForAuthenticatedUserReq, opt ...requests.Option) (*ListMembershipsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListMembershipsForAuthenticatedUserReq)
	}
	resp := &ListMembershipsForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListMembershipsForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListMembershipsForAuthenticatedUserResponse builds a new *ListMembershipsForAuthenticatedUserResponse from an *http.Response
func NewListMembershipsForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListMembershipsForAuthenticatedUserResponse, error) {
	var result ListMembershipsForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListMembershipsForAuthenticatedUser performs requests for "orgs/list-memberships-for-authenticated-user"

List organization memberships for the authenticated user.

  GET /user/memberships/orgs

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
func (c Client) ListMembershipsForAuthenticatedUser(ctx context.Context, req *ListMembershipsForAuthenticatedUserReq, opt ...requests.Option) (*ListMembershipsForAuthenticatedUserResponse, error) {
	return ListMembershipsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListMembershipsForAuthenticatedUserReq is request data for Client.ListMembershipsForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
type ListMembershipsForAuthenticatedUserReq struct {
	_url string

	/*
	Indicates the state of the memberships to return. Can be either `active` or
	`pending`. If not specified, the API returns both active and pending
	memberships.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListMembershipsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListMembershipsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-memberships-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/memberships/orgs"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListMembershipsForAuthenticatedUserReq) Rel(link string, resp *ListMembershipsForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListMembershipsForAuthenticatedUserResponse is a response for ListMembershipsForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
type ListMembershipsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.OrgMembership
}

func (r *ListMembershipsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListOutsideCollaborators performs requests for "orgs/list-outside-collaborators"

List outside collaborators for an organization.

  GET /orgs/{org}/outside_collaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
func ListOutsideCollaborators(ctx context.Context, req *ListOutsideCollaboratorsReq, opt ...requests.Option) (*ListOutsideCollaboratorsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListOutsideCollaboratorsReq)
	}
	resp := &ListOutsideCollaboratorsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListOutsideCollaboratorsResponse(r, opts.PreserveResponseBody())
}

// NewListOutsideCollaboratorsResponse builds a new *ListOutsideCollaboratorsResponse from an *http.Response
func NewListOutsideCollaboratorsResponse(resp *http.Response, preserveBody bool) (*ListOutsideCollaboratorsResponse, error) {
	var result ListOutsideCollaboratorsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListOutsideCollaborators performs requests for "orgs/list-outside-collaborators"

List outside collaborators for an organization.

  GET /orgs/{org}/outside_collaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
func (c Client) ListOutsideCollaborators(ctx context.Context, req *ListOutsideCollaboratorsReq, opt ...requests.Option) (*ListOutsideCollaboratorsResponse, error) {
	return ListOutsideCollaborators(ctx, req, append(c, opt...)...)
}

/*
ListOutsideCollaboratorsReq is request data for Client.ListOutsideCollaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
type ListOutsideCollaboratorsReq struct {
	_url string
	Org  string

	/*
	Filter the list of outside collaborators. Can be one of:
	\* `2fa_disabled`: Outside collaborators without [two-factor
	authentication](https://github.com/blog/1614-two-factor-authentication) enabled.
	\* `all`: All outside collaborators.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListOutsideCollaboratorsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListOutsideCollaboratorsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-outside-collaborators",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/outside_collaborators", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListOutsideCollaboratorsReq) Rel(link string, resp *ListOutsideCollaboratorsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListOutsideCollaboratorsResponse is a response for ListOutsideCollaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
type ListOutsideCollaboratorsResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListOutsideCollaboratorsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPendingInvitations performs requests for "orgs/list-pending-invitations"

List pending organization invitations.

  GET /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
func ListPendingInvitations(ctx context.Context, req *ListPendingInvitationsReq, opt ...requests.Option) (*ListPendingInvitationsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPendingInvitationsReq)
	}
	resp := &ListPendingInvitationsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPendingInvitationsResponse(r, opts.PreserveResponseBody())
}

// NewListPendingInvitationsResponse builds a new *ListPendingInvitationsResponse from an *http.Response
func NewListPendingInvitationsResponse(resp *http.Response, preserveBody bool) (*ListPendingInvitationsResponse, error) {
	var result ListPendingInvitationsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPendingInvitations performs requests for "orgs/list-pending-invitations"

List pending organization invitations.

  GET /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
func (c Client) ListPendingInvitations(ctx context.Context, req *ListPendingInvitationsReq, opt ...requests.Option) (*ListPendingInvitationsResponse, error) {
	return ListPendingInvitations(ctx, req, append(c, opt...)...)
}

/*
ListPendingInvitationsReq is request data for Client.ListPendingInvitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
type ListPendingInvitationsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPendingInvitationsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPendingInvitationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-pending-invitations",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/invitations", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPendingInvitationsReq) Rel(link string, resp *ListPendingInvitationsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPendingInvitationsResponse is a response for ListPendingInvitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
type ListPendingInvitationsResponse struct {
	httpResponse *http.Response
	Data         []components.OrganizationInvitation
}

func (r *ListPendingInvitationsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPublicMembers performs requests for "orgs/list-public-members"

List public organization members.

  GET /orgs/{org}/public_members

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
func ListPublicMembers(ctx context.Context, req *ListPublicMembersReq, opt ...requests.Option) (*ListPublicMembersResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicMembersReq)
	}
	resp := &ListPublicMembersResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPublicMembersResponse(r, opts.PreserveResponseBody())
}

// NewListPublicMembersResponse builds a new *ListPublicMembersResponse from an *http.Response
func NewListPublicMembersResponse(resp *http.Response, preserveBody bool) (*ListPublicMembersResponse, error) {
	var result ListPublicMembersResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPublicMembers performs requests for "orgs/list-public-members"

List public organization members.

  GET /orgs/{org}/public_members

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
func (c Client) ListPublicMembers(ctx context.Context, req *ListPublicMembersReq, opt ...requests.Option) (*ListPublicMembersResponse, error) {
	return ListPublicMembers(ctx, req, append(c, opt...)...)
}

/*
ListPublicMembersReq is request data for Client.ListPublicMembers

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
type ListPublicMembersReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicMembersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicMembersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-public-members",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/public_members", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicMembersReq) Rel(link string, resp *ListPublicMembersResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicMembersResponse is a response for ListPublicMembers

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
type ListPublicMembersResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListPublicMembersResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListSamlSsoAuthorizations performs requests for "orgs/list-saml-sso-authorizations"

List SAML SSO authorizations for an organization.

  GET /orgs/{org}/credential-authorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
func ListSamlSsoAuthorizations(ctx context.Context, req *ListSamlSsoAuthorizationsReq, opt ...requests.Option) (*ListSamlSsoAuthorizationsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListSamlSsoAuthorizationsReq)
	}
	resp := &ListSamlSsoAuthorizationsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListSamlSsoAuthorizationsResponse(r, opts.PreserveResponseBody())
}

// NewListSamlSsoAuthorizationsResponse builds a new *ListSamlSsoAuthorizationsResponse from an *http.Response
func NewListSamlSsoAuthorizationsResponse(resp *http.Response, preserveBody bool) (*ListSamlSsoAuthorizationsResponse, error) {
	var result ListSamlSsoAuthorizationsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListSamlSsoAuthorizations performs requests for "orgs/list-saml-sso-authorizations"

List SAML SSO authorizations for an organization.

  GET /orgs/{org}/credential-authorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
func (c Client) ListSamlSsoAuthorizations(ctx context.Context, req *ListSamlSsoAuthorizationsReq, opt ...requests.Option) (*ListSamlSsoAuthorizationsResponse, error) {
	return ListSamlSsoAuthorizations(ctx, req, append(c, opt...)...)
}

/*
ListSamlSsoAuthorizationsReq is request data for Client.ListSamlSsoAuthorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
type ListSamlSsoAuthorizationsReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *ListSamlSsoAuthorizationsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListSamlSsoAuthorizationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-saml-sso-authorizations",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/credential-authorizations", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListSamlSsoAuthorizationsReq) Rel(link string, resp *ListSamlSsoAuthorizationsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListSamlSsoAuthorizationsResponse is a response for ListSamlSsoAuthorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
type ListSamlSsoAuthorizationsResponse struct {
	httpResponse *http.Response
	Data         []components.CredentialAuthorization
}

func (r *ListSamlSsoAuthorizationsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListWebhooks performs requests for "orgs/list-webhooks"

List organization webhooks.

  GET /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
func ListWebhooks(ctx context.Context, req *ListWebhooksReq, opt ...requests.Option) (*ListWebhooksResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListWebhooksReq)
	}
	resp := &ListWebhooksResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListWebhooksResponse(r, opts.PreserveResponseBody())
}

// NewListWebhooksResponse builds a new *ListWebhooksResponse from an *http.Response
func NewListWebhooksResponse(resp *http.Response, preserveBody bool) (*ListWebhooksResponse, error) {
	var result ListWebhooksResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListWebhooks performs requests for "orgs/list-webhooks"

List organization webhooks.

  GET /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
func (c Client) ListWebhooks(ctx context.Context, req *ListWebhooksReq, opt ...requests.Option) (*ListWebhooksResponse, error) {
	return ListWebhooks(ctx, req, append(c, opt...)...)
}

/*
ListWebhooksReq is request data for Client.ListWebhooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
type ListWebhooksReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListWebhooksReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListWebhooksReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "orgs/list-webhooks",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/hooks", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListWebhooksReq) Rel(link string, resp *ListWebhooksResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListWebhooksResponse is a response for ListWebhooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
type ListWebhooksResponse struct {
	httpResponse *http.Response
	Data         []components.OrgHook
}

func (r *ListWebhooksResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
PingWebhook performs requests for "orgs/ping-webhook"

Ping an organization webhook.

  POST /orgs/{org}/hooks/{hook_id}/pings

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
func PingWebhook(ctx context.Context, req *PingWebhookReq, opt ...requests.Option) (*PingWebhookResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PingWebhookReq)
	}
	resp := &PingWebhookResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewPingWebhookResponse(r, opts.PreserveResponseBody())
}

// NewPingWebhookResponse builds a new *PingWebhookResponse from an *http.Response
func NewPingWebhookResponse(resp *http.Response, preserveBody bool) (*PingWebhookResponse, error) {
	var result PingWebhookResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
PingWebhook performs requests for "orgs/ping-webhook"

Ping an organization webhook.

  POST /orgs/{org}/hooks/{hook_id}/pings

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
func (c Client) PingWebhook(ctx context.Context, req *PingWebhookReq, opt ...requests.Option) (*PingWebhookResponse, error) {
	return PingWebhook(ctx, req, append(c, opt...)...)
}

/*
PingWebhookReq is request data for Client.PingWebhook

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
type PingWebhookReq struct {
	_url   string
	Org    string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *PingWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PingWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "POST",
		OperationID:        "orgs/ping-webhook",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/hooks/%v/pings", r.Org, r.HookId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PingWebhookReq) Rel(link string, resp *PingWebhookResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PingWebhookResponse is a response for PingWebhook

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
type PingWebhookResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *PingWebhookResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveMember performs requests for "orgs/remove-member"

Remove an organization member.

  DELETE /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
func RemoveMember(ctx context.Context, req *RemoveMemberReq, opt ...requests.Option) (*RemoveMemberResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveMemberReq)
	}
	resp := &RemoveMemberResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveMemberResponse(r, opts.PreserveResponseBody())
}

// NewRemoveMemberResponse builds a new *RemoveMemberResponse from an *http.Response
func NewRemoveMemberResponse(resp *http.Response, preserveBody bool) (*RemoveMemberResponse, error) {
	var result RemoveMemberResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveMember performs requests for "orgs/remove-member"

Remove an organization member.

  DELETE /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
func (c Client) RemoveMember(ctx context.Context, req *RemoveMemberReq, opt ...requests.Option) (*RemoveMemberResponse, error) {
	return RemoveMember(ctx, req, append(c, opt...)...)
}

/*
RemoveMemberReq is request data for Client.RemoveMember

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
type RemoveMemberReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemoveMemberReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveMemberReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/remove-member",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/members/%v", r.Org, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveMemberReq) Rel(link string, resp *RemoveMemberResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveMemberResponse is a response for RemoveMember

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
type RemoveMemberResponse struct {
	httpResponse *http.Response
}

func (r *RemoveMemberResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveMembershipForUser performs requests for "orgs/remove-membership-for-user"

Remove organization membership for a user.

  DELETE /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
func RemoveMembershipForUser(ctx context.Context, req *RemoveMembershipForUserReq, opt ...requests.Option) (*RemoveMembershipForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveMembershipForUserReq)
	}
	resp := &RemoveMembershipForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveMembershipForUserResponse(r, opts.PreserveResponseBody())
}

// NewRemoveMembershipForUserResponse builds a new *RemoveMembershipForUserResponse from an *http.Response
func NewRemoveMembershipForUserResponse(resp *http.Response, preserveBody bool) (*RemoveMembershipForUserResponse, error) {
	var result RemoveMembershipForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveMembershipForUser performs requests for "orgs/remove-membership-for-user"

Remove organization membership for a user.

  DELETE /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
func (c Client) RemoveMembershipForUser(ctx context.Context, req *RemoveMembershipForUserReq, opt ...requests.Option) (*RemoveMembershipForUserResponse, error) {
	return RemoveMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
RemoveMembershipForUserReq is request data for Client.RemoveMembershipForUser

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
type RemoveMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemoveMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/remove-membership-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveMembershipForUserReq) Rel(link string, resp *RemoveMembershipForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveMembershipForUserResponse is a response for RemoveMembershipForUser

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
type RemoveMembershipForUserResponse struct {
	httpResponse *http.Response
}

func (r *RemoveMembershipForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveOutsideCollaborator performs requests for "orgs/remove-outside-collaborator"

Remove outside collaborator from an organization.

  DELETE /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
func RemoveOutsideCollaborator(ctx context.Context, req *RemoveOutsideCollaboratorReq, opt ...requests.Option) (*RemoveOutsideCollaboratorResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveOutsideCollaboratorReq)
	}
	resp := &RemoveOutsideCollaboratorResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveOutsideCollaboratorResponse(r, opts.PreserveResponseBody())
}

// NewRemoveOutsideCollaboratorResponse builds a new *RemoveOutsideCollaboratorResponse from an *http.Response
func NewRemoveOutsideCollaboratorResponse(resp *http.Response, preserveBody bool) (*RemoveOutsideCollaboratorResponse, error) {
	var result RemoveOutsideCollaboratorResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveOutsideCollaborator performs requests for "orgs/remove-outside-collaborator"

Remove outside collaborator from an organization.

  DELETE /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
func (c Client) RemoveOutsideCollaborator(ctx context.Context, req *RemoveOutsideCollaboratorReq, opt ...requests.Option) (*RemoveOutsideCollaboratorResponse, error) {
	return RemoveOutsideCollaborator(ctx, req, append(c, opt...)...)
}

/*
RemoveOutsideCollaboratorReq is request data for Client.RemoveOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
type RemoveOutsideCollaboratorReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemoveOutsideCollaboratorReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveOutsideCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/remove-outside-collaborator",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/outside_collaborators/%v", r.Org, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveOutsideCollaboratorReq) Rel(link string, resp *RemoveOutsideCollaboratorResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveOutsideCollaboratorResponse is a response for RemoveOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
type RemoveOutsideCollaboratorResponse struct {
	httpResponse *http.Response
}

func (r *RemoveOutsideCollaboratorResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemovePublicMembershipForAuthenticatedUser performs requests for "orgs/remove-public-membership-for-authenticated-user"

Remove public organization membership for the authenticated user.

  DELETE /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
func RemovePublicMembershipForAuthenticatedUser(ctx context.Context, req *RemovePublicMembershipForAuthenticatedUserReq, opt ...requests.Option) (*RemovePublicMembershipForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemovePublicMembershipForAuthenticatedUserReq)
	}
	resp := &RemovePublicMembershipForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemovePublicMembershipForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewRemovePublicMembershipForAuthenticatedUserResponse builds a new *RemovePublicMembershipForAuthenticatedUserResponse from an *http.Response
func NewRemovePublicMembershipForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*RemovePublicMembershipForAuthenticatedUserResponse, error) {
	var result RemovePublicMembershipForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemovePublicMembershipForAuthenticatedUser performs requests for "orgs/remove-public-membership-for-authenticated-user"

Remove public organization membership for the authenticated user.

  DELETE /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
func (c Client) RemovePublicMembershipForAuthenticatedUser(ctx context.Context, req *RemovePublicMembershipForAuthenticatedUserReq, opt ...requests.Option) (*RemovePublicMembershipForAuthenticatedUserResponse, error) {
	return RemovePublicMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
RemovePublicMembershipForAuthenticatedUserReq is request data for Client.RemovePublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
type RemovePublicMembershipForAuthenticatedUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemovePublicMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemovePublicMembershipForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/remove-public-membership-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemovePublicMembershipForAuthenticatedUserReq) Rel(link string, resp *RemovePublicMembershipForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemovePublicMembershipForAuthenticatedUserResponse is a response for RemovePublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
type RemovePublicMembershipForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

func (r *RemovePublicMembershipForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveSamlSsoAuthorization performs requests for "orgs/remove-saml-sso-authorization"

Remove a SAML SSO authorization for an organization.

  DELETE /orgs/{org}/credential-authorizations/{credential_id}

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
func RemoveSamlSsoAuthorization(ctx context.Context, req *RemoveSamlSsoAuthorizationReq, opt ...requests.Option) (*RemoveSamlSsoAuthorizationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveSamlSsoAuthorizationReq)
	}
	resp := &RemoveSamlSsoAuthorizationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveSamlSsoAuthorizationResponse(r, opts.PreserveResponseBody())
}

// NewRemoveSamlSsoAuthorizationResponse builds a new *RemoveSamlSsoAuthorizationResponse from an *http.Response
func NewRemoveSamlSsoAuthorizationResponse(resp *http.Response, preserveBody bool) (*RemoveSamlSsoAuthorizationResponse, error) {
	var result RemoveSamlSsoAuthorizationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveSamlSsoAuthorization performs requests for "orgs/remove-saml-sso-authorization"

Remove a SAML SSO authorization for an organization.

  DELETE /orgs/{org}/credential-authorizations/{credential_id}

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
func (c Client) RemoveSamlSsoAuthorization(ctx context.Context, req *RemoveSamlSsoAuthorizationReq, opt ...requests.Option) (*RemoveSamlSsoAuthorizationResponse, error) {
	return RemoveSamlSsoAuthorization(ctx, req, append(c, opt...)...)
}

/*
RemoveSamlSsoAuthorizationReq is request data for Client.RemoveSamlSsoAuthorization

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
type RemoveSamlSsoAuthorizationReq struct {
	_url string
	Org  string

	// credential_id parameter
	CredentialId int64
}

// HTTPRequest builds an *http.Request
func (r *RemoveSamlSsoAuthorizationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveSamlSsoAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/remove-saml-sso-authorization",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/credential-authorizations/%v", r.Org, r.CredentialId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveSamlSsoAuthorizationReq) Rel(link string, resp *RemoveSamlSsoAuthorizationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveSamlSsoAuthorizationResponse is a response for RemoveSamlSsoAuthorization

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
type RemoveSamlSsoAuthorizationResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *RemoveSamlSsoAuthorizationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
SetMembershipForUser performs requests for "orgs/set-membership-for-user"

Set organization membership for a user.

  PUT /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
func SetMembershipForUser(ctx context.Context, req *SetMembershipForUserReq, opt ...requests.Option) (*SetMembershipForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetMembershipForUserReq)
	}
	resp := &SetMembershipForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewSetMembershipForUserResponse(r, opts.PreserveResponseBody())
}

// NewSetMembershipForUserResponse builds a new *SetMembershipForUserResponse from an *http.Response
func NewSetMembershipForUserResponse(resp *http.Response, preserveBody bool) (*SetMembershipForUserResponse, error) {
	var result SetMembershipForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
SetMembershipForUser performs requests for "orgs/set-membership-for-user"

Set organization membership for a user.

  PUT /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
func (c Client) SetMembershipForUser(ctx context.Context, req *SetMembershipForUserReq, opt ...requests.Option) (*SetMembershipForUserResponse, error) {
	return SetMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
SetMembershipForUserReq is request data for Client.SetMembershipForUser

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
type SetMembershipForUserReq struct {
	_url        string
	Org         string
	Username    string
	RequestBody SetMembershipForUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "orgs/set-membership-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetMembershipForUserReq) Rel(link string, resp *SetMembershipForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetMembershipForUserReqBody is a request body for orgs/set-membership-for-user

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
type SetMembershipForUserReqBody struct {

	/*
	The role to give the user in the organization. Can be one of:
	\* `admin` - The user will become an owner of the organization.
	\* `member` - The user will become a non-owner member of the organization.
	*/
	Role *string `json:"role,omitempty"`
}

/*
SetMembershipForUserResponse is a response for SetMembershipForUser

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
type SetMembershipForUserResponse struct {
	httpResponse *http.Response
	Data         components.OrgMembership
}

func (r *SetMembershipForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
SetPublicMembershipForAuthenticatedUser performs requests for "orgs/set-public-membership-for-authenticated-user"

Set public organization membership for the authenticated user.

  PUT /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
func SetPublicMembershipForAuthenticatedUser(ctx context.Context, req *SetPublicMembershipForAuthenticatedUserReq, opt ...requests.Option) (*SetPublicMembershipForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetPublicMembershipForAuthenticatedUserReq)
	}
	resp := &SetPublicMembershipForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewSetPublicMembershipForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewSetPublicMembershipForAuthenticatedUserResponse builds a new *SetPublicMembershipForAuthenticatedUserResponse from an *http.Response
func NewSetPublicMembershipForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*SetPublicMembershipForAuthenticatedUserResponse, error) {
	var result SetPublicMembershipForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
SetPublicMembershipForAuthenticatedUser performs requests for "orgs/set-public-membership-for-authenticated-user"

Set public organization membership for the authenticated user.

  PUT /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
func (c Client) SetPublicMembershipForAuthenticatedUser(ctx context.Context, req *SetPublicMembershipForAuthenticatedUserReq, opt ...requests.Option) (*SetPublicMembershipForAuthenticatedUserResponse, error) {
	return SetPublicMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
SetPublicMembershipForAuthenticatedUserReq is request data for Client.SetPublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
type SetPublicMembershipForAuthenticatedUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *SetPublicMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetPublicMembershipForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "orgs/set-public-membership-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetPublicMembershipForAuthenticatedUserReq) Rel(link string, resp *SetPublicMembershipForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetPublicMembershipForAuthenticatedUserResponse is a response for SetPublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
type SetPublicMembershipForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

func (r *SetPublicMembershipForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UnblockUser performs requests for "orgs/unblock-user"

Unblock a user from an organization.

  DELETE /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
func UnblockUser(ctx context.Context, req *UnblockUserReq, opt ...requests.Option) (*UnblockUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnblockUserReq)
	}
	resp := &UnblockUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUnblockUserResponse(r, opts.PreserveResponseBody())
}

// NewUnblockUserResponse builds a new *UnblockUserResponse from an *http.Response
func NewUnblockUserResponse(resp *http.Response, preserveBody bool) (*UnblockUserResponse, error) {
	var result UnblockUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
UnblockUser performs requests for "orgs/unblock-user"

Unblock a user from an organization.

  DELETE /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
func (c Client) UnblockUser(ctx context.Context, req *UnblockUserReq, opt ...requests.Option) (*UnblockUserResponse, error) {
	return UnblockUser(ctx, req, append(c, opt...)...)
}

/*
UnblockUserReq is request data for Client.UnblockUser

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
type UnblockUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *UnblockUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnblockUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "orgs/unblock-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnblockUserReq) Rel(link string, resp *UnblockUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnblockUserResponse is a response for UnblockUser

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
type UnblockUserResponse struct {
	httpResponse *http.Response
}

func (r *UnblockUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Update performs requests for "orgs/update"

Update an organization.

  PATCH /orgs/{org}

https://developer.github.com/v3/orgs/#update-an-organization
*/
func Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateReq)
	}
	resp := &UpdateResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateResponse(r, opts.PreserveResponseBody())
}

// NewUpdateResponse builds a new *UpdateResponse from an *http.Response
func NewUpdateResponse(resp *http.Response, preserveBody bool) (*UpdateResponse, error) {
	var result UpdateResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
Update performs requests for "orgs/update"

Update an organization.

  PATCH /orgs/{org}

https://developer.github.com/v3/orgs/#update-an-organization
*/
func (c Client) Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	return Update(ctx, req, append(c, opt...)...)
}

/*
UpdateReq is request data for Client.Update

https://developer.github.com/v3/orgs/#update-an-organization
*/
type UpdateReq struct {
	_url        string
	Org         string
	RequestBody UpdateReqBody

	/*
	New repository creation permissions are available to preview. You can now use
	`members_can_create_public_repositories`,
	`members_can_create_private_repositories`, and
	`members_can_create_internal_repositories`. You can only allow members to create
	internal repositories if your organization is associated with an enterprise
	account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. These
	parameters provide more granular permissions to configure the type of
	repositories organization members can create.

	To access these new parameters during the preview period, you must set this to
	true.
	*/
	SurturPreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"surtur"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "orgs/update",
		Previews:         map[string]bool{"surtur": r.SurturPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v", r.Org),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReq) Rel(link string, resp *UpdateResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateReqBody is a request body for orgs/update

https://developer.github.com/v3/orgs/#update-an-organization
*/
type UpdateReqBody struct {

	// Billing email address. This address is not publicized.
	BillingEmail *string `json:"billing_email,omitempty"`
	Blog         *string `json:"blog,omitempty"`

	// The company name.
	Company *string `json:"company,omitempty"`

	/*
	Default permission level members have for organization repositories:
	\* `read` - can pull, but not push to or administer this repository.
	\* `write` - can pull and push, but not administer this repository.
	\* `admin` - can pull, push, and administer this repository.
	\* `none` - no permissions granted by default.
	*/
	DefaultRepositoryPermission *string `json:"default_repository_permission,omitempty"`

	// The description of the company.
	Description *string `json:"description,omitempty"`

	// The publicly visible email address.
	Email *string `json:"email,omitempty"`

	// Toggles whether an organization can use organization projects.
	HasOrganizationProjects *bool `json:"has_organization_projects,omitempty"`

	// Toggles whether repositories that belong to the organization can use repository projects.
	HasRepositoryProjects *bool `json:"has_repository_projects,omitempty"`

	// The location.
	Location *string `json:"location,omitempty"`

	/*
	Specifies which types of repositories non-admin organization members can create.
	Can be one of:
	\* `all` - all organization members can create public and private repositories.
	\* `private` - members can create private repositories. This option is only
	available to repositories that are part of an organization on GitHub Enterprise
	Cloud.
	\* `none` - only admin members can create repositories.
	**Note:** This parameter is deprecated and will be removed in the future. Its
	return value ignores internal repositories. Using this parameter overrides
	values set in `members_can_create_repositories`. See [this
	note](https://developer.github.com/v3/orgs/#members_can_create_repositories) for
	details.
	*/
	MembersAllowedRepositoryCreationType *string `json:"members_allowed_repository_creation_type,omitempty"`

	/*
	Toggles whether organization members can create internal repositories, which are
	visible to all enterprise members. You can only allow members to create internal
	repositories if your organization is associated with an enterprise account using
	GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. Can be one of:
	\* `true` - all organization members can create internal repositories.
	\* `false` - only organization owners can create internal repositories.
	Default: `true`. For more information, see "[Restricting repository creation in
	your
	organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	in the GitHub Help documentation.
	*/
	MembersCanCreateInternalRepositories *bool `json:"members_can_create_internal_repositories,omitempty"`

	/*
	Toggles whether organization members can create private repositories, which are
	visible to organization members with permission. Can be one of:
	\* `true` - all organization members can create private repositories.
	\* `false` - only organization owners can create private repositories.
	Default: `true`. For more information, see "[Restricting repository creation in
	your
	organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	in the GitHub Help documentation.
	*/
	MembersCanCreatePrivateRepositories *bool `json:"members_can_create_private_repositories,omitempty"`

	/*
	Toggles whether organization members can create public repositories, which are
	visible to anyone. Can be one of:
	\* `true` - all organization members can create public repositories.
	\* `false` - only organization owners can create public repositories.
	Default: `true`. For more information, see "[Restricting repository creation in
	your
	organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	in the GitHub Help documentation.
	*/
	MembersCanCreatePublicRepositories *bool `json:"members_can_create_public_repositories,omitempty"`

	/*
	Toggles the ability of non-admin organization members to create repositories.
	Can be one of:
	\* `true` - all organization members can create repositories.
	\* `false` - only organization owners can create repositories.
	Default: `true`
	**Note:** A parameter can override this parameter. See
	`members_allowed_repository_creation_type` in this table for details. **Note:**
	A parameter can override this parameter. See
	`members_allowed_repository_creation_type` in this table for details.
	*/
	MembersCanCreateRepositories *bool `json:"members_can_create_repositories,omitempty"`

	// The shorthand name of the company.
	Name *string `json:"name,omitempty"`

	// The Twitter username of the company.
	TwitterUsername *string `json:"twitter_username,omitempty"`
}

/*
UpdateResponse is a response for Update

https://developer.github.com/v3/orgs/#update-an-organization
*/
type UpdateResponse struct {
	httpResponse *http.Response
	Data         components.OrganizationFull
}

func (r *UpdateResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateMembershipForAuthenticatedUser performs requests for "orgs/update-membership-for-authenticated-user"

Update an organization membership for the authenticated user.

  PATCH /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
func UpdateMembershipForAuthenticatedUser(ctx context.Context, req *UpdateMembershipForAuthenticatedUserReq, opt ...requests.Option) (*UpdateMembershipForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateMembershipForAuthenticatedUserReq)
	}
	resp := &UpdateMembershipForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateMembershipForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewUpdateMembershipForAuthenticatedUserResponse builds a new *UpdateMembershipForAuthenticatedUserResponse from an *http.Response
func NewUpdateMembershipForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*UpdateMembershipForAuthenticatedUserResponse, error) {
	var result UpdateMembershipForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateMembershipForAuthenticatedUser performs requests for "orgs/update-membership-for-authenticated-user"

Update an organization membership for the authenticated user.

  PATCH /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
func (c Client) UpdateMembershipForAuthenticatedUser(ctx context.Context, req *UpdateMembershipForAuthenticatedUserReq, opt ...requests.Option) (*UpdateMembershipForAuthenticatedUserResponse, error) {
	return UpdateMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
UpdateMembershipForAuthenticatedUserReq is request data for Client.UpdateMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
type UpdateMembershipForAuthenticatedUserReq struct {
	_url        string
	Org         string
	RequestBody UpdateMembershipForAuthenticatedUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateMembershipForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "orgs/update-membership-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/memberships/orgs/%v", r.Org),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateMembershipForAuthenticatedUserReq) Rel(link string, resp *UpdateMembershipForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateMembershipForAuthenticatedUserReqBody is a request body for orgs/update-membership-for-authenticated-user

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
type UpdateMembershipForAuthenticatedUserReqBody struct {

	// The state that the membership should be in. Only `"active"` will be accepted.
	State *string `json:"state"`
}

/*
UpdateMembershipForAuthenticatedUserResponse is a response for UpdateMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
type UpdateMembershipForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         components.OrgMembership
}

func (r *UpdateMembershipForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateWebhook performs requests for "orgs/update-webhook"

Update an organization webhook.

  PATCH /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
func UpdateWebhook(ctx context.Context, req *UpdateWebhookReq, opt ...requests.Option) (*UpdateWebhookResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateWebhookReq)
	}
	resp := &UpdateWebhookResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateWebhookResponse(r, opts.PreserveResponseBody())
}

// NewUpdateWebhookResponse builds a new *UpdateWebhookResponse from an *http.Response
func NewUpdateWebhookResponse(resp *http.Response, preserveBody bool) (*UpdateWebhookResponse, error) {
	var result UpdateWebhookResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateWebhook performs requests for "orgs/update-webhook"

Update an organization webhook.

  PATCH /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
func (c Client) UpdateWebhook(ctx context.Context, req *UpdateWebhookReq, opt ...requests.Option) (*UpdateWebhookResponse, error) {
	return UpdateWebhook(ctx, req, append(c, opt...)...)
}

/*
UpdateWebhookReq is request data for Client.UpdateWebhook

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
type UpdateWebhookReq struct {
	_url        string
	Org         string
	HookId      int64
	RequestBody UpdateWebhookReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "orgs/update-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateWebhookReq) Rel(link string, resp *UpdateWebhookResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// UpdateWebhookReqBodyConfig is a value for UpdateWebhookReqBody's Config field
type UpdateWebhookReqBodyConfig struct {

	// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
	ContentType *string `json:"content_type,omitempty"`

	/*
	Determines whether the SSL certificate of the host for `url` will be verified
	when delivering payloads. Supported values include `0` (verification is
	performed) and `1` (verification is not performed). The default is `0`. **We
	strongly recommend not setting this to `1` as you are subject to
	man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	If provided, the `secret` will be used as the `key` to generate the HMAC hex
	digest value in the
	[`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
UpdateWebhookReqBody is a request body for orgs/update-webhook

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
type UpdateWebhookReqBody struct {

	// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
	Active *bool `json:"active,omitempty"`

	/*
	Key/value pairs to provide settings for this webhook. [These are defined
	below](https://developer.github.com/v3/orgs/hooks/#update-hook-config-params).
	*/
	Config *UpdateWebhookReqBodyConfig `json:"config,omitempty"`

	// Determines what [events](https://developer.github.com/webhooks/event-payloads) the hook is triggered for.
	Events []string `json:"events,omitempty"`
	Name   *string  `json:"name,omitempty"`
}

/*
UpdateWebhookResponse is a response for UpdateWebhook

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
type UpdateWebhookResponse struct {
	httpResponse *http.Response
	Data         components.OrgHook
}

func (r *UpdateWebhookResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}
