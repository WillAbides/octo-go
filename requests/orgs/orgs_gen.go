// Code generated by octo-go; DO NOT EDIT.

package orgs

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
BlockUser performs requests for "orgs/block-user"

Block a user from an organization.

  PUT /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
func BlockUser(ctx context.Context, req *BlockUserReq, opt ...requests.Option) (*BlockUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(BlockUserReq)
	}
	resp := &BlockUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
BlockUser performs requests for "orgs/block-user"

Block a user from an organization.

  PUT /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) BlockUser(ctx context.Context, req *BlockUserReq, opt ...requests.Option) (*BlockUserResponse, error) {
	return BlockUser(ctx, req, append(c, opt...)...)
}

/*
BlockUserReq is request data for Client.BlockUser

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type BlockUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *BlockUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "PUT",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BlockUserReq) Rel(link string, resp *BlockUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BlockUserResponse is a response for BlockUser

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
type BlockUserResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *BlockUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *BlockUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
CheckBlockedUser performs requests for "orgs/check-blocked-user"

Check if a user is blocked by an organization.

  GET /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
func CheckBlockedUser(ctx context.Context, req *CheckBlockedUserReq, opt ...requests.Option) (*CheckBlockedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CheckBlockedUserReq)
	}
	resp := &CheckBlockedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckBlockedUser performs requests for "orgs/check-blocked-user"

Check if a user is blocked by an organization.

  GET /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CheckBlockedUser(ctx context.Context, req *CheckBlockedUserReq, opt ...requests.Option) (*CheckBlockedUserResponse, error) {
	return CheckBlockedUser(ctx, req, append(c, opt...)...)
}

/*
CheckBlockedUserReq is request data for Client.CheckBlockedUser

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CheckBlockedUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CheckBlockedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckBlockedUserReq) Rel(link string, resp *CheckBlockedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckBlockedUserResponse is a response for CheckBlockedUser

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
type CheckBlockedUserResponse struct {
	httpResponse *http.Response
	Data         bool
}

// HTTPResponse returns the *http.Response
func (r *CheckBlockedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CheckBlockedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 404})
	if err != nil {
		return err
	}
	err = internal.SetBoolResult(resp, &r.Data)
	if err != nil {
		return err
	}
	return nil
}

/*
CheckMembershipForUser performs requests for "orgs/check-membership-for-user"

Check organization membership for a user.

  GET /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
func CheckMembershipForUser(ctx context.Context, req *CheckMembershipForUserReq, opt ...requests.Option) (*CheckMembershipForUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CheckMembershipForUserReq)
	}
	resp := &CheckMembershipForUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckMembershipForUser performs requests for "orgs/check-membership-for-user"

Check organization membership for a user.

  GET /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CheckMembershipForUser(ctx context.Context, req *CheckMembershipForUserReq, opt ...requests.Option) (*CheckMembershipForUserResponse, error) {
	return CheckMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
CheckMembershipForUserReq is request data for Client.CheckMembershipForUser

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CheckMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CheckMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/members/%v", r.Org, r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckMembershipForUserReq) Rel(link string, resp *CheckMembershipForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckMembershipForUserResponse is a response for CheckMembershipForUser

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
type CheckMembershipForUserResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *CheckMembershipForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CheckMembershipForUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 302})
	if err != nil {
		return err
	}
	return nil
}

/*
CheckPublicMembershipForUser performs requests for "orgs/check-public-membership-for-user"

Check public organization membership for a user.

  GET /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
func CheckPublicMembershipForUser(ctx context.Context, req *CheckPublicMembershipForUserReq, opt ...requests.Option) (*CheckPublicMembershipForUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CheckPublicMembershipForUserReq)
	}
	resp := &CheckPublicMembershipForUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckPublicMembershipForUser performs requests for "orgs/check-public-membership-for-user"

Check public organization membership for a user.

  GET /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CheckPublicMembershipForUser(ctx context.Context, req *CheckPublicMembershipForUserReq, opt ...requests.Option) (*CheckPublicMembershipForUserResponse, error) {
	return CheckPublicMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
CheckPublicMembershipForUserReq is request data for Client.CheckPublicMembershipForUser

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CheckPublicMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CheckPublicMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckPublicMembershipForUserReq) Rel(link string, resp *CheckPublicMembershipForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckPublicMembershipForUserResponse is a response for CheckPublicMembershipForUser

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
type CheckPublicMembershipForUserResponse struct {
	httpResponse *http.Response
	Data         bool
}

// HTTPResponse returns the *http.Response
func (r *CheckPublicMembershipForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CheckPublicMembershipForUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 404})
	if err != nil {
		return err
	}
	err = internal.SetBoolResult(resp, &r.Data)
	if err != nil {
		return err
	}
	return nil
}

/*
ConvertMemberToOutsideCollaborator performs requests for "orgs/convert-member-to-outside-collaborator"

Convert an organization member to outside collaborator.

  PUT /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
func ConvertMemberToOutsideCollaborator(ctx context.Context, req *ConvertMemberToOutsideCollaboratorReq, opt ...requests.Option) (*ConvertMemberToOutsideCollaboratorResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ConvertMemberToOutsideCollaboratorReq)
	}
	resp := &ConvertMemberToOutsideCollaboratorResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ConvertMemberToOutsideCollaborator performs requests for "orgs/convert-member-to-outside-collaborator"

Convert an organization member to outside collaborator.

  PUT /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ConvertMemberToOutsideCollaborator(ctx context.Context, req *ConvertMemberToOutsideCollaboratorReq, opt ...requests.Option) (*ConvertMemberToOutsideCollaboratorResponse, error) {
	return ConvertMemberToOutsideCollaborator(ctx, req, append(c, opt...)...)
}

/*
ConvertMemberToOutsideCollaboratorReq is request data for Client.ConvertMemberToOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ConvertMemberToOutsideCollaboratorReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ConvertMemberToOutsideCollaboratorReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "PUT",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/outside_collaborators/%v", r.Org, r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ConvertMemberToOutsideCollaboratorReq) Rel(link string, resp *ConvertMemberToOutsideCollaboratorResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ConvertMemberToOutsideCollaboratorResponse is a response for ConvertMemberToOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
type ConvertMemberToOutsideCollaboratorResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *ConvertMemberToOutsideCollaboratorResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ConvertMemberToOutsideCollaboratorResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{202, 204})
	if err != nil {
		return err
	}
	return nil
}

/*
CreateInvitation performs requests for "orgs/create-invitation"

Create an organization invitation.

  POST /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
func CreateInvitation(ctx context.Context, req *CreateInvitationReq, opt ...requests.Option) (*CreateInvitationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CreateInvitationReq)
	}
	resp := &CreateInvitationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateInvitation performs requests for "orgs/create-invitation"

Create an organization invitation.

  POST /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CreateInvitation(ctx context.Context, req *CreateInvitationReq, opt ...requests.Option) (*CreateInvitationResponse, error) {
	return CreateInvitation(ctx, req, append(c, opt...)...)
}

/*
CreateInvitationReq is request data for Client.CreateInvitation

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CreateInvitationReq struct {
	_url        string
	Org         string
	RequestBody CreateInvitationReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CreateInvitationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		JSONRequestBody: true,
		Method:          "POST",
		Options:         opt,
		URLPath:         fmt.Sprintf("/orgs/%v/invitations", r.Org),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateInvitationReq) Rel(link string, resp *CreateInvitationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateInvitationReqBody is a request body for orgs/create-invitation

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
type CreateInvitationReqBody struct {

	/*
	**Required unless you provide `invitee_id`**. Email address of the person you
	are inviting, which can be an existing GitHub user.
	*/
	Email *string `json:"email,omitempty"`

	// **Required unless you provide `email`**. GitHub user ID for the person you are inviting.
	InviteeId *int64 `json:"invitee_id,omitempty"`

	/*
	Specify role for new member. Can be one of:
	\* `admin` - Organization owners with full administrative rights to the
	organization and complete access to all repositories and teams.
	\* `direct_member` - Non-owner organization members with ability to see other
	members and join teams by invitation.
	\* `billing_manager` - Non-owner organization members with ability to manage the
	billing settings of your organization.
	*/
	Role *string `json:"role,omitempty"`

	// Specify IDs for the teams you want to invite new members to.
	TeamIds []int64 `json:"team_ids,omitempty"`
}

/*
CreateInvitationResponse is a response for CreateInvitation

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
type CreateInvitationResponse struct {
	httpResponse *http.Response
	Data         components.OrganizationInvitation
}

// HTTPResponse returns the *http.Response
func (r *CreateInvitationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CreateInvitationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{201})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
CreateWebhook performs requests for "orgs/create-webhook"

Create an organization webhook.

  POST /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
func CreateWebhook(ctx context.Context, req *CreateWebhookReq, opt ...requests.Option) (*CreateWebhookResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CreateWebhookReq)
	}
	resp := &CreateWebhookResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateWebhook performs requests for "orgs/create-webhook"

Create an organization webhook.

  POST /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CreateWebhook(ctx context.Context, req *CreateWebhookReq, opt ...requests.Option) (*CreateWebhookResponse, error) {
	return CreateWebhook(ctx, req, append(c, opt...)...)
}

/*
CreateWebhookReq is request data for Client.CreateWebhook

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CreateWebhookReq struct {
	_url        string
	Org         string
	RequestBody CreateWebhookReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CreateWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		JSONRequestBody: true,
		Method:          "POST",
		Options:         opt,
		URLPath:         fmt.Sprintf("/orgs/%v/hooks", r.Org),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateWebhookReq) Rel(link string, resp *CreateWebhookResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateWebhookReqBodyConfig is a value for CreateWebhookReqBody's Config field
type CreateWebhookReqBodyConfig struct {

	// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
	ContentType *string `json:"content_type,omitempty"`

	/*
	Determines whether the SSL certificate of the host for `url` will be verified
	when delivering payloads. Supported values include `0` (verification is
	performed) and `1` (verification is not performed). The default is `0`. **We
	strongly recommend not setting this to `1` as you are subject to
	man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`
	Password    *string `json:"password,omitempty"`

	/*
	If provided, the `secret` will be used as the `key` to generate the HMAC hex
	digest value in the
	[`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url      *string `json:"url"`
	Username *string `json:"username,omitempty"`
}

/*
CreateWebhookReqBody is a request body for orgs/create-webhook

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
type CreateWebhookReqBody struct {

	// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
	Active *bool `json:"active,omitempty"`

	/*
	Key/value pairs to provide settings for this webhook. [These are defined
	below](https://developer.github.com/v3/orgs/hooks/#create-hook-config-params).
	*/
	Config *CreateWebhookReqBodyConfig `json:"config"`

	// Determines what [events](https://developer.github.com/webhooks/event-payloads) the hook is triggered for.
	Events []string `json:"events,omitempty"`

	// Must be passed as "web".
	Name *string `json:"name"`
}

/*
CreateWebhookResponse is a response for CreateWebhook

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
type CreateWebhookResponse struct {
	httpResponse *http.Response
	Data         components.OrgHook
}

// HTTPResponse returns the *http.Response
func (r *CreateWebhookResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CreateWebhookResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{201})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
DeleteWebhook performs requests for "orgs/delete-webhook"

Delete an organization webhook.

  DELETE /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
func DeleteWebhook(ctx context.Context, req *DeleteWebhookReq, opt ...requests.Option) (*DeleteWebhookResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DeleteWebhookReq)
	}
	resp := &DeleteWebhookResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteWebhook performs requests for "orgs/delete-webhook"

Delete an organization webhook.

  DELETE /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) DeleteWebhook(ctx context.Context, req *DeleteWebhookReq, opt ...requests.Option) (*DeleteWebhookResponse, error) {
	return DeleteWebhook(ctx, req, append(c, opt...)...)
}

/*
DeleteWebhookReq is request data for Client.DeleteWebhook

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DeleteWebhookReq struct {
	_url   string
	Org    string
	HookId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DeleteWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteWebhookReq) Rel(link string, resp *DeleteWebhookResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteWebhookResponse is a response for DeleteWebhook

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
type DeleteWebhookResponse struct {
	httpResponse *http.Response
	Data         bool
}

// HTTPResponse returns the *http.Response
func (r *DeleteWebhookResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DeleteWebhookResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 404})
	if err != nil {
		return err
	}
	err = internal.SetBoolResult(resp, &r.Data)
	if err != nil {
		return err
	}
	return nil
}

/*
Get performs requests for "orgs/get"

Get an organization.

  GET /orgs/{org}

https://developer.github.com/v3/orgs/#get-an-organization
*/
func Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetReq)
	}
	resp := &GetResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Get performs requests for "orgs/get"

Get an organization.

  GET /orgs/{org}

https://developer.github.com/v3/orgs/#get-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	return Get(ctx, req, append(c, opt...)...)
}

/*
GetReq is request data for Client.Get

https://developer.github.com/v3/orgs/#get-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetReq struct {
	_url string
	Org  string

	/*
	New repository creation permissions are available to preview. You can now use
	`members_can_create_public_repositories`,
	`members_can_create_private_repositories`, and
	`members_can_create_internal_repositories`. You can only allow members to create
	internal repositories if your organization is associated with an enterprise
	account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. These
	parameters provide more granular permissions to configure the type of
	repositories organization members can create.

	To access these new parameters during the preview period, you must set this to
	true.
	*/
	SurturPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews: []string{"surtur"},
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		Previews:    map[string]bool{"surtur": r.SurturPreview},
		URLPath:     fmt.Sprintf("/orgs/%v", r.Org),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReq) Rel(link string, resp *GetResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetResponse is a response for Get

https://developer.github.com/v3/orgs/#get-an-organization
*/
type GetResponse struct {
	httpResponse *http.Response
	Data         components.OrganizationFull
}

// HTTPResponse returns the *http.Response
func (r *GetResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetMembershipForAuthenticatedUser performs requests for "orgs/get-membership-for-authenticated-user"

Get an organization membership for the authenticated user.

  GET /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
func GetMembershipForAuthenticatedUser(ctx context.Context, req *GetMembershipForAuthenticatedUserReq, opt ...requests.Option) (*GetMembershipForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetMembershipForAuthenticatedUserReq)
	}
	resp := &GetMembershipForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetMembershipForAuthenticatedUser performs requests for "orgs/get-membership-for-authenticated-user"

Get an organization membership for the authenticated user.

  GET /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetMembershipForAuthenticatedUser(ctx context.Context, req *GetMembershipForAuthenticatedUserReq, opt ...requests.Option) (*GetMembershipForAuthenticatedUserResponse, error) {
	return GetMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
GetMembershipForAuthenticatedUserReq is request data for Client.GetMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetMembershipForAuthenticatedUserReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/user/memberships/orgs/%v", r.Org),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetMembershipForAuthenticatedUserReq) Rel(link string, resp *GetMembershipForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetMembershipForAuthenticatedUserResponse is a response for GetMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
type GetMembershipForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         components.OrgMembership
}

// HTTPResponse returns the *http.Response
func (r *GetMembershipForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetMembershipForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetMembershipForUser performs requests for "orgs/get-membership-for-user"

Get organization membership for a user.

  GET /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
func GetMembershipForUser(ctx context.Context, req *GetMembershipForUserReq, opt ...requests.Option) (*GetMembershipForUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetMembershipForUserReq)
	}
	resp := &GetMembershipForUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetMembershipForUser performs requests for "orgs/get-membership-for-user"

Get organization membership for a user.

  GET /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetMembershipForUser(ctx context.Context, req *GetMembershipForUserReq, opt ...requests.Option) (*GetMembershipForUserResponse, error) {
	return GetMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
GetMembershipForUserReq is request data for Client.GetMembershipForUser

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetMembershipForUserReq) Rel(link string, resp *GetMembershipForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetMembershipForUserResponse is a response for GetMembershipForUser

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
type GetMembershipForUserResponse struct {
	httpResponse *http.Response
	Data         components.OrgMembership
}

// HTTPResponse returns the *http.Response
func (r *GetMembershipForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetMembershipForUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetWebhook performs requests for "orgs/get-webhook"

Get an organization webhook.

  GET /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
func GetWebhook(ctx context.Context, req *GetWebhookReq, opt ...requests.Option) (*GetWebhookResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetWebhookReq)
	}
	resp := &GetWebhookResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetWebhook performs requests for "orgs/get-webhook"

Get an organization webhook.

  GET /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetWebhook(ctx context.Context, req *GetWebhookReq, opt ...requests.Option) (*GetWebhookResponse, error) {
	return GetWebhook(ctx, req, append(c, opt...)...)
}

/*
GetWebhookReq is request data for Client.GetWebhook

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetWebhookReq struct {
	_url   string
	Org    string
	HookId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetWebhookReq) Rel(link string, resp *GetWebhookResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetWebhookResponse is a response for GetWebhook

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
type GetWebhookResponse struct {
	httpResponse *http.Response
	Data         components.OrgHook
}

// HTTPResponse returns the *http.Response
func (r *GetWebhookResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetWebhookResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
List performs requests for "orgs/list"

List organizations.

  GET /organizations

https://developer.github.com/v3/orgs/#list-organizations
*/
func List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReq)
	}
	resp := &ListResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
List performs requests for "orgs/list"

List organizations.

  GET /organizations

https://developer.github.com/v3/orgs/#list-organizations

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	return List(ctx, req, append(c, opt...)...)
}

/*
ListReq is request data for Client.List

https://developer.github.com/v3/orgs/#list-organizations

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/organizations"),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReq) Rel(link string, resp *ListResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListResponse is a response for List

https://developer.github.com/v3/orgs/#list-organizations
*/
type ListResponse struct {
	httpResponse *http.Response
	Data         []components.OrganizationSimple
}

// HTTPResponse returns the *http.Response
func (r *ListResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListAppInstallations performs requests for "orgs/list-app-installations"

List app installations for an organization.

  GET /orgs/{org}/installations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
func ListAppInstallations(ctx context.Context, req *ListAppInstallationsReq, opt ...requests.Option) (*ListAppInstallationsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListAppInstallationsReq)
	}
	resp := &ListAppInstallationsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListAppInstallations performs requests for "orgs/list-app-installations"

List app installations for an organization.

  GET /orgs/{org}/installations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListAppInstallations(ctx context.Context, req *ListAppInstallationsReq, opt ...requests.Option) (*ListAppInstallationsResponse, error) {
	return ListAppInstallations(ctx, req, append(c, opt...)...)
}

/*
ListAppInstallationsReq is request data for Client.ListAppInstallations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListAppInstallationsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListAppInstallationsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/orgs/%v/installations", r.Org),
		URLQuery:         query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListAppInstallationsReq) Rel(link string, resp *ListAppInstallationsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListAppInstallationsResponseBody is a response body for ListAppInstallations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
type ListAppInstallationsResponseBody struct {
	Installations []components.Installation `json:"installations,omitempty"`
	TotalCount    int64                     `json:"total_count,omitempty"`
}

/*
ListAppInstallationsResponse is a response for ListAppInstallations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
type ListAppInstallationsResponse struct {
	httpResponse *http.Response
	Data         ListAppInstallationsResponseBody
}

// HTTPResponse returns the *http.Response
func (r *ListAppInstallationsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListAppInstallationsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListBlockedUsers performs requests for "orgs/list-blocked-users"

List users blocked by an organization.

  GET /orgs/{org}/blocks

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
func ListBlockedUsers(ctx context.Context, req *ListBlockedUsersReq, opt ...requests.Option) (*ListBlockedUsersResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListBlockedUsersReq)
	}
	resp := &ListBlockedUsersResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListBlockedUsers performs requests for "orgs/list-blocked-users"

List users blocked by an organization.

  GET /orgs/{org}/blocks

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListBlockedUsers(ctx context.Context, req *ListBlockedUsersReq, opt ...requests.Option) (*ListBlockedUsersResponse, error) {
	return ListBlockedUsers(ctx, req, append(c, opt...)...)
}

/*
ListBlockedUsersReq is request data for Client.ListBlockedUsers

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListBlockedUsersReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListBlockedUsersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/blocks", r.Org),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListBlockedUsersReq) Rel(link string, resp *ListBlockedUsersResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListBlockedUsersResponse is a response for ListBlockedUsers

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
type ListBlockedUsersResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

// HTTPResponse returns the *http.Response
func (r *ListBlockedUsersResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListBlockedUsersResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListForAuthenticatedUser performs requests for "orgs/list-for-authenticated-user"

List organizations for the authenticated user.

  GET /user/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
func ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListForAuthenticatedUserReq)
	}
	resp := &ListForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForAuthenticatedUser performs requests for "orgs/list-for-authenticated-user"

List organizations for the authenticated user.

  GET /user/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	return ListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListForAuthenticatedUserReq is request data for Client.ListForAuthenticatedUser

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/user/orgs"),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForAuthenticatedUserReq) Rel(link string, resp *ListForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForAuthenticatedUserResponse is a response for ListForAuthenticatedUser

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
type ListForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.OrganizationSimple
}

// HTTPResponse returns the *http.Response
func (r *ListForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListForUser performs requests for "orgs/list-for-user"

List organizations for a user.

  GET /users/{username}/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
func ListForUser(ctx context.Context, req *ListForUserReq, opt ...requests.Option) (*ListForUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListForUserReq)
	}
	resp := &ListForUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForUser performs requests for "orgs/list-for-user"

List organizations for a user.

  GET /users/{username}/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListForUser(ctx context.Context, req *ListForUserReq, opt ...requests.Option) (*ListForUserResponse, error) {
	return ListForUser(ctx, req, append(c, opt...)...)
}

/*
ListForUserReq is request data for Client.ListForUser

https://developer.github.com/v3/orgs/#list-organizations-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/users/%v/orgs", r.Username),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForUserReq) Rel(link string, resp *ListForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForUserResponse is a response for ListForUser

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
type ListForUserResponse struct {
	httpResponse *http.Response
	Data         []components.OrganizationSimple
}

// HTTPResponse returns the *http.Response
func (r *ListForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListForUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListInvitationTeams performs requests for "orgs/list-invitation-teams"

List organization invitation teams.

  GET /orgs/{org}/invitations/{invitation_id}/teams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
func ListInvitationTeams(ctx context.Context, req *ListInvitationTeamsReq, opt ...requests.Option) (*ListInvitationTeamsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListInvitationTeamsReq)
	}
	resp := &ListInvitationTeamsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListInvitationTeams performs requests for "orgs/list-invitation-teams"

List organization invitation teams.

  GET /orgs/{org}/invitations/{invitation_id}/teams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListInvitationTeams(ctx context.Context, req *ListInvitationTeamsReq, opt ...requests.Option) (*ListInvitationTeamsResponse, error) {
	return ListInvitationTeams(ctx, req, append(c, opt...)...)
}

/*
ListInvitationTeamsReq is request data for Client.ListInvitationTeams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListInvitationTeamsReq struct {
	_url string
	Org  string

	// invitation_id parameter
	InvitationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListInvitationTeamsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/invitations/%v/teams", r.Org, r.InvitationId),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInvitationTeamsReq) Rel(link string, resp *ListInvitationTeamsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInvitationTeamsResponse is a response for ListInvitationTeams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
type ListInvitationTeamsResponse struct {
	httpResponse *http.Response
	Data         []components.Team
}

// HTTPResponse returns the *http.Response
func (r *ListInvitationTeamsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListInvitationTeamsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListMembers performs requests for "orgs/list-members"

List organization members.

  GET /orgs/{org}/members

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
func ListMembers(ctx context.Context, req *ListMembersReq, opt ...requests.Option) (*ListMembersResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListMembersReq)
	}
	resp := &ListMembersResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListMembers performs requests for "orgs/list-members"

List organization members.

  GET /orgs/{org}/members

https://developer.github.com/v3/orgs/members/#list-organization-members

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListMembers(ctx context.Context, req *ListMembersReq, opt ...requests.Option) (*ListMembersResponse, error) {
	return ListMembers(ctx, req, append(c, opt...)...)
}

/*
ListMembersReq is request data for Client.ListMembers

https://developer.github.com/v3/orgs/members/#list-organization-members

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListMembersReq struct {
	_url string
	Org  string

	/*
	Filter members returned in the list. Can be one of:
	\* `2fa_disabled` - Members without [two-factor
	authentication](https://github.com/blog/1614-two-factor-authentication) enabled.
	Available for organization owners.
	\* `all` - All members the authenticated user can see.
	*/
	Filter *string

	/*
	Filter members returned by their role. Can be one of:
	\* `all` - All members of the organization, regardless of role.
	\* `admin` - Organization owners.
	\* `member` - Non-owner organization members.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListMembersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/members", r.Org),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListMembersReq) Rel(link string, resp *ListMembersResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListMembersResponse is a response for ListMembers

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
type ListMembersResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

// HTTPResponse returns the *http.Response
func (r *ListMembersResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListMembersResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 302})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListMembershipsForAuthenticatedUser performs requests for "orgs/list-memberships-for-authenticated-user"

List organization memberships for the authenticated user.

  GET /user/memberships/orgs

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
func ListMembershipsForAuthenticatedUser(ctx context.Context, req *ListMembershipsForAuthenticatedUserReq, opt ...requests.Option) (*ListMembershipsForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListMembershipsForAuthenticatedUserReq)
	}
	resp := &ListMembershipsForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListMembershipsForAuthenticatedUser performs requests for "orgs/list-memberships-for-authenticated-user"

List organization memberships for the authenticated user.

  GET /user/memberships/orgs

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListMembershipsForAuthenticatedUser(ctx context.Context, req *ListMembershipsForAuthenticatedUserReq, opt ...requests.Option) (*ListMembershipsForAuthenticatedUserResponse, error) {
	return ListMembershipsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListMembershipsForAuthenticatedUserReq is request data for Client.ListMembershipsForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListMembershipsForAuthenticatedUserReq struct {
	_url string

	/*
	Indicates the state of the memberships to return. Can be either `active` or
	`pending`. If not specified, the API returns both active and pending
	memberships.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListMembershipsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/user/memberships/orgs"),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListMembershipsForAuthenticatedUserReq) Rel(link string, resp *ListMembershipsForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListMembershipsForAuthenticatedUserResponse is a response for ListMembershipsForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
type ListMembershipsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.OrgMembership
}

// HTTPResponse returns the *http.Response
func (r *ListMembershipsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListMembershipsForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListOutsideCollaborators performs requests for "orgs/list-outside-collaborators"

List outside collaborators for an organization.

  GET /orgs/{org}/outside_collaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
func ListOutsideCollaborators(ctx context.Context, req *ListOutsideCollaboratorsReq, opt ...requests.Option) (*ListOutsideCollaboratorsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListOutsideCollaboratorsReq)
	}
	resp := &ListOutsideCollaboratorsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListOutsideCollaborators performs requests for "orgs/list-outside-collaborators"

List outside collaborators for an organization.

  GET /orgs/{org}/outside_collaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListOutsideCollaborators(ctx context.Context, req *ListOutsideCollaboratorsReq, opt ...requests.Option) (*ListOutsideCollaboratorsResponse, error) {
	return ListOutsideCollaborators(ctx, req, append(c, opt...)...)
}

/*
ListOutsideCollaboratorsReq is request data for Client.ListOutsideCollaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListOutsideCollaboratorsReq struct {
	_url string
	Org  string

	/*
	Filter the list of outside collaborators. Can be one of:
	\* `2fa_disabled`: Outside collaborators without [two-factor
	authentication](https://github.com/blog/1614-two-factor-authentication) enabled.
	\* `all`: All outside collaborators.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListOutsideCollaboratorsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/outside_collaborators", r.Org),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListOutsideCollaboratorsReq) Rel(link string, resp *ListOutsideCollaboratorsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListOutsideCollaboratorsResponse is a response for ListOutsideCollaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
type ListOutsideCollaboratorsResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

// HTTPResponse returns the *http.Response
func (r *ListOutsideCollaboratorsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListOutsideCollaboratorsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListPendingInvitations performs requests for "orgs/list-pending-invitations"

List pending organization invitations.

  GET /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
func ListPendingInvitations(ctx context.Context, req *ListPendingInvitationsReq, opt ...requests.Option) (*ListPendingInvitationsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListPendingInvitationsReq)
	}
	resp := &ListPendingInvitationsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPendingInvitations performs requests for "orgs/list-pending-invitations"

List pending organization invitations.

  GET /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListPendingInvitations(ctx context.Context, req *ListPendingInvitationsReq, opt ...requests.Option) (*ListPendingInvitationsResponse, error) {
	return ListPendingInvitations(ctx, req, append(c, opt...)...)
}

/*
ListPendingInvitationsReq is request data for Client.ListPendingInvitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListPendingInvitationsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListPendingInvitationsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/invitations", r.Org),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPendingInvitationsReq) Rel(link string, resp *ListPendingInvitationsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPendingInvitationsResponse is a response for ListPendingInvitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
type ListPendingInvitationsResponse struct {
	httpResponse *http.Response
	Data         []components.OrganizationInvitation
}

// HTTPResponse returns the *http.Response
func (r *ListPendingInvitationsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListPendingInvitationsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListPublicMembers performs requests for "orgs/list-public-members"

List public organization members.

  GET /orgs/{org}/public_members

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
func ListPublicMembers(ctx context.Context, req *ListPublicMembersReq, opt ...requests.Option) (*ListPublicMembersResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListPublicMembersReq)
	}
	resp := &ListPublicMembersResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublicMembers performs requests for "orgs/list-public-members"

List public organization members.

  GET /orgs/{org}/public_members

https://developer.github.com/v3/orgs/members/#list-public-organization-members

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListPublicMembers(ctx context.Context, req *ListPublicMembersReq, opt ...requests.Option) (*ListPublicMembersResponse, error) {
	return ListPublicMembers(ctx, req, append(c, opt...)...)
}

/*
ListPublicMembersReq is request data for Client.ListPublicMembers

https://developer.github.com/v3/orgs/members/#list-public-organization-members

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListPublicMembersReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListPublicMembersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/public_members", r.Org),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicMembersReq) Rel(link string, resp *ListPublicMembersResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicMembersResponse is a response for ListPublicMembers

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
type ListPublicMembersResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

// HTTPResponse returns the *http.Response
func (r *ListPublicMembersResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListPublicMembersResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListSamlSsoAuthorizations performs requests for "orgs/list-saml-sso-authorizations"

List SAML SSO authorizations for an organization.

  GET /orgs/{org}/credential-authorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
func ListSamlSsoAuthorizations(ctx context.Context, req *ListSamlSsoAuthorizationsReq, opt ...requests.Option) (*ListSamlSsoAuthorizationsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListSamlSsoAuthorizationsReq)
	}
	resp := &ListSamlSsoAuthorizationsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListSamlSsoAuthorizations performs requests for "orgs/list-saml-sso-authorizations"

List SAML SSO authorizations for an organization.

  GET /orgs/{org}/credential-authorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListSamlSsoAuthorizations(ctx context.Context, req *ListSamlSsoAuthorizationsReq, opt ...requests.Option) (*ListSamlSsoAuthorizationsResponse, error) {
	return ListSamlSsoAuthorizations(ctx, req, append(c, opt...)...)
}

/*
ListSamlSsoAuthorizationsReq is request data for Client.ListSamlSsoAuthorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListSamlSsoAuthorizationsReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListSamlSsoAuthorizationsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/credential-authorizations", r.Org),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListSamlSsoAuthorizationsReq) Rel(link string, resp *ListSamlSsoAuthorizationsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListSamlSsoAuthorizationsResponse is a response for ListSamlSsoAuthorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
type ListSamlSsoAuthorizationsResponse struct {
	httpResponse *http.Response
	Data         []components.CredentialAuthorization
}

// HTTPResponse returns the *http.Response
func (r *ListSamlSsoAuthorizationsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListSamlSsoAuthorizationsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListWebhooks performs requests for "orgs/list-webhooks"

List organization webhooks.

  GET /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
func ListWebhooks(ctx context.Context, req *ListWebhooksReq, opt ...requests.Option) (*ListWebhooksResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListWebhooksReq)
	}
	resp := &ListWebhooksResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListWebhooks performs requests for "orgs/list-webhooks"

List organization webhooks.

  GET /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListWebhooks(ctx context.Context, req *ListWebhooksReq, opt ...requests.Option) (*ListWebhooksResponse, error) {
	return ListWebhooks(ctx, req, append(c, opt...)...)
}

/*
ListWebhooksReq is request data for Client.ListWebhooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListWebhooksReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListWebhooksReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/hooks", r.Org),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListWebhooksReq) Rel(link string, resp *ListWebhooksResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListWebhooksResponse is a response for ListWebhooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
type ListWebhooksResponse struct {
	httpResponse *http.Response
	Data         []components.OrgHook
}

// HTTPResponse returns the *http.Response
func (r *ListWebhooksResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListWebhooksResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
PingWebhook performs requests for "orgs/ping-webhook"

Ping an organization webhook.

  POST /orgs/{org}/hooks/{hook_id}/pings

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
func PingWebhook(ctx context.Context, req *PingWebhookReq, opt ...requests.Option) (*PingWebhookResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(PingWebhookReq)
	}
	resp := &PingWebhookResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PingWebhook performs requests for "orgs/ping-webhook"

Ping an organization webhook.

  POST /orgs/{org}/hooks/{hook_id}/pings

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) PingWebhook(ctx context.Context, req *PingWebhookReq, opt ...requests.Option) (*PingWebhookResponse, error) {
	return PingWebhook(ctx, req, append(c, opt...)...)
}

/*
PingWebhookReq is request data for Client.PingWebhook

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type PingWebhookReq struct {
	_url   string
	Org    string
	HookId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *PingWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "POST",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/hooks/%v/pings", r.Org, r.HookId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PingWebhookReq) Rel(link string, resp *PingWebhookResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PingWebhookResponse is a response for PingWebhook

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
type PingWebhookResponse struct {
	httpResponse *http.Response
	Data         bool
}

// HTTPResponse returns the *http.Response
func (r *PingWebhookResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *PingWebhookResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 404})
	if err != nil {
		return err
	}
	err = internal.SetBoolResult(resp, &r.Data)
	if err != nil {
		return err
	}
	return nil
}

/*
RemoveMember performs requests for "orgs/remove-member"

Remove an organization member.

  DELETE /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
func RemoveMember(ctx context.Context, req *RemoveMemberReq, opt ...requests.Option) (*RemoveMemberResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(RemoveMemberReq)
	}
	resp := &RemoveMemberResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveMember performs requests for "orgs/remove-member"

Remove an organization member.

  DELETE /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#remove-an-organization-member

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) RemoveMember(ctx context.Context, req *RemoveMemberReq, opt ...requests.Option) (*RemoveMemberResponse, error) {
	return RemoveMember(ctx, req, append(c, opt...)...)
}

/*
RemoveMemberReq is request data for Client.RemoveMember

https://developer.github.com/v3/orgs/members/#remove-an-organization-member

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type RemoveMemberReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *RemoveMemberReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/members/%v", r.Org, r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveMemberReq) Rel(link string, resp *RemoveMemberResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveMemberResponse is a response for RemoveMember

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
type RemoveMemberResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *RemoveMemberResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *RemoveMemberResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
RemoveMembershipForUser performs requests for "orgs/remove-membership-for-user"

Remove organization membership for a user.

  DELETE /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
func RemoveMembershipForUser(ctx context.Context, req *RemoveMembershipForUserReq, opt ...requests.Option) (*RemoveMembershipForUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(RemoveMembershipForUserReq)
	}
	resp := &RemoveMembershipForUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveMembershipForUser performs requests for "orgs/remove-membership-for-user"

Remove organization membership for a user.

  DELETE /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) RemoveMembershipForUser(ctx context.Context, req *RemoveMembershipForUserReq, opt ...requests.Option) (*RemoveMembershipForUserResponse, error) {
	return RemoveMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
RemoveMembershipForUserReq is request data for Client.RemoveMembershipForUser

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type RemoveMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *RemoveMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveMembershipForUserReq) Rel(link string, resp *RemoveMembershipForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveMembershipForUserResponse is a response for RemoveMembershipForUser

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
type RemoveMembershipForUserResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *RemoveMembershipForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *RemoveMembershipForUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
RemoveOutsideCollaborator performs requests for "orgs/remove-outside-collaborator"

Remove outside collaborator from an organization.

  DELETE /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
func RemoveOutsideCollaborator(ctx context.Context, req *RemoveOutsideCollaboratorReq, opt ...requests.Option) (*RemoveOutsideCollaboratorResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(RemoveOutsideCollaboratorReq)
	}
	resp := &RemoveOutsideCollaboratorResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveOutsideCollaborator performs requests for "orgs/remove-outside-collaborator"

Remove outside collaborator from an organization.

  DELETE /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) RemoveOutsideCollaborator(ctx context.Context, req *RemoveOutsideCollaboratorReq, opt ...requests.Option) (*RemoveOutsideCollaboratorResponse, error) {
	return RemoveOutsideCollaborator(ctx, req, append(c, opt...)...)
}

/*
RemoveOutsideCollaboratorReq is request data for Client.RemoveOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type RemoveOutsideCollaboratorReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *RemoveOutsideCollaboratorReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/outside_collaborators/%v", r.Org, r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveOutsideCollaboratorReq) Rel(link string, resp *RemoveOutsideCollaboratorResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveOutsideCollaboratorResponse is a response for RemoveOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
type RemoveOutsideCollaboratorResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *RemoveOutsideCollaboratorResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *RemoveOutsideCollaboratorResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
RemovePublicMembershipForAuthenticatedUser performs requests for "orgs/remove-public-membership-for-authenticated-user"

Remove public organization membership for the authenticated user.

  DELETE /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
func RemovePublicMembershipForAuthenticatedUser(ctx context.Context, req *RemovePublicMembershipForAuthenticatedUserReq, opt ...requests.Option) (*RemovePublicMembershipForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(RemovePublicMembershipForAuthenticatedUserReq)
	}
	resp := &RemovePublicMembershipForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemovePublicMembershipForAuthenticatedUser performs requests for "orgs/remove-public-membership-for-authenticated-user"

Remove public organization membership for the authenticated user.

  DELETE /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) RemovePublicMembershipForAuthenticatedUser(ctx context.Context, req *RemovePublicMembershipForAuthenticatedUserReq, opt ...requests.Option) (*RemovePublicMembershipForAuthenticatedUserResponse, error) {
	return RemovePublicMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
RemovePublicMembershipForAuthenticatedUserReq is request data for Client.RemovePublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type RemovePublicMembershipForAuthenticatedUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *RemovePublicMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemovePublicMembershipForAuthenticatedUserReq) Rel(link string, resp *RemovePublicMembershipForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemovePublicMembershipForAuthenticatedUserResponse is a response for RemovePublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
type RemovePublicMembershipForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *RemovePublicMembershipForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *RemovePublicMembershipForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
RemoveSamlSsoAuthorization performs requests for "orgs/remove-saml-sso-authorization"

Remove a SAML SSO authorization for an organization.

  DELETE /orgs/{org}/credential-authorizations/{credential_id}

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
func RemoveSamlSsoAuthorization(ctx context.Context, req *RemoveSamlSsoAuthorizationReq, opt ...requests.Option) (*RemoveSamlSsoAuthorizationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(RemoveSamlSsoAuthorizationReq)
	}
	resp := &RemoveSamlSsoAuthorizationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveSamlSsoAuthorization performs requests for "orgs/remove-saml-sso-authorization"

Remove a SAML SSO authorization for an organization.

  DELETE /orgs/{org}/credential-authorizations/{credential_id}

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) RemoveSamlSsoAuthorization(ctx context.Context, req *RemoveSamlSsoAuthorizationReq, opt ...requests.Option) (*RemoveSamlSsoAuthorizationResponse, error) {
	return RemoveSamlSsoAuthorization(ctx, req, append(c, opt...)...)
}

/*
RemoveSamlSsoAuthorizationReq is request data for Client.RemoveSamlSsoAuthorization

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type RemoveSamlSsoAuthorizationReq struct {
	_url string
	Org  string

	// credential_id parameter
	CredentialId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *RemoveSamlSsoAuthorizationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/credential-authorizations/%v", r.Org, r.CredentialId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveSamlSsoAuthorizationReq) Rel(link string, resp *RemoveSamlSsoAuthorizationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveSamlSsoAuthorizationResponse is a response for RemoveSamlSsoAuthorization

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
type RemoveSamlSsoAuthorizationResponse struct {
	httpResponse *http.Response
	Data         bool
}

// HTTPResponse returns the *http.Response
func (r *RemoveSamlSsoAuthorizationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *RemoveSamlSsoAuthorizationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 404})
	if err != nil {
		return err
	}
	err = internal.SetBoolResult(resp, &r.Data)
	if err != nil {
		return err
	}
	return nil
}

/*
SetMembershipForUser performs requests for "orgs/set-membership-for-user"

Set organization membership for a user.

  PUT /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
func SetMembershipForUser(ctx context.Context, req *SetMembershipForUserReq, opt ...requests.Option) (*SetMembershipForUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(SetMembershipForUserReq)
	}
	resp := &SetMembershipForUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetMembershipForUser performs requests for "orgs/set-membership-for-user"

Set organization membership for a user.

  PUT /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) SetMembershipForUser(ctx context.Context, req *SetMembershipForUserReq, opt ...requests.Option) (*SetMembershipForUserResponse, error) {
	return SetMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
SetMembershipForUserReq is request data for Client.SetMembershipForUser

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type SetMembershipForUserReq struct {
	_url        string
	Org         string
	Username    string
	RequestBody SetMembershipForUserReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *SetMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		JSONRequestBody: true,
		Method:          "PUT",
		Options:         opt,
		URLPath:         fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetMembershipForUserReq) Rel(link string, resp *SetMembershipForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetMembershipForUserReqBody is a request body for orgs/set-membership-for-user

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
type SetMembershipForUserReqBody struct {

	/*
	The role to give the user in the organization. Can be one of:
	\* `admin` - The user will become an owner of the organization.
	\* `member` - The user will become a non-owner member of the organization.
	*/
	Role *string `json:"role,omitempty"`
}

/*
SetMembershipForUserResponse is a response for SetMembershipForUser

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
type SetMembershipForUserResponse struct {
	httpResponse *http.Response
	Data         components.OrgMembership
}

// HTTPResponse returns the *http.Response
func (r *SetMembershipForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *SetMembershipForUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
SetPublicMembershipForAuthenticatedUser performs requests for "orgs/set-public-membership-for-authenticated-user"

Set public organization membership for the authenticated user.

  PUT /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
func SetPublicMembershipForAuthenticatedUser(ctx context.Context, req *SetPublicMembershipForAuthenticatedUserReq, opt ...requests.Option) (*SetPublicMembershipForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(SetPublicMembershipForAuthenticatedUserReq)
	}
	resp := &SetPublicMembershipForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetPublicMembershipForAuthenticatedUser performs requests for "orgs/set-public-membership-for-authenticated-user"

Set public organization membership for the authenticated user.

  PUT /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) SetPublicMembershipForAuthenticatedUser(ctx context.Context, req *SetPublicMembershipForAuthenticatedUserReq, opt ...requests.Option) (*SetPublicMembershipForAuthenticatedUserResponse, error) {
	return SetPublicMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
SetPublicMembershipForAuthenticatedUserReq is request data for Client.SetPublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type SetPublicMembershipForAuthenticatedUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *SetPublicMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "PUT",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetPublicMembershipForAuthenticatedUserReq) Rel(link string, resp *SetPublicMembershipForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetPublicMembershipForAuthenticatedUserResponse is a response for SetPublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
type SetPublicMembershipForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *SetPublicMembershipForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *SetPublicMembershipForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
UnblockUser performs requests for "orgs/unblock-user"

Unblock a user from an organization.

  DELETE /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
func UnblockUser(ctx context.Context, req *UnblockUserReq, opt ...requests.Option) (*UnblockUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UnblockUserReq)
	}
	resp := &UnblockUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UnblockUser performs requests for "orgs/unblock-user"

Unblock a user from an organization.

  DELETE /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) UnblockUser(ctx context.Context, req *UnblockUserReq, opt ...requests.Option) (*UnblockUserResponse, error) {
	return UnblockUser(ctx, req, append(c, opt...)...)
}

/*
UnblockUserReq is request data for Client.UnblockUser

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UnblockUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UnblockUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnblockUserReq) Rel(link string, resp *UnblockUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnblockUserResponse is a response for UnblockUser

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
type UnblockUserResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *UnblockUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UnblockUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
Update performs requests for "orgs/update"

Update an organization.

  PATCH /orgs/{org}

https://developer.github.com/v3/orgs/#update-an-organization
*/
func Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UpdateReq)
	}
	resp := &UpdateResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Update performs requests for "orgs/update"

Update an organization.

  PATCH /orgs/{org}

https://developer.github.com/v3/orgs/#update-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	return Update(ctx, req, append(c, opt...)...)
}

/*
UpdateReq is request data for Client.Update

https://developer.github.com/v3/orgs/#update-an-organization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UpdateReq struct {
	_url        string
	Org         string
	RequestBody UpdateReqBody

	/*
	New repository creation permissions are available to preview. You can now use
	`members_can_create_public_repositories`,
	`members_can_create_private_repositories`, and
	`members_can_create_internal_repositories`. You can only allow members to create
	internal repositories if your organization is associated with an enterprise
	account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. These
	parameters provide more granular permissions to configure the type of
	repositories organization members can create.

	To access these new parameters during the preview period, you must set this to
	true.
	*/
	SurturPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UpdateReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews: []string{"surtur"},
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		JSONRequestBody: true,
		Method:          "PATCH",
		Options:         opt,
		Previews:        map[string]bool{"surtur": r.SurturPreview},
		URLPath:         fmt.Sprintf("/orgs/%v", r.Org),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReq) Rel(link string, resp *UpdateResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateReqBody is a request body for orgs/update

https://developer.github.com/v3/orgs/#update-an-organization
*/
type UpdateReqBody struct {

	// Billing email address. This address is not publicized.
	BillingEmail *string `json:"billing_email,omitempty"`
	Blog         *string `json:"blog,omitempty"`

	// The company name.
	Company *string `json:"company,omitempty"`

	/*
	Default permission level members have for organization repositories:
	\* `read` - can pull, but not push to or administer this repository.
	\* `write` - can pull and push, but not administer this repository.
	\* `admin` - can pull, push, and administer this repository.
	\* `none` - no permissions granted by default.
	*/
	DefaultRepositoryPermission *string `json:"default_repository_permission,omitempty"`

	// The description of the company.
	Description *string `json:"description,omitempty"`

	// The publicly visible email address.
	Email *string `json:"email,omitempty"`

	// Toggles whether an organization can use organization projects.
	HasOrganizationProjects *bool `json:"has_organization_projects,omitempty"`

	// Toggles whether repositories that belong to the organization can use repository projects.
	HasRepositoryProjects *bool `json:"has_repository_projects,omitempty"`

	// The location.
	Location *string `json:"location,omitempty"`

	/*
	Specifies which types of repositories non-admin organization members can create.
	Can be one of:
	\* `all` - all organization members can create public and private repositories.
	\* `private` - members can create private repositories. This option is only
	available to repositories that are part of an organization on GitHub Enterprise
	Cloud.
	\* `none` - only admin members can create repositories.
	**Note:** This parameter is deprecated and will be removed in the future. Its
	return value ignores internal repositories. Using this parameter overrides
	values set in `members_can_create_repositories`. See [this
	note](https://developer.github.com/v3/orgs/#members_can_create_repositories) for
	details.
	*/
	MembersAllowedRepositoryCreationType *string `json:"members_allowed_repository_creation_type,omitempty"`

	/*
	Toggles whether organization members can create internal repositories, which are
	visible to all enterprise members. You can only allow members to create internal
	repositories if your organization is associated with an enterprise account using
	GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. Can be one of:
	\* `true` - all organization members can create internal repositories.
	\* `false` - only organization owners can create internal repositories.
	Default: `true`. For more information, see "[Restricting repository creation in
	your
	organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	in the GitHub Help documentation.
	*/
	MembersCanCreateInternalRepositories *bool `json:"members_can_create_internal_repositories,omitempty"`

	/*
	Toggles whether organization members can create private repositories, which are
	visible to organization members with permission. Can be one of:
	\* `true` - all organization members can create private repositories.
	\* `false` - only organization owners can create private repositories.
	Default: `true`. For more information, see "[Restricting repository creation in
	your
	organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	in the GitHub Help documentation.
	*/
	MembersCanCreatePrivateRepositories *bool `json:"members_can_create_private_repositories,omitempty"`

	/*
	Toggles whether organization members can create public repositories, which are
	visible to anyone. Can be one of:
	\* `true` - all organization members can create public repositories.
	\* `false` - only organization owners can create public repositories.
	Default: `true`. For more information, see "[Restricting repository creation in
	your
	organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	in the GitHub Help documentation.
	*/
	MembersCanCreatePublicRepositories *bool `json:"members_can_create_public_repositories,omitempty"`

	/*
	Toggles the ability of non-admin organization members to create repositories.
	Can be one of:
	\* `true` - all organization members can create repositories.
	\* `false` - only organization owners can create repositories.
	Default: `true`
	**Note:** A parameter can override this parameter. See
	`members_allowed_repository_creation_type` in this table for details. **Note:**
	A parameter can override this parameter. See
	`members_allowed_repository_creation_type` in this table for details.
	*/
	MembersCanCreateRepositories *bool `json:"members_can_create_repositories,omitempty"`

	// The shorthand name of the company.
	Name *string `json:"name,omitempty"`

	// The Twitter username of the company.
	TwitterUsername *string `json:"twitter_username,omitempty"`
}

/*
UpdateResponse is a response for Update

https://developer.github.com/v3/orgs/#update-an-organization
*/
type UpdateResponse struct {
	httpResponse *http.Response
	Data         components.OrganizationFull
}

// HTTPResponse returns the *http.Response
func (r *UpdateResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UpdateResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
UpdateMembershipForAuthenticatedUser performs requests for "orgs/update-membership-for-authenticated-user"

Update an organization membership for the authenticated user.

  PATCH /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
func UpdateMembershipForAuthenticatedUser(ctx context.Context, req *UpdateMembershipForAuthenticatedUserReq, opt ...requests.Option) (*UpdateMembershipForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UpdateMembershipForAuthenticatedUserReq)
	}
	resp := &UpdateMembershipForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateMembershipForAuthenticatedUser performs requests for "orgs/update-membership-for-authenticated-user"

Update an organization membership for the authenticated user.

  PATCH /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) UpdateMembershipForAuthenticatedUser(ctx context.Context, req *UpdateMembershipForAuthenticatedUserReq, opt ...requests.Option) (*UpdateMembershipForAuthenticatedUserResponse, error) {
	return UpdateMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
UpdateMembershipForAuthenticatedUserReq is request data for Client.UpdateMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UpdateMembershipForAuthenticatedUserReq struct {
	_url        string
	Org         string
	RequestBody UpdateMembershipForAuthenticatedUserReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UpdateMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		JSONRequestBody: true,
		Method:          "PATCH",
		Options:         opt,
		URLPath:         fmt.Sprintf("/user/memberships/orgs/%v", r.Org),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateMembershipForAuthenticatedUserReq) Rel(link string, resp *UpdateMembershipForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateMembershipForAuthenticatedUserReqBody is a request body for orgs/update-membership-for-authenticated-user

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
type UpdateMembershipForAuthenticatedUserReqBody struct {

	// The state that the membership should be in. Only `"active"` will be accepted.
	State *string `json:"state"`
}

/*
UpdateMembershipForAuthenticatedUserResponse is a response for UpdateMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
type UpdateMembershipForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         components.OrgMembership
}

// HTTPResponse returns the *http.Response
func (r *UpdateMembershipForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UpdateMembershipForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
UpdateWebhook performs requests for "orgs/update-webhook"

Update an organization webhook.

  PATCH /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
func UpdateWebhook(ctx context.Context, req *UpdateWebhookReq, opt ...requests.Option) (*UpdateWebhookResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UpdateWebhookReq)
	}
	resp := &UpdateWebhookResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateWebhook performs requests for "orgs/update-webhook"

Update an organization webhook.

  PATCH /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) UpdateWebhook(ctx context.Context, req *UpdateWebhookReq, opt ...requests.Option) (*UpdateWebhookResponse, error) {
	return UpdateWebhook(ctx, req, append(c, opt...)...)
}

/*
UpdateWebhookReq is request data for Client.UpdateWebhook

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UpdateWebhookReq struct {
	_url        string
	Org         string
	HookId      int64
	RequestBody UpdateWebhookReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UpdateWebhookReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		JSONRequestBody: true,
		Method:          "PATCH",
		Options:         opt,
		URLPath:         fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateWebhookReq) Rel(link string, resp *UpdateWebhookResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// UpdateWebhookReqBodyConfig is a value for UpdateWebhookReqBody's Config field
type UpdateWebhookReqBodyConfig struct {

	// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
	ContentType *string `json:"content_type,omitempty"`

	/*
	Determines whether the SSL certificate of the host for `url` will be verified
	when delivering payloads. Supported values include `0` (verification is
	performed) and `1` (verification is not performed). The default is `0`. **We
	strongly recommend not setting this to `1` as you are subject to
	man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	If provided, the `secret` will be used as the `key` to generate the HMAC hex
	digest value in the
	[`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
UpdateWebhookReqBody is a request body for orgs/update-webhook

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
type UpdateWebhookReqBody struct {

	// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
	Active *bool `json:"active,omitempty"`

	/*
	Key/value pairs to provide settings for this webhook. [These are defined
	below](https://developer.github.com/v3/orgs/hooks/#update-hook-config-params).
	*/
	Config *UpdateWebhookReqBodyConfig `json:"config,omitempty"`

	// Determines what [events](https://developer.github.com/webhooks/event-payloads) the hook is triggered for.
	Events []string `json:"events,omitempty"`
	Name   *string  `json:"name,omitempty"`
}

/*
UpdateWebhookResponse is a response for UpdateWebhook

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
type UpdateWebhookResponse struct {
	httpResponse *http.Response
	Data         components.OrgHook
}

// HTTPResponse returns the *http.Response
func (r *UpdateWebhookResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UpdateWebhookResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}
