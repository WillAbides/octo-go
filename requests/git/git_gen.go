// Code generated by octo-go; DO NOT EDIT.

package git

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
CreateBlob performs requests for "git/create-blob"

Create a blob.

  POST /repos/{owner}/{repo}/git/blobs

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
func CreateBlob(ctx context.Context, req *CreateBlobReq, opt ...requests.Option) (*CreateBlobResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateBlobReq)
	}
	resp := &CreateBlobResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateBlobResponse(r, opts.PreserveResponseBody())
}

// NewCreateBlobResponse builds a new *CreateBlobResponse from an *http.Response
func NewCreateBlobResponse(resp *http.Response, preserveBody bool) (*CreateBlobResponse, error) {
	var result CreateBlobResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateBlob performs requests for "git/create-blob"

Create a blob.

  POST /repos/{owner}/{repo}/git/blobs

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
func (c Client) CreateBlob(ctx context.Context, req *CreateBlobReq, opt ...requests.Option) (*CreateBlobResponse, error) {
	return CreateBlob(ctx, req, append(c, opt...)...)
}

/*
CreateBlobReq is request data for Client.CreateBlob

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
type CreateBlobReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateBlobReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateBlobReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateBlobReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "git/create-blob",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/blobs", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateBlobReq) Rel(link string, resp *CreateBlobResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateBlobReqBody is a request body for git/create-blob

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
type CreateBlobReqBody struct {

	// The new blob's content.
	Content *string `json:"content"`

	// The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.
	Encoding *string `json:"encoding,omitempty"`
}

/*
CreateBlobResponse is a response for CreateBlob

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
type CreateBlobResponse struct {
	httpResponse *http.Response
	Data         components.ShortBlob
}

func (r *CreateBlobResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateCommit performs requests for "git/create-commit"

Create a commit.

  POST /repos/{owner}/{repo}/git/commits

https://developer.github.com/v3/git/commits/#create-a-commit
*/
func CreateCommit(ctx context.Context, req *CreateCommitReq, opt ...requests.Option) (*CreateCommitResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateCommitReq)
	}
	resp := &CreateCommitResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateCommitResponse(r, opts.PreserveResponseBody())
}

// NewCreateCommitResponse builds a new *CreateCommitResponse from an *http.Response
func NewCreateCommitResponse(resp *http.Response, preserveBody bool) (*CreateCommitResponse, error) {
	var result CreateCommitResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateCommit performs requests for "git/create-commit"

Create a commit.

  POST /repos/{owner}/{repo}/git/commits

https://developer.github.com/v3/git/commits/#create-a-commit
*/
func (c Client) CreateCommit(ctx context.Context, req *CreateCommitReq, opt ...requests.Option) (*CreateCommitResponse, error) {
	return CreateCommit(ctx, req, append(c, opt...)...)
}

/*
CreateCommitReq is request data for Client.CreateCommit

https://developer.github.com/v3/git/commits/#create-a-commit
*/
type CreateCommitReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateCommitReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateCommitReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateCommitReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "git/create-commit",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/commits", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateCommitReq) Rel(link string, resp *CreateCommitResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateCommitReqBodyAuthor is a value for CreateCommitReqBody's Author field
type CreateCommitReqBodyAuthor struct {

	/*
	Indicates when this commit was authored (or committed). This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Date *string `json:"date,omitempty"`

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

// CreateCommitReqBodyCommitter is a value for CreateCommitReqBody's Committer field
type CreateCommitReqBodyCommitter struct {

	/*
	Indicates when this commit was authored (or committed). This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Date *string `json:"date,omitempty"`

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

/*
CreateCommitReqBody is a request body for git/create-commit

https://developer.github.com/v3/git/commits/#create-a-commit
*/
type CreateCommitReqBody struct {

	/*
	Information about the author of the commit. By default, the `author` will be the
	authenticated user and the current date. See the `author` and `committer` object
	below for details.
	*/
	Author *CreateCommitReqBodyAuthor `json:"author,omitempty"`

	/*
	Information about the person who is making the commit. By default, `committer`
	will use the information set in `author`. See the `author` and `committer`
	object below for details.
	*/
	Committer *CreateCommitReqBodyCommitter `json:"committer,omitempty"`

	// The commit message
	Message *string `json:"message"`

	/*
	The SHAs of the commits that were the parents of this commit. If omitted or
	empty, the commit will be written as a root commit. For a single parent, an
	array of one SHA should be provided; for a merge commit, an array of more than
	one should be provided.
	*/
	Parents []string `json:"parents,omitempty"`

	/*
	The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the
	commit. GitHub adds the signature to the `gpgsig` header of the created commit.
	For a commit signature to be verifiable by Git or GitHub, it must be an
	ASCII-armored detached PGP signature over the string commit as it would be
	written to the object database. To pass a `signature` parameter, you need to
	first manually create a valid PGP signature, which can be complicated. You may
	find it easier to [use the command
	line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create
	signed commits.
	*/
	Signature *string `json:"signature,omitempty"`

	// The SHA of the tree object this commit points to
	Tree *string `json:"tree"`
}

/*
CreateCommitResponse is a response for CreateCommit

https://developer.github.com/v3/git/commits/#create-a-commit
*/
type CreateCommitResponse struct {
	httpResponse *http.Response
	Data         components.GitCommit
}

func (r *CreateCommitResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateRef performs requests for "git/create-ref"

Create a reference.

  POST /repos/{owner}/{repo}/git/refs

https://developer.github.com/v3/git/refs/#create-a-reference
*/
func CreateRef(ctx context.Context, req *CreateRefReq, opt ...requests.Option) (*CreateRefResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateRefReq)
	}
	resp := &CreateRefResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateRefResponse(r, opts.PreserveResponseBody())
}

// NewCreateRefResponse builds a new *CreateRefResponse from an *http.Response
func NewCreateRefResponse(resp *http.Response, preserveBody bool) (*CreateRefResponse, error) {
	var result CreateRefResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateRef performs requests for "git/create-ref"

Create a reference.

  POST /repos/{owner}/{repo}/git/refs

https://developer.github.com/v3/git/refs/#create-a-reference
*/
func (c Client) CreateRef(ctx context.Context, req *CreateRefReq, opt ...requests.Option) (*CreateRefResponse, error) {
	return CreateRef(ctx, req, append(c, opt...)...)
}

/*
CreateRefReq is request data for Client.CreateRef

https://developer.github.com/v3/git/refs/#create-a-reference
*/
type CreateRefReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateRefReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateRefReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "git/create-ref",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/refs", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateRefReq) Rel(link string, resp *CreateRefResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateRefReqBody is a request body for git/create-ref

https://developer.github.com/v3/git/refs/#create-a-reference
*/
type CreateRefReqBody struct {
	Key *string `json:"key,omitempty"`

	/*
	The name of the fully qualified reference (ie: `refs/heads/master`). If it
	doesn't start with 'refs' and have at least two slashes, it will be rejected.
	*/
	Ref *string `json:"ref"`

	// The SHA1 value for this reference.
	Sha *string `json:"sha"`
}

/*
CreateRefResponse is a response for CreateRef

https://developer.github.com/v3/git/refs/#create-a-reference
*/
type CreateRefResponse struct {
	httpResponse *http.Response
	Data         components.GitRef
}

func (r *CreateRefResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateTag performs requests for "git/create-tag"

Create a tag object.

  POST /repos/{owner}/{repo}/git/tags

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
func CreateTag(ctx context.Context, req *CreateTagReq, opt ...requests.Option) (*CreateTagResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateTagReq)
	}
	resp := &CreateTagResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateTagResponse(r, opts.PreserveResponseBody())
}

// NewCreateTagResponse builds a new *CreateTagResponse from an *http.Response
func NewCreateTagResponse(resp *http.Response, preserveBody bool) (*CreateTagResponse, error) {
	var result CreateTagResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateTag performs requests for "git/create-tag"

Create a tag object.

  POST /repos/{owner}/{repo}/git/tags

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
func (c Client) CreateTag(ctx context.Context, req *CreateTagReq, opt ...requests.Option) (*CreateTagResponse, error) {
	return CreateTag(ctx, req, append(c, opt...)...)
}

/*
CreateTagReq is request data for Client.CreateTag

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
type CreateTagReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateTagReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateTagReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateTagReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "git/create-tag",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/tags", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateTagReq) Rel(link string, resp *CreateTagResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateTagReqBodyTagger is a value for CreateTagReqBody's Tagger field
type CreateTagReqBodyTagger struct {

	/*
	When this object was tagged. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Date *string `json:"date,omitempty"`

	// The email of the author of the tag
	Email *string `json:"email,omitempty"`

	// The name of the author of the tag
	Name *string `json:"name,omitempty"`
}

/*
CreateTagReqBody is a request body for git/create-tag

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
type CreateTagReqBody struct {

	// The tag message.
	Message *string `json:"message"`

	// The SHA of the git object this is tagging.
	Object *string `json:"object"`

	// The tag's name. This is typically a version (e.g., "v0.0.1").
	Tag *string `json:"tag"`

	// An object with information about the individual creating the tag.
	Tagger *CreateTagReqBodyTagger `json:"tagger,omitempty"`

	// The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`.
	Type *string `json:"type"`
}

/*
CreateTagResponse is a response for CreateTag

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
type CreateTagResponse struct {
	httpResponse *http.Response
	Data         components.GitTag
}

func (r *CreateTagResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateTree performs requests for "git/create-tree"

Create a tree.

  POST /repos/{owner}/{repo}/git/trees

https://developer.github.com/v3/git/trees/#create-a-tree
*/
func CreateTree(ctx context.Context, req *CreateTreeReq, opt ...requests.Option) (*CreateTreeResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateTreeReq)
	}
	resp := &CreateTreeResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateTreeResponse(r, opts.PreserveResponseBody())
}

// NewCreateTreeResponse builds a new *CreateTreeResponse from an *http.Response
func NewCreateTreeResponse(resp *http.Response, preserveBody bool) (*CreateTreeResponse, error) {
	var result CreateTreeResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateTree performs requests for "git/create-tree"

Create a tree.

  POST /repos/{owner}/{repo}/git/trees

https://developer.github.com/v3/git/trees/#create-a-tree
*/
func (c Client) CreateTree(ctx context.Context, req *CreateTreeReq, opt ...requests.Option) (*CreateTreeResponse, error) {
	return CreateTree(ctx, req, append(c, opt...)...)
}

/*
CreateTreeReq is request data for Client.CreateTree

https://developer.github.com/v3/git/trees/#create-a-tree
*/
type CreateTreeReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateTreeReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateTreeReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateTreeReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "git/create-tree",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/trees", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateTreeReq) Rel(link string, resp *CreateTreeResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateTreeReqBodyTree is a value for CreateTreeReqBody's Tree field
type CreateTreeReqBodyTree struct {

	/*
	The content you want this file to have. GitHub will write this blob out and use
	that SHA for this entry. Use either this, or `tree.sha`.

	**Note:** Use either `tree.sha` or `content` to specify the contents of the
	entry. Using both `tree.sha` and `content` will return an error.
	*/
	Content *string `json:"content,omitempty"`

	/*
	The file mode; one of `100644` for file (blob), `100755` for executable (blob),
	`040000` for subdirectory (tree), `160000` for submodule (commit), or `120000`
	for a blob that specifies the path of a symlink.
	*/
	Mode *string `json:"mode,omitempty"`

	// The file referenced in the tree.
	Path *string `json:"path,omitempty"`

	/*
	The SHA1 checksum ID of the object in the tree. Also called `tree.sha`. If the
	value is `null` then the file will be deleted.

	**Note:** Use either `tree.sha` or `content` to specify the contents of the
	entry. Using both `tree.sha` and `content` will return an error.
	*/
	Sha *string `json:"sha,omitempty"`

	// Either `blob`, `tree`, or `commit`.
	Type *string `json:"type,omitempty"`
}

/*
CreateTreeReqBody is a request body for git/create-tree

https://developer.github.com/v3/git/trees/#create-a-tree
*/
type CreateTreeReqBody struct {

	/*
	The SHA1 of the tree you want to update with new data. If you don't set this,
	the commit will be created on top of everything; however, it will only contain
	your change, the rest of your files will show up as deleted.
	*/
	BaseTree *string `json:"base_tree,omitempty"`

	// Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure.
	Tree []CreateTreeReqBodyTree `json:"tree"`
}

/*
CreateTreeResponse is a response for CreateTree

https://developer.github.com/v3/git/trees/#create-a-tree
*/
type CreateTreeResponse struct {
	httpResponse *http.Response
	Data         components.GitTree
}

func (r *CreateTreeResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteRef performs requests for "git/delete-ref"

Delete a reference.

  DELETE /repos/{owner}/{repo}/git/refs/{ref}

https://developer.github.com/v3/git/refs/#delete-a-reference
*/
func DeleteRef(ctx context.Context, req *DeleteRefReq, opt ...requests.Option) (*DeleteRefResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteRefReq)
	}
	resp := &DeleteRefResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteRefResponse(r, opts.PreserveResponseBody())
}

// NewDeleteRefResponse builds a new *DeleteRefResponse from an *http.Response
func NewDeleteRefResponse(resp *http.Response, preserveBody bool) (*DeleteRefResponse, error) {
	var result DeleteRefResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteRef performs requests for "git/delete-ref"

Delete a reference.

  DELETE /repos/{owner}/{repo}/git/refs/{ref}

https://developer.github.com/v3/git/refs/#delete-a-reference
*/
func (c Client) DeleteRef(ctx context.Context, req *DeleteRefReq, opt ...requests.Option) (*DeleteRefResponse, error) {
	return DeleteRef(ctx, req, append(c, opt...)...)
}

/*
DeleteRefReq is request data for Client.DeleteRef

https://developer.github.com/v3/git/refs/#delete-a-reference
*/
type DeleteRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string
}

// HTTPRequest builds an *http.Request
func (r *DeleteRefReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "git/delete-ref",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/git/refs/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteRefReq) Rel(link string, resp *DeleteRefResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteRefResponse is a response for DeleteRef

https://developer.github.com/v3/git/refs/#delete-a-reference
*/
type DeleteRefResponse struct {
	httpResponse *http.Response
}

func (r *DeleteRefResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetBlob performs requests for "git/get-blob"

Get a blob.

  GET /repos/{owner}/{repo}/git/blobs/{file_sha}

https://developer.github.com/v3/git/blobs/#get-a-blob
*/
func GetBlob(ctx context.Context, req *GetBlobReq, opt ...requests.Option) (*GetBlobResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetBlobReq)
	}
	resp := &GetBlobResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetBlobResponse(r, opts.PreserveResponseBody())
}

// NewGetBlobResponse builds a new *GetBlobResponse from an *http.Response
func NewGetBlobResponse(resp *http.Response, preserveBody bool) (*GetBlobResponse, error) {
	var result GetBlobResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetBlob performs requests for "git/get-blob"

Get a blob.

  GET /repos/{owner}/{repo}/git/blobs/{file_sha}

https://developer.github.com/v3/git/blobs/#get-a-blob
*/
func (c Client) GetBlob(ctx context.Context, req *GetBlobReq, opt ...requests.Option) (*GetBlobResponse, error) {
	return GetBlob(ctx, req, append(c, opt...)...)
}

/*
GetBlobReq is request data for Client.GetBlob

https://developer.github.com/v3/git/blobs/#get-a-blob
*/
type GetBlobReq struct {
	_url  string
	Owner string
	Repo  string

	// file_sha parameter
	FileSha string
}

// HTTPRequest builds an *http.Request
func (r *GetBlobReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetBlobReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "git/get-blob",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/git/blobs/%v", r.Owner, r.Repo, r.FileSha),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetBlobReq) Rel(link string, resp *GetBlobResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetBlobResponse is a response for GetBlob

https://developer.github.com/v3/git/blobs/#get-a-blob
*/
type GetBlobResponse struct {
	httpResponse *http.Response
	Data         components.Blob
}

func (r *GetBlobResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetCommit performs requests for "git/get-commit"

Get a commit.

  GET /repos/{owner}/{repo}/git/commits/{commit_sha}

https://developer.github.com/v3/git/commits/#get-a-commit
*/
func GetCommit(ctx context.Context, req *GetCommitReq, opt ...requests.Option) (*GetCommitResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCommitReq)
	}
	resp := &GetCommitResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetCommitResponse(r, opts.PreserveResponseBody())
}

// NewGetCommitResponse builds a new *GetCommitResponse from an *http.Response
func NewGetCommitResponse(resp *http.Response, preserveBody bool) (*GetCommitResponse, error) {
	var result GetCommitResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetCommit performs requests for "git/get-commit"

Get a commit.

  GET /repos/{owner}/{repo}/git/commits/{commit_sha}

https://developer.github.com/v3/git/commits/#get-a-commit
*/
func (c Client) GetCommit(ctx context.Context, req *GetCommitReq, opt ...requests.Option) (*GetCommitResponse, error) {
	return GetCommit(ctx, req, append(c, opt...)...)
}

/*
GetCommitReq is request data for Client.GetCommit

https://developer.github.com/v3/git/commits/#get-a-commit
*/
type GetCommitReq struct {
	_url  string
	Owner string
	Repo  string

	// commit_sha+ parameter
	CommitSha string
}

// HTTPRequest builds an *http.Request
func (r *GetCommitReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCommitReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "git/get-commit",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/git/commits/%v", r.Owner, r.Repo, r.CommitSha),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCommitReq) Rel(link string, resp *GetCommitResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCommitResponse is a response for GetCommit

https://developer.github.com/v3/git/commits/#get-a-commit
*/
type GetCommitResponse struct {
	httpResponse *http.Response
	Data         components.GitCommit
}

func (r *GetCommitResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetRef performs requests for "git/get-ref"

Get a reference.

  GET /repos/{owner}/{repo}/git/ref/{ref}

https://developer.github.com/v3/git/refs/#get-a-reference
*/
func GetRef(ctx context.Context, req *GetRefReq, opt ...requests.Option) (*GetRefResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetRefReq)
	}
	resp := &GetRefResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetRefResponse(r, opts.PreserveResponseBody())
}

// NewGetRefResponse builds a new *GetRefResponse from an *http.Response
func NewGetRefResponse(resp *http.Response, preserveBody bool) (*GetRefResponse, error) {
	var result GetRefResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetRef performs requests for "git/get-ref"

Get a reference.

  GET /repos/{owner}/{repo}/git/ref/{ref}

https://developer.github.com/v3/git/refs/#get-a-reference
*/
func (c Client) GetRef(ctx context.Context, req *GetRefReq, opt ...requests.Option) (*GetRefResponse, error) {
	return GetRef(ctx, req, append(c, opt...)...)
}

/*
GetRefReq is request data for Client.GetRef

https://developer.github.com/v3/git/refs/#get-a-reference
*/
type GetRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string
}

// HTTPRequest builds an *http.Request
func (r *GetRefReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "git/get-ref",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/git/ref/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetRefReq) Rel(link string, resp *GetRefResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetRefResponse is a response for GetRef

https://developer.github.com/v3/git/refs/#get-a-reference
*/
type GetRefResponse struct {
	httpResponse *http.Response
	Data         components.GitRef
}

func (r *GetRefResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetTag performs requests for "git/get-tag"

Get a tag.

  GET /repos/{owner}/{repo}/git/tags/{tag_sha}

https://developer.github.com/v3/git/tags/#get-a-tag
*/
func GetTag(ctx context.Context, req *GetTagReq, opt ...requests.Option) (*GetTagResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetTagReq)
	}
	resp := &GetTagResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetTagResponse(r, opts.PreserveResponseBody())
}

// NewGetTagResponse builds a new *GetTagResponse from an *http.Response
func NewGetTagResponse(resp *http.Response, preserveBody bool) (*GetTagResponse, error) {
	var result GetTagResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetTag performs requests for "git/get-tag"

Get a tag.

  GET /repos/{owner}/{repo}/git/tags/{tag_sha}

https://developer.github.com/v3/git/tags/#get-a-tag
*/
func (c Client) GetTag(ctx context.Context, req *GetTagReq, opt ...requests.Option) (*GetTagResponse, error) {
	return GetTag(ctx, req, append(c, opt...)...)
}

/*
GetTagReq is request data for Client.GetTag

https://developer.github.com/v3/git/tags/#get-a-tag
*/
type GetTagReq struct {
	_url  string
	Owner string
	Repo  string

	// tag_sha parameter
	TagSha string
}

// HTTPRequest builds an *http.Request
func (r *GetTagReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetTagReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "git/get-tag",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/git/tags/%v", r.Owner, r.Repo, r.TagSha),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetTagReq) Rel(link string, resp *GetTagResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetTagResponse is a response for GetTag

https://developer.github.com/v3/git/tags/#get-a-tag
*/
type GetTagResponse struct {
	httpResponse *http.Response
	Data         components.GitTag
}

func (r *GetTagResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetTree performs requests for "git/get-tree"

Get a tree.

  GET /repos/{owner}/{repo}/git/trees/{tree_sha}

https://developer.github.com/v3/git/trees/#get-a-tree
*/
func GetTree(ctx context.Context, req *GetTreeReq, opt ...requests.Option) (*GetTreeResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetTreeReq)
	}
	resp := &GetTreeResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetTreeResponse(r, opts.PreserveResponseBody())
}

// NewGetTreeResponse builds a new *GetTreeResponse from an *http.Response
func NewGetTreeResponse(resp *http.Response, preserveBody bool) (*GetTreeResponse, error) {
	var result GetTreeResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetTree performs requests for "git/get-tree"

Get a tree.

  GET /repos/{owner}/{repo}/git/trees/{tree_sha}

https://developer.github.com/v3/git/trees/#get-a-tree
*/
func (c Client) GetTree(ctx context.Context, req *GetTreeReq, opt ...requests.Option) (*GetTreeResponse, error) {
	return GetTree(ctx, req, append(c, opt...)...)
}

/*
GetTreeReq is request data for Client.GetTree

https://developer.github.com/v3/git/trees/#get-a-tree
*/
type GetTreeReq struct {
	_url  string
	Owner string
	Repo  string

	// tree_sha parameter
	TreeSha string

	/*
	Setting this parameter to any value returns the objects or subtrees referenced
	by the tree specified in `:tree_sha`. For example, setting `recursive` to any of
	the following will enable returning objects or subtrees: `0`, `1`, `"true"`, and
	`"false"`. Omit this parameter to prevent recursively returning objects or
	subtrees.
	*/
	Recursive *string
}

// HTTPRequest builds an *http.Request
func (r *GetTreeReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetTreeReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Recursive != nil {
		query.Set("recursive", *r.Recursive)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "git/get-tree",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/git/trees/%v", r.Owner, r.Repo, r.TreeSha),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetTreeReq) Rel(link string, resp *GetTreeResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetTreeResponse is a response for GetTree

https://developer.github.com/v3/git/trees/#get-a-tree
*/
type GetTreeResponse struct {
	httpResponse *http.Response
	Data         components.GitTree
}

func (r *GetTreeResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListMatchingRefs performs requests for "git/list-matching-refs"

List matching references.

  GET /repos/{owner}/{repo}/git/matching-refs/{ref}

https://developer.github.com/v3/git/refs/#list-matching-references
*/
func ListMatchingRefs(ctx context.Context, req *ListMatchingRefsReq, opt ...requests.Option) (*ListMatchingRefsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListMatchingRefsReq)
	}
	resp := &ListMatchingRefsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListMatchingRefsResponse(r, opts.PreserveResponseBody())
}

// NewListMatchingRefsResponse builds a new *ListMatchingRefsResponse from an *http.Response
func NewListMatchingRefsResponse(resp *http.Response, preserveBody bool) (*ListMatchingRefsResponse, error) {
	var result ListMatchingRefsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListMatchingRefs performs requests for "git/list-matching-refs"

List matching references.

  GET /repos/{owner}/{repo}/git/matching-refs/{ref}

https://developer.github.com/v3/git/refs/#list-matching-references
*/
func (c Client) ListMatchingRefs(ctx context.Context, req *ListMatchingRefsReq, opt ...requests.Option) (*ListMatchingRefsResponse, error) {
	return ListMatchingRefs(ctx, req, append(c, opt...)...)
}

/*
ListMatchingRefsReq is request data for Client.ListMatchingRefs

https://developer.github.com/v3/git/refs/#list-matching-references
*/
type ListMatchingRefsReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListMatchingRefsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListMatchingRefsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "git/list-matching-refs",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/git/matching-refs/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListMatchingRefsReq) Rel(link string, resp *ListMatchingRefsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListMatchingRefsResponse is a response for ListMatchingRefs

https://developer.github.com/v3/git/refs/#list-matching-references
*/
type ListMatchingRefsResponse struct {
	httpResponse *http.Response
	Data         []components.GitRef
}

func (r *ListMatchingRefsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateRef performs requests for "git/update-ref"

Update a reference.

  PATCH /repos/{owner}/{repo}/git/refs/{ref}

https://developer.github.com/v3/git/refs/#update-a-reference
*/
func UpdateRef(ctx context.Context, req *UpdateRefReq, opt ...requests.Option) (*UpdateRefResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateRefReq)
	}
	resp := &UpdateRefResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateRefResponse(r, opts.PreserveResponseBody())
}

// NewUpdateRefResponse builds a new *UpdateRefResponse from an *http.Response
func NewUpdateRefResponse(resp *http.Response, preserveBody bool) (*UpdateRefResponse, error) {
	var result UpdateRefResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateRef performs requests for "git/update-ref"

Update a reference.

  PATCH /repos/{owner}/{repo}/git/refs/{ref}

https://developer.github.com/v3/git/refs/#update-a-reference
*/
func (c Client) UpdateRef(ctx context.Context, req *UpdateRefReq, opt ...requests.Option) (*UpdateRefResponse, error) {
	return UpdateRef(ctx, req, append(c, opt...)...)
}

/*
UpdateRefReq is request data for Client.UpdateRef

https://developer.github.com/v3/git/refs/#update-a-reference
*/
type UpdateRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref         string
	RequestBody UpdateRefReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateRefReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "git/update-ref",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/refs/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateRefReq) Rel(link string, resp *UpdateRefResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateRefReqBody is a request body for git/update-ref

https://developer.github.com/v3/git/refs/#update-a-reference
*/
type UpdateRefReqBody struct {

	/*
	Indicates whether to force the update or to make sure the update is a
	fast-forward update. Leaving this out or setting it to `false` will make sure
	you're not overwriting work.
	*/
	Force *bool `json:"force,omitempty"`

	// The SHA1 value to set this reference to
	Sha *string `json:"sha"`
}

/*
UpdateRefResponse is a response for UpdateRef

https://developer.github.com/v3/git/refs/#update-a-reference
*/
type UpdateRefResponse struct {
	httpResponse *http.Response
	Data         components.GitRef
}

func (r *UpdateRefResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}
