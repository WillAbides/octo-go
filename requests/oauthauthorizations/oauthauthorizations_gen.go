// Code generated by octo-go; DO NOT EDIT.

package oauthauthorizations

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []options.Option

// NewClient returns a new Client
func NewClient(opt ...options.Option) Client {
	return opt
}

// Apply implements options.Option
func (c Client) Apply(opts *options.Options) error {
	for _, o := range c {
		err := o.Apply(opts)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
CreateAuthorization performs requests for "oauth-authorizations/create-authorization"

Create a new authorization.

  POST /authorizations

https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization
*/
func CreateAuthorization(ctx context.Context, req *CreateAuthorizationReq, opt ...options.Option) (*CreateAuthorizationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateAuthorizationReq)
	}
	resp := &CreateAuthorizationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateAuthorization performs requests for "oauth-authorizations/create-authorization"

Create a new authorization.

  POST /authorizations

https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization
*/
func (c Client) CreateAuthorization(ctx context.Context, req *CreateAuthorizationReq, opt ...options.Option) (*CreateAuthorizationResponse, error) {
	return CreateAuthorization(ctx, req, append(c, opt...)...)
}

/*
CreateAuthorizationReq is request data for Client.CreateAuthorization

https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization
*/
type CreateAuthorizationReq struct {
	_url        string
	RequestBody CreateAuthorizationReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateAuthorizationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "oauth-authorizations/create-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateAuthorizationReq) Rel(link string, resp *CreateAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateAuthorizationReqBody is a request body for oauth-authorizations/create-authorization

https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization
*/
type CreateAuthorizationReqBody struct {

	// The OAuth app client key for which to create the token.
	ClientId *string `json:"client_id,omitempty"`

	// The OAuth app client secret for which to create the token.
	ClientSecret *string `json:"client_secret,omitempty"`

	// A unique string to distinguish an authorization from others created for the same client ID and user.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// A note to remind you what the OAuth token is for.
	Note *string `json:"note,omitempty"`

	// A URL to remind you what app the OAuth token is for.
	NoteUrl *string `json:"note_url,omitempty"`

	// A list of scopes that this authorization is in.
	Scopes []string `json:"scopes,omitempty"`
}

/*
CreateAuthorizationResponse is a response for CreateAuthorization

https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization
*/
type CreateAuthorizationResponse struct {
	common.Response
	request *CreateAuthorizationReq
	Data    components.Authorization
}

/*
DeleteAuthorization performs requests for "oauth-authorizations/delete-authorization"

Delete an authorization.

  DELETE /authorizations/{authorization_id}

https://developer.github.com/v3/oauth_authorizations/#delete-an-authorization
*/
func DeleteAuthorization(ctx context.Context, req *DeleteAuthorizationReq, opt ...options.Option) (*DeleteAuthorizationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteAuthorizationReq)
	}
	resp := &DeleteAuthorizationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteAuthorization performs requests for "oauth-authorizations/delete-authorization"

Delete an authorization.

  DELETE /authorizations/{authorization_id}

https://developer.github.com/v3/oauth_authorizations/#delete-an-authorization
*/
func (c Client) DeleteAuthorization(ctx context.Context, req *DeleteAuthorizationReq, opt ...options.Option) (*DeleteAuthorizationResponse, error) {
	return DeleteAuthorization(ctx, req, append(c, opt...)...)
}

/*
DeleteAuthorizationReq is request data for Client.DeleteAuthorization

https://developer.github.com/v3/oauth_authorizations/#delete-an-authorization
*/
type DeleteAuthorizationReq struct {
	_url string

	// authorization_id parameter
	AuthorizationId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteAuthorizationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "oauth-authorizations/delete-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations/%v", r.AuthorizationId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteAuthorizationReq) Rel(link string, resp *DeleteAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteAuthorizationResponse is a response for DeleteAuthorization

https://developer.github.com/v3/oauth_authorizations/#delete-an-authorization
*/
type DeleteAuthorizationResponse struct {
	common.Response
	request *DeleteAuthorizationReq
}

/*
DeleteGrant performs requests for "oauth-authorizations/delete-grant"

Delete a grant.

  DELETE /applications/grants/{grant_id}

https://developer.github.com/v3/oauth_authorizations/#delete-a-grant
*/
func DeleteGrant(ctx context.Context, req *DeleteGrantReq, opt ...options.Option) (*DeleteGrantResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteGrantReq)
	}
	resp := &DeleteGrantResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteGrant performs requests for "oauth-authorizations/delete-grant"

Delete a grant.

  DELETE /applications/grants/{grant_id}

https://developer.github.com/v3/oauth_authorizations/#delete-a-grant
*/
func (c Client) DeleteGrant(ctx context.Context, req *DeleteGrantReq, opt ...options.Option) (*DeleteGrantResponse, error) {
	return DeleteGrant(ctx, req, append(c, opt...)...)
}

/*
DeleteGrantReq is request data for Client.DeleteGrant

https://developer.github.com/v3/oauth_authorizations/#delete-a-grant
*/
type DeleteGrantReq struct {
	_url string

	// grant_id parameter
	GrantId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteGrantReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteGrantReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "oauth-authorizations/delete-grant",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/grants/%v", r.GrantId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteGrantReq) Rel(link string, resp *DeleteGrantResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteGrantResponse is a response for DeleteGrant

https://developer.github.com/v3/oauth_authorizations/#delete-a-grant
*/
type DeleteGrantResponse struct {
	common.Response
	request *DeleteGrantReq
}

/*
GetAuthorization performs requests for "oauth-authorizations/get-authorization"

Get a single authorization.

  GET /authorizations/{authorization_id}

https://developer.github.com/v3/oauth_authorizations/#get-a-single-authorization
*/
func GetAuthorization(ctx context.Context, req *GetAuthorizationReq, opt ...options.Option) (*GetAuthorizationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetAuthorizationReq)
	}
	resp := &GetAuthorizationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetAuthorization performs requests for "oauth-authorizations/get-authorization"

Get a single authorization.

  GET /authorizations/{authorization_id}

https://developer.github.com/v3/oauth_authorizations/#get-a-single-authorization
*/
func (c Client) GetAuthorization(ctx context.Context, req *GetAuthorizationReq, opt ...options.Option) (*GetAuthorizationResponse, error) {
	return GetAuthorization(ctx, req, append(c, opt...)...)
}

/*
GetAuthorizationReq is request data for Client.GetAuthorization

https://developer.github.com/v3/oauth_authorizations/#get-a-single-authorization
*/
type GetAuthorizationReq struct {
	_url string

	// authorization_id parameter
	AuthorizationId int64
}

// HTTPRequest builds an *http.Request
func (r *GetAuthorizationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "oauth-authorizations/get-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations/%v", r.AuthorizationId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetAuthorizationReq) Rel(link string, resp *GetAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetAuthorizationResponse is a response for GetAuthorization

https://developer.github.com/v3/oauth_authorizations/#get-a-single-authorization
*/
type GetAuthorizationResponse struct {
	common.Response
	request *GetAuthorizationReq
	Data    components.Authorization
}

/*
GetGrant performs requests for "oauth-authorizations/get-grant"

Get a single grant.

  GET /applications/grants/{grant_id}

https://developer.github.com/v3/oauth_authorizations/#get-a-single-grant
*/
func GetGrant(ctx context.Context, req *GetGrantReq, opt ...options.Option) (*GetGrantResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetGrantReq)
	}
	resp := &GetGrantResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ApplicationGrant{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetGrant performs requests for "oauth-authorizations/get-grant"

Get a single grant.

  GET /applications/grants/{grant_id}

https://developer.github.com/v3/oauth_authorizations/#get-a-single-grant
*/
func (c Client) GetGrant(ctx context.Context, req *GetGrantReq, opt ...options.Option) (*GetGrantResponse, error) {
	return GetGrant(ctx, req, append(c, opt...)...)
}

/*
GetGrantReq is request data for Client.GetGrant

https://developer.github.com/v3/oauth_authorizations/#get-a-single-grant
*/
type GetGrantReq struct {
	_url string

	// grant_id parameter
	GrantId int64
}

// HTTPRequest builds an *http.Request
func (r *GetGrantReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetGrantReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "oauth-authorizations/get-grant",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/grants/%v", r.GrantId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetGrantReq) Rel(link string, resp *GetGrantResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetGrantResponse is a response for GetGrant

https://developer.github.com/v3/oauth_authorizations/#get-a-single-grant
*/
type GetGrantResponse struct {
	common.Response
	request *GetGrantReq
	Data    components.ApplicationGrant
}

/*
GetOrCreateAuthorizationForApp performs requests for "oauth-authorizations/get-or-create-authorization-for-app"

Get-or-create an authorization for a specific app.

  PUT /authorizations/clients/{client_id}

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app
*/
func GetOrCreateAuthorizationForApp(ctx context.Context, req *GetOrCreateAuthorizationForAppReq, opt ...options.Option) (*GetOrCreateAuthorizationForAppResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetOrCreateAuthorizationForAppReq)
	}
	resp := &GetOrCreateAuthorizationForAppResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetOrCreateAuthorizationForApp performs requests for "oauth-authorizations/get-or-create-authorization-for-app"

Get-or-create an authorization for a specific app.

  PUT /authorizations/clients/{client_id}

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app
*/
func (c Client) GetOrCreateAuthorizationForApp(ctx context.Context, req *GetOrCreateAuthorizationForAppReq, opt ...options.Option) (*GetOrCreateAuthorizationForAppResponse, error) {
	return GetOrCreateAuthorizationForApp(ctx, req, append(c, opt...)...)
}

/*
GetOrCreateAuthorizationForAppReq is request data for Client.GetOrCreateAuthorizationForApp

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app
*/
type GetOrCreateAuthorizationForAppReq struct {
	_url        string
	ClientId    string
	RequestBody GetOrCreateAuthorizationForAppReqBody
}

// HTTPRequest builds an *http.Request
func (r *GetOrCreateAuthorizationForAppReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetOrCreateAuthorizationForAppReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200, 201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "oauth-authorizations/get-or-create-authorization-for-app",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations/clients/%v", r.ClientId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetOrCreateAuthorizationForAppReq) Rel(link string, resp *GetOrCreateAuthorizationForAppResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetOrCreateAuthorizationForAppReqBody is a request body for oauth-authorizations/get-or-create-authorization-for-app

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app
*/
type GetOrCreateAuthorizationForAppReqBody struct {

	// The OAuth app client secret for which to create the token.
	ClientSecret *string `json:"client_secret"`

	// A unique string to distinguish an authorization from others created for the same client ID and user.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// A note to remind you what the OAuth token is for.
	Note *string `json:"note,omitempty"`

	// A URL to remind you what app the OAuth token is for.
	NoteUrl *string `json:"note_url,omitempty"`

	// A list of scopes that this authorization is in.
	Scopes []string `json:"scopes,omitempty"`
}

/*
GetOrCreateAuthorizationForAppResponse is a response for GetOrCreateAuthorizationForApp

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app
*/
type GetOrCreateAuthorizationForAppResponse struct {
	common.Response
	request *GetOrCreateAuthorizationForAppReq
	Data    components.Authorization
}

/*
GetOrCreateAuthorizationForAppAndFingerprint performs requests for "oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint"

Get-or-create an authorization for a specific app and fingerprint.

  PUT /authorizations/clients/{client_id}/{fingerprint}

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app-and-fingerprint
*/
func GetOrCreateAuthorizationForAppAndFingerprint(ctx context.Context, req *GetOrCreateAuthorizationForAppAndFingerprintReq, opt ...options.Option) (*GetOrCreateAuthorizationForAppAndFingerprintResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetOrCreateAuthorizationForAppAndFingerprintReq)
	}
	resp := &GetOrCreateAuthorizationForAppAndFingerprintResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetOrCreateAuthorizationForAppAndFingerprint performs requests for "oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint"

Get-or-create an authorization for a specific app and fingerprint.

  PUT /authorizations/clients/{client_id}/{fingerprint}

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app-and-fingerprint
*/
func (c Client) GetOrCreateAuthorizationForAppAndFingerprint(ctx context.Context, req *GetOrCreateAuthorizationForAppAndFingerprintReq, opt ...options.Option) (*GetOrCreateAuthorizationForAppAndFingerprintResponse, error) {
	return GetOrCreateAuthorizationForAppAndFingerprint(ctx, req, append(c, opt...)...)
}

/*
GetOrCreateAuthorizationForAppAndFingerprintReq is request data for Client.GetOrCreateAuthorizationForAppAndFingerprint

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app-and-fingerprint
*/
type GetOrCreateAuthorizationForAppAndFingerprintReq struct {
	_url     string
	ClientId string

	// fingerprint parameter
	Fingerprint string
	RequestBody GetOrCreateAuthorizationForAppAndFingerprintReqBody
}

// HTTPRequest builds an *http.Request
func (r *GetOrCreateAuthorizationForAppAndFingerprintReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetOrCreateAuthorizationForAppAndFingerprintReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200, 201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations/clients/%v/%v", r.ClientId, r.Fingerprint),
		URLQuery:         query,
		ValidStatuses:    []int{200, 201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetOrCreateAuthorizationForAppAndFingerprintReq) Rel(link string, resp *GetOrCreateAuthorizationForAppAndFingerprintResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetOrCreateAuthorizationForAppAndFingerprintReqBody is a request body for oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app-and-fingerprint
*/
type GetOrCreateAuthorizationForAppAndFingerprintReqBody struct {

	// The OAuth app client secret for which to create the token.
	ClientSecret *string `json:"client_secret"`

	// A note to remind you what the OAuth token is for.
	Note *string `json:"note,omitempty"`

	// A URL to remind you what app the OAuth token is for.
	NoteUrl *string `json:"note_url,omitempty"`

	// A list of scopes that this authorization is in.
	Scopes []string `json:"scopes,omitempty"`
}

/*
GetOrCreateAuthorizationForAppAndFingerprintResponse is a response for GetOrCreateAuthorizationForAppAndFingerprint

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app-and-fingerprint
*/
type GetOrCreateAuthorizationForAppAndFingerprintResponse struct {
	common.Response
	request *GetOrCreateAuthorizationForAppAndFingerprintReq
	Data    components.Authorization
}

/*
ListAuthorizations performs requests for "oauth-authorizations/list-authorizations"

List your authorizations.

  GET /authorizations

https://developer.github.com/v3/oauth_authorizations/#list-your-authorizations
*/
func ListAuthorizations(ctx context.Context, req *ListAuthorizationsReq, opt ...options.Option) (*ListAuthorizationsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListAuthorizationsReq)
	}
	resp := &ListAuthorizationsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Authorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListAuthorizations performs requests for "oauth-authorizations/list-authorizations"

List your authorizations.

  GET /authorizations

https://developer.github.com/v3/oauth_authorizations/#list-your-authorizations
*/
func (c Client) ListAuthorizations(ctx context.Context, req *ListAuthorizationsReq, opt ...options.Option) (*ListAuthorizationsResponse, error) {
	return ListAuthorizations(ctx, req, append(c, opt...)...)
}

/*
ListAuthorizationsReq is request data for Client.ListAuthorizations

https://developer.github.com/v3/oauth_authorizations/#list-your-authorizations
*/
type ListAuthorizationsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListAuthorizationsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListAuthorizationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "oauth-authorizations/list-authorizations",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListAuthorizationsReq) Rel(link string, resp *ListAuthorizationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListAuthorizationsResponse is a response for ListAuthorizations

https://developer.github.com/v3/oauth_authorizations/#list-your-authorizations
*/
type ListAuthorizationsResponse struct {
	common.Response
	request *ListAuthorizationsReq
	Data    []components.Authorization
}

/*
ListGrants performs requests for "oauth-authorizations/list-grants"

List your grants.

  GET /applications/grants

https://developer.github.com/v3/oauth_authorizations/#list-your-grants
*/
func ListGrants(ctx context.Context, req *ListGrantsReq, opt ...options.Option) (*ListGrantsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListGrantsReq)
	}
	resp := &ListGrantsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ApplicationGrant{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListGrants performs requests for "oauth-authorizations/list-grants"

List your grants.

  GET /applications/grants

https://developer.github.com/v3/oauth_authorizations/#list-your-grants
*/
func (c Client) ListGrants(ctx context.Context, req *ListGrantsReq, opt ...options.Option) (*ListGrantsResponse, error) {
	return ListGrants(ctx, req, append(c, opt...)...)
}

/*
ListGrantsReq is request data for Client.ListGrants

https://developer.github.com/v3/oauth_authorizations/#list-your-grants
*/
type ListGrantsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListGrantsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListGrantsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "oauth-authorizations/list-grants",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/grants"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListGrantsReq) Rel(link string, resp *ListGrantsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListGrantsResponse is a response for ListGrants

https://developer.github.com/v3/oauth_authorizations/#list-your-grants
*/
type ListGrantsResponse struct {
	common.Response
	request *ListGrantsReq
	Data    []components.ApplicationGrant
}

/*
UpdateAuthorization performs requests for "oauth-authorizations/update-authorization"

Update an existing authorization.

  PATCH /authorizations/{authorization_id}

https://developer.github.com/v3/oauth_authorizations/#update-an-existing-authorization
*/
func UpdateAuthorization(ctx context.Context, req *UpdateAuthorizationReq, opt ...options.Option) (*UpdateAuthorizationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateAuthorizationReq)
	}
	resp := &UpdateAuthorizationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateAuthorization performs requests for "oauth-authorizations/update-authorization"

Update an existing authorization.

  PATCH /authorizations/{authorization_id}

https://developer.github.com/v3/oauth_authorizations/#update-an-existing-authorization
*/
func (c Client) UpdateAuthorization(ctx context.Context, req *UpdateAuthorizationReq, opt ...options.Option) (*UpdateAuthorizationResponse, error) {
	return UpdateAuthorization(ctx, req, append(c, opt...)...)
}

/*
UpdateAuthorizationReq is request data for Client.UpdateAuthorization

https://developer.github.com/v3/oauth_authorizations/#update-an-existing-authorization
*/
type UpdateAuthorizationReq struct {
	_url string

	// authorization_id parameter
	AuthorizationId int64
	RequestBody     UpdateAuthorizationReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateAuthorizationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "oauth-authorizations/update-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations/%v", r.AuthorizationId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateAuthorizationReq) Rel(link string, resp *UpdateAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateAuthorizationReqBody is a request body for oauth-authorizations/update-authorization

https://developer.github.com/v3/oauth_authorizations/#update-an-existing-authorization
*/
type UpdateAuthorizationReqBody struct {

	// A list of scopes to add to this authorization.
	AddScopes []string `json:"add_scopes,omitempty"`

	// A unique string to distinguish an authorization from others created for the same client ID and user.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// A note to remind you what the OAuth token is for.
	Note *string `json:"note,omitempty"`

	// A URL to remind you what app the OAuth token is for.
	NoteUrl *string `json:"note_url,omitempty"`

	// A list of scopes to remove from this authorization.
	RemoveScopes []string `json:"remove_scopes,omitempty"`

	// A list of scopes that this authorization is in.
	Scopes []string `json:"scopes,omitempty"`
}

/*
UpdateAuthorizationResponse is a response for UpdateAuthorization

https://developer.github.com/v3/oauth_authorizations/#update-an-existing-authorization
*/
type UpdateAuthorizationResponse struct {
	common.Response
	request *UpdateAuthorizationReq
	Data    components.Authorization
}
