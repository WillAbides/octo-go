// Code generated by octo-go; DO NOT EDIT.

package reactions

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
CreateForCommitComment performs requests for "reactions/create-for-commit-comment"

Create reaction for a commit comment.

  POST /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
func CreateForCommitComment(ctx context.Context, req *CreateForCommitCommentReq, opt ...requests.Option) (*CreateForCommitCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateForCommitCommentReq)
	}
	resp := &CreateForCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateForCommitComment performs requests for "reactions/create-for-commit-comment"

Create reaction for a commit comment.

  POST /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
func (c Client) CreateForCommitComment(ctx context.Context, req *CreateForCommitCommentReq, opt ...requests.Option) (*CreateForCommitCommentResponse, error) {
	return CreateForCommitComment(ctx, req, append(c, opt...)...)
}

/*
CreateForCommitCommentReq is request data for Client.CreateForCommitComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
type CreateForCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody CreateForCommitCommentReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateForCommitCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateForCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		DataStatuses:       []int{200, 201},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-commit-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/comments/%v/reactions", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateForCommitCommentReq) Rel(link string, resp *CreateForCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateForCommitCommentReqBody is a request body for reactions/create-for-commit-comment

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
type CreateForCommitCommentReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the commit comment.
	Content *string `json:"content"`
}

/*
CreateForCommitCommentResponse is a response for CreateForCommitComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment
*/
type CreateForCommitCommentResponse struct {
	requests.Response
	request *CreateForCommitCommentReq
	Data    components.Reaction
}

/*
CreateForIssue performs requests for "reactions/create-for-issue"

Create reaction for an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
func CreateForIssue(ctx context.Context, req *CreateForIssueReq, opt ...requests.Option) (*CreateForIssueResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateForIssueReq)
	}
	resp := &CreateForIssueResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateForIssue performs requests for "reactions/create-for-issue"

Create reaction for an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
func (c Client) CreateForIssue(ctx context.Context, req *CreateForIssueReq, opt ...requests.Option) (*CreateForIssueResponse, error) {
	return CreateForIssue(ctx, req, append(c, opt...)...)
}

/*
CreateForIssueReq is request data for Client.CreateForIssue

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
type CreateForIssueReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody CreateForIssueReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateForIssueReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateForIssueReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		DataStatuses:       []int{201},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-issue",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/reactions", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateForIssueReq) Rel(link string, resp *CreateForIssueResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateForIssueReqBody is a request body for reactions/create-for-issue

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
type CreateForIssueReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the issue.
	Content *string `json:"content"`
}

/*
CreateForIssueResponse is a response for CreateForIssue

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue
*/
type CreateForIssueResponse struct {
	requests.Response
	request *CreateForIssueReq
	Data    components.Reaction
}

/*
CreateForIssueComment performs requests for "reactions/create-for-issue-comment"

Create reaction for an issue comment.

  POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
func CreateForIssueComment(ctx context.Context, req *CreateForIssueCommentReq, opt ...requests.Option) (*CreateForIssueCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateForIssueCommentReq)
	}
	resp := &CreateForIssueCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateForIssueComment performs requests for "reactions/create-for-issue-comment"

Create reaction for an issue comment.

  POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
func (c Client) CreateForIssueComment(ctx context.Context, req *CreateForIssueCommentReq, opt ...requests.Option) (*CreateForIssueCommentResponse, error) {
	return CreateForIssueComment(ctx, req, append(c, opt...)...)
}

/*
CreateForIssueCommentReq is request data for Client.CreateForIssueComment

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
type CreateForIssueCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody CreateForIssueCommentReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateForIssueCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateForIssueCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		DataStatuses:       []int{200, 201},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-issue-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/comments/%v/reactions", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateForIssueCommentReq) Rel(link string, resp *CreateForIssueCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateForIssueCommentReqBody is a request body for reactions/create-for-issue-comment

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
type CreateForIssueCommentReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the issue comment.
	Content *string `json:"content"`
}

/*
CreateForIssueCommentResponse is a response for CreateForIssueComment

https://developer.github.com/v3/reactions/#create-reaction-for-an-issue-comment
*/
type CreateForIssueCommentResponse struct {
	requests.Response
	request *CreateForIssueCommentReq
	Data    components.Reaction
}

/*
CreateForPullRequestReviewComment performs requests for "reactions/create-for-pull-request-review-comment"

Create reaction for a pull request review comment.

  POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
func CreateForPullRequestReviewComment(ctx context.Context, req *CreateForPullRequestReviewCommentReq, opt ...requests.Option) (*CreateForPullRequestReviewCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateForPullRequestReviewCommentReq)
	}
	resp := &CreateForPullRequestReviewCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateForPullRequestReviewComment performs requests for "reactions/create-for-pull-request-review-comment"

Create reaction for a pull request review comment.

  POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
func (c Client) CreateForPullRequestReviewComment(ctx context.Context, req *CreateForPullRequestReviewCommentReq, opt ...requests.Option) (*CreateForPullRequestReviewCommentResponse, error) {
	return CreateForPullRequestReviewComment(ctx, req, append(c, opt...)...)
}

/*
CreateForPullRequestReviewCommentReq is request data for Client.CreateForPullRequestReviewComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
type CreateForPullRequestReviewCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody CreateForPullRequestReviewCommentReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateForPullRequestReviewCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateForPullRequestReviewCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		DataStatuses:       []int{200, 201},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-pull-request-review-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/comments/%v/reactions", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateForPullRequestReviewCommentReq) Rel(link string, resp *CreateForPullRequestReviewCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateForPullRequestReviewCommentReqBody is a request body for reactions/create-for-pull-request-review-comment

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
type CreateForPullRequestReviewCommentReqBody struct {

	/*
	The [reaction type](https://developer.github.com/v3/reactions/#reaction-types)
	to add to the pull request review comment.
	*/
	Content *string `json:"content"`
}

/*
CreateForPullRequestReviewCommentResponse is a response for CreateForPullRequestReviewComment

https://developer.github.com/v3/reactions/#create-reaction-for-a-pull-request-review-comment
*/
type CreateForPullRequestReviewCommentResponse struct {
	requests.Response
	request *CreateForPullRequestReviewCommentReq
	Data    components.Reaction
}

/*
CreateForTeamDiscussionCommentInOrg performs requests for "reactions/create-for-team-discussion-comment-in-org"

Create reaction for a team discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
func CreateForTeamDiscussionCommentInOrg(ctx context.Context, req *CreateForTeamDiscussionCommentInOrgReq, opt ...requests.Option) (*CreateForTeamDiscussionCommentInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateForTeamDiscussionCommentInOrgReq)
	}
	resp := &CreateForTeamDiscussionCommentInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateForTeamDiscussionCommentInOrg performs requests for "reactions/create-for-team-discussion-comment-in-org"

Create reaction for a team discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
func (c Client) CreateForTeamDiscussionCommentInOrg(ctx context.Context, req *CreateForTeamDiscussionCommentInOrgReq, opt ...requests.Option) (*CreateForTeamDiscussionCommentInOrgResponse, error) {
	return CreateForTeamDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
CreateForTeamDiscussionCommentInOrgReq is request data for Client.CreateForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
type CreateForTeamDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      CreateForTeamDiscussionCommentInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateForTeamDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateForTeamDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		DataStatuses:       []int{201},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-team-discussion-comment-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateForTeamDiscussionCommentInOrgReq) Rel(link string, resp *CreateForTeamDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateForTeamDiscussionCommentInOrgReqBody is a request body for reactions/create-for-team-discussion-comment-in-org

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
type CreateForTeamDiscussionCommentInOrgReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the team discussion comment.
	Content *string `json:"content"`
}

/*
CreateForTeamDiscussionCommentInOrgResponse is a response for CreateForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment
*/
type CreateForTeamDiscussionCommentInOrgResponse struct {
	requests.Response
	request *CreateForTeamDiscussionCommentInOrgReq
	Data    components.Reaction
}

/*
CreateForTeamDiscussionCommentLegacy performs requests for "reactions/create-for-team-discussion-comment-legacy"

Create reaction for a team discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
func CreateForTeamDiscussionCommentLegacy(ctx context.Context, req *CreateForTeamDiscussionCommentLegacyReq, opt ...requests.Option) (*CreateForTeamDiscussionCommentLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateForTeamDiscussionCommentLegacyReq)
	}
	resp := &CreateForTeamDiscussionCommentLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateForTeamDiscussionCommentLegacy performs requests for "reactions/create-for-team-discussion-comment-legacy"

Create reaction for a team discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
func (c Client) CreateForTeamDiscussionCommentLegacy(ctx context.Context, req *CreateForTeamDiscussionCommentLegacyReq, opt ...requests.Option) (*CreateForTeamDiscussionCommentLegacyResponse, error) {
	return CreateForTeamDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
CreateForTeamDiscussionCommentLegacyReq is request data for Client.CreateForTeamDiscussionCommentLegacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
type CreateForTeamDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      CreateForTeamDiscussionCommentLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateForTeamDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateForTeamDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		DataStatuses:       []int{201},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-team-discussion-comment-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments/%v/reactions", r.TeamId, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateForTeamDiscussionCommentLegacyReq) Rel(link string, resp *CreateForTeamDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateForTeamDiscussionCommentLegacyReqBody is a request body for reactions/create-for-team-discussion-comment-legacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
type CreateForTeamDiscussionCommentLegacyReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the team discussion comment.
	Content *string `json:"content"`
}

/*
CreateForTeamDiscussionCommentLegacyResponse is a response for CreateForTeamDiscussionCommentLegacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy
*/
type CreateForTeamDiscussionCommentLegacyResponse struct {
	requests.Response
	request *CreateForTeamDiscussionCommentLegacyReq
	Data    components.Reaction
}

/*
CreateForTeamDiscussionInOrg performs requests for "reactions/create-for-team-discussion-in-org"

Create reaction for a team discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
func CreateForTeamDiscussionInOrg(ctx context.Context, req *CreateForTeamDiscussionInOrgReq, opt ...requests.Option) (*CreateForTeamDiscussionInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateForTeamDiscussionInOrgReq)
	}
	resp := &CreateForTeamDiscussionInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateForTeamDiscussionInOrg performs requests for "reactions/create-for-team-discussion-in-org"

Create reaction for a team discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
func (c Client) CreateForTeamDiscussionInOrg(ctx context.Context, req *CreateForTeamDiscussionInOrgReq, opt ...requests.Option) (*CreateForTeamDiscussionInOrgResponse, error) {
	return CreateForTeamDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
CreateForTeamDiscussionInOrgReq is request data for Client.CreateForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
type CreateForTeamDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      CreateForTeamDiscussionInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateForTeamDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateForTeamDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		DataStatuses:       []int{201},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-team-discussion-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateForTeamDiscussionInOrgReq) Rel(link string, resp *CreateForTeamDiscussionInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateForTeamDiscussionInOrgReqBody is a request body for reactions/create-for-team-discussion-in-org

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
type CreateForTeamDiscussionInOrgReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the team discussion.
	Content *string `json:"content"`
}

/*
CreateForTeamDiscussionInOrgResponse is a response for CreateForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion
*/
type CreateForTeamDiscussionInOrgResponse struct {
	requests.Response
	request *CreateForTeamDiscussionInOrgReq
	Data    components.Reaction
}

/*
CreateForTeamDiscussionLegacy performs requests for "reactions/create-for-team-discussion-legacy"

Create reaction for a team discussion (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
func CreateForTeamDiscussionLegacy(ctx context.Context, req *CreateForTeamDiscussionLegacyReq, opt ...requests.Option) (*CreateForTeamDiscussionLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateForTeamDiscussionLegacyReq)
	}
	resp := &CreateForTeamDiscussionLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateForTeamDiscussionLegacy performs requests for "reactions/create-for-team-discussion-legacy"

Create reaction for a team discussion (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
func (c Client) CreateForTeamDiscussionLegacy(ctx context.Context, req *CreateForTeamDiscussionLegacyReq, opt ...requests.Option) (*CreateForTeamDiscussionLegacyResponse, error) {
	return CreateForTeamDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
CreateForTeamDiscussionLegacyReq is request data for Client.CreateForTeamDiscussionLegacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
type CreateForTeamDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	RequestBody      CreateForTeamDiscussionLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateForTeamDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateForTeamDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		DataStatuses:       []int{201},
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "reactions/create-for-team-discussion-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{"squirrel-girl"},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/reactions", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateForTeamDiscussionLegacyReq) Rel(link string, resp *CreateForTeamDiscussionLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateForTeamDiscussionLegacyReqBody is a request body for reactions/create-for-team-discussion-legacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
type CreateForTeamDiscussionLegacyReqBody struct {

	// The [reaction type](https://developer.github.com/v3/reactions/#reaction-types) to add to the team discussion.
	Content *string `json:"content"`
}

/*
CreateForTeamDiscussionLegacyResponse is a response for CreateForTeamDiscussionLegacy

https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy
*/
type CreateForTeamDiscussionLegacyResponse struct {
	requests.Response
	request *CreateForTeamDiscussionLegacyReq
	Data    components.Reaction
}

/*
DeleteForCommitComment performs requests for "reactions/delete-for-commit-comment"

Delete a commit comment reaction.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
func DeleteForCommitComment(ctx context.Context, req *DeleteForCommitCommentReq, opt ...requests.Option) (*DeleteForCommitCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteForCommitCommentReq)
	}
	resp := &DeleteForCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteForCommitComment performs requests for "reactions/delete-for-commit-comment"

Delete a commit comment reaction.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
func (c Client) DeleteForCommitComment(ctx context.Context, req *DeleteForCommitCommentReq, opt ...requests.Option) (*DeleteForCommitCommentResponse, error) {
	return DeleteForCommitComment(ctx, req, append(c, opt...)...)
}

/*
DeleteForCommitCommentReq is request data for Client.DeleteForCommitComment

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
type DeleteForCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId  int64
	ReactionId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteForCommitCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteForCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "reactions/delete-for-commit-comment",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/repos/%v/%v/comments/%v/reactions/%v", r.Owner, r.Repo, r.CommentId, r.ReactionId),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteForCommitCommentReq) Rel(link string, resp *DeleteForCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteForCommitCommentResponse is a response for DeleteForCommitComment

https://developer.github.com/v3/reactions/#delete-a-commit-comment-reaction
*/
type DeleteForCommitCommentResponse struct {
	requests.Response
	request *DeleteForCommitCommentReq
}

/*
DeleteForIssue performs requests for "reactions/delete-for-issue"

Delete an issue reaction.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
func DeleteForIssue(ctx context.Context, req *DeleteForIssueReq, opt ...requests.Option) (*DeleteForIssueResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteForIssueReq)
	}
	resp := &DeleteForIssueResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteForIssue performs requests for "reactions/delete-for-issue"

Delete an issue reaction.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
func (c Client) DeleteForIssue(ctx context.Context, req *DeleteForIssueReq, opt ...requests.Option) (*DeleteForIssueResponse, error) {
	return DeleteForIssue(ctx, req, append(c, opt...)...)
}

/*
DeleteForIssueReq is request data for Client.DeleteForIssue

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
type DeleteForIssueReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	ReactionId  int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteForIssueReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteForIssueReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "reactions/delete-for-issue",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/repos/%v/%v/issues/%v/reactions/%v", r.Owner, r.Repo, r.IssueNumber, r.ReactionId),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteForIssueReq) Rel(link string, resp *DeleteForIssueResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteForIssueResponse is a response for DeleteForIssue

https://developer.github.com/v3/reactions/#delete-an-issue-reaction
*/
type DeleteForIssueResponse struct {
	requests.Response
	request *DeleteForIssueReq
}

/*
DeleteForIssueComment performs requests for "reactions/delete-for-issue-comment"

Delete an issue comment reaction.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
func DeleteForIssueComment(ctx context.Context, req *DeleteForIssueCommentReq, opt ...requests.Option) (*DeleteForIssueCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteForIssueCommentReq)
	}
	resp := &DeleteForIssueCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteForIssueComment performs requests for "reactions/delete-for-issue-comment"

Delete an issue comment reaction.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
func (c Client) DeleteForIssueComment(ctx context.Context, req *DeleteForIssueCommentReq, opt ...requests.Option) (*DeleteForIssueCommentResponse, error) {
	return DeleteForIssueComment(ctx, req, append(c, opt...)...)
}

/*
DeleteForIssueCommentReq is request data for Client.DeleteForIssueComment

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
type DeleteForIssueCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId  int64
	ReactionId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteForIssueCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteForIssueCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "reactions/delete-for-issue-comment",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/repos/%v/%v/issues/comments/%v/reactions/%v", r.Owner, r.Repo, r.CommentId, r.ReactionId),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteForIssueCommentReq) Rel(link string, resp *DeleteForIssueCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteForIssueCommentResponse is a response for DeleteForIssueComment

https://developer.github.com/v3/reactions/#delete-an-issue-comment-reaction
*/
type DeleteForIssueCommentResponse struct {
	requests.Response
	request *DeleteForIssueCommentReq
}

/*
DeleteForPullRequestComment performs requests for "reactions/delete-for-pull-request-comment"

Delete a pull request comment reaction.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
func DeleteForPullRequestComment(ctx context.Context, req *DeleteForPullRequestCommentReq, opt ...requests.Option) (*DeleteForPullRequestCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteForPullRequestCommentReq)
	}
	resp := &DeleteForPullRequestCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteForPullRequestComment performs requests for "reactions/delete-for-pull-request-comment"

Delete a pull request comment reaction.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
func (c Client) DeleteForPullRequestComment(ctx context.Context, req *DeleteForPullRequestCommentReq, opt ...requests.Option) (*DeleteForPullRequestCommentResponse, error) {
	return DeleteForPullRequestComment(ctx, req, append(c, opt...)...)
}

/*
DeleteForPullRequestCommentReq is request data for Client.DeleteForPullRequestComment

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
type DeleteForPullRequestCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId  int64
	ReactionId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteForPullRequestCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteForPullRequestCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "reactions/delete-for-pull-request-comment",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/repos/%v/%v/pulls/comments/%v/reactions/%v", r.Owner, r.Repo, r.CommentId, r.ReactionId),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteForPullRequestCommentReq) Rel(link string, resp *DeleteForPullRequestCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteForPullRequestCommentResponse is a response for DeleteForPullRequestComment

https://developer.github.com/v3/reactions/#delete-a-pull-request-comment-reaction
*/
type DeleteForPullRequestCommentResponse struct {
	requests.Response
	request *DeleteForPullRequestCommentReq
}

/*
DeleteForTeamDiscussion performs requests for "reactions/delete-for-team-discussion"

Delete team discussion reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
func DeleteForTeamDiscussion(ctx context.Context, req *DeleteForTeamDiscussionReq, opt ...requests.Option) (*DeleteForTeamDiscussionResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteForTeamDiscussionReq)
	}
	resp := &DeleteForTeamDiscussionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteForTeamDiscussion performs requests for "reactions/delete-for-team-discussion"

Delete team discussion reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
func (c Client) DeleteForTeamDiscussion(ctx context.Context, req *DeleteForTeamDiscussionReq, opt ...requests.Option) (*DeleteForTeamDiscussionResponse, error) {
	return DeleteForTeamDiscussion(ctx, req, append(c, opt...)...)
}

/*
DeleteForTeamDiscussionReq is request data for Client.DeleteForTeamDiscussion

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
type DeleteForTeamDiscussionReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	ReactionId       int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteForTeamDiscussionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteForTeamDiscussionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "reactions/delete-for-team-discussion",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/reactions/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.ReactionId),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteForTeamDiscussionReq) Rel(link string, resp *DeleteForTeamDiscussionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteForTeamDiscussionResponse is a response for DeleteForTeamDiscussion

https://developer.github.com/v3/reactions/#delete-team-discussion-reaction
*/
type DeleteForTeamDiscussionResponse struct {
	requests.Response
	request *DeleteForTeamDiscussionReq
}

/*
DeleteForTeamDiscussionComment performs requests for "reactions/delete-for-team-discussion-comment"

Delete team discussion comment reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
func DeleteForTeamDiscussionComment(ctx context.Context, req *DeleteForTeamDiscussionCommentReq, opt ...requests.Option) (*DeleteForTeamDiscussionCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteForTeamDiscussionCommentReq)
	}
	resp := &DeleteForTeamDiscussionCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteForTeamDiscussionComment performs requests for "reactions/delete-for-team-discussion-comment"

Delete team discussion comment reaction.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
func (c Client) DeleteForTeamDiscussionComment(ctx context.Context, req *DeleteForTeamDiscussionCommentReq, opt ...requests.Option) (*DeleteForTeamDiscussionCommentResponse, error) {
	return DeleteForTeamDiscussionComment(ctx, req, append(c, opt...)...)
}

/*
DeleteForTeamDiscussionCommentReq is request data for Client.DeleteForTeamDiscussionComment

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
type DeleteForTeamDiscussionCommentReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	ReactionId       int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteForTeamDiscussionCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteForTeamDiscussionCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "reactions/delete-for-team-discussion-comment",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v/reactions/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber, r.ReactionId),
		URLQuery:           query,
		ValidStatuses:      []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteForTeamDiscussionCommentReq) Rel(link string, resp *DeleteForTeamDiscussionCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteForTeamDiscussionCommentResponse is a response for DeleteForTeamDiscussionComment

https://developer.github.com/v3/reactions/#delete-team-discussion-comment-reaction
*/
type DeleteForTeamDiscussionCommentResponse struct {
	requests.Response
	request *DeleteForTeamDiscussionCommentReq
}

/*
DeleteLegacy performs requests for "reactions/delete-legacy"

Delete a reaction (Legacy).

  DELETE /reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-reaction-legacy
*/
func DeleteLegacy(ctx context.Context, req *DeleteLegacyReq, opt ...requests.Option) (*DeleteLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteLegacyReq)
	}
	resp := &DeleteLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteLegacy performs requests for "reactions/delete-legacy"

Delete a reaction (Legacy).

  DELETE /reactions/{reaction_id}

https://developer.github.com/v3/reactions/#delete-a-reaction-legacy
*/
func (c Client) DeleteLegacy(ctx context.Context, req *DeleteLegacyReq, opt ...requests.Option) (*DeleteLegacyResponse, error) {
	return DeleteLegacy(ctx, req, append(c, opt...)...)
}

/*
DeleteLegacyReq is request data for Client.DeleteLegacy

https://developer.github.com/v3/reactions/#delete-a-reaction-legacy
*/
type DeleteLegacyReq struct {
	_url       string
	ReactionId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "reactions/delete-legacy",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/reactions/%v", r.ReactionId),
		URLQuery:           query,
		ValidStatuses:      []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteLegacyReq) Rel(link string, resp *DeleteLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteLegacyResponse is a response for DeleteLegacy

https://developer.github.com/v3/reactions/#delete-a-reaction-legacy
*/
type DeleteLegacyResponse struct {
	requests.Response
	request *DeleteLegacyReq
}

/*
ListForCommitComment performs requests for "reactions/list-for-commit-comment"

List reactions for a commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
func ListForCommitComment(ctx context.Context, req *ListForCommitCommentReq, opt ...requests.Option) (*ListForCommitCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForCommitCommentReq)
	}
	resp := &ListForCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForCommitComment performs requests for "reactions/list-for-commit-comment"

List reactions for a commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
func (c Client) ListForCommitComment(ctx context.Context, req *ListForCommitCommentReq, opt ...requests.Option) (*ListForCommitCommentResponse, error) {
	return ListForCommitComment(ctx, req, append(c, opt...)...)
}

/*
ListForCommitCommentReq is request data for Client.ListForCommitComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
type ListForCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a commit comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForCommitCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "reactions/list-for-commit-comment",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/repos/%v/%v/comments/%v/reactions", r.Owner, r.Repo, r.CommentId),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForCommitCommentReq) Rel(link string, resp *ListForCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForCommitCommentResponse is a response for ListForCommitComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment
*/
type ListForCommitCommentResponse struct {
	requests.Response
	request *ListForCommitCommentReq
	Data    []components.Reaction
}

/*
ListForIssue performs requests for "reactions/list-for-issue"

List reactions for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
func ListForIssue(ctx context.Context, req *ListForIssueReq, opt ...requests.Option) (*ListForIssueResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForIssueReq)
	}
	resp := &ListForIssueResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForIssue performs requests for "reactions/list-for-issue"

List reactions for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
func (c Client) ListForIssue(ctx context.Context, req *ListForIssueReq, opt ...requests.Option) (*ListForIssueResponse, error) {
	return ListForIssue(ctx, req, append(c, opt...)...)
}

/*
ListForIssueReq is request data for Client.ListForIssue

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
type ListForIssueReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to an issue.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForIssueReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForIssueReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "reactions/list-for-issue",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/repos/%v/%v/issues/%v/reactions", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForIssueReq) Rel(link string, resp *ListForIssueResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForIssueResponse is a response for ListForIssue

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue
*/
type ListForIssueResponse struct {
	requests.Response
	request *ListForIssueReq
	Data    []components.Reaction
}

/*
ListForIssueComment performs requests for "reactions/list-for-issue-comment"

List reactions for an issue comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
func ListForIssueComment(ctx context.Context, req *ListForIssueCommentReq, opt ...requests.Option) (*ListForIssueCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForIssueCommentReq)
	}
	resp := &ListForIssueCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForIssueComment performs requests for "reactions/list-for-issue-comment"

List reactions for an issue comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
func (c Client) ListForIssueComment(ctx context.Context, req *ListForIssueCommentReq, opt ...requests.Option) (*ListForIssueCommentResponse, error) {
	return ListForIssueComment(ctx, req, append(c, opt...)...)
}

/*
ListForIssueCommentReq is request data for Client.ListForIssueComment

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
type ListForIssueCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to an issue comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForIssueCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForIssueCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "reactions/list-for-issue-comment",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/repos/%v/%v/issues/comments/%v/reactions", r.Owner, r.Repo, r.CommentId),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForIssueCommentReq) Rel(link string, resp *ListForIssueCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForIssueCommentResponse is a response for ListForIssueComment

https://developer.github.com/v3/reactions/#list-reactions-for-an-issue-comment
*/
type ListForIssueCommentResponse struct {
	requests.Response
	request *ListForIssueCommentReq
	Data    []components.Reaction
}

/*
ListForPullRequestReviewComment performs requests for "reactions/list-for-pull-request-review-comment"

List reactions for a pull request review comment.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
func ListForPullRequestReviewComment(ctx context.Context, req *ListForPullRequestReviewCommentReq, opt ...requests.Option) (*ListForPullRequestReviewCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForPullRequestReviewCommentReq)
	}
	resp := &ListForPullRequestReviewCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForPullRequestReviewComment performs requests for "reactions/list-for-pull-request-review-comment"

List reactions for a pull request review comment.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
func (c Client) ListForPullRequestReviewComment(ctx context.Context, req *ListForPullRequestReviewCommentReq, opt ...requests.Option) (*ListForPullRequestReviewCommentResponse, error) {
	return ListForPullRequestReviewComment(ctx, req, append(c, opt...)...)
}

/*
ListForPullRequestReviewCommentReq is request data for Client.ListForPullRequestReviewComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
type ListForPullRequestReviewCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a pull request review comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForPullRequestReviewCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForPullRequestReviewCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "reactions/list-for-pull-request-review-comment",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/repos/%v/%v/pulls/comments/%v/reactions", r.Owner, r.Repo, r.CommentId),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForPullRequestReviewCommentReq) Rel(link string, resp *ListForPullRequestReviewCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForPullRequestReviewCommentResponse is a response for ListForPullRequestReviewComment

https://developer.github.com/v3/reactions/#list-reactions-for-a-pull-request-review-comment
*/
type ListForPullRequestReviewCommentResponse struct {
	requests.Response
	request *ListForPullRequestReviewCommentReq
	Data    []components.Reaction
}

/*
ListForTeamDiscussionCommentInOrg performs requests for "reactions/list-for-team-discussion-comment-in-org"

List reactions for a team discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
func ListForTeamDiscussionCommentInOrg(ctx context.Context, req *ListForTeamDiscussionCommentInOrgReq, opt ...requests.Option) (*ListForTeamDiscussionCommentInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForTeamDiscussionCommentInOrgReq)
	}
	resp := &ListForTeamDiscussionCommentInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForTeamDiscussionCommentInOrg performs requests for "reactions/list-for-team-discussion-comment-in-org"

List reactions for a team discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
func (c Client) ListForTeamDiscussionCommentInOrg(ctx context.Context, req *ListForTeamDiscussionCommentInOrgReq, opt ...requests.Option) (*ListForTeamDiscussionCommentInOrgResponse, error) {
	return ListForTeamDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
ListForTeamDiscussionCommentInOrgReq is request data for Client.ListForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
type ListForTeamDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForTeamDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForTeamDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "reactions/list-for-team-discussion-comment-in-org",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForTeamDiscussionCommentInOrgReq) Rel(link string, resp *ListForTeamDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForTeamDiscussionCommentInOrgResponse is a response for ListForTeamDiscussionCommentInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment
*/
type ListForTeamDiscussionCommentInOrgResponse struct {
	requests.Response
	request *ListForTeamDiscussionCommentInOrgReq
	Data    []components.Reaction
}

/*
ListForTeamDiscussionCommentLegacy performs requests for "reactions/list-for-team-discussion-comment-legacy"

List reactions for a team discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment-legacy
*/
func ListForTeamDiscussionCommentLegacy(ctx context.Context, req *ListForTeamDiscussionCommentLegacyReq, opt ...requests.Option) (*ListForTeamDiscussionCommentLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForTeamDiscussionCommentLegacyReq)
	}
	resp := &ListForTeamDiscussionCommentLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForTeamDiscussionCommentLegacy performs requests for "reactions/list-for-team-discussion-comment-legacy"

List reactions for a team discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment-legacy
*/
func (c Client) ListForTeamDiscussionCommentLegacy(ctx context.Context, req *ListForTeamDiscussionCommentLegacyReq, opt ...requests.Option) (*ListForTeamDiscussionCommentLegacyResponse, error) {
	return ListForTeamDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
ListForTeamDiscussionCommentLegacyReq is request data for Client.ListForTeamDiscussionCommentLegacy

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment-legacy
*/
type ListForTeamDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion comment.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForTeamDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForTeamDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "reactions/list-for-team-discussion-comment-legacy",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/teams/%v/discussions/%v/comments/%v/reactions", r.TeamId, r.DiscussionNumber, r.CommentNumber),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForTeamDiscussionCommentLegacyReq) Rel(link string, resp *ListForTeamDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForTeamDiscussionCommentLegacyResponse is a response for ListForTeamDiscussionCommentLegacy

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment-legacy
*/
type ListForTeamDiscussionCommentLegacyResponse struct {
	requests.Response
	request *ListForTeamDiscussionCommentLegacyReq
	Data    []components.Reaction
}

/*
ListForTeamDiscussionInOrg performs requests for "reactions/list-for-team-discussion-in-org"

List reactions for a team discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
func ListForTeamDiscussionInOrg(ctx context.Context, req *ListForTeamDiscussionInOrgReq, opt ...requests.Option) (*ListForTeamDiscussionInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForTeamDiscussionInOrgReq)
	}
	resp := &ListForTeamDiscussionInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForTeamDiscussionInOrg performs requests for "reactions/list-for-team-discussion-in-org"

List reactions for a team discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
func (c Client) ListForTeamDiscussionInOrg(ctx context.Context, req *ListForTeamDiscussionInOrgReq, opt ...requests.Option) (*ListForTeamDiscussionInOrgResponse, error) {
	return ListForTeamDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
ListForTeamDiscussionInOrgReq is request data for Client.ListForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
type ListForTeamDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForTeamDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForTeamDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "reactions/list-for-team-discussion-in-org",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/reactions", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForTeamDiscussionInOrgReq) Rel(link string, resp *ListForTeamDiscussionInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForTeamDiscussionInOrgResponse is a response for ListForTeamDiscussionInOrg

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion
*/
type ListForTeamDiscussionInOrgResponse struct {
	requests.Response
	request *ListForTeamDiscussionInOrgReq
	Data    []components.Reaction
}

/*
ListForTeamDiscussionLegacy performs requests for "reactions/list-for-team-discussion-legacy"

List reactions for a team discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-legacy
*/
func ListForTeamDiscussionLegacy(ctx context.Context, req *ListForTeamDiscussionLegacyReq, opt ...requests.Option) (*ListForTeamDiscussionLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForTeamDiscussionLegacyReq)
	}
	resp := &ListForTeamDiscussionLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Reaction{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForTeamDiscussionLegacy performs requests for "reactions/list-for-team-discussion-legacy"

List reactions for a team discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/reactions

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-legacy
*/
func (c Client) ListForTeamDiscussionLegacy(ctx context.Context, req *ListForTeamDiscussionLegacyReq, opt ...requests.Option) (*ListForTeamDiscussionLegacyResponse, error) {
	return ListForTeamDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
ListForTeamDiscussionLegacyReq is request data for Client.ListForTeamDiscussionLegacy

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-legacy
*/
type ListForTeamDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64

	/*
	Returns a single [reaction
	type](https://developer.github.com/v3/reactions/#reaction-types). Omit this
	parameter to list all reactions to a team discussion.
	*/
	Content *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForTeamDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForTeamDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Content != nil {
		query.Set("content", *r.Content)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		DataStatuses:       []int{200},
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "reactions/list-for-team-discussion-legacy",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{"squirrel-girl"},
		URLPath:            fmt.Sprintf("/teams/%v/discussions/%v/reactions", r.TeamId, r.DiscussionNumber),
		URLQuery:           query,
		ValidStatuses:      []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForTeamDiscussionLegacyReq) Rel(link string, resp *ListForTeamDiscussionLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForTeamDiscussionLegacyResponse is a response for ListForTeamDiscussionLegacy

https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-legacy
*/
type ListForTeamDiscussionLegacyResponse struct {
	requests.Response
	request *ListForTeamDiscussionLegacyReq
	Data    []components.Reaction
}
