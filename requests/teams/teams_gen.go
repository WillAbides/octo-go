// Code generated by octo-go; DO NOT EDIT.

package teams

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []options.Option

// NewClient returns a new Client
func NewClient(opt ...options.Option) Client {
	return opt
}

// Apply implements options.Option
func (c Client) Apply(opts *options.Options) error {
	for _, o := range c {
		err := o.Apply(opts)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
AddMemberLegacy performs requests for "teams/add-member-legacy"

Add team member (Legacy).

  PUT /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
func AddMemberLegacy(ctx context.Context, req *AddMemberLegacyReq, opt ...options.Option) (*AddMemberLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddMemberLegacyReq)
	}
	resp := &AddMemberLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddMemberLegacy performs requests for "teams/add-member-legacy"

Add team member (Legacy).

  PUT /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
func (c Client) AddMemberLegacy(ctx context.Context, req *AddMemberLegacyReq, opt ...options.Option) (*AddMemberLegacyResponse, error) {
	return AddMemberLegacy(ctx, req, append(c, opt...)...)
}

/*
AddMemberLegacyReq is request data for Client.AddMemberLegacy

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
type AddMemberLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *AddMemberLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddMemberLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "teams/add-member-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/members/%v", r.TeamId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddMemberLegacyReq) Rel(link string, resp *AddMemberLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddMemberLegacyResponse is a response for AddMemberLegacy

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
type AddMemberLegacyResponse struct {
	common.Response
	request *AddMemberLegacyReq
}

/*
AddOrUpdateMembershipForUserInOrg performs requests for "teams/add-or-update-membership-for-user-in-org"

Add or update team membership for a user.

  PUT /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
func AddOrUpdateMembershipForUserInOrg(ctx context.Context, req *AddOrUpdateMembershipForUserInOrgReq, opt ...options.Option) (*AddOrUpdateMembershipForUserInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddOrUpdateMembershipForUserInOrgReq)
	}
	resp := &AddOrUpdateMembershipForUserInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddOrUpdateMembershipForUserInOrg performs requests for "teams/add-or-update-membership-for-user-in-org"

Add or update team membership for a user.

  PUT /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
func (c Client) AddOrUpdateMembershipForUserInOrg(ctx context.Context, req *AddOrUpdateMembershipForUserInOrgReq, opt ...options.Option) (*AddOrUpdateMembershipForUserInOrgResponse, error) {
	return AddOrUpdateMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
AddOrUpdateMembershipForUserInOrgReq is request data for Client.AddOrUpdateMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type AddOrUpdateMembershipForUserInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	Username    string
	RequestBody AddOrUpdateMembershipForUserInOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddOrUpdateMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddOrUpdateMembershipForUserInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-membership-for-user-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddOrUpdateMembershipForUserInOrgReq) Rel(link string, resp *AddOrUpdateMembershipForUserInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddOrUpdateMembershipForUserInOrgReqBody is a request body for teams/add-or-update-membership-for-user-in-org

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type AddOrUpdateMembershipForUserInOrgReqBody struct {

	/*
	The role that this user should have in the team. Can be one of:
	\* `member` - a normal member of the team.
	\* `maintainer` - a team maintainer. Able to add/remove other team members,
	promote other team members to team maintainer, and edit the team's name and
	description.
	*/
	Role *string `json:"role,omitempty"`
}

/*
AddOrUpdateMembershipForUserInOrgResponse is a response for AddOrUpdateMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type AddOrUpdateMembershipForUserInOrgResponse struct {
	common.Response
	request *AddOrUpdateMembershipForUserInOrgReq
	Data    components.TeamMembership
}

/*
AddOrUpdateMembershipForUserLegacy performs requests for "teams/add-or-update-membership-for-user-legacy"

Add or update team membership for a user (Legacy).

  PUT /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
func AddOrUpdateMembershipForUserLegacy(ctx context.Context, req *AddOrUpdateMembershipForUserLegacyReq, opt ...options.Option) (*AddOrUpdateMembershipForUserLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddOrUpdateMembershipForUserLegacyReq)
	}
	resp := &AddOrUpdateMembershipForUserLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddOrUpdateMembershipForUserLegacy performs requests for "teams/add-or-update-membership-for-user-legacy"

Add or update team membership for a user (Legacy).

  PUT /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
func (c Client) AddOrUpdateMembershipForUserLegacy(ctx context.Context, req *AddOrUpdateMembershipForUserLegacyReq, opt ...options.Option) (*AddOrUpdateMembershipForUserLegacyResponse, error) {
	return AddOrUpdateMembershipForUserLegacy(ctx, req, append(c, opt...)...)
}

/*
AddOrUpdateMembershipForUserLegacyReq is request data for Client.AddOrUpdateMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
type AddOrUpdateMembershipForUserLegacyReq struct {
	_url        string
	TeamId      int64
	Username    string
	RequestBody AddOrUpdateMembershipForUserLegacyReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddOrUpdateMembershipForUserLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddOrUpdateMembershipForUserLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-membership-for-user-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/memberships/%v", r.TeamId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddOrUpdateMembershipForUserLegacyReq) Rel(link string, resp *AddOrUpdateMembershipForUserLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddOrUpdateMembershipForUserLegacyReqBody is a request body for teams/add-or-update-membership-for-user-legacy

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
type AddOrUpdateMembershipForUserLegacyReqBody struct {

	/*
	The role that this user should have in the team. Can be one of:
	\* `member` - a normal member of the team.
	\* `maintainer` - a team maintainer. Able to add/remove other team members,
	promote other team members to team maintainer, and edit the team's name and
	description.
	*/
	Role *string `json:"role,omitempty"`
}

/*
AddOrUpdateMembershipForUserLegacyResponse is a response for AddOrUpdateMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
type AddOrUpdateMembershipForUserLegacyResponse struct {
	common.Response
	request *AddOrUpdateMembershipForUserLegacyReq
	Data    components.TeamMembership
}

/*
AddOrUpdateProjectPermissionsInOrg performs requests for "teams/add-or-update-project-permissions-in-org"

Add or update team project permissions.

  PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
func AddOrUpdateProjectPermissionsInOrg(ctx context.Context, req *AddOrUpdateProjectPermissionsInOrgReq, opt ...options.Option) (*AddOrUpdateProjectPermissionsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddOrUpdateProjectPermissionsInOrgReq)
	}
	resp := &AddOrUpdateProjectPermissionsInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddOrUpdateProjectPermissionsInOrg performs requests for "teams/add-or-update-project-permissions-in-org"

Add or update team project permissions.

  PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
func (c Client) AddOrUpdateProjectPermissionsInOrg(ctx context.Context, req *AddOrUpdateProjectPermissionsInOrgReq, opt ...options.Option) (*AddOrUpdateProjectPermissionsInOrgResponse, error) {
	return AddOrUpdateProjectPermissionsInOrg(ctx, req, append(c, opt...)...)
}

/*
AddOrUpdateProjectPermissionsInOrgReq is request data for Client.AddOrUpdateProjectPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type AddOrUpdateProjectPermissionsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	ProjectId   int64
	RequestBody AddOrUpdateProjectPermissionsInOrgReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AddOrUpdateProjectPermissionsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddOrUpdateProjectPermissionsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": internal.String("application/json")},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-project-permissions-in-org",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddOrUpdateProjectPermissionsInOrgReq) Rel(link string, resp *AddOrUpdateProjectPermissionsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddOrUpdateProjectPermissionsInOrgReqBody is a request body for teams/add-or-update-project-permissions-in-org

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type AddOrUpdateProjectPermissionsInOrgReqBody struct {

	/*
	The permission to grant to the team for this project. Can be one of:
	\* `read` - team members can read, but not write to or administer this project.
	\* `write` - team members can read and write, but not administer this project.
	\* `admin` - team members can read, write and administer this project.
	Default: the team's `permission` attribute will be used to determine what
	permission to grant the team on this project. Note that, if you choose not to
	pass any parameters, you'll need to set `Content-Length` to zero when calling
	out to this endpoint. For more information, see "[HTTP
	verbs](https://developer.github.com/v3/#http-verbs)."
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
AddOrUpdateProjectPermissionsInOrgResponse is a response for AddOrUpdateProjectPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type AddOrUpdateProjectPermissionsInOrgResponse struct {
	common.Response
	request *AddOrUpdateProjectPermissionsInOrgReq
}

/*
AddOrUpdateProjectPermissionsLegacy performs requests for "teams/add-or-update-project-permissions-legacy"

Add or update team project permissions (Legacy).

  PUT /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
func AddOrUpdateProjectPermissionsLegacy(ctx context.Context, req *AddOrUpdateProjectPermissionsLegacyReq, opt ...options.Option) (*AddOrUpdateProjectPermissionsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddOrUpdateProjectPermissionsLegacyReq)
	}
	resp := &AddOrUpdateProjectPermissionsLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddOrUpdateProjectPermissionsLegacy performs requests for "teams/add-or-update-project-permissions-legacy"

Add or update team project permissions (Legacy).

  PUT /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
func (c Client) AddOrUpdateProjectPermissionsLegacy(ctx context.Context, req *AddOrUpdateProjectPermissionsLegacyReq, opt ...options.Option) (*AddOrUpdateProjectPermissionsLegacyResponse, error) {
	return AddOrUpdateProjectPermissionsLegacy(ctx, req, append(c, opt...)...)
}

/*
AddOrUpdateProjectPermissionsLegacyReq is request data for Client.AddOrUpdateProjectPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
type AddOrUpdateProjectPermissionsLegacyReq struct {
	_url        string
	TeamId      int64
	ProjectId   int64
	RequestBody AddOrUpdateProjectPermissionsLegacyReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AddOrUpdateProjectPermissionsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddOrUpdateProjectPermissionsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": internal.String("application/json")},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-project-permissions-legacy",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/teams/%v/projects/%v", r.TeamId, r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddOrUpdateProjectPermissionsLegacyReq) Rel(link string, resp *AddOrUpdateProjectPermissionsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddOrUpdateProjectPermissionsLegacyReqBody is a request body for teams/add-or-update-project-permissions-legacy

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
type AddOrUpdateProjectPermissionsLegacyReqBody struct {

	/*
	The permission to grant to the team for this project. Can be one of:
	\* `read` - team members can read, but not write to or administer this project.
	\* `write` - team members can read and write, but not administer this project.
	\* `admin` - team members can read, write and administer this project.
	Default: the team's `permission` attribute will be used to determine what
	permission to grant the team on this project. Note that, if you choose not to
	pass any parameters, you'll need to set `Content-Length` to zero when calling
	out to this endpoint. For more information, see "[HTTP
	verbs](https://developer.github.com/v3/#http-verbs)."
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
AddOrUpdateProjectPermissionsLegacyResponse is a response for AddOrUpdateProjectPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
type AddOrUpdateProjectPermissionsLegacyResponse struct {
	common.Response
	request *AddOrUpdateProjectPermissionsLegacyReq
}

/*
AddOrUpdateRepoPermissionsInOrg performs requests for "teams/add-or-update-repo-permissions-in-org"

Add or update team repository permissions.

  PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
func AddOrUpdateRepoPermissionsInOrg(ctx context.Context, req *AddOrUpdateRepoPermissionsInOrgReq, opt ...options.Option) (*AddOrUpdateRepoPermissionsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddOrUpdateRepoPermissionsInOrgReq)
	}
	resp := &AddOrUpdateRepoPermissionsInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddOrUpdateRepoPermissionsInOrg performs requests for "teams/add-or-update-repo-permissions-in-org"

Add or update team repository permissions.

  PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
func (c Client) AddOrUpdateRepoPermissionsInOrg(ctx context.Context, req *AddOrUpdateRepoPermissionsInOrgReq, opt ...options.Option) (*AddOrUpdateRepoPermissionsInOrgResponse, error) {
	return AddOrUpdateRepoPermissionsInOrg(ctx, req, append(c, opt...)...)
}

/*
AddOrUpdateRepoPermissionsInOrgReq is request data for Client.AddOrUpdateRepoPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type AddOrUpdateRepoPermissionsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	Owner       string
	Repo        string
	RequestBody AddOrUpdateRepoPermissionsInOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddOrUpdateRepoPermissionsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddOrUpdateRepoPermissionsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": internal.String("application/json")},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-repo-permissions-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddOrUpdateRepoPermissionsInOrgReq) Rel(link string, resp *AddOrUpdateRepoPermissionsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddOrUpdateRepoPermissionsInOrgReqBody is a request body for teams/add-or-update-repo-permissions-in-org

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type AddOrUpdateRepoPermissionsInOrgReqBody struct {

	/*
	The permission to grant the team on this repository. Can be one of:
	\* `pull` - team members can pull, but not push to or administer this
	repository.
	\* `push` - team members can pull and push, but not administer this repository.
	\* `admin` - team members can pull, push and administer this repository.
	\* `maintain` - team members can manage the repository without access to
	sensitive or destructive actions. Recommended for project managers. Only applies
	to repositories owned by organizations.
	\* `triage` - team members can proactively manage issues and pull requests
	without write access. Recommended for contributors who triage a repository. Only
	applies to repositories owned by organizations.

	If no permission is specified, the team's `permission` attribute will be used to
	determine what permission to grant the team on this repository.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
AddOrUpdateRepoPermissionsInOrgResponse is a response for AddOrUpdateRepoPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type AddOrUpdateRepoPermissionsInOrgResponse struct {
	common.Response
	request *AddOrUpdateRepoPermissionsInOrgReq
}

/*
AddOrUpdateRepoPermissionsLegacy performs requests for "teams/add-or-update-repo-permissions-legacy"

Add or update team repository permissions (Legacy).

  PUT /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
func AddOrUpdateRepoPermissionsLegacy(ctx context.Context, req *AddOrUpdateRepoPermissionsLegacyReq, opt ...options.Option) (*AddOrUpdateRepoPermissionsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddOrUpdateRepoPermissionsLegacyReq)
	}
	resp := &AddOrUpdateRepoPermissionsLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddOrUpdateRepoPermissionsLegacy performs requests for "teams/add-or-update-repo-permissions-legacy"

Add or update team repository permissions (Legacy).

  PUT /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
func (c Client) AddOrUpdateRepoPermissionsLegacy(ctx context.Context, req *AddOrUpdateRepoPermissionsLegacyReq, opt ...options.Option) (*AddOrUpdateRepoPermissionsLegacyResponse, error) {
	return AddOrUpdateRepoPermissionsLegacy(ctx, req, append(c, opt...)...)
}

/*
AddOrUpdateRepoPermissionsLegacyReq is request data for Client.AddOrUpdateRepoPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
type AddOrUpdateRepoPermissionsLegacyReq struct {
	_url        string
	TeamId      int64
	Owner       string
	Repo        string
	RequestBody AddOrUpdateRepoPermissionsLegacyReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddOrUpdateRepoPermissionsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddOrUpdateRepoPermissionsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": internal.String("application/json")},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-repo-permissions-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/repos/%v/%v", r.TeamId, r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddOrUpdateRepoPermissionsLegacyReq) Rel(link string, resp *AddOrUpdateRepoPermissionsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddOrUpdateRepoPermissionsLegacyReqBody is a request body for teams/add-or-update-repo-permissions-legacy

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
type AddOrUpdateRepoPermissionsLegacyReqBody struct {

	/*
	The permission to grant the team on this repository. Can be one of:
	\* `pull` - team members can pull, but not push to or administer this
	repository.
	\* `push` - team members can pull and push, but not administer this repository.
	\* `admin` - team members can pull, push and administer this repository.

	If no permission is specified, the team's `permission` attribute will be used to
	determine what permission to grant the team on this repository.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
AddOrUpdateRepoPermissionsLegacyResponse is a response for AddOrUpdateRepoPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
type AddOrUpdateRepoPermissionsLegacyResponse struct {
	common.Response
	request *AddOrUpdateRepoPermissionsLegacyReq
}

/*
CheckPermissionsForProjectInOrg performs requests for "teams/check-permissions-for-project-in-org"

Check team permissions for a project.

  GET /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
func CheckPermissionsForProjectInOrg(ctx context.Context, req *CheckPermissionsForProjectInOrgReq, opt ...options.Option) (*CheckPermissionsForProjectInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckPermissionsForProjectInOrgReq)
	}
	resp := &CheckPermissionsForProjectInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamProject{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckPermissionsForProjectInOrg performs requests for "teams/check-permissions-for-project-in-org"

Check team permissions for a project.

  GET /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
func (c Client) CheckPermissionsForProjectInOrg(ctx context.Context, req *CheckPermissionsForProjectInOrgReq, opt ...options.Option) (*CheckPermissionsForProjectInOrgResponse, error) {
	return CheckPermissionsForProjectInOrg(ctx, req, append(c, opt...)...)
}

/*
CheckPermissionsForProjectInOrgReq is request data for Client.CheckPermissionsForProjectInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
type CheckPermissionsForProjectInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug  string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CheckPermissionsForProjectInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckPermissionsForProjectInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/check-permissions-for-project-in-org",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckPermissionsForProjectInOrgReq) Rel(link string, resp *CheckPermissionsForProjectInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckPermissionsForProjectInOrgResponse is a response for CheckPermissionsForProjectInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
type CheckPermissionsForProjectInOrgResponse struct {
	common.Response
	request *CheckPermissionsForProjectInOrgReq
	Data    components.TeamProject
}

/*
CheckPermissionsForProjectLegacy performs requests for "teams/check-permissions-for-project-legacy"

Check team permissions for a project (Legacy).

  GET /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
func CheckPermissionsForProjectLegacy(ctx context.Context, req *CheckPermissionsForProjectLegacyReq, opt ...options.Option) (*CheckPermissionsForProjectLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckPermissionsForProjectLegacyReq)
	}
	resp := &CheckPermissionsForProjectLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamProject{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckPermissionsForProjectLegacy performs requests for "teams/check-permissions-for-project-legacy"

Check team permissions for a project (Legacy).

  GET /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
func (c Client) CheckPermissionsForProjectLegacy(ctx context.Context, req *CheckPermissionsForProjectLegacyReq, opt ...options.Option) (*CheckPermissionsForProjectLegacyResponse, error) {
	return CheckPermissionsForProjectLegacy(ctx, req, append(c, opt...)...)
}

/*
CheckPermissionsForProjectLegacyReq is request data for Client.CheckPermissionsForProjectLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
type CheckPermissionsForProjectLegacyReq struct {
	_url      string
	TeamId    int64
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CheckPermissionsForProjectLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckPermissionsForProjectLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/check-permissions-for-project-legacy",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/teams/%v/projects/%v", r.TeamId, r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckPermissionsForProjectLegacyReq) Rel(link string, resp *CheckPermissionsForProjectLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckPermissionsForProjectLegacyResponse is a response for CheckPermissionsForProjectLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
type CheckPermissionsForProjectLegacyResponse struct {
	common.Response
	request *CheckPermissionsForProjectLegacyReq
	Data    components.TeamProject
}

/*
CheckPermissionsForRepoInOrg performs requests for "teams/check-permissions-for-repo-in-org"

Check team permissions for a repository.

  GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
func CheckPermissionsForRepoInOrg(ctx context.Context, req *CheckPermissionsForRepoInOrgReq, opt ...options.Option) (*CheckPermissionsForRepoInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckPermissionsForRepoInOrgReq)
	}
	resp := &CheckPermissionsForRepoInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckPermissionsForRepoInOrg performs requests for "teams/check-permissions-for-repo-in-org"

Check team permissions for a repository.

  GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
func (c Client) CheckPermissionsForRepoInOrg(ctx context.Context, req *CheckPermissionsForRepoInOrgReq, opt ...options.Option) (*CheckPermissionsForRepoInOrgResponse, error) {
	return CheckPermissionsForRepoInOrg(ctx, req, append(c, opt...)...)
}

/*
CheckPermissionsForRepoInOrgReq is request data for Client.CheckPermissionsForRepoInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
type CheckPermissionsForRepoInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
	Owner    string
	Repo     string
}

// HTTPRequest builds an *http.Request
func (r *CheckPermissionsForRepoInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckPermissionsForRepoInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/vnd.github.v3.repository+json")},
		Method:           "GET",
		OperationID:      "teams/check-permissions-for-repo-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckPermissionsForRepoInOrgReq) Rel(link string, resp *CheckPermissionsForRepoInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckPermissionsForRepoInOrgResponse is a response for CheckPermissionsForRepoInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
type CheckPermissionsForRepoInOrgResponse struct {
	common.Response
	request *CheckPermissionsForRepoInOrgReq
	Data    components.TeamRepository
}

/*
CheckPermissionsForRepoLegacy performs requests for "teams/check-permissions-for-repo-legacy"

Check team permissions for a repository (Legacy).

  GET /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
func CheckPermissionsForRepoLegacy(ctx context.Context, req *CheckPermissionsForRepoLegacyReq, opt ...options.Option) (*CheckPermissionsForRepoLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckPermissionsForRepoLegacyReq)
	}
	resp := &CheckPermissionsForRepoLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckPermissionsForRepoLegacy performs requests for "teams/check-permissions-for-repo-legacy"

Check team permissions for a repository (Legacy).

  GET /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
func (c Client) CheckPermissionsForRepoLegacy(ctx context.Context, req *CheckPermissionsForRepoLegacyReq, opt ...options.Option) (*CheckPermissionsForRepoLegacyResponse, error) {
	return CheckPermissionsForRepoLegacy(ctx, req, append(c, opt...)...)
}

/*
CheckPermissionsForRepoLegacyReq is request data for Client.CheckPermissionsForRepoLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
type CheckPermissionsForRepoLegacyReq struct {
	_url   string
	TeamId int64
	Owner  string
	Repo   string
}

// HTTPRequest builds an *http.Request
func (r *CheckPermissionsForRepoLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckPermissionsForRepoLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/vnd.github.v3.repository+json")},
		Method:           "GET",
		OperationID:      "teams/check-permissions-for-repo-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/repos/%v/%v", r.TeamId, r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckPermissionsForRepoLegacyReq) Rel(link string, resp *CheckPermissionsForRepoLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckPermissionsForRepoLegacyResponse is a response for CheckPermissionsForRepoLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
type CheckPermissionsForRepoLegacyResponse struct {
	common.Response
	request *CheckPermissionsForRepoLegacyReq
	Data    components.TeamRepository
}

/*
Create performs requests for "teams/create"

Create a team.

  POST /orgs/{org}/teams

https://developer.github.com/v3/teams/#create-a-team
*/
func Create(ctx context.Context, req *CreateReq, opt ...options.Option) (*CreateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateReq)
	}
	resp := &CreateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Create performs requests for "teams/create"

Create a team.

  POST /orgs/{org}/teams

https://developer.github.com/v3/teams/#create-a-team
*/
func (c Client) Create(ctx context.Context, req *CreateReq, opt ...options.Option) (*CreateResponse, error) {
	return Create(ctx, req, append(c, opt...)...)
}

/*
CreateReq is request data for Client.Create

https://developer.github.com/v3/teams/#create-a-team
*/
type CreateReq struct {
	_url        string
	Org         string
	RequestBody CreateReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateReq) Rel(link string, resp *CreateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateReqBody is a request body for teams/create

https://developer.github.com/v3/teams/#create-a-team
*/
type CreateReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// List GitHub IDs for organization members who will become team maintainers.
	Maintainers []string `json:"maintainers,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	**Deprecated**. The permission that new repositories will be added to the team
	with when none is specified. Can be one of:
	\* `pull` - team members can pull, but not push to or administer newly-added
	repositories.
	\* `push` - team members can pull and push, but not administer newly-added
	repositories.
	\* `admin` - team members can pull, push and administer newly-added
	repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	The level of privacy this team should have. The options are:
	**For a non-nested team:**
	\* `secret` - only visible to organization owners and members of this team.
	\* `closed` - visible to all members of this organization.
	Default: `secret`
	**For a parent or child team:**
	\* `closed` - visible to all members of this organization.
	Default for child team: `closed`
	*/
	Privacy *string `json:"privacy,omitempty"`

	// The full name (e.g., "organization-name/repository-name") of repositories to add the team to.
	RepoNames []string `json:"repo_names,omitempty"`
}

/*
CreateResponse is a response for Create

https://developer.github.com/v3/teams/#create-a-team
*/
type CreateResponse struct {
	common.Response
	request *CreateReq
	Data    components.TeamFull
}

/*
CreateDiscussionCommentInOrg performs requests for "teams/create-discussion-comment-in-org"

Create a discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
func CreateDiscussionCommentInOrg(ctx context.Context, req *CreateDiscussionCommentInOrgReq, opt ...options.Option) (*CreateDiscussionCommentInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateDiscussionCommentInOrgReq)
	}
	resp := &CreateDiscussionCommentInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateDiscussionCommentInOrg performs requests for "teams/create-discussion-comment-in-org"

Create a discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
func (c Client) CreateDiscussionCommentInOrg(ctx context.Context, req *CreateDiscussionCommentInOrgReq, opt ...options.Option) (*CreateDiscussionCommentInOrgResponse, error) {
	return CreateDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
CreateDiscussionCommentInOrgReq is request data for Client.CreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type CreateDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      CreateDiscussionCommentInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create-discussion-comment-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateDiscussionCommentInOrgReq) Rel(link string, resp *CreateDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateDiscussionCommentInOrgReqBody is a request body for teams/create-discussion-comment-in-org

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type CreateDiscussionCommentInOrgReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
CreateDiscussionCommentInOrgResponse is a response for CreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type CreateDiscussionCommentInOrgResponse struct {
	common.Response
	request *CreateDiscussionCommentInOrgReq
	Data    components.TeamDiscussionComment
}

/*
CreateDiscussionCommentLegacy performs requests for "teams/create-discussion-comment-legacy"

Create a discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
func CreateDiscussionCommentLegacy(ctx context.Context, req *CreateDiscussionCommentLegacyReq, opt ...options.Option) (*CreateDiscussionCommentLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateDiscussionCommentLegacyReq)
	}
	resp := &CreateDiscussionCommentLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateDiscussionCommentLegacy performs requests for "teams/create-discussion-comment-legacy"

Create a discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
func (c Client) CreateDiscussionCommentLegacy(ctx context.Context, req *CreateDiscussionCommentLegacyReq, opt ...options.Option) (*CreateDiscussionCommentLegacyResponse, error) {
	return CreateDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
CreateDiscussionCommentLegacyReq is request data for Client.CreateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
type CreateDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	RequestBody      CreateDiscussionCommentLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create-discussion-comment-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateDiscussionCommentLegacyReq) Rel(link string, resp *CreateDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateDiscussionCommentLegacyReqBody is a request body for teams/create-discussion-comment-legacy

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
type CreateDiscussionCommentLegacyReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
CreateDiscussionCommentLegacyResponse is a response for CreateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
type CreateDiscussionCommentLegacyResponse struct {
	common.Response
	request *CreateDiscussionCommentLegacyReq
	Data    components.TeamDiscussionComment
}

/*
CreateDiscussionInOrg performs requests for "teams/create-discussion-in-org"

Create a discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
func CreateDiscussionInOrg(ctx context.Context, req *CreateDiscussionInOrgReq, opt ...options.Option) (*CreateDiscussionInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateDiscussionInOrgReq)
	}
	resp := &CreateDiscussionInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateDiscussionInOrg performs requests for "teams/create-discussion-in-org"

Create a discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
func (c Client) CreateDiscussionInOrg(ctx context.Context, req *CreateDiscussionInOrgReq, opt ...options.Option) (*CreateDiscussionInOrgResponse, error) {
	return CreateDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
CreateDiscussionInOrgReq is request data for Client.CreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type CreateDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	RequestBody CreateDiscussionInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create-discussion-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateDiscussionInOrgReq) Rel(link string, resp *CreateDiscussionInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateDiscussionInOrgReqBody is a request body for teams/create-discussion-in-org

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type CreateDiscussionInOrgReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body"`

	/*
	Private posts are only visible to team members, organization owners, and team
	maintainers. Public posts are visible to all members of the organization. Set to
	`true` to create a private post.
	*/
	Private *bool `json:"private,omitempty"`

	// The discussion post's title.
	Title *string `json:"title"`
}

/*
CreateDiscussionInOrgResponse is a response for CreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type CreateDiscussionInOrgResponse struct {
	common.Response
	request *CreateDiscussionInOrgReq
	Data    components.TeamDiscussion
}

/*
CreateDiscussionLegacy performs requests for "teams/create-discussion-legacy"

Create a discussion (Legacy).

  POST /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
func CreateDiscussionLegacy(ctx context.Context, req *CreateDiscussionLegacyReq, opt ...options.Option) (*CreateDiscussionLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateDiscussionLegacyReq)
	}
	resp := &CreateDiscussionLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateDiscussionLegacy performs requests for "teams/create-discussion-legacy"

Create a discussion (Legacy).

  POST /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
func (c Client) CreateDiscussionLegacy(ctx context.Context, req *CreateDiscussionLegacyReq, opt ...options.Option) (*CreateDiscussionLegacyResponse, error) {
	return CreateDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
CreateDiscussionLegacyReq is request data for Client.CreateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
type CreateDiscussionLegacyReq struct {
	_url        string
	TeamId      int64
	RequestBody CreateDiscussionLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create-discussion-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateDiscussionLegacyReq) Rel(link string, resp *CreateDiscussionLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateDiscussionLegacyReqBody is a request body for teams/create-discussion-legacy

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
type CreateDiscussionLegacyReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body"`

	/*
	Private posts are only visible to team members, organization owners, and team
	maintainers. Public posts are visible to all members of the organization. Set to
	`true` to create a private post.
	*/
	Private *bool `json:"private,omitempty"`

	// The discussion post's title.
	Title *string `json:"title"`
}

/*
CreateDiscussionLegacyResponse is a response for CreateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
type CreateDiscussionLegacyResponse struct {
	common.Response
	request *CreateDiscussionLegacyReq
	Data    components.TeamDiscussion
}

/*
CreateOrUpdateIdpGroupConnectionsInOrg performs requests for "teams/create-or-update-idp-group-connections-in-org"

Create or update IdP group connections.

  PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
func CreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, req *CreateOrUpdateIdpGroupConnectionsInOrgReq, opt ...options.Option) (*CreateOrUpdateIdpGroupConnectionsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateOrUpdateIdpGroupConnectionsInOrgReq)
	}
	resp := &CreateOrUpdateIdpGroupConnectionsInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GroupMapping{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateOrUpdateIdpGroupConnectionsInOrg performs requests for "teams/create-or-update-idp-group-connections-in-org"

Create or update IdP group connections.

  PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
func (c Client) CreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, req *CreateOrUpdateIdpGroupConnectionsInOrgReq, opt ...options.Option) (*CreateOrUpdateIdpGroupConnectionsInOrgResponse, error) {
	return CreateOrUpdateIdpGroupConnectionsInOrg(ctx, req, append(c, opt...)...)
}

/*
CreateOrUpdateIdpGroupConnectionsInOrgReq is request data for Client.CreateOrUpdateIdpGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type CreateOrUpdateIdpGroupConnectionsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	RequestBody CreateOrUpdateIdpGroupConnectionsInOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateOrUpdateIdpGroupConnectionsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateOrUpdateIdpGroupConnectionsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/create-or-update-idp-group-connections-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/team-sync/group-mappings", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateOrUpdateIdpGroupConnectionsInOrgReq) Rel(link string, resp *CreateOrUpdateIdpGroupConnectionsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateOrUpdateIdpGroupConnectionsInOrgReqBodyGroups is a value for CreateOrUpdateIdpGroupConnectionsInOrgReqBody's Groups field
type CreateOrUpdateIdpGroupConnectionsInOrgReqBodyGroups struct {

	// Description of the IdP group.
	GroupDescription *string `json:"group_description"`

	// ID of the IdP group.
	GroupId *string `json:"group_id"`

	// Name of the IdP group.
	GroupName *string `json:"group_name"`
}

/*
CreateOrUpdateIdpGroupConnectionsInOrgReqBody is a request body for teams/create-or-update-idp-group-connections-in-org

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type CreateOrUpdateIdpGroupConnectionsInOrgReqBody struct {

	/*
	The IdP groups you want to connect to a GitHub team. When updating, the new
	`groups` object will replace the original one. You must include any existing
	groups that you don't want to remove.
	*/
	Groups []CreateOrUpdateIdpGroupConnectionsInOrgReqBodyGroups `json:"groups"`
}

/*
CreateOrUpdateIdpGroupConnectionsInOrgResponse is a response for CreateOrUpdateIdpGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type CreateOrUpdateIdpGroupConnectionsInOrgResponse struct {
	common.Response
	request *CreateOrUpdateIdpGroupConnectionsInOrgReq
	Data    components.GroupMapping
}

/*
CreateOrUpdateIdpGroupConnectionsLegacy performs requests for "teams/create-or-update-idp-group-connections-legacy"

Create or update IdP group connections (Legacy).

  PATCH /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
func CreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, req *CreateOrUpdateIdpGroupConnectionsLegacyReq, opt ...options.Option) (*CreateOrUpdateIdpGroupConnectionsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateOrUpdateIdpGroupConnectionsLegacyReq)
	}
	resp := &CreateOrUpdateIdpGroupConnectionsLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GroupMapping{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateOrUpdateIdpGroupConnectionsLegacy performs requests for "teams/create-or-update-idp-group-connections-legacy"

Create or update IdP group connections (Legacy).

  PATCH /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
func (c Client) CreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, req *CreateOrUpdateIdpGroupConnectionsLegacyReq, opt ...options.Option) (*CreateOrUpdateIdpGroupConnectionsLegacyResponse, error) {
	return CreateOrUpdateIdpGroupConnectionsLegacy(ctx, req, append(c, opt...)...)
}

/*
CreateOrUpdateIdpGroupConnectionsLegacyReq is request data for Client.CreateOrUpdateIdpGroupConnectionsLegacy

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
type CreateOrUpdateIdpGroupConnectionsLegacyReq struct {
	_url        string
	TeamId      int64
	RequestBody CreateOrUpdateIdpGroupConnectionsLegacyReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateOrUpdateIdpGroupConnectionsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateOrUpdateIdpGroupConnectionsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/create-or-update-idp-group-connections-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/team-sync/group-mappings", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateOrUpdateIdpGroupConnectionsLegacyReq) Rel(link string, resp *CreateOrUpdateIdpGroupConnectionsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateOrUpdateIdpGroupConnectionsLegacyReqBodyGroups is a value for CreateOrUpdateIdpGroupConnectionsLegacyReqBody's Groups field
type CreateOrUpdateIdpGroupConnectionsLegacyReqBodyGroups struct {
	Description *string `json:"description,omitempty"`

	// Description of the IdP group.
	GroupDescription *string `json:"group_description"`

	// ID of the IdP group.
	GroupId *string `json:"group_id"`

	// Name of the IdP group.
	GroupName *string `json:"group_name"`
	Id        *string `json:"id,omitempty"`
	Name      *string `json:"name,omitempty"`
}

/*
CreateOrUpdateIdpGroupConnectionsLegacyReqBody is a request body for teams/create-or-update-idp-group-connections-legacy

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
type CreateOrUpdateIdpGroupConnectionsLegacyReqBody struct {

	/*
	The IdP groups you want to connect to a GitHub team. When updating, the new
	`groups` object will replace the original one. You must include any existing
	groups that you don't want to remove.
	*/
	Groups   []CreateOrUpdateIdpGroupConnectionsLegacyReqBodyGroups `json:"groups"`
	SyncedAt *string                                                `json:"synced_at,omitempty"`
}

/*
CreateOrUpdateIdpGroupConnectionsLegacyResponse is a response for CreateOrUpdateIdpGroupConnectionsLegacy

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
type CreateOrUpdateIdpGroupConnectionsLegacyResponse struct {
	common.Response
	request *CreateOrUpdateIdpGroupConnectionsLegacyReq
	Data    components.GroupMapping
}

/*
DeleteDiscussionCommentInOrg performs requests for "teams/delete-discussion-comment-in-org"

Delete a discussion comment.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
func DeleteDiscussionCommentInOrg(ctx context.Context, req *DeleteDiscussionCommentInOrgReq, opt ...options.Option) (*DeleteDiscussionCommentInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteDiscussionCommentInOrgReq)
	}
	resp := &DeleteDiscussionCommentInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteDiscussionCommentInOrg performs requests for "teams/delete-discussion-comment-in-org"

Delete a discussion comment.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
func (c Client) DeleteDiscussionCommentInOrg(ctx context.Context, req *DeleteDiscussionCommentInOrgReq, opt ...options.Option) (*DeleteDiscussionCommentInOrgResponse, error) {
	return DeleteDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
DeleteDiscussionCommentInOrgReq is request data for Client.DeleteDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
type DeleteDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/delete-discussion-comment-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteDiscussionCommentInOrgReq) Rel(link string, resp *DeleteDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteDiscussionCommentInOrgResponse is a response for DeleteDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
type DeleteDiscussionCommentInOrgResponse struct {
	common.Response
	request *DeleteDiscussionCommentInOrgReq
}

/*
DeleteDiscussionCommentLegacy performs requests for "teams/delete-discussion-comment-legacy"

Delete a discussion comment (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
func DeleteDiscussionCommentLegacy(ctx context.Context, req *DeleteDiscussionCommentLegacyReq, opt ...options.Option) (*DeleteDiscussionCommentLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteDiscussionCommentLegacyReq)
	}
	resp := &DeleteDiscussionCommentLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteDiscussionCommentLegacy performs requests for "teams/delete-discussion-comment-legacy"

Delete a discussion comment (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
func (c Client) DeleteDiscussionCommentLegacy(ctx context.Context, req *DeleteDiscussionCommentLegacyReq, opt ...options.Option) (*DeleteDiscussionCommentLegacyResponse, error) {
	return DeleteDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
DeleteDiscussionCommentLegacyReq is request data for Client.DeleteDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
type DeleteDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/delete-discussion-comment-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments/%v", r.TeamId, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteDiscussionCommentLegacyReq) Rel(link string, resp *DeleteDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteDiscussionCommentLegacyResponse is a response for DeleteDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
type DeleteDiscussionCommentLegacyResponse struct {
	common.Response
	request *DeleteDiscussionCommentLegacyReq
}

/*
DeleteDiscussionInOrg performs requests for "teams/delete-discussion-in-org"

Delete a discussion.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
func DeleteDiscussionInOrg(ctx context.Context, req *DeleteDiscussionInOrgReq, opt ...options.Option) (*DeleteDiscussionInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteDiscussionInOrgReq)
	}
	resp := &DeleteDiscussionInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteDiscussionInOrg performs requests for "teams/delete-discussion-in-org"

Delete a discussion.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
func (c Client) DeleteDiscussionInOrg(ctx context.Context, req *DeleteDiscussionInOrgReq, opt ...options.Option) (*DeleteDiscussionInOrgResponse, error) {
	return DeleteDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
DeleteDiscussionInOrgReq is request data for Client.DeleteDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
type DeleteDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/delete-discussion-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteDiscussionInOrgReq) Rel(link string, resp *DeleteDiscussionInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteDiscussionInOrgResponse is a response for DeleteDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
type DeleteDiscussionInOrgResponse struct {
	common.Response
	request *DeleteDiscussionInOrgReq
}

/*
DeleteDiscussionLegacy performs requests for "teams/delete-discussion-legacy"

Delete a discussion (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
func DeleteDiscussionLegacy(ctx context.Context, req *DeleteDiscussionLegacyReq, opt ...options.Option) (*DeleteDiscussionLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteDiscussionLegacyReq)
	}
	resp := &DeleteDiscussionLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteDiscussionLegacy performs requests for "teams/delete-discussion-legacy"

Delete a discussion (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
func (c Client) DeleteDiscussionLegacy(ctx context.Context, req *DeleteDiscussionLegacyReq, opt ...options.Option) (*DeleteDiscussionLegacyResponse, error) {
	return DeleteDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
DeleteDiscussionLegacyReq is request data for Client.DeleteDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
type DeleteDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/delete-discussion-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteDiscussionLegacyReq) Rel(link string, resp *DeleteDiscussionLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteDiscussionLegacyResponse is a response for DeleteDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
type DeleteDiscussionLegacyResponse struct {
	common.Response
	request *DeleteDiscussionLegacyReq
}

/*
DeleteInOrg performs requests for "teams/delete-in-org"

Delete a team.

  DELETE /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#delete-a-team
*/
func DeleteInOrg(ctx context.Context, req *DeleteInOrgReq, opt ...options.Option) (*DeleteInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteInOrgReq)
	}
	resp := &DeleteInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteInOrg performs requests for "teams/delete-in-org"

Delete a team.

  DELETE /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#delete-a-team
*/
func (c Client) DeleteInOrg(ctx context.Context, req *DeleteInOrgReq, opt ...options.Option) (*DeleteInOrgResponse, error) {
	return DeleteInOrg(ctx, req, append(c, opt...)...)
}

/*
DeleteInOrgReq is request data for Client.DeleteInOrg

https://developer.github.com/v3/teams/#delete-a-team
*/
type DeleteInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
}

// HTTPRequest builds an *http.Request
func (r *DeleteInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/delete-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteInOrgReq) Rel(link string, resp *DeleteInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteInOrgResponse is a response for DeleteInOrg

https://developer.github.com/v3/teams/#delete-a-team
*/
type DeleteInOrgResponse struct {
	common.Response
	request *DeleteInOrgReq
}

/*
DeleteLegacy performs requests for "teams/delete-legacy"

Delete a team (Legacy).

  DELETE /teams/{team_id}

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
func DeleteLegacy(ctx context.Context, req *DeleteLegacyReq, opt ...options.Option) (*DeleteLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteLegacyReq)
	}
	resp := &DeleteLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteLegacy performs requests for "teams/delete-legacy"

Delete a team (Legacy).

  DELETE /teams/{team_id}

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
func (c Client) DeleteLegacy(ctx context.Context, req *DeleteLegacyReq, opt ...options.Option) (*DeleteLegacyResponse, error) {
	return DeleteLegacy(ctx, req, append(c, opt...)...)
}

/*
DeleteLegacyReq is request data for Client.DeleteLegacy

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
type DeleteLegacyReq struct {
	_url   string
	TeamId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/delete-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteLegacyReq) Rel(link string, resp *DeleteLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteLegacyResponse is a response for DeleteLegacy

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
type DeleteLegacyResponse struct {
	common.Response
	request *DeleteLegacyReq
}

/*
GetByName performs requests for "teams/get-by-name"

Get a team by name.

  GET /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
func GetByName(ctx context.Context, req *GetByNameReq, opt ...options.Option) (*GetByNameResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetByNameReq)
	}
	resp := &GetByNameResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetByName performs requests for "teams/get-by-name"

Get a team by name.

  GET /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
func (c Client) GetByName(ctx context.Context, req *GetByNameReq, opt ...options.Option) (*GetByNameResponse, error) {
	return GetByName(ctx, req, append(c, opt...)...)
}

/*
GetByNameReq is request data for Client.GetByName

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
type GetByNameReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
}

// HTTPRequest builds an *http.Request
func (r *GetByNameReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetByNameReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-by-name",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetByNameReq) Rel(link string, resp *GetByNameResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetByNameResponse is a response for GetByName

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
type GetByNameResponse struct {
	common.Response
	request *GetByNameReq
	Data    components.TeamFull
}

/*
GetDiscussionCommentInOrg performs requests for "teams/get-discussion-comment-in-org"

Get a discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
func GetDiscussionCommentInOrg(ctx context.Context, req *GetDiscussionCommentInOrgReq, opt ...options.Option) (*GetDiscussionCommentInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetDiscussionCommentInOrgReq)
	}
	resp := &GetDiscussionCommentInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetDiscussionCommentInOrg performs requests for "teams/get-discussion-comment-in-org"

Get a discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
func (c Client) GetDiscussionCommentInOrg(ctx context.Context, req *GetDiscussionCommentInOrgReq, opt ...options.Option) (*GetDiscussionCommentInOrgResponse, error) {
	return GetDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
GetDiscussionCommentInOrgReq is request data for Client.GetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
type GetDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-discussion-comment-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetDiscussionCommentInOrgReq) Rel(link string, resp *GetDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetDiscussionCommentInOrgResponse is a response for GetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
type GetDiscussionCommentInOrgResponse struct {
	common.Response
	request *GetDiscussionCommentInOrgReq
	Data    components.TeamDiscussionComment
}

/*
GetDiscussionCommentLegacy performs requests for "teams/get-discussion-comment-legacy"

Get a discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
func GetDiscussionCommentLegacy(ctx context.Context, req *GetDiscussionCommentLegacyReq, opt ...options.Option) (*GetDiscussionCommentLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetDiscussionCommentLegacyReq)
	}
	resp := &GetDiscussionCommentLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetDiscussionCommentLegacy performs requests for "teams/get-discussion-comment-legacy"

Get a discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
func (c Client) GetDiscussionCommentLegacy(ctx context.Context, req *GetDiscussionCommentLegacyReq, opt ...options.Option) (*GetDiscussionCommentLegacyResponse, error) {
	return GetDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
GetDiscussionCommentLegacyReq is request data for Client.GetDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
type GetDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-discussion-comment-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments/%v", r.TeamId, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetDiscussionCommentLegacyReq) Rel(link string, resp *GetDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetDiscussionCommentLegacyResponse is a response for GetDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
type GetDiscussionCommentLegacyResponse struct {
	common.Response
	request *GetDiscussionCommentLegacyReq
	Data    components.TeamDiscussionComment
}

/*
GetDiscussionInOrg performs requests for "teams/get-discussion-in-org"

Get a discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
func GetDiscussionInOrg(ctx context.Context, req *GetDiscussionInOrgReq, opt ...options.Option) (*GetDiscussionInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetDiscussionInOrgReq)
	}
	resp := &GetDiscussionInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetDiscussionInOrg performs requests for "teams/get-discussion-in-org"

Get a discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
func (c Client) GetDiscussionInOrg(ctx context.Context, req *GetDiscussionInOrgReq, opt ...options.Option) (*GetDiscussionInOrgResponse, error) {
	return GetDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
GetDiscussionInOrgReq is request data for Client.GetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
type GetDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-discussion-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetDiscussionInOrgReq) Rel(link string, resp *GetDiscussionInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetDiscussionInOrgResponse is a response for GetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
type GetDiscussionInOrgResponse struct {
	common.Response
	request *GetDiscussionInOrgReq
	Data    components.TeamDiscussion
}

/*
GetDiscussionLegacy performs requests for "teams/get-discussion-legacy"

Get a discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
func GetDiscussionLegacy(ctx context.Context, req *GetDiscussionLegacyReq, opt ...options.Option) (*GetDiscussionLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetDiscussionLegacyReq)
	}
	resp := &GetDiscussionLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetDiscussionLegacy performs requests for "teams/get-discussion-legacy"

Get a discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
func (c Client) GetDiscussionLegacy(ctx context.Context, req *GetDiscussionLegacyReq, opt ...options.Option) (*GetDiscussionLegacyResponse, error) {
	return GetDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
GetDiscussionLegacyReq is request data for Client.GetDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
type GetDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-discussion-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetDiscussionLegacyReq) Rel(link string, resp *GetDiscussionLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetDiscussionLegacyResponse is a response for GetDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
type GetDiscussionLegacyResponse struct {
	common.Response
	request *GetDiscussionLegacyReq
	Data    components.TeamDiscussion
}

/*
GetLegacy performs requests for "teams/get-legacy"

Get a team (Legacy).

  GET /teams/{team_id}

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
func GetLegacy(ctx context.Context, req *GetLegacyReq, opt ...options.Option) (*GetLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetLegacyReq)
	}
	resp := &GetLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetLegacy performs requests for "teams/get-legacy"

Get a team (Legacy).

  GET /teams/{team_id}

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
func (c Client) GetLegacy(ctx context.Context, req *GetLegacyReq, opt ...options.Option) (*GetLegacyResponse, error) {
	return GetLegacy(ctx, req, append(c, opt...)...)
}

/*
GetLegacyReq is request data for Client.GetLegacy

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
type GetLegacyReq struct {
	_url   string
	TeamId int64
}

// HTTPRequest builds an *http.Request
func (r *GetLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetLegacyReq) Rel(link string, resp *GetLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetLegacyResponse is a response for GetLegacy

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
type GetLegacyResponse struct {
	common.Response
	request *GetLegacyReq
	Data    components.TeamFull
}

/*
GetMemberLegacy performs requests for "teams/get-member-legacy"

Get team member (Legacy).

  GET /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
func GetMemberLegacy(ctx context.Context, req *GetMemberLegacyReq, opt ...options.Option) (*GetMemberLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetMemberLegacyReq)
	}
	resp := &GetMemberLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetMemberLegacy performs requests for "teams/get-member-legacy"

Get team member (Legacy).

  GET /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
func (c Client) GetMemberLegacy(ctx context.Context, req *GetMemberLegacyReq, opt ...options.Option) (*GetMemberLegacyResponse, error) {
	return GetMemberLegacy(ctx, req, append(c, opt...)...)
}

/*
GetMemberLegacyReq is request data for Client.GetMemberLegacy

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
type GetMemberLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetMemberLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetMemberLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "teams/get-member-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/members/%v", r.TeamId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetMemberLegacyReq) Rel(link string, resp *GetMemberLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetMemberLegacyResponse is a response for GetMemberLegacy

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
type GetMemberLegacyResponse struct {
	common.Response
	request *GetMemberLegacyReq
	Data    bool
}

/*
GetMembershipForUserInOrg performs requests for "teams/get-membership-for-user-in-org"

Get team membership for a user.

  GET /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
func GetMembershipForUserInOrg(ctx context.Context, req *GetMembershipForUserInOrgReq, opt ...options.Option) (*GetMembershipForUserInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetMembershipForUserInOrgReq)
	}
	resp := &GetMembershipForUserInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetMembershipForUserInOrg performs requests for "teams/get-membership-for-user-in-org"

Get team membership for a user.

  GET /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
func (c Client) GetMembershipForUserInOrg(ctx context.Context, req *GetMembershipForUserInOrgReq, opt ...options.Option) (*GetMembershipForUserInOrgResponse, error) {
	return GetMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
GetMembershipForUserInOrgReq is request data for Client.GetMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
type GetMembershipForUserInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetMembershipForUserInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-membership-for-user-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetMembershipForUserInOrgReq) Rel(link string, resp *GetMembershipForUserInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetMembershipForUserInOrgResponse is a response for GetMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
type GetMembershipForUserInOrgResponse struct {
	common.Response
	request *GetMembershipForUserInOrgReq
	Data    components.TeamMembership
}

/*
GetMembershipForUserLegacy performs requests for "teams/get-membership-for-user-legacy"

Get team membership for a user (Legacy).

  GET /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
func GetMembershipForUserLegacy(ctx context.Context, req *GetMembershipForUserLegacyReq, opt ...options.Option) (*GetMembershipForUserLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetMembershipForUserLegacyReq)
	}
	resp := &GetMembershipForUserLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetMembershipForUserLegacy performs requests for "teams/get-membership-for-user-legacy"

Get team membership for a user (Legacy).

  GET /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
func (c Client) GetMembershipForUserLegacy(ctx context.Context, req *GetMembershipForUserLegacyReq, opt ...options.Option) (*GetMembershipForUserLegacyResponse, error) {
	return GetMembershipForUserLegacy(ctx, req, append(c, opt...)...)
}

/*
GetMembershipForUserLegacyReq is request data for Client.GetMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
type GetMembershipForUserLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetMembershipForUserLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetMembershipForUserLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-membership-for-user-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/memberships/%v", r.TeamId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetMembershipForUserLegacyReq) Rel(link string, resp *GetMembershipForUserLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetMembershipForUserLegacyResponse is a response for GetMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
type GetMembershipForUserLegacyResponse struct {
	common.Response
	request *GetMembershipForUserLegacyReq
	Data    components.TeamMembership
}

/*
List performs requests for "teams/list"

List teams.

  GET /orgs/{org}/teams

https://developer.github.com/v3/teams/#list-teams
*/
func List(ctx context.Context, req *ListReq, opt ...options.Option) (*ListResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReq)
	}
	resp := &ListResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
List performs requests for "teams/list"

List teams.

  GET /orgs/{org}/teams

https://developer.github.com/v3/teams/#list-teams
*/
func (c Client) List(ctx context.Context, req *ListReq, opt ...options.Option) (*ListResponse, error) {
	return List(ctx, req, append(c, opt...)...)
}

/*
ListReq is request data for Client.List

https://developer.github.com/v3/teams/#list-teams
*/
type ListReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReq) Rel(link string, resp *ListResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListResponse is a response for List

https://developer.github.com/v3/teams/#list-teams
*/
type ListResponse struct {
	common.Response
	request *ListReq
	Data    []components.Team
}

/*
ListChildInOrg performs requests for "teams/list-child-in-org"

List child teams.

  GET /orgs/{org}/teams/{team_slug}/teams

https://developer.github.com/v3/teams/#list-child-teams
*/
func ListChildInOrg(ctx context.Context, req *ListChildInOrgReq, opt ...options.Option) (*ListChildInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListChildInOrgReq)
	}
	resp := &ListChildInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListChildInOrg performs requests for "teams/list-child-in-org"

List child teams.

  GET /orgs/{org}/teams/{team_slug}/teams

https://developer.github.com/v3/teams/#list-child-teams
*/
func (c Client) ListChildInOrg(ctx context.Context, req *ListChildInOrgReq, opt ...options.Option) (*ListChildInOrgResponse, error) {
	return ListChildInOrg(ctx, req, append(c, opt...)...)
}

/*
ListChildInOrgReq is request data for Client.ListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type ListChildInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListChildInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListChildInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-child-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/teams", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListChildInOrgReq) Rel(link string, resp *ListChildInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListChildInOrgResponse is a response for ListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type ListChildInOrgResponse struct {
	common.Response
	request *ListChildInOrgReq
	Data    []components.Team
}

/*
ListChildLegacy performs requests for "teams/list-child-legacy"

List child teams (Legacy).

  GET /teams/{team_id}/teams

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
func ListChildLegacy(ctx context.Context, req *ListChildLegacyReq, opt ...options.Option) (*ListChildLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListChildLegacyReq)
	}
	resp := &ListChildLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListChildLegacy performs requests for "teams/list-child-legacy"

List child teams (Legacy).

  GET /teams/{team_id}/teams

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
func (c Client) ListChildLegacy(ctx context.Context, req *ListChildLegacyReq, opt ...options.Option) (*ListChildLegacyResponse, error) {
	return ListChildLegacy(ctx, req, append(c, opt...)...)
}

/*
ListChildLegacyReq is request data for Client.ListChildLegacy

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
type ListChildLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListChildLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListChildLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-child-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/teams", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListChildLegacyReq) Rel(link string, resp *ListChildLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListChildLegacyResponse is a response for ListChildLegacy

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
type ListChildLegacyResponse struct {
	common.Response
	request *ListChildLegacyReq
	Data    []components.Team
}

/*
ListDiscussionCommentsInOrg performs requests for "teams/list-discussion-comments-in-org"

List discussion comments.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
func ListDiscussionCommentsInOrg(ctx context.Context, req *ListDiscussionCommentsInOrgReq, opt ...options.Option) (*ListDiscussionCommentsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListDiscussionCommentsInOrgReq)
	}
	resp := &ListDiscussionCommentsInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListDiscussionCommentsInOrg performs requests for "teams/list-discussion-comments-in-org"

List discussion comments.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
func (c Client) ListDiscussionCommentsInOrg(ctx context.Context, req *ListDiscussionCommentsInOrgReq, opt ...options.Option) (*ListDiscussionCommentsInOrgResponse, error) {
	return ListDiscussionCommentsInOrg(ctx, req, append(c, opt...)...)
}

/*
ListDiscussionCommentsInOrgReq is request data for Client.ListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
type ListDiscussionCommentsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListDiscussionCommentsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListDiscussionCommentsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-discussion-comments-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListDiscussionCommentsInOrgReq) Rel(link string, resp *ListDiscussionCommentsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListDiscussionCommentsInOrgResponse is a response for ListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
type ListDiscussionCommentsInOrgResponse struct {
	common.Response
	request *ListDiscussionCommentsInOrgReq
	Data    []components.TeamDiscussionComment
}

/*
ListDiscussionCommentsLegacy performs requests for "teams/list-discussion-comments-legacy"

List discussion comments (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
func ListDiscussionCommentsLegacy(ctx context.Context, req *ListDiscussionCommentsLegacyReq, opt ...options.Option) (*ListDiscussionCommentsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListDiscussionCommentsLegacyReq)
	}
	resp := &ListDiscussionCommentsLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListDiscussionCommentsLegacy performs requests for "teams/list-discussion-comments-legacy"

List discussion comments (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
func (c Client) ListDiscussionCommentsLegacy(ctx context.Context, req *ListDiscussionCommentsLegacyReq, opt ...options.Option) (*ListDiscussionCommentsLegacyResponse, error) {
	return ListDiscussionCommentsLegacy(ctx, req, append(c, opt...)...)
}

/*
ListDiscussionCommentsLegacyReq is request data for Client.ListDiscussionCommentsLegacy

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
type ListDiscussionCommentsLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListDiscussionCommentsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListDiscussionCommentsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-discussion-comments-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListDiscussionCommentsLegacyReq) Rel(link string, resp *ListDiscussionCommentsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListDiscussionCommentsLegacyResponse is a response for ListDiscussionCommentsLegacy

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
type ListDiscussionCommentsLegacyResponse struct {
	common.Response
	request *ListDiscussionCommentsLegacyReq
	Data    []components.TeamDiscussionComment
}

/*
ListDiscussionsInOrg performs requests for "teams/list-discussions-in-org"

List discussions.

  GET /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
func ListDiscussionsInOrg(ctx context.Context, req *ListDiscussionsInOrgReq, opt ...options.Option) (*ListDiscussionsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListDiscussionsInOrgReq)
	}
	resp := &ListDiscussionsInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListDiscussionsInOrg performs requests for "teams/list-discussions-in-org"

List discussions.

  GET /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
func (c Client) ListDiscussionsInOrg(ctx context.Context, req *ListDiscussionsInOrgReq, opt ...options.Option) (*ListDiscussionsInOrgResponse, error) {
	return ListDiscussionsInOrg(ctx, req, append(c, opt...)...)
}

/*
ListDiscussionsInOrgReq is request data for Client.ListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type ListDiscussionsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListDiscussionsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListDiscussionsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-discussions-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListDiscussionsInOrgReq) Rel(link string, resp *ListDiscussionsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListDiscussionsInOrgResponse is a response for ListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type ListDiscussionsInOrgResponse struct {
	common.Response
	request *ListDiscussionsInOrgReq
	Data    []components.TeamDiscussion
}

/*
ListDiscussionsLegacy performs requests for "teams/list-discussions-legacy"

List discussions (Legacy).

  GET /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
func ListDiscussionsLegacy(ctx context.Context, req *ListDiscussionsLegacyReq, opt ...options.Option) (*ListDiscussionsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListDiscussionsLegacyReq)
	}
	resp := &ListDiscussionsLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListDiscussionsLegacy performs requests for "teams/list-discussions-legacy"

List discussions (Legacy).

  GET /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
func (c Client) ListDiscussionsLegacy(ctx context.Context, req *ListDiscussionsLegacyReq, opt ...options.Option) (*ListDiscussionsLegacyResponse, error) {
	return ListDiscussionsLegacy(ctx, req, append(c, opt...)...)
}

/*
ListDiscussionsLegacyReq is request data for Client.ListDiscussionsLegacy

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
type ListDiscussionsLegacyReq struct {
	_url   string
	TeamId int64

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListDiscussionsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListDiscussionsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-discussions-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListDiscussionsLegacyReq) Rel(link string, resp *ListDiscussionsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListDiscussionsLegacyResponse is a response for ListDiscussionsLegacy

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
type ListDiscussionsLegacyResponse struct {
	common.Response
	request *ListDiscussionsLegacyReq
	Data    []components.TeamDiscussion
}

/*
ListForAuthenticatedUser performs requests for "teams/list-for-authenticated-user"

List teams for the authenticated user.

  GET /user/teams

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
func ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...options.Option) (*ListForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForAuthenticatedUserReq)
	}
	resp := &ListForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForAuthenticatedUser performs requests for "teams/list-for-authenticated-user"

List teams for the authenticated user.

  GET /user/teams

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
func (c Client) ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...options.Option) (*ListForAuthenticatedUserResponse, error) {
	return ListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListForAuthenticatedUserReq is request data for Client.ListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
type ListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/teams"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForAuthenticatedUserReq) Rel(link string, resp *ListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForAuthenticatedUserResponse is a response for ListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
type ListForAuthenticatedUserResponse struct {
	common.Response
	request *ListForAuthenticatedUserReq
	Data    []components.TeamFull
}

/*
ListIdpGroupsForLegacy performs requests for "teams/list-idp-groups-for-legacy"

List IdP groups for a team (Legacy).

  GET /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
func ListIdpGroupsForLegacy(ctx context.Context, req *ListIdpGroupsForLegacyReq, opt ...options.Option) (*ListIdpGroupsForLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListIdpGroupsForLegacyReq)
	}
	resp := &ListIdpGroupsForLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GroupMapping{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListIdpGroupsForLegacy performs requests for "teams/list-idp-groups-for-legacy"

List IdP groups for a team (Legacy).

  GET /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
func (c Client) ListIdpGroupsForLegacy(ctx context.Context, req *ListIdpGroupsForLegacyReq, opt ...options.Option) (*ListIdpGroupsForLegacyResponse, error) {
	return ListIdpGroupsForLegacy(ctx, req, append(c, opt...)...)
}

/*
ListIdpGroupsForLegacyReq is request data for Client.ListIdpGroupsForLegacy

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
type ListIdpGroupsForLegacyReq struct {
	_url   string
	TeamId int64
}

// HTTPRequest builds an *http.Request
func (r *ListIdpGroupsForLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListIdpGroupsForLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-idp-groups-for-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/team-sync/group-mappings", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListIdpGroupsForLegacyReq) Rel(link string, resp *ListIdpGroupsForLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListIdpGroupsForLegacyResponse is a response for ListIdpGroupsForLegacy

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
type ListIdpGroupsForLegacyResponse struct {
	common.Response
	request *ListIdpGroupsForLegacyReq
	Data    components.GroupMapping
}

/*
ListIdpGroupsForOrg performs requests for "teams/list-idp-groups-for-org"

List IdP groups for an organization.

  GET /orgs/{org}/team-sync/groups

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
func ListIdpGroupsForOrg(ctx context.Context, req *ListIdpGroupsForOrgReq, opt ...options.Option) (*ListIdpGroupsForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListIdpGroupsForOrgReq)
	}
	resp := &ListIdpGroupsForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GroupMapping{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListIdpGroupsForOrg performs requests for "teams/list-idp-groups-for-org"

List IdP groups for an organization.

  GET /orgs/{org}/team-sync/groups

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
func (c Client) ListIdpGroupsForOrg(ctx context.Context, req *ListIdpGroupsForOrgReq, opt ...options.Option) (*ListIdpGroupsForOrgResponse, error) {
	return ListIdpGroupsForOrg(ctx, req, append(c, opt...)...)
}

/*
ListIdpGroupsForOrgReq is request data for Client.ListIdpGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
type ListIdpGroupsForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListIdpGroupsForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListIdpGroupsForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-idp-groups-for-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/team-sync/groups", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListIdpGroupsForOrgReq) Rel(link string, resp *ListIdpGroupsForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListIdpGroupsForOrgResponse is a response for ListIdpGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
type ListIdpGroupsForOrgResponse struct {
	common.Response
	request *ListIdpGroupsForOrgReq
	Data    components.GroupMapping
}

/*
ListIdpGroupsInOrg performs requests for "teams/list-idp-groups-in-org"

List IdP groups for a team.

  GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
func ListIdpGroupsInOrg(ctx context.Context, req *ListIdpGroupsInOrgReq, opt ...options.Option) (*ListIdpGroupsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListIdpGroupsInOrgReq)
	}
	resp := &ListIdpGroupsInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GroupMapping{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListIdpGroupsInOrg performs requests for "teams/list-idp-groups-in-org"

List IdP groups for a team.

  GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
func (c Client) ListIdpGroupsInOrg(ctx context.Context, req *ListIdpGroupsInOrgReq, opt ...options.Option) (*ListIdpGroupsInOrgResponse, error) {
	return ListIdpGroupsInOrg(ctx, req, append(c, opt...)...)
}

/*
ListIdpGroupsInOrgReq is request data for Client.ListIdpGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type ListIdpGroupsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
}

// HTTPRequest builds an *http.Request
func (r *ListIdpGroupsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListIdpGroupsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-idp-groups-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/team-sync/group-mappings", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListIdpGroupsInOrgReq) Rel(link string, resp *ListIdpGroupsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListIdpGroupsInOrgResponse is a response for ListIdpGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type ListIdpGroupsInOrgResponse struct {
	common.Response
	request *ListIdpGroupsInOrgReq
	Data    components.GroupMapping
}

/*
ListMembersInOrg performs requests for "teams/list-members-in-org"

List team members.

  GET /orgs/{org}/teams/{team_slug}/members

https://developer.github.com/v3/teams/members/#list-team-members
*/
func ListMembersInOrg(ctx context.Context, req *ListMembersInOrgReq, opt ...options.Option) (*ListMembersInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListMembersInOrgReq)
	}
	resp := &ListMembersInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListMembersInOrg performs requests for "teams/list-members-in-org"

List team members.

  GET /orgs/{org}/teams/{team_slug}/members

https://developer.github.com/v3/teams/members/#list-team-members
*/
func (c Client) ListMembersInOrg(ctx context.Context, req *ListMembersInOrgReq, opt ...options.Option) (*ListMembersInOrgResponse, error) {
	return ListMembersInOrg(ctx, req, append(c, opt...)...)
}

/*
ListMembersInOrgReq is request data for Client.ListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type ListMembersInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	/*
	Filters members returned by their role in the team. Can be one of:
	\* `member` - normal members of the team.
	\* `maintainer` - team maintainers.
	\* `all` - all members of the team.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListMembersInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListMembersInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-members-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/members", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListMembersInOrgReq) Rel(link string, resp *ListMembersInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListMembersInOrgResponse is a response for ListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type ListMembersInOrgResponse struct {
	common.Response
	request *ListMembersInOrgReq
	Data    []components.SimpleUser
}

/*
ListMembersLegacy performs requests for "teams/list-members-legacy"

List team members (Legacy).

  GET /teams/{team_id}/members

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
func ListMembersLegacy(ctx context.Context, req *ListMembersLegacyReq, opt ...options.Option) (*ListMembersLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListMembersLegacyReq)
	}
	resp := &ListMembersLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListMembersLegacy performs requests for "teams/list-members-legacy"

List team members (Legacy).

  GET /teams/{team_id}/members

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
func (c Client) ListMembersLegacy(ctx context.Context, req *ListMembersLegacyReq, opt ...options.Option) (*ListMembersLegacyResponse, error) {
	return ListMembersLegacy(ctx, req, append(c, opt...)...)
}

/*
ListMembersLegacyReq is request data for Client.ListMembersLegacy

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
type ListMembersLegacyReq struct {
	_url   string
	TeamId int64

	/*
	Filters members returned by their role in the team. Can be one of:
	\* `member` - normal members of the team.
	\* `maintainer` - team maintainers.
	\* `all` - all members of the team.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListMembersLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListMembersLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-members-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/members", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListMembersLegacyReq) Rel(link string, resp *ListMembersLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListMembersLegacyResponse is a response for ListMembersLegacy

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
type ListMembersLegacyResponse struct {
	common.Response
	request *ListMembersLegacyReq
	Data    []components.SimpleUser
}

/*
ListPendingInvitationsInOrg performs requests for "teams/list-pending-invitations-in-org"

List pending team invitations.

  GET /orgs/{org}/teams/{team_slug}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
func ListPendingInvitationsInOrg(ctx context.Context, req *ListPendingInvitationsInOrgReq, opt ...options.Option) (*ListPendingInvitationsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPendingInvitationsInOrgReq)
	}
	resp := &ListPendingInvitationsInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrganizationInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPendingInvitationsInOrg performs requests for "teams/list-pending-invitations-in-org"

List pending team invitations.

  GET /orgs/{org}/teams/{team_slug}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
func (c Client) ListPendingInvitationsInOrg(ctx context.Context, req *ListPendingInvitationsInOrgReq, opt ...options.Option) (*ListPendingInvitationsInOrgResponse, error) {
	return ListPendingInvitationsInOrg(ctx, req, append(c, opt...)...)
}

/*
ListPendingInvitationsInOrgReq is request data for Client.ListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type ListPendingInvitationsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPendingInvitationsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPendingInvitationsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-pending-invitations-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/invitations", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPendingInvitationsInOrgReq) Rel(link string, resp *ListPendingInvitationsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPendingInvitationsInOrgResponse is a response for ListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type ListPendingInvitationsInOrgResponse struct {
	common.Response
	request *ListPendingInvitationsInOrgReq
	Data    []components.OrganizationInvitation
}

/*
ListPendingInvitationsLegacy performs requests for "teams/list-pending-invitations-legacy"

List pending team invitations (Legacy).

  GET /teams/{team_id}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
func ListPendingInvitationsLegacy(ctx context.Context, req *ListPendingInvitationsLegacyReq, opt ...options.Option) (*ListPendingInvitationsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPendingInvitationsLegacyReq)
	}
	resp := &ListPendingInvitationsLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrganizationInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPendingInvitationsLegacy performs requests for "teams/list-pending-invitations-legacy"

List pending team invitations (Legacy).

  GET /teams/{team_id}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
func (c Client) ListPendingInvitationsLegacy(ctx context.Context, req *ListPendingInvitationsLegacyReq, opt ...options.Option) (*ListPendingInvitationsLegacyResponse, error) {
	return ListPendingInvitationsLegacy(ctx, req, append(c, opt...)...)
}

/*
ListPendingInvitationsLegacyReq is request data for Client.ListPendingInvitationsLegacy

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
type ListPendingInvitationsLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPendingInvitationsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPendingInvitationsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-pending-invitations-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/invitations", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPendingInvitationsLegacyReq) Rel(link string, resp *ListPendingInvitationsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPendingInvitationsLegacyResponse is a response for ListPendingInvitationsLegacy

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
type ListPendingInvitationsLegacyResponse struct {
	common.Response
	request *ListPendingInvitationsLegacyReq
	Data    []components.OrganizationInvitation
}

/*
ListProjectsInOrg performs requests for "teams/list-projects-in-org"

List team projects.

  GET /orgs/{org}/teams/{team_slug}/projects

https://developer.github.com/v3/teams/#list-team-projects
*/
func ListProjectsInOrg(ctx context.Context, req *ListProjectsInOrgReq, opt ...options.Option) (*ListProjectsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListProjectsInOrgReq)
	}
	resp := &ListProjectsInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamProject{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListProjectsInOrg performs requests for "teams/list-projects-in-org"

List team projects.

  GET /orgs/{org}/teams/{team_slug}/projects

https://developer.github.com/v3/teams/#list-team-projects
*/
func (c Client) ListProjectsInOrg(ctx context.Context, req *ListProjectsInOrgReq, opt ...options.Option) (*ListProjectsInOrgResponse, error) {
	return ListProjectsInOrg(ctx, req, append(c, opt...)...)
}

/*
ListProjectsInOrgReq is request data for Client.ListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type ListProjectsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListProjectsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListProjectsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-projects-in-org",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/projects", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListProjectsInOrgReq) Rel(link string, resp *ListProjectsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListProjectsInOrgResponse is a response for ListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type ListProjectsInOrgResponse struct {
	common.Response
	request *ListProjectsInOrgReq
	Data    []components.TeamProject
}

/*
ListProjectsLegacy performs requests for "teams/list-projects-legacy"

List team projects (Legacy).

  GET /teams/{team_id}/projects

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
func ListProjectsLegacy(ctx context.Context, req *ListProjectsLegacyReq, opt ...options.Option) (*ListProjectsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListProjectsLegacyReq)
	}
	resp := &ListProjectsLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamProject{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListProjectsLegacy performs requests for "teams/list-projects-legacy"

List team projects (Legacy).

  GET /teams/{team_id}/projects

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
func (c Client) ListProjectsLegacy(ctx context.Context, req *ListProjectsLegacyReq, opt ...options.Option) (*ListProjectsLegacyResponse, error) {
	return ListProjectsLegacy(ctx, req, append(c, opt...)...)
}

/*
ListProjectsLegacyReq is request data for Client.ListProjectsLegacy

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
type ListProjectsLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListProjectsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListProjectsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-projects-legacy",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/teams/%v/projects", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListProjectsLegacyReq) Rel(link string, resp *ListProjectsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListProjectsLegacyResponse is a response for ListProjectsLegacy

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
type ListProjectsLegacyResponse struct {
	common.Response
	request *ListProjectsLegacyReq
	Data    []components.TeamProject
}

/*
ListReposInOrg performs requests for "teams/list-repos-in-org"

List team repositories.

  GET /orgs/{org}/teams/{team_slug}/repos

https://developer.github.com/v3/teams/#list-team-repositories
*/
func ListReposInOrg(ctx context.Context, req *ListReposInOrgReq, opt ...options.Option) (*ListReposInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposInOrgReq)
	}
	resp := &ListReposInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposInOrg performs requests for "teams/list-repos-in-org"

List team repositories.

  GET /orgs/{org}/teams/{team_slug}/repos

https://developer.github.com/v3/teams/#list-team-repositories
*/
func (c Client) ListReposInOrg(ctx context.Context, req *ListReposInOrgReq, opt ...options.Option) (*ListReposInOrgResponse, error) {
	return ListReposInOrg(ctx, req, append(c, opt...)...)
}

/*
ListReposInOrgReq is request data for Client.ListReposInOrg

https://developer.github.com/v3/teams/#list-team-repositories
*/
type ListReposInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReposInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-repos-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/repos", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposInOrgReq) Rel(link string, resp *ListReposInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposInOrgResponse is a response for ListReposInOrg

https://developer.github.com/v3/teams/#list-team-repositories
*/
type ListReposInOrgResponse struct {
	common.Response
	request *ListReposInOrgReq
	Data    []components.MinimalRepository
}

/*
ListReposLegacy performs requests for "teams/list-repos-legacy"

List team repositories (Legacy).

  GET /teams/{team_id}/repos

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
func ListReposLegacy(ctx context.Context, req *ListReposLegacyReq, opt ...options.Option) (*ListReposLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposLegacyReq)
	}
	resp := &ListReposLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposLegacy performs requests for "teams/list-repos-legacy"

List team repositories (Legacy).

  GET /teams/{team_id}/repos

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
func (c Client) ListReposLegacy(ctx context.Context, req *ListReposLegacyReq, opt ...options.Option) (*ListReposLegacyResponse, error) {
	return ListReposLegacy(ctx, req, append(c, opt...)...)
}

/*
ListReposLegacyReq is request data for Client.ListReposLegacy

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
type ListReposLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReposLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-repos-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/repos", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposLegacyReq) Rel(link string, resp *ListReposLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposLegacyResponse is a response for ListReposLegacy

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
type ListReposLegacyResponse struct {
	common.Response
	request *ListReposLegacyReq
	Data    []components.MinimalRepository
}

/*
RemoveMemberLegacy performs requests for "teams/remove-member-legacy"

Remove team member (Legacy).

  DELETE /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
func RemoveMemberLegacy(ctx context.Context, req *RemoveMemberLegacyReq, opt ...options.Option) (*RemoveMemberLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveMemberLegacyReq)
	}
	resp := &RemoveMemberLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveMemberLegacy performs requests for "teams/remove-member-legacy"

Remove team member (Legacy).

  DELETE /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
func (c Client) RemoveMemberLegacy(ctx context.Context, req *RemoveMemberLegacyReq, opt ...options.Option) (*RemoveMemberLegacyResponse, error) {
	return RemoveMemberLegacy(ctx, req, append(c, opt...)...)
}

/*
RemoveMemberLegacyReq is request data for Client.RemoveMemberLegacy

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
type RemoveMemberLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemoveMemberLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveMemberLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-member-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/members/%v", r.TeamId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveMemberLegacyReq) Rel(link string, resp *RemoveMemberLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveMemberLegacyResponse is a response for RemoveMemberLegacy

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
type RemoveMemberLegacyResponse struct {
	common.Response
	request *RemoveMemberLegacyReq
	Data    bool
}

/*
RemoveMembershipForUserInOrg performs requests for "teams/remove-membership-for-user-in-org"

Remove team membership for a user.

  DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
func RemoveMembershipForUserInOrg(ctx context.Context, req *RemoveMembershipForUserInOrgReq, opt ...options.Option) (*RemoveMembershipForUserInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveMembershipForUserInOrgReq)
	}
	resp := &RemoveMembershipForUserInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveMembershipForUserInOrg performs requests for "teams/remove-membership-for-user-in-org"

Remove team membership for a user.

  DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
func (c Client) RemoveMembershipForUserInOrg(ctx context.Context, req *RemoveMembershipForUserInOrgReq, opt ...options.Option) (*RemoveMembershipForUserInOrgResponse, error) {
	return RemoveMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
RemoveMembershipForUserInOrgReq is request data for Client.RemoveMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
type RemoveMembershipForUserInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemoveMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveMembershipForUserInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-membership-for-user-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveMembershipForUserInOrgReq) Rel(link string, resp *RemoveMembershipForUserInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveMembershipForUserInOrgResponse is a response for RemoveMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
type RemoveMembershipForUserInOrgResponse struct {
	common.Response
	request *RemoveMembershipForUserInOrgReq
}

/*
RemoveMembershipForUserLegacy performs requests for "teams/remove-membership-for-user-legacy"

Remove team membership for a user (Legacy).

  DELETE /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
func RemoveMembershipForUserLegacy(ctx context.Context, req *RemoveMembershipForUserLegacyReq, opt ...options.Option) (*RemoveMembershipForUserLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveMembershipForUserLegacyReq)
	}
	resp := &RemoveMembershipForUserLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveMembershipForUserLegacy performs requests for "teams/remove-membership-for-user-legacy"

Remove team membership for a user (Legacy).

  DELETE /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
func (c Client) RemoveMembershipForUserLegacy(ctx context.Context, req *RemoveMembershipForUserLegacyReq, opt ...options.Option) (*RemoveMembershipForUserLegacyResponse, error) {
	return RemoveMembershipForUserLegacy(ctx, req, append(c, opt...)...)
}

/*
RemoveMembershipForUserLegacyReq is request data for Client.RemoveMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
type RemoveMembershipForUserLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemoveMembershipForUserLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveMembershipForUserLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-membership-for-user-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/memberships/%v", r.TeamId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveMembershipForUserLegacyReq) Rel(link string, resp *RemoveMembershipForUserLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveMembershipForUserLegacyResponse is a response for RemoveMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
type RemoveMembershipForUserLegacyResponse struct {
	common.Response
	request *RemoveMembershipForUserLegacyReq
}

/*
RemoveProjectInOrg performs requests for "teams/remove-project-in-org"

Remove a project from a team.

  DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
func RemoveProjectInOrg(ctx context.Context, req *RemoveProjectInOrgReq, opt ...options.Option) (*RemoveProjectInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveProjectInOrgReq)
	}
	resp := &RemoveProjectInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveProjectInOrg performs requests for "teams/remove-project-in-org"

Remove a project from a team.

  DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
func (c Client) RemoveProjectInOrg(ctx context.Context, req *RemoveProjectInOrgReq, opt ...options.Option) (*RemoveProjectInOrgResponse, error) {
	return RemoveProjectInOrg(ctx, req, append(c, opt...)...)
}

/*
RemoveProjectInOrgReq is request data for Client.RemoveProjectInOrg

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
type RemoveProjectInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug  string
	ProjectId int64
}

// HTTPRequest builds an *http.Request
func (r *RemoveProjectInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveProjectInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-project-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveProjectInOrgReq) Rel(link string, resp *RemoveProjectInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveProjectInOrgResponse is a response for RemoveProjectInOrg

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
type RemoveProjectInOrgResponse struct {
	common.Response
	request *RemoveProjectInOrgReq
}

/*
RemoveProjectLegacy performs requests for "teams/remove-project-legacy"

Remove a project from a team (Legacy).

  DELETE /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
func RemoveProjectLegacy(ctx context.Context, req *RemoveProjectLegacyReq, opt ...options.Option) (*RemoveProjectLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveProjectLegacyReq)
	}
	resp := &RemoveProjectLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveProjectLegacy performs requests for "teams/remove-project-legacy"

Remove a project from a team (Legacy).

  DELETE /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
func (c Client) RemoveProjectLegacy(ctx context.Context, req *RemoveProjectLegacyReq, opt ...options.Option) (*RemoveProjectLegacyResponse, error) {
	return RemoveProjectLegacy(ctx, req, append(c, opt...)...)
}

/*
RemoveProjectLegacyReq is request data for Client.RemoveProjectLegacy

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
type RemoveProjectLegacyReq struct {
	_url      string
	TeamId    int64
	ProjectId int64
}

// HTTPRequest builds an *http.Request
func (r *RemoveProjectLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveProjectLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-project-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/projects/%v", r.TeamId, r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveProjectLegacyReq) Rel(link string, resp *RemoveProjectLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveProjectLegacyResponse is a response for RemoveProjectLegacy

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
type RemoveProjectLegacyResponse struct {
	common.Response
	request *RemoveProjectLegacyReq
}

/*
RemoveRepoInOrg performs requests for "teams/remove-repo-in-org"

Remove a repository from a team.

  DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
func RemoveRepoInOrg(ctx context.Context, req *RemoveRepoInOrgReq, opt ...options.Option) (*RemoveRepoInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveRepoInOrgReq)
	}
	resp := &RemoveRepoInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveRepoInOrg performs requests for "teams/remove-repo-in-org"

Remove a repository from a team.

  DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
func (c Client) RemoveRepoInOrg(ctx context.Context, req *RemoveRepoInOrgReq, opt ...options.Option) (*RemoveRepoInOrgResponse, error) {
	return RemoveRepoInOrg(ctx, req, append(c, opt...)...)
}

/*
RemoveRepoInOrgReq is request data for Client.RemoveRepoInOrg

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
type RemoveRepoInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
	Owner    string
	Repo     string
}

// HTTPRequest builds an *http.Request
func (r *RemoveRepoInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveRepoInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-repo-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveRepoInOrgReq) Rel(link string, resp *RemoveRepoInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveRepoInOrgResponse is a response for RemoveRepoInOrg

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
type RemoveRepoInOrgResponse struct {
	common.Response
	request *RemoveRepoInOrgReq
}

/*
RemoveRepoLegacy performs requests for "teams/remove-repo-legacy"

Remove a repository from a team (Legacy).

  DELETE /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
func RemoveRepoLegacy(ctx context.Context, req *RemoveRepoLegacyReq, opt ...options.Option) (*RemoveRepoLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveRepoLegacyReq)
	}
	resp := &RemoveRepoLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveRepoLegacy performs requests for "teams/remove-repo-legacy"

Remove a repository from a team (Legacy).

  DELETE /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
func (c Client) RemoveRepoLegacy(ctx context.Context, req *RemoveRepoLegacyReq, opt ...options.Option) (*RemoveRepoLegacyResponse, error) {
	return RemoveRepoLegacy(ctx, req, append(c, opt...)...)
}

/*
RemoveRepoLegacyReq is request data for Client.RemoveRepoLegacy

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
type RemoveRepoLegacyReq struct {
	_url   string
	TeamId int64
	Owner  string
	Repo   string
}

// HTTPRequest builds an *http.Request
func (r *RemoveRepoLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveRepoLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-repo-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/repos/%v/%v", r.TeamId, r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveRepoLegacyReq) Rel(link string, resp *RemoveRepoLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveRepoLegacyResponse is a response for RemoveRepoLegacy

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
type RemoveRepoLegacyResponse struct {
	common.Response
	request *RemoveRepoLegacyReq
}

/*
UpdateDiscussionCommentInOrg performs requests for "teams/update-discussion-comment-in-org"

Update a discussion comment.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
func UpdateDiscussionCommentInOrg(ctx context.Context, req *UpdateDiscussionCommentInOrgReq, opt ...options.Option) (*UpdateDiscussionCommentInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateDiscussionCommentInOrgReq)
	}
	resp := &UpdateDiscussionCommentInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateDiscussionCommentInOrg performs requests for "teams/update-discussion-comment-in-org"

Update a discussion comment.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
func (c Client) UpdateDiscussionCommentInOrg(ctx context.Context, req *UpdateDiscussionCommentInOrgReq, opt ...options.Option) (*UpdateDiscussionCommentInOrgResponse, error) {
	return UpdateDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
UpdateDiscussionCommentInOrgReq is request data for Client.UpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type UpdateDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      UpdateDiscussionCommentInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-discussion-comment-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateDiscussionCommentInOrgReq) Rel(link string, resp *UpdateDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateDiscussionCommentInOrgReqBody is a request body for teams/update-discussion-comment-in-org

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type UpdateDiscussionCommentInOrgReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
UpdateDiscussionCommentInOrgResponse is a response for UpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type UpdateDiscussionCommentInOrgResponse struct {
	common.Response
	request *UpdateDiscussionCommentInOrgReq
	Data    components.TeamDiscussionComment
}

/*
UpdateDiscussionCommentLegacy performs requests for "teams/update-discussion-comment-legacy"

Update a discussion comment (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
func UpdateDiscussionCommentLegacy(ctx context.Context, req *UpdateDiscussionCommentLegacyReq, opt ...options.Option) (*UpdateDiscussionCommentLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateDiscussionCommentLegacyReq)
	}
	resp := &UpdateDiscussionCommentLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateDiscussionCommentLegacy performs requests for "teams/update-discussion-comment-legacy"

Update a discussion comment (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
func (c Client) UpdateDiscussionCommentLegacy(ctx context.Context, req *UpdateDiscussionCommentLegacyReq, opt ...options.Option) (*UpdateDiscussionCommentLegacyResponse, error) {
	return UpdateDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
UpdateDiscussionCommentLegacyReq is request data for Client.UpdateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
type UpdateDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      UpdateDiscussionCommentLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-discussion-comment-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments/%v", r.TeamId, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateDiscussionCommentLegacyReq) Rel(link string, resp *UpdateDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateDiscussionCommentLegacyReqBody is a request body for teams/update-discussion-comment-legacy

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
type UpdateDiscussionCommentLegacyReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
UpdateDiscussionCommentLegacyResponse is a response for UpdateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
type UpdateDiscussionCommentLegacyResponse struct {
	common.Response
	request *UpdateDiscussionCommentLegacyReq
	Data    components.TeamDiscussionComment
}

/*
UpdateDiscussionInOrg performs requests for "teams/update-discussion-in-org"

Update a discussion.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
func UpdateDiscussionInOrg(ctx context.Context, req *UpdateDiscussionInOrgReq, opt ...options.Option) (*UpdateDiscussionInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateDiscussionInOrgReq)
	}
	resp := &UpdateDiscussionInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateDiscussionInOrg performs requests for "teams/update-discussion-in-org"

Update a discussion.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
func (c Client) UpdateDiscussionInOrg(ctx context.Context, req *UpdateDiscussionInOrgReq, opt ...options.Option) (*UpdateDiscussionInOrgResponse, error) {
	return UpdateDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
UpdateDiscussionInOrgReq is request data for Client.UpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type UpdateDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      UpdateDiscussionInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-discussion-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateDiscussionInOrgReq) Rel(link string, resp *UpdateDiscussionInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateDiscussionInOrgReqBody is a request body for teams/update-discussion-in-org

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type UpdateDiscussionInOrgReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body,omitempty"`

	// The discussion post's title.
	Title *string `json:"title,omitempty"`
}

/*
UpdateDiscussionInOrgResponse is a response for UpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type UpdateDiscussionInOrgResponse struct {
	common.Response
	request *UpdateDiscussionInOrgReq
	Data    components.TeamDiscussion
}

/*
UpdateDiscussionLegacy performs requests for "teams/update-discussion-legacy"

Update a discussion (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
func UpdateDiscussionLegacy(ctx context.Context, req *UpdateDiscussionLegacyReq, opt ...options.Option) (*UpdateDiscussionLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateDiscussionLegacyReq)
	}
	resp := &UpdateDiscussionLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateDiscussionLegacy performs requests for "teams/update-discussion-legacy"

Update a discussion (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
func (c Client) UpdateDiscussionLegacy(ctx context.Context, req *UpdateDiscussionLegacyReq, opt ...options.Option) (*UpdateDiscussionLegacyResponse, error) {
	return UpdateDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
UpdateDiscussionLegacyReq is request data for Client.UpdateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
type UpdateDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	RequestBody      UpdateDiscussionLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-discussion-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateDiscussionLegacyReq) Rel(link string, resp *UpdateDiscussionLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateDiscussionLegacyReqBody is a request body for teams/update-discussion-legacy

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
type UpdateDiscussionLegacyReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body,omitempty"`

	// The discussion post's title.
	Title *string `json:"title,omitempty"`
}

/*
UpdateDiscussionLegacyResponse is a response for UpdateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
type UpdateDiscussionLegacyResponse struct {
	common.Response
	request *UpdateDiscussionLegacyReq
	Data    components.TeamDiscussion
}

/*
UpdateInOrg performs requests for "teams/update-in-org"

Update a team.

  PATCH /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#update-a-team
*/
func UpdateInOrg(ctx context.Context, req *UpdateInOrgReq, opt ...options.Option) (*UpdateInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateInOrgReq)
	}
	resp := &UpdateInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateInOrg performs requests for "teams/update-in-org"

Update a team.

  PATCH /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#update-a-team
*/
func (c Client) UpdateInOrg(ctx context.Context, req *UpdateInOrgReq, opt ...options.Option) (*UpdateInOrgResponse, error) {
	return UpdateInOrg(ctx, req, append(c, opt...)...)
}

/*
UpdateInOrgReq is request data for Client.UpdateInOrg

https://developer.github.com/v3/teams/#update-a-team
*/
type UpdateInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	RequestBody UpdateInOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateInOrgReq) Rel(link string, resp *UpdateInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateInOrgReqBody is a request body for teams/update-in-org

https://developer.github.com/v3/teams/#update-a-team
*/
type UpdateInOrgReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	**Deprecated**. The permission that new repositories will be added to the team
	with when none is specified. Can be one of:
	\* `pull` - team members can pull, but not push to or administer newly-added
	repositories.
	\* `push` - team members can pull and push, but not administer newly-added
	repositories.
	\* `admin` - team members can pull, push and administer newly-added
	repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	The level of privacy this team should have. Editing teams without specifying
	this parameter leaves `privacy` intact. When a team is nested, the `privacy` for
	parent teams cannot be `secret`. The options are:
	**For a non-nested team:**
	\* `secret` - only visible to organization owners and members of this team.
	\* `closed` - visible to all members of this organization.
	**For a parent or child team:**
	\* `closed` - visible to all members of this organization.
	*/
	Privacy *string `json:"privacy,omitempty"`
}

/*
UpdateInOrgResponse is a response for UpdateInOrg

https://developer.github.com/v3/teams/#update-a-team
*/
type UpdateInOrgResponse struct {
	common.Response
	request *UpdateInOrgReq
	Data    components.TeamFull
}

/*
UpdateLegacy performs requests for "teams/update-legacy"

Update a team (Legacy).

  PATCH /teams/{team_id}

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
func UpdateLegacy(ctx context.Context, req *UpdateLegacyReq, opt ...options.Option) (*UpdateLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateLegacyReq)
	}
	resp := &UpdateLegacyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateLegacy performs requests for "teams/update-legacy"

Update a team (Legacy).

  PATCH /teams/{team_id}

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
func (c Client) UpdateLegacy(ctx context.Context, req *UpdateLegacyReq, opt ...options.Option) (*UpdateLegacyResponse, error) {
	return UpdateLegacy(ctx, req, append(c, opt...)...)
}

/*
UpdateLegacyReq is request data for Client.UpdateLegacy

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
type UpdateLegacyReq struct {
	_url        string
	TeamId      int64
	RequestBody UpdateLegacyReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateLegacyReq) Rel(link string, resp *UpdateLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateLegacyReqBody is a request body for teams/update-legacy

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
type UpdateLegacyReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	**Deprecated**. The permission that new repositories will be added to the team
	with when none is specified. Can be one of:
	\* `pull` - team members can pull, but not push to or administer newly-added
	repositories.
	\* `push` - team members can pull and push, but not administer newly-added
	repositories.
	\* `admin` - team members can pull, push and administer newly-added
	repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	The level of privacy this team should have. Editing teams without specifying
	this parameter leaves `privacy` intact. The options are:
	**For a non-nested team:**
	\* `secret` - only visible to organization owners and members of this team.
	\* `closed` - visible to all members of this organization.
	**For a parent or child team:**
	\* `closed` - visible to all members of this organization.
	*/
	Privacy *string `json:"privacy,omitempty"`
}

/*
UpdateLegacyResponse is a response for UpdateLegacy

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
type UpdateLegacyResponse struct {
	common.Response
	request *UpdateLegacyReq
	Data    components.TeamFull
}
