// Code generated by octo-go; DO NOT EDIT.

package teams

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
AddMemberLegacy performs requests for "teams/add-member-legacy"

Add team member (Legacy).

  PUT /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
func AddMemberLegacy(ctx context.Context, req *AddMemberLegacyReq, opt ...requests.Option) (*AddMemberLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddMemberLegacyReq)
	}
	resp := &AddMemberLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewAddMemberLegacyResponse(r, opts.PreserveResponseBody())
}

// NewAddMemberLegacyResponse builds a new *AddMemberLegacyResponse from an *http.Response
func NewAddMemberLegacyResponse(resp *http.Response, preserveBody bool) (*AddMemberLegacyResponse, error) {
	var result AddMemberLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
AddMemberLegacy performs requests for "teams/add-member-legacy"

Add team member (Legacy).

  PUT /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
func (c Client) AddMemberLegacy(ctx context.Context, req *AddMemberLegacyReq, opt ...requests.Option) (*AddMemberLegacyResponse, error) {
	return AddMemberLegacy(ctx, req, append(c, opt...)...)
}

/*
AddMemberLegacyReq is request data for Client.AddMemberLegacy

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
type AddMemberLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *AddMemberLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddMemberLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "teams/add-member-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/members/%v", r.TeamId, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddMemberLegacyReq) Rel(link string, resp *AddMemberLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddMemberLegacyResponse is a response for AddMemberLegacy

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
type AddMemberLegacyResponse struct {
	httpResponse *http.Response
}

func (r *AddMemberLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
AddOrUpdateMembershipForUserInOrg performs requests for "teams/add-or-update-membership-for-user-in-org"

Add or update team membership for a user.

  PUT /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
func AddOrUpdateMembershipForUserInOrg(ctx context.Context, req *AddOrUpdateMembershipForUserInOrgReq, opt ...requests.Option) (*AddOrUpdateMembershipForUserInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddOrUpdateMembershipForUserInOrgReq)
	}
	resp := &AddOrUpdateMembershipForUserInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewAddOrUpdateMembershipForUserInOrgResponse(r, opts.PreserveResponseBody())
}

// NewAddOrUpdateMembershipForUserInOrgResponse builds a new *AddOrUpdateMembershipForUserInOrgResponse from an *http.Response
func NewAddOrUpdateMembershipForUserInOrgResponse(resp *http.Response, preserveBody bool) (*AddOrUpdateMembershipForUserInOrgResponse, error) {
	var result AddOrUpdateMembershipForUserInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
AddOrUpdateMembershipForUserInOrg performs requests for "teams/add-or-update-membership-for-user-in-org"

Add or update team membership for a user.

  PUT /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
func (c Client) AddOrUpdateMembershipForUserInOrg(ctx context.Context, req *AddOrUpdateMembershipForUserInOrgReq, opt ...requests.Option) (*AddOrUpdateMembershipForUserInOrgResponse, error) {
	return AddOrUpdateMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
AddOrUpdateMembershipForUserInOrgReq is request data for Client.AddOrUpdateMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type AddOrUpdateMembershipForUserInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	Username    string
	RequestBody AddOrUpdateMembershipForUserInOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddOrUpdateMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddOrUpdateMembershipForUserInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-membership-for-user-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddOrUpdateMembershipForUserInOrgReq) Rel(link string, resp *AddOrUpdateMembershipForUserInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddOrUpdateMembershipForUserInOrgReqBody is a request body for teams/add-or-update-membership-for-user-in-org

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type AddOrUpdateMembershipForUserInOrgReqBody struct {

	/*
	The role that this user should have in the team. Can be one of:
	\* `member` - a normal member of the team.
	\* `maintainer` - a team maintainer. Able to add/remove other team members,
	promote other team members to team maintainer, and edit the team's name and
	description.
	*/
	Role *string `json:"role,omitempty"`
}

/*
AddOrUpdateMembershipForUserInOrgResponse is a response for AddOrUpdateMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type AddOrUpdateMembershipForUserInOrgResponse struct {
	httpResponse *http.Response
	Data         components.TeamMembership
}

func (r *AddOrUpdateMembershipForUserInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
AddOrUpdateMembershipForUserLegacy performs requests for "teams/add-or-update-membership-for-user-legacy"

Add or update team membership for a user (Legacy).

  PUT /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
func AddOrUpdateMembershipForUserLegacy(ctx context.Context, req *AddOrUpdateMembershipForUserLegacyReq, opt ...requests.Option) (*AddOrUpdateMembershipForUserLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddOrUpdateMembershipForUserLegacyReq)
	}
	resp := &AddOrUpdateMembershipForUserLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewAddOrUpdateMembershipForUserLegacyResponse(r, opts.PreserveResponseBody())
}

// NewAddOrUpdateMembershipForUserLegacyResponse builds a new *AddOrUpdateMembershipForUserLegacyResponse from an *http.Response
func NewAddOrUpdateMembershipForUserLegacyResponse(resp *http.Response, preserveBody bool) (*AddOrUpdateMembershipForUserLegacyResponse, error) {
	var result AddOrUpdateMembershipForUserLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
AddOrUpdateMembershipForUserLegacy performs requests for "teams/add-or-update-membership-for-user-legacy"

Add or update team membership for a user (Legacy).

  PUT /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
func (c Client) AddOrUpdateMembershipForUserLegacy(ctx context.Context, req *AddOrUpdateMembershipForUserLegacyReq, opt ...requests.Option) (*AddOrUpdateMembershipForUserLegacyResponse, error) {
	return AddOrUpdateMembershipForUserLegacy(ctx, req, append(c, opt...)...)
}

/*
AddOrUpdateMembershipForUserLegacyReq is request data for Client.AddOrUpdateMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
type AddOrUpdateMembershipForUserLegacyReq struct {
	_url        string
	TeamId      int64
	Username    string
	RequestBody AddOrUpdateMembershipForUserLegacyReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddOrUpdateMembershipForUserLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddOrUpdateMembershipForUserLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-membership-for-user-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/memberships/%v", r.TeamId, r.Username),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddOrUpdateMembershipForUserLegacyReq) Rel(link string, resp *AddOrUpdateMembershipForUserLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddOrUpdateMembershipForUserLegacyReqBody is a request body for teams/add-or-update-membership-for-user-legacy

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
type AddOrUpdateMembershipForUserLegacyReqBody struct {

	/*
	The role that this user should have in the team. Can be one of:
	\* `member` - a normal member of the team.
	\* `maintainer` - a team maintainer. Able to add/remove other team members,
	promote other team members to team maintainer, and edit the team's name and
	description.
	*/
	Role *string `json:"role,omitempty"`
}

/*
AddOrUpdateMembershipForUserLegacyResponse is a response for AddOrUpdateMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
type AddOrUpdateMembershipForUserLegacyResponse struct {
	httpResponse *http.Response
	Data         components.TeamMembership
}

func (r *AddOrUpdateMembershipForUserLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
AddOrUpdateProjectPermissionsInOrg performs requests for "teams/add-or-update-project-permissions-in-org"

Add or update team project permissions.

  PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
func AddOrUpdateProjectPermissionsInOrg(ctx context.Context, req *AddOrUpdateProjectPermissionsInOrgReq, opt ...requests.Option) (*AddOrUpdateProjectPermissionsInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddOrUpdateProjectPermissionsInOrgReq)
	}
	resp := &AddOrUpdateProjectPermissionsInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewAddOrUpdateProjectPermissionsInOrgResponse(r, opts.PreserveResponseBody())
}

// NewAddOrUpdateProjectPermissionsInOrgResponse builds a new *AddOrUpdateProjectPermissionsInOrgResponse from an *http.Response
func NewAddOrUpdateProjectPermissionsInOrgResponse(resp *http.Response, preserveBody bool) (*AddOrUpdateProjectPermissionsInOrgResponse, error) {
	var result AddOrUpdateProjectPermissionsInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
AddOrUpdateProjectPermissionsInOrg performs requests for "teams/add-or-update-project-permissions-in-org"

Add or update team project permissions.

  PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
func (c Client) AddOrUpdateProjectPermissionsInOrg(ctx context.Context, req *AddOrUpdateProjectPermissionsInOrgReq, opt ...requests.Option) (*AddOrUpdateProjectPermissionsInOrgResponse, error) {
	return AddOrUpdateProjectPermissionsInOrg(ctx, req, append(c, opt...)...)
}

/*
AddOrUpdateProjectPermissionsInOrgReq is request data for Client.AddOrUpdateProjectPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type AddOrUpdateProjectPermissionsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	ProjectId   int64
	RequestBody AddOrUpdateProjectPermissionsInOrgReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AddOrUpdateProjectPermissionsInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddOrUpdateProjectPermissionsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"inertia"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "PUT",
		OperationID:        "teams/add-or-update-project-permissions-in-org",
		Previews:           map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews:   []string{"inertia"},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddOrUpdateProjectPermissionsInOrgReq) Rel(link string, resp *AddOrUpdateProjectPermissionsInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddOrUpdateProjectPermissionsInOrgReqBody is a request body for teams/add-or-update-project-permissions-in-org

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type AddOrUpdateProjectPermissionsInOrgReqBody struct {

	/*
	The permission to grant to the team for this project. Can be one of:
	\* `read` - team members can read, but not write to or administer this project.
	\* `write` - team members can read and write, but not administer this project.
	\* `admin` - team members can read, write and administer this project.
	Default: the team's `permission` attribute will be used to determine what
	permission to grant the team on this project. Note that, if you choose not to
	pass any parameters, you'll need to set `Content-Length` to zero when calling
	out to this endpoint. For more information, see "[HTTP
	verbs](https://developer.github.com/v3/#http-verbs)."
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
AddOrUpdateProjectPermissionsInOrgResponse is a response for AddOrUpdateProjectPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type AddOrUpdateProjectPermissionsInOrgResponse struct {
	httpResponse *http.Response
}

func (r *AddOrUpdateProjectPermissionsInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
AddOrUpdateProjectPermissionsLegacy performs requests for "teams/add-or-update-project-permissions-legacy"

Add or update team project permissions (Legacy).

  PUT /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
func AddOrUpdateProjectPermissionsLegacy(ctx context.Context, req *AddOrUpdateProjectPermissionsLegacyReq, opt ...requests.Option) (*AddOrUpdateProjectPermissionsLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddOrUpdateProjectPermissionsLegacyReq)
	}
	resp := &AddOrUpdateProjectPermissionsLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewAddOrUpdateProjectPermissionsLegacyResponse(r, opts.PreserveResponseBody())
}

// NewAddOrUpdateProjectPermissionsLegacyResponse builds a new *AddOrUpdateProjectPermissionsLegacyResponse from an *http.Response
func NewAddOrUpdateProjectPermissionsLegacyResponse(resp *http.Response, preserveBody bool) (*AddOrUpdateProjectPermissionsLegacyResponse, error) {
	var result AddOrUpdateProjectPermissionsLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
AddOrUpdateProjectPermissionsLegacy performs requests for "teams/add-or-update-project-permissions-legacy"

Add or update team project permissions (Legacy).

  PUT /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
func (c Client) AddOrUpdateProjectPermissionsLegacy(ctx context.Context, req *AddOrUpdateProjectPermissionsLegacyReq, opt ...requests.Option) (*AddOrUpdateProjectPermissionsLegacyResponse, error) {
	return AddOrUpdateProjectPermissionsLegacy(ctx, req, append(c, opt...)...)
}

/*
AddOrUpdateProjectPermissionsLegacyReq is request data for Client.AddOrUpdateProjectPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
type AddOrUpdateProjectPermissionsLegacyReq struct {
	_url        string
	TeamId      int64
	ProjectId   int64
	RequestBody AddOrUpdateProjectPermissionsLegacyReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AddOrUpdateProjectPermissionsLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddOrUpdateProjectPermissionsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"inertia"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "PUT",
		OperationID:        "teams/add-or-update-project-permissions-legacy",
		Previews:           map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews:   []string{"inertia"},
		URLPath:            fmt.Sprintf("/teams/%v/projects/%v", r.TeamId, r.ProjectId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddOrUpdateProjectPermissionsLegacyReq) Rel(link string, resp *AddOrUpdateProjectPermissionsLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddOrUpdateProjectPermissionsLegacyReqBody is a request body for teams/add-or-update-project-permissions-legacy

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
type AddOrUpdateProjectPermissionsLegacyReqBody struct {

	/*
	The permission to grant to the team for this project. Can be one of:
	\* `read` - team members can read, but not write to or administer this project.
	\* `write` - team members can read and write, but not administer this project.
	\* `admin` - team members can read, write and administer this project.
	Default: the team's `permission` attribute will be used to determine what
	permission to grant the team on this project. Note that, if you choose not to
	pass any parameters, you'll need to set `Content-Length` to zero when calling
	out to this endpoint. For more information, see "[HTTP
	verbs](https://developer.github.com/v3/#http-verbs)."
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
AddOrUpdateProjectPermissionsLegacyResponse is a response for AddOrUpdateProjectPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
type AddOrUpdateProjectPermissionsLegacyResponse struct {
	httpResponse *http.Response
}

func (r *AddOrUpdateProjectPermissionsLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
AddOrUpdateRepoPermissionsInOrg performs requests for "teams/add-or-update-repo-permissions-in-org"

Add or update team repository permissions.

  PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
func AddOrUpdateRepoPermissionsInOrg(ctx context.Context, req *AddOrUpdateRepoPermissionsInOrgReq, opt ...requests.Option) (*AddOrUpdateRepoPermissionsInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddOrUpdateRepoPermissionsInOrgReq)
	}
	resp := &AddOrUpdateRepoPermissionsInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewAddOrUpdateRepoPermissionsInOrgResponse(r, opts.PreserveResponseBody())
}

// NewAddOrUpdateRepoPermissionsInOrgResponse builds a new *AddOrUpdateRepoPermissionsInOrgResponse from an *http.Response
func NewAddOrUpdateRepoPermissionsInOrgResponse(resp *http.Response, preserveBody bool) (*AddOrUpdateRepoPermissionsInOrgResponse, error) {
	var result AddOrUpdateRepoPermissionsInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
AddOrUpdateRepoPermissionsInOrg performs requests for "teams/add-or-update-repo-permissions-in-org"

Add or update team repository permissions.

  PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
func (c Client) AddOrUpdateRepoPermissionsInOrg(ctx context.Context, req *AddOrUpdateRepoPermissionsInOrgReq, opt ...requests.Option) (*AddOrUpdateRepoPermissionsInOrgResponse, error) {
	return AddOrUpdateRepoPermissionsInOrg(ctx, req, append(c, opt...)...)
}

/*
AddOrUpdateRepoPermissionsInOrgReq is request data for Client.AddOrUpdateRepoPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type AddOrUpdateRepoPermissionsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	Owner       string
	Repo        string
	RequestBody AddOrUpdateRepoPermissionsInOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddOrUpdateRepoPermissionsInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddOrUpdateRepoPermissionsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "PUT",
		OperationID:        "teams/add-or-update-repo-permissions-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddOrUpdateRepoPermissionsInOrgReq) Rel(link string, resp *AddOrUpdateRepoPermissionsInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddOrUpdateRepoPermissionsInOrgReqBody is a request body for teams/add-or-update-repo-permissions-in-org

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type AddOrUpdateRepoPermissionsInOrgReqBody struct {

	/*
	The permission to grant the team on this repository. Can be one of:
	\* `pull` - team members can pull, but not push to or administer this
	repository.
	\* `push` - team members can pull and push, but not administer this repository.
	\* `admin` - team members can pull, push and administer this repository.
	\* `maintain` - team members can manage the repository without access to
	sensitive or destructive actions. Recommended for project managers. Only applies
	to repositories owned by organizations.
	\* `triage` - team members can proactively manage issues and pull requests
	without write access. Recommended for contributors who triage a repository. Only
	applies to repositories owned by organizations.

	If no permission is specified, the team's `permission` attribute will be used to
	determine what permission to grant the team on this repository.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
AddOrUpdateRepoPermissionsInOrgResponse is a response for AddOrUpdateRepoPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type AddOrUpdateRepoPermissionsInOrgResponse struct {
	httpResponse *http.Response
}

func (r *AddOrUpdateRepoPermissionsInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
AddOrUpdateRepoPermissionsLegacy performs requests for "teams/add-or-update-repo-permissions-legacy"

Add or update team repository permissions (Legacy).

  PUT /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
func AddOrUpdateRepoPermissionsLegacy(ctx context.Context, req *AddOrUpdateRepoPermissionsLegacyReq, opt ...requests.Option) (*AddOrUpdateRepoPermissionsLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddOrUpdateRepoPermissionsLegacyReq)
	}
	resp := &AddOrUpdateRepoPermissionsLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewAddOrUpdateRepoPermissionsLegacyResponse(r, opts.PreserveResponseBody())
}

// NewAddOrUpdateRepoPermissionsLegacyResponse builds a new *AddOrUpdateRepoPermissionsLegacyResponse from an *http.Response
func NewAddOrUpdateRepoPermissionsLegacyResponse(resp *http.Response, preserveBody bool) (*AddOrUpdateRepoPermissionsLegacyResponse, error) {
	var result AddOrUpdateRepoPermissionsLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
AddOrUpdateRepoPermissionsLegacy performs requests for "teams/add-or-update-repo-permissions-legacy"

Add or update team repository permissions (Legacy).

  PUT /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
func (c Client) AddOrUpdateRepoPermissionsLegacy(ctx context.Context, req *AddOrUpdateRepoPermissionsLegacyReq, opt ...requests.Option) (*AddOrUpdateRepoPermissionsLegacyResponse, error) {
	return AddOrUpdateRepoPermissionsLegacy(ctx, req, append(c, opt...)...)
}

/*
AddOrUpdateRepoPermissionsLegacyReq is request data for Client.AddOrUpdateRepoPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
type AddOrUpdateRepoPermissionsLegacyReq struct {
	_url        string
	TeamId      int64
	Owner       string
	Repo        string
	RequestBody AddOrUpdateRepoPermissionsLegacyReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddOrUpdateRepoPermissionsLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddOrUpdateRepoPermissionsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "PUT",
		OperationID:        "teams/add-or-update-repo-permissions-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/repos/%v/%v", r.TeamId, r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddOrUpdateRepoPermissionsLegacyReq) Rel(link string, resp *AddOrUpdateRepoPermissionsLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddOrUpdateRepoPermissionsLegacyReqBody is a request body for teams/add-or-update-repo-permissions-legacy

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
type AddOrUpdateRepoPermissionsLegacyReqBody struct {

	/*
	The permission to grant the team on this repository. Can be one of:
	\* `pull` - team members can pull, but not push to or administer this
	repository.
	\* `push` - team members can pull and push, but not administer this repository.
	\* `admin` - team members can pull, push and administer this repository.

	If no permission is specified, the team's `permission` attribute will be used to
	determine what permission to grant the team on this repository.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
AddOrUpdateRepoPermissionsLegacyResponse is a response for AddOrUpdateRepoPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
type AddOrUpdateRepoPermissionsLegacyResponse struct {
	httpResponse *http.Response
}

func (r *AddOrUpdateRepoPermissionsLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CheckPermissionsForProjectInOrg performs requests for "teams/check-permissions-for-project-in-org"

Check team permissions for a project.

  GET /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
func CheckPermissionsForProjectInOrg(ctx context.Context, req *CheckPermissionsForProjectInOrgReq, opt ...requests.Option) (*CheckPermissionsForProjectInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckPermissionsForProjectInOrgReq)
	}
	resp := &CheckPermissionsForProjectInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckPermissionsForProjectInOrgResponse(r, opts.PreserveResponseBody())
}

// NewCheckPermissionsForProjectInOrgResponse builds a new *CheckPermissionsForProjectInOrgResponse from an *http.Response
func NewCheckPermissionsForProjectInOrgResponse(resp *http.Response, preserveBody bool) (*CheckPermissionsForProjectInOrgResponse, error) {
	var result CheckPermissionsForProjectInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CheckPermissionsForProjectInOrg performs requests for "teams/check-permissions-for-project-in-org"

Check team permissions for a project.

  GET /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
func (c Client) CheckPermissionsForProjectInOrg(ctx context.Context, req *CheckPermissionsForProjectInOrgReq, opt ...requests.Option) (*CheckPermissionsForProjectInOrgResponse, error) {
	return CheckPermissionsForProjectInOrg(ctx, req, append(c, opt...)...)
}

/*
CheckPermissionsForProjectInOrgReq is request data for Client.CheckPermissionsForProjectInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
type CheckPermissionsForProjectInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug  string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CheckPermissionsForProjectInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckPermissionsForProjectInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"inertia"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/check-permissions-for-project-in-org",
		Previews:           map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews:   []string{"inertia"},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckPermissionsForProjectInOrgReq) Rel(link string, resp *CheckPermissionsForProjectInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckPermissionsForProjectInOrgResponse is a response for CheckPermissionsForProjectInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
type CheckPermissionsForProjectInOrgResponse struct {
	httpResponse *http.Response
	Data         components.TeamProject
}

func (r *CheckPermissionsForProjectInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CheckPermissionsForProjectLegacy performs requests for "teams/check-permissions-for-project-legacy"

Check team permissions for a project (Legacy).

  GET /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
func CheckPermissionsForProjectLegacy(ctx context.Context, req *CheckPermissionsForProjectLegacyReq, opt ...requests.Option) (*CheckPermissionsForProjectLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckPermissionsForProjectLegacyReq)
	}
	resp := &CheckPermissionsForProjectLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckPermissionsForProjectLegacyResponse(r, opts.PreserveResponseBody())
}

// NewCheckPermissionsForProjectLegacyResponse builds a new *CheckPermissionsForProjectLegacyResponse from an *http.Response
func NewCheckPermissionsForProjectLegacyResponse(resp *http.Response, preserveBody bool) (*CheckPermissionsForProjectLegacyResponse, error) {
	var result CheckPermissionsForProjectLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CheckPermissionsForProjectLegacy performs requests for "teams/check-permissions-for-project-legacy"

Check team permissions for a project (Legacy).

  GET /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
func (c Client) CheckPermissionsForProjectLegacy(ctx context.Context, req *CheckPermissionsForProjectLegacyReq, opt ...requests.Option) (*CheckPermissionsForProjectLegacyResponse, error) {
	return CheckPermissionsForProjectLegacy(ctx, req, append(c, opt...)...)
}

/*
CheckPermissionsForProjectLegacyReq is request data for Client.CheckPermissionsForProjectLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
type CheckPermissionsForProjectLegacyReq struct {
	_url      string
	TeamId    int64
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CheckPermissionsForProjectLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckPermissionsForProjectLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"inertia"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/check-permissions-for-project-legacy",
		Previews:           map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews:   []string{"inertia"},
		URLPath:            fmt.Sprintf("/teams/%v/projects/%v", r.TeamId, r.ProjectId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckPermissionsForProjectLegacyReq) Rel(link string, resp *CheckPermissionsForProjectLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckPermissionsForProjectLegacyResponse is a response for CheckPermissionsForProjectLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
type CheckPermissionsForProjectLegacyResponse struct {
	httpResponse *http.Response
	Data         components.TeamProject
}

func (r *CheckPermissionsForProjectLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CheckPermissionsForRepoInOrg performs requests for "teams/check-permissions-for-repo-in-org"

Check team permissions for a repository.

  GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
func CheckPermissionsForRepoInOrg(ctx context.Context, req *CheckPermissionsForRepoInOrgReq, opt ...requests.Option) (*CheckPermissionsForRepoInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckPermissionsForRepoInOrgReq)
	}
	resp := &CheckPermissionsForRepoInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckPermissionsForRepoInOrgResponse(r, opts.PreserveResponseBody())
}

// NewCheckPermissionsForRepoInOrgResponse builds a new *CheckPermissionsForRepoInOrgResponse from an *http.Response
func NewCheckPermissionsForRepoInOrgResponse(resp *http.Response, preserveBody bool) (*CheckPermissionsForRepoInOrgResponse, error) {
	var result CheckPermissionsForRepoInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 204})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CheckPermissionsForRepoInOrg performs requests for "teams/check-permissions-for-repo-in-org"

Check team permissions for a repository.

  GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
func (c Client) CheckPermissionsForRepoInOrg(ctx context.Context, req *CheckPermissionsForRepoInOrgReq, opt ...requests.Option) (*CheckPermissionsForRepoInOrgResponse, error) {
	return CheckPermissionsForRepoInOrg(ctx, req, append(c, opt...)...)
}

/*
CheckPermissionsForRepoInOrgReq is request data for Client.CheckPermissionsForRepoInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
type CheckPermissionsForRepoInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
	Owner    string
	Repo     string
}

// HTTPRequest builds an *http.Request
func (r *CheckPermissionsForRepoInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckPermissionsForRepoInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/vnd.github.v3.repository+json")},
		Method:             "GET",
		OperationID:        "teams/check-permissions-for-repo-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckPermissionsForRepoInOrgReq) Rel(link string, resp *CheckPermissionsForRepoInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckPermissionsForRepoInOrgResponse is a response for CheckPermissionsForRepoInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
type CheckPermissionsForRepoInOrgResponse struct {
	httpResponse *http.Response
	Data         components.TeamRepository
}

func (r *CheckPermissionsForRepoInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CheckPermissionsForRepoLegacy performs requests for "teams/check-permissions-for-repo-legacy"

Check team permissions for a repository (Legacy).

  GET /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
func CheckPermissionsForRepoLegacy(ctx context.Context, req *CheckPermissionsForRepoLegacyReq, opt ...requests.Option) (*CheckPermissionsForRepoLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckPermissionsForRepoLegacyReq)
	}
	resp := &CheckPermissionsForRepoLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckPermissionsForRepoLegacyResponse(r, opts.PreserveResponseBody())
}

// NewCheckPermissionsForRepoLegacyResponse builds a new *CheckPermissionsForRepoLegacyResponse from an *http.Response
func NewCheckPermissionsForRepoLegacyResponse(resp *http.Response, preserveBody bool) (*CheckPermissionsForRepoLegacyResponse, error) {
	var result CheckPermissionsForRepoLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 204})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CheckPermissionsForRepoLegacy performs requests for "teams/check-permissions-for-repo-legacy"

Check team permissions for a repository (Legacy).

  GET /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
func (c Client) CheckPermissionsForRepoLegacy(ctx context.Context, req *CheckPermissionsForRepoLegacyReq, opt ...requests.Option) (*CheckPermissionsForRepoLegacyResponse, error) {
	return CheckPermissionsForRepoLegacy(ctx, req, append(c, opt...)...)
}

/*
CheckPermissionsForRepoLegacyReq is request data for Client.CheckPermissionsForRepoLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
type CheckPermissionsForRepoLegacyReq struct {
	_url   string
	TeamId int64
	Owner  string
	Repo   string
}

// HTTPRequest builds an *http.Request
func (r *CheckPermissionsForRepoLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckPermissionsForRepoLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/vnd.github.v3.repository+json")},
		Method:             "GET",
		OperationID:        "teams/check-permissions-for-repo-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/repos/%v/%v", r.TeamId, r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckPermissionsForRepoLegacyReq) Rel(link string, resp *CheckPermissionsForRepoLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckPermissionsForRepoLegacyResponse is a response for CheckPermissionsForRepoLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
type CheckPermissionsForRepoLegacyResponse struct {
	httpResponse *http.Response
	Data         components.TeamRepository
}

func (r *CheckPermissionsForRepoLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Create performs requests for "teams/create"

Create a team.

  POST /orgs/{org}/teams

https://developer.github.com/v3/teams/#create-a-team
*/
func Create(ctx context.Context, req *CreateReq, opt ...requests.Option) (*CreateResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateReq)
	}
	resp := &CreateResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateResponse(r, opts.PreserveResponseBody())
}

// NewCreateResponse builds a new *CreateResponse from an *http.Response
func NewCreateResponse(resp *http.Response, preserveBody bool) (*CreateResponse, error) {
	var result CreateResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
Create performs requests for "teams/create"

Create a team.

  POST /orgs/{org}/teams

https://developer.github.com/v3/teams/#create-a-team
*/
func (c Client) Create(ctx context.Context, req *CreateReq, opt ...requests.Option) (*CreateResponse, error) {
	return Create(ctx, req, append(c, opt...)...)
}

/*
CreateReq is request data for Client.Create

https://developer.github.com/v3/teams/#create-a-team
*/
type CreateReq struct {
	_url        string
	Org         string
	RequestBody CreateReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams", r.Org),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateReq) Rel(link string, resp *CreateResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateReqBody is a request body for teams/create

https://developer.github.com/v3/teams/#create-a-team
*/
type CreateReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// List GitHub IDs for organization members who will become team maintainers.
	Maintainers []string `json:"maintainers,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	**Deprecated**. The permission that new repositories will be added to the team
	with when none is specified. Can be one of:
	\* `pull` - team members can pull, but not push to or administer newly-added
	repositories.
	\* `push` - team members can pull and push, but not administer newly-added
	repositories.
	\* `admin` - team members can pull, push and administer newly-added
	repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	The level of privacy this team should have. The options are:
	**For a non-nested team:**
	\* `secret` - only visible to organization owners and members of this team.
	\* `closed` - visible to all members of this organization.
	Default: `secret`
	**For a parent or child team:**
	\* `closed` - visible to all members of this organization.
	Default for child team: `closed`
	*/
	Privacy *string `json:"privacy,omitempty"`

	// The full name (e.g., "organization-name/repository-name") of repositories to add the team to.
	RepoNames []string `json:"repo_names,omitempty"`
}

/*
CreateResponse is a response for Create

https://developer.github.com/v3/teams/#create-a-team
*/
type CreateResponse struct {
	httpResponse *http.Response
	Data         components.TeamFull
}

func (r *CreateResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateDiscussionCommentInOrg performs requests for "teams/create-discussion-comment-in-org"

Create a discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
func CreateDiscussionCommentInOrg(ctx context.Context, req *CreateDiscussionCommentInOrgReq, opt ...requests.Option) (*CreateDiscussionCommentInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateDiscussionCommentInOrgReq)
	}
	resp := &CreateDiscussionCommentInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateDiscussionCommentInOrgResponse(r, opts.PreserveResponseBody())
}

// NewCreateDiscussionCommentInOrgResponse builds a new *CreateDiscussionCommentInOrgResponse from an *http.Response
func NewCreateDiscussionCommentInOrgResponse(resp *http.Response, preserveBody bool) (*CreateDiscussionCommentInOrgResponse, error) {
	var result CreateDiscussionCommentInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateDiscussionCommentInOrg performs requests for "teams/create-discussion-comment-in-org"

Create a discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
func (c Client) CreateDiscussionCommentInOrg(ctx context.Context, req *CreateDiscussionCommentInOrgReq, opt ...requests.Option) (*CreateDiscussionCommentInOrgResponse, error) {
	return CreateDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
CreateDiscussionCommentInOrgReq is request data for Client.CreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type CreateDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      CreateDiscussionCommentInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create-discussion-comment-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateDiscussionCommentInOrgReq) Rel(link string, resp *CreateDiscussionCommentInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateDiscussionCommentInOrgReqBody is a request body for teams/create-discussion-comment-in-org

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type CreateDiscussionCommentInOrgReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
CreateDiscussionCommentInOrgResponse is a response for CreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type CreateDiscussionCommentInOrgResponse struct {
	httpResponse *http.Response
	Data         components.TeamDiscussionComment
}

func (r *CreateDiscussionCommentInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateDiscussionCommentLegacy performs requests for "teams/create-discussion-comment-legacy"

Create a discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
func CreateDiscussionCommentLegacy(ctx context.Context, req *CreateDiscussionCommentLegacyReq, opt ...requests.Option) (*CreateDiscussionCommentLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateDiscussionCommentLegacyReq)
	}
	resp := &CreateDiscussionCommentLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateDiscussionCommentLegacyResponse(r, opts.PreserveResponseBody())
}

// NewCreateDiscussionCommentLegacyResponse builds a new *CreateDiscussionCommentLegacyResponse from an *http.Response
func NewCreateDiscussionCommentLegacyResponse(resp *http.Response, preserveBody bool) (*CreateDiscussionCommentLegacyResponse, error) {
	var result CreateDiscussionCommentLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateDiscussionCommentLegacy performs requests for "teams/create-discussion-comment-legacy"

Create a discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
func (c Client) CreateDiscussionCommentLegacy(ctx context.Context, req *CreateDiscussionCommentLegacyReq, opt ...requests.Option) (*CreateDiscussionCommentLegacyResponse, error) {
	return CreateDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
CreateDiscussionCommentLegacyReq is request data for Client.CreateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
type CreateDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	RequestBody      CreateDiscussionCommentLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create-discussion-comment-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateDiscussionCommentLegacyReq) Rel(link string, resp *CreateDiscussionCommentLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateDiscussionCommentLegacyReqBody is a request body for teams/create-discussion-comment-legacy

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
type CreateDiscussionCommentLegacyReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
CreateDiscussionCommentLegacyResponse is a response for CreateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
type CreateDiscussionCommentLegacyResponse struct {
	httpResponse *http.Response
	Data         components.TeamDiscussionComment
}

func (r *CreateDiscussionCommentLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateDiscussionInOrg performs requests for "teams/create-discussion-in-org"

Create a discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
func CreateDiscussionInOrg(ctx context.Context, req *CreateDiscussionInOrgReq, opt ...requests.Option) (*CreateDiscussionInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateDiscussionInOrgReq)
	}
	resp := &CreateDiscussionInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateDiscussionInOrgResponse(r, opts.PreserveResponseBody())
}

// NewCreateDiscussionInOrgResponse builds a new *CreateDiscussionInOrgResponse from an *http.Response
func NewCreateDiscussionInOrgResponse(resp *http.Response, preserveBody bool) (*CreateDiscussionInOrgResponse, error) {
	var result CreateDiscussionInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateDiscussionInOrg performs requests for "teams/create-discussion-in-org"

Create a discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
func (c Client) CreateDiscussionInOrg(ctx context.Context, req *CreateDiscussionInOrgReq, opt ...requests.Option) (*CreateDiscussionInOrgResponse, error) {
	return CreateDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
CreateDiscussionInOrgReq is request data for Client.CreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type CreateDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	RequestBody CreateDiscussionInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create-discussion-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions", r.Org, r.TeamSlug),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateDiscussionInOrgReq) Rel(link string, resp *CreateDiscussionInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateDiscussionInOrgReqBody is a request body for teams/create-discussion-in-org

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type CreateDiscussionInOrgReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body"`

	/*
	Private posts are only visible to team members, organization owners, and team
	maintainers. Public posts are visible to all members of the organization. Set to
	`true` to create a private post.
	*/
	Private *bool `json:"private,omitempty"`

	// The discussion post's title.
	Title *string `json:"title"`
}

/*
CreateDiscussionInOrgResponse is a response for CreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type CreateDiscussionInOrgResponse struct {
	httpResponse *http.Response
	Data         components.TeamDiscussion
}

func (r *CreateDiscussionInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateDiscussionLegacy performs requests for "teams/create-discussion-legacy"

Create a discussion (Legacy).

  POST /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
func CreateDiscussionLegacy(ctx context.Context, req *CreateDiscussionLegacyReq, opt ...requests.Option) (*CreateDiscussionLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateDiscussionLegacyReq)
	}
	resp := &CreateDiscussionLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateDiscussionLegacyResponse(r, opts.PreserveResponseBody())
}

// NewCreateDiscussionLegacyResponse builds a new *CreateDiscussionLegacyResponse from an *http.Response
func NewCreateDiscussionLegacyResponse(resp *http.Response, preserveBody bool) (*CreateDiscussionLegacyResponse, error) {
	var result CreateDiscussionLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateDiscussionLegacy performs requests for "teams/create-discussion-legacy"

Create a discussion (Legacy).

  POST /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
func (c Client) CreateDiscussionLegacy(ctx context.Context, req *CreateDiscussionLegacyReq, opt ...requests.Option) (*CreateDiscussionLegacyResponse, error) {
	return CreateDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
CreateDiscussionLegacyReq is request data for Client.CreateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
type CreateDiscussionLegacyReq struct {
	_url        string
	TeamId      int64
	RequestBody CreateDiscussionLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create-discussion-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions", r.TeamId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateDiscussionLegacyReq) Rel(link string, resp *CreateDiscussionLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateDiscussionLegacyReqBody is a request body for teams/create-discussion-legacy

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
type CreateDiscussionLegacyReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body"`

	/*
	Private posts are only visible to team members, organization owners, and team
	maintainers. Public posts are visible to all members of the organization. Set to
	`true` to create a private post.
	*/
	Private *bool `json:"private,omitempty"`

	// The discussion post's title.
	Title *string `json:"title"`
}

/*
CreateDiscussionLegacyResponse is a response for CreateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
type CreateDiscussionLegacyResponse struct {
	httpResponse *http.Response
	Data         components.TeamDiscussion
}

func (r *CreateDiscussionLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateOrUpdateIdpGroupConnectionsInOrg performs requests for "teams/create-or-update-idp-group-connections-in-org"

Create or update IdP group connections.

  PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
func CreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, req *CreateOrUpdateIdpGroupConnectionsInOrgReq, opt ...requests.Option) (*CreateOrUpdateIdpGroupConnectionsInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateOrUpdateIdpGroupConnectionsInOrgReq)
	}
	resp := &CreateOrUpdateIdpGroupConnectionsInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateOrUpdateIdpGroupConnectionsInOrgResponse(r, opts.PreserveResponseBody())
}

// NewCreateOrUpdateIdpGroupConnectionsInOrgResponse builds a new *CreateOrUpdateIdpGroupConnectionsInOrgResponse from an *http.Response
func NewCreateOrUpdateIdpGroupConnectionsInOrgResponse(resp *http.Response, preserveBody bool) (*CreateOrUpdateIdpGroupConnectionsInOrgResponse, error) {
	var result CreateOrUpdateIdpGroupConnectionsInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateOrUpdateIdpGroupConnectionsInOrg performs requests for "teams/create-or-update-idp-group-connections-in-org"

Create or update IdP group connections.

  PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
func (c Client) CreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, req *CreateOrUpdateIdpGroupConnectionsInOrgReq, opt ...requests.Option) (*CreateOrUpdateIdpGroupConnectionsInOrgResponse, error) {
	return CreateOrUpdateIdpGroupConnectionsInOrg(ctx, req, append(c, opt...)...)
}

/*
CreateOrUpdateIdpGroupConnectionsInOrgReq is request data for Client.CreateOrUpdateIdpGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type CreateOrUpdateIdpGroupConnectionsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	RequestBody CreateOrUpdateIdpGroupConnectionsInOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateOrUpdateIdpGroupConnectionsInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateOrUpdateIdpGroupConnectionsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/create-or-update-idp-group-connections-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/team-sync/group-mappings", r.Org, r.TeamSlug),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateOrUpdateIdpGroupConnectionsInOrgReq) Rel(link string, resp *CreateOrUpdateIdpGroupConnectionsInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateOrUpdateIdpGroupConnectionsInOrgReqBodyGroups is a value for CreateOrUpdateIdpGroupConnectionsInOrgReqBody's Groups field
type CreateOrUpdateIdpGroupConnectionsInOrgReqBodyGroups struct {

	// Description of the IdP group.
	GroupDescription *string `json:"group_description"`

	// ID of the IdP group.
	GroupId *string `json:"group_id"`

	// Name of the IdP group.
	GroupName *string `json:"group_name"`
}

/*
CreateOrUpdateIdpGroupConnectionsInOrgReqBody is a request body for teams/create-or-update-idp-group-connections-in-org

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type CreateOrUpdateIdpGroupConnectionsInOrgReqBody struct {

	/*
	The IdP groups you want to connect to a GitHub team. When updating, the new
	`groups` object will replace the original one. You must include any existing
	groups that you don't want to remove.
	*/
	Groups []CreateOrUpdateIdpGroupConnectionsInOrgReqBodyGroups `json:"groups"`
}

/*
CreateOrUpdateIdpGroupConnectionsInOrgResponse is a response for CreateOrUpdateIdpGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type CreateOrUpdateIdpGroupConnectionsInOrgResponse struct {
	httpResponse *http.Response
	Data         components.GroupMapping
}

func (r *CreateOrUpdateIdpGroupConnectionsInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateOrUpdateIdpGroupConnectionsLegacy performs requests for "teams/create-or-update-idp-group-connections-legacy"

Create or update IdP group connections (Legacy).

  PATCH /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
func CreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, req *CreateOrUpdateIdpGroupConnectionsLegacyReq, opt ...requests.Option) (*CreateOrUpdateIdpGroupConnectionsLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateOrUpdateIdpGroupConnectionsLegacyReq)
	}
	resp := &CreateOrUpdateIdpGroupConnectionsLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateOrUpdateIdpGroupConnectionsLegacyResponse(r, opts.PreserveResponseBody())
}

// NewCreateOrUpdateIdpGroupConnectionsLegacyResponse builds a new *CreateOrUpdateIdpGroupConnectionsLegacyResponse from an *http.Response
func NewCreateOrUpdateIdpGroupConnectionsLegacyResponse(resp *http.Response, preserveBody bool) (*CreateOrUpdateIdpGroupConnectionsLegacyResponse, error) {
	var result CreateOrUpdateIdpGroupConnectionsLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateOrUpdateIdpGroupConnectionsLegacy performs requests for "teams/create-or-update-idp-group-connections-legacy"

Create or update IdP group connections (Legacy).

  PATCH /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
func (c Client) CreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, req *CreateOrUpdateIdpGroupConnectionsLegacyReq, opt ...requests.Option) (*CreateOrUpdateIdpGroupConnectionsLegacyResponse, error) {
	return CreateOrUpdateIdpGroupConnectionsLegacy(ctx, req, append(c, opt...)...)
}

/*
CreateOrUpdateIdpGroupConnectionsLegacyReq is request data for Client.CreateOrUpdateIdpGroupConnectionsLegacy

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
type CreateOrUpdateIdpGroupConnectionsLegacyReq struct {
	_url        string
	TeamId      int64
	RequestBody CreateOrUpdateIdpGroupConnectionsLegacyReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateOrUpdateIdpGroupConnectionsLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateOrUpdateIdpGroupConnectionsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/create-or-update-idp-group-connections-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/team-sync/group-mappings", r.TeamId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateOrUpdateIdpGroupConnectionsLegacyReq) Rel(link string, resp *CreateOrUpdateIdpGroupConnectionsLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateOrUpdateIdpGroupConnectionsLegacyReqBodyGroups is a value for CreateOrUpdateIdpGroupConnectionsLegacyReqBody's Groups field
type CreateOrUpdateIdpGroupConnectionsLegacyReqBodyGroups struct {
	Description *string `json:"description,omitempty"`

	// Description of the IdP group.
	GroupDescription *string `json:"group_description"`

	// ID of the IdP group.
	GroupId *string `json:"group_id"`

	// Name of the IdP group.
	GroupName *string `json:"group_name"`
	Id        *string `json:"id,omitempty"`
	Name      *string `json:"name,omitempty"`
}

/*
CreateOrUpdateIdpGroupConnectionsLegacyReqBody is a request body for teams/create-or-update-idp-group-connections-legacy

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
type CreateOrUpdateIdpGroupConnectionsLegacyReqBody struct {

	/*
	The IdP groups you want to connect to a GitHub team. When updating, the new
	`groups` object will replace the original one. You must include any existing
	groups that you don't want to remove.
	*/
	Groups   []CreateOrUpdateIdpGroupConnectionsLegacyReqBodyGroups `json:"groups"`
	SyncedAt *string                                                `json:"synced_at,omitempty"`
}

/*
CreateOrUpdateIdpGroupConnectionsLegacyResponse is a response for CreateOrUpdateIdpGroupConnectionsLegacy

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
type CreateOrUpdateIdpGroupConnectionsLegacyResponse struct {
	httpResponse *http.Response
	Data         components.GroupMapping
}

func (r *CreateOrUpdateIdpGroupConnectionsLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteDiscussionCommentInOrg performs requests for "teams/delete-discussion-comment-in-org"

Delete a discussion comment.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
func DeleteDiscussionCommentInOrg(ctx context.Context, req *DeleteDiscussionCommentInOrgReq, opt ...requests.Option) (*DeleteDiscussionCommentInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteDiscussionCommentInOrgReq)
	}
	resp := &DeleteDiscussionCommentInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteDiscussionCommentInOrgResponse(r, opts.PreserveResponseBody())
}

// NewDeleteDiscussionCommentInOrgResponse builds a new *DeleteDiscussionCommentInOrgResponse from an *http.Response
func NewDeleteDiscussionCommentInOrgResponse(resp *http.Response, preserveBody bool) (*DeleteDiscussionCommentInOrgResponse, error) {
	var result DeleteDiscussionCommentInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteDiscussionCommentInOrg performs requests for "teams/delete-discussion-comment-in-org"

Delete a discussion comment.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
func (c Client) DeleteDiscussionCommentInOrg(ctx context.Context, req *DeleteDiscussionCommentInOrgReq, opt ...requests.Option) (*DeleteDiscussionCommentInOrgResponse, error) {
	return DeleteDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
DeleteDiscussionCommentInOrgReq is request data for Client.DeleteDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
type DeleteDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "teams/delete-discussion-comment-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteDiscussionCommentInOrgReq) Rel(link string, resp *DeleteDiscussionCommentInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteDiscussionCommentInOrgResponse is a response for DeleteDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
type DeleteDiscussionCommentInOrgResponse struct {
	httpResponse *http.Response
}

func (r *DeleteDiscussionCommentInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteDiscussionCommentLegacy performs requests for "teams/delete-discussion-comment-legacy"

Delete a discussion comment (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
func DeleteDiscussionCommentLegacy(ctx context.Context, req *DeleteDiscussionCommentLegacyReq, opt ...requests.Option) (*DeleteDiscussionCommentLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteDiscussionCommentLegacyReq)
	}
	resp := &DeleteDiscussionCommentLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteDiscussionCommentLegacyResponse(r, opts.PreserveResponseBody())
}

// NewDeleteDiscussionCommentLegacyResponse builds a new *DeleteDiscussionCommentLegacyResponse from an *http.Response
func NewDeleteDiscussionCommentLegacyResponse(resp *http.Response, preserveBody bool) (*DeleteDiscussionCommentLegacyResponse, error) {
	var result DeleteDiscussionCommentLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteDiscussionCommentLegacy performs requests for "teams/delete-discussion-comment-legacy"

Delete a discussion comment (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
func (c Client) DeleteDiscussionCommentLegacy(ctx context.Context, req *DeleteDiscussionCommentLegacyReq, opt ...requests.Option) (*DeleteDiscussionCommentLegacyResponse, error) {
	return DeleteDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
DeleteDiscussionCommentLegacyReq is request data for Client.DeleteDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
type DeleteDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "teams/delete-discussion-comment-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/discussions/%v/comments/%v", r.TeamId, r.DiscussionNumber, r.CommentNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteDiscussionCommentLegacyReq) Rel(link string, resp *DeleteDiscussionCommentLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteDiscussionCommentLegacyResponse is a response for DeleteDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
type DeleteDiscussionCommentLegacyResponse struct {
	httpResponse *http.Response
}

func (r *DeleteDiscussionCommentLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteDiscussionInOrg performs requests for "teams/delete-discussion-in-org"

Delete a discussion.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
func DeleteDiscussionInOrg(ctx context.Context, req *DeleteDiscussionInOrgReq, opt ...requests.Option) (*DeleteDiscussionInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteDiscussionInOrgReq)
	}
	resp := &DeleteDiscussionInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteDiscussionInOrgResponse(r, opts.PreserveResponseBody())
}

// NewDeleteDiscussionInOrgResponse builds a new *DeleteDiscussionInOrgResponse from an *http.Response
func NewDeleteDiscussionInOrgResponse(resp *http.Response, preserveBody bool) (*DeleteDiscussionInOrgResponse, error) {
	var result DeleteDiscussionInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteDiscussionInOrg performs requests for "teams/delete-discussion-in-org"

Delete a discussion.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
func (c Client) DeleteDiscussionInOrg(ctx context.Context, req *DeleteDiscussionInOrgReq, opt ...requests.Option) (*DeleteDiscussionInOrgResponse, error) {
	return DeleteDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
DeleteDiscussionInOrgReq is request data for Client.DeleteDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
type DeleteDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "teams/delete-discussion-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteDiscussionInOrgReq) Rel(link string, resp *DeleteDiscussionInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteDiscussionInOrgResponse is a response for DeleteDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
type DeleteDiscussionInOrgResponse struct {
	httpResponse *http.Response
}

func (r *DeleteDiscussionInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteDiscussionLegacy performs requests for "teams/delete-discussion-legacy"

Delete a discussion (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
func DeleteDiscussionLegacy(ctx context.Context, req *DeleteDiscussionLegacyReq, opt ...requests.Option) (*DeleteDiscussionLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteDiscussionLegacyReq)
	}
	resp := &DeleteDiscussionLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteDiscussionLegacyResponse(r, opts.PreserveResponseBody())
}

// NewDeleteDiscussionLegacyResponse builds a new *DeleteDiscussionLegacyResponse from an *http.Response
func NewDeleteDiscussionLegacyResponse(resp *http.Response, preserveBody bool) (*DeleteDiscussionLegacyResponse, error) {
	var result DeleteDiscussionLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteDiscussionLegacy performs requests for "teams/delete-discussion-legacy"

Delete a discussion (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
func (c Client) DeleteDiscussionLegacy(ctx context.Context, req *DeleteDiscussionLegacyReq, opt ...requests.Option) (*DeleteDiscussionLegacyResponse, error) {
	return DeleteDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
DeleteDiscussionLegacyReq is request data for Client.DeleteDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
type DeleteDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "teams/delete-discussion-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/discussions/%v", r.TeamId, r.DiscussionNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteDiscussionLegacyReq) Rel(link string, resp *DeleteDiscussionLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteDiscussionLegacyResponse is a response for DeleteDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
type DeleteDiscussionLegacyResponse struct {
	httpResponse *http.Response
}

func (r *DeleteDiscussionLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteInOrg performs requests for "teams/delete-in-org"

Delete a team.

  DELETE /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#delete-a-team
*/
func DeleteInOrg(ctx context.Context, req *DeleteInOrgReq, opt ...requests.Option) (*DeleteInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteInOrgReq)
	}
	resp := &DeleteInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteInOrgResponse(r, opts.PreserveResponseBody())
}

// NewDeleteInOrgResponse builds a new *DeleteInOrgResponse from an *http.Response
func NewDeleteInOrgResponse(resp *http.Response, preserveBody bool) (*DeleteInOrgResponse, error) {
	var result DeleteInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteInOrg performs requests for "teams/delete-in-org"

Delete a team.

  DELETE /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#delete-a-team
*/
func (c Client) DeleteInOrg(ctx context.Context, req *DeleteInOrgReq, opt ...requests.Option) (*DeleteInOrgResponse, error) {
	return DeleteInOrg(ctx, req, append(c, opt...)...)
}

/*
DeleteInOrgReq is request data for Client.DeleteInOrg

https://developer.github.com/v3/teams/#delete-a-team
*/
type DeleteInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
}

// HTTPRequest builds an *http.Request
func (r *DeleteInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "teams/delete-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteInOrgReq) Rel(link string, resp *DeleteInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteInOrgResponse is a response for DeleteInOrg

https://developer.github.com/v3/teams/#delete-a-team
*/
type DeleteInOrgResponse struct {
	httpResponse *http.Response
}

func (r *DeleteInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteLegacy performs requests for "teams/delete-legacy"

Delete a team (Legacy).

  DELETE /teams/{team_id}

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
func DeleteLegacy(ctx context.Context, req *DeleteLegacyReq, opt ...requests.Option) (*DeleteLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteLegacyReq)
	}
	resp := &DeleteLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteLegacyResponse(r, opts.PreserveResponseBody())
}

// NewDeleteLegacyResponse builds a new *DeleteLegacyResponse from an *http.Response
func NewDeleteLegacyResponse(resp *http.Response, preserveBody bool) (*DeleteLegacyResponse, error) {
	var result DeleteLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteLegacy performs requests for "teams/delete-legacy"

Delete a team (Legacy).

  DELETE /teams/{team_id}

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
func (c Client) DeleteLegacy(ctx context.Context, req *DeleteLegacyReq, opt ...requests.Option) (*DeleteLegacyResponse, error) {
	return DeleteLegacy(ctx, req, append(c, opt...)...)
}

/*
DeleteLegacyReq is request data for Client.DeleteLegacy

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
type DeleteLegacyReq struct {
	_url   string
	TeamId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "teams/delete-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v", r.TeamId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteLegacyReq) Rel(link string, resp *DeleteLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteLegacyResponse is a response for DeleteLegacy

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
type DeleteLegacyResponse struct {
	httpResponse *http.Response
}

func (r *DeleteLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetByName performs requests for "teams/get-by-name"

Get a team by name.

  GET /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
func GetByName(ctx context.Context, req *GetByNameReq, opt ...requests.Option) (*GetByNameResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetByNameReq)
	}
	resp := &GetByNameResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetByNameResponse(r, opts.PreserveResponseBody())
}

// NewGetByNameResponse builds a new *GetByNameResponse from an *http.Response
func NewGetByNameResponse(resp *http.Response, preserveBody bool) (*GetByNameResponse, error) {
	var result GetByNameResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetByName performs requests for "teams/get-by-name"

Get a team by name.

  GET /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
func (c Client) GetByName(ctx context.Context, req *GetByNameReq, opt ...requests.Option) (*GetByNameResponse, error) {
	return GetByName(ctx, req, append(c, opt...)...)
}

/*
GetByNameReq is request data for Client.GetByName

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
type GetByNameReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
}

// HTTPRequest builds an *http.Request
func (r *GetByNameReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetByNameReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/get-by-name",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetByNameReq) Rel(link string, resp *GetByNameResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetByNameResponse is a response for GetByName

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
type GetByNameResponse struct {
	httpResponse *http.Response
	Data         components.TeamFull
}

func (r *GetByNameResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetDiscussionCommentInOrg performs requests for "teams/get-discussion-comment-in-org"

Get a discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
func GetDiscussionCommentInOrg(ctx context.Context, req *GetDiscussionCommentInOrgReq, opt ...requests.Option) (*GetDiscussionCommentInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetDiscussionCommentInOrgReq)
	}
	resp := &GetDiscussionCommentInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetDiscussionCommentInOrgResponse(r, opts.PreserveResponseBody())
}

// NewGetDiscussionCommentInOrgResponse builds a new *GetDiscussionCommentInOrgResponse from an *http.Response
func NewGetDiscussionCommentInOrgResponse(resp *http.Response, preserveBody bool) (*GetDiscussionCommentInOrgResponse, error) {
	var result GetDiscussionCommentInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetDiscussionCommentInOrg performs requests for "teams/get-discussion-comment-in-org"

Get a discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
func (c Client) GetDiscussionCommentInOrg(ctx context.Context, req *GetDiscussionCommentInOrgReq, opt ...requests.Option) (*GetDiscussionCommentInOrgResponse, error) {
	return GetDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
GetDiscussionCommentInOrgReq is request data for Client.GetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
type GetDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/get-discussion-comment-in-org",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetDiscussionCommentInOrgReq) Rel(link string, resp *GetDiscussionCommentInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetDiscussionCommentInOrgResponse is a response for GetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
type GetDiscussionCommentInOrgResponse struct {
	httpResponse *http.Response
	Data         components.TeamDiscussionComment
}

func (r *GetDiscussionCommentInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetDiscussionCommentLegacy performs requests for "teams/get-discussion-comment-legacy"

Get a discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
func GetDiscussionCommentLegacy(ctx context.Context, req *GetDiscussionCommentLegacyReq, opt ...requests.Option) (*GetDiscussionCommentLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetDiscussionCommentLegacyReq)
	}
	resp := &GetDiscussionCommentLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetDiscussionCommentLegacyResponse(r, opts.PreserveResponseBody())
}

// NewGetDiscussionCommentLegacyResponse builds a new *GetDiscussionCommentLegacyResponse from an *http.Response
func NewGetDiscussionCommentLegacyResponse(resp *http.Response, preserveBody bool) (*GetDiscussionCommentLegacyResponse, error) {
	var result GetDiscussionCommentLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetDiscussionCommentLegacy performs requests for "teams/get-discussion-comment-legacy"

Get a discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
func (c Client) GetDiscussionCommentLegacy(ctx context.Context, req *GetDiscussionCommentLegacyReq, opt ...requests.Option) (*GetDiscussionCommentLegacyResponse, error) {
	return GetDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
GetDiscussionCommentLegacyReq is request data for Client.GetDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
type GetDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/get-discussion-comment-legacy",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/discussions/%v/comments/%v", r.TeamId, r.DiscussionNumber, r.CommentNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetDiscussionCommentLegacyReq) Rel(link string, resp *GetDiscussionCommentLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetDiscussionCommentLegacyResponse is a response for GetDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
type GetDiscussionCommentLegacyResponse struct {
	httpResponse *http.Response
	Data         components.TeamDiscussionComment
}

func (r *GetDiscussionCommentLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetDiscussionInOrg performs requests for "teams/get-discussion-in-org"

Get a discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
func GetDiscussionInOrg(ctx context.Context, req *GetDiscussionInOrgReq, opt ...requests.Option) (*GetDiscussionInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetDiscussionInOrgReq)
	}
	resp := &GetDiscussionInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetDiscussionInOrgResponse(r, opts.PreserveResponseBody())
}

// NewGetDiscussionInOrgResponse builds a new *GetDiscussionInOrgResponse from an *http.Response
func NewGetDiscussionInOrgResponse(resp *http.Response, preserveBody bool) (*GetDiscussionInOrgResponse, error) {
	var result GetDiscussionInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetDiscussionInOrg performs requests for "teams/get-discussion-in-org"

Get a discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
func (c Client) GetDiscussionInOrg(ctx context.Context, req *GetDiscussionInOrgReq, opt ...requests.Option) (*GetDiscussionInOrgResponse, error) {
	return GetDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
GetDiscussionInOrgReq is request data for Client.GetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
type GetDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/get-discussion-in-org",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetDiscussionInOrgReq) Rel(link string, resp *GetDiscussionInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetDiscussionInOrgResponse is a response for GetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
type GetDiscussionInOrgResponse struct {
	httpResponse *http.Response
	Data         components.TeamDiscussion
}

func (r *GetDiscussionInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetDiscussionLegacy performs requests for "teams/get-discussion-legacy"

Get a discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
func GetDiscussionLegacy(ctx context.Context, req *GetDiscussionLegacyReq, opt ...requests.Option) (*GetDiscussionLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetDiscussionLegacyReq)
	}
	resp := &GetDiscussionLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetDiscussionLegacyResponse(r, opts.PreserveResponseBody())
}

// NewGetDiscussionLegacyResponse builds a new *GetDiscussionLegacyResponse from an *http.Response
func NewGetDiscussionLegacyResponse(resp *http.Response, preserveBody bool) (*GetDiscussionLegacyResponse, error) {
	var result GetDiscussionLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetDiscussionLegacy performs requests for "teams/get-discussion-legacy"

Get a discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
func (c Client) GetDiscussionLegacy(ctx context.Context, req *GetDiscussionLegacyReq, opt ...requests.Option) (*GetDiscussionLegacyResponse, error) {
	return GetDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
GetDiscussionLegacyReq is request data for Client.GetDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
type GetDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/get-discussion-legacy",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/discussions/%v", r.TeamId, r.DiscussionNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetDiscussionLegacyReq) Rel(link string, resp *GetDiscussionLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetDiscussionLegacyResponse is a response for GetDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
type GetDiscussionLegacyResponse struct {
	httpResponse *http.Response
	Data         components.TeamDiscussion
}

func (r *GetDiscussionLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetLegacy performs requests for "teams/get-legacy"

Get a team (Legacy).

  GET /teams/{team_id}

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
func GetLegacy(ctx context.Context, req *GetLegacyReq, opt ...requests.Option) (*GetLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetLegacyReq)
	}
	resp := &GetLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetLegacyResponse(r, opts.PreserveResponseBody())
}

// NewGetLegacyResponse builds a new *GetLegacyResponse from an *http.Response
func NewGetLegacyResponse(resp *http.Response, preserveBody bool) (*GetLegacyResponse, error) {
	var result GetLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetLegacy performs requests for "teams/get-legacy"

Get a team (Legacy).

  GET /teams/{team_id}

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
func (c Client) GetLegacy(ctx context.Context, req *GetLegacyReq, opt ...requests.Option) (*GetLegacyResponse, error) {
	return GetLegacy(ctx, req, append(c, opt...)...)
}

/*
GetLegacyReq is request data for Client.GetLegacy

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
type GetLegacyReq struct {
	_url   string
	TeamId int64
}

// HTTPRequest builds an *http.Request
func (r *GetLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/get-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v", r.TeamId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetLegacyReq) Rel(link string, resp *GetLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetLegacyResponse is a response for GetLegacy

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
type GetLegacyResponse struct {
	httpResponse *http.Response
	Data         components.TeamFull
}

func (r *GetLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetMemberLegacy performs requests for "teams/get-member-legacy"

Get team member (Legacy).

  GET /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
func GetMemberLegacy(ctx context.Context, req *GetMemberLegacyReq, opt ...requests.Option) (*GetMemberLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetMemberLegacyReq)
	}
	resp := &GetMemberLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetMemberLegacyResponse(r, opts.PreserveResponseBody())
}

// NewGetMemberLegacyResponse builds a new *GetMemberLegacyResponse from an *http.Response
func NewGetMemberLegacyResponse(resp *http.Response, preserveBody bool) (*GetMemberLegacyResponse, error) {
	var result GetMemberLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
GetMemberLegacy performs requests for "teams/get-member-legacy"

Get team member (Legacy).

  GET /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
func (c Client) GetMemberLegacy(ctx context.Context, req *GetMemberLegacyReq, opt ...requests.Option) (*GetMemberLegacyResponse, error) {
	return GetMemberLegacy(ctx, req, append(c, opt...)...)
}

/*
GetMemberLegacyReq is request data for Client.GetMemberLegacy

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
type GetMemberLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetMemberLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetMemberLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "teams/get-member-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/members/%v", r.TeamId, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetMemberLegacyReq) Rel(link string, resp *GetMemberLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetMemberLegacyResponse is a response for GetMemberLegacy

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
type GetMemberLegacyResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *GetMemberLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetMembershipForUserInOrg performs requests for "teams/get-membership-for-user-in-org"

Get team membership for a user.

  GET /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
func GetMembershipForUserInOrg(ctx context.Context, req *GetMembershipForUserInOrgReq, opt ...requests.Option) (*GetMembershipForUserInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetMembershipForUserInOrgReq)
	}
	resp := &GetMembershipForUserInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetMembershipForUserInOrgResponse(r, opts.PreserveResponseBody())
}

// NewGetMembershipForUserInOrgResponse builds a new *GetMembershipForUserInOrgResponse from an *http.Response
func NewGetMembershipForUserInOrgResponse(resp *http.Response, preserveBody bool) (*GetMembershipForUserInOrgResponse, error) {
	var result GetMembershipForUserInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetMembershipForUserInOrg performs requests for "teams/get-membership-for-user-in-org"

Get team membership for a user.

  GET /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
func (c Client) GetMembershipForUserInOrg(ctx context.Context, req *GetMembershipForUserInOrgReq, opt ...requests.Option) (*GetMembershipForUserInOrgResponse, error) {
	return GetMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
GetMembershipForUserInOrgReq is request data for Client.GetMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
type GetMembershipForUserInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetMembershipForUserInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/get-membership-for-user-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetMembershipForUserInOrgReq) Rel(link string, resp *GetMembershipForUserInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetMembershipForUserInOrgResponse is a response for GetMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
type GetMembershipForUserInOrgResponse struct {
	httpResponse *http.Response
	Data         components.TeamMembership
}

func (r *GetMembershipForUserInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetMembershipForUserLegacy performs requests for "teams/get-membership-for-user-legacy"

Get team membership for a user (Legacy).

  GET /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
func GetMembershipForUserLegacy(ctx context.Context, req *GetMembershipForUserLegacyReq, opt ...requests.Option) (*GetMembershipForUserLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetMembershipForUserLegacyReq)
	}
	resp := &GetMembershipForUserLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetMembershipForUserLegacyResponse(r, opts.PreserveResponseBody())
}

// NewGetMembershipForUserLegacyResponse builds a new *GetMembershipForUserLegacyResponse from an *http.Response
func NewGetMembershipForUserLegacyResponse(resp *http.Response, preserveBody bool) (*GetMembershipForUserLegacyResponse, error) {
	var result GetMembershipForUserLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetMembershipForUserLegacy performs requests for "teams/get-membership-for-user-legacy"

Get team membership for a user (Legacy).

  GET /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
func (c Client) GetMembershipForUserLegacy(ctx context.Context, req *GetMembershipForUserLegacyReq, opt ...requests.Option) (*GetMembershipForUserLegacyResponse, error) {
	return GetMembershipForUserLegacy(ctx, req, append(c, opt...)...)
}

/*
GetMembershipForUserLegacyReq is request data for Client.GetMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
type GetMembershipForUserLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetMembershipForUserLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetMembershipForUserLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/get-membership-for-user-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/memberships/%v", r.TeamId, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetMembershipForUserLegacyReq) Rel(link string, resp *GetMembershipForUserLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetMembershipForUserLegacyResponse is a response for GetMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
type GetMembershipForUserLegacyResponse struct {
	httpResponse *http.Response
	Data         components.TeamMembership
}

func (r *GetMembershipForUserLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
List performs requests for "teams/list"

List teams.

  GET /orgs/{org}/teams

https://developer.github.com/v3/teams/#list-teams
*/
func List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReq)
	}
	resp := &ListResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListResponse(r, opts.PreserveResponseBody())
}

// NewListResponse builds a new *ListResponse from an *http.Response
func NewListResponse(resp *http.Response, preserveBody bool) (*ListResponse, error) {
	var result ListResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
List performs requests for "teams/list"

List teams.

  GET /orgs/{org}/teams

https://developer.github.com/v3/teams/#list-teams
*/
func (c Client) List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	return List(ctx, req, append(c, opt...)...)
}

/*
ListReq is request data for Client.List

https://developer.github.com/v3/teams/#list-teams
*/
type ListReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReq) Rel(link string, resp *ListResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListResponse is a response for List

https://developer.github.com/v3/teams/#list-teams
*/
type ListResponse struct {
	httpResponse *http.Response
	Data         []components.Team
}

func (r *ListResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListChildInOrg performs requests for "teams/list-child-in-org"

List child teams.

  GET /orgs/{org}/teams/{team_slug}/teams

https://developer.github.com/v3/teams/#list-child-teams
*/
func ListChildInOrg(ctx context.Context, req *ListChildInOrgReq, opt ...requests.Option) (*ListChildInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListChildInOrgReq)
	}
	resp := &ListChildInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListChildInOrgResponse(r, opts.PreserveResponseBody())
}

// NewListChildInOrgResponse builds a new *ListChildInOrgResponse from an *http.Response
func NewListChildInOrgResponse(resp *http.Response, preserveBody bool) (*ListChildInOrgResponse, error) {
	var result ListChildInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListChildInOrg performs requests for "teams/list-child-in-org"

List child teams.

  GET /orgs/{org}/teams/{team_slug}/teams

https://developer.github.com/v3/teams/#list-child-teams
*/
func (c Client) ListChildInOrg(ctx context.Context, req *ListChildInOrgReq, opt ...requests.Option) (*ListChildInOrgResponse, error) {
	return ListChildInOrg(ctx, req, append(c, opt...)...)
}

/*
ListChildInOrgReq is request data for Client.ListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type ListChildInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListChildInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListChildInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-child-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/teams", r.Org, r.TeamSlug),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListChildInOrgReq) Rel(link string, resp *ListChildInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListChildInOrgResponse is a response for ListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type ListChildInOrgResponse struct {
	httpResponse *http.Response
	Data         []components.Team
}

func (r *ListChildInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListChildLegacy performs requests for "teams/list-child-legacy"

List child teams (Legacy).

  GET /teams/{team_id}/teams

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
func ListChildLegacy(ctx context.Context, req *ListChildLegacyReq, opt ...requests.Option) (*ListChildLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListChildLegacyReq)
	}
	resp := &ListChildLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListChildLegacyResponse(r, opts.PreserveResponseBody())
}

// NewListChildLegacyResponse builds a new *ListChildLegacyResponse from an *http.Response
func NewListChildLegacyResponse(resp *http.Response, preserveBody bool) (*ListChildLegacyResponse, error) {
	var result ListChildLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListChildLegacy performs requests for "teams/list-child-legacy"

List child teams (Legacy).

  GET /teams/{team_id}/teams

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
func (c Client) ListChildLegacy(ctx context.Context, req *ListChildLegacyReq, opt ...requests.Option) (*ListChildLegacyResponse, error) {
	return ListChildLegacy(ctx, req, append(c, opt...)...)
}

/*
ListChildLegacyReq is request data for Client.ListChildLegacy

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
type ListChildLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListChildLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListChildLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-child-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/teams", r.TeamId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListChildLegacyReq) Rel(link string, resp *ListChildLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListChildLegacyResponse is a response for ListChildLegacy

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
type ListChildLegacyResponse struct {
	httpResponse *http.Response
	Data         []components.Team
}

func (r *ListChildLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListDiscussionCommentsInOrg performs requests for "teams/list-discussion-comments-in-org"

List discussion comments.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
func ListDiscussionCommentsInOrg(ctx context.Context, req *ListDiscussionCommentsInOrgReq, opt ...requests.Option) (*ListDiscussionCommentsInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListDiscussionCommentsInOrgReq)
	}
	resp := &ListDiscussionCommentsInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListDiscussionCommentsInOrgResponse(r, opts.PreserveResponseBody())
}

// NewListDiscussionCommentsInOrgResponse builds a new *ListDiscussionCommentsInOrgResponse from an *http.Response
func NewListDiscussionCommentsInOrgResponse(resp *http.Response, preserveBody bool) (*ListDiscussionCommentsInOrgResponse, error) {
	var result ListDiscussionCommentsInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListDiscussionCommentsInOrg performs requests for "teams/list-discussion-comments-in-org"

List discussion comments.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
func (c Client) ListDiscussionCommentsInOrg(ctx context.Context, req *ListDiscussionCommentsInOrgReq, opt ...requests.Option) (*ListDiscussionCommentsInOrgResponse, error) {
	return ListDiscussionCommentsInOrg(ctx, req, append(c, opt...)...)
}

/*
ListDiscussionCommentsInOrgReq is request data for Client.ListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
type ListDiscussionCommentsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListDiscussionCommentsInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListDiscussionCommentsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-discussion-comments-in-org",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListDiscussionCommentsInOrgReq) Rel(link string, resp *ListDiscussionCommentsInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListDiscussionCommentsInOrgResponse is a response for ListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
type ListDiscussionCommentsInOrgResponse struct {
	httpResponse *http.Response
	Data         []components.TeamDiscussionComment
}

func (r *ListDiscussionCommentsInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListDiscussionCommentsLegacy performs requests for "teams/list-discussion-comments-legacy"

List discussion comments (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
func ListDiscussionCommentsLegacy(ctx context.Context, req *ListDiscussionCommentsLegacyReq, opt ...requests.Option) (*ListDiscussionCommentsLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListDiscussionCommentsLegacyReq)
	}
	resp := &ListDiscussionCommentsLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListDiscussionCommentsLegacyResponse(r, opts.PreserveResponseBody())
}

// NewListDiscussionCommentsLegacyResponse builds a new *ListDiscussionCommentsLegacyResponse from an *http.Response
func NewListDiscussionCommentsLegacyResponse(resp *http.Response, preserveBody bool) (*ListDiscussionCommentsLegacyResponse, error) {
	var result ListDiscussionCommentsLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListDiscussionCommentsLegacy performs requests for "teams/list-discussion-comments-legacy"

List discussion comments (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
func (c Client) ListDiscussionCommentsLegacy(ctx context.Context, req *ListDiscussionCommentsLegacyReq, opt ...requests.Option) (*ListDiscussionCommentsLegacyResponse, error) {
	return ListDiscussionCommentsLegacy(ctx, req, append(c, opt...)...)
}

/*
ListDiscussionCommentsLegacyReq is request data for Client.ListDiscussionCommentsLegacy

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
type ListDiscussionCommentsLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListDiscussionCommentsLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListDiscussionCommentsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-discussion-comments-legacy",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/discussions/%v/comments", r.TeamId, r.DiscussionNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListDiscussionCommentsLegacyReq) Rel(link string, resp *ListDiscussionCommentsLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListDiscussionCommentsLegacyResponse is a response for ListDiscussionCommentsLegacy

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
type ListDiscussionCommentsLegacyResponse struct {
	httpResponse *http.Response
	Data         []components.TeamDiscussionComment
}

func (r *ListDiscussionCommentsLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListDiscussionsInOrg performs requests for "teams/list-discussions-in-org"

List discussions.

  GET /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
func ListDiscussionsInOrg(ctx context.Context, req *ListDiscussionsInOrgReq, opt ...requests.Option) (*ListDiscussionsInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListDiscussionsInOrgReq)
	}
	resp := &ListDiscussionsInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListDiscussionsInOrgResponse(r, opts.PreserveResponseBody())
}

// NewListDiscussionsInOrgResponse builds a new *ListDiscussionsInOrgResponse from an *http.Response
func NewListDiscussionsInOrgResponse(resp *http.Response, preserveBody bool) (*ListDiscussionsInOrgResponse, error) {
	var result ListDiscussionsInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListDiscussionsInOrg performs requests for "teams/list-discussions-in-org"

List discussions.

  GET /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
func (c Client) ListDiscussionsInOrg(ctx context.Context, req *ListDiscussionsInOrgReq, opt ...requests.Option) (*ListDiscussionsInOrgResponse, error) {
	return ListDiscussionsInOrg(ctx, req, append(c, opt...)...)
}

/*
ListDiscussionsInOrgReq is request data for Client.ListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type ListDiscussionsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListDiscussionsInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListDiscussionsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-discussions-in-org",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/discussions", r.Org, r.TeamSlug),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListDiscussionsInOrgReq) Rel(link string, resp *ListDiscussionsInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListDiscussionsInOrgResponse is a response for ListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type ListDiscussionsInOrgResponse struct {
	httpResponse *http.Response
	Data         []components.TeamDiscussion
}

func (r *ListDiscussionsInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListDiscussionsLegacy performs requests for "teams/list-discussions-legacy"

List discussions (Legacy).

  GET /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
func ListDiscussionsLegacy(ctx context.Context, req *ListDiscussionsLegacyReq, opt ...requests.Option) (*ListDiscussionsLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListDiscussionsLegacyReq)
	}
	resp := &ListDiscussionsLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListDiscussionsLegacyResponse(r, opts.PreserveResponseBody())
}

// NewListDiscussionsLegacyResponse builds a new *ListDiscussionsLegacyResponse from an *http.Response
func NewListDiscussionsLegacyResponse(resp *http.Response, preserveBody bool) (*ListDiscussionsLegacyResponse, error) {
	var result ListDiscussionsLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListDiscussionsLegacy performs requests for "teams/list-discussions-legacy"

List discussions (Legacy).

  GET /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
func (c Client) ListDiscussionsLegacy(ctx context.Context, req *ListDiscussionsLegacyReq, opt ...requests.Option) (*ListDiscussionsLegacyResponse, error) {
	return ListDiscussionsLegacy(ctx, req, append(c, opt...)...)
}

/*
ListDiscussionsLegacyReq is request data for Client.ListDiscussionsLegacy

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
type ListDiscussionsLegacyReq struct {
	_url   string
	TeamId int64

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListDiscussionsLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListDiscussionsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-discussions-legacy",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/discussions", r.TeamId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListDiscussionsLegacyReq) Rel(link string, resp *ListDiscussionsLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListDiscussionsLegacyResponse is a response for ListDiscussionsLegacy

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
type ListDiscussionsLegacyResponse struct {
	httpResponse *http.Response
	Data         []components.TeamDiscussion
}

func (r *ListDiscussionsLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListForAuthenticatedUser performs requests for "teams/list-for-authenticated-user"

List teams for the authenticated user.

  GET /user/teams

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
func ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForAuthenticatedUserReq)
	}
	resp := &ListForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListForAuthenticatedUserResponse builds a new *ListForAuthenticatedUserResponse from an *http.Response
func NewListForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListForAuthenticatedUserResponse, error) {
	var result ListForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListForAuthenticatedUser performs requests for "teams/list-for-authenticated-user"

List teams for the authenticated user.

  GET /user/teams

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
func (c Client) ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	return ListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListForAuthenticatedUserReq is request data for Client.ListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
type ListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/teams"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForAuthenticatedUserReq) Rel(link string, resp *ListForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForAuthenticatedUserResponse is a response for ListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
type ListForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.TeamFull
}

func (r *ListForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListIdpGroupsForLegacy performs requests for "teams/list-idp-groups-for-legacy"

List IdP groups for a team (Legacy).

  GET /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
func ListIdpGroupsForLegacy(ctx context.Context, req *ListIdpGroupsForLegacyReq, opt ...requests.Option) (*ListIdpGroupsForLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListIdpGroupsForLegacyReq)
	}
	resp := &ListIdpGroupsForLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListIdpGroupsForLegacyResponse(r, opts.PreserveResponseBody())
}

// NewListIdpGroupsForLegacyResponse builds a new *ListIdpGroupsForLegacyResponse from an *http.Response
func NewListIdpGroupsForLegacyResponse(resp *http.Response, preserveBody bool) (*ListIdpGroupsForLegacyResponse, error) {
	var result ListIdpGroupsForLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListIdpGroupsForLegacy performs requests for "teams/list-idp-groups-for-legacy"

List IdP groups for a team (Legacy).

  GET /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
func (c Client) ListIdpGroupsForLegacy(ctx context.Context, req *ListIdpGroupsForLegacyReq, opt ...requests.Option) (*ListIdpGroupsForLegacyResponse, error) {
	return ListIdpGroupsForLegacy(ctx, req, append(c, opt...)...)
}

/*
ListIdpGroupsForLegacyReq is request data for Client.ListIdpGroupsForLegacy

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
type ListIdpGroupsForLegacyReq struct {
	_url   string
	TeamId int64
}

// HTTPRequest builds an *http.Request
func (r *ListIdpGroupsForLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListIdpGroupsForLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-idp-groups-for-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/team-sync/group-mappings", r.TeamId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListIdpGroupsForLegacyReq) Rel(link string, resp *ListIdpGroupsForLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListIdpGroupsForLegacyResponse is a response for ListIdpGroupsForLegacy

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
type ListIdpGroupsForLegacyResponse struct {
	httpResponse *http.Response
	Data         components.GroupMapping
}

func (r *ListIdpGroupsForLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListIdpGroupsForOrg performs requests for "teams/list-idp-groups-for-org"

List IdP groups for an organization.

  GET /orgs/{org}/team-sync/groups

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
func ListIdpGroupsForOrg(ctx context.Context, req *ListIdpGroupsForOrgReq, opt ...requests.Option) (*ListIdpGroupsForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListIdpGroupsForOrgReq)
	}
	resp := &ListIdpGroupsForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListIdpGroupsForOrgResponse(r, opts.PreserveResponseBody())
}

// NewListIdpGroupsForOrgResponse builds a new *ListIdpGroupsForOrgResponse from an *http.Response
func NewListIdpGroupsForOrgResponse(resp *http.Response, preserveBody bool) (*ListIdpGroupsForOrgResponse, error) {
	var result ListIdpGroupsForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListIdpGroupsForOrg performs requests for "teams/list-idp-groups-for-org"

List IdP groups for an organization.

  GET /orgs/{org}/team-sync/groups

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
func (c Client) ListIdpGroupsForOrg(ctx context.Context, req *ListIdpGroupsForOrgReq, opt ...requests.Option) (*ListIdpGroupsForOrgResponse, error) {
	return ListIdpGroupsForOrg(ctx, req, append(c, opt...)...)
}

/*
ListIdpGroupsForOrgReq is request data for Client.ListIdpGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
type ListIdpGroupsForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListIdpGroupsForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListIdpGroupsForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-idp-groups-for-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/team-sync/groups", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListIdpGroupsForOrgReq) Rel(link string, resp *ListIdpGroupsForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListIdpGroupsForOrgResponse is a response for ListIdpGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
type ListIdpGroupsForOrgResponse struct {
	httpResponse *http.Response
	Data         components.GroupMapping
}

func (r *ListIdpGroupsForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListIdpGroupsInOrg performs requests for "teams/list-idp-groups-in-org"

List IdP groups for a team.

  GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
func ListIdpGroupsInOrg(ctx context.Context, req *ListIdpGroupsInOrgReq, opt ...requests.Option) (*ListIdpGroupsInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListIdpGroupsInOrgReq)
	}
	resp := &ListIdpGroupsInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListIdpGroupsInOrgResponse(r, opts.PreserveResponseBody())
}

// NewListIdpGroupsInOrgResponse builds a new *ListIdpGroupsInOrgResponse from an *http.Response
func NewListIdpGroupsInOrgResponse(resp *http.Response, preserveBody bool) (*ListIdpGroupsInOrgResponse, error) {
	var result ListIdpGroupsInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListIdpGroupsInOrg performs requests for "teams/list-idp-groups-in-org"

List IdP groups for a team.

  GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
func (c Client) ListIdpGroupsInOrg(ctx context.Context, req *ListIdpGroupsInOrgReq, opt ...requests.Option) (*ListIdpGroupsInOrgResponse, error) {
	return ListIdpGroupsInOrg(ctx, req, append(c, opt...)...)
}

/*
ListIdpGroupsInOrgReq is request data for Client.ListIdpGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type ListIdpGroupsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
}

// HTTPRequest builds an *http.Request
func (r *ListIdpGroupsInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListIdpGroupsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-idp-groups-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/team-sync/group-mappings", r.Org, r.TeamSlug),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListIdpGroupsInOrgReq) Rel(link string, resp *ListIdpGroupsInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListIdpGroupsInOrgResponse is a response for ListIdpGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type ListIdpGroupsInOrgResponse struct {
	httpResponse *http.Response
	Data         components.GroupMapping
}

func (r *ListIdpGroupsInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListMembersInOrg performs requests for "teams/list-members-in-org"

List team members.

  GET /orgs/{org}/teams/{team_slug}/members

https://developer.github.com/v3/teams/members/#list-team-members
*/
func ListMembersInOrg(ctx context.Context, req *ListMembersInOrgReq, opt ...requests.Option) (*ListMembersInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListMembersInOrgReq)
	}
	resp := &ListMembersInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListMembersInOrgResponse(r, opts.PreserveResponseBody())
}

// NewListMembersInOrgResponse builds a new *ListMembersInOrgResponse from an *http.Response
func NewListMembersInOrgResponse(resp *http.Response, preserveBody bool) (*ListMembersInOrgResponse, error) {
	var result ListMembersInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListMembersInOrg performs requests for "teams/list-members-in-org"

List team members.

  GET /orgs/{org}/teams/{team_slug}/members

https://developer.github.com/v3/teams/members/#list-team-members
*/
func (c Client) ListMembersInOrg(ctx context.Context, req *ListMembersInOrgReq, opt ...requests.Option) (*ListMembersInOrgResponse, error) {
	return ListMembersInOrg(ctx, req, append(c, opt...)...)
}

/*
ListMembersInOrgReq is request data for Client.ListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type ListMembersInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	/*
	Filters members returned by their role in the team. Can be one of:
	\* `member` - normal members of the team.
	\* `maintainer` - team maintainers.
	\* `all` - all members of the team.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListMembersInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListMembersInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-members-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/members", r.Org, r.TeamSlug),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListMembersInOrgReq) Rel(link string, resp *ListMembersInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListMembersInOrgResponse is a response for ListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type ListMembersInOrgResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListMembersInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListMembersLegacy performs requests for "teams/list-members-legacy"

List team members (Legacy).

  GET /teams/{team_id}/members

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
func ListMembersLegacy(ctx context.Context, req *ListMembersLegacyReq, opt ...requests.Option) (*ListMembersLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListMembersLegacyReq)
	}
	resp := &ListMembersLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListMembersLegacyResponse(r, opts.PreserveResponseBody())
}

// NewListMembersLegacyResponse builds a new *ListMembersLegacyResponse from an *http.Response
func NewListMembersLegacyResponse(resp *http.Response, preserveBody bool) (*ListMembersLegacyResponse, error) {
	var result ListMembersLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListMembersLegacy performs requests for "teams/list-members-legacy"

List team members (Legacy).

  GET /teams/{team_id}/members

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
func (c Client) ListMembersLegacy(ctx context.Context, req *ListMembersLegacyReq, opt ...requests.Option) (*ListMembersLegacyResponse, error) {
	return ListMembersLegacy(ctx, req, append(c, opt...)...)
}

/*
ListMembersLegacyReq is request data for Client.ListMembersLegacy

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
type ListMembersLegacyReq struct {
	_url   string
	TeamId int64

	/*
	Filters members returned by their role in the team. Can be one of:
	\* `member` - normal members of the team.
	\* `maintainer` - team maintainers.
	\* `all` - all members of the team.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListMembersLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListMembersLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-members-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/members", r.TeamId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListMembersLegacyReq) Rel(link string, resp *ListMembersLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListMembersLegacyResponse is a response for ListMembersLegacy

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
type ListMembersLegacyResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListMembersLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPendingInvitationsInOrg performs requests for "teams/list-pending-invitations-in-org"

List pending team invitations.

  GET /orgs/{org}/teams/{team_slug}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
func ListPendingInvitationsInOrg(ctx context.Context, req *ListPendingInvitationsInOrgReq, opt ...requests.Option) (*ListPendingInvitationsInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPendingInvitationsInOrgReq)
	}
	resp := &ListPendingInvitationsInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPendingInvitationsInOrgResponse(r, opts.PreserveResponseBody())
}

// NewListPendingInvitationsInOrgResponse builds a new *ListPendingInvitationsInOrgResponse from an *http.Response
func NewListPendingInvitationsInOrgResponse(resp *http.Response, preserveBody bool) (*ListPendingInvitationsInOrgResponse, error) {
	var result ListPendingInvitationsInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPendingInvitationsInOrg performs requests for "teams/list-pending-invitations-in-org"

List pending team invitations.

  GET /orgs/{org}/teams/{team_slug}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
func (c Client) ListPendingInvitationsInOrg(ctx context.Context, req *ListPendingInvitationsInOrgReq, opt ...requests.Option) (*ListPendingInvitationsInOrgResponse, error) {
	return ListPendingInvitationsInOrg(ctx, req, append(c, opt...)...)
}

/*
ListPendingInvitationsInOrgReq is request data for Client.ListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type ListPendingInvitationsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPendingInvitationsInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPendingInvitationsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-pending-invitations-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/invitations", r.Org, r.TeamSlug),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPendingInvitationsInOrgReq) Rel(link string, resp *ListPendingInvitationsInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPendingInvitationsInOrgResponse is a response for ListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type ListPendingInvitationsInOrgResponse struct {
	httpResponse *http.Response
	Data         []components.OrganizationInvitation
}

func (r *ListPendingInvitationsInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPendingInvitationsLegacy performs requests for "teams/list-pending-invitations-legacy"

List pending team invitations (Legacy).

  GET /teams/{team_id}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
func ListPendingInvitationsLegacy(ctx context.Context, req *ListPendingInvitationsLegacyReq, opt ...requests.Option) (*ListPendingInvitationsLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPendingInvitationsLegacyReq)
	}
	resp := &ListPendingInvitationsLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPendingInvitationsLegacyResponse(r, opts.PreserveResponseBody())
}

// NewListPendingInvitationsLegacyResponse builds a new *ListPendingInvitationsLegacyResponse from an *http.Response
func NewListPendingInvitationsLegacyResponse(resp *http.Response, preserveBody bool) (*ListPendingInvitationsLegacyResponse, error) {
	var result ListPendingInvitationsLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPendingInvitationsLegacy performs requests for "teams/list-pending-invitations-legacy"

List pending team invitations (Legacy).

  GET /teams/{team_id}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
func (c Client) ListPendingInvitationsLegacy(ctx context.Context, req *ListPendingInvitationsLegacyReq, opt ...requests.Option) (*ListPendingInvitationsLegacyResponse, error) {
	return ListPendingInvitationsLegacy(ctx, req, append(c, opt...)...)
}

/*
ListPendingInvitationsLegacyReq is request data for Client.ListPendingInvitationsLegacy

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
type ListPendingInvitationsLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPendingInvitationsLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPendingInvitationsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-pending-invitations-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/invitations", r.TeamId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPendingInvitationsLegacyReq) Rel(link string, resp *ListPendingInvitationsLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPendingInvitationsLegacyResponse is a response for ListPendingInvitationsLegacy

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
type ListPendingInvitationsLegacyResponse struct {
	httpResponse *http.Response
	Data         []components.OrganizationInvitation
}

func (r *ListPendingInvitationsLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListProjectsInOrg performs requests for "teams/list-projects-in-org"

List team projects.

  GET /orgs/{org}/teams/{team_slug}/projects

https://developer.github.com/v3/teams/#list-team-projects
*/
func ListProjectsInOrg(ctx context.Context, req *ListProjectsInOrgReq, opt ...requests.Option) (*ListProjectsInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListProjectsInOrgReq)
	}
	resp := &ListProjectsInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListProjectsInOrgResponse(r, opts.PreserveResponseBody())
}

// NewListProjectsInOrgResponse builds a new *ListProjectsInOrgResponse from an *http.Response
func NewListProjectsInOrgResponse(resp *http.Response, preserveBody bool) (*ListProjectsInOrgResponse, error) {
	var result ListProjectsInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListProjectsInOrg performs requests for "teams/list-projects-in-org"

List team projects.

  GET /orgs/{org}/teams/{team_slug}/projects

https://developer.github.com/v3/teams/#list-team-projects
*/
func (c Client) ListProjectsInOrg(ctx context.Context, req *ListProjectsInOrgReq, opt ...requests.Option) (*ListProjectsInOrgResponse, error) {
	return ListProjectsInOrg(ctx, req, append(c, opt...)...)
}

/*
ListProjectsInOrgReq is request data for Client.ListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type ListProjectsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListProjectsInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListProjectsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"inertia"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-projects-in-org",
		Previews:           map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews:   []string{"inertia"},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/projects", r.Org, r.TeamSlug),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListProjectsInOrgReq) Rel(link string, resp *ListProjectsInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListProjectsInOrgResponse is a response for ListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type ListProjectsInOrgResponse struct {
	httpResponse *http.Response
	Data         []components.TeamProject
}

func (r *ListProjectsInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListProjectsLegacy performs requests for "teams/list-projects-legacy"

List team projects (Legacy).

  GET /teams/{team_id}/projects

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
func ListProjectsLegacy(ctx context.Context, req *ListProjectsLegacyReq, opt ...requests.Option) (*ListProjectsLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListProjectsLegacyReq)
	}
	resp := &ListProjectsLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListProjectsLegacyResponse(r, opts.PreserveResponseBody())
}

// NewListProjectsLegacyResponse builds a new *ListProjectsLegacyResponse from an *http.Response
func NewListProjectsLegacyResponse(resp *http.Response, preserveBody bool) (*ListProjectsLegacyResponse, error) {
	var result ListProjectsLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListProjectsLegacy performs requests for "teams/list-projects-legacy"

List team projects (Legacy).

  GET /teams/{team_id}/projects

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
func (c Client) ListProjectsLegacy(ctx context.Context, req *ListProjectsLegacyReq, opt ...requests.Option) (*ListProjectsLegacyResponse, error) {
	return ListProjectsLegacy(ctx, req, append(c, opt...)...)
}

/*
ListProjectsLegacyReq is request data for Client.ListProjectsLegacy

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
type ListProjectsLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListProjectsLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListProjectsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"inertia"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-projects-legacy",
		Previews:           map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews:   []string{"inertia"},
		URLPath:            fmt.Sprintf("/teams/%v/projects", r.TeamId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListProjectsLegacyReq) Rel(link string, resp *ListProjectsLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListProjectsLegacyResponse is a response for ListProjectsLegacy

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
type ListProjectsLegacyResponse struct {
	httpResponse *http.Response
	Data         []components.TeamProject
}

func (r *ListProjectsLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListReposInOrg performs requests for "teams/list-repos-in-org"

List team repositories.

  GET /orgs/{org}/teams/{team_slug}/repos

https://developer.github.com/v3/teams/#list-team-repositories
*/
func ListReposInOrg(ctx context.Context, req *ListReposInOrgReq, opt ...requests.Option) (*ListReposInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposInOrgReq)
	}
	resp := &ListReposInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListReposInOrgResponse(r, opts.PreserveResponseBody())
}

// NewListReposInOrgResponse builds a new *ListReposInOrgResponse from an *http.Response
func NewListReposInOrgResponse(resp *http.Response, preserveBody bool) (*ListReposInOrgResponse, error) {
	var result ListReposInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListReposInOrg performs requests for "teams/list-repos-in-org"

List team repositories.

  GET /orgs/{org}/teams/{team_slug}/repos

https://developer.github.com/v3/teams/#list-team-repositories
*/
func (c Client) ListReposInOrg(ctx context.Context, req *ListReposInOrgReq, opt ...requests.Option) (*ListReposInOrgResponse, error) {
	return ListReposInOrg(ctx, req, append(c, opt...)...)
}

/*
ListReposInOrgReq is request data for Client.ListReposInOrg

https://developer.github.com/v3/teams/#list-team-repositories
*/
type ListReposInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReposInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-repos-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/repos", r.Org, r.TeamSlug),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposInOrgReq) Rel(link string, resp *ListReposInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposInOrgResponse is a response for ListReposInOrg

https://developer.github.com/v3/teams/#list-team-repositories
*/
type ListReposInOrgResponse struct {
	httpResponse *http.Response
	Data         []components.MinimalRepository
}

func (r *ListReposInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListReposLegacy performs requests for "teams/list-repos-legacy"

List team repositories (Legacy).

  GET /teams/{team_id}/repos

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
func ListReposLegacy(ctx context.Context, req *ListReposLegacyReq, opt ...requests.Option) (*ListReposLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposLegacyReq)
	}
	resp := &ListReposLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListReposLegacyResponse(r, opts.PreserveResponseBody())
}

// NewListReposLegacyResponse builds a new *ListReposLegacyResponse from an *http.Response
func NewListReposLegacyResponse(resp *http.Response, preserveBody bool) (*ListReposLegacyResponse, error) {
	var result ListReposLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListReposLegacy performs requests for "teams/list-repos-legacy"

List team repositories (Legacy).

  GET /teams/{team_id}/repos

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
func (c Client) ListReposLegacy(ctx context.Context, req *ListReposLegacyReq, opt ...requests.Option) (*ListReposLegacyResponse, error) {
	return ListReposLegacy(ctx, req, append(c, opt...)...)
}

/*
ListReposLegacyReq is request data for Client.ListReposLegacy

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
type ListReposLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReposLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "teams/list-repos-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/repos", r.TeamId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposLegacyReq) Rel(link string, resp *ListReposLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposLegacyResponse is a response for ListReposLegacy

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
type ListReposLegacyResponse struct {
	httpResponse *http.Response
	Data         []components.MinimalRepository
}

func (r *ListReposLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveMemberLegacy performs requests for "teams/remove-member-legacy"

Remove team member (Legacy).

  DELETE /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
func RemoveMemberLegacy(ctx context.Context, req *RemoveMemberLegacyReq, opt ...requests.Option) (*RemoveMemberLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveMemberLegacyReq)
	}
	resp := &RemoveMemberLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveMemberLegacyResponse(r, opts.PreserveResponseBody())
}

// NewRemoveMemberLegacyResponse builds a new *RemoveMemberLegacyResponse from an *http.Response
func NewRemoveMemberLegacyResponse(resp *http.Response, preserveBody bool) (*RemoveMemberLegacyResponse, error) {
	var result RemoveMemberLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveMemberLegacy performs requests for "teams/remove-member-legacy"

Remove team member (Legacy).

  DELETE /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
func (c Client) RemoveMemberLegacy(ctx context.Context, req *RemoveMemberLegacyReq, opt ...requests.Option) (*RemoveMemberLegacyResponse, error) {
	return RemoveMemberLegacy(ctx, req, append(c, opt...)...)
}

/*
RemoveMemberLegacyReq is request data for Client.RemoveMemberLegacy

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
type RemoveMemberLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemoveMemberLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveMemberLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "teams/remove-member-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/members/%v", r.TeamId, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveMemberLegacyReq) Rel(link string, resp *RemoveMemberLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveMemberLegacyResponse is a response for RemoveMemberLegacy

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
type RemoveMemberLegacyResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *RemoveMemberLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveMembershipForUserInOrg performs requests for "teams/remove-membership-for-user-in-org"

Remove team membership for a user.

  DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
func RemoveMembershipForUserInOrg(ctx context.Context, req *RemoveMembershipForUserInOrgReq, opt ...requests.Option) (*RemoveMembershipForUserInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveMembershipForUserInOrgReq)
	}
	resp := &RemoveMembershipForUserInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveMembershipForUserInOrgResponse(r, opts.PreserveResponseBody())
}

// NewRemoveMembershipForUserInOrgResponse builds a new *RemoveMembershipForUserInOrgResponse from an *http.Response
func NewRemoveMembershipForUserInOrgResponse(resp *http.Response, preserveBody bool) (*RemoveMembershipForUserInOrgResponse, error) {
	var result RemoveMembershipForUserInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveMembershipForUserInOrg performs requests for "teams/remove-membership-for-user-in-org"

Remove team membership for a user.

  DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
func (c Client) RemoveMembershipForUserInOrg(ctx context.Context, req *RemoveMembershipForUserInOrgReq, opt ...requests.Option) (*RemoveMembershipForUserInOrgResponse, error) {
	return RemoveMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
RemoveMembershipForUserInOrgReq is request data for Client.RemoveMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
type RemoveMembershipForUserInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemoveMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveMembershipForUserInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "teams/remove-membership-for-user-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveMembershipForUserInOrgReq) Rel(link string, resp *RemoveMembershipForUserInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveMembershipForUserInOrgResponse is a response for RemoveMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
type RemoveMembershipForUserInOrgResponse struct {
	httpResponse *http.Response
}

func (r *RemoveMembershipForUserInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveMembershipForUserLegacy performs requests for "teams/remove-membership-for-user-legacy"

Remove team membership for a user (Legacy).

  DELETE /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
func RemoveMembershipForUserLegacy(ctx context.Context, req *RemoveMembershipForUserLegacyReq, opt ...requests.Option) (*RemoveMembershipForUserLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveMembershipForUserLegacyReq)
	}
	resp := &RemoveMembershipForUserLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveMembershipForUserLegacyResponse(r, opts.PreserveResponseBody())
}

// NewRemoveMembershipForUserLegacyResponse builds a new *RemoveMembershipForUserLegacyResponse from an *http.Response
func NewRemoveMembershipForUserLegacyResponse(resp *http.Response, preserveBody bool) (*RemoveMembershipForUserLegacyResponse, error) {
	var result RemoveMembershipForUserLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveMembershipForUserLegacy performs requests for "teams/remove-membership-for-user-legacy"

Remove team membership for a user (Legacy).

  DELETE /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
func (c Client) RemoveMembershipForUserLegacy(ctx context.Context, req *RemoveMembershipForUserLegacyReq, opt ...requests.Option) (*RemoveMembershipForUserLegacyResponse, error) {
	return RemoveMembershipForUserLegacy(ctx, req, append(c, opt...)...)
}

/*
RemoveMembershipForUserLegacyReq is request data for Client.RemoveMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
type RemoveMembershipForUserLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemoveMembershipForUserLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveMembershipForUserLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "teams/remove-membership-for-user-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/memberships/%v", r.TeamId, r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveMembershipForUserLegacyReq) Rel(link string, resp *RemoveMembershipForUserLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveMembershipForUserLegacyResponse is a response for RemoveMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
type RemoveMembershipForUserLegacyResponse struct {
	httpResponse *http.Response
}

func (r *RemoveMembershipForUserLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveProjectInOrg performs requests for "teams/remove-project-in-org"

Remove a project from a team.

  DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
func RemoveProjectInOrg(ctx context.Context, req *RemoveProjectInOrgReq, opt ...requests.Option) (*RemoveProjectInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveProjectInOrgReq)
	}
	resp := &RemoveProjectInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveProjectInOrgResponse(r, opts.PreserveResponseBody())
}

// NewRemoveProjectInOrgResponse builds a new *RemoveProjectInOrgResponse from an *http.Response
func NewRemoveProjectInOrgResponse(resp *http.Response, preserveBody bool) (*RemoveProjectInOrgResponse, error) {
	var result RemoveProjectInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveProjectInOrg performs requests for "teams/remove-project-in-org"

Remove a project from a team.

  DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
func (c Client) RemoveProjectInOrg(ctx context.Context, req *RemoveProjectInOrgReq, opt ...requests.Option) (*RemoveProjectInOrgResponse, error) {
	return RemoveProjectInOrg(ctx, req, append(c, opt...)...)
}

/*
RemoveProjectInOrgReq is request data for Client.RemoveProjectInOrg

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
type RemoveProjectInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug  string
	ProjectId int64
}

// HTTPRequest builds an *http.Request
func (r *RemoveProjectInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveProjectInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "teams/remove-project-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveProjectInOrgReq) Rel(link string, resp *RemoveProjectInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveProjectInOrgResponse is a response for RemoveProjectInOrg

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
type RemoveProjectInOrgResponse struct {
	httpResponse *http.Response
}

func (r *RemoveProjectInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveProjectLegacy performs requests for "teams/remove-project-legacy"

Remove a project from a team (Legacy).

  DELETE /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
func RemoveProjectLegacy(ctx context.Context, req *RemoveProjectLegacyReq, opt ...requests.Option) (*RemoveProjectLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveProjectLegacyReq)
	}
	resp := &RemoveProjectLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveProjectLegacyResponse(r, opts.PreserveResponseBody())
}

// NewRemoveProjectLegacyResponse builds a new *RemoveProjectLegacyResponse from an *http.Response
func NewRemoveProjectLegacyResponse(resp *http.Response, preserveBody bool) (*RemoveProjectLegacyResponse, error) {
	var result RemoveProjectLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveProjectLegacy performs requests for "teams/remove-project-legacy"

Remove a project from a team (Legacy).

  DELETE /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
func (c Client) RemoveProjectLegacy(ctx context.Context, req *RemoveProjectLegacyReq, opt ...requests.Option) (*RemoveProjectLegacyResponse, error) {
	return RemoveProjectLegacy(ctx, req, append(c, opt...)...)
}

/*
RemoveProjectLegacyReq is request data for Client.RemoveProjectLegacy

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
type RemoveProjectLegacyReq struct {
	_url      string
	TeamId    int64
	ProjectId int64
}

// HTTPRequest builds an *http.Request
func (r *RemoveProjectLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveProjectLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "teams/remove-project-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/projects/%v", r.TeamId, r.ProjectId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveProjectLegacyReq) Rel(link string, resp *RemoveProjectLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveProjectLegacyResponse is a response for RemoveProjectLegacy

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
type RemoveProjectLegacyResponse struct {
	httpResponse *http.Response
}

func (r *RemoveProjectLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveRepoInOrg performs requests for "teams/remove-repo-in-org"

Remove a repository from a team.

  DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
func RemoveRepoInOrg(ctx context.Context, req *RemoveRepoInOrgReq, opt ...requests.Option) (*RemoveRepoInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveRepoInOrgReq)
	}
	resp := &RemoveRepoInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveRepoInOrgResponse(r, opts.PreserveResponseBody())
}

// NewRemoveRepoInOrgResponse builds a new *RemoveRepoInOrgResponse from an *http.Response
func NewRemoveRepoInOrgResponse(resp *http.Response, preserveBody bool) (*RemoveRepoInOrgResponse, error) {
	var result RemoveRepoInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveRepoInOrg performs requests for "teams/remove-repo-in-org"

Remove a repository from a team.

  DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
func (c Client) RemoveRepoInOrg(ctx context.Context, req *RemoveRepoInOrgReq, opt ...requests.Option) (*RemoveRepoInOrgResponse, error) {
	return RemoveRepoInOrg(ctx, req, append(c, opt...)...)
}

/*
RemoveRepoInOrgReq is request data for Client.RemoveRepoInOrg

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
type RemoveRepoInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
	Owner    string
	Repo     string
}

// HTTPRequest builds an *http.Request
func (r *RemoveRepoInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveRepoInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "teams/remove-repo-in-org",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveRepoInOrgReq) Rel(link string, resp *RemoveRepoInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveRepoInOrgResponse is a response for RemoveRepoInOrg

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
type RemoveRepoInOrgResponse struct {
	httpResponse *http.Response
}

func (r *RemoveRepoInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveRepoLegacy performs requests for "teams/remove-repo-legacy"

Remove a repository from a team (Legacy).

  DELETE /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
func RemoveRepoLegacy(ctx context.Context, req *RemoveRepoLegacyReq, opt ...requests.Option) (*RemoveRepoLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveRepoLegacyReq)
	}
	resp := &RemoveRepoLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveRepoLegacyResponse(r, opts.PreserveResponseBody())
}

// NewRemoveRepoLegacyResponse builds a new *RemoveRepoLegacyResponse from an *http.Response
func NewRemoveRepoLegacyResponse(resp *http.Response, preserveBody bool) (*RemoveRepoLegacyResponse, error) {
	var result RemoveRepoLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveRepoLegacy performs requests for "teams/remove-repo-legacy"

Remove a repository from a team (Legacy).

  DELETE /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
func (c Client) RemoveRepoLegacy(ctx context.Context, req *RemoveRepoLegacyReq, opt ...requests.Option) (*RemoveRepoLegacyResponse, error) {
	return RemoveRepoLegacy(ctx, req, append(c, opt...)...)
}

/*
RemoveRepoLegacyReq is request data for Client.RemoveRepoLegacy

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
type RemoveRepoLegacyReq struct {
	_url   string
	TeamId int64
	Owner  string
	Repo   string
}

// HTTPRequest builds an *http.Request
func (r *RemoveRepoLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveRepoLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "teams/remove-repo-legacy",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/teams/%v/repos/%v/%v", r.TeamId, r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveRepoLegacyReq) Rel(link string, resp *RemoveRepoLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveRepoLegacyResponse is a response for RemoveRepoLegacy

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
type RemoveRepoLegacyResponse struct {
	httpResponse *http.Response
}

func (r *RemoveRepoLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateDiscussionCommentInOrg performs requests for "teams/update-discussion-comment-in-org"

Update a discussion comment.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
func UpdateDiscussionCommentInOrg(ctx context.Context, req *UpdateDiscussionCommentInOrgReq, opt ...requests.Option) (*UpdateDiscussionCommentInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateDiscussionCommentInOrgReq)
	}
	resp := &UpdateDiscussionCommentInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateDiscussionCommentInOrgResponse(r, opts.PreserveResponseBody())
}

// NewUpdateDiscussionCommentInOrgResponse builds a new *UpdateDiscussionCommentInOrgResponse from an *http.Response
func NewUpdateDiscussionCommentInOrgResponse(resp *http.Response, preserveBody bool) (*UpdateDiscussionCommentInOrgResponse, error) {
	var result UpdateDiscussionCommentInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateDiscussionCommentInOrg performs requests for "teams/update-discussion-comment-in-org"

Update a discussion comment.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
func (c Client) UpdateDiscussionCommentInOrg(ctx context.Context, req *UpdateDiscussionCommentInOrgReq, opt ...requests.Option) (*UpdateDiscussionCommentInOrgResponse, error) {
	return UpdateDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
UpdateDiscussionCommentInOrgReq is request data for Client.UpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type UpdateDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      UpdateDiscussionCommentInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-discussion-comment-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateDiscussionCommentInOrgReq) Rel(link string, resp *UpdateDiscussionCommentInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateDiscussionCommentInOrgReqBody is a request body for teams/update-discussion-comment-in-org

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type UpdateDiscussionCommentInOrgReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
UpdateDiscussionCommentInOrgResponse is a response for UpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type UpdateDiscussionCommentInOrgResponse struct {
	httpResponse *http.Response
	Data         components.TeamDiscussionComment
}

func (r *UpdateDiscussionCommentInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateDiscussionCommentLegacy performs requests for "teams/update-discussion-comment-legacy"

Update a discussion comment (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
func UpdateDiscussionCommentLegacy(ctx context.Context, req *UpdateDiscussionCommentLegacyReq, opt ...requests.Option) (*UpdateDiscussionCommentLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateDiscussionCommentLegacyReq)
	}
	resp := &UpdateDiscussionCommentLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateDiscussionCommentLegacyResponse(r, opts.PreserveResponseBody())
}

// NewUpdateDiscussionCommentLegacyResponse builds a new *UpdateDiscussionCommentLegacyResponse from an *http.Response
func NewUpdateDiscussionCommentLegacyResponse(resp *http.Response, preserveBody bool) (*UpdateDiscussionCommentLegacyResponse, error) {
	var result UpdateDiscussionCommentLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateDiscussionCommentLegacy performs requests for "teams/update-discussion-comment-legacy"

Update a discussion comment (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
func (c Client) UpdateDiscussionCommentLegacy(ctx context.Context, req *UpdateDiscussionCommentLegacyReq, opt ...requests.Option) (*UpdateDiscussionCommentLegacyResponse, error) {
	return UpdateDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
UpdateDiscussionCommentLegacyReq is request data for Client.UpdateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
type UpdateDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      UpdateDiscussionCommentLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-discussion-comment-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments/%v", r.TeamId, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateDiscussionCommentLegacyReq) Rel(link string, resp *UpdateDiscussionCommentLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateDiscussionCommentLegacyReqBody is a request body for teams/update-discussion-comment-legacy

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
type UpdateDiscussionCommentLegacyReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
UpdateDiscussionCommentLegacyResponse is a response for UpdateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
type UpdateDiscussionCommentLegacyResponse struct {
	httpResponse *http.Response
	Data         components.TeamDiscussionComment
}

func (r *UpdateDiscussionCommentLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateDiscussionInOrg performs requests for "teams/update-discussion-in-org"

Update a discussion.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
func UpdateDiscussionInOrg(ctx context.Context, req *UpdateDiscussionInOrgReq, opt ...requests.Option) (*UpdateDiscussionInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateDiscussionInOrgReq)
	}
	resp := &UpdateDiscussionInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateDiscussionInOrgResponse(r, opts.PreserveResponseBody())
}

// NewUpdateDiscussionInOrgResponse builds a new *UpdateDiscussionInOrgResponse from an *http.Response
func NewUpdateDiscussionInOrgResponse(resp *http.Response, preserveBody bool) (*UpdateDiscussionInOrgResponse, error) {
	var result UpdateDiscussionInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateDiscussionInOrg performs requests for "teams/update-discussion-in-org"

Update a discussion.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
func (c Client) UpdateDiscussionInOrg(ctx context.Context, req *UpdateDiscussionInOrgReq, opt ...requests.Option) (*UpdateDiscussionInOrgResponse, error) {
	return UpdateDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
UpdateDiscussionInOrgReq is request data for Client.UpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type UpdateDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      UpdateDiscussionInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-discussion-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateDiscussionInOrgReq) Rel(link string, resp *UpdateDiscussionInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateDiscussionInOrgReqBody is a request body for teams/update-discussion-in-org

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type UpdateDiscussionInOrgReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body,omitempty"`

	// The discussion post's title.
	Title *string `json:"title,omitempty"`
}

/*
UpdateDiscussionInOrgResponse is a response for UpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type UpdateDiscussionInOrgResponse struct {
	httpResponse *http.Response
	Data         components.TeamDiscussion
}

func (r *UpdateDiscussionInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateDiscussionLegacy performs requests for "teams/update-discussion-legacy"

Update a discussion (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
func UpdateDiscussionLegacy(ctx context.Context, req *UpdateDiscussionLegacyReq, opt ...requests.Option) (*UpdateDiscussionLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateDiscussionLegacyReq)
	}
	resp := &UpdateDiscussionLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateDiscussionLegacyResponse(r, opts.PreserveResponseBody())
}

// NewUpdateDiscussionLegacyResponse builds a new *UpdateDiscussionLegacyResponse from an *http.Response
func NewUpdateDiscussionLegacyResponse(resp *http.Response, preserveBody bool) (*UpdateDiscussionLegacyResponse, error) {
	var result UpdateDiscussionLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateDiscussionLegacy performs requests for "teams/update-discussion-legacy"

Update a discussion (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
func (c Client) UpdateDiscussionLegacy(ctx context.Context, req *UpdateDiscussionLegacyReq, opt ...requests.Option) (*UpdateDiscussionLegacyResponse, error) {
	return UpdateDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
UpdateDiscussionLegacyReq is request data for Client.UpdateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
type UpdateDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	RequestBody      UpdateDiscussionLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-discussion-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateDiscussionLegacyReq) Rel(link string, resp *UpdateDiscussionLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateDiscussionLegacyReqBody is a request body for teams/update-discussion-legacy

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
type UpdateDiscussionLegacyReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body,omitempty"`

	// The discussion post's title.
	Title *string `json:"title,omitempty"`
}

/*
UpdateDiscussionLegacyResponse is a response for UpdateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
type UpdateDiscussionLegacyResponse struct {
	httpResponse *http.Response
	Data         components.TeamDiscussion
}

func (r *UpdateDiscussionLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateInOrg performs requests for "teams/update-in-org"

Update a team.

  PATCH /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#update-a-team
*/
func UpdateInOrg(ctx context.Context, req *UpdateInOrgReq, opt ...requests.Option) (*UpdateInOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateInOrgReq)
	}
	resp := &UpdateInOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateInOrgResponse(r, opts.PreserveResponseBody())
}

// NewUpdateInOrgResponse builds a new *UpdateInOrgResponse from an *http.Response
func NewUpdateInOrgResponse(resp *http.Response, preserveBody bool) (*UpdateInOrgResponse, error) {
	var result UpdateInOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateInOrg performs requests for "teams/update-in-org"

Update a team.

  PATCH /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#update-a-team
*/
func (c Client) UpdateInOrg(ctx context.Context, req *UpdateInOrgReq, opt ...requests.Option) (*UpdateInOrgResponse, error) {
	return UpdateInOrg(ctx, req, append(c, opt...)...)
}

/*
UpdateInOrgReq is request data for Client.UpdateInOrg

https://developer.github.com/v3/teams/#update-a-team
*/
type UpdateInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	RequestBody UpdateInOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateInOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateInOrgReq) Rel(link string, resp *UpdateInOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateInOrgReqBody is a request body for teams/update-in-org

https://developer.github.com/v3/teams/#update-a-team
*/
type UpdateInOrgReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	**Deprecated**. The permission that new repositories will be added to the team
	with when none is specified. Can be one of:
	\* `pull` - team members can pull, but not push to or administer newly-added
	repositories.
	\* `push` - team members can pull and push, but not administer newly-added
	repositories.
	\* `admin` - team members can pull, push and administer newly-added
	repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	The level of privacy this team should have. Editing teams without specifying
	this parameter leaves `privacy` intact. When a team is nested, the `privacy` for
	parent teams cannot be `secret`. The options are:
	**For a non-nested team:**
	\* `secret` - only visible to organization owners and members of this team.
	\* `closed` - visible to all members of this organization.
	**For a parent or child team:**
	\* `closed` - visible to all members of this organization.
	*/
	Privacy *string `json:"privacy,omitempty"`
}

/*
UpdateInOrgResponse is a response for UpdateInOrg

https://developer.github.com/v3/teams/#update-a-team
*/
type UpdateInOrgResponse struct {
	httpResponse *http.Response
	Data         components.TeamFull
}

func (r *UpdateInOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateLegacy performs requests for "teams/update-legacy"

Update a team (Legacy).

  PATCH /teams/{team_id}

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
func UpdateLegacy(ctx context.Context, req *UpdateLegacyReq, opt ...requests.Option) (*UpdateLegacyResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateLegacyReq)
	}
	resp := &UpdateLegacyResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateLegacyResponse(r, opts.PreserveResponseBody())
}

// NewUpdateLegacyResponse builds a new *UpdateLegacyResponse from an *http.Response
func NewUpdateLegacyResponse(resp *http.Response, preserveBody bool) (*UpdateLegacyResponse, error) {
	var result UpdateLegacyResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateLegacy performs requests for "teams/update-legacy"

Update a team (Legacy).

  PATCH /teams/{team_id}

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
func (c Client) UpdateLegacy(ctx context.Context, req *UpdateLegacyReq, opt ...requests.Option) (*UpdateLegacyResponse, error) {
	return UpdateLegacy(ctx, req, append(c, opt...)...)
}

/*
UpdateLegacyReq is request data for Client.UpdateLegacy

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
type UpdateLegacyReq struct {
	_url        string
	TeamId      int64
	RequestBody UpdateLegacyReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateLegacyReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v", r.TeamId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateLegacyReq) Rel(link string, resp *UpdateLegacyResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateLegacyReqBody is a request body for teams/update-legacy

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
type UpdateLegacyReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	**Deprecated**. The permission that new repositories will be added to the team
	with when none is specified. Can be one of:
	\* `pull` - team members can pull, but not push to or administer newly-added
	repositories.
	\* `push` - team members can pull and push, but not administer newly-added
	repositories.
	\* `admin` - team members can pull, push and administer newly-added
	repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	The level of privacy this team should have. Editing teams without specifying
	this parameter leaves `privacy` intact. The options are:
	**For a non-nested team:**
	\* `secret` - only visible to organization owners and members of this team.
	\* `closed` - visible to all members of this organization.
	**For a parent or child team:**
	\* `closed` - visible to all members of this organization.
	*/
	Privacy *string `json:"privacy,omitempty"`
}

/*
UpdateLegacyResponse is a response for UpdateLegacy

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
type UpdateLegacyResponse struct {
	httpResponse *http.Response
	Data         components.TeamFull
}

func (r *UpdateLegacyResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}
