// Code generated by octo-go; DO NOT EDIT.

package scim

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []options.Option

// NewClient returns a new Client
func NewClient(opt ...options.Option) Client {
	return opt
}

/*
DeleteUserFromOrg performs requests for "scim/delete-user-from-org"

Delete a SCIM user from an organization.

  DELETE /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#delete-a-scim-user-from-an-organization
*/
func DeleteUserFromOrg(ctx context.Context, req *DeleteUserFromOrgReq, opt ...options.Option) (*DeleteUserFromOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteUserFromOrgReq)
	}
	resp := &DeleteUserFromOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteUserFromOrg performs requests for "scim/delete-user-from-org"

Delete a SCIM user from an organization.

  DELETE /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#delete-a-scim-user-from-an-organization
*/
func (c Client) DeleteUserFromOrg(ctx context.Context, req *DeleteUserFromOrgReq, opt ...options.Option) (*DeleteUserFromOrgResponse, error) {
	return DeleteUserFromOrg(ctx, req, append(c, opt...)...)
}

/*
DeleteUserFromOrgReq is request data for Client.DeleteUserFromOrg

https://developer.github.com/v3/scim/#delete-a-scim-user-from-an-organization
*/
type DeleteUserFromOrgReq struct {
	_url string
	Org  string

	// scim_user_id parameter
	ScimUserId string
}

// HTTPRequest builds an *http.Request
func (r *DeleteUserFromOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteUserFromOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "scim/delete-user-from-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/scim/v2/organizations/%v/Users/%v", r.Org, r.ScimUserId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteUserFromOrgReq) Rel(link string, resp *DeleteUserFromOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteUserFromOrgResponse is a response for DeleteUserFromOrg

https://developer.github.com/v3/scim/#delete-a-scim-user-from-an-organization
*/
type DeleteUserFromOrgResponse struct {
	common.Response
	request *DeleteUserFromOrgReq
}

/*
GetProvisioningInformationForUser performs requests for "scim/get-provisioning-information-for-user"

Get SCIM provisioning information for a user.

  GET /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#get-scim-provisioning-information-for-a-user
*/
func GetProvisioningInformationForUser(ctx context.Context, req *GetProvisioningInformationForUserReq, opt ...options.Option) (*GetProvisioningInformationForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetProvisioningInformationForUserReq)
	}
	resp := &GetProvisioningInformationForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ScimUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetProvisioningInformationForUser performs requests for "scim/get-provisioning-information-for-user"

Get SCIM provisioning information for a user.

  GET /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#get-scim-provisioning-information-for-a-user
*/
func (c Client) GetProvisioningInformationForUser(ctx context.Context, req *GetProvisioningInformationForUserReq, opt ...options.Option) (*GetProvisioningInformationForUserResponse, error) {
	return GetProvisioningInformationForUser(ctx, req, append(c, opt...)...)
}

/*
GetProvisioningInformationForUserReq is request data for Client.GetProvisioningInformationForUser

https://developer.github.com/v3/scim/#get-scim-provisioning-information-for-a-user
*/
type GetProvisioningInformationForUserReq struct {
	_url string
	Org  string

	// scim_user_id parameter
	ScimUserId string
}

// HTTPRequest builds an *http.Request
func (r *GetProvisioningInformationForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetProvisioningInformationForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/scim+json")},
		Method:           "GET",
		OperationID:      "scim/get-provisioning-information-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/scim/v2/organizations/%v/Users/%v", r.Org, r.ScimUserId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetProvisioningInformationForUserReq) Rel(link string, resp *GetProvisioningInformationForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetProvisioningInformationForUserResponse is a response for GetProvisioningInformationForUser

https://developer.github.com/v3/scim/#get-scim-provisioning-information-for-a-user
*/
type GetProvisioningInformationForUserResponse struct {
	common.Response
	request *GetProvisioningInformationForUserReq
	Data    components.ScimUser
}

/*
ListProvisionedIdentities performs requests for "scim/list-provisioned-identities"

List SCIM provisioned identities.

  GET /scim/v2/organizations/{org}/Users

https://developer.github.com/v3/scim/#list-scim-provisioned-identities
*/
func ListProvisionedIdentities(ctx context.Context, req *ListProvisionedIdentitiesReq, opt ...options.Option) (*ListProvisionedIdentitiesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListProvisionedIdentitiesReq)
	}
	resp := &ListProvisionedIdentitiesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ScimUserList{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListProvisionedIdentities performs requests for "scim/list-provisioned-identities"

List SCIM provisioned identities.

  GET /scim/v2/organizations/{org}/Users

https://developer.github.com/v3/scim/#list-scim-provisioned-identities
*/
func (c Client) ListProvisionedIdentities(ctx context.Context, req *ListProvisionedIdentitiesReq, opt ...options.Option) (*ListProvisionedIdentitiesResponse, error) {
	return ListProvisionedIdentities(ctx, req, append(c, opt...)...)
}

/*
ListProvisionedIdentitiesReq is request data for Client.ListProvisionedIdentities

https://developer.github.com/v3/scim/#list-scim-provisioned-identities
*/
type ListProvisionedIdentitiesReq struct {
	_url string
	Org  string

	// Used for pagination: the index of the first result to return.
	StartIndex *int64

	// Used for pagination: the number of results to return.
	Count *int64

	/*
	Filters results using the equals query parameter operator (`eq`). You can filter
	results that are equal to `id`, `userName`, `emails`, and `external_id`. For
	example, to search for an identity with the `userName` Octocat, you would use
	this query:

	`?filter=userName%20eq%20\"Octocat\"`.

	To filter results for for the identity with the email `octocat@github.com`, you
	would use this query:

	`?filter=emails%20eq%20\"octocat@github.com\"`.
	*/
	Filter *string
}

// HTTPRequest builds an *http.Request
func (r *ListProvisionedIdentitiesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListProvisionedIdentitiesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.StartIndex != nil {
		query.Set("startIndex", strconv.FormatInt(*r.StartIndex, 10))
	}
	if r.Count != nil {
		query.Set("count", strconv.FormatInt(*r.Count, 10))
	}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/scim+json")},
		Method:           "GET",
		OperationID:      "scim/list-provisioned-identities",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/scim/v2/organizations/%v/Users", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListProvisionedIdentitiesReq) Rel(link string, resp *ListProvisionedIdentitiesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListProvisionedIdentitiesResponse is a response for ListProvisionedIdentities

https://developer.github.com/v3/scim/#list-scim-provisioned-identities
*/
type ListProvisionedIdentitiesResponse struct {
	common.Response
	request *ListProvisionedIdentitiesReq
	Data    components.ScimUserList
}

/*
ProvisionAndInviteUser performs requests for "scim/provision-and-invite-user"

Provision and invite a SCIM user.

  POST /scim/v2/organizations/{org}/Users

https://developer.github.com/v3/scim/#provision-and-invite-a-scim-user
*/
func ProvisionAndInviteUser(ctx context.Context, req *ProvisionAndInviteUserReq, opt ...options.Option) (*ProvisionAndInviteUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProvisionAndInviteUserReq)
	}
	resp := &ProvisionAndInviteUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ScimUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProvisionAndInviteUser performs requests for "scim/provision-and-invite-user"

Provision and invite a SCIM user.

  POST /scim/v2/organizations/{org}/Users

https://developer.github.com/v3/scim/#provision-and-invite-a-scim-user
*/
func (c Client) ProvisionAndInviteUser(ctx context.Context, req *ProvisionAndInviteUserReq, opt ...options.Option) (*ProvisionAndInviteUserResponse, error) {
	return ProvisionAndInviteUser(ctx, req, append(c, opt...)...)
}

/*
ProvisionAndInviteUserReq is request data for Client.ProvisionAndInviteUser

https://developer.github.com/v3/scim/#provision-and-invite-a-scim-user
*/
type ProvisionAndInviteUserReq struct {
	_url        string
	Org         string
	RequestBody ProvisionAndInviteUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *ProvisionAndInviteUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProvisionAndInviteUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/scim+json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "scim/provision-and-invite-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/scim/v2/organizations/%v/Users", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProvisionAndInviteUserReq) Rel(link string, resp *ProvisionAndInviteUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ProvisionAndInviteUserReqBodyEmails is a value for ProvisionAndInviteUserReqBody's Emails field
type ProvisionAndInviteUserReqBodyEmails struct {
	Primary *bool   `json:"primary,omitempty"`
	Type    *string `json:"type,omitempty"`
	Value   *string `json:"value"`
}

// ProvisionAndInviteUserReqBodyName is a value for ProvisionAndInviteUserReqBody's Name field
type ProvisionAndInviteUserReqBodyName struct {
	FamilyName *string `json:"familyName"`
	GivenName  *string `json:"givenName"`
}

/*
ProvisionAndInviteUserReqBody is a request body for scim/provision-and-invite-user

https://developer.github.com/v3/scim/#provision-and-invite-a-scim-user
*/
type ProvisionAndInviteUserReqBody struct {
	Active      *bool   `json:"active,omitempty"`
	DisplayName *string `json:"displayName,omitempty"`

	// user emails
	Emails     []ProvisionAndInviteUserReqBodyEmails `json:"emails"`
	ExternalId *string                               `json:"externalId,omitempty"`
	Groups     []string                              `json:"groups,omitempty"`
	Name       *ProvisionAndInviteUserReqBodyName    `json:"name"`
	Schemas    []string                              `json:"schemas,omitempty"`

	// Configured by the admin. Could be an email, login, or username
	UserName *string `json:"userName"`
}

/*
ProvisionAndInviteUserResponse is a response for ProvisionAndInviteUser

https://developer.github.com/v3/scim/#provision-and-invite-a-scim-user
*/
type ProvisionAndInviteUserResponse struct {
	common.Response
	request *ProvisionAndInviteUserReq
	Data    components.ScimUser
}

/*
SetInformationForProvisionedUser performs requests for "scim/set-information-for-provisioned-user"

Update a provisioned organization membership.

  PUT /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#set-scim-information-for-a-provisioned-user
*/
func SetInformationForProvisionedUser(ctx context.Context, req *SetInformationForProvisionedUserReq, opt ...options.Option) (*SetInformationForProvisionedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetInformationForProvisionedUserReq)
	}
	resp := &SetInformationForProvisionedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ScimUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetInformationForProvisionedUser performs requests for "scim/set-information-for-provisioned-user"

Update a provisioned organization membership.

  PUT /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#set-scim-information-for-a-provisioned-user
*/
func (c Client) SetInformationForProvisionedUser(ctx context.Context, req *SetInformationForProvisionedUserReq, opt ...options.Option) (*SetInformationForProvisionedUserResponse, error) {
	return SetInformationForProvisionedUser(ctx, req, append(c, opt...)...)
}

/*
SetInformationForProvisionedUserReq is request data for Client.SetInformationForProvisionedUser

https://developer.github.com/v3/scim/#set-scim-information-for-a-provisioned-user
*/
type SetInformationForProvisionedUserReq struct {
	_url string
	Org  string

	// scim_user_id parameter
	ScimUserId  string
	RequestBody SetInformationForProvisionedUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetInformationForProvisionedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetInformationForProvisionedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/scim+json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "scim/set-information-for-provisioned-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/scim/v2/organizations/%v/Users/%v", r.Org, r.ScimUserId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetInformationForProvisionedUserReq) Rel(link string, resp *SetInformationForProvisionedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// SetInformationForProvisionedUserReqBodyEmails is a value for SetInformationForProvisionedUserReqBody's Emails field
type SetInformationForProvisionedUserReqBodyEmails struct {
	Primary *bool   `json:"primary,omitempty"`
	Type    *string `json:"type,omitempty"`
	Value   *string `json:"value"`
}

// SetInformationForProvisionedUserReqBodyName is a value for SetInformationForProvisionedUserReqBody's Name field
type SetInformationForProvisionedUserReqBodyName struct {
	FamilyName *string `json:"familyName"`
	GivenName  *string `json:"givenName"`
}

/*
SetInformationForProvisionedUserReqBody is a request body for scim/set-information-for-provisioned-user

https://developer.github.com/v3/scim/#set-scim-information-for-a-provisioned-user
*/
type SetInformationForProvisionedUserReqBody struct {
	Active      *bool   `json:"active,omitempty"`
	DisplayName *string `json:"displayName,omitempty"`

	// user emails
	Emails     []SetInformationForProvisionedUserReqBodyEmails `json:"emails"`
	ExternalId *string                                         `json:"externalId,omitempty"`
	Groups     []string                                        `json:"groups,omitempty"`
	Name       *SetInformationForProvisionedUserReqBodyName    `json:"name"`
	Schemas    []string                                        `json:"schemas,omitempty"`

	// Configured by the admin. Could be an email, login, or username
	UserName *string `json:"userName"`
}

/*
SetInformationForProvisionedUserResponse is a response for SetInformationForProvisionedUser

https://developer.github.com/v3/scim/#set-scim-information-for-a-provisioned-user
*/
type SetInformationForProvisionedUserResponse struct {
	common.Response
	request *SetInformationForProvisionedUserReq
	Data    components.ScimUser
}

/*
UpdateAttributeForUser performs requests for "scim/update-attribute-for-user"

Update an attribute for a SCIM user.

  PATCH /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#update-an-attribute-for-a-scim-user
*/
func UpdateAttributeForUser(ctx context.Context, req *UpdateAttributeForUserReq, opt ...options.Option) (*UpdateAttributeForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateAttributeForUserReq)
	}
	resp := &UpdateAttributeForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ScimUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateAttributeForUser performs requests for "scim/update-attribute-for-user"

Update an attribute for a SCIM user.

  PATCH /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#update-an-attribute-for-a-scim-user
*/
func (c Client) UpdateAttributeForUser(ctx context.Context, req *UpdateAttributeForUserReq, opt ...options.Option) (*UpdateAttributeForUserResponse, error) {
	return UpdateAttributeForUser(ctx, req, append(c, opt...)...)
}

/*
UpdateAttributeForUserReq is request data for Client.UpdateAttributeForUser

https://developer.github.com/v3/scim/#update-an-attribute-for-a-scim-user
*/
type UpdateAttributeForUserReq struct {
	_url string
	Org  string

	// scim_user_id parameter
	ScimUserId  string
	RequestBody UpdateAttributeForUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateAttributeForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateAttributeForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/scim+json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "scim/update-attribute-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/scim/v2/organizations/%v/Users/%v", r.Org, r.ScimUserId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateAttributeForUserReq) Rel(link string, resp *UpdateAttributeForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// UpdateAttributeForUserReqBodyOperations is a value for UpdateAttributeForUserReqBody's Operations field
type UpdateAttributeForUserReqBodyOperations struct {
	Op    *string                                       `json:"op"`
	Path  *string                                       `json:"path,omitempty"`
	Value *UpdateAttributeForUserReqBodyOperationsValue `json:"value,omitempty"`
}

// UpdateAttributeForUserReqBodyOperationsValue is a value for UpdateAttributeForUserReqBodyOperations's Value field
type UpdateAttributeForUserReqBodyOperationsValue struct {
	Active     *bool   `json:"active,omitempty"`
	ExternalId *string `json:"externalId,omitempty"`
	FamilyName *string `json:"familyName,omitempty"`
	GivenName  *string `json:"givenName,omitempty"`
	UserName   *string `json:"userName,omitempty"`
}

/*
UpdateAttributeForUserReqBody is a request body for scim/update-attribute-for-user

https://developer.github.com/v3/scim/#update-an-attribute-for-a-scim-user
*/
type UpdateAttributeForUserReqBody struct {

	// Set of operations to be performed
	Operations []UpdateAttributeForUserReqBodyOperations `json:"Operations"`
	Schemas    []string                                  `json:"schemas,omitempty"`
}

/*
UpdateAttributeForUserResponse is a response for UpdateAttributeForUser

https://developer.github.com/v3/scim/#update-an-attribute-for-a-scim-user
*/
type UpdateAttributeForUserResponse struct {
	common.Response
	request *UpdateAttributeForUserReq
	Data    components.ScimUser
}
