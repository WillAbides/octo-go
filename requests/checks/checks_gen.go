// Code generated by octo-go; DO NOT EDIT.

package checks

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []options.Option

// NewClient returns a new Client
func NewClient(opt ...options.Option) Client {
	return opt
}

// Apply implements options.Option
func (c Client) Apply(opts *options.Options) error {
	for _, o := range c {
		err := o.Apply(opts)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
Create performs requests for "checks/create"

Create a check run.

  POST /repos/{owner}/{repo}/check-runs

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
func Create(ctx context.Context, req *CreateReq, opt ...options.Option) (*CreateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateReq)
	}
	resp := &CreateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CheckRun{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Create performs requests for "checks/create"

Create a check run.

  POST /repos/{owner}/{repo}/check-runs

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
func (c Client) Create(ctx context.Context, req *CreateReq, opt ...options.Option) (*CreateResponse, error) {
	return Create(ctx, req, append(c, opt...)...)
}

/*
CreateReq is request data for Client.Create

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
type CreateReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateReqBody

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"antiope"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "checks/create",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-runs", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateReq) Rel(link string, resp *CreateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateReqBodyActions is a value for CreateReqBody's Actions field
type CreateReqBodyActions struct {

	// A short explanation of what this action would do. The maximum size is 40 characters.
	Description *string `json:"description"`

	// A reference for the action on the integrator's system. The maximum size is 20 characters.
	Identifier *string `json:"identifier"`

	// The text to be displayed on a button in the web UI. The maximum size is 20 characters.
	Label *string `json:"label"`
}

// CreateReqBodyOutput is a value for CreateReqBody's Output field
type CreateReqBodyOutput struct {

	/*
	Adds information from your analysis to specific lines of code. Annotations are
	visible on GitHub in the **Checks** and **Files changed** tab of the pull
	request. The Checks API limits the number of annotations to a maximum of 50 per
	API request. To create more than 50 annotations, you have to make multiple
	requests to the [Update a check
	run](https://developer.github.com/v3/checks/runs/#update-a-check-run) endpoint.
	Each time you update the check run, annotations are appended to the list of
	annotations that already exist for the check run. For details about how you can
	view annotations on GitHub, see "[About status
	checks](https://help.github.com/articles/about-status-checks#checks)". See the
	[`annotations`
	object](https://developer.github.com/v3/checks/runs/#annotations-object)
	description for details about how to use this parameter.
	*/
	Annotations []CreateReqBodyOutputAnnotations `json:"annotations,omitempty"`

	/*
	Adds images to the output displayed in the GitHub pull request UI. See the
	[`images` object](https://developer.github.com/v3/checks/runs/#images-object)
	description for details.
	*/
	Images []CreateReqBodyOutputImages `json:"images,omitempty"`

	// The summary of the check run. This parameter supports Markdown.
	Summary *string `json:"summary"`

	// The details of the check run. This parameter supports Markdown.
	Text *string `json:"text,omitempty"`

	// The title of the check run.
	Title *string `json:"title"`
}

// CreateReqBodyOutputAnnotations is a value for CreateReqBodyOutput's Annotations field
type CreateReqBodyOutputAnnotations struct {

	// The level of the annotation. Can be one of `notice`, `warning`, or `failure`.
	AnnotationLevel *string `json:"annotation_level"`

	/*
	The end column of the annotation. Annotations only support `start_column` and
	`end_column` on the same line. Omit this parameter if `start_line` and
	`end_line` have different values.
	*/
	EndColumn *int64 `json:"end_column,omitempty"`

	// The end line of the annotation.
	EndLine *int64 `json:"end_line"`

	// A short description of the feedback for these lines of code. The maximum size is 64 KB.
	Message *string `json:"message"`

	// The path of the file to add an annotation to. For example, `assets/css/main.css`.
	Path *string `json:"path"`

	// Details about this annotation. The maximum size is 64 KB.
	RawDetails *string `json:"raw_details,omitempty"`

	/*
	The start column of the annotation. Annotations only support `start_column` and
	`end_column` on the same line. Omit this parameter if `start_line` and
	`end_line` have different values.
	*/
	StartColumn *int64 `json:"start_column,omitempty"`

	// The start line of the annotation.
	StartLine *int64 `json:"start_line"`

	// The title that represents the annotation. The maximum size is 255 characters.
	Title *string `json:"title,omitempty"`
}

// CreateReqBodyOutputImages is a value for CreateReqBodyOutput's Images field
type CreateReqBodyOutputImages struct {

	// The alternative text for the image.
	Alt *string `json:"alt"`

	// A short image description.
	Caption *string `json:"caption,omitempty"`

	// The full URL of the image.
	ImageUrl *string `json:"image_url"`
}

/*
CreateReqBody is a request body for checks/create

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
type CreateReqBody struct {

	/*
	Displays a button on GitHub that can be clicked to alert your app to do
	additional tasks. For example, a code linting app can display a button that
	automatically fixes detected errors. The button created in this object is
	displayed after the check run completes. When a user clicks the button, GitHub
	sends the [`check_run.requested_action`
	webhook](https://developer.github.com/webhooks/event-payloads/#check_run) to
	your app. Each action includes a `label`, `identifier` and `description`. A
	maximum of three actions are accepted. See the [`actions`
	object](https://developer.github.com/v3/checks/runs/#actions-object)
	description. To learn more about check runs and requested actions, see "[Check
	runs and requested
	actions](https://developer.github.com/v3/checks/runs/#check-runs-and-requested-actions)."
	To learn more about check runs and requested actions, see "[Check runs and
	requested
	actions](https://developer.github.com/v3/checks/runs/#check-runs-and-requested-actions)."
	*/
	Actions []CreateReqBodyActions `json:"actions,omitempty"`

	/*
	The time the check completed. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	CompletedAt *string `json:"completed_at,omitempty"`

	/*
	**Required if you provide `completed_at` or a `status` of `completed`**. The
	final conclusion of the check. Can be one of `success`, `failure`, `neutral`,
	`cancelled`, `skipped`, `timed_out`, or `action_required`. When the conclusion
	is `action_required`, additional details should be provided on the site
	specified by `details_url`.
	**Note:** Providing `conclusion` will automatically set the `status` parameter
	to `completed`. Only GitHub can change a check run conclusion to `stale`.
	*/
	Conclusion *string `json:"conclusion,omitempty"`

	/*
	The URL of the integrator's site that has the full details of the check. If the
	integrator does not provide this, then the homepage of the GitHub app is used.
	*/
	DetailsUrl *string `json:"details_url,omitempty"`

	// A reference for the run on the integrator's system.
	ExternalId *string `json:"external_id,omitempty"`

	// The SHA of the commit.
	HeadSha *string `json:"head_sha"`

	// The name of the check. For example, "code-coverage".
	Name *string `json:"name"`

	/*
	Check runs can accept a variety of data in the `output` object, including a
	`title` and `summary` and can optionally provide descriptive details about the
	run. See the [`output`
	object](https://developer.github.com/v3/checks/runs/#output-object) description.
	*/
	Output *CreateReqBodyOutput `json:"output,omitempty"`

	/*
	The time that the check run began. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	StartedAt *string `json:"started_at,omitempty"`

	// The current status. Can be one of `queued`, `in_progress`, or `completed`.
	Status *string `json:"status,omitempty"`
}

/*
CreateResponse is a response for Create

https://developer.github.com/v3/checks/runs/#create-a-check-run
*/
type CreateResponse struct {
	common.Response
	request *CreateReq
	Data    components.CheckRun
}

/*
CreateSuite performs requests for "checks/create-suite"

Create a check suite.

  POST /repos/{owner}/{repo}/check-suites

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
func CreateSuite(ctx context.Context, req *CreateSuiteReq, opt ...options.Option) (*CreateSuiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateSuiteReq)
	}
	resp := &CreateSuiteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CheckSuite{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateSuite performs requests for "checks/create-suite"

Create a check suite.

  POST /repos/{owner}/{repo}/check-suites

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
func (c Client) CreateSuite(ctx context.Context, req *CreateSuiteReq, opt ...options.Option) (*CreateSuiteResponse, error) {
	return CreateSuite(ctx, req, append(c, opt...)...)
}

/*
CreateSuiteReq is request data for Client.CreateSuite

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
type CreateSuiteReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateSuiteReqBody

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateSuiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateSuiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"antiope"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "checks/create-suite",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-suites", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateSuiteReq) Rel(link string, resp *CreateSuiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateSuiteReqBody is a request body for checks/create-suite

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
type CreateSuiteReqBody struct {

	// The sha of the head commit.
	HeadSha *string `json:"head_sha"`
}

/*
CreateSuiteResponse is a response for CreateSuite

https://developer.github.com/v3/checks/suites/#create-a-check-suite
*/
type CreateSuiteResponse struct {
	common.Response
	request *CreateSuiteReq
	Data    components.CheckSuite
}

/*
Get performs requests for "checks/get"

Get a check run.

  GET /repos/{owner}/{repo}/check-runs/{check_run_id}

https://developer.github.com/v3/checks/runs/#get-a-check-run
*/
func Get(ctx context.Context, req *GetReq, opt ...options.Option) (*GetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetReq)
	}
	resp := &GetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CheckRun{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Get performs requests for "checks/get"

Get a check run.

  GET /repos/{owner}/{repo}/check-runs/{check_run_id}

https://developer.github.com/v3/checks/runs/#get-a-check-run
*/
func (c Client) Get(ctx context.Context, req *GetReq, opt ...options.Option) (*GetResponse, error) {
	return Get(ctx, req, append(c, opt...)...)
}

/*
GetReq is request data for Client.Get

https://developer.github.com/v3/checks/runs/#get-a-check-run
*/
type GetReq struct {
	_url  string
	Owner string
	Repo  string

	// check_run_id parameter
	CheckRunId int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "checks/get",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-runs/%v", r.Owner, r.Repo, r.CheckRunId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReq) Rel(link string, resp *GetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetResponse is a response for Get

https://developer.github.com/v3/checks/runs/#get-a-check-run
*/
type GetResponse struct {
	common.Response
	request *GetReq
	Data    components.CheckRun
}

/*
GetSuite performs requests for "checks/get-suite"

Get a check suite.

  GET /repos/{owner}/{repo}/check-suites/{check_suite_id}

https://developer.github.com/v3/checks/suites/#get-a-check-suite
*/
func GetSuite(ctx context.Context, req *GetSuiteReq, opt ...options.Option) (*GetSuiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetSuiteReq)
	}
	resp := &GetSuiteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CheckSuite{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetSuite performs requests for "checks/get-suite"

Get a check suite.

  GET /repos/{owner}/{repo}/check-suites/{check_suite_id}

https://developer.github.com/v3/checks/suites/#get-a-check-suite
*/
func (c Client) GetSuite(ctx context.Context, req *GetSuiteReq, opt ...options.Option) (*GetSuiteResponse, error) {
	return GetSuite(ctx, req, append(c, opt...)...)
}

/*
GetSuiteReq is request data for Client.GetSuite

https://developer.github.com/v3/checks/suites/#get-a-check-suite
*/
type GetSuiteReq struct {
	_url  string
	Owner string
	Repo  string

	// check_suite_id parameter
	CheckSuiteId int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetSuiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetSuiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "checks/get-suite",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-suites/%v", r.Owner, r.Repo, r.CheckSuiteId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetSuiteReq) Rel(link string, resp *GetSuiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetSuiteResponse is a response for GetSuite

https://developer.github.com/v3/checks/suites/#get-a-check-suite
*/
type GetSuiteResponse struct {
	common.Response
	request *GetSuiteReq
	Data    components.CheckSuite
}

/*
ListAnnotations performs requests for "checks/list-annotations"

List check run annotations.

  GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations

https://developer.github.com/v3/checks/runs/#list-check-run-annotations
*/
func ListAnnotations(ctx context.Context, req *ListAnnotationsReq, opt ...options.Option) (*ListAnnotationsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListAnnotationsReq)
	}
	resp := &ListAnnotationsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CheckAnnotation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListAnnotations performs requests for "checks/list-annotations"

List check run annotations.

  GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations

https://developer.github.com/v3/checks/runs/#list-check-run-annotations
*/
func (c Client) ListAnnotations(ctx context.Context, req *ListAnnotationsReq, opt ...options.Option) (*ListAnnotationsResponse, error) {
	return ListAnnotations(ctx, req, append(c, opt...)...)
}

/*
ListAnnotationsReq is request data for Client.ListAnnotations

https://developer.github.com/v3/checks/runs/#list-check-run-annotations
*/
type ListAnnotationsReq struct {
	_url  string
	Owner string
	Repo  string

	// check_run_id parameter
	CheckRunId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListAnnotationsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListAnnotationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "checks/list-annotations",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-runs/%v/annotations", r.Owner, r.Repo, r.CheckRunId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListAnnotationsReq) Rel(link string, resp *ListAnnotationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListAnnotationsResponse is a response for ListAnnotations

https://developer.github.com/v3/checks/runs/#list-check-run-annotations
*/
type ListAnnotationsResponse struct {
	common.Response
	request *ListAnnotationsReq
	Data    []components.CheckAnnotation
}

/*
ListForRef performs requests for "checks/list-for-ref"

List check runs for a Git reference.

  GET /repos/{owner}/{repo}/commits/{ref}/check-runs

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
func ListForRef(ctx context.Context, req *ListForRefReq, opt ...options.Option) (*ListForRefResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForRefReq)
	}
	resp := &ListForRefResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ListForRefResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForRef performs requests for "checks/list-for-ref"

List check runs for a Git reference.

  GET /repos/{owner}/{repo}/commits/{ref}/check-runs

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
func (c Client) ListForRef(ctx context.Context, req *ListForRefReq, opt ...options.Option) (*ListForRefResponse, error) {
	return ListForRef(ctx, req, append(c, opt...)...)
}

/*
ListForRefReq is request data for Client.ListForRef

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
type ListForRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string

	// Returns check runs with the specified `name`.
	CheckName *string

	/*
	Returns check runs with the specified `status`. Can be one of `queued`,
	`in_progress`, or `completed`.
	*/
	Status *string

	/*
	Filters check runs by their `completed_at` timestamp. Can be one of `latest`
	(returning the most recent check runs) or `all`.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForRefReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.CheckName != nil {
		query.Set("check_name", *r.CheckName)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "checks/list-for-ref",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/check-runs", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForRefReq) Rel(link string, resp *ListForRefResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForRefResponseBody is a response body for ListForRef

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
type ListForRefResponseBody struct {
	CheckRuns  []components.CheckRun `json:"check_runs,omitempty"`
	TotalCount int64                 `json:"total_count,omitempty"`
}

/*
ListForRefResponse is a response for ListForRef

https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-git-reference
*/
type ListForRefResponse struct {
	common.Response
	request *ListForRefReq
	Data    ListForRefResponseBody
}

/*
ListForSuite performs requests for "checks/list-for-suite"

List check runs in a check suite.

  GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
func ListForSuite(ctx context.Context, req *ListForSuiteReq, opt ...options.Option) (*ListForSuiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForSuiteReq)
	}
	resp := &ListForSuiteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ListForSuiteResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForSuite performs requests for "checks/list-for-suite"

List check runs in a check suite.

  GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
func (c Client) ListForSuite(ctx context.Context, req *ListForSuiteReq, opt ...options.Option) (*ListForSuiteResponse, error) {
	return ListForSuite(ctx, req, append(c, opt...)...)
}

/*
ListForSuiteReq is request data for Client.ListForSuite

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
type ListForSuiteReq struct {
	_url  string
	Owner string
	Repo  string

	// check_suite_id parameter
	CheckSuiteId int64

	// Returns check runs with the specified `name`.
	CheckName *string

	/*
	Returns check runs with the specified `status`. Can be one of `queued`,
	`in_progress`, or `completed`.
	*/
	Status *string

	/*
	Filters check runs by their `completed_at` timestamp. Can be one of `latest`
	(returning the most recent check runs) or `all`.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForSuiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForSuiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.CheckName != nil {
		query.Set("check_name", *r.CheckName)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "checks/list-for-suite",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-suites/%v/check-runs", r.Owner, r.Repo, r.CheckSuiteId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForSuiteReq) Rel(link string, resp *ListForSuiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForSuiteResponseBody is a response body for ListForSuite

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
type ListForSuiteResponseBody struct {
	CheckRuns  []components.CheckRun `json:"check_runs,omitempty"`
	TotalCount int64                 `json:"total_count,omitempty"`
}

/*
ListForSuiteResponse is a response for ListForSuite

https://developer.github.com/v3/checks/runs/#list-check-runs-in-a-check-suite
*/
type ListForSuiteResponse struct {
	common.Response
	request *ListForSuiteReq
	Data    ListForSuiteResponseBody
}

/*
ListSuitesForRef performs requests for "checks/list-suites-for-ref"

List check suites for a Git reference.

  GET /repos/{owner}/{repo}/commits/{ref}/check-suites

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
func ListSuitesForRef(ctx context.Context, req *ListSuitesForRefReq, opt ...options.Option) (*ListSuitesForRefResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListSuitesForRefReq)
	}
	resp := &ListSuitesForRefResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ListSuitesForRefResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListSuitesForRef performs requests for "checks/list-suites-for-ref"

List check suites for a Git reference.

  GET /repos/{owner}/{repo}/commits/{ref}/check-suites

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
func (c Client) ListSuitesForRef(ctx context.Context, req *ListSuitesForRefReq, opt ...options.Option) (*ListSuitesForRefResponse, error) {
	return ListSuitesForRef(ctx, req, append(c, opt...)...)
}

/*
ListSuitesForRefReq is request data for Client.ListSuitesForRef

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
type ListSuitesForRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string

	// Filters check suites by GitHub App `id`.
	AppId *int64

	// Returns check runs with the specified `name`.
	CheckName *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListSuitesForRefReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListSuitesForRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.AppId != nil {
		query.Set("app_id", strconv.FormatInt(*r.AppId, 10))
	}
	if r.CheckName != nil {
		query.Set("check_name", *r.CheckName)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "checks/list-suites-for-ref",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/check-suites", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListSuitesForRefReq) Rel(link string, resp *ListSuitesForRefResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListSuitesForRefResponseBody is a response body for ListSuitesForRef

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
type ListSuitesForRefResponseBody struct {
	CheckSuites []components.CheckSuite `json:"check_suites,omitempty"`
	TotalCount  int64                   `json:"total_count,omitempty"`
}

/*
ListSuitesForRefResponse is a response for ListSuitesForRef

https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-git-reference
*/
type ListSuitesForRefResponse struct {
	common.Response
	request *ListSuitesForRefReq
	Data    ListSuitesForRefResponseBody
}

/*
RerequestSuite performs requests for "checks/rerequest-suite"

Rerequest a check suite.

  POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest

https://developer.github.com/v3/checks/suites/#rerequest-a-check-suite
*/
func RerequestSuite(ctx context.Context, req *RerequestSuiteReq, opt ...options.Option) (*RerequestSuiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RerequestSuiteReq)
	}
	resp := &RerequestSuiteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RerequestSuite performs requests for "checks/rerequest-suite"

Rerequest a check suite.

  POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest

https://developer.github.com/v3/checks/suites/#rerequest-a-check-suite
*/
func (c Client) RerequestSuite(ctx context.Context, req *RerequestSuiteReq, opt ...options.Option) (*RerequestSuiteResponse, error) {
	return RerequestSuite(ctx, req, append(c, opt...)...)
}

/*
RerequestSuiteReq is request data for Client.RerequestSuite

https://developer.github.com/v3/checks/suites/#rerequest-a-check-suite
*/
type RerequestSuiteReq struct {
	_url  string
	Owner string
	Repo  string

	// check_suite_id parameter
	CheckSuiteId int64

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *RerequestSuiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RerequestSuiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"antiope"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "POST",
		OperationID:      "checks/rerequest-suite",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-suites/%v/rerequest", r.Owner, r.Repo, r.CheckSuiteId),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RerequestSuiteReq) Rel(link string, resp *RerequestSuiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RerequestSuiteResponse is a response for RerequestSuite

https://developer.github.com/v3/checks/suites/#rerequest-a-check-suite
*/
type RerequestSuiteResponse struct {
	common.Response
	request *RerequestSuiteReq
}

/*
SetSuitesPreferences performs requests for "checks/set-suites-preferences"

Update repository preferences for check suites.

  PATCH /repos/{owner}/{repo}/check-suites/preferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
func SetSuitesPreferences(ctx context.Context, req *SetSuitesPreferencesReq, opt ...options.Option) (*SetSuitesPreferencesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetSuitesPreferencesReq)
	}
	resp := &SetSuitesPreferencesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CheckSuitePreference{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetSuitesPreferences performs requests for "checks/set-suites-preferences"

Update repository preferences for check suites.

  PATCH /repos/{owner}/{repo}/check-suites/preferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
func (c Client) SetSuitesPreferences(ctx context.Context, req *SetSuitesPreferencesReq, opt ...options.Option) (*SetSuitesPreferencesResponse, error) {
	return SetSuitesPreferences(ctx, req, append(c, opt...)...)
}

/*
SetSuitesPreferencesReq is request data for Client.SetSuitesPreferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
type SetSuitesPreferencesReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody SetSuitesPreferencesReqBody

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *SetSuitesPreferencesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetSuitesPreferencesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"antiope"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "checks/set-suites-preferences",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-suites/preferences", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetSuitesPreferencesReq) Rel(link string, resp *SetSuitesPreferencesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// SetSuitesPreferencesReqBodyAutoTriggerChecks is a value for SetSuitesPreferencesReqBody's AutoTriggerChecks field
type SetSuitesPreferencesReqBodyAutoTriggerChecks struct {

	// The `id` of the GitHub App.
	AppId *int64 `json:"app_id"`

	/*
	Set to `true` to enable automatic creation of CheckSuite events upon pushes to
	the repository, or `false` to disable them.
	*/
	Setting *bool `json:"setting"`
}

/*
SetSuitesPreferencesReqBody is a request body for checks/set-suites-preferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
type SetSuitesPreferencesReqBody struct {

	/*
	Enables or disables automatic creation of CheckSuite events upon pushes to the
	repository. Enabled by default. See the [`auto_trigger_checks`
	object](https://developer.github.com/v3/checks/suites/#auto_trigger_checks-object)
	description for details.
	*/
	AutoTriggerChecks []SetSuitesPreferencesReqBodyAutoTriggerChecks `json:"auto_trigger_checks,omitempty"`
}

/*
SetSuitesPreferencesResponse is a response for SetSuitesPreferences

https://developer.github.com/v3/checks/suites/#update-repository-preferences-for-check-suites
*/
type SetSuitesPreferencesResponse struct {
	common.Response
	request *SetSuitesPreferencesReq
	Data    components.CheckSuitePreference
}

/*
Update performs requests for "checks/update"

Update a check run.

  PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
func Update(ctx context.Context, req *UpdateReq, opt ...options.Option) (*UpdateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateReq)
	}
	resp := &UpdateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CheckRun{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Update performs requests for "checks/update"

Update a check run.

  PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
func (c Client) Update(ctx context.Context, req *UpdateReq, opt ...options.Option) (*UpdateResponse, error) {
	return Update(ctx, req, append(c, opt...)...)
}

/*
UpdateReq is request data for Client.Update

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
type UpdateReq struct {
	_url  string
	Owner string
	Repo  string

	// check_run_id parameter
	CheckRunId  int64
	RequestBody UpdateReqBody

	/*
	The Checks API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2018-05-07-new-checks-api-public-beta/)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	AntiopePreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"antiope"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "checks/update",
		Previews:         map[string]bool{"antiope": r.AntiopePreview},
		RequiredPreviews: []string{"antiope"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/check-runs/%v", r.Owner, r.Repo, r.CheckRunId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReq) Rel(link string, resp *UpdateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// UpdateReqBodyActions is a value for UpdateReqBody's Actions field
type UpdateReqBodyActions struct {

	// A short explanation of what this action would do. The maximum size is 40 characters.
	Description *string `json:"description"`

	// A reference for the action on the integrator's system. The maximum size is 20 characters.
	Identifier *string `json:"identifier"`

	// The text to be displayed on a button in the web UI. The maximum size is 20 characters.
	Label *string `json:"label"`
}

// UpdateReqBodyOutput is a value for UpdateReqBody's Output field
type UpdateReqBodyOutput struct {

	/*
	Adds information from your analysis to specific lines of code. Annotations are
	visible in GitHub's pull request UI. Annotations are visible in GitHub's pull
	request UI. The Checks API limits the number of annotations to a maximum of 50
	per API request. To create more than 50 annotations, you have to make multiple
	requests to the [Update a check
	run](https://developer.github.com/v3/checks/runs/#update-a-check-run) endpoint.
	Each time you update the check run, annotations are appended to the list of
	annotations that already exist for the check run. For details about annotations
	in the UI, see "[About status
	checks](https://help.github.com/articles/about-status-checks#checks)". See the
	[`annotations`
	object](https://developer.github.com/v3/checks/runs/#annotations-object-1)
	description for details.
	*/
	Annotations []UpdateReqBodyOutputAnnotations `json:"annotations,omitempty"`

	/*
	Adds images to the output displayed in the GitHub pull request UI. See the
	[`images`
	object](https://developer.github.com/v3/checks/runs/#annotations-object-1)
	description for details.
	*/
	Images []UpdateReqBodyOutputImages `json:"images,omitempty"`

	// Can contain Markdown.
	Summary *string `json:"summary"`

	// Can contain Markdown.
	Text *string `json:"text,omitempty"`

	// **Required**.
	Title *string `json:"title,omitempty"`
}

// UpdateReqBodyOutputAnnotations is a value for UpdateReqBodyOutput's Annotations field
type UpdateReqBodyOutputAnnotations struct {

	// The level of the annotation. Can be one of `notice`, `warning`, or `failure`.
	AnnotationLevel *string `json:"annotation_level"`

	/*
	The end column of the annotation. Annotations only support `start_column` and
	`end_column` on the same line. Omit this parameter if `start_line` and
	`end_line` have different values.
	*/
	EndColumn *int64 `json:"end_column,omitempty"`

	// The end line of the annotation.
	EndLine *int64 `json:"end_line"`

	// A short description of the feedback for these lines of code. The maximum size is 64 KB.
	Message *string `json:"message"`

	// The path of the file to add an annotation to. For example, `assets/css/main.css`.
	Path *string `json:"path"`

	// Details about this annotation. The maximum size is 64 KB.
	RawDetails *string `json:"raw_details,omitempty"`

	/*
	The start column of the annotation. Annotations only support `start_column` and
	`end_column` on the same line. Omit this parameter if `start_line` and
	`end_line` have different values.
	*/
	StartColumn *int64 `json:"start_column,omitempty"`

	// The start line of the annotation.
	StartLine *int64 `json:"start_line"`

	// The title that represents the annotation. The maximum size is 255 characters.
	Title *string `json:"title,omitempty"`
}

// UpdateReqBodyOutputImages is a value for UpdateReqBodyOutput's Images field
type UpdateReqBodyOutputImages struct {

	// The alternative text for the image.
	Alt *string `json:"alt"`

	// A short image description.
	Caption *string `json:"caption,omitempty"`

	// The full URL of the image.
	ImageUrl *string `json:"image_url"`
}

/*
UpdateReqBody is a request body for checks/update

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
type UpdateReqBody struct {

	/*
	Possible further actions the integrator can perform, which a user may trigger.
	Each action includes a `label`, `identifier` and `description`. A maximum of
	three actions are accepted. See the [`actions`
	object](https://developer.github.com/v3/checks/runs/#actions-object)
	description. To learn more about check runs and requested actions, see "[Check
	runs and requested
	actions](https://developer.github.com/v3/checks/runs/#check-runs-and-requested-actions)."
	*/
	Actions []UpdateReqBodyActions `json:"actions,omitempty"`

	/*
	The time the check completed. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	CompletedAt *string `json:"completed_at,omitempty"`

	/*
	**Required if you provide `completed_at` or a `status` of `completed`**. The
	final conclusion of the check. Can be one of `success`, `failure`, `neutral`,
	`cancelled`, `skipped`, `timed_out`, or `action_required`.
	**Note:** Providing `conclusion` will automatically set the `status` parameter
	to `completed`. Only GitHub can change a check run conclusion to `stale`.
	*/
	Conclusion *string `json:"conclusion,omitempty"`

	// The URL of the integrator's site that has the full details of the check.
	DetailsUrl *string `json:"details_url,omitempty"`

	// A reference for the run on the integrator's system.
	ExternalId *string `json:"external_id,omitempty"`

	// The name of the check. For example, "code-coverage".
	Name *string `json:"name,omitempty"`

	/*
	Check runs can accept a variety of data in the `output` object, including a
	`title` and `summary` and can optionally provide descriptive details about the
	run. See the [`output`
	object](https://developer.github.com/v3/checks/runs/#output-object-1)
	description.
	*/
	Output *UpdateReqBodyOutput `json:"output,omitempty"`

	// This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	StartedAt *string `json:"started_at,omitempty"`

	// The current status. Can be one of `queued`, `in_progress`, or `completed`.
	Status *string `json:"status,omitempty"`
}

/*
UpdateResponse is a response for Update

https://developer.github.com/v3/checks/runs/#update-a-check-run
*/
type UpdateResponse struct {
	common.Response
	request *UpdateReq
	Data    components.CheckRun
}
