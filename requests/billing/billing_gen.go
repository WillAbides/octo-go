// Code generated by octo-go; DO NOT EDIT.

package billing

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []options.Option

// NewClient returns a new Client
func NewClient(opt ...options.Option) Client {
	return opt
}

// Apply implements options.Option
func (c Client) Apply(opts *options.Options) error {
	for _, o := range c {
		err := o.Apply(opts)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetGithubActionsBillingGhe performs requests for "billing/get-github-actions-billing-ghe"

Get GitHub Actions billing for an enterprise.

  GET /enterprises/{enterprise_id}/settings/billing/actions

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-enterprise
*/
func GetGithubActionsBillingGhe(ctx context.Context, req *GetGithubActionsBillingGheReq, opt ...options.Option) (*GetGithubActionsBillingGheResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetGithubActionsBillingGheReq)
	}
	resp := &GetGithubActionsBillingGheResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ActionsBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetGithubActionsBillingGhe performs requests for "billing/get-github-actions-billing-ghe"

Get GitHub Actions billing for an enterprise.

  GET /enterprises/{enterprise_id}/settings/billing/actions

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-enterprise
*/
func (c Client) GetGithubActionsBillingGhe(ctx context.Context, req *GetGithubActionsBillingGheReq, opt ...options.Option) (*GetGithubActionsBillingGheResponse, error) {
	return GetGithubActionsBillingGhe(ctx, req, append(c, opt...)...)
}

/*
GetGithubActionsBillingGheReq is request data for Client.GetGithubActionsBillingGhe

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-enterprise
*/
type GetGithubActionsBillingGheReq struct {
	_url string

	// Unique identifier of the GitHub Enterprise Cloud instance.
	EnterpriseId string
}

// HTTPRequest builds an *http.Request
func (r *GetGithubActionsBillingGheReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetGithubActionsBillingGheReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-github-actions-billing-ghe",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/enterprises/%v/settings/billing/actions", r.EnterpriseId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetGithubActionsBillingGheReq) Rel(link string, resp *GetGithubActionsBillingGheResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetGithubActionsBillingGheResponse is a response for GetGithubActionsBillingGhe

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-enterprise
*/
type GetGithubActionsBillingGheResponse struct {
	common.Response
	request *GetGithubActionsBillingGheReq
	Data    components.ActionsBillingUsage
}

/*
GetGithubActionsBillingOrg performs requests for "billing/get-github-actions-billing-org"

Get GitHub Actions billing for an organization.

  GET /orgs/{org}/settings/billing/actions

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-organization
*/
func GetGithubActionsBillingOrg(ctx context.Context, req *GetGithubActionsBillingOrgReq, opt ...options.Option) (*GetGithubActionsBillingOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetGithubActionsBillingOrgReq)
	}
	resp := &GetGithubActionsBillingOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ActionsBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetGithubActionsBillingOrg performs requests for "billing/get-github-actions-billing-org"

Get GitHub Actions billing for an organization.

  GET /orgs/{org}/settings/billing/actions

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-organization
*/
func (c Client) GetGithubActionsBillingOrg(ctx context.Context, req *GetGithubActionsBillingOrgReq, opt ...options.Option) (*GetGithubActionsBillingOrgResponse, error) {
	return GetGithubActionsBillingOrg(ctx, req, append(c, opt...)...)
}

/*
GetGithubActionsBillingOrgReq is request data for Client.GetGithubActionsBillingOrg

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-organization
*/
type GetGithubActionsBillingOrgReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *GetGithubActionsBillingOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetGithubActionsBillingOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-github-actions-billing-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/settings/billing/actions", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetGithubActionsBillingOrgReq) Rel(link string, resp *GetGithubActionsBillingOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetGithubActionsBillingOrgResponse is a response for GetGithubActionsBillingOrg

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-organization
*/
type GetGithubActionsBillingOrgResponse struct {
	common.Response
	request *GetGithubActionsBillingOrgReq
	Data    components.ActionsBillingUsage
}

/*
GetGithubActionsBillingUser performs requests for "billing/get-github-actions-billing-user"

Get GitHub Actions billing for a user.

  GET /users/{username}/settings/billing/actions

https://developer.github.com/v3/billing/#get-github-actions-billing-for-a-user
*/
func GetGithubActionsBillingUser(ctx context.Context, req *GetGithubActionsBillingUserReq, opt ...options.Option) (*GetGithubActionsBillingUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetGithubActionsBillingUserReq)
	}
	resp := &GetGithubActionsBillingUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ActionsBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetGithubActionsBillingUser performs requests for "billing/get-github-actions-billing-user"

Get GitHub Actions billing for a user.

  GET /users/{username}/settings/billing/actions

https://developer.github.com/v3/billing/#get-github-actions-billing-for-a-user
*/
func (c Client) GetGithubActionsBillingUser(ctx context.Context, req *GetGithubActionsBillingUserReq, opt ...options.Option) (*GetGithubActionsBillingUserResponse, error) {
	return GetGithubActionsBillingUser(ctx, req, append(c, opt...)...)
}

/*
GetGithubActionsBillingUserReq is request data for Client.GetGithubActionsBillingUser

https://developer.github.com/v3/billing/#get-github-actions-billing-for-a-user
*/
type GetGithubActionsBillingUserReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetGithubActionsBillingUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetGithubActionsBillingUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-github-actions-billing-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/settings/billing/actions", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetGithubActionsBillingUserReq) Rel(link string, resp *GetGithubActionsBillingUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetGithubActionsBillingUserResponse is a response for GetGithubActionsBillingUser

https://developer.github.com/v3/billing/#get-github-actions-billing-for-a-user
*/
type GetGithubActionsBillingUserResponse struct {
	common.Response
	request *GetGithubActionsBillingUserReq
	Data    components.ActionsBillingUsage
}

/*
GetGithubPackagesBillingGhe performs requests for "billing/get-github-packages-billing-ghe"

Get GitHub Packages billing for an enterprise.

  GET /enterprises/{enterprise_id}/settings/billing/packages

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-enterprise
*/
func GetGithubPackagesBillingGhe(ctx context.Context, req *GetGithubPackagesBillingGheReq, opt ...options.Option) (*GetGithubPackagesBillingGheResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetGithubPackagesBillingGheReq)
	}
	resp := &GetGithubPackagesBillingGheResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PackagesBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetGithubPackagesBillingGhe performs requests for "billing/get-github-packages-billing-ghe"

Get GitHub Packages billing for an enterprise.

  GET /enterprises/{enterprise_id}/settings/billing/packages

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-enterprise
*/
func (c Client) GetGithubPackagesBillingGhe(ctx context.Context, req *GetGithubPackagesBillingGheReq, opt ...options.Option) (*GetGithubPackagesBillingGheResponse, error) {
	return GetGithubPackagesBillingGhe(ctx, req, append(c, opt...)...)
}

/*
GetGithubPackagesBillingGheReq is request data for Client.GetGithubPackagesBillingGhe

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-enterprise
*/
type GetGithubPackagesBillingGheReq struct {
	_url string

	// Unique identifier of the GitHub Enterprise Cloud instance.
	EnterpriseId string
}

// HTTPRequest builds an *http.Request
func (r *GetGithubPackagesBillingGheReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetGithubPackagesBillingGheReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-github-packages-billing-ghe",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/enterprises/%v/settings/billing/packages", r.EnterpriseId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetGithubPackagesBillingGheReq) Rel(link string, resp *GetGithubPackagesBillingGheResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetGithubPackagesBillingGheResponse is a response for GetGithubPackagesBillingGhe

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-enterprise
*/
type GetGithubPackagesBillingGheResponse struct {
	common.Response
	request *GetGithubPackagesBillingGheReq
	Data    components.PackagesBillingUsage
}

/*
GetGithubPackagesBillingOrg performs requests for "billing/get-github-packages-billing-org"

Get GitHub Packages billing for an organization.

  GET /orgs/{org}/settings/billing/packages

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-organization
*/
func GetGithubPackagesBillingOrg(ctx context.Context, req *GetGithubPackagesBillingOrgReq, opt ...options.Option) (*GetGithubPackagesBillingOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetGithubPackagesBillingOrgReq)
	}
	resp := &GetGithubPackagesBillingOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PackagesBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetGithubPackagesBillingOrg performs requests for "billing/get-github-packages-billing-org"

Get GitHub Packages billing for an organization.

  GET /orgs/{org}/settings/billing/packages

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-organization
*/
func (c Client) GetGithubPackagesBillingOrg(ctx context.Context, req *GetGithubPackagesBillingOrgReq, opt ...options.Option) (*GetGithubPackagesBillingOrgResponse, error) {
	return GetGithubPackagesBillingOrg(ctx, req, append(c, opt...)...)
}

/*
GetGithubPackagesBillingOrgReq is request data for Client.GetGithubPackagesBillingOrg

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-organization
*/
type GetGithubPackagesBillingOrgReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *GetGithubPackagesBillingOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetGithubPackagesBillingOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-github-packages-billing-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/settings/billing/packages", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetGithubPackagesBillingOrgReq) Rel(link string, resp *GetGithubPackagesBillingOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetGithubPackagesBillingOrgResponse is a response for GetGithubPackagesBillingOrg

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-organization
*/
type GetGithubPackagesBillingOrgResponse struct {
	common.Response
	request *GetGithubPackagesBillingOrgReq
	Data    components.PackagesBillingUsage
}

/*
GetGithubPackagesBillingUser performs requests for "billing/get-github-packages-billing-user"

Get GitHub Packages billing for a user.

  GET /users/{username}/settings/billing/packages

https://developer.github.com/v3/billing/#get-github-packages-billing-for-a-user
*/
func GetGithubPackagesBillingUser(ctx context.Context, req *GetGithubPackagesBillingUserReq, opt ...options.Option) (*GetGithubPackagesBillingUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetGithubPackagesBillingUserReq)
	}
	resp := &GetGithubPackagesBillingUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PackagesBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetGithubPackagesBillingUser performs requests for "billing/get-github-packages-billing-user"

Get GitHub Packages billing for a user.

  GET /users/{username}/settings/billing/packages

https://developer.github.com/v3/billing/#get-github-packages-billing-for-a-user
*/
func (c Client) GetGithubPackagesBillingUser(ctx context.Context, req *GetGithubPackagesBillingUserReq, opt ...options.Option) (*GetGithubPackagesBillingUserResponse, error) {
	return GetGithubPackagesBillingUser(ctx, req, append(c, opt...)...)
}

/*
GetGithubPackagesBillingUserReq is request data for Client.GetGithubPackagesBillingUser

https://developer.github.com/v3/billing/#get-github-packages-billing-for-a-user
*/
type GetGithubPackagesBillingUserReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetGithubPackagesBillingUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetGithubPackagesBillingUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-github-packages-billing-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/settings/billing/packages", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetGithubPackagesBillingUserReq) Rel(link string, resp *GetGithubPackagesBillingUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetGithubPackagesBillingUserResponse is a response for GetGithubPackagesBillingUser

https://developer.github.com/v3/billing/#get-github-packages-billing-for-a-user
*/
type GetGithubPackagesBillingUserResponse struct {
	common.Response
	request *GetGithubPackagesBillingUserReq
	Data    components.PackagesBillingUsage
}

/*
GetSharedStorageBillingGhe performs requests for "billing/get-shared-storage-billing-ghe"

Get shared storage billing for an enterprise.

  GET /enterprises/{enterprise_id}/settings/billing/shared-storage

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-enterprise
*/
func GetSharedStorageBillingGhe(ctx context.Context, req *GetSharedStorageBillingGheReq, opt ...options.Option) (*GetSharedStorageBillingGheResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetSharedStorageBillingGheReq)
	}
	resp := &GetSharedStorageBillingGheResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CombinedBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetSharedStorageBillingGhe performs requests for "billing/get-shared-storage-billing-ghe"

Get shared storage billing for an enterprise.

  GET /enterprises/{enterprise_id}/settings/billing/shared-storage

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-enterprise
*/
func (c Client) GetSharedStorageBillingGhe(ctx context.Context, req *GetSharedStorageBillingGheReq, opt ...options.Option) (*GetSharedStorageBillingGheResponse, error) {
	return GetSharedStorageBillingGhe(ctx, req, append(c, opt...)...)
}

/*
GetSharedStorageBillingGheReq is request data for Client.GetSharedStorageBillingGhe

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-enterprise
*/
type GetSharedStorageBillingGheReq struct {
	_url string

	// Unique identifier of the GitHub Enterprise Cloud instance.
	EnterpriseId string
}

// HTTPRequest builds an *http.Request
func (r *GetSharedStorageBillingGheReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetSharedStorageBillingGheReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-shared-storage-billing-ghe",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/enterprises/%v/settings/billing/shared-storage", r.EnterpriseId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetSharedStorageBillingGheReq) Rel(link string, resp *GetSharedStorageBillingGheResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetSharedStorageBillingGheResponse is a response for GetSharedStorageBillingGhe

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-enterprise
*/
type GetSharedStorageBillingGheResponse struct {
	common.Response
	request *GetSharedStorageBillingGheReq
	Data    components.CombinedBillingUsage
}

/*
GetSharedStorageBillingOrg performs requests for "billing/get-shared-storage-billing-org"

Get shared storage billing for an organization.

  GET /orgs/{org}/settings/billing/shared-storage

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-organization
*/
func GetSharedStorageBillingOrg(ctx context.Context, req *GetSharedStorageBillingOrgReq, opt ...options.Option) (*GetSharedStorageBillingOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetSharedStorageBillingOrgReq)
	}
	resp := &GetSharedStorageBillingOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CombinedBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetSharedStorageBillingOrg performs requests for "billing/get-shared-storage-billing-org"

Get shared storage billing for an organization.

  GET /orgs/{org}/settings/billing/shared-storage

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-organization
*/
func (c Client) GetSharedStorageBillingOrg(ctx context.Context, req *GetSharedStorageBillingOrgReq, opt ...options.Option) (*GetSharedStorageBillingOrgResponse, error) {
	return GetSharedStorageBillingOrg(ctx, req, append(c, opt...)...)
}

/*
GetSharedStorageBillingOrgReq is request data for Client.GetSharedStorageBillingOrg

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-organization
*/
type GetSharedStorageBillingOrgReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *GetSharedStorageBillingOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetSharedStorageBillingOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-shared-storage-billing-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/settings/billing/shared-storage", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetSharedStorageBillingOrgReq) Rel(link string, resp *GetSharedStorageBillingOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetSharedStorageBillingOrgResponse is a response for GetSharedStorageBillingOrg

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-organization
*/
type GetSharedStorageBillingOrgResponse struct {
	common.Response
	request *GetSharedStorageBillingOrgReq
	Data    components.CombinedBillingUsage
}

/*
GetSharedStorageBillingUser performs requests for "billing/get-shared-storage-billing-user"

Get shared storage billing for a user.

  GET /users/{username}/settings/billing/shared-storage

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-a-user
*/
func GetSharedStorageBillingUser(ctx context.Context, req *GetSharedStorageBillingUserReq, opt ...options.Option) (*GetSharedStorageBillingUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetSharedStorageBillingUserReq)
	}
	resp := &GetSharedStorageBillingUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CombinedBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetSharedStorageBillingUser performs requests for "billing/get-shared-storage-billing-user"

Get shared storage billing for a user.

  GET /users/{username}/settings/billing/shared-storage

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-a-user
*/
func (c Client) GetSharedStorageBillingUser(ctx context.Context, req *GetSharedStorageBillingUserReq, opt ...options.Option) (*GetSharedStorageBillingUserResponse, error) {
	return GetSharedStorageBillingUser(ctx, req, append(c, opt...)...)
}

/*
GetSharedStorageBillingUserReq is request data for Client.GetSharedStorageBillingUser

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-a-user
*/
type GetSharedStorageBillingUserReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetSharedStorageBillingUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetSharedStorageBillingUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-shared-storage-billing-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/settings/billing/shared-storage", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetSharedStorageBillingUserReq) Rel(link string, resp *GetSharedStorageBillingUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetSharedStorageBillingUserResponse is a response for GetSharedStorageBillingUser

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-a-user
*/
type GetSharedStorageBillingUserResponse struct {
	common.Response
	request *GetSharedStorageBillingUserReq
	Data    components.CombinedBillingUsage
}
