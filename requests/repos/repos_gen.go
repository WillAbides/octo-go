// Code generated by octo-go; DO NOT EDIT.

package repos

import (
	"context"
	"encoding/json"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"io"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []options.Option

// NewClient returns a new Client
func NewClient(opt ...options.Option) Client {
	return opt
}

// Apply implements options.Option
func (c Client) Apply(opts *options.Options) error {
	for _, o := range c {
		err := o.Apply(opts)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
AcceptInvitation performs requests for "repos/accept-invitation"

Accept a repository invitation.

  PATCH /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
func AcceptInvitation(ctx context.Context, req *AcceptInvitationReq, opt ...options.Option) (*AcceptInvitationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AcceptInvitationReq)
	}
	resp := &AcceptInvitationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AcceptInvitation performs requests for "repos/accept-invitation"

Accept a repository invitation.

  PATCH /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
func (c Client) AcceptInvitation(ctx context.Context, req *AcceptInvitationReq, opt ...options.Option) (*AcceptInvitationResponse, error) {
	return AcceptInvitation(ctx, req, append(c, opt...)...)
}

/*
AcceptInvitationReq is request data for Client.AcceptInvitation

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
type AcceptInvitationReq struct {
	_url string

	// invitation_id parameter
	InvitationId int64
}

// HTTPRequest builds an *http.Request
func (r *AcceptInvitationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AcceptInvitationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PATCH",
		OperationID:      "repos/accept-invitation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/repository_invitations/%v", r.InvitationId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AcceptInvitationReq) Rel(link string, resp *AcceptInvitationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AcceptInvitationResponse is a response for AcceptInvitation

https://developer.github.com/v3/repos/invitations/#accept-a-repository-invitation
*/
type AcceptInvitationResponse struct {
	common.Response
	request *AcceptInvitationReq
}

/*
AddAppAccessRestrictions performs requests for "repos/add-app-access-restrictions"

Add app access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
func AddAppAccessRestrictions(ctx context.Context, req *AddAppAccessRestrictionsReq, opt ...options.Option) (*AddAppAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddAppAccessRestrictionsReq)
	}
	resp := &AddAppAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Integration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddAppAccessRestrictions performs requests for "repos/add-app-access-restrictions"

Add app access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
func (c Client) AddAppAccessRestrictions(ctx context.Context, req *AddAppAccessRestrictionsReq, opt ...options.Option) (*AddAppAccessRestrictionsResponse, error) {
	return AddAppAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
AddAppAccessRestrictionsReq is request data for Client.AddAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
type AddAppAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody AddAppAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddAppAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddAppAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/add-app-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddAppAccessRestrictionsReq) Rel(link string, resp *AddAppAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddAppAccessRestrictionsReqBody is a request body for repos/add-app-access-restrictions

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
type AddAppAccessRestrictionsReqBody []string

/*
AddAppAccessRestrictionsResponse is a response for AddAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-app-access-restrictions
*/
type AddAppAccessRestrictionsResponse struct {
	common.Response
	request *AddAppAccessRestrictionsReq
	Data    []components.Integration
}

/*
AddCollaborator performs requests for "repos/add-collaborator"

Add a repository collaborator.

  PUT /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
func AddCollaborator(ctx context.Context, req *AddCollaboratorReq, opt ...options.Option) (*AddCollaboratorResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddCollaboratorReq)
	}
	resp := &AddCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.RepositoryInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddCollaborator performs requests for "repos/add-collaborator"

Add a repository collaborator.

  PUT /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
func (c Client) AddCollaborator(ctx context.Context, req *AddCollaboratorReq, opt ...options.Option) (*AddCollaboratorResponse, error) {
	return AddCollaborator(ctx, req, append(c, opt...)...)
}

/*
AddCollaboratorReq is request data for Client.AddCollaborator

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
type AddCollaboratorReq struct {
	_url        string
	Owner       string
	Repo        string
	Username    string
	RequestBody AddCollaboratorReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddCollaboratorReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/add-collaborator",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{201, 204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddCollaboratorReq) Rel(link string, resp *AddCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddCollaboratorReqBody is a request body for repos/add-collaborator

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
type AddCollaboratorReqBody struct {

	/*
	The permission to grant the collaborator. **Only valid on organization-owned
	repositories.** Can be one of:
	\* `pull` - can pull, but not push to or administer this repository.
	\* `push` - can pull and push, but not administer this repository.
	\* `admin` - can pull, push and administer this repository.
	\* `maintain` - Recommended for project managers who need to manage the
	repository without access to sensitive or destructive actions.
	\* `triage` - Recommended for contributors who need to proactively manage issues
	and pull requests without write access.
	*/
	Permission  *string `json:"permission,omitempty"`
	Permissions *string `json:"permissions,omitempty"`
}

/*
AddCollaboratorResponse is a response for AddCollaborator

https://developer.github.com/v3/repos/collaborators/#add-a-repository-collaborator
*/
type AddCollaboratorResponse struct {
	common.Response
	request *AddCollaboratorReq
	Data    components.RepositoryInvitation
}

/*
AddStatusCheckContexts performs requests for "repos/add-status-check-contexts"

Add status check contexts.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
func AddStatusCheckContexts(ctx context.Context, req *AddStatusCheckContextsReq, opt ...options.Option) (*AddStatusCheckContextsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddStatusCheckContextsReq)
	}
	resp := &AddStatusCheckContextsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = AddStatusCheckContextsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddStatusCheckContexts performs requests for "repos/add-status-check-contexts"

Add status check contexts.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
func (c Client) AddStatusCheckContexts(ctx context.Context, req *AddStatusCheckContextsReq, opt ...options.Option) (*AddStatusCheckContextsResponse, error) {
	return AddStatusCheckContexts(ctx, req, append(c, opt...)...)
}

/*
AddStatusCheckContextsReq is request data for Client.AddStatusCheckContexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
type AddStatusCheckContextsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody AddStatusCheckContextsReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddStatusCheckContextsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddStatusCheckContextsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/add-status-check-contexts",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddStatusCheckContextsReq) Rel(link string, resp *AddStatusCheckContextsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddStatusCheckContextsReqBody is a request body for repos/add-status-check-contexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
type AddStatusCheckContextsReqBody []string

/*
AddStatusCheckContextsResponseBody is a response body for AddStatusCheckContexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
type AddStatusCheckContextsResponseBody []string

/*
AddStatusCheckContextsResponse is a response for AddStatusCheckContexts

https://developer.github.com/v3/repos/branches/#add-status-check-contexts
*/
type AddStatusCheckContextsResponse struct {
	common.Response
	request *AddStatusCheckContextsReq
	Data    AddStatusCheckContextsResponseBody
}

/*
AddTeamAccessRestrictions performs requests for "repos/add-team-access-restrictions"

Add team access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
func AddTeamAccessRestrictions(ctx context.Context, req *AddTeamAccessRestrictionsReq, opt ...options.Option) (*AddTeamAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddTeamAccessRestrictionsReq)
	}
	resp := &AddTeamAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddTeamAccessRestrictions performs requests for "repos/add-team-access-restrictions"

Add team access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
func (c Client) AddTeamAccessRestrictions(ctx context.Context, req *AddTeamAccessRestrictionsReq, opt ...options.Option) (*AddTeamAccessRestrictionsResponse, error) {
	return AddTeamAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
AddTeamAccessRestrictionsReq is request data for Client.AddTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
type AddTeamAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody AddTeamAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddTeamAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddTeamAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/add-team-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddTeamAccessRestrictionsReq) Rel(link string, resp *AddTeamAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddTeamAccessRestrictionsReqBody is a request body for repos/add-team-access-restrictions

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
type AddTeamAccessRestrictionsReqBody []string

/*
AddTeamAccessRestrictionsResponse is a response for AddTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-team-access-restrictions
*/
type AddTeamAccessRestrictionsResponse struct {
	common.Response
	request *AddTeamAccessRestrictionsReq
	Data    []components.Team
}

/*
AddUserAccessRestrictions performs requests for "repos/add-user-access-restrictions"

Add user access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
func AddUserAccessRestrictions(ctx context.Context, req *AddUserAccessRestrictionsReq, opt ...options.Option) (*AddUserAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddUserAccessRestrictionsReq)
	}
	resp := &AddUserAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddUserAccessRestrictions performs requests for "repos/add-user-access-restrictions"

Add user access restrictions.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
func (c Client) AddUserAccessRestrictions(ctx context.Context, req *AddUserAccessRestrictionsReq, opt ...options.Option) (*AddUserAccessRestrictionsResponse, error) {
	return AddUserAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
AddUserAccessRestrictionsReq is request data for Client.AddUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
type AddUserAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody AddUserAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddUserAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddUserAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/add-user-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddUserAccessRestrictionsReq) Rel(link string, resp *AddUserAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddUserAccessRestrictionsReqBody is a request body for repos/add-user-access-restrictions

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
type AddUserAccessRestrictionsReqBody []string

/*
AddUserAccessRestrictionsResponse is a response for AddUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#add-user-access-restrictions
*/
type AddUserAccessRestrictionsResponse struct {
	common.Response
	request *AddUserAccessRestrictionsReq
	Data    []components.SimpleUser
}

/*
CheckCollaborator performs requests for "repos/check-collaborator"

Check if a user is a repository collaborator.

  GET /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-repository-collaborator
*/
func CheckCollaborator(ctx context.Context, req *CheckCollaboratorReq, opt ...options.Option) (*CheckCollaboratorResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckCollaboratorReq)
	}
	resp := &CheckCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckCollaborator performs requests for "repos/check-collaborator"

Check if a user is a repository collaborator.

  GET /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-repository-collaborator
*/
func (c Client) CheckCollaborator(ctx context.Context, req *CheckCollaboratorReq, opt ...options.Option) (*CheckCollaboratorResponse, error) {
	return CheckCollaborator(ctx, req, append(c, opt...)...)
}

/*
CheckCollaboratorReq is request data for Client.CheckCollaborator

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-repository-collaborator
*/
type CheckCollaboratorReq struct {
	_url     string
	Owner    string
	Repo     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *CheckCollaboratorReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "repos/check-collaborator",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckCollaboratorReq) Rel(link string, resp *CheckCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckCollaboratorResponse is a response for CheckCollaborator

https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-repository-collaborator
*/
type CheckCollaboratorResponse struct {
	common.Response
	request *CheckCollaboratorReq
	Data    bool
}

/*
CheckVulnerabilityAlerts performs requests for "repos/check-vulnerability-alerts"

Check if vulnerability alerts are enabled for a repository.

  GET /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
func CheckVulnerabilityAlerts(ctx context.Context, req *CheckVulnerabilityAlertsReq, opt ...options.Option) (*CheckVulnerabilityAlertsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckVulnerabilityAlertsReq)
	}
	resp := &CheckVulnerabilityAlertsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckVulnerabilityAlerts performs requests for "repos/check-vulnerability-alerts"

Check if vulnerability alerts are enabled for a repository.

  GET /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
func (c Client) CheckVulnerabilityAlerts(ctx context.Context, req *CheckVulnerabilityAlertsReq, opt ...options.Option) (*CheckVulnerabilityAlertsResponse, error) {
	return CheckVulnerabilityAlerts(ctx, req, append(c, opt...)...)
}

/*
CheckVulnerabilityAlertsReq is request data for Client.CheckVulnerabilityAlerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
type CheckVulnerabilityAlertsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling dependency alerts for a repository using the REST API is
	currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CheckVulnerabilityAlertsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckVulnerabilityAlertsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"dorian"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "repos/check-vulnerability-alerts",
		Previews:         map[string]bool{"dorian": r.DorianPreview},
		RequiredPreviews: []string{"dorian"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckVulnerabilityAlertsReq) Rel(link string, resp *CheckVulnerabilityAlertsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckVulnerabilityAlertsResponse is a response for CheckVulnerabilityAlerts

https://developer.github.com/v3/repos/#check-if-vulnerability-alerts-are-enabled-for-a-repository
*/
type CheckVulnerabilityAlertsResponse struct {
	common.Response
	request *CheckVulnerabilityAlertsReq
	Data    bool
}

/*
CompareCommits performs requests for "repos/compare-commits"

Compare two commits.

  GET /repos/{owner}/{repo}/compare/{base}...{head}

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
func CompareCommits(ctx context.Context, req *CompareCommitsReq, opt ...options.Option) (*CompareCommitsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CompareCommitsReq)
	}
	resp := &CompareCommitsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CommitComparison{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CompareCommits performs requests for "repos/compare-commits"

Compare two commits.

  GET /repos/{owner}/{repo}/compare/{base}...{head}

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
func (c Client) CompareCommits(ctx context.Context, req *CompareCommitsReq, opt ...options.Option) (*CompareCommitsResponse, error) {
	return CompareCommits(ctx, req, append(c, opt...)...)
}

/*
CompareCommitsReq is request data for Client.CompareCommits

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
type CompareCommitsReq struct {
	_url  string
	Owner string
	Repo  string

	// base parameter
	Base string

	// head parameter
	Head string
}

// HTTPRequest builds an *http.Request
func (r *CompareCommitsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CompareCommitsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/compare-commits",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/compare/%v...%v", r.Owner, r.Repo, r.Base, r.Head),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CompareCommitsReq) Rel(link string, resp *CompareCommitsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CompareCommitsResponse is a response for CompareCommits

https://developer.github.com/v3/repos/commits/#compare-two-commits
*/
type CompareCommitsResponse struct {
	common.Response
	request *CompareCommitsReq
	Data    components.CommitComparison
}

/*
CreateCommitComment performs requests for "repos/create-commit-comment"

Create a commit comment.

  POST /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
func CreateCommitComment(ctx context.Context, req *CreateCommitCommentReq, opt ...options.Option) (*CreateCommitCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateCommitCommentReq)
	}
	resp := &CreateCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CommitComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateCommitComment performs requests for "repos/create-commit-comment"

Create a commit comment.

  POST /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
func (c Client) CreateCommitComment(ctx context.Context, req *CreateCommitCommentReq, opt ...options.Option) (*CreateCommitCommentResponse, error) {
	return CreateCommitComment(ctx, req, append(c, opt...)...)
}

/*
CreateCommitCommentReq is request data for Client.CreateCommitComment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type CreateCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// commit_sha+ parameter
	CommitSha   string
	RequestBody CreateCommitCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateCommitCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-commit-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/comments", r.Owner, r.Repo, r.CommitSha),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateCommitCommentReq) Rel(link string, resp *CreateCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateCommitCommentReqBody is a request body for repos/create-commit-comment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type CreateCommitCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`

	// **Deprecated**. Use **position** parameter instead. Line number in the file to comment on.
	Line *int64 `json:"line,omitempty"`

	// Relative path of the file to comment on.
	Path *string `json:"path,omitempty"`

	// Line index in the diff to comment on.
	Position *int64 `json:"position,omitempty"`
}

/*
CreateCommitCommentResponse is a response for CreateCommitComment

https://developer.github.com/v3/repos/comments/#create-a-commit-comment
*/
type CreateCommitCommentResponse struct {
	common.Response
	request *CreateCommitCommentReq
	Data    components.CommitComment
}

/*
CreateCommitSignatureProtection performs requests for "repos/create-commit-signature-protection"

Create commit signature protection.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#create-commit-signature-protection
*/
func CreateCommitSignatureProtection(ctx context.Context, req *CreateCommitSignatureProtectionReq, opt ...options.Option) (*CreateCommitSignatureProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateCommitSignatureProtectionReq)
	}
	resp := &CreateCommitSignatureProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranchAdminEnforced{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateCommitSignatureProtection performs requests for "repos/create-commit-signature-protection"

Create commit signature protection.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#create-commit-signature-protection
*/
func (c Client) CreateCommitSignatureProtection(ctx context.Context, req *CreateCommitSignatureProtectionReq, opt ...options.Option) (*CreateCommitSignatureProtectionResponse, error) {
	return CreateCommitSignatureProtection(ctx, req, append(c, opt...)...)
}

/*
CreateCommitSignatureProtectionReq is request data for Client.CreateCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#create-commit-signature-protection
*/
type CreateCommitSignatureProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateCommitSignatureProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateCommitSignatureProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"zzzax"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "POST",
		OperationID:      "repos/create-commit-signature-protection",
		Previews:         map[string]bool{"zzzax": r.ZzzaxPreview},
		RequiredPreviews: []string{"zzzax"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateCommitSignatureProtectionReq) Rel(link string, resp *CreateCommitSignatureProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateCommitSignatureProtectionResponse is a response for CreateCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#create-commit-signature-protection
*/
type CreateCommitSignatureProtectionResponse struct {
	common.Response
	request *CreateCommitSignatureProtectionReq
	Data    components.ProtectedBranchAdminEnforced
}

/*
CreateCommitStatus performs requests for "repos/create-commit-status"

Create a commit status.

  POST /repos/{owner}/{repo}/statuses/{sha}

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
func CreateCommitStatus(ctx context.Context, req *CreateCommitStatusReq, opt ...options.Option) (*CreateCommitStatusResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateCommitStatusReq)
	}
	resp := &CreateCommitStatusResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Status{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateCommitStatus performs requests for "repos/create-commit-status"

Create a commit status.

  POST /repos/{owner}/{repo}/statuses/{sha}

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
func (c Client) CreateCommitStatus(ctx context.Context, req *CreateCommitStatusReq, opt ...options.Option) (*CreateCommitStatusResponse, error) {
	return CreateCommitStatus(ctx, req, append(c, opt...)...)
}

/*
CreateCommitStatusReq is request data for Client.CreateCommitStatus

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
type CreateCommitStatusReq struct {
	_url  string
	Owner string
	Repo  string

	// sha parameter
	Sha         string
	RequestBody CreateCommitStatusReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateCommitStatusReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateCommitStatusReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-commit-status",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/statuses/%v", r.Owner, r.Repo, r.Sha),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateCommitStatusReq) Rel(link string, resp *CreateCommitStatusResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateCommitStatusReqBody is a request body for repos/create-commit-status

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
type CreateCommitStatusReqBody struct {

	// A string label to differentiate this status from the status of other systems.
	Context *string `json:"context,omitempty"`

	// A short description of the status.
	Description *string `json:"description,omitempty"`

	// The state of the status. Can be one of `error`, `failure`, `pending`, or `success`.
	State *string `json:"state"`

	/*
	The target URL to associate with this status. This URL will be linked from the
	GitHub UI to allow users to easily see the source of the status.
	For example, if your continuous integration system is posting build status, you
	would want to provide the deep link for the build output for this specific SHA:
	`http://ci.example.com/user/repo/build/sha`
	*/
	TargetUrl *string `json:"target_url,omitempty"`
}

/*
CreateCommitStatusResponse is a response for CreateCommitStatus

https://developer.github.com/v3/repos/statuses/#create-a-commit-status
*/
type CreateCommitStatusResponse struct {
	common.Response
	request *CreateCommitStatusReq
	Data    components.Status
}

/*
CreateDeployKey performs requests for "repos/create-deploy-key"

Create a deploy key.

  POST /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
func CreateDeployKey(ctx context.Context, req *CreateDeployKeyReq, opt ...options.Option) (*CreateDeployKeyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateDeployKeyReq)
	}
	resp := &CreateDeployKeyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.DeployKey{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateDeployKey performs requests for "repos/create-deploy-key"

Create a deploy key.

  POST /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
func (c Client) CreateDeployKey(ctx context.Context, req *CreateDeployKeyReq, opt ...options.Option) (*CreateDeployKeyResponse, error) {
	return CreateDeployKey(ctx, req, append(c, opt...)...)
}

/*
CreateDeployKeyReq is request data for Client.CreateDeployKey

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
type CreateDeployKeyReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateDeployKeyReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateDeployKeyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateDeployKeyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-deploy-key",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/keys", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateDeployKeyReq) Rel(link string, resp *CreateDeployKeyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateDeployKeyReqBody is a request body for repos/create-deploy-key

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
type CreateDeployKeyReqBody struct {

	// The contents of the key.
	Key *string `json:"key"`

	/*
	If `true`, the key will only be able to read repository contents. Otherwise, the
	key will be able to read and write.

	Deploy keys with write access can perform the same actions as an organization
	member with admin access, or a collaborator on a personal repository. For more
	information, see "[Repository permission levels for an
	organization](https://help.github.com/articles/repository-permission-levels-for-an-organization/)"
	and "[Permission levels for a user account
	repository](https://help.github.com/articles/permission-levels-for-a-user-account-repository/)."
	*/
	ReadOnly *bool `json:"read_only,omitempty"`

	// A name for the key.
	Title *string `json:"title,omitempty"`
}

/*
CreateDeployKeyResponse is a response for CreateDeployKey

https://developer.github.com/v3/repos/keys/#create-a-deploy-key
*/
type CreateDeployKeyResponse struct {
	common.Response
	request *CreateDeployKeyReq
	Data    components.DeployKey
}

/*
CreateDeployment performs requests for "repos/create-deployment"

Create a deployment.

  POST /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
func CreateDeployment(ctx context.Context, req *CreateDeploymentReq, opt ...options.Option) (*CreateDeploymentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateDeploymentReq)
	}
	resp := &CreateDeploymentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Deployment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateDeployment performs requests for "repos/create-deployment"

Create a deployment.

  POST /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
func (c Client) CreateDeployment(ctx context.Context, req *CreateDeploymentReq, opt ...options.Option) (*CreateDeploymentResponse, error) {
	return CreateDeployment(ctx, req, append(c, opt...)...)
}

/*
CreateDeploymentReq is request data for Client.CreateDeployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type CreateDeploymentReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateDeploymentReqBody

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateDeploymentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateDeploymentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"ant-man"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-deployment",
		Previews:         map[string]bool{"ant-man": r.AntManPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201, 202},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateDeploymentReq) Rel(link string, resp *CreateDeploymentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateDeploymentReqBody is a request body for repos/create-deployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type CreateDeploymentReqBody struct {

	// Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch.
	AutoMerge *bool   `json:"auto_merge,omitempty"`
	CreatedAt *string `json:"created_at,omitempty"`

	// Short description of the deployment.
	Description *string `json:"description,omitempty"`

	// Name for the target deployment environment (e.g., `production`, `staging`, `qa`).
	Environment *string `json:"environment,omitempty"`

	// JSON payload with extra information about the deployment.
	Payload *string `json:"payload,omitempty"`

	/*
	Specifies if the given environment is one that end-users directly interact with.
	Default: `true` when `environment` is `production` and `false` otherwise.
	**Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type.
	*/
	ProductionEnvironment *bool `json:"production_environment,omitempty"`

	// The ref to deploy. This can be a branch, tag, or SHA.
	Ref *string `json:"ref"`

	/*
	The [status](https://developer.github.com/v3/repos/statuses/) contexts to verify
	against commit status checks. If you omit this parameter, GitHub verifies all
	unique contexts before creating a deployment. To bypass checking entirely, pass
	an empty array. Defaults to all unique contexts.
	*/
	RequiredContexts []string `json:"required_contexts,omitempty"`

	// Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).
	Task *string `json:"task,omitempty"`

	/*
	Specifies if the given environment is specific to the deployment and will no
	longer exist at some point in the future. Default: `false`
	**Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type. **Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type.
	*/
	TransientEnvironment *bool `json:"transient_environment,omitempty"`
}

/*
CreateDeploymentResponse is a response for CreateDeployment

https://developer.github.com/v3/repos/deployments/#create-a-deployment
*/
type CreateDeploymentResponse struct {
	common.Response
	request *CreateDeploymentReq
	Data    components.Deployment
}

/*
CreateDeploymentStatus performs requests for "repos/create-deployment-status"

Create a deployment status.

  POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
func CreateDeploymentStatus(ctx context.Context, req *CreateDeploymentStatusReq, opt ...options.Option) (*CreateDeploymentStatusResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateDeploymentStatusReq)
	}
	resp := &CreateDeploymentStatusResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.DeploymentStatus{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateDeploymentStatus performs requests for "repos/create-deployment-status"

Create a deployment status.

  POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
func (c Client) CreateDeploymentStatus(ctx context.Context, req *CreateDeploymentStatusReq, opt ...options.Option) (*CreateDeploymentStatusResponse, error) {
	return CreateDeploymentStatus(ctx, req, append(c, opt...)...)
}

/*
CreateDeploymentStatusReq is request data for Client.CreateDeploymentStatus

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type CreateDeploymentStatusReq struct {
	_url  string
	Owner string
	Repo  string

	// deployment_id parameter
	DeploymentId int64
	RequestBody  CreateDeploymentStatusReqBody

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateDeploymentStatusReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateDeploymentStatusReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"flash", "ant-man"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:      "POST",
		OperationID: "repos/create-deployment-status",
		Previews: map[string]bool{
			"ant-man": r.AntManPreview,
			"flash":   r.FlashPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses", r.Owner, r.Repo, r.DeploymentId),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateDeploymentStatusReq) Rel(link string, resp *CreateDeploymentStatusResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateDeploymentStatusReqBody is a request body for repos/create-deployment-status

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type CreateDeploymentStatusReqBody struct {

	/*
	Adds a new `inactive` status to all prior non-transient, non-production
	environment deployments with the same repository and `environment` name as the
	created status's deployment. An `inactive` status is only added to deployments
	that had a `success` state. Default: `true`
	**Note:** To add an `inactive` status to `production` environments, you must use
	the
	[`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	custom media type.
	**Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type.
	*/
	AutoInactive *bool `json:"auto_inactive,omitempty"`

	// A short description of the status. The maximum description length is 140 characters.
	Description *string `json:"description,omitempty"`

	/*
	Name for the target deployment environment, which can be changed when setting a
	deploy status. For example, `production`, `staging`, or `qa`. **Note:** This
	parameter requires you to use the
	[`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	custom media type.
	*/
	Environment *string `json:"environment,omitempty"`

	/*
	Sets the URL for accessing your environment. Default: `""`
	**Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type. **Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type.
	*/
	EnvironmentUrl *string `json:"environment_url,omitempty"`

	/*
	The full URL of the deployment's output. This parameter replaces `target_url`.
	We will continue to accept `target_url` to support legacy uses, but we recommend
	replacing `target_url` with `log_url`. Setting `log_url` will automatically set
	`target_url` to the same value. Default: `""`
	**Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type. **Note:** This parameter requires you to use the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type.
	*/
	LogUrl *string `json:"log_url,omitempty"`

	/*
	The state of the status. Can be one of `error`, `failure`, `inactive`,
	`in_progress`, `queued` `pending`, or `success`. **Note:** To use the `inactive`
	state, you must provide the
	[`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments)
	custom media type. To use the `in_progress` and `queued` states, you must
	provide the
	[`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses)
	custom media type. When you set a transient deployment to `inactive`, the
	deployment will be shown as `destroyed` in GitHub.
	*/
	State *string `json:"state"`

	/*
	The target URL to associate with this status. This URL should contain output to
	keep the user updated while the task is running or serve as historical
	information for what happened in the deployment. **Note:** It's recommended to
	use the `log_url` parameter, which replaces `target_url`.
	*/
	TargetUrl *string `json:"target_url,omitempty"`
}

/*
CreateDeploymentStatusResponse is a response for CreateDeploymentStatus

https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
*/
type CreateDeploymentStatusResponse struct {
	common.Response
	request *CreateDeploymentStatusReq
	Data    components.DeploymentStatus
}

/*
CreateDispatchEvent performs requests for "repos/create-dispatch-event"

Create a repository dispatch event.

  POST /repos/{owner}/{repo}/dispatches

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
func CreateDispatchEvent(ctx context.Context, req *CreateDispatchEventReq, opt ...options.Option) (*CreateDispatchEventResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateDispatchEventReq)
	}
	resp := &CreateDispatchEventResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateDispatchEvent performs requests for "repos/create-dispatch-event"

Create a repository dispatch event.

  POST /repos/{owner}/{repo}/dispatches

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
func (c Client) CreateDispatchEvent(ctx context.Context, req *CreateDispatchEventReq, opt ...options.Option) (*CreateDispatchEventResponse, error) {
	return CreateDispatchEvent(ctx, req, append(c, opt...)...)
}

/*
CreateDispatchEventReq is request data for Client.CreateDispatchEvent

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type CreateDispatchEventReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateDispatchEventReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateDispatchEventReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateDispatchEventReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": internal.String("application/json")},
		Method:           "POST",
		OperationID:      "repos/create-dispatch-event",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/dispatches", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateDispatchEventReq) Rel(link string, resp *CreateDispatchEventResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateDispatchEventReqBody is a request body for repos/create-dispatch-event

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type CreateDispatchEventReqBody struct {

	// JSON payload with extra information about the webhook event that your action or worklow may use.
	ClientPayload interface{} `json:"client_payload,omitempty"`

	// **Required:** A custom webhook event name.
	EventType *string `json:"event_type,omitempty"`
}

/*
CreateDispatchEventResponse is a response for CreateDispatchEvent

https://developer.github.com/v3/repos/#create-a-repository-dispatch-event
*/
type CreateDispatchEventResponse struct {
	common.Response
	request *CreateDispatchEventReq
}

/*
CreateForAuthenticatedUser performs requests for "repos/create-for-authenticated-user"

Create a repository for the authenticated user.

  POST /user/repos

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
func CreateForAuthenticatedUser(ctx context.Context, req *CreateForAuthenticatedUserReq, opt ...options.Option) (*CreateForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateForAuthenticatedUserReq)
	}
	resp := &CreateForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Repository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateForAuthenticatedUser performs requests for "repos/create-for-authenticated-user"

Create a repository for the authenticated user.

  POST /user/repos

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
func (c Client) CreateForAuthenticatedUser(ctx context.Context, req *CreateForAuthenticatedUserReq, opt ...options.Option) (*CreateForAuthenticatedUserResponse, error) {
	return CreateForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
CreateForAuthenticatedUserReq is request data for Client.CreateForAuthenticatedUser

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type CreateForAuthenticatedUserReq struct {
	_url        string
	RequestBody CreateForAuthenticatedUserReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"nebula", "baptiste"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:      "POST",
		OperationID: "repos/create-for-authenticated-user",
		Previews: map[string]bool{
			"baptiste": r.BaptistePreview,
			"nebula":   r.NebulaPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/repos"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateForAuthenticatedUserReq) Rel(link string, resp *CreateForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateForAuthenticatedUserReqBody is a request body for repos/create-for-authenticated-user

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type CreateForAuthenticatedUserReqBody struct {

	// Whether to allow merge commits for pull requests.
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	// Whether to allow rebase merges for pull requests.
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	// Whether to allow squash merges for pull requests.
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	// Whether the repository is initialized with a minimal README.
	AutoInit *bool `json:"auto_init,omitempty"`

	// Whether to delete head branches when pull requests are merged
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	// The desired language or platform to apply to the .gitignore.
	GitignoreTemplate *string `json:"gitignore_template,omitempty"`

	// Whether downloads are enabled.
	HasDownloads *bool `json:"has_downloads,omitempty"`

	// Whether issues are enabled.
	HasIssues *bool `json:"has_issues,omitempty"`

	// Whether projects are enabled.
	HasProjects *bool `json:"has_projects,omitempty"`

	// Whether the wiki is enabled.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	// Whether this repository acts as a template that can be used to generate new repositories.
	IsTemplate *bool `json:"is_template,omitempty"`

	// The license keyword of the open source license for this repository.
	LicenseTemplate *string `json:"license_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name"`

	// Whether the repository is private or public.
	Private *bool `json:"private,omitempty"`

	/*
	The id of the team that will be granted access to this repository. This is only
	valid when creating a repository in an organization.
	*/
	TeamId *int64 `json:"team_id,omitempty"`
}

/*
CreateForAuthenticatedUserResponse is a response for CreateForAuthenticatedUser

https://developer.github.com/v3/repos/#create-a-repository-for-the-authenticated-user
*/
type CreateForAuthenticatedUserResponse struct {
	common.Response
	request *CreateForAuthenticatedUserReq
	Data    components.Repository
}

/*
CreateFork performs requests for "repos/create-fork"

Create a fork.

  POST /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
func CreateFork(ctx context.Context, req *CreateForkReq, opt ...options.Option) (*CreateForkResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateForkReq)
	}
	resp := &CreateForkResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Repository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateFork performs requests for "repos/create-fork"

Create a fork.

  POST /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
func (c Client) CreateFork(ctx context.Context, req *CreateForkReq, opt ...options.Option) (*CreateForkResponse, error) {
	return CreateFork(ctx, req, append(c, opt...)...)
}

/*
CreateForkReq is request data for Client.CreateFork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type CreateForkReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateForkReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateForkReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateForkReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{202},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-fork",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/forks", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{202},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateForkReq) Rel(link string, resp *CreateForkResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateForkReqBody is a request body for repos/create-fork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type CreateForkReqBody struct {

	// Optional parameter to specify the organization name if forking into an organization.
	Organization *string `json:"organization,omitempty"`
}

/*
CreateForkResponse is a response for CreateFork

https://developer.github.com/v3/repos/forks/#create-a-fork
*/
type CreateForkResponse struct {
	common.Response
	request *CreateForkReq
	Data    components.Repository
}

/*
CreateInOrg performs requests for "repos/create-in-org"

Create an organization repository.

  POST /orgs/{org}/repos

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
func CreateInOrg(ctx context.Context, req *CreateInOrgReq, opt ...options.Option) (*CreateInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateInOrgReq)
	}
	resp := &CreateInOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Repository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateInOrg performs requests for "repos/create-in-org"

Create an organization repository.

  POST /orgs/{org}/repos

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
func (c Client) CreateInOrg(ctx context.Context, req *CreateInOrgReq, opt ...options.Option) (*CreateInOrgResponse, error) {
	return CreateInOrg(ctx, req, append(c, opt...)...)
}

/*
CreateInOrgReq is request data for Client.CreateInOrg

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type CreateInOrgReq struct {
	_url        string
	Org         string
	RequestBody CreateInOrgReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"nebula", "baptiste"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:      "POST",
		OperationID: "repos/create-in-org",
		Previews: map[string]bool{
			"baptiste": r.BaptistePreview,
			"nebula":   r.NebulaPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/repos", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateInOrgReq) Rel(link string, resp *CreateInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateInOrgReqBody is a request body for repos/create-in-org

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type CreateInOrgReqBody struct {

	/*
	Either `true` to allow merging pull requests with a merge commit, or `false` to
	prevent merging pull requests with merge commits.
	*/
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	// Pass `true` to create an initial commit with empty README.
	AutoInit *bool `json:"auto_init,omitempty"`

	/*
	Either `true` to allow automatically deleting head branches when pull requests
	are merged, or `false` to prevent automatic deletion.
	*/
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	/*
	Desired language or platform [.gitignore
	template](https://github.com/github/gitignore) to apply. Use the name of the
	template without the extension. For example, "Haskell".
	*/
	GitignoreTemplate *string `json:"gitignore_template,omitempty"`

	// Either `true` to enable issues for this repository or `false` to disable them.
	HasIssues *bool `json:"has_issues,omitempty"`

	/*
	Either `true` to enable projects for this repository or `false` to disable them.
	**Note:** If you're creating a repository in an organization that has disabled
	repository projects, the default is `false`, and if you pass `true`, the API
	returns an error.
	*/
	HasProjects *bool `json:"has_projects,omitempty"`

	// Either `true` to enable the wiki for this repository or `false` to disable it.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	// Either `true` to make this repo available as a template repository or `false` to prevent it.
	IsTemplate *bool `json:"is_template,omitempty"`

	/*
	Choose an [open source license template](https://choosealicense.com/) that best
	suits your needs, and then use the [license
	keyword](https://help.github.com/articles/licensing-a-repository/#searching-github-by-license-type)
	as the `license_template` string. For example, "mit" or "mpl-2.0".
	*/
	LicenseTemplate *string `json:"license_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name"`

	// Either `true` to create a private repository or `false` to create a public one.
	Private *bool `json:"private,omitempty"`

	/*
	The id of the team that will be granted access to this repository. This is only
	valid when creating a repository in an organization.
	*/
	TeamId *int64 `json:"team_id,omitempty"`

	/*
	Can be `public` or `private`. If your organization is associated with an
	enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server
	2.20+, `visibility` can also be `internal`. For more information, see "[Creating
	an internal
	repository](https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)"
	in the GitHub Help documentation.
	The `visibility` parameter overrides the `private` parameter when you use both
	parameters with the `nebula-preview` preview header.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
CreateInOrgResponse is a response for CreateInOrg

https://developer.github.com/v3/repos/#create-an-organization-repository
*/
type CreateInOrgResponse struct {
	common.Response
	request *CreateInOrgReq
	Data    components.Repository
}

/*
CreateOrUpdateFileContents performs requests for "repos/create-or-update-file-contents"

Create or update file contents.

  PUT /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
func CreateOrUpdateFileContents(ctx context.Context, req *CreateOrUpdateFileContentsReq, opt ...options.Option) (*CreateOrUpdateFileContentsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateOrUpdateFileContentsReq)
	}
	resp := &CreateOrUpdateFileContentsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.FileCommit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateOrUpdateFileContents performs requests for "repos/create-or-update-file-contents"

Create or update file contents.

  PUT /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
func (c Client) CreateOrUpdateFileContents(ctx context.Context, req *CreateOrUpdateFileContentsReq, opt ...options.Option) (*CreateOrUpdateFileContentsResponse, error) {
	return CreateOrUpdateFileContents(ctx, req, append(c, opt...)...)
}

/*
CreateOrUpdateFileContentsReq is request data for Client.CreateOrUpdateFileContents

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
type CreateOrUpdateFileContentsReq struct {
	_url  string
	Owner string
	Repo  string

	// path+ parameter
	Path        string
	RequestBody CreateOrUpdateFileContentsReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateOrUpdateFileContentsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateOrUpdateFileContentsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200, 201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/create-or-update-file-contents",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path),
		URLQuery:         query,
		ValidStatuses:    []int{200, 201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateOrUpdateFileContentsReq) Rel(link string, resp *CreateOrUpdateFileContentsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateOrUpdateFileContentsReqBodyAuthor is a value for CreateOrUpdateFileContentsReqBody's Author field
type CreateOrUpdateFileContentsReqBodyAuthor struct {
	Date *string `json:"date,omitempty"`

	// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
	Email *string `json:"email"`

	// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
	Name *string `json:"name"`
}

// CreateOrUpdateFileContentsReqBodyCommitter is a value for CreateOrUpdateFileContentsReqBody's Committer field
type CreateOrUpdateFileContentsReqBodyCommitter struct {
	Date *string `json:"date,omitempty"`

	// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
	Email *string `json:"email"`

	// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
	Name *string `json:"name"`
}

/*
CreateOrUpdateFileContentsReqBody is a request body for repos/create-or-update-file-contents

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
type CreateOrUpdateFileContentsReqBody struct {

	// The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
	Author *CreateOrUpdateFileContentsReqBodyAuthor `json:"author,omitempty"`

	// The branch name. Default: the repository’s default branch (usually `master`)
	Branch *string `json:"branch,omitempty"`

	// The person that committed the file. Default: the authenticated user.
	Committer *CreateOrUpdateFileContentsReqBodyCommitter `json:"committer,omitempty"`

	// The new file content, using Base64 encoding.
	Content *string `json:"content"`

	// The commit message.
	Message *string `json:"message"`

	// **Required if you are updating a file**. The blob SHA of the file being replaced.
	Sha *string `json:"sha,omitempty"`
}

/*
CreateOrUpdateFileContentsResponse is a response for CreateOrUpdateFileContents

https://developer.github.com/v3/repos/contents/#create-or-update-file-contents
*/
type CreateOrUpdateFileContentsResponse struct {
	common.Response
	request *CreateOrUpdateFileContentsReq
	Data    components.FileCommit
}

/*
CreatePagesSite performs requests for "repos/create-pages-site"

Create a GitHub Pages site.

  POST /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
func CreatePagesSite(ctx context.Context, req *CreatePagesSiteReq, opt ...options.Option) (*CreatePagesSiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreatePagesSiteReq)
	}
	resp := &CreatePagesSiteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Page{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreatePagesSite performs requests for "repos/create-pages-site"

Create a GitHub Pages site.

  POST /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
func (c Client) CreatePagesSite(ctx context.Context, req *CreatePagesSiteReq, opt ...options.Option) (*CreatePagesSiteResponse, error) {
	return CreatePagesSite(ctx, req, append(c, opt...)...)
}

/*
CreatePagesSiteReq is request data for Client.CreatePagesSite

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
type CreatePagesSiteReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreatePagesSiteReqBody

	/*
	Enabling and disabling Pages in the Pages API is currently available for
	developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-03-14-enabling-disabling-pages/)
	preview for more details. To access the new endpoints during the preview period,
	you must set this to true.
	*/
	SwitcherooPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreatePagesSiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreatePagesSiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"switcheroo"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-pages-site",
		Previews:         map[string]bool{"switcheroo": r.SwitcherooPreview},
		RequiredPreviews: []string{"switcheroo"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreatePagesSiteReq) Rel(link string, resp *CreatePagesSiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreatePagesSiteReqBodySource is a value for CreatePagesSiteReqBody's Source field
type CreatePagesSiteReqBodySource struct {

	/*
	The repository branch used to publish your [site's source
	files](https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/).
	Can be either `master` or `gh-pages`.
	*/
	Branch *string `json:"branch,omitempty"`

	/*
	The repository directory that includes the source files for the Pages site. When
	`branch` is `master`, you can change `path` to `/docs`. When `branch` is
	`gh-pages`, you are unable to specify a `path` other than `/`.
	*/
	Path *string `json:"path,omitempty"`
}

/*
CreatePagesSiteReqBody is a request body for repos/create-pages-site

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
type CreatePagesSiteReqBody struct {
	Source *CreatePagesSiteReqBodySource `json:"source,omitempty"`
}

/*
CreatePagesSiteResponse is a response for CreatePagesSite

https://developer.github.com/v3/repos/pages/#create-a-github-pages-site
*/
type CreatePagesSiteResponse struct {
	common.Response
	request *CreatePagesSiteReq
	Data    components.Page
}

/*
CreateRelease performs requests for "repos/create-release"

Create a release.

  POST /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#create-a-release
*/
func CreateRelease(ctx context.Context, req *CreateReleaseReq, opt ...options.Option) (*CreateReleaseResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateReleaseReq)
	}
	resp := &CreateReleaseResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Release{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateRelease performs requests for "repos/create-release"

Create a release.

  POST /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#create-a-release
*/
func (c Client) CreateRelease(ctx context.Context, req *CreateReleaseReq, opt ...options.Option) (*CreateReleaseResponse, error) {
	return CreateRelease(ctx, req, append(c, opt...)...)
}

/*
CreateReleaseReq is request data for Client.CreateRelease

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type CreateReleaseReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateReleaseReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateReleaseReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateReleaseReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-release",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateReleaseReq) Rel(link string, resp *CreateReleaseResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateReleaseReqBody is a request body for repos/create-release

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type CreateReleaseReqBody struct {

	// Text describing the contents of the tag.
	Body *string `json:"body,omitempty"`

	// `true` to create a draft (unpublished) release, `false` to create a published one.
	Draft *bool `json:"draft,omitempty"`

	// The name of the release.
	Name *string `json:"name,omitempty"`

	// `true` to identify the release as a prerelease. `false` to identify the release as a full release.
	Prerelease *bool `json:"prerelease,omitempty"`

	// The name of the tag.
	TagName *string `json:"tag_name"`

	/*
	Specifies the commitish value that determines where the Git tag is created from.
	Can be any branch or commit SHA. Unused if the Git tag already exists. Default:
	the repository's default branch (usually `master`).
	*/
	TargetCommitish *string `json:"target_commitish,omitempty"`
}

/*
CreateReleaseResponse is a response for CreateRelease

https://developer.github.com/v3/repos/releases/#create-a-release
*/
type CreateReleaseResponse struct {
	common.Response
	request *CreateReleaseReq
	Data    components.Release
}

/*
CreateUsingTemplate performs requests for "repos/create-using-template"

Create a repository using a template.

  POST /repos/{template_owner}/{template_repo}/generate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
func CreateUsingTemplate(ctx context.Context, req *CreateUsingTemplateReq, opt ...options.Option) (*CreateUsingTemplateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateUsingTemplateReq)
	}
	resp := &CreateUsingTemplateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Repository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateUsingTemplate performs requests for "repos/create-using-template"

Create a repository using a template.

  POST /repos/{template_owner}/{template_repo}/generate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
func (c Client) CreateUsingTemplate(ctx context.Context, req *CreateUsingTemplateReq, opt ...options.Option) (*CreateUsingTemplateResponse, error) {
	return CreateUsingTemplate(ctx, req, append(c, opt...)...)
}

/*
CreateUsingTemplateReq is request data for Client.CreateUsingTemplate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type CreateUsingTemplateReq struct {
	_url string

	// template_owner parameter
	TemplateOwner string

	// template_repo parameter
	TemplateRepo string
	RequestBody  CreateUsingTemplateReqBody

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateUsingTemplateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateUsingTemplateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"baptiste"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-using-template",
		Previews:         map[string]bool{"baptiste": r.BaptistePreview},
		RequiredPreviews: []string{"baptiste"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/generate", r.TemplateOwner, r.TemplateRepo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateUsingTemplateReq) Rel(link string, resp *CreateUsingTemplateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateUsingTemplateReqBody is a request body for repos/create-using-template

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type CreateUsingTemplateReqBody struct {

	// A short description of the new repository.
	Description *string `json:"description,omitempty"`

	// The name of the new repository.
	Name *string `json:"name"`

	/*
	The organization or person who will own the new repository. To create a new
	repository in an organization, the authenticated user must be a member of the
	specified organization.
	*/
	Owner *string `json:"owner,omitempty"`

	// Either `true` to create a new private repository or `false` to create a new public one.
	Private *bool `json:"private,omitempty"`
}

/*
CreateUsingTemplateResponse is a response for CreateUsingTemplate

https://developer.github.com/v3/repos/#create-a-repository-using-a-template
*/
type CreateUsingTemplateResponse struct {
	common.Response
	request *CreateUsingTemplateReq
	Data    components.Repository
}

/*
CreateWebhook performs requests for "repos/create-webhook"

Create a repository webhook.

  POST /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
func CreateWebhook(ctx context.Context, req *CreateWebhookReq, opt ...options.Option) (*CreateWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateWebhookReq)
	}
	resp := &CreateWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Hook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateWebhook performs requests for "repos/create-webhook"

Create a repository webhook.

  POST /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
func (c Client) CreateWebhook(ctx context.Context, req *CreateWebhookReq, opt ...options.Option) (*CreateWebhookResponse, error) {
	return CreateWebhook(ctx, req, append(c, opt...)...)
}

/*
CreateWebhookReq is request data for Client.CreateWebhook

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
type CreateWebhookReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateWebhookReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/create-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateWebhookReq) Rel(link string, resp *CreateWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateWebhookReqBodyConfig is a value for CreateWebhookReqBody's Config field
type CreateWebhookReqBodyConfig struct {

	// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
	ContentType *string `json:"content_type,omitempty"`
	Digest      *string `json:"digest,omitempty"`

	/*
	Determines whether the SSL certificate of the host for `url` will be verified
	when delivering payloads. Supported values include `0` (verification is
	performed) and `1` (verification is not performed). The default is `0`. **We
	strongly recommend not setting this to `1` as you are subject to
	man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	If provided, the `secret` will be used as the `key` to generate the HMAC hex
	digest value in the
	[`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	header.
	*/
	Secret *string `json:"secret,omitempty"`
	Token  *string `json:"token,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
CreateWebhookReqBody is a request body for repos/create-webhook

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
type CreateWebhookReqBody struct {

	// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
	Active *bool `json:"active,omitempty"`

	/*
	Key/value pairs to provide settings for this webhook. [These are defined
	below](https://developer.github.com/v3/repos/hooks/#create-hook-config-params).
	*/
	Config *CreateWebhookReqBodyConfig `json:"config"`

	// Determines what [events](https://developer.github.com/webhooks/event-payloads) the hook is triggered for.
	Events []string `json:"events,omitempty"`

	// Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`.
	Name *string `json:"name,omitempty"`
}

/*
CreateWebhookResponse is a response for CreateWebhook

https://developer.github.com/v3/repos/hooks/#create-a-repository-webhook
*/
type CreateWebhookResponse struct {
	common.Response
	request *CreateWebhookReq
	Data    components.Hook
}

/*
DeclineInvitation performs requests for "repos/decline-invitation"

Decline a repository invitation.

  DELETE /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
func DeclineInvitation(ctx context.Context, req *DeclineInvitationReq, opt ...options.Option) (*DeclineInvitationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeclineInvitationReq)
	}
	resp := &DeclineInvitationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeclineInvitation performs requests for "repos/decline-invitation"

Decline a repository invitation.

  DELETE /user/repository_invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
func (c Client) DeclineInvitation(ctx context.Context, req *DeclineInvitationReq, opt ...options.Option) (*DeclineInvitationResponse, error) {
	return DeclineInvitation(ctx, req, append(c, opt...)...)
}

/*
DeclineInvitationReq is request data for Client.DeclineInvitation

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
type DeclineInvitationReq struct {
	_url string

	// invitation_id parameter
	InvitationId int64
}

// HTTPRequest builds an *http.Request
func (r *DeclineInvitationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeclineInvitationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/decline-invitation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/repository_invitations/%v", r.InvitationId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeclineInvitationReq) Rel(link string, resp *DeclineInvitationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeclineInvitationResponse is a response for DeclineInvitation

https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation
*/
type DeclineInvitationResponse struct {
	common.Response
	request *DeclineInvitationReq
}

/*
Delete performs requests for "repos/delete"

Delete a repository.

  DELETE /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#delete-a-repository
*/
func Delete(ctx context.Context, req *DeleteReq, opt ...options.Option) (*DeleteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteReq)
	}
	resp := &DeleteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Delete performs requests for "repos/delete"

Delete a repository.

  DELETE /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#delete-a-repository
*/
func (c Client) Delete(ctx context.Context, req *DeleteReq, opt ...options.Option) (*DeleteResponse, error) {
	return Delete(ctx, req, append(c, opt...)...)
}

/*
DeleteReq is request data for Client.Delete

https://developer.github.com/v3/repos/#delete-a-repository
*/
type DeleteReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *DeleteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteReq) Rel(link string, resp *DeleteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteResponse is a response for Delete

https://developer.github.com/v3/repos/#delete-a-repository
*/
type DeleteResponse struct {
	common.Response
	request *DeleteReq
}

/*
DeleteAccessRestrictions performs requests for "repos/delete-access-restrictions"

Delete access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#delete-access-restrictions
*/
func DeleteAccessRestrictions(ctx context.Context, req *DeleteAccessRestrictionsReq, opt ...options.Option) (*DeleteAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteAccessRestrictionsReq)
	}
	resp := &DeleteAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteAccessRestrictions performs requests for "repos/delete-access-restrictions"

Delete access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#delete-access-restrictions
*/
func (c Client) DeleteAccessRestrictions(ctx context.Context, req *DeleteAccessRestrictionsReq, opt ...options.Option) (*DeleteAccessRestrictionsResponse, error) {
	return DeleteAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
DeleteAccessRestrictionsReq is request data for Client.DeleteAccessRestrictions

https://developer.github.com/v3/repos/branches/#delete-access-restrictions
*/
type DeleteAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *DeleteAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteAccessRestrictionsReq) Rel(link string, resp *DeleteAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteAccessRestrictionsResponse is a response for DeleteAccessRestrictions

https://developer.github.com/v3/repos/branches/#delete-access-restrictions
*/
type DeleteAccessRestrictionsResponse struct {
	common.Response
	request *DeleteAccessRestrictionsReq
}

/*
DeleteAdminBranchProtection performs requests for "repos/delete-admin-branch-protection"

Delete admin branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#delete-admin-branch-protection
*/
func DeleteAdminBranchProtection(ctx context.Context, req *DeleteAdminBranchProtectionReq, opt ...options.Option) (*DeleteAdminBranchProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteAdminBranchProtectionReq)
	}
	resp := &DeleteAdminBranchProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteAdminBranchProtection performs requests for "repos/delete-admin-branch-protection"

Delete admin branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#delete-admin-branch-protection
*/
func (c Client) DeleteAdminBranchProtection(ctx context.Context, req *DeleteAdminBranchProtectionReq, opt ...options.Option) (*DeleteAdminBranchProtectionResponse, error) {
	return DeleteAdminBranchProtection(ctx, req, append(c, opt...)...)
}

/*
DeleteAdminBranchProtectionReq is request data for Client.DeleteAdminBranchProtection

https://developer.github.com/v3/repos/branches/#delete-admin-branch-protection
*/
type DeleteAdminBranchProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *DeleteAdminBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteAdminBranchProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-admin-branch-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteAdminBranchProtectionReq) Rel(link string, resp *DeleteAdminBranchProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteAdminBranchProtectionResponse is a response for DeleteAdminBranchProtection

https://developer.github.com/v3/repos/branches/#delete-admin-branch-protection
*/
type DeleteAdminBranchProtectionResponse struct {
	common.Response
	request *DeleteAdminBranchProtectionReq
	Data    bool
}

/*
DeleteBranchProtection performs requests for "repos/delete-branch-protection"

Delete branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#delete-branch-protection
*/
func DeleteBranchProtection(ctx context.Context, req *DeleteBranchProtectionReq, opt ...options.Option) (*DeleteBranchProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteBranchProtectionReq)
	}
	resp := &DeleteBranchProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteBranchProtection performs requests for "repos/delete-branch-protection"

Delete branch protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#delete-branch-protection
*/
func (c Client) DeleteBranchProtection(ctx context.Context, req *DeleteBranchProtectionReq, opt ...options.Option) (*DeleteBranchProtectionResponse, error) {
	return DeleteBranchProtection(ctx, req, append(c, opt...)...)
}

/*
DeleteBranchProtectionReq is request data for Client.DeleteBranchProtection

https://developer.github.com/v3/repos/branches/#delete-branch-protection
*/
type DeleteBranchProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *DeleteBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteBranchProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-branch-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteBranchProtectionReq) Rel(link string, resp *DeleteBranchProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteBranchProtectionResponse is a response for DeleteBranchProtection

https://developer.github.com/v3/repos/branches/#delete-branch-protection
*/
type DeleteBranchProtectionResponse struct {
	common.Response
	request *DeleteBranchProtectionReq
}

/*
DeleteCommitComment performs requests for "repos/delete-commit-comment"

Delete a commit comment.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
func DeleteCommitComment(ctx context.Context, req *DeleteCommitCommentReq, opt ...options.Option) (*DeleteCommitCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteCommitCommentReq)
	}
	resp := &DeleteCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteCommitComment performs requests for "repos/delete-commit-comment"

Delete a commit comment.

  DELETE /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
func (c Client) DeleteCommitComment(ctx context.Context, req *DeleteCommitCommentReq, opt ...options.Option) (*DeleteCommitCommentResponse, error) {
	return DeleteCommitComment(ctx, req, append(c, opt...)...)
}

/*
DeleteCommitCommentReq is request data for Client.DeleteCommitComment

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
type DeleteCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteCommitCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-commit-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteCommitCommentReq) Rel(link string, resp *DeleteCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteCommitCommentResponse is a response for DeleteCommitComment

https://developer.github.com/v3/repos/comments/#delete-a-commit-comment
*/
type DeleteCommitCommentResponse struct {
	common.Response
	request *DeleteCommitCommentReq
	Data    bool
}

/*
DeleteCommitSignatureProtection performs requests for "repos/delete-commit-signature-protection"

Delete commit signature protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#delete-commit-signature-protection
*/
func DeleteCommitSignatureProtection(ctx context.Context, req *DeleteCommitSignatureProtectionReq, opt ...options.Option) (*DeleteCommitSignatureProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteCommitSignatureProtectionReq)
	}
	resp := &DeleteCommitSignatureProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteCommitSignatureProtection performs requests for "repos/delete-commit-signature-protection"

Delete commit signature protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#delete-commit-signature-protection
*/
func (c Client) DeleteCommitSignatureProtection(ctx context.Context, req *DeleteCommitSignatureProtectionReq, opt ...options.Option) (*DeleteCommitSignatureProtectionResponse, error) {
	return DeleteCommitSignatureProtection(ctx, req, append(c, opt...)...)
}

/*
DeleteCommitSignatureProtectionReq is request data for Client.DeleteCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#delete-commit-signature-protection
*/
type DeleteCommitSignatureProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteCommitSignatureProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteCommitSignatureProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"zzzax"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-commit-signature-protection",
		Previews:         map[string]bool{"zzzax": r.ZzzaxPreview},
		RequiredPreviews: []string{"zzzax"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteCommitSignatureProtectionReq) Rel(link string, resp *DeleteCommitSignatureProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteCommitSignatureProtectionResponse is a response for DeleteCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#delete-commit-signature-protection
*/
type DeleteCommitSignatureProtectionResponse struct {
	common.Response
	request *DeleteCommitSignatureProtectionReq
	Data    bool
}

/*
DeleteDeployKey performs requests for "repos/delete-deploy-key"

Delete a deploy key.

  DELETE /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
*/
func DeleteDeployKey(ctx context.Context, req *DeleteDeployKeyReq, opt ...options.Option) (*DeleteDeployKeyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteDeployKeyReq)
	}
	resp := &DeleteDeployKeyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteDeployKey performs requests for "repos/delete-deploy-key"

Delete a deploy key.

  DELETE /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
*/
func (c Client) DeleteDeployKey(ctx context.Context, req *DeleteDeployKeyReq, opt ...options.Option) (*DeleteDeployKeyResponse, error) {
	return DeleteDeployKey(ctx, req, append(c, opt...)...)
}

/*
DeleteDeployKeyReq is request data for Client.DeleteDeployKey

https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
*/
type DeleteDeployKeyReq struct {
	_url  string
	Owner string
	Repo  string

	// key_id parameter
	KeyId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteDeployKeyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteDeployKeyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-deploy-key",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/keys/%v", r.Owner, r.Repo, r.KeyId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteDeployKeyReq) Rel(link string, resp *DeleteDeployKeyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteDeployKeyResponse is a response for DeleteDeployKey

https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
*/
type DeleteDeployKeyResponse struct {
	common.Response
	request *DeleteDeployKeyReq
}

/*
DeleteDeployment performs requests for "repos/delete-deployment"

Delete a deployment.

  DELETE /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
func DeleteDeployment(ctx context.Context, req *DeleteDeploymentReq, opt ...options.Option) (*DeleteDeploymentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteDeploymentReq)
	}
	resp := &DeleteDeploymentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteDeployment performs requests for "repos/delete-deployment"

Delete a deployment.

  DELETE /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
func (c Client) DeleteDeployment(ctx context.Context, req *DeleteDeploymentReq, opt ...options.Option) (*DeleteDeploymentResponse, error) {
	return DeleteDeployment(ctx, req, append(c, opt...)...)
}

/*
DeleteDeploymentReq is request data for Client.DeleteDeployment

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
type DeleteDeploymentReq struct {
	_url  string
	Owner string
	Repo  string

	// deployment_id parameter
	DeploymentId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteDeploymentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteDeploymentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-deployment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments/%v", r.Owner, r.Repo, r.DeploymentId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteDeploymentReq) Rel(link string, resp *DeleteDeploymentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteDeploymentResponse is a response for DeleteDeployment

https://developer.github.com/v3/repos/deployments/#delete-a-deployment
*/
type DeleteDeploymentResponse struct {
	common.Response
	request *DeleteDeploymentReq
}

/*
DeleteFile performs requests for "repos/delete-file"

Delete a file.

  DELETE /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
func DeleteFile(ctx context.Context, req *DeleteFileReq, opt ...options.Option) (*DeleteFileResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteFileReq)
	}
	resp := &DeleteFileResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.FileCommit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteFile performs requests for "repos/delete-file"

Delete a file.

  DELETE /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
func (c Client) DeleteFile(ctx context.Context, req *DeleteFileReq, opt ...options.Option) (*DeleteFileResponse, error) {
	return DeleteFile(ctx, req, append(c, opt...)...)
}

/*
DeleteFileReq is request data for Client.DeleteFile

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type DeleteFileReq struct {
	_url  string
	Owner string
	Repo  string

	// path+ parameter
	Path        string
	RequestBody DeleteFileReqBody
}

// HTTPRequest builds an *http.Request
func (r *DeleteFileReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteFileReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "DELETE",
		OperationID:      "repos/delete-file",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteFileReq) Rel(link string, resp *DeleteFileResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// DeleteFileReqBodyAuthor is a value for DeleteFileReqBody's Author field
type DeleteFileReqBodyAuthor struct {

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

// DeleteFileReqBodyCommitter is a value for DeleteFileReqBody's Committer field
type DeleteFileReqBodyCommitter struct {

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

/*
DeleteFileReqBody is a request body for repos/delete-file

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type DeleteFileReqBody struct {

	// object containing information about the author.
	Author *DeleteFileReqBodyAuthor `json:"author,omitempty"`

	// The branch name. Default: the repository’s default branch (usually `master`)
	Branch *string `json:"branch,omitempty"`

	// object containing information about the committer.
	Committer *DeleteFileReqBodyCommitter `json:"committer,omitempty"`

	// The commit message.
	Message *string `json:"message"`

	// The blob SHA of the file being replaced.
	Sha *string `json:"sha"`
}

/*
DeleteFileResponse is a response for DeleteFile

https://developer.github.com/v3/repos/contents/#delete-a-file
*/
type DeleteFileResponse struct {
	common.Response
	request *DeleteFileReq
	Data    components.FileCommit
}

/*
DeleteInvitation performs requests for "repos/delete-invitation"

Delete a repository invitation.

  DELETE /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
func DeleteInvitation(ctx context.Context, req *DeleteInvitationReq, opt ...options.Option) (*DeleteInvitationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteInvitationReq)
	}
	resp := &DeleteInvitationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteInvitation performs requests for "repos/delete-invitation"

Delete a repository invitation.

  DELETE /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
func (c Client) DeleteInvitation(ctx context.Context, req *DeleteInvitationReq, opt ...options.Option) (*DeleteInvitationResponse, error) {
	return DeleteInvitation(ctx, req, append(c, opt...)...)
}

/*
DeleteInvitationReq is request data for Client.DeleteInvitation

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
type DeleteInvitationReq struct {
	_url  string
	Owner string
	Repo  string

	// invitation_id parameter
	InvitationId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteInvitationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteInvitationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-invitation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/invitations/%v", r.Owner, r.Repo, r.InvitationId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteInvitationReq) Rel(link string, resp *DeleteInvitationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteInvitationResponse is a response for DeleteInvitation

https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation
*/
type DeleteInvitationResponse struct {
	common.Response
	request *DeleteInvitationReq
}

/*
DeletePagesSite performs requests for "repos/delete-pages-site"

Delete a GitHub Pages site.

  DELETE /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#delete-a-github-pages-site
*/
func DeletePagesSite(ctx context.Context, req *DeletePagesSiteReq, opt ...options.Option) (*DeletePagesSiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeletePagesSiteReq)
	}
	resp := &DeletePagesSiteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeletePagesSite performs requests for "repos/delete-pages-site"

Delete a GitHub Pages site.

  DELETE /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#delete-a-github-pages-site
*/
func (c Client) DeletePagesSite(ctx context.Context, req *DeletePagesSiteReq, opt ...options.Option) (*DeletePagesSiteResponse, error) {
	return DeletePagesSite(ctx, req, append(c, opt...)...)
}

/*
DeletePagesSiteReq is request data for Client.DeletePagesSite

https://developer.github.com/v3/repos/pages/#delete-a-github-pages-site
*/
type DeletePagesSiteReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling Pages in the Pages API is currently available for
	developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-03-14-enabling-disabling-pages/)
	preview for more details. To access the new endpoints during the preview period,
	you must set this to true.
	*/
	SwitcherooPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeletePagesSiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeletePagesSiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"switcheroo"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-pages-site",
		Previews:         map[string]bool{"switcheroo": r.SwitcherooPreview},
		RequiredPreviews: []string{"switcheroo"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeletePagesSiteReq) Rel(link string, resp *DeletePagesSiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeletePagesSiteResponse is a response for DeletePagesSite

https://developer.github.com/v3/repos/pages/#delete-a-github-pages-site
*/
type DeletePagesSiteResponse struct {
	common.Response
	request *DeletePagesSiteReq
}

/*
DeletePullRequestReviewProtection performs requests for "repos/delete-pull-request-review-protection"

Delete pull request review protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#delete-pull-request-review-protection
*/
func DeletePullRequestReviewProtection(ctx context.Context, req *DeletePullRequestReviewProtectionReq, opt ...options.Option) (*DeletePullRequestReviewProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeletePullRequestReviewProtectionReq)
	}
	resp := &DeletePullRequestReviewProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeletePullRequestReviewProtection performs requests for "repos/delete-pull-request-review-protection"

Delete pull request review protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#delete-pull-request-review-protection
*/
func (c Client) DeletePullRequestReviewProtection(ctx context.Context, req *DeletePullRequestReviewProtectionReq, opt ...options.Option) (*DeletePullRequestReviewProtectionResponse, error) {
	return DeletePullRequestReviewProtection(ctx, req, append(c, opt...)...)
}

/*
DeletePullRequestReviewProtectionReq is request data for Client.DeletePullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#delete-pull-request-review-protection
*/
type DeletePullRequestReviewProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *DeletePullRequestReviewProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeletePullRequestReviewProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-pull-request-review-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeletePullRequestReviewProtectionReq) Rel(link string, resp *DeletePullRequestReviewProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeletePullRequestReviewProtectionResponse is a response for DeletePullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#delete-pull-request-review-protection
*/
type DeletePullRequestReviewProtectionResponse struct {
	common.Response
	request *DeletePullRequestReviewProtectionReq
	Data    bool
}

/*
DeleteRelease performs requests for "repos/delete-release"

Delete a release.

  DELETE /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
func DeleteRelease(ctx context.Context, req *DeleteReleaseReq, opt ...options.Option) (*DeleteReleaseResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteReleaseReq)
	}
	resp := &DeleteReleaseResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteRelease performs requests for "repos/delete-release"

Delete a release.

  DELETE /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
func (c Client) DeleteRelease(ctx context.Context, req *DeleteReleaseReq, opt ...options.Option) (*DeleteReleaseResponse, error) {
	return DeleteRelease(ctx, req, append(c, opt...)...)
}

/*
DeleteReleaseReq is request data for Client.DeleteRelease

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
type DeleteReleaseReq struct {
	_url  string
	Owner string
	Repo  string

	// release_id parameter
	ReleaseId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteReleaseReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteReleaseReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-release",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteReleaseReq) Rel(link string, resp *DeleteReleaseResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteReleaseResponse is a response for DeleteRelease

https://developer.github.com/v3/repos/releases/#delete-a-release
*/
type DeleteReleaseResponse struct {
	common.Response
	request *DeleteReleaseReq
}

/*
DeleteReleaseAsset performs requests for "repos/delete-release-asset"

Delete a release asset.

  DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
func DeleteReleaseAsset(ctx context.Context, req *DeleteReleaseAssetReq, opt ...options.Option) (*DeleteReleaseAssetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteReleaseAssetReq)
	}
	resp := &DeleteReleaseAssetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteReleaseAsset performs requests for "repos/delete-release-asset"

Delete a release asset.

  DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
func (c Client) DeleteReleaseAsset(ctx context.Context, req *DeleteReleaseAssetReq, opt ...options.Option) (*DeleteReleaseAssetResponse, error) {
	return DeleteReleaseAsset(ctx, req, append(c, opt...)...)
}

/*
DeleteReleaseAssetReq is request data for Client.DeleteReleaseAsset

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
type DeleteReleaseAssetReq struct {
	_url  string
	Owner string
	Repo  string

	// asset_id parameter
	AssetId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteReleaseAssetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-release-asset",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteReleaseAssetReq) Rel(link string, resp *DeleteReleaseAssetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteReleaseAssetResponse is a response for DeleteReleaseAsset

https://developer.github.com/v3/repos/releases/#delete-a-release-asset
*/
type DeleteReleaseAssetResponse struct {
	common.Response
	request *DeleteReleaseAssetReq
}

/*
DeleteWebhook performs requests for "repos/delete-webhook"

Delete a repository webhook.

  DELETE /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#delete-a-repository-webhook
*/
func DeleteWebhook(ctx context.Context, req *DeleteWebhookReq, opt ...options.Option) (*DeleteWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteWebhookReq)
	}
	resp := &DeleteWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteWebhook performs requests for "repos/delete-webhook"

Delete a repository webhook.

  DELETE /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#delete-a-repository-webhook
*/
func (c Client) DeleteWebhook(ctx context.Context, req *DeleteWebhookReq, opt ...options.Option) (*DeleteWebhookResponse, error) {
	return DeleteWebhook(ctx, req, append(c, opt...)...)
}

/*
DeleteWebhookReq is request data for Client.DeleteWebhook

https://developer.github.com/v3/repos/hooks/#delete-a-repository-webhook
*/
type DeleteWebhookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/delete-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteWebhookReq) Rel(link string, resp *DeleteWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteWebhookResponse is a response for DeleteWebhook

https://developer.github.com/v3/repos/hooks/#delete-a-repository-webhook
*/
type DeleteWebhookResponse struct {
	common.Response
	request *DeleteWebhookReq
	Data    bool
}

/*
DisableAutomatedSecurityFixes performs requests for "repos/disable-automated-security-fixes"

Disable automated security fixes.

  DELETE /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
func DisableAutomatedSecurityFixes(ctx context.Context, req *DisableAutomatedSecurityFixesReq, opt ...options.Option) (*DisableAutomatedSecurityFixesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DisableAutomatedSecurityFixesReq)
	}
	resp := &DisableAutomatedSecurityFixesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DisableAutomatedSecurityFixes performs requests for "repos/disable-automated-security-fixes"

Disable automated security fixes.

  DELETE /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
func (c Client) DisableAutomatedSecurityFixes(ctx context.Context, req *DisableAutomatedSecurityFixesReq, opt ...options.Option) (*DisableAutomatedSecurityFixesResponse, error) {
	return DisableAutomatedSecurityFixes(ctx, req, append(c, opt...)...)
}

/*
DisableAutomatedSecurityFixesReq is request data for Client.DisableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
type DisableAutomatedSecurityFixesReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling or disabling automated security fixes is currently available for
	developers to preview. To access this new endpoint during the preview period,
	you must set this to true.
	*/
	LondonPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DisableAutomatedSecurityFixesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DisableAutomatedSecurityFixesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"london"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/disable-automated-security-fixes",
		Previews:         map[string]bool{"london": r.LondonPreview},
		RequiredPreviews: []string{"london"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/automated-security-fixes", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DisableAutomatedSecurityFixesReq) Rel(link string, resp *DisableAutomatedSecurityFixesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DisableAutomatedSecurityFixesResponse is a response for DisableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#disable-automated-security-fixes
*/
type DisableAutomatedSecurityFixesResponse struct {
	common.Response
	request *DisableAutomatedSecurityFixesReq
}

/*
DisableVulnerabilityAlerts performs requests for "repos/disable-vulnerability-alerts"

Disable vulnerability alerts.

  DELETE /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
func DisableVulnerabilityAlerts(ctx context.Context, req *DisableVulnerabilityAlertsReq, opt ...options.Option) (*DisableVulnerabilityAlertsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DisableVulnerabilityAlertsReq)
	}
	resp := &DisableVulnerabilityAlertsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DisableVulnerabilityAlerts performs requests for "repos/disable-vulnerability-alerts"

Disable vulnerability alerts.

  DELETE /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
func (c Client) DisableVulnerabilityAlerts(ctx context.Context, req *DisableVulnerabilityAlertsReq, opt ...options.Option) (*DisableVulnerabilityAlertsResponse, error) {
	return DisableVulnerabilityAlerts(ctx, req, append(c, opt...)...)
}

/*
DisableVulnerabilityAlertsReq is request data for Client.DisableVulnerabilityAlerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
type DisableVulnerabilityAlertsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling dependency alerts for a repository using the REST API is
	currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DisableVulnerabilityAlertsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DisableVulnerabilityAlertsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"dorian"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/disable-vulnerability-alerts",
		Previews:         map[string]bool{"dorian": r.DorianPreview},
		RequiredPreviews: []string{"dorian"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DisableVulnerabilityAlertsReq) Rel(link string, resp *DisableVulnerabilityAlertsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DisableVulnerabilityAlertsResponse is a response for DisableVulnerabilityAlerts

https://developer.github.com/v3/repos/#disable-vulnerability-alerts
*/
type DisableVulnerabilityAlertsResponse struct {
	common.Response
	request *DisableVulnerabilityAlertsReq
}

/*
DownloadTarballArchive performs requests for "repos/download-tarball-archive"

Download a repository archive (tar).

  GET /repos/{owner}/{repo}/tarball/{ref}

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
func DownloadTarballArchive(ctx context.Context, req *DownloadTarballArchiveReq, opt ...options.Option) (*DownloadTarballArchiveResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DownloadTarballArchiveReq)
	}
	resp := &DownloadTarballArchiveResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DownloadTarballArchive performs requests for "repos/download-tarball-archive"

Download a repository archive (tar).

  GET /repos/{owner}/{repo}/tarball/{ref}

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
func (c Client) DownloadTarballArchive(ctx context.Context, req *DownloadTarballArchiveReq, opt ...options.Option) (*DownloadTarballArchiveResponse, error) {
	return DownloadTarballArchive(ctx, req, append(c, opt...)...)
}

/*
DownloadTarballArchiveReq is request data for Client.DownloadTarballArchive

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
type DownloadTarballArchiveReq struct {
	_url  string
	Owner string
	Repo  string

	// ref parameter
	Ref string
}

// HTTPRequest builds an *http.Request
func (r *DownloadTarballArchiveReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DownloadTarballArchiveReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "repos/download-tarball-archive",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/tarball/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DownloadTarballArchiveReq) Rel(link string, resp *DownloadTarballArchiveResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DownloadTarballArchiveResponse is a response for DownloadTarballArchive

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
type DownloadTarballArchiveResponse struct {
	common.Response
	request *DownloadTarballArchiveReq
}

/*
DownloadZipballArchive performs requests for "repos/download-zipball-archive"

Download a repository archive (zip).

  GET /repos/{owner}/{repo}/zipball/{ref}

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
func DownloadZipballArchive(ctx context.Context, req *DownloadZipballArchiveReq, opt ...options.Option) (*DownloadZipballArchiveResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DownloadZipballArchiveReq)
	}
	resp := &DownloadZipballArchiveResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DownloadZipballArchive performs requests for "repos/download-zipball-archive"

Download a repository archive (zip).

  GET /repos/{owner}/{repo}/zipball/{ref}

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
func (c Client) DownloadZipballArchive(ctx context.Context, req *DownloadZipballArchiveReq, opt ...options.Option) (*DownloadZipballArchiveResponse, error) {
	return DownloadZipballArchive(ctx, req, append(c, opt...)...)
}

/*
DownloadZipballArchiveReq is request data for Client.DownloadZipballArchive

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
type DownloadZipballArchiveReq struct {
	_url  string
	Owner string
	Repo  string

	// ref parameter
	Ref string
}

// HTTPRequest builds an *http.Request
func (r *DownloadZipballArchiveReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DownloadZipballArchiveReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "repos/download-zipball-archive",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/zipball/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DownloadZipballArchiveReq) Rel(link string, resp *DownloadZipballArchiveResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DownloadZipballArchiveResponse is a response for DownloadZipballArchive

https://developer.github.com/v3/repos/contents/#download-a-repository-archive
*/
type DownloadZipballArchiveResponse struct {
	common.Response
	request *DownloadZipballArchiveReq
}

/*
EnableAutomatedSecurityFixes performs requests for "repos/enable-automated-security-fixes"

Enable automated security fixes.

  PUT /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
func EnableAutomatedSecurityFixes(ctx context.Context, req *EnableAutomatedSecurityFixesReq, opt ...options.Option) (*EnableAutomatedSecurityFixesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(EnableAutomatedSecurityFixesReq)
	}
	resp := &EnableAutomatedSecurityFixesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
EnableAutomatedSecurityFixes performs requests for "repos/enable-automated-security-fixes"

Enable automated security fixes.

  PUT /repos/{owner}/{repo}/automated-security-fixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
func (c Client) EnableAutomatedSecurityFixes(ctx context.Context, req *EnableAutomatedSecurityFixesReq, opt ...options.Option) (*EnableAutomatedSecurityFixesResponse, error) {
	return EnableAutomatedSecurityFixes(ctx, req, append(c, opt...)...)
}

/*
EnableAutomatedSecurityFixesReq is request data for Client.EnableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
type EnableAutomatedSecurityFixesReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling or disabling automated security fixes is currently available for
	developers to preview. To access this new endpoint during the preview period,
	you must set this to true.
	*/
	LondonPreview bool
}

// HTTPRequest builds an *http.Request
func (r *EnableAutomatedSecurityFixesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *EnableAutomatedSecurityFixesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"london"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "repos/enable-automated-security-fixes",
		Previews:         map[string]bool{"london": r.LondonPreview},
		RequiredPreviews: []string{"london"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/automated-security-fixes", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *EnableAutomatedSecurityFixesReq) Rel(link string, resp *EnableAutomatedSecurityFixesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
EnableAutomatedSecurityFixesResponse is a response for EnableAutomatedSecurityFixes

https://developer.github.com/v3/repos/#enable-automated-security-fixes
*/
type EnableAutomatedSecurityFixesResponse struct {
	common.Response
	request *EnableAutomatedSecurityFixesReq
}

/*
EnableVulnerabilityAlerts performs requests for "repos/enable-vulnerability-alerts"

Enable vulnerability alerts.

  PUT /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
func EnableVulnerabilityAlerts(ctx context.Context, req *EnableVulnerabilityAlertsReq, opt ...options.Option) (*EnableVulnerabilityAlertsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(EnableVulnerabilityAlertsReq)
	}
	resp := &EnableVulnerabilityAlertsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
EnableVulnerabilityAlerts performs requests for "repos/enable-vulnerability-alerts"

Enable vulnerability alerts.

  PUT /repos/{owner}/{repo}/vulnerability-alerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
func (c Client) EnableVulnerabilityAlerts(ctx context.Context, req *EnableVulnerabilityAlertsReq, opt ...options.Option) (*EnableVulnerabilityAlertsResponse, error) {
	return EnableVulnerabilityAlerts(ctx, req, append(c, opt...)...)
}

/*
EnableVulnerabilityAlertsReq is request data for Client.EnableVulnerabilityAlerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
type EnableVulnerabilityAlertsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Enabling and disabling dependency alerts for a repository using the REST API is
	currently available for developers to preview. To access these new endpoints
	during the preview period, you must set this to true.
	*/
	DorianPreview bool
}

// HTTPRequest builds an *http.Request
func (r *EnableVulnerabilityAlertsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *EnableVulnerabilityAlertsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"dorian"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "repos/enable-vulnerability-alerts",
		Previews:         map[string]bool{"dorian": r.DorianPreview},
		RequiredPreviews: []string{"dorian"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/vulnerability-alerts", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *EnableVulnerabilityAlertsReq) Rel(link string, resp *EnableVulnerabilityAlertsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
EnableVulnerabilityAlertsResponse is a response for EnableVulnerabilityAlerts

https://developer.github.com/v3/repos/#enable-vulnerability-alerts
*/
type EnableVulnerabilityAlertsResponse struct {
	common.Response
	request *EnableVulnerabilityAlertsReq
}

/*
Get performs requests for "repos/get"

Get a repository.

  GET /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#get-a-repository
*/
func Get(ctx context.Context, req *GetReq, opt ...options.Option) (*GetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetReq)
	}
	resp := &GetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.FullRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Get performs requests for "repos/get"

Get a repository.

  GET /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#get-a-repository
*/
func (c Client) Get(ctx context.Context, req *GetReq, opt ...options.Option) (*GetResponse, error) {
	return Get(ctx, req, append(c, opt...)...)
}

/*
GetReq is request data for Client.Get

https://developer.github.com/v3/repos/#get-a-repository
*/
type GetReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The Codes of Conduct API is currently available for developers to preview.

	To access the API during the preview period, you must set this to true.
	*/
	ScarletWitchPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"nebula", "scarlet-witch"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": internal.String("application/json")},
		Method:       "GET",
		OperationID:  "repos/get",
		Previews: map[string]bool{
			"nebula":        r.NebulaPreview,
			"scarlet-witch": r.ScarletWitchPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 301},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReq) Rel(link string, resp *GetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetResponse is a response for Get

https://developer.github.com/v3/repos/#get-a-repository
*/
type GetResponse struct {
	common.Response
	request *GetReq
	Data    components.FullRepository
}

/*
GetAccessRestrictions performs requests for "repos/get-access-restrictions"

Get access restrictions.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#get-access-restrictions
*/
func GetAccessRestrictions(ctx context.Context, req *GetAccessRestrictionsReq, opt ...options.Option) (*GetAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetAccessRestrictionsReq)
	}
	resp := &GetAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.BranchRestrictionPolicy{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetAccessRestrictions performs requests for "repos/get-access-restrictions"

Get access restrictions.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions

https://developer.github.com/v3/repos/branches/#get-access-restrictions
*/
func (c Client) GetAccessRestrictions(ctx context.Context, req *GetAccessRestrictionsReq, opt ...options.Option) (*GetAccessRestrictionsResponse, error) {
	return GetAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
GetAccessRestrictionsReq is request data for Client.GetAccessRestrictions

https://developer.github.com/v3/repos/branches/#get-access-restrictions
*/
type GetAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *GetAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetAccessRestrictionsReq) Rel(link string, resp *GetAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetAccessRestrictionsResponse is a response for GetAccessRestrictions

https://developer.github.com/v3/repos/branches/#get-access-restrictions
*/
type GetAccessRestrictionsResponse struct {
	common.Response
	request *GetAccessRestrictionsReq
	Data    components.BranchRestrictionPolicy
}

/*
GetAdminBranchProtection performs requests for "repos/get-admin-branch-protection"

Get admin branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#get-admin-branch-protection
*/
func GetAdminBranchProtection(ctx context.Context, req *GetAdminBranchProtectionReq, opt ...options.Option) (*GetAdminBranchProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetAdminBranchProtectionReq)
	}
	resp := &GetAdminBranchProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranchAdminEnforced{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetAdminBranchProtection performs requests for "repos/get-admin-branch-protection"

Get admin branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#get-admin-branch-protection
*/
func (c Client) GetAdminBranchProtection(ctx context.Context, req *GetAdminBranchProtectionReq, opt ...options.Option) (*GetAdminBranchProtectionResponse, error) {
	return GetAdminBranchProtection(ctx, req, append(c, opt...)...)
}

/*
GetAdminBranchProtectionReq is request data for Client.GetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#get-admin-branch-protection
*/
type GetAdminBranchProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *GetAdminBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetAdminBranchProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-admin-branch-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetAdminBranchProtectionReq) Rel(link string, resp *GetAdminBranchProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetAdminBranchProtectionResponse is a response for GetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#get-admin-branch-protection
*/
type GetAdminBranchProtectionResponse struct {
	common.Response
	request *GetAdminBranchProtectionReq
	Data    components.ProtectedBranchAdminEnforced
}

/*
GetAllStatusCheckContexts performs requests for "repos/get-all-status-check-contexts"

Get all status check contexts.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
func GetAllStatusCheckContexts(ctx context.Context, req *GetAllStatusCheckContextsReq, opt ...options.Option) (*GetAllStatusCheckContextsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetAllStatusCheckContextsReq)
	}
	resp := &GetAllStatusCheckContextsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = GetAllStatusCheckContextsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetAllStatusCheckContexts performs requests for "repos/get-all-status-check-contexts"

Get all status check contexts.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
func (c Client) GetAllStatusCheckContexts(ctx context.Context, req *GetAllStatusCheckContextsReq, opt ...options.Option) (*GetAllStatusCheckContextsResponse, error) {
	return GetAllStatusCheckContexts(ctx, req, append(c, opt...)...)
}

/*
GetAllStatusCheckContextsReq is request data for Client.GetAllStatusCheckContexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
type GetAllStatusCheckContextsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *GetAllStatusCheckContextsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetAllStatusCheckContextsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-all-status-check-contexts",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetAllStatusCheckContextsReq) Rel(link string, resp *GetAllStatusCheckContextsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetAllStatusCheckContextsResponseBody is a response body for GetAllStatusCheckContexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
type GetAllStatusCheckContextsResponseBody []string

/*
GetAllStatusCheckContextsResponse is a response for GetAllStatusCheckContexts

https://developer.github.com/v3/repos/branches/#get-all-status-check-contexts
*/
type GetAllStatusCheckContextsResponse struct {
	common.Response
	request *GetAllStatusCheckContextsReq
	Data    GetAllStatusCheckContextsResponseBody
}

/*
GetAllTopics performs requests for "repos/get-all-topics"

Get all repository topics.

  GET /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
func GetAllTopics(ctx context.Context, req *GetAllTopicsReq, opt ...options.Option) (*GetAllTopicsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetAllTopicsReq)
	}
	resp := &GetAllTopicsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Topic{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetAllTopics performs requests for "repos/get-all-topics"

Get all repository topics.

  GET /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
func (c Client) GetAllTopics(ctx context.Context, req *GetAllTopicsReq, opt ...options.Option) (*GetAllTopicsResponse, error) {
	return GetAllTopics(ctx, req, append(c, opt...)...)
}

/*
GetAllTopicsReq is request data for Client.GetAllTopics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
type GetAllTopicsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetAllTopicsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetAllTopicsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"mercy"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-all-topics",
		Previews:         map[string]bool{"mercy": r.MercyPreview},
		RequiredPreviews: []string{"mercy"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/topics", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetAllTopicsReq) Rel(link string, resp *GetAllTopicsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetAllTopicsResponse is a response for GetAllTopics

https://developer.github.com/v3/repos/#get-all-repository-topics
*/
type GetAllTopicsResponse struct {
	common.Response
	request *GetAllTopicsReq
	Data    components.Topic
}

/*
GetAppsWithAccessToProtectedBranch performs requests for "repos/get-apps-with-access-to-protected-branch"

Get apps with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-the-protected-branch
*/
func GetAppsWithAccessToProtectedBranch(ctx context.Context, req *GetAppsWithAccessToProtectedBranchReq, opt ...options.Option) (*GetAppsWithAccessToProtectedBranchResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetAppsWithAccessToProtectedBranchReq)
	}
	resp := &GetAppsWithAccessToProtectedBranchResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Integration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetAppsWithAccessToProtectedBranch performs requests for "repos/get-apps-with-access-to-protected-branch"

Get apps with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-the-protected-branch
*/
func (c Client) GetAppsWithAccessToProtectedBranch(ctx context.Context, req *GetAppsWithAccessToProtectedBranchReq, opt ...options.Option) (*GetAppsWithAccessToProtectedBranchResponse, error) {
	return GetAppsWithAccessToProtectedBranch(ctx, req, append(c, opt...)...)
}

/*
GetAppsWithAccessToProtectedBranchReq is request data for Client.GetAppsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-the-protected-branch
*/
type GetAppsWithAccessToProtectedBranchReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *GetAppsWithAccessToProtectedBranchReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetAppsWithAccessToProtectedBranchReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-apps-with-access-to-protected-branch",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetAppsWithAccessToProtectedBranchReq) Rel(link string, resp *GetAppsWithAccessToProtectedBranchResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetAppsWithAccessToProtectedBranchResponse is a response for GetAppsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-apps-with-access-to-the-protected-branch
*/
type GetAppsWithAccessToProtectedBranchResponse struct {
	common.Response
	request *GetAppsWithAccessToProtectedBranchReq
	Data    []components.Integration
}

/*
GetBranch performs requests for "repos/get-branch"

Get a branch.

  GET /repos/{owner}/{repo}/branches/{branch}

https://developer.github.com/v3/repos/branches/#get-a-branch
*/
func GetBranch(ctx context.Context, req *GetBranchReq, opt ...options.Option) (*GetBranchResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetBranchReq)
	}
	resp := &GetBranchResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.BranchWithProtection{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetBranch performs requests for "repos/get-branch"

Get a branch.

  GET /repos/{owner}/{repo}/branches/{branch}

https://developer.github.com/v3/repos/branches/#get-a-branch
*/
func (c Client) GetBranch(ctx context.Context, req *GetBranchReq, opt ...options.Option) (*GetBranchResponse, error) {
	return GetBranch(ctx, req, append(c, opt...)...)
}

/*
GetBranchReq is request data for Client.GetBranch

https://developer.github.com/v3/repos/branches/#get-a-branch
*/
type GetBranchReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *GetBranchReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetBranchReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-branch",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetBranchReq) Rel(link string, resp *GetBranchResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetBranchResponse is a response for GetBranch

https://developer.github.com/v3/repos/branches/#get-a-branch
*/
type GetBranchResponse struct {
	common.Response
	request *GetBranchReq
	Data    components.BranchWithProtection
}

/*
GetBranchProtection performs requests for "repos/get-branch-protection"

Get branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
func GetBranchProtection(ctx context.Context, req *GetBranchProtectionReq, opt ...options.Option) (*GetBranchProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetBranchProtectionReq)
	}
	resp := &GetBranchProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.BranchProtection{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetBranchProtection performs requests for "repos/get-branch-protection"

Get branch protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
func (c Client) GetBranchProtection(ctx context.Context, req *GetBranchProtectionReq, opt ...options.Option) (*GetBranchProtectionResponse, error) {
	return GetBranchProtection(ctx, req, append(c, opt...)...)
}

/*
GetBranchProtectionReq is request data for Client.GetBranchProtection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
type GetBranchProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetBranchProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"luke-cage"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-branch-protection",
		Previews:         map[string]bool{"luke-cage": r.LukeCagePreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetBranchProtectionReq) Rel(link string, resp *GetBranchProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetBranchProtectionResponse is a response for GetBranchProtection

https://developer.github.com/v3/repos/branches/#get-branch-protection
*/
type GetBranchProtectionResponse struct {
	common.Response
	request *GetBranchProtectionReq
	Data    components.BranchProtection
}

/*
GetClones performs requests for "repos/get-clones"

Get repository clones.

  GET /repos/{owner}/{repo}/traffic/clones

https://developer.github.com/v3/repos/traffic/#get-repository-clones
*/
func GetClones(ctx context.Context, req *GetClonesReq, opt ...options.Option) (*GetClonesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetClonesReq)
	}
	resp := &GetClonesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CloneTraffic{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetClones performs requests for "repos/get-clones"

Get repository clones.

  GET /repos/{owner}/{repo}/traffic/clones

https://developer.github.com/v3/repos/traffic/#get-repository-clones
*/
func (c Client) GetClones(ctx context.Context, req *GetClonesReq, opt ...options.Option) (*GetClonesResponse, error) {
	return GetClones(ctx, req, append(c, opt...)...)
}

/*
GetClonesReq is request data for Client.GetClones

https://developer.github.com/v3/repos/traffic/#get-repository-clones
*/
type GetClonesReq struct {
	_url  string
	Owner string
	Repo  string

	// Must be one of: `day`, `week`.
	Per *string
}

// HTTPRequest builds an *http.Request
func (r *GetClonesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetClonesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Per != nil {
		query.Set("per", *r.Per)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-clones",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/traffic/clones", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetClonesReq) Rel(link string, resp *GetClonesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetClonesResponse is a response for GetClones

https://developer.github.com/v3/repos/traffic/#get-repository-clones
*/
type GetClonesResponse struct {
	common.Response
	request *GetClonesReq
	Data    components.CloneTraffic
}

/*
GetCodeFrequencyStats performs requests for "repos/get-code-frequency-stats"

Get the weekly commit activity.

  GET /repos/{owner}/{repo}/stats/code_frequency

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-activity
*/
func GetCodeFrequencyStats(ctx context.Context, req *GetCodeFrequencyStatsReq, opt ...options.Option) (*GetCodeFrequencyStatsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCodeFrequencyStatsReq)
	}
	resp := &GetCodeFrequencyStatsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CodeFrequencyStat{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetCodeFrequencyStats performs requests for "repos/get-code-frequency-stats"

Get the weekly commit activity.

  GET /repos/{owner}/{repo}/stats/code_frequency

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-activity
*/
func (c Client) GetCodeFrequencyStats(ctx context.Context, req *GetCodeFrequencyStatsReq, opt ...options.Option) (*GetCodeFrequencyStatsResponse, error) {
	return GetCodeFrequencyStats(ctx, req, append(c, opt...)...)
}

/*
GetCodeFrequencyStatsReq is request data for Client.GetCodeFrequencyStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-activity
*/
type GetCodeFrequencyStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetCodeFrequencyStatsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCodeFrequencyStatsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-code-frequency-stats",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/stats/code_frequency", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCodeFrequencyStatsReq) Rel(link string, resp *GetCodeFrequencyStatsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCodeFrequencyStatsResponse is a response for GetCodeFrequencyStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-activity
*/
type GetCodeFrequencyStatsResponse struct {
	common.Response
	request *GetCodeFrequencyStatsReq
	Data    []components.CodeFrequencyStat
}

/*
GetCollaboratorPermissionLevel performs requests for "repos/get-collaborator-permission-level"

Get repository permissions for a user.

  GET /repos/{owner}/{repo}/collaborators/{username}/permission

https://developer.github.com/v3/repos/collaborators/#get-repository-permissions-for-a-user
*/
func GetCollaboratorPermissionLevel(ctx context.Context, req *GetCollaboratorPermissionLevelReq, opt ...options.Option) (*GetCollaboratorPermissionLevelResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCollaboratorPermissionLevelReq)
	}
	resp := &GetCollaboratorPermissionLevelResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.RepositoryCollaboratorPermission{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetCollaboratorPermissionLevel performs requests for "repos/get-collaborator-permission-level"

Get repository permissions for a user.

  GET /repos/{owner}/{repo}/collaborators/{username}/permission

https://developer.github.com/v3/repos/collaborators/#get-repository-permissions-for-a-user
*/
func (c Client) GetCollaboratorPermissionLevel(ctx context.Context, req *GetCollaboratorPermissionLevelReq, opt ...options.Option) (*GetCollaboratorPermissionLevelResponse, error) {
	return GetCollaboratorPermissionLevel(ctx, req, append(c, opt...)...)
}

/*
GetCollaboratorPermissionLevelReq is request data for Client.GetCollaboratorPermissionLevel

https://developer.github.com/v3/repos/collaborators/#get-repository-permissions-for-a-user
*/
type GetCollaboratorPermissionLevelReq struct {
	_url     string
	Owner    string
	Repo     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetCollaboratorPermissionLevelReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCollaboratorPermissionLevelReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-collaborator-permission-level",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/collaborators/%v/permission", r.Owner, r.Repo, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCollaboratorPermissionLevelReq) Rel(link string, resp *GetCollaboratorPermissionLevelResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCollaboratorPermissionLevelResponse is a response for GetCollaboratorPermissionLevel

https://developer.github.com/v3/repos/collaborators/#get-repository-permissions-for-a-user
*/
type GetCollaboratorPermissionLevelResponse struct {
	common.Response
	request *GetCollaboratorPermissionLevelReq
	Data    components.RepositoryCollaboratorPermission
}

/*
GetCombinedStatusForRef performs requests for "repos/get-combined-status-for-ref"

Get the combined status for a specific reference.

  GET /repos/{owner}/{repo}/commits/{ref}/status

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-reference
*/
func GetCombinedStatusForRef(ctx context.Context, req *GetCombinedStatusForRefReq, opt ...options.Option) (*GetCombinedStatusForRefResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCombinedStatusForRefReq)
	}
	resp := &GetCombinedStatusForRefResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CombinedCommitStatus{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetCombinedStatusForRef performs requests for "repos/get-combined-status-for-ref"

Get the combined status for a specific reference.

  GET /repos/{owner}/{repo}/commits/{ref}/status

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-reference
*/
func (c Client) GetCombinedStatusForRef(ctx context.Context, req *GetCombinedStatusForRefReq, opt ...options.Option) (*GetCombinedStatusForRefResponse, error) {
	return GetCombinedStatusForRef(ctx, req, append(c, opt...)...)
}

/*
GetCombinedStatusForRefReq is request data for Client.GetCombinedStatusForRef

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-reference
*/
type GetCombinedStatusForRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string
}

// HTTPRequest builds an *http.Request
func (r *GetCombinedStatusForRefReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCombinedStatusForRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-combined-status-for-ref",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/status", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCombinedStatusForRefReq) Rel(link string, resp *GetCombinedStatusForRefResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCombinedStatusForRefResponse is a response for GetCombinedStatusForRef

https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-reference
*/
type GetCombinedStatusForRefResponse struct {
	common.Response
	request *GetCombinedStatusForRefReq
	Data    components.CombinedCommitStatus
}

/*
GetCommit performs requests for "repos/get-commit"

Get a commit.

  GET /repos/{owner}/{repo}/commits/{ref}

https://developer.github.com/v3/repos/commits/#get-a-commit
*/
func GetCommit(ctx context.Context, req *GetCommitReq, opt ...options.Option) (*GetCommitResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCommitReq)
	}
	resp := &GetCommitResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Commit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetCommit performs requests for "repos/get-commit"

Get a commit.

  GET /repos/{owner}/{repo}/commits/{ref}

https://developer.github.com/v3/repos/commits/#get-a-commit
*/
func (c Client) GetCommit(ctx context.Context, req *GetCommitReq, opt ...options.Option) (*GetCommitResponse, error) {
	return GetCommit(ctx, req, append(c, opt...)...)
}

/*
GetCommitReq is request data for Client.GetCommit

https://developer.github.com/v3/repos/commits/#get-a-commit
*/
type GetCommitReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string
}

// HTTPRequest builds an *http.Request
func (r *GetCommitReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCommitReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-commit",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCommitReq) Rel(link string, resp *GetCommitResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCommitResponse is a response for GetCommit

https://developer.github.com/v3/repos/commits/#get-a-commit
*/
type GetCommitResponse struct {
	common.Response
	request *GetCommitReq
	Data    components.Commit
}

/*
GetCommitActivityStats performs requests for "repos/get-commit-activity-stats"

Get the last year of commit activity.

  GET /repos/{owner}/{repo}/stats/commit_activity

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity
*/
func GetCommitActivityStats(ctx context.Context, req *GetCommitActivityStatsReq, opt ...options.Option) (*GetCommitActivityStatsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCommitActivityStatsReq)
	}
	resp := &GetCommitActivityStatsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CommitActivity{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetCommitActivityStats performs requests for "repos/get-commit-activity-stats"

Get the last year of commit activity.

  GET /repos/{owner}/{repo}/stats/commit_activity

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity
*/
func (c Client) GetCommitActivityStats(ctx context.Context, req *GetCommitActivityStatsReq, opt ...options.Option) (*GetCommitActivityStatsResponse, error) {
	return GetCommitActivityStats(ctx, req, append(c, opt...)...)
}

/*
GetCommitActivityStatsReq is request data for Client.GetCommitActivityStats

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity
*/
type GetCommitActivityStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetCommitActivityStatsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCommitActivityStatsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-commit-activity-stats",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/stats/commit_activity", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCommitActivityStatsReq) Rel(link string, resp *GetCommitActivityStatsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCommitActivityStatsResponse is a response for GetCommitActivityStats

https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity
*/
type GetCommitActivityStatsResponse struct {
	common.Response
	request *GetCommitActivityStatsReq
	Data    []components.CommitActivity
}

/*
GetCommitComment performs requests for "repos/get-commit-comment"

Get a commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#get-a-commit-comment
*/
func GetCommitComment(ctx context.Context, req *GetCommitCommentReq, opt ...options.Option) (*GetCommitCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCommitCommentReq)
	}
	resp := &GetCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CommitComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetCommitComment performs requests for "repos/get-commit-comment"

Get a commit comment.

  GET /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#get-a-commit-comment
*/
func (c Client) GetCommitComment(ctx context.Context, req *GetCommitCommentReq, opt ...options.Option) (*GetCommitCommentResponse, error) {
	return GetCommitComment(ctx, req, append(c, opt...)...)
}

/*
GetCommitCommentReq is request data for Client.GetCommitComment

https://developer.github.com/v3/repos/comments/#get-a-commit-comment
*/
type GetCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetCommitCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-commit-comment",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCommitCommentReq) Rel(link string, resp *GetCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCommitCommentResponse is a response for GetCommitComment

https://developer.github.com/v3/repos/comments/#get-a-commit-comment
*/
type GetCommitCommentResponse struct {
	common.Response
	request *GetCommitCommentReq
	Data    components.CommitComment
}

/*
GetCommitSignatureProtection performs requests for "repos/get-commit-signature-protection"

Get commit signature protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#get-commit-signature-protection
*/
func GetCommitSignatureProtection(ctx context.Context, req *GetCommitSignatureProtectionReq, opt ...options.Option) (*GetCommitSignatureProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCommitSignatureProtectionReq)
	}
	resp := &GetCommitSignatureProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranchAdminEnforced{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetCommitSignatureProtection performs requests for "repos/get-commit-signature-protection"

Get commit signature protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures

https://developer.github.com/v3/repos/branches/#get-commit-signature-protection
*/
func (c Client) GetCommitSignatureProtection(ctx context.Context, req *GetCommitSignatureProtectionReq, opt ...options.Option) (*GetCommitSignatureProtectionResponse, error) {
	return GetCommitSignatureProtection(ctx, req, append(c, opt...)...)
}

/*
GetCommitSignatureProtectionReq is request data for Client.GetCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#get-commit-signature-protection
*/
type GetCommitSignatureProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string

	/*
	Protected Branches API can now manage a setting for requiring signed commits.
	This feature is currently available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-02-22-protected-branches-required-signatures)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	ZzzaxPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetCommitSignatureProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCommitSignatureProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"zzzax"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-commit-signature-protection",
		Previews:         map[string]bool{"zzzax": r.ZzzaxPreview},
		RequiredPreviews: []string{"zzzax"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_signatures", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCommitSignatureProtectionReq) Rel(link string, resp *GetCommitSignatureProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCommitSignatureProtectionResponse is a response for GetCommitSignatureProtection

https://developer.github.com/v3/repos/branches/#get-commit-signature-protection
*/
type GetCommitSignatureProtectionResponse struct {
	common.Response
	request *GetCommitSignatureProtectionReq
	Data    components.ProtectedBranchAdminEnforced
}

/*
GetCommunityProfileMetrics performs requests for "repos/get-community-profile-metrics"

Get community profile metrics.

  GET /repos/{owner}/{repo}/community/profile

https://developer.github.com/v3/repos/community/#get-community-profile-metrics
*/
func GetCommunityProfileMetrics(ctx context.Context, req *GetCommunityProfileMetricsReq, opt ...options.Option) (*GetCommunityProfileMetricsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCommunityProfileMetricsReq)
	}
	resp := &GetCommunityProfileMetricsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CommunityProfile{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetCommunityProfileMetrics performs requests for "repos/get-community-profile-metrics"

Get community profile metrics.

  GET /repos/{owner}/{repo}/community/profile

https://developer.github.com/v3/repos/community/#get-community-profile-metrics
*/
func (c Client) GetCommunityProfileMetrics(ctx context.Context, req *GetCommunityProfileMetricsReq, opt ...options.Option) (*GetCommunityProfileMetricsResponse, error) {
	return GetCommunityProfileMetrics(ctx, req, append(c, opt...)...)
}

/*
GetCommunityProfileMetricsReq is request data for Client.GetCommunityProfileMetrics

https://developer.github.com/v3/repos/community/#get-community-profile-metrics
*/
type GetCommunityProfileMetricsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	We're currently offering a preview of the Community Profile API (also known as
	community health). To access the API during the preview period, you must set
	this to true.
	*/
	BlackPantherPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetCommunityProfileMetricsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCommunityProfileMetricsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"black-panther"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-community-profile-metrics",
		Previews:         map[string]bool{"black-panther": r.BlackPantherPreview},
		RequiredPreviews: []string{"black-panther"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/community/profile", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCommunityProfileMetricsReq) Rel(link string, resp *GetCommunityProfileMetricsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCommunityProfileMetricsResponse is a response for GetCommunityProfileMetrics

https://developer.github.com/v3/repos/community/#get-community-profile-metrics
*/
type GetCommunityProfileMetricsResponse struct {
	common.Response
	request *GetCommunityProfileMetricsReq
	Data    components.CommunityProfile
}

/*
GetContent performs requests for "repos/get-content"

Get repository content.

  GET /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
func GetContent(ctx context.Context, req *GetContentReq, opt ...options.Option) (*GetContentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetContentReq)
	}
	resp := &GetContentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = GetContentResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetContent performs requests for "repos/get-content"

Get repository content.

  GET /repos/{owner}/{repo}/contents/{path}

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
func (c Client) GetContent(ctx context.Context, req *GetContentReq, opt ...options.Option) (*GetContentResponse, error) {
	return GetContent(ctx, req, append(c, opt...)...)
}

/*
GetContentReq is request data for Client.GetContent

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
type GetContentReq struct {
	_url  string
	Owner string
	Repo  string

	// path+ parameter
	Path string

	/*
	The name of the commit/branch/tag. Default: the repository’s default branch
	(usually `master`)
	*/
	Ref *string
}

// HTTPRequest builds an *http.Request
func (r *GetContentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetContentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-content",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/contents/%v", r.Owner, r.Repo, r.Path),
		URLQuery:         query,
		ValidStatuses:    []int{200, 302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetContentReq) Rel(link string, resp *GetContentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetContentResponseBody is a response body for GetContent

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
type GetContentResponseBody struct {
	oneOfField string

	// A list of directory items
	contentDirectory components.ContentDirectory

	// Content File
	contentFile components.ContentFile

	// An object describing a symlink
	contentSymlink components.ContentSymlink

	// An object describing a symlink
	contentSubmodule components.ContentSubmodule
}

// Value returns GetContentResponseBody's value. The type will be one of components.ContentDirectory, components.ContentFile, components.ContentSymlink or components.ContentSubmodule.
func (c *GetContentResponseBody) Value() interface{} {
	switch c.oneOfField {
	case "contentDirectory":
		return c.contentDirectory
	case "contentFile":
		return c.contentFile
	case "contentSymlink":
		return c.contentSymlink
	case "contentSubmodule":
		return c.contentSubmodule
	}
	return nil
}

// SetValue sets GetContentResponseBody's value. The type must be one of components.ContentDirectory, components.ContentFile, components.ContentSymlink or components.ContentSubmodule.
func (c *GetContentResponseBody) SetValue(value interface{}) {
	switch v := value.(type) {
	case components.ContentDirectory:
		c.contentDirectory = v
	case components.ContentFile:
		c.contentFile = v
	case components.ContentSymlink:
		c.contentSymlink = v
	case components.ContentSubmodule:
		c.contentSubmodule = v
	default:
		panic("type not acceptable")
	}
}

func (c *GetContentResponseBody) MarshalJSON() ([]byte, error) {
	switch c.oneOfField {
	case "contentDirectory":
		return json.Marshal(&c.contentDirectory)
	case "contentFile":
		return json.Marshal(&c.contentFile)
	case "contentSymlink":
		return json.Marshal(&c.contentSymlink)
	case "contentSubmodule":
		return json.Marshal(&c.contentSubmodule)
	}
	return json.Marshal(interface{}(nil))
}

func (c *GetContentResponseBody) UnmarshalJSON(data []byte) error {
	var err error
	err = json.Unmarshal(data, &c.contentDirectory)
	if err == nil {
		c.oneOfField = "contentDirectory"
		return nil
	}
	err = json.Unmarshal(data, &c.contentFile)
	if err == nil {
		c.oneOfField = "contentFile"
		return nil
	}
	err = json.Unmarshal(data, &c.contentSymlink)
	if err == nil {
		c.oneOfField = "contentSymlink"
		return nil
	}
	err = json.Unmarshal(data, &c.contentSubmodule)
	if err == nil {
		c.oneOfField = "contentSubmodule"
		return nil
	}
	return fmt.Errorf("could not unmarshal json")
}

/*
GetContentResponse is a response for GetContent

https://developer.github.com/v3/repos/contents/#get-repository-content
*/
type GetContentResponse struct {
	common.Response
	request *GetContentReq
	Data    GetContentResponseBody
}

/*
GetContributorsStats performs requests for "repos/get-contributors-stats"

Get all contributor commit activity.

  GET /repos/{owner}/{repo}/stats/contributors

https://developer.github.com/v3/repos/statistics/#get-all-contributor-commit-activity
*/
func GetContributorsStats(ctx context.Context, req *GetContributorsStatsReq, opt ...options.Option) (*GetContributorsStatsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetContributorsStatsReq)
	}
	resp := &GetContributorsStatsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ContributorActivity{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetContributorsStats performs requests for "repos/get-contributors-stats"

Get all contributor commit activity.

  GET /repos/{owner}/{repo}/stats/contributors

https://developer.github.com/v3/repos/statistics/#get-all-contributor-commit-activity
*/
func (c Client) GetContributorsStats(ctx context.Context, req *GetContributorsStatsReq, opt ...options.Option) (*GetContributorsStatsResponse, error) {
	return GetContributorsStats(ctx, req, append(c, opt...)...)
}

/*
GetContributorsStatsReq is request data for Client.GetContributorsStats

https://developer.github.com/v3/repos/statistics/#get-all-contributor-commit-activity
*/
type GetContributorsStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetContributorsStatsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetContributorsStatsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-contributors-stats",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/stats/contributors", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetContributorsStatsReq) Rel(link string, resp *GetContributorsStatsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetContributorsStatsResponse is a response for GetContributorsStats

https://developer.github.com/v3/repos/statistics/#get-all-contributor-commit-activity
*/
type GetContributorsStatsResponse struct {
	common.Response
	request *GetContributorsStatsReq
	Data    []components.ContributorActivity
}

/*
GetDeployKey performs requests for "repos/get-deploy-key"

Get a deploy key.

  GET /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
func GetDeployKey(ctx context.Context, req *GetDeployKeyReq, opt ...options.Option) (*GetDeployKeyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetDeployKeyReq)
	}
	resp := &GetDeployKeyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.DeployKey{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetDeployKey performs requests for "repos/get-deploy-key"

Get a deploy key.

  GET /repos/{owner}/{repo}/keys/{key_id}

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
func (c Client) GetDeployKey(ctx context.Context, req *GetDeployKeyReq, opt ...options.Option) (*GetDeployKeyResponse, error) {
	return GetDeployKey(ctx, req, append(c, opt...)...)
}

/*
GetDeployKeyReq is request data for Client.GetDeployKey

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
type GetDeployKeyReq struct {
	_url  string
	Owner string
	Repo  string

	// key_id parameter
	KeyId int64
}

// HTTPRequest builds an *http.Request
func (r *GetDeployKeyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetDeployKeyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-deploy-key",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/keys/%v", r.Owner, r.Repo, r.KeyId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetDeployKeyReq) Rel(link string, resp *GetDeployKeyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetDeployKeyResponse is a response for GetDeployKey

https://developer.github.com/v3/repos/keys/#get-a-deploy-key
*/
type GetDeployKeyResponse struct {
	common.Response
	request *GetDeployKeyReq
	Data    components.DeployKey
}

/*
GetDeployment performs requests for "repos/get-deployment"

Get a deployment.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#get-a-deployment
*/
func GetDeployment(ctx context.Context, req *GetDeploymentReq, opt ...options.Option) (*GetDeploymentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetDeploymentReq)
	}
	resp := &GetDeploymentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Deployment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetDeployment performs requests for "repos/get-deployment"

Get a deployment.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}

https://developer.github.com/v3/repos/deployments/#get-a-deployment
*/
func (c Client) GetDeployment(ctx context.Context, req *GetDeploymentReq, opt ...options.Option) (*GetDeploymentResponse, error) {
	return GetDeployment(ctx, req, append(c, opt...)...)
}

/*
GetDeploymentReq is request data for Client.GetDeployment

https://developer.github.com/v3/repos/deployments/#get-a-deployment
*/
type GetDeploymentReq struct {
	_url  string
	Owner string
	Repo  string

	// deployment_id parameter
	DeploymentId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetDeploymentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetDeploymentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man", "ant-man"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": internal.String("application/json")},
		Method:       "GET",
		OperationID:  "repos/get-deployment",
		Previews: map[string]bool{
			"ant-man":     r.AntManPreview,
			"machine-man": r.MachineManPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments/%v", r.Owner, r.Repo, r.DeploymentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetDeploymentReq) Rel(link string, resp *GetDeploymentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetDeploymentResponse is a response for GetDeployment

https://developer.github.com/v3/repos/deployments/#get-a-deployment
*/
type GetDeploymentResponse struct {
	common.Response
	request *GetDeploymentReq
	Data    components.Deployment
}

/*
GetDeploymentStatus performs requests for "repos/get-deployment-status"

Get a deployment status.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}

https://developer.github.com/v3/repos/deployments/#get-a-deployment-status
*/
func GetDeploymentStatus(ctx context.Context, req *GetDeploymentStatusReq, opt ...options.Option) (*GetDeploymentStatusResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetDeploymentStatusReq)
	}
	resp := &GetDeploymentStatusResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.DeploymentStatus{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetDeploymentStatus performs requests for "repos/get-deployment-status"

Get a deployment status.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}

https://developer.github.com/v3/repos/deployments/#get-a-deployment-status
*/
func (c Client) GetDeploymentStatus(ctx context.Context, req *GetDeploymentStatusReq, opt ...options.Option) (*GetDeploymentStatusResponse, error) {
	return GetDeploymentStatus(ctx, req, append(c, opt...)...)
}

/*
GetDeploymentStatusReq is request data for Client.GetDeploymentStatus

https://developer.github.com/v3/repos/deployments/#get-a-deployment-status
*/
type GetDeploymentStatusReq struct {
	_url  string
	Owner string
	Repo  string

	// deployment_id parameter
	DeploymentId int64

	// status_id parameter
	StatusId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetDeploymentStatusReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetDeploymentStatusReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man", "flash", "ant-man"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": internal.String("application/json")},
		Method:       "GET",
		OperationID:  "repos/get-deployment-status",
		Previews: map[string]bool{
			"ant-man":     r.AntManPreview,
			"flash":       r.FlashPreview,
			"machine-man": r.MachineManPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses/%v", r.Owner, r.Repo, r.DeploymentId, r.StatusId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetDeploymentStatusReq) Rel(link string, resp *GetDeploymentStatusResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetDeploymentStatusResponse is a response for GetDeploymentStatus

https://developer.github.com/v3/repos/deployments/#get-a-deployment-status
*/
type GetDeploymentStatusResponse struct {
	common.Response
	request *GetDeploymentStatusReq
	Data    components.DeploymentStatus
}

/*
GetLatestPagesBuild performs requests for "repos/get-latest-pages-build"

Get latest Pages build.

  GET /repos/{owner}/{repo}/pages/builds/latest

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
func GetLatestPagesBuild(ctx context.Context, req *GetLatestPagesBuildReq, opt ...options.Option) (*GetLatestPagesBuildResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetLatestPagesBuildReq)
	}
	resp := &GetLatestPagesBuildResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PageBuild{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetLatestPagesBuild performs requests for "repos/get-latest-pages-build"

Get latest Pages build.

  GET /repos/{owner}/{repo}/pages/builds/latest

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
func (c Client) GetLatestPagesBuild(ctx context.Context, req *GetLatestPagesBuildReq, opt ...options.Option) (*GetLatestPagesBuildResponse, error) {
	return GetLatestPagesBuild(ctx, req, append(c, opt...)...)
}

/*
GetLatestPagesBuildReq is request data for Client.GetLatestPagesBuild

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
type GetLatestPagesBuildReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetLatestPagesBuildReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetLatestPagesBuildReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-latest-pages-build",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages/builds/latest", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetLatestPagesBuildReq) Rel(link string, resp *GetLatestPagesBuildResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetLatestPagesBuildResponse is a response for GetLatestPagesBuild

https://developer.github.com/v3/repos/pages/#get-latest-pages-build
*/
type GetLatestPagesBuildResponse struct {
	common.Response
	request *GetLatestPagesBuildReq
	Data    components.PageBuild
}

/*
GetLatestRelease performs requests for "repos/get-latest-release"

Get the latest release.

  GET /repos/{owner}/{repo}/releases/latest

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
func GetLatestRelease(ctx context.Context, req *GetLatestReleaseReq, opt ...options.Option) (*GetLatestReleaseResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetLatestReleaseReq)
	}
	resp := &GetLatestReleaseResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Release{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetLatestRelease performs requests for "repos/get-latest-release"

Get the latest release.

  GET /repos/{owner}/{repo}/releases/latest

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
func (c Client) GetLatestRelease(ctx context.Context, req *GetLatestReleaseReq, opt ...options.Option) (*GetLatestReleaseResponse, error) {
	return GetLatestRelease(ctx, req, append(c, opt...)...)
}

/*
GetLatestReleaseReq is request data for Client.GetLatestRelease

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
type GetLatestReleaseReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetLatestReleaseReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetLatestReleaseReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-latest-release",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/latest", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetLatestReleaseReq) Rel(link string, resp *GetLatestReleaseResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetLatestReleaseResponse is a response for GetLatestRelease

https://developer.github.com/v3/repos/releases/#get-the-latest-release
*/
type GetLatestReleaseResponse struct {
	common.Response
	request *GetLatestReleaseReq
	Data    components.Release
}

/*
GetPages performs requests for "repos/get-pages"

Get a GitHub Pages site.

  GET /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#get-a-github-pages-site
*/
func GetPages(ctx context.Context, req *GetPagesReq, opt ...options.Option) (*GetPagesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetPagesReq)
	}
	resp := &GetPagesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Page{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetPages performs requests for "repos/get-pages"

Get a GitHub Pages site.

  GET /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#get-a-github-pages-site
*/
func (c Client) GetPages(ctx context.Context, req *GetPagesReq, opt ...options.Option) (*GetPagesResponse, error) {
	return GetPages(ctx, req, append(c, opt...)...)
}

/*
GetPagesReq is request data for Client.GetPages

https://developer.github.com/v3/repos/pages/#get-a-github-pages-site
*/
type GetPagesReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetPagesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetPagesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-pages",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetPagesReq) Rel(link string, resp *GetPagesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetPagesResponse is a response for GetPages

https://developer.github.com/v3/repos/pages/#get-a-github-pages-site
*/
type GetPagesResponse struct {
	common.Response
	request *GetPagesReq
	Data    components.Page
}

/*
GetPagesBuild performs requests for "repos/get-pages-build"

Get GitHub Pages build.

  GET /repos/{owner}/{repo}/pages/builds/{build_id}

https://developer.github.com/v3/repos/pages/#get-github-pages-build
*/
func GetPagesBuild(ctx context.Context, req *GetPagesBuildReq, opt ...options.Option) (*GetPagesBuildResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetPagesBuildReq)
	}
	resp := &GetPagesBuildResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PageBuild{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetPagesBuild performs requests for "repos/get-pages-build"

Get GitHub Pages build.

  GET /repos/{owner}/{repo}/pages/builds/{build_id}

https://developer.github.com/v3/repos/pages/#get-github-pages-build
*/
func (c Client) GetPagesBuild(ctx context.Context, req *GetPagesBuildReq, opt ...options.Option) (*GetPagesBuildResponse, error) {
	return GetPagesBuild(ctx, req, append(c, opt...)...)
}

/*
GetPagesBuildReq is request data for Client.GetPagesBuild

https://developer.github.com/v3/repos/pages/#get-github-pages-build
*/
type GetPagesBuildReq struct {
	_url  string
	Owner string
	Repo  string

	// build_id parameter
	BuildId int64
}

// HTTPRequest builds an *http.Request
func (r *GetPagesBuildReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetPagesBuildReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-pages-build",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages/builds/%v", r.Owner, r.Repo, r.BuildId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetPagesBuildReq) Rel(link string, resp *GetPagesBuildResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetPagesBuildResponse is a response for GetPagesBuild

https://developer.github.com/v3/repos/pages/#get-github-pages-build
*/
type GetPagesBuildResponse struct {
	common.Response
	request *GetPagesBuildReq
	Data    components.PageBuild
}

/*
GetParticipationStats performs requests for "repos/get-participation-stats"

Get the weekly commit count.

  GET /repos/{owner}/{repo}/stats/participation

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count
*/
func GetParticipationStats(ctx context.Context, req *GetParticipationStatsReq, opt ...options.Option) (*GetParticipationStatsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetParticipationStatsReq)
	}
	resp := &GetParticipationStatsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ParticipationStats{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetParticipationStats performs requests for "repos/get-participation-stats"

Get the weekly commit count.

  GET /repos/{owner}/{repo}/stats/participation

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count
*/
func (c Client) GetParticipationStats(ctx context.Context, req *GetParticipationStatsReq, opt ...options.Option) (*GetParticipationStatsResponse, error) {
	return GetParticipationStats(ctx, req, append(c, opt...)...)
}

/*
GetParticipationStatsReq is request data for Client.GetParticipationStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count
*/
type GetParticipationStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetParticipationStatsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetParticipationStatsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-participation-stats",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/stats/participation", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetParticipationStatsReq) Rel(link string, resp *GetParticipationStatsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetParticipationStatsResponse is a response for GetParticipationStats

https://developer.github.com/v3/repos/statistics/#get-the-weekly-commit-count
*/
type GetParticipationStatsResponse struct {
	common.Response
	request *GetParticipationStatsReq
	Data    components.ParticipationStats
}

/*
GetPullRequestReviewProtection performs requests for "repos/get-pull-request-review-protection"

Get pull request review protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#get-pull-request-review-protection
*/
func GetPullRequestReviewProtection(ctx context.Context, req *GetPullRequestReviewProtectionReq, opt ...options.Option) (*GetPullRequestReviewProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetPullRequestReviewProtectionReq)
	}
	resp := &GetPullRequestReviewProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranchPullRequestReview{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetPullRequestReviewProtection performs requests for "repos/get-pull-request-review-protection"

Get pull request review protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#get-pull-request-review-protection
*/
func (c Client) GetPullRequestReviewProtection(ctx context.Context, req *GetPullRequestReviewProtectionReq, opt ...options.Option) (*GetPullRequestReviewProtectionResponse, error) {
	return GetPullRequestReviewProtection(ctx, req, append(c, opt...)...)
}

/*
GetPullRequestReviewProtectionReq is request data for Client.GetPullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#get-pull-request-review-protection
*/
type GetPullRequestReviewProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetPullRequestReviewProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetPullRequestReviewProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"luke-cage"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/vnd.github.luke-cage-preview+json")},
		Method:           "GET",
		OperationID:      "repos/get-pull-request-review-protection",
		Previews:         map[string]bool{"luke-cage": r.LukeCagePreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetPullRequestReviewProtectionReq) Rel(link string, resp *GetPullRequestReviewProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetPullRequestReviewProtectionResponse is a response for GetPullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#get-pull-request-review-protection
*/
type GetPullRequestReviewProtectionResponse struct {
	common.Response
	request *GetPullRequestReviewProtectionReq
	Data    components.ProtectedBranchPullRequestReview
}

/*
GetPunchCardStats performs requests for "repos/get-punch-card-stats"

Get the hourly commit count for each day.

  GET /repos/{owner}/{repo}/stats/punch_card

https://developer.github.com/v3/repos/statistics/#get-the-hourly-commit-count-for-each-day
*/
func GetPunchCardStats(ctx context.Context, req *GetPunchCardStatsReq, opt ...options.Option) (*GetPunchCardStatsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetPunchCardStatsReq)
	}
	resp := &GetPunchCardStatsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CodeFrequencyStat{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetPunchCardStats performs requests for "repos/get-punch-card-stats"

Get the hourly commit count for each day.

  GET /repos/{owner}/{repo}/stats/punch_card

https://developer.github.com/v3/repos/statistics/#get-the-hourly-commit-count-for-each-day
*/
func (c Client) GetPunchCardStats(ctx context.Context, req *GetPunchCardStatsReq, opt ...options.Option) (*GetPunchCardStatsResponse, error) {
	return GetPunchCardStats(ctx, req, append(c, opt...)...)
}

/*
GetPunchCardStatsReq is request data for Client.GetPunchCardStats

https://developer.github.com/v3/repos/statistics/#get-the-hourly-commit-count-for-each-day
*/
type GetPunchCardStatsReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetPunchCardStatsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetPunchCardStatsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-punch-card-stats",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/stats/punch_card", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetPunchCardStatsReq) Rel(link string, resp *GetPunchCardStatsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetPunchCardStatsResponse is a response for GetPunchCardStats

https://developer.github.com/v3/repos/statistics/#get-the-hourly-commit-count-for-each-day
*/
type GetPunchCardStatsResponse struct {
	common.Response
	request *GetPunchCardStatsReq
	Data    []components.CodeFrequencyStat
}

/*
GetReadme performs requests for "repos/get-readme"

Get a repository README.

  GET /repos/{owner}/{repo}/readme

https://developer.github.com/v3/repos/contents/#get-a-repository-readme
*/
func GetReadme(ctx context.Context, req *GetReadmeReq, opt ...options.Option) (*GetReadmeResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetReadmeReq)
	}
	resp := &GetReadmeResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ContentFile{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetReadme performs requests for "repos/get-readme"

Get a repository README.

  GET /repos/{owner}/{repo}/readme

https://developer.github.com/v3/repos/contents/#get-a-repository-readme
*/
func (c Client) GetReadme(ctx context.Context, req *GetReadmeReq, opt ...options.Option) (*GetReadmeResponse, error) {
	return GetReadme(ctx, req, append(c, opt...)...)
}

/*
GetReadmeReq is request data for Client.GetReadme

https://developer.github.com/v3/repos/contents/#get-a-repository-readme
*/
type GetReadmeReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	The name of the commit/branch/tag. Default: the repository’s default branch
	(usually `master`)
	*/
	Ref *string
}

// HTTPRequest builds an *http.Request
func (r *GetReadmeReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetReadmeReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-readme",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/readme", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReadmeReq) Rel(link string, resp *GetReadmeResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetReadmeResponse is a response for GetReadme

https://developer.github.com/v3/repos/contents/#get-a-repository-readme
*/
type GetReadmeResponse struct {
	common.Response
	request *GetReadmeReq
	Data    components.ContentFile
}

/*
GetRelease performs requests for "repos/get-release"

Get a release.

  GET /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#get-a-release
*/
func GetRelease(ctx context.Context, req *GetReleaseReq, opt ...options.Option) (*GetReleaseResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetReleaseReq)
	}
	resp := &GetReleaseResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Release{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetRelease performs requests for "repos/get-release"

Get a release.

  GET /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#get-a-release
*/
func (c Client) GetRelease(ctx context.Context, req *GetReleaseReq, opt ...options.Option) (*GetReleaseResponse, error) {
	return GetRelease(ctx, req, append(c, opt...)...)
}

/*
GetReleaseReq is request data for Client.GetRelease

https://developer.github.com/v3/repos/releases/#get-a-release
*/
type GetReleaseReq struct {
	_url  string
	Owner string
	Repo  string

	// release_id parameter
	ReleaseId int64
}

// HTTPRequest builds an *http.Request
func (r *GetReleaseReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetReleaseReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-release",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReleaseReq) Rel(link string, resp *GetReleaseResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetReleaseResponse is a response for GetRelease

https://developer.github.com/v3/repos/releases/#get-a-release
*/
type GetReleaseResponse struct {
	common.Response
	request *GetReleaseReq
	Data    components.Release
}

/*
GetReleaseAsset performs requests for "repos/get-release-asset"

Get a release asset.

  GET /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#get-a-release-asset
*/
func GetReleaseAsset(ctx context.Context, req *GetReleaseAssetReq, opt ...options.Option) (*GetReleaseAssetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetReleaseAssetReq)
	}
	resp := &GetReleaseAssetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ReleaseAsset{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetReleaseAsset performs requests for "repos/get-release-asset"

Get a release asset.

  GET /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#get-a-release-asset
*/
func (c Client) GetReleaseAsset(ctx context.Context, req *GetReleaseAssetReq, opt ...options.Option) (*GetReleaseAssetResponse, error) {
	return GetReleaseAsset(ctx, req, append(c, opt...)...)
}

/*
GetReleaseAssetReq is request data for Client.GetReleaseAsset

https://developer.github.com/v3/repos/releases/#get-a-release-asset
*/
type GetReleaseAssetReq struct {
	_url  string
	Owner string
	Repo  string

	// asset_id parameter
	AssetId int64
}

// HTTPRequest builds an *http.Request
func (r *GetReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetReleaseAssetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-release-asset",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReleaseAssetReq) Rel(link string, resp *GetReleaseAssetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetReleaseAssetResponse is a response for GetReleaseAsset

https://developer.github.com/v3/repos/releases/#get-a-release-asset
*/
type GetReleaseAssetResponse struct {
	common.Response
	request *GetReleaseAssetReq
	Data    components.ReleaseAsset
}

/*
GetReleaseByTag performs requests for "repos/get-release-by-tag"

Get a release by tag name.

  GET /repos/{owner}/{repo}/releases/tags/{tag}

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
func GetReleaseByTag(ctx context.Context, req *GetReleaseByTagReq, opt ...options.Option) (*GetReleaseByTagResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetReleaseByTagReq)
	}
	resp := &GetReleaseByTagResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Release{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetReleaseByTag performs requests for "repos/get-release-by-tag"

Get a release by tag name.

  GET /repos/{owner}/{repo}/releases/tags/{tag}

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
func (c Client) GetReleaseByTag(ctx context.Context, req *GetReleaseByTagReq, opt ...options.Option) (*GetReleaseByTagResponse, error) {
	return GetReleaseByTag(ctx, req, append(c, opt...)...)
}

/*
GetReleaseByTagReq is request data for Client.GetReleaseByTag

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
type GetReleaseByTagReq struct {
	_url  string
	Owner string
	Repo  string

	// tag+ parameter
	Tag string
}

// HTTPRequest builds an *http.Request
func (r *GetReleaseByTagReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetReleaseByTagReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-release-by-tag",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/tags/%v", r.Owner, r.Repo, r.Tag),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReleaseByTagReq) Rel(link string, resp *GetReleaseByTagResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetReleaseByTagResponse is a response for GetReleaseByTag

https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
*/
type GetReleaseByTagResponse struct {
	common.Response
	request *GetReleaseByTagReq
	Data    components.Release
}

/*
GetStatusChecksProtection performs requests for "repos/get-status-checks-protection"

Get status checks protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#get-status-checks-protection
*/
func GetStatusChecksProtection(ctx context.Context, req *GetStatusChecksProtectionReq, opt ...options.Option) (*GetStatusChecksProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetStatusChecksProtectionReq)
	}
	resp := &GetStatusChecksProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.StatusCheckPolicy{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetStatusChecksProtection performs requests for "repos/get-status-checks-protection"

Get status checks protection.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#get-status-checks-protection
*/
func (c Client) GetStatusChecksProtection(ctx context.Context, req *GetStatusChecksProtectionReq, opt ...options.Option) (*GetStatusChecksProtectionResponse, error) {
	return GetStatusChecksProtection(ctx, req, append(c, opt...)...)
}

/*
GetStatusChecksProtectionReq is request data for Client.GetStatusChecksProtection

https://developer.github.com/v3/repos/branches/#get-status-checks-protection
*/
type GetStatusChecksProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *GetStatusChecksProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetStatusChecksProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-status-checks-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetStatusChecksProtectionReq) Rel(link string, resp *GetStatusChecksProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetStatusChecksProtectionResponse is a response for GetStatusChecksProtection

https://developer.github.com/v3/repos/branches/#get-status-checks-protection
*/
type GetStatusChecksProtectionResponse struct {
	common.Response
	request *GetStatusChecksProtectionReq
	Data    components.StatusCheckPolicy
}

/*
GetTeamsWithAccessToProtectedBranch performs requests for "repos/get-teams-with-access-to-protected-branch"

Get teams with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-the-protected-branch
*/
func GetTeamsWithAccessToProtectedBranch(ctx context.Context, req *GetTeamsWithAccessToProtectedBranchReq, opt ...options.Option) (*GetTeamsWithAccessToProtectedBranchResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetTeamsWithAccessToProtectedBranchReq)
	}
	resp := &GetTeamsWithAccessToProtectedBranchResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetTeamsWithAccessToProtectedBranch performs requests for "repos/get-teams-with-access-to-protected-branch"

Get teams with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-the-protected-branch
*/
func (c Client) GetTeamsWithAccessToProtectedBranch(ctx context.Context, req *GetTeamsWithAccessToProtectedBranchReq, opt ...options.Option) (*GetTeamsWithAccessToProtectedBranchResponse, error) {
	return GetTeamsWithAccessToProtectedBranch(ctx, req, append(c, opt...)...)
}

/*
GetTeamsWithAccessToProtectedBranchReq is request data for Client.GetTeamsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-the-protected-branch
*/
type GetTeamsWithAccessToProtectedBranchReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *GetTeamsWithAccessToProtectedBranchReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetTeamsWithAccessToProtectedBranchReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-teams-with-access-to-protected-branch",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetTeamsWithAccessToProtectedBranchReq) Rel(link string, resp *GetTeamsWithAccessToProtectedBranchResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetTeamsWithAccessToProtectedBranchResponse is a response for GetTeamsWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-teams-with-access-to-the-protected-branch
*/
type GetTeamsWithAccessToProtectedBranchResponse struct {
	common.Response
	request *GetTeamsWithAccessToProtectedBranchReq
	Data    []components.Team
}

/*
GetTopPaths performs requests for "repos/get-top-paths"

Get top referral paths.

  GET /repos/{owner}/{repo}/traffic/popular/paths

https://developer.github.com/v3/repos/traffic/#get-top-referral-paths
*/
func GetTopPaths(ctx context.Context, req *GetTopPathsReq, opt ...options.Option) (*GetTopPathsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetTopPathsReq)
	}
	resp := &GetTopPathsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ContentTraffic{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetTopPaths performs requests for "repos/get-top-paths"

Get top referral paths.

  GET /repos/{owner}/{repo}/traffic/popular/paths

https://developer.github.com/v3/repos/traffic/#get-top-referral-paths
*/
func (c Client) GetTopPaths(ctx context.Context, req *GetTopPathsReq, opt ...options.Option) (*GetTopPathsResponse, error) {
	return GetTopPaths(ctx, req, append(c, opt...)...)
}

/*
GetTopPathsReq is request data for Client.GetTopPaths

https://developer.github.com/v3/repos/traffic/#get-top-referral-paths
*/
type GetTopPathsReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetTopPathsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetTopPathsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-top-paths",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/traffic/popular/paths", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetTopPathsReq) Rel(link string, resp *GetTopPathsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetTopPathsResponse is a response for GetTopPaths

https://developer.github.com/v3/repos/traffic/#get-top-referral-paths
*/
type GetTopPathsResponse struct {
	common.Response
	request *GetTopPathsReq
	Data    []components.ContentTraffic
}

/*
GetTopReferrers performs requests for "repos/get-top-referrers"

Get top referral sources.

  GET /repos/{owner}/{repo}/traffic/popular/referrers

https://developer.github.com/v3/repos/traffic/#get-top-referral-sources
*/
func GetTopReferrers(ctx context.Context, req *GetTopReferrersReq, opt ...options.Option) (*GetTopReferrersResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetTopReferrersReq)
	}
	resp := &GetTopReferrersResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ReferrerTraffic{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetTopReferrers performs requests for "repos/get-top-referrers"

Get top referral sources.

  GET /repos/{owner}/{repo}/traffic/popular/referrers

https://developer.github.com/v3/repos/traffic/#get-top-referral-sources
*/
func (c Client) GetTopReferrers(ctx context.Context, req *GetTopReferrersReq, opt ...options.Option) (*GetTopReferrersResponse, error) {
	return GetTopReferrers(ctx, req, append(c, opt...)...)
}

/*
GetTopReferrersReq is request data for Client.GetTopReferrers

https://developer.github.com/v3/repos/traffic/#get-top-referral-sources
*/
type GetTopReferrersReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetTopReferrersReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetTopReferrersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-top-referrers",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/traffic/popular/referrers", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetTopReferrersReq) Rel(link string, resp *GetTopReferrersResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetTopReferrersResponse is a response for GetTopReferrers

https://developer.github.com/v3/repos/traffic/#get-top-referral-sources
*/
type GetTopReferrersResponse struct {
	common.Response
	request *GetTopReferrersReq
	Data    []components.ReferrerTraffic
}

/*
GetUsersWithAccessToProtectedBranch performs requests for "repos/get-users-with-access-to-protected-branch"

Get users with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-the-protected-branch
*/
func GetUsersWithAccessToProtectedBranch(ctx context.Context, req *GetUsersWithAccessToProtectedBranchReq, opt ...options.Option) (*GetUsersWithAccessToProtectedBranchResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetUsersWithAccessToProtectedBranchReq)
	}
	resp := &GetUsersWithAccessToProtectedBranchResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetUsersWithAccessToProtectedBranch performs requests for "repos/get-users-with-access-to-protected-branch"

Get users with access to the protected branch.

  GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-the-protected-branch
*/
func (c Client) GetUsersWithAccessToProtectedBranch(ctx context.Context, req *GetUsersWithAccessToProtectedBranchReq, opt ...options.Option) (*GetUsersWithAccessToProtectedBranchResponse, error) {
	return GetUsersWithAccessToProtectedBranch(ctx, req, append(c, opt...)...)
}

/*
GetUsersWithAccessToProtectedBranchReq is request data for Client.GetUsersWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-the-protected-branch
*/
type GetUsersWithAccessToProtectedBranchReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *GetUsersWithAccessToProtectedBranchReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetUsersWithAccessToProtectedBranchReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-users-with-access-to-protected-branch",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetUsersWithAccessToProtectedBranchReq) Rel(link string, resp *GetUsersWithAccessToProtectedBranchResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetUsersWithAccessToProtectedBranchResponse is a response for GetUsersWithAccessToProtectedBranch

https://developer.github.com/v3/repos/branches/#list-users-with-access-to-the-protected-branch
*/
type GetUsersWithAccessToProtectedBranchResponse struct {
	common.Response
	request *GetUsersWithAccessToProtectedBranchReq
	Data    []components.SimpleUser
}

/*
GetViews performs requests for "repos/get-views"

Get page views.

  GET /repos/{owner}/{repo}/traffic/views

https://developer.github.com/v3/repos/traffic/#get-page-views
*/
func GetViews(ctx context.Context, req *GetViewsReq, opt ...options.Option) (*GetViewsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetViewsReq)
	}
	resp := &GetViewsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ViewTraffic{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetViews performs requests for "repos/get-views"

Get page views.

  GET /repos/{owner}/{repo}/traffic/views

https://developer.github.com/v3/repos/traffic/#get-page-views
*/
func (c Client) GetViews(ctx context.Context, req *GetViewsReq, opt ...options.Option) (*GetViewsResponse, error) {
	return GetViews(ctx, req, append(c, opt...)...)
}

/*
GetViewsReq is request data for Client.GetViews

https://developer.github.com/v3/repos/traffic/#get-page-views
*/
type GetViewsReq struct {
	_url  string
	Owner string
	Repo  string

	// Must be one of: `day`, `week`.
	Per *string
}

// HTTPRequest builds an *http.Request
func (r *GetViewsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetViewsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Per != nil {
		query.Set("per", *r.Per)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-views",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/traffic/views", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetViewsReq) Rel(link string, resp *GetViewsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetViewsResponse is a response for GetViews

https://developer.github.com/v3/repos/traffic/#get-page-views
*/
type GetViewsResponse struct {
	common.Response
	request *GetViewsReq
	Data    components.ViewTraffic
}

/*
GetWebhook performs requests for "repos/get-webhook"

Get a repository webhook.

  GET /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#get-a-repository-webhook
*/
func GetWebhook(ctx context.Context, req *GetWebhookReq, opt ...options.Option) (*GetWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetWebhookReq)
	}
	resp := &GetWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Hook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetWebhook performs requests for "repos/get-webhook"

Get a repository webhook.

  GET /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#get-a-repository-webhook
*/
func (c Client) GetWebhook(ctx context.Context, req *GetWebhookReq, opt ...options.Option) (*GetWebhookResponse, error) {
	return GetWebhook(ctx, req, append(c, opt...)...)
}

/*
GetWebhookReq is request data for Client.GetWebhook

https://developer.github.com/v3/repos/hooks/#get-a-repository-webhook
*/
type GetWebhookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *GetWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/get-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetWebhookReq) Rel(link string, resp *GetWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetWebhookResponse is a response for GetWebhook

https://developer.github.com/v3/repos/hooks/#get-a-repository-webhook
*/
type GetWebhookResponse struct {
	common.Response
	request *GetWebhookReq
	Data    components.Hook
}

/*
ListBranches performs requests for "repos/list-branches"

List branches.

  GET /repos/{owner}/{repo}/branches

https://developer.github.com/v3/repos/branches/#list-branches
*/
func ListBranches(ctx context.Context, req *ListBranchesReq, opt ...options.Option) (*ListBranchesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListBranchesReq)
	}
	resp := &ListBranchesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ShortBranch{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListBranches performs requests for "repos/list-branches"

List branches.

  GET /repos/{owner}/{repo}/branches

https://developer.github.com/v3/repos/branches/#list-branches
*/
func (c Client) ListBranches(ctx context.Context, req *ListBranchesReq, opt ...options.Option) (*ListBranchesResponse, error) {
	return ListBranches(ctx, req, append(c, opt...)...)
}

/*
ListBranchesReq is request data for Client.ListBranches

https://developer.github.com/v3/repos/branches/#list-branches
*/
type ListBranchesReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Setting to `true` returns only protected branches. When set to `false`, only
	unprotected branches are returned. Omitting this parameter returns all branches.
	*/
	Protected *bool

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListBranchesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListBranchesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Protected != nil {
		query.Set("protected", strconv.FormatBool(*r.Protected))
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-branches",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListBranchesReq) Rel(link string, resp *ListBranchesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListBranchesResponse is a response for ListBranches

https://developer.github.com/v3/repos/branches/#list-branches
*/
type ListBranchesResponse struct {
	common.Response
	request *ListBranchesReq
	Data    []components.ShortBranch
}

/*
ListBranchesForHeadCommit performs requests for "repos/list-branches-for-head-commit"

List branches for HEAD commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
func ListBranchesForHeadCommit(ctx context.Context, req *ListBranchesForHeadCommitReq, opt ...options.Option) (*ListBranchesForHeadCommitResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListBranchesForHeadCommitReq)
	}
	resp := &ListBranchesForHeadCommitResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.BranchShort{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListBranchesForHeadCommit performs requests for "repos/list-branches-for-head-commit"

List branches for HEAD commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
func (c Client) ListBranchesForHeadCommit(ctx context.Context, req *ListBranchesForHeadCommitReq, opt ...options.Option) (*ListBranchesForHeadCommitResponse, error) {
	return ListBranchesForHeadCommit(ctx, req, append(c, opt...)...)
}

/*
ListBranchesForHeadCommitReq is request data for Client.ListBranchesForHeadCommit

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
type ListBranchesForHeadCommitReq struct {
	_url  string
	Owner string
	Repo  string

	// commit_sha+ parameter
	CommitSha string

	/*
	Listing branches or pull requests for a commit in the Commits API is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-04-11-pulls-branches-for-commit/)
	for more details. To access the new endpoints during the preview period, you
	must set this to true.
	*/
	GrootPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListBranchesForHeadCommitReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListBranchesForHeadCommitReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"groot"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-branches-for-head-commit",
		Previews:         map[string]bool{"groot": r.GrootPreview},
		RequiredPreviews: []string{"groot"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/branches-where-head", r.Owner, r.Repo, r.CommitSha),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListBranchesForHeadCommitReq) Rel(link string, resp *ListBranchesForHeadCommitResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListBranchesForHeadCommitResponse is a response for ListBranchesForHeadCommit

https://developer.github.com/v3/repos/commits/#list-branches-for-head-commit
*/
type ListBranchesForHeadCommitResponse struct {
	common.Response
	request *ListBranchesForHeadCommitReq
	Data    []components.BranchShort
}

/*
ListCollaborators performs requests for "repos/list-collaborators"

List repository collaborators.

  GET /repos/{owner}/{repo}/collaborators

https://developer.github.com/v3/repos/collaborators/#list-repository-collaborators
*/
func ListCollaborators(ctx context.Context, req *ListCollaboratorsReq, opt ...options.Option) (*ListCollaboratorsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListCollaboratorsReq)
	}
	resp := &ListCollaboratorsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Collaborator{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListCollaborators performs requests for "repos/list-collaborators"

List repository collaborators.

  GET /repos/{owner}/{repo}/collaborators

https://developer.github.com/v3/repos/collaborators/#list-repository-collaborators
*/
func (c Client) ListCollaborators(ctx context.Context, req *ListCollaboratorsReq, opt ...options.Option) (*ListCollaboratorsResponse, error) {
	return ListCollaborators(ctx, req, append(c, opt...)...)
}

/*
ListCollaboratorsReq is request data for Client.ListCollaborators

https://developer.github.com/v3/repos/collaborators/#list-repository-collaborators
*/
type ListCollaboratorsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Filter collaborators returned by their affiliation. Can be one of:
	\* `outside`: All outside collaborators of an organization-owned repository.
	\* `direct`: All collaborators with permissions to an organization-owned
	repository, regardless of organization membership status.
	\* `all`: All collaborators the authenticated user can see.
	*/
	Affiliation *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListCollaboratorsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListCollaboratorsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-collaborators",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/collaborators", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCollaboratorsReq) Rel(link string, resp *ListCollaboratorsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCollaboratorsResponse is a response for ListCollaborators

https://developer.github.com/v3/repos/collaborators/#list-repository-collaborators
*/
type ListCollaboratorsResponse struct {
	common.Response
	request *ListCollaboratorsReq
	Data    []components.Collaborator
}

/*
ListCommentsForCommit performs requests for "repos/list-comments-for-commit"

List commit comments.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments
*/
func ListCommentsForCommit(ctx context.Context, req *ListCommentsForCommitReq, opt ...options.Option) (*ListCommentsForCommitResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListCommentsForCommitReq)
	}
	resp := &ListCommentsForCommitResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CommitComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListCommentsForCommit performs requests for "repos/list-comments-for-commit"

List commit comments.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments
*/
func (c Client) ListCommentsForCommit(ctx context.Context, req *ListCommentsForCommitReq, opt ...options.Option) (*ListCommentsForCommitResponse, error) {
	return ListCommentsForCommit(ctx, req, append(c, opt...)...)
}

/*
ListCommentsForCommitReq is request data for Client.ListCommentsForCommit

https://developer.github.com/v3/repos/comments/#list-commit-comments
*/
type ListCommentsForCommitReq struct {
	_url  string
	Owner string
	Repo  string

	// commit_sha+ parameter
	CommitSha string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListCommentsForCommitReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListCommentsForCommitReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-comments-for-commit",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/comments", r.Owner, r.Repo, r.CommitSha),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommentsForCommitReq) Rel(link string, resp *ListCommentsForCommitResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommentsForCommitResponse is a response for ListCommentsForCommit

https://developer.github.com/v3/repos/comments/#list-commit-comments
*/
type ListCommentsForCommitResponse struct {
	common.Response
	request *ListCommentsForCommitReq
	Data    []components.CommitComment
}

/*
ListCommitCommentsForRepo performs requests for "repos/list-commit-comments-for-repo"

List commit comments for a repository.

  GET /repos/{owner}/{repo}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
func ListCommitCommentsForRepo(ctx context.Context, req *ListCommitCommentsForRepoReq, opt ...options.Option) (*ListCommitCommentsForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListCommitCommentsForRepoReq)
	}
	resp := &ListCommitCommentsForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CommitComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListCommitCommentsForRepo performs requests for "repos/list-commit-comments-for-repo"

List commit comments for a repository.

  GET /repos/{owner}/{repo}/comments

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
func (c Client) ListCommitCommentsForRepo(ctx context.Context, req *ListCommitCommentsForRepoReq, opt ...options.Option) (*ListCommitCommentsForRepoResponse, error) {
	return ListCommitCommentsForRepo(ctx, req, append(c, opt...)...)
}

/*
ListCommitCommentsForRepoReq is request data for Client.ListCommitCommentsForRepo

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
type ListCommitCommentsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListCommitCommentsForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListCommitCommentsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-commit-comments-for-repo",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/comments", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommitCommentsForRepoReq) Rel(link string, resp *ListCommitCommentsForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommitCommentsForRepoResponse is a response for ListCommitCommentsForRepo

https://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
*/
type ListCommitCommentsForRepoResponse struct {
	common.Response
	request *ListCommitCommentsForRepoReq
	Data    []components.CommitComment
}

/*
ListCommitStatusesForRef performs requests for "repos/list-commit-statuses-for-ref"

List commit statuses for a reference.

  GET /repos/{owner}/{repo}/commits/{ref}/statuses

https://developer.github.com/v3/repos/statuses/#list-commit-statuses-for-a-reference
*/
func ListCommitStatusesForRef(ctx context.Context, req *ListCommitStatusesForRefReq, opt ...options.Option) (*ListCommitStatusesForRefResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListCommitStatusesForRefReq)
	}
	resp := &ListCommitStatusesForRefResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Status{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListCommitStatusesForRef performs requests for "repos/list-commit-statuses-for-ref"

List commit statuses for a reference.

  GET /repos/{owner}/{repo}/commits/{ref}/statuses

https://developer.github.com/v3/repos/statuses/#list-commit-statuses-for-a-reference
*/
func (c Client) ListCommitStatusesForRef(ctx context.Context, req *ListCommitStatusesForRefReq, opt ...options.Option) (*ListCommitStatusesForRefResponse, error) {
	return ListCommitStatusesForRef(ctx, req, append(c, opt...)...)
}

/*
ListCommitStatusesForRefReq is request data for Client.ListCommitStatusesForRef

https://developer.github.com/v3/repos/statuses/#list-commit-statuses-for-a-reference
*/
type ListCommitStatusesForRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListCommitStatusesForRefReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListCommitStatusesForRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-commit-statuses-for-ref",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/statuses", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{200, 301},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommitStatusesForRefReq) Rel(link string, resp *ListCommitStatusesForRefResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommitStatusesForRefResponse is a response for ListCommitStatusesForRef

https://developer.github.com/v3/repos/statuses/#list-commit-statuses-for-a-reference
*/
type ListCommitStatusesForRefResponse struct {
	common.Response
	request *ListCommitStatusesForRefReq
	Data    []components.Status
}

/*
ListCommits performs requests for "repos/list-commits"

List commits.

  GET /repos/{owner}/{repo}/commits

https://developer.github.com/v3/repos/commits/#list-commits
*/
func ListCommits(ctx context.Context, req *ListCommitsReq, opt ...options.Option) (*ListCommitsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListCommitsReq)
	}
	resp := &ListCommitsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleCommit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListCommits performs requests for "repos/list-commits"

List commits.

  GET /repos/{owner}/{repo}/commits

https://developer.github.com/v3/repos/commits/#list-commits
*/
func (c Client) ListCommits(ctx context.Context, req *ListCommitsReq, opt ...options.Option) (*ListCommitsResponse, error) {
	return ListCommits(ctx, req, append(c, opt...)...)
}

/*
ListCommitsReq is request data for Client.ListCommits

https://developer.github.com/v3/repos/commits/#list-commits
*/
type ListCommitsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	SHA or branch to start listing commits from. Default: the repository’s default
	branch (usually `master`).
	*/
	Sha *string

	// Only commits containing this file path will be returned.
	Path *string

	// GitHub login or email address by which to filter by commit author.
	Author *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only commits before this date will be returned. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Until *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListCommitsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListCommitsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sha != nil {
		query.Set("sha", *r.Sha)
	}
	if r.Path != nil {
		query.Set("path", *r.Path)
	}
	if r.Author != nil {
		query.Set("author", *r.Author)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Until != nil {
		query.Set("until", *r.Until)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-commits",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommitsReq) Rel(link string, resp *ListCommitsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommitsResponse is a response for ListCommits

https://developer.github.com/v3/repos/commits/#list-commits
*/
type ListCommitsResponse struct {
	common.Response
	request *ListCommitsReq
	Data    []components.SimpleCommit
}

/*
ListContributors performs requests for "repos/list-contributors"

List repository contributors.

  GET /repos/{owner}/{repo}/contributors

https://developer.github.com/v3/repos/#list-repository-contributors
*/
func ListContributors(ctx context.Context, req *ListContributorsReq, opt ...options.Option) (*ListContributorsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListContributorsReq)
	}
	resp := &ListContributorsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Contributor{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListContributors performs requests for "repos/list-contributors"

List repository contributors.

  GET /repos/{owner}/{repo}/contributors

https://developer.github.com/v3/repos/#list-repository-contributors
*/
func (c Client) ListContributors(ctx context.Context, req *ListContributorsReq, opt ...options.Option) (*ListContributorsResponse, error) {
	return ListContributors(ctx, req, append(c, opt...)...)
}

/*
ListContributorsReq is request data for Client.ListContributors

https://developer.github.com/v3/repos/#list-repository-contributors
*/
type ListContributorsReq struct {
	_url  string
	Owner string
	Repo  string

	// Set to `1` or `true` to include anonymous contributors in results.
	Anon *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListContributorsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListContributorsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Anon != nil {
		query.Set("anon", *r.Anon)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-contributors",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/contributors", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListContributorsReq) Rel(link string, resp *ListContributorsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListContributorsResponse is a response for ListContributors

https://developer.github.com/v3/repos/#list-repository-contributors
*/
type ListContributorsResponse struct {
	common.Response
	request *ListContributorsReq
	Data    []components.Contributor
}

/*
ListDeployKeys performs requests for "repos/list-deploy-keys"

List deploy keys.

  GET /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
func ListDeployKeys(ctx context.Context, req *ListDeployKeysReq, opt ...options.Option) (*ListDeployKeysResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListDeployKeysReq)
	}
	resp := &ListDeployKeysResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.DeployKey{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListDeployKeys performs requests for "repos/list-deploy-keys"

List deploy keys.

  GET /repos/{owner}/{repo}/keys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
func (c Client) ListDeployKeys(ctx context.Context, req *ListDeployKeysReq, opt ...options.Option) (*ListDeployKeysResponse, error) {
	return ListDeployKeys(ctx, req, append(c, opt...)...)
}

/*
ListDeployKeysReq is request data for Client.ListDeployKeys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
type ListDeployKeysReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListDeployKeysReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListDeployKeysReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-deploy-keys",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/keys", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListDeployKeysReq) Rel(link string, resp *ListDeployKeysResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListDeployKeysResponse is a response for ListDeployKeys

https://developer.github.com/v3/repos/keys/#list-deploy-keys
*/
type ListDeployKeysResponse struct {
	common.Response
	request *ListDeployKeysReq
	Data    []components.DeployKey
}

/*
ListDeploymentStatuses performs requests for "repos/list-deployment-statuses"

List deployment statuses.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
func ListDeploymentStatuses(ctx context.Context, req *ListDeploymentStatusesReq, opt ...options.Option) (*ListDeploymentStatusesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListDeploymentStatusesReq)
	}
	resp := &ListDeploymentStatusesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.DeploymentStatus{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListDeploymentStatuses performs requests for "repos/list-deployment-statuses"

List deployment statuses.

  GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
func (c Client) ListDeploymentStatuses(ctx context.Context, req *ListDeploymentStatusesReq, opt ...options.Option) (*ListDeploymentStatusesResponse, error) {
	return ListDeploymentStatuses(ctx, req, append(c, opt...)...)
}

/*
ListDeploymentStatusesReq is request data for Client.ListDeploymentStatuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
type ListDeploymentStatusesReq struct {
	_url  string
	Owner string
	Repo  string

	// deployment_id parameter
	DeploymentId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	New features in the Deployments API on GitHub are currently available during a
	public beta. Please see the [blog
	post](https://developer.github.com/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/)
	for full details.

	To access the new `environment` parameter, the two new values for the `state`
	parameter (`in_progress` and `queued`), and use `auto_inactive` on production
	deployments during the public beta period, you must set this to true.
	*/
	FlashPreview bool

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListDeploymentStatusesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListDeploymentStatusesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"flash", "ant-man"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": internal.String("application/json")},
		Method:       "GET",
		OperationID:  "repos/list-deployment-statuses",
		Previews: map[string]bool{
			"ant-man": r.AntManPreview,
			"flash":   r.FlashPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments/%v/statuses", r.Owner, r.Repo, r.DeploymentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListDeploymentStatusesReq) Rel(link string, resp *ListDeploymentStatusesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListDeploymentStatusesResponse is a response for ListDeploymentStatuses

https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
*/
type ListDeploymentStatusesResponse struct {
	common.Response
	request *ListDeploymentStatusesReq
	Data    []components.DeploymentStatus
}

/*
ListDeployments performs requests for "repos/list-deployments"

List deployments.

  GET /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
func ListDeployments(ctx context.Context, req *ListDeploymentsReq, opt ...options.Option) (*ListDeploymentsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListDeploymentsReq)
	}
	resp := &ListDeploymentsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Deployment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListDeployments performs requests for "repos/list-deployments"

List deployments.

  GET /repos/{owner}/{repo}/deployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
func (c Client) ListDeployments(ctx context.Context, req *ListDeploymentsReq, opt ...options.Option) (*ListDeploymentsResponse, error) {
	return ListDeployments(ctx, req, append(c, opt...)...)
}

/*
ListDeploymentsReq is request data for Client.ListDeployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
type ListDeploymentsReq struct {
	_url  string
	Owner string
	Repo  string

	// The SHA recorded at creation time.
	Sha *string

	// The name of the ref. This can be a branch, tag, or SHA.
	Ref *string

	// The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).
	Task *string

	/*
	The name of the environment that was deployed to (e.g., `staging` or
	`production`).
	*/
	Environment *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive`
	parameters are currently available for developers to preview. Please see the
	[blog
	post](https://developer.github.com/changes/2016-04-06-deployment-and-deployment-status-enhancements)
	for full details.

	To access the API during the preview period, you must set this to true.
	*/
	AntManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListDeploymentsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListDeploymentsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sha != nil {
		query.Set("sha", *r.Sha)
	}
	if r.Ref != nil {
		query.Set("ref", *r.Ref)
	}
	if r.Task != nil {
		query.Set("task", *r.Task)
	}
	if r.Environment != nil {
		query.Set("environment", *r.Environment)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"ant-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-deployments",
		Previews:         map[string]bool{"ant-man": r.AntManPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/deployments", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListDeploymentsReq) Rel(link string, resp *ListDeploymentsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListDeploymentsResponse is a response for ListDeployments

https://developer.github.com/v3/repos/deployments/#list-deployments
*/
type ListDeploymentsResponse struct {
	common.Response
	request *ListDeploymentsReq
	Data    []components.Deployment
}

/*
ListForAuthenticatedUser performs requests for "repos/list-for-authenticated-user"

List repositories for the authenticated user.

  GET /user/repos

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
func ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...options.Option) (*ListForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForAuthenticatedUserReq)
	}
	resp := &ListForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Repository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForAuthenticatedUser performs requests for "repos/list-for-authenticated-user"

List repositories for the authenticated user.

  GET /user/repos

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
func (c Client) ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...options.Option) (*ListForAuthenticatedUserResponse, error) {
	return ListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListForAuthenticatedUserReq is request data for Client.ListForAuthenticatedUser

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
type ListForAuthenticatedUserReq struct {
	_url string

	// Can be one of `all`, `public`, or `private`.
	Visibility *string

	/*
	Comma-separated list of values. Can include:
	\* `owner`: Repositories that are owned by the authenticated user.
	\* `collaborator`: Repositories that the user has been added to as a
	collaborator.
	\* `organization_member`: Repositories that the user has access to through being
	a member of an organization. This includes every repository on every team that
	the user is on.
	*/
	Affiliation *string

	/*
	Can be one of `all`, `owner`, `public`, `private`, `member`. Default: `all`

	Will cause a `422` error if used in the same request as **visibility** or
	**affiliation**. Will cause a `422` error if used in the same request as
	**visibility** or **affiliation**.
	*/
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only show notifications updated before the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Before *string
}

// HTTPRequest builds an *http.Request
func (r *ListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Visibility != nil {
		query.Set("visibility", *r.Visibility)
	}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Before != nil {
		query.Set("before", *r.Before)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/repos"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForAuthenticatedUserReq) Rel(link string, resp *ListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForAuthenticatedUserResponse is a response for ListForAuthenticatedUser

https://developer.github.com/v3/repos/#list-repositories-for-the-authenticated-user
*/
type ListForAuthenticatedUserResponse struct {
	common.Response
	request *ListForAuthenticatedUserReq
	Data    []components.Repository
}

/*
ListForOrg performs requests for "repos/list-for-org"

List organization repositories.

  GET /orgs/{org}/repos

https://developer.github.com/v3/repos/#list-organization-repositories
*/
func ListForOrg(ctx context.Context, req *ListForOrgReq, opt ...options.Option) (*ListForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForOrgReq)
	}
	resp := &ListForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForOrg performs requests for "repos/list-for-org"

List organization repositories.

  GET /orgs/{org}/repos

https://developer.github.com/v3/repos/#list-organization-repositories
*/
func (c Client) ListForOrg(ctx context.Context, req *ListForOrgReq, opt ...options.Option) (*ListForOrgResponse, error) {
	return ListForOrg(ctx, req, append(c, opt...)...)
}

/*
ListForOrgReq is request data for Client.ListForOrg

https://developer.github.com/v3/repos/#list-organization-repositories
*/
type ListForOrgReq struct {
	_url string
	Org  string

	/*
	Specifies the types of repositories you want returned. Can be one of `all`,
	`public`, `private`, `forks`, `sources`, `member`, `internal`. Default: `all`.
	If your organization is associated with an enterprise account using GitHub
	Enterprise Cloud or GitHub Enterprise Server 2.20+, `type` can also be
	`internal`.
	*/
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: when using `full_name`: `asc`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"nebula", "baptiste"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": internal.String("application/json")},
		Method:       "GET",
		OperationID:  "repos/list-for-org",
		Previews: map[string]bool{
			"baptiste": r.BaptistePreview,
			"nebula":   r.NebulaPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/repos", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForOrgReq) Rel(link string, resp *ListForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForOrgResponse is a response for ListForOrg

https://developer.github.com/v3/repos/#list-organization-repositories
*/
type ListForOrgResponse struct {
	common.Response
	request *ListForOrgReq
	Data    []components.MinimalRepository
}

/*
ListForUser performs requests for "repos/list-for-user"

List repositories for a user.

  GET /users/{username}/repos

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
func ListForUser(ctx context.Context, req *ListForUserReq, opt ...options.Option) (*ListForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForUserReq)
	}
	resp := &ListForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForUser performs requests for "repos/list-for-user"

List repositories for a user.

  GET /users/{username}/repos

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
func (c Client) ListForUser(ctx context.Context, req *ListForUserReq, opt ...options.Option) (*ListForUserResponse, error) {
	return ListForUser(ctx, req, append(c, opt...)...)
}

/*
ListForUserReq is request data for Client.ListForUser

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
type ListForUserReq struct {
	_url     string
	Username string

	// Can be one of `all`, `owner`, `member`.
	Type *string

	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort *string

	/*
	Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise
	`desc`
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Type != nil {
		query.Set("type", *r.Type)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"nebula"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-for-user",
		Previews:         map[string]bool{"nebula": r.NebulaPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/repos", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForUserReq) Rel(link string, resp *ListForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForUserResponse is a response for ListForUser

https://developer.github.com/v3/repos/#list-repositories-for-a-user
*/
type ListForUserResponse struct {
	common.Response
	request *ListForUserReq
	Data    []components.MinimalRepository
}

/*
ListForks performs requests for "repos/list-forks"

List forks.

  GET /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#list-forks
*/
func ListForks(ctx context.Context, req *ListForksReq, opt ...options.Option) (*ListForksResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForksReq)
	}
	resp := &ListForksResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForks performs requests for "repos/list-forks"

List forks.

  GET /repos/{owner}/{repo}/forks

https://developer.github.com/v3/repos/forks/#list-forks
*/
func (c Client) ListForks(ctx context.Context, req *ListForksReq, opt ...options.Option) (*ListForksResponse, error) {
	return ListForks(ctx, req, append(c, opt...)...)
}

/*
ListForksReq is request data for Client.ListForks

https://developer.github.com/v3/repos/forks/#list-forks
*/
type ListForksReq struct {
	_url  string
	Owner string
	Repo  string

	// The sort order. Can be either `newest`, `oldest`, or `stargazers`.
	Sort *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListForksReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForksReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-forks",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/forks", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForksReq) Rel(link string, resp *ListForksResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForksResponse is a response for ListForks

https://developer.github.com/v3/repos/forks/#list-forks
*/
type ListForksResponse struct {
	common.Response
	request *ListForksReq
	Data    []components.MinimalRepository
}

/*
ListInvitations performs requests for "repos/list-invitations"

List repository invitations.

  GET /repos/{owner}/{repo}/invitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations
*/
func ListInvitations(ctx context.Context, req *ListInvitationsReq, opt ...options.Option) (*ListInvitationsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListInvitationsReq)
	}
	resp := &ListInvitationsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.RepositoryInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListInvitations performs requests for "repos/list-invitations"

List repository invitations.

  GET /repos/{owner}/{repo}/invitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations
*/
func (c Client) ListInvitations(ctx context.Context, req *ListInvitationsReq, opt ...options.Option) (*ListInvitationsResponse, error) {
	return ListInvitations(ctx, req, append(c, opt...)...)
}

/*
ListInvitationsReq is request data for Client.ListInvitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations
*/
type ListInvitationsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListInvitationsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListInvitationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-invitations",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/invitations", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInvitationsReq) Rel(link string, resp *ListInvitationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInvitationsResponse is a response for ListInvitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations
*/
type ListInvitationsResponse struct {
	common.Response
	request *ListInvitationsReq
	Data    []components.RepositoryInvitation
}

/*
ListInvitationsForAuthenticatedUser performs requests for "repos/list-invitations-for-authenticated-user"

List repository invitations for the authenticated user.

  GET /user/repository_invitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations-for-the-authenticated-user
*/
func ListInvitationsForAuthenticatedUser(ctx context.Context, req *ListInvitationsForAuthenticatedUserReq, opt ...options.Option) (*ListInvitationsForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListInvitationsForAuthenticatedUserReq)
	}
	resp := &ListInvitationsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.RepositoryInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListInvitationsForAuthenticatedUser performs requests for "repos/list-invitations-for-authenticated-user"

List repository invitations for the authenticated user.

  GET /user/repository_invitations

https://developer.github.com/v3/repos/invitations/#list-repository-invitations-for-the-authenticated-user
*/
func (c Client) ListInvitationsForAuthenticatedUser(ctx context.Context, req *ListInvitationsForAuthenticatedUserReq, opt ...options.Option) (*ListInvitationsForAuthenticatedUserResponse, error) {
	return ListInvitationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListInvitationsForAuthenticatedUserReq is request data for Client.ListInvitationsForAuthenticatedUser

https://developer.github.com/v3/repos/invitations/#list-repository-invitations-for-the-authenticated-user
*/
type ListInvitationsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListInvitationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListInvitationsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-invitations-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/repository_invitations"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInvitationsForAuthenticatedUserReq) Rel(link string, resp *ListInvitationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInvitationsForAuthenticatedUserResponse is a response for ListInvitationsForAuthenticatedUser

https://developer.github.com/v3/repos/invitations/#list-repository-invitations-for-the-authenticated-user
*/
type ListInvitationsForAuthenticatedUserResponse struct {
	common.Response
	request *ListInvitationsForAuthenticatedUserReq
	Data    []components.RepositoryInvitation
}

/*
ListLanguages performs requests for "repos/list-languages"

List repository languages.

  GET /repos/{owner}/{repo}/languages

https://developer.github.com/v3/repos/#list-repository-languages
*/
func ListLanguages(ctx context.Context, req *ListLanguagesReq, opt ...options.Option) (*ListLanguagesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListLanguagesReq)
	}
	resp := &ListLanguagesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Language{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListLanguages performs requests for "repos/list-languages"

List repository languages.

  GET /repos/{owner}/{repo}/languages

https://developer.github.com/v3/repos/#list-repository-languages
*/
func (c Client) ListLanguages(ctx context.Context, req *ListLanguagesReq, opt ...options.Option) (*ListLanguagesResponse, error) {
	return ListLanguages(ctx, req, append(c, opt...)...)
}

/*
ListLanguagesReq is request data for Client.ListLanguages

https://developer.github.com/v3/repos/#list-repository-languages
*/
type ListLanguagesReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ListLanguagesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListLanguagesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-languages",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/languages", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListLanguagesReq) Rel(link string, resp *ListLanguagesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListLanguagesResponse is a response for ListLanguages

https://developer.github.com/v3/repos/#list-repository-languages
*/
type ListLanguagesResponse struct {
	common.Response
	request *ListLanguagesReq
	Data    components.Language
}

/*
ListPagesBuilds performs requests for "repos/list-pages-builds"

List GitHub Pages builds.

  GET /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#list-github-pages-builds
*/
func ListPagesBuilds(ctx context.Context, req *ListPagesBuildsReq, opt ...options.Option) (*ListPagesBuildsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPagesBuildsReq)
	}
	resp := &ListPagesBuildsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.PageBuild{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPagesBuilds performs requests for "repos/list-pages-builds"

List GitHub Pages builds.

  GET /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#list-github-pages-builds
*/
func (c Client) ListPagesBuilds(ctx context.Context, req *ListPagesBuildsReq, opt ...options.Option) (*ListPagesBuildsResponse, error) {
	return ListPagesBuilds(ctx, req, append(c, opt...)...)
}

/*
ListPagesBuildsReq is request data for Client.ListPagesBuilds

https://developer.github.com/v3/repos/pages/#list-github-pages-builds
*/
type ListPagesBuildsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPagesBuildsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPagesBuildsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-pages-builds",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages/builds", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPagesBuildsReq) Rel(link string, resp *ListPagesBuildsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPagesBuildsResponse is a response for ListPagesBuilds

https://developer.github.com/v3/repos/pages/#list-github-pages-builds
*/
type ListPagesBuildsResponse struct {
	common.Response
	request *ListPagesBuildsReq
	Data    []components.PageBuild
}

/*
ListPublic performs requests for "repos/list-public"

List public repositories.

  GET /repositories

https://developer.github.com/v3/repos/#list-public-repositories
*/
func ListPublic(ctx context.Context, req *ListPublicReq, opt ...options.Option) (*ListPublicResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicReq)
	}
	resp := &ListPublicResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublic performs requests for "repos/list-public"

List public repositories.

  GET /repositories

https://developer.github.com/v3/repos/#list-public-repositories
*/
func (c Client) ListPublic(ctx context.Context, req *ListPublicReq, opt ...options.Option) (*ListPublicResponse, error) {
	return ListPublic(ctx, req, append(c, opt...)...)
}

/*
ListPublicReq is request data for Client.ListPublic

https://developer.github.com/v3/repos/#list-public-repositories
*/
type ListPublicReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since      *string
	Visibility *string
}

// HTTPRequest builds an *http.Request
func (r *ListPublicReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Visibility != nil {
		query.Set("visibility", *r.Visibility)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-public",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repositories"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicReq) Rel(link string, resp *ListPublicResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicResponse is a response for ListPublic

https://developer.github.com/v3/repos/#list-public-repositories
*/
type ListPublicResponse struct {
	common.Response
	request *ListPublicReq
	Data    []components.MinimalRepository
}

/*
ListPullRequestsAssociatedWithCommit performs requests for "repos/list-pull-requests-associated-with-commit"

List pull requests associated with a commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-a-commit
*/
func ListPullRequestsAssociatedWithCommit(ctx context.Context, req *ListPullRequestsAssociatedWithCommitReq, opt ...options.Option) (*ListPullRequestsAssociatedWithCommitResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPullRequestsAssociatedWithCommitReq)
	}
	resp := &ListPullRequestsAssociatedWithCommitResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.PullRequestSimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPullRequestsAssociatedWithCommit performs requests for "repos/list-pull-requests-associated-with-commit"

List pull requests associated with a commit.

  GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-a-commit
*/
func (c Client) ListPullRequestsAssociatedWithCommit(ctx context.Context, req *ListPullRequestsAssociatedWithCommitReq, opt ...options.Option) (*ListPullRequestsAssociatedWithCommitResponse, error) {
	return ListPullRequestsAssociatedWithCommit(ctx, req, append(c, opt...)...)
}

/*
ListPullRequestsAssociatedWithCommitReq is request data for Client.ListPullRequestsAssociatedWithCommit

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-a-commit
*/
type ListPullRequestsAssociatedWithCommitReq struct {
	_url  string
	Owner string
	Repo  string

	// commit_sha+ parameter
	CommitSha string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Listing branches or pull requests for a commit in the Commits API is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2019-04-11-pulls-branches-for-commit/)
	for more details. To access the new endpoints during the preview period, you
	must set this to true.
	*/
	GrootPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListPullRequestsAssociatedWithCommitReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPullRequestsAssociatedWithCommitReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"groot"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-pull-requests-associated-with-commit",
		Previews:         map[string]bool{"groot": r.GrootPreview},
		RequiredPreviews: []string{"groot"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/commits/%v/pulls", r.Owner, r.Repo, r.CommitSha),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPullRequestsAssociatedWithCommitReq) Rel(link string, resp *ListPullRequestsAssociatedWithCommitResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPullRequestsAssociatedWithCommitResponse is a response for ListPullRequestsAssociatedWithCommit

https://developer.github.com/v3/repos/commits/#list-pull-requests-associated-with-a-commit
*/
type ListPullRequestsAssociatedWithCommitResponse struct {
	common.Response
	request *ListPullRequestsAssociatedWithCommitReq
	Data    []components.PullRequestSimple
}

/*
ListReleaseAssets performs requests for "repos/list-release-assets"

List release assets.

  GET /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#list-release-assets
*/
func ListReleaseAssets(ctx context.Context, req *ListReleaseAssetsReq, opt ...options.Option) (*ListReleaseAssetsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReleaseAssetsReq)
	}
	resp := &ListReleaseAssetsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ReleaseAsset{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReleaseAssets performs requests for "repos/list-release-assets"

List release assets.

  GET /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#list-release-assets
*/
func (c Client) ListReleaseAssets(ctx context.Context, req *ListReleaseAssetsReq, opt ...options.Option) (*ListReleaseAssetsResponse, error) {
	return ListReleaseAssets(ctx, req, append(c, opt...)...)
}

/*
ListReleaseAssetsReq is request data for Client.ListReleaseAssets

https://developer.github.com/v3/repos/releases/#list-release-assets
*/
type ListReleaseAssetsReq struct {
	_url  string
	Owner string
	Repo  string

	// release_id parameter
	ReleaseId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReleaseAssetsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReleaseAssetsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-release-assets",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/%v/assets", r.Owner, r.Repo, r.ReleaseId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReleaseAssetsReq) Rel(link string, resp *ListReleaseAssetsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReleaseAssetsResponse is a response for ListReleaseAssets

https://developer.github.com/v3/repos/releases/#list-release-assets
*/
type ListReleaseAssetsResponse struct {
	common.Response
	request *ListReleaseAssetsReq
	Data    []components.ReleaseAsset
}

/*
ListReleases performs requests for "repos/list-releases"

List releases.

  GET /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#list-releases
*/
func ListReleases(ctx context.Context, req *ListReleasesReq, opt ...options.Option) (*ListReleasesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReleasesReq)
	}
	resp := &ListReleasesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Release{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReleases performs requests for "repos/list-releases"

List releases.

  GET /repos/{owner}/{repo}/releases

https://developer.github.com/v3/repos/releases/#list-releases
*/
func (c Client) ListReleases(ctx context.Context, req *ListReleasesReq, opt ...options.Option) (*ListReleasesResponse, error) {
	return ListReleases(ctx, req, append(c, opt...)...)
}

/*
ListReleasesReq is request data for Client.ListReleases

https://developer.github.com/v3/repos/releases/#list-releases
*/
type ListReleasesReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReleasesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReleasesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-releases",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReleasesReq) Rel(link string, resp *ListReleasesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReleasesResponse is a response for ListReleases

https://developer.github.com/v3/repos/releases/#list-releases
*/
type ListReleasesResponse struct {
	common.Response
	request *ListReleasesReq
	Data    []components.Release
}

/*
ListTags performs requests for "repos/list-tags"

List repository tags.

  GET /repos/{owner}/{repo}/tags

https://developer.github.com/v3/repos/#list-repository-tags
*/
func ListTags(ctx context.Context, req *ListTagsReq, opt ...options.Option) (*ListTagsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListTagsReq)
	}
	resp := &ListTagsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Tag{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListTags performs requests for "repos/list-tags"

List repository tags.

  GET /repos/{owner}/{repo}/tags

https://developer.github.com/v3/repos/#list-repository-tags
*/
func (c Client) ListTags(ctx context.Context, req *ListTagsReq, opt ...options.Option) (*ListTagsResponse, error) {
	return ListTags(ctx, req, append(c, opt...)...)
}

/*
ListTagsReq is request data for Client.ListTags

https://developer.github.com/v3/repos/#list-repository-tags
*/
type ListTagsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListTagsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListTagsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-tags",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/tags", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListTagsReq) Rel(link string, resp *ListTagsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListTagsResponse is a response for ListTags

https://developer.github.com/v3/repos/#list-repository-tags
*/
type ListTagsResponse struct {
	common.Response
	request *ListTagsReq
	Data    []components.Tag
}

/*
ListTeams performs requests for "repos/list-teams"

List repository teams.

  GET /repos/{owner}/{repo}/teams

https://developer.github.com/v3/repos/#list-repository-teams
*/
func ListTeams(ctx context.Context, req *ListTeamsReq, opt ...options.Option) (*ListTeamsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListTeamsReq)
	}
	resp := &ListTeamsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListTeams performs requests for "repos/list-teams"

List repository teams.

  GET /repos/{owner}/{repo}/teams

https://developer.github.com/v3/repos/#list-repository-teams
*/
func (c Client) ListTeams(ctx context.Context, req *ListTeamsReq, opt ...options.Option) (*ListTeamsResponse, error) {
	return ListTeams(ctx, req, append(c, opt...)...)
}

/*
ListTeamsReq is request data for Client.ListTeams

https://developer.github.com/v3/repos/#list-repository-teams
*/
type ListTeamsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListTeamsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListTeamsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-teams",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/teams", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListTeamsReq) Rel(link string, resp *ListTeamsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListTeamsResponse is a response for ListTeams

https://developer.github.com/v3/repos/#list-repository-teams
*/
type ListTeamsResponse struct {
	common.Response
	request *ListTeamsReq
	Data    []components.Team
}

/*
ListWebhooks performs requests for "repos/list-webhooks"

List repository webhooks.

  GET /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#list-repository-webhooks
*/
func ListWebhooks(ctx context.Context, req *ListWebhooksReq, opt ...options.Option) (*ListWebhooksResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListWebhooksReq)
	}
	resp := &ListWebhooksResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Hook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListWebhooks performs requests for "repos/list-webhooks"

List repository webhooks.

  GET /repos/{owner}/{repo}/hooks

https://developer.github.com/v3/repos/hooks/#list-repository-webhooks
*/
func (c Client) ListWebhooks(ctx context.Context, req *ListWebhooksReq, opt ...options.Option) (*ListWebhooksResponse, error) {
	return ListWebhooks(ctx, req, append(c, opt...)...)
}

/*
ListWebhooksReq is request data for Client.ListWebhooks

https://developer.github.com/v3/repos/hooks/#list-repository-webhooks
*/
type ListWebhooksReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListWebhooksReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListWebhooksReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "repos/list-webhooks",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListWebhooksReq) Rel(link string, resp *ListWebhooksResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListWebhooksResponse is a response for ListWebhooks

https://developer.github.com/v3/repos/hooks/#list-repository-webhooks
*/
type ListWebhooksResponse struct {
	common.Response
	request *ListWebhooksReq
	Data    []components.Hook
}

/*
Merge performs requests for "repos/merge"

Merge a branch.

  POST /repos/{owner}/{repo}/merges

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
func Merge(ctx context.Context, req *MergeReq, opt ...options.Option) (*MergeResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MergeReq)
	}
	resp := &MergeResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Commit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Merge performs requests for "repos/merge"

Merge a branch.

  POST /repos/{owner}/{repo}/merges

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
func (c Client) Merge(ctx context.Context, req *MergeReq, opt ...options.Option) (*MergeResponse, error) {
	return Merge(ctx, req, append(c, opt...)...)
}

/*
MergeReq is request data for Client.Merge

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
type MergeReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody MergeReqBody
}

// HTTPRequest builds an *http.Request
func (r *MergeReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MergeReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/merge",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/merges", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MergeReq) Rel(link string, resp *MergeResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MergeReqBody is a request body for repos/merge

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
type MergeReqBody struct {

	// The name of the base branch that the head will be merged into.
	Base *string `json:"base"`

	// Commit message to use for the merge commit. If omitted, a default message will be used.
	CommitMessage *string `json:"commit_message,omitempty"`

	// The head to merge. This can be a branch name or a commit SHA1.
	Head *string `json:"head"`
}

/*
MergeResponse is a response for Merge

https://developer.github.com/v3/repos/merging/#merge-a-branch
*/
type MergeResponse struct {
	common.Response
	request *MergeReq
	Data    components.Commit
}

/*
PingWebhook performs requests for "repos/ping-webhook"

Ping a repository webhook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/pings

https://developer.github.com/v3/repos/hooks/#ping-a-repository-webhook
*/
func PingWebhook(ctx context.Context, req *PingWebhookReq, opt ...options.Option) (*PingWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PingWebhookReq)
	}
	resp := &PingWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PingWebhook performs requests for "repos/ping-webhook"

Ping a repository webhook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/pings

https://developer.github.com/v3/repos/hooks/#ping-a-repository-webhook
*/
func (c Client) PingWebhook(ctx context.Context, req *PingWebhookReq, opt ...options.Option) (*PingWebhookResponse, error) {
	return PingWebhook(ctx, req, append(c, opt...)...)
}

/*
PingWebhookReq is request data for Client.PingWebhook

https://developer.github.com/v3/repos/hooks/#ping-a-repository-webhook
*/
type PingWebhookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *PingWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PingWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "POST",
		OperationID:      "repos/ping-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks/%v/pings", r.Owner, r.Repo, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PingWebhookReq) Rel(link string, resp *PingWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PingWebhookResponse is a response for PingWebhook

https://developer.github.com/v3/repos/hooks/#ping-a-repository-webhook
*/
type PingWebhookResponse struct {
	common.Response
	request *PingWebhookReq
	Data    bool
}

/*
RemoveAppAccessRestrictions performs requests for "repos/remove-app-access-restrictions"

Remove app access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
func RemoveAppAccessRestrictions(ctx context.Context, req *RemoveAppAccessRestrictionsReq, opt ...options.Option) (*RemoveAppAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveAppAccessRestrictionsReq)
	}
	resp := &RemoveAppAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Integration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveAppAccessRestrictions performs requests for "repos/remove-app-access-restrictions"

Remove app access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
func (c Client) RemoveAppAccessRestrictions(ctx context.Context, req *RemoveAppAccessRestrictionsReq, opt ...options.Option) (*RemoveAppAccessRestrictionsResponse, error) {
	return RemoveAppAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
RemoveAppAccessRestrictionsReq is request data for Client.RemoveAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
type RemoveAppAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody RemoveAppAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *RemoveAppAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveAppAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "DELETE",
		OperationID:      "repos/remove-app-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveAppAccessRestrictionsReq) Rel(link string, resp *RemoveAppAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveAppAccessRestrictionsReqBody is a request body for repos/remove-app-access-restrictions

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
type RemoveAppAccessRestrictionsReqBody []string

/*
RemoveAppAccessRestrictionsResponse is a response for RemoveAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-app-access-restrictions
*/
type RemoveAppAccessRestrictionsResponse struct {
	common.Response
	request *RemoveAppAccessRestrictionsReq
	Data    []components.Integration
}

/*
RemoveCollaborator performs requests for "repos/remove-collaborator"

Remove a repository collaborator.

  DELETE /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#remove-a-repository-collaborator
*/
func RemoveCollaborator(ctx context.Context, req *RemoveCollaboratorReq, opt ...options.Option) (*RemoveCollaboratorResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveCollaboratorReq)
	}
	resp := &RemoveCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveCollaborator performs requests for "repos/remove-collaborator"

Remove a repository collaborator.

  DELETE /repos/{owner}/{repo}/collaborators/{username}

https://developer.github.com/v3/repos/collaborators/#remove-a-repository-collaborator
*/
func (c Client) RemoveCollaborator(ctx context.Context, req *RemoveCollaboratorReq, opt ...options.Option) (*RemoveCollaboratorResponse, error) {
	return RemoveCollaborator(ctx, req, append(c, opt...)...)
}

/*
RemoveCollaboratorReq is request data for Client.RemoveCollaborator

https://developer.github.com/v3/repos/collaborators/#remove-a-repository-collaborator
*/
type RemoveCollaboratorReq struct {
	_url     string
	Owner    string
	Repo     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *RemoveCollaboratorReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/remove-collaborator",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/collaborators/%v", r.Owner, r.Repo, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveCollaboratorReq) Rel(link string, resp *RemoveCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveCollaboratorResponse is a response for RemoveCollaborator

https://developer.github.com/v3/repos/collaborators/#remove-a-repository-collaborator
*/
type RemoveCollaboratorResponse struct {
	common.Response
	request *RemoveCollaboratorReq
}

/*
RemoveStatusCheckContexts performs requests for "repos/remove-status-check-contexts"

Remove status check contexts.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
func RemoveStatusCheckContexts(ctx context.Context, req *RemoveStatusCheckContextsReq, opt ...options.Option) (*RemoveStatusCheckContextsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveStatusCheckContextsReq)
	}
	resp := &RemoveStatusCheckContextsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = RemoveStatusCheckContextsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveStatusCheckContexts performs requests for "repos/remove-status-check-contexts"

Remove status check contexts.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
func (c Client) RemoveStatusCheckContexts(ctx context.Context, req *RemoveStatusCheckContextsReq, opt ...options.Option) (*RemoveStatusCheckContextsResponse, error) {
	return RemoveStatusCheckContexts(ctx, req, append(c, opt...)...)
}

/*
RemoveStatusCheckContextsReq is request data for Client.RemoveStatusCheckContexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
type RemoveStatusCheckContextsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody RemoveStatusCheckContextsReqBody
}

// HTTPRequest builds an *http.Request
func (r *RemoveStatusCheckContextsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveStatusCheckContextsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "DELETE",
		OperationID:      "repos/remove-status-check-contexts",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveStatusCheckContextsReq) Rel(link string, resp *RemoveStatusCheckContextsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveStatusCheckContextsReqBody is a request body for repos/remove-status-check-contexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
type RemoveStatusCheckContextsReqBody []string

/*
RemoveStatusCheckContextsResponseBody is a response body for RemoveStatusCheckContexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
type RemoveStatusCheckContextsResponseBody []string

/*
RemoveStatusCheckContextsResponse is a response for RemoveStatusCheckContexts

https://developer.github.com/v3/repos/branches/#remove-status-check-contexts
*/
type RemoveStatusCheckContextsResponse struct {
	common.Response
	request *RemoveStatusCheckContextsReq
	Data    RemoveStatusCheckContextsResponseBody
}

/*
RemoveStatusCheckProtection performs requests for "repos/remove-status-check-protection"

Remove status check protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#remove-status-check-protection
*/
func RemoveStatusCheckProtection(ctx context.Context, req *RemoveStatusCheckProtectionReq, opt ...options.Option) (*RemoveStatusCheckProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveStatusCheckProtectionReq)
	}
	resp := &RemoveStatusCheckProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveStatusCheckProtection performs requests for "repos/remove-status-check-protection"

Remove status check protection.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#remove-status-check-protection
*/
func (c Client) RemoveStatusCheckProtection(ctx context.Context, req *RemoveStatusCheckProtectionReq, opt ...options.Option) (*RemoveStatusCheckProtectionResponse, error) {
	return RemoveStatusCheckProtection(ctx, req, append(c, opt...)...)
}

/*
RemoveStatusCheckProtectionReq is request data for Client.RemoveStatusCheckProtection

https://developer.github.com/v3/repos/branches/#remove-status-check-protection
*/
type RemoveStatusCheckProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *RemoveStatusCheckProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveStatusCheckProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "repos/remove-status-check-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveStatusCheckProtectionReq) Rel(link string, resp *RemoveStatusCheckProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveStatusCheckProtectionResponse is a response for RemoveStatusCheckProtection

https://developer.github.com/v3/repos/branches/#remove-status-check-protection
*/
type RemoveStatusCheckProtectionResponse struct {
	common.Response
	request *RemoveStatusCheckProtectionReq
}

/*
RemoveTeamAccessRestrictions performs requests for "repos/remove-team-access-restrictions"

Remove team access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
func RemoveTeamAccessRestrictions(ctx context.Context, req *RemoveTeamAccessRestrictionsReq, opt ...options.Option) (*RemoveTeamAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveTeamAccessRestrictionsReq)
	}
	resp := &RemoveTeamAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveTeamAccessRestrictions performs requests for "repos/remove-team-access-restrictions"

Remove team access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
func (c Client) RemoveTeamAccessRestrictions(ctx context.Context, req *RemoveTeamAccessRestrictionsReq, opt ...options.Option) (*RemoveTeamAccessRestrictionsResponse, error) {
	return RemoveTeamAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
RemoveTeamAccessRestrictionsReq is request data for Client.RemoveTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
type RemoveTeamAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody RemoveTeamAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *RemoveTeamAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveTeamAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "DELETE",
		OperationID:      "repos/remove-team-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveTeamAccessRestrictionsReq) Rel(link string, resp *RemoveTeamAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveTeamAccessRestrictionsReqBody is a request body for repos/remove-team-access-restrictions

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
type RemoveTeamAccessRestrictionsReqBody []string

/*
RemoveTeamAccessRestrictionsResponse is a response for RemoveTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-team-access-restrictions
*/
type RemoveTeamAccessRestrictionsResponse struct {
	common.Response
	request *RemoveTeamAccessRestrictionsReq
	Data    []components.Team
}

/*
RemoveUserAccessRestrictions performs requests for "repos/remove-user-access-restrictions"

Remove user access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
func RemoveUserAccessRestrictions(ctx context.Context, req *RemoveUserAccessRestrictionsReq, opt ...options.Option) (*RemoveUserAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveUserAccessRestrictionsReq)
	}
	resp := &RemoveUserAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveUserAccessRestrictions performs requests for "repos/remove-user-access-restrictions"

Remove user access restrictions.

  DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
func (c Client) RemoveUserAccessRestrictions(ctx context.Context, req *RemoveUserAccessRestrictionsReq, opt ...options.Option) (*RemoveUserAccessRestrictionsResponse, error) {
	return RemoveUserAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
RemoveUserAccessRestrictionsReq is request data for Client.RemoveUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
type RemoveUserAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody RemoveUserAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *RemoveUserAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveUserAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "DELETE",
		OperationID:      "repos/remove-user-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveUserAccessRestrictionsReq) Rel(link string, resp *RemoveUserAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveUserAccessRestrictionsReqBody is a request body for repos/remove-user-access-restrictions

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
type RemoveUserAccessRestrictionsReqBody []string

/*
RemoveUserAccessRestrictionsResponse is a response for RemoveUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#remove-user-access-restrictions
*/
type RemoveUserAccessRestrictionsResponse struct {
	common.Response
	request *RemoveUserAccessRestrictionsReq
	Data    []components.SimpleUser
}

/*
ReplaceAllTopics performs requests for "repos/replace-all-topics"

Replace all repository topics.

  PUT /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
func ReplaceAllTopics(ctx context.Context, req *ReplaceAllTopicsReq, opt ...options.Option) (*ReplaceAllTopicsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReplaceAllTopicsReq)
	}
	resp := &ReplaceAllTopicsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Topic{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ReplaceAllTopics performs requests for "repos/replace-all-topics"

Replace all repository topics.

  PUT /repos/{owner}/{repo}/topics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
func (c Client) ReplaceAllTopics(ctx context.Context, req *ReplaceAllTopicsReq, opt ...options.Option) (*ReplaceAllTopicsResponse, error) {
	return ReplaceAllTopics(ctx, req, append(c, opt...)...)
}

/*
ReplaceAllTopicsReq is request data for Client.ReplaceAllTopics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReplaceAllTopicsReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ReplaceAllTopicsReqBody

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReplaceAllTopicsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReplaceAllTopicsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"mercy"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/replace-all-topics",
		Previews:         map[string]bool{"mercy": r.MercyPreview},
		RequiredPreviews: []string{"mercy"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/topics", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReplaceAllTopicsReq) Rel(link string, resp *ReplaceAllTopicsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReplaceAllTopicsReqBody is a request body for repos/replace-all-topics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReplaceAllTopicsReqBody struct {

	/*
	An array of topics to add to the repository. Pass one or more topics to
	_replace_ the set of existing topics. Send an empty array (`[]`) to clear all
	topics from the repository. **Note:** Topic `names` cannot contain uppercase
	letters.
	*/
	Names []string `json:"names"`
}

/*
ReplaceAllTopicsResponse is a response for ReplaceAllTopics

https://developer.github.com/v3/repos/#replace-all-repository-topics
*/
type ReplaceAllTopicsResponse struct {
	common.Response
	request *ReplaceAllTopicsReq
	Data    components.Topic
}

/*
RequestPagesBuild performs requests for "repos/request-pages-build"

Request a GitHub Pages build.

  POST /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#request-a-github-pages-build
*/
func RequestPagesBuild(ctx context.Context, req *RequestPagesBuildReq, opt ...options.Option) (*RequestPagesBuildResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RequestPagesBuildReq)
	}
	resp := &RequestPagesBuildResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PageBuildStatus{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RequestPagesBuild performs requests for "repos/request-pages-build"

Request a GitHub Pages build.

  POST /repos/{owner}/{repo}/pages/builds

https://developer.github.com/v3/repos/pages/#request-a-github-pages-build
*/
func (c Client) RequestPagesBuild(ctx context.Context, req *RequestPagesBuildReq, opt ...options.Option) (*RequestPagesBuildResponse, error) {
	return RequestPagesBuild(ctx, req, append(c, opt...)...)
}

/*
RequestPagesBuildReq is request data for Client.RequestPagesBuild

https://developer.github.com/v3/repos/pages/#request-a-github-pages-build
*/
type RequestPagesBuildReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *RequestPagesBuildReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RequestPagesBuildReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{201},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "POST",
		OperationID:      "repos/request-pages-build",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages/builds", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RequestPagesBuildReq) Rel(link string, resp *RequestPagesBuildResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RequestPagesBuildResponse is a response for RequestPagesBuild

https://developer.github.com/v3/repos/pages/#request-a-github-pages-build
*/
type RequestPagesBuildResponse struct {
	common.Response
	request *RequestPagesBuildReq
	Data    components.PageBuildStatus
}

/*
SetAdminBranchProtection performs requests for "repos/set-admin-branch-protection"

Set admin branch protection.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#set-admin-branch-protection
*/
func SetAdminBranchProtection(ctx context.Context, req *SetAdminBranchProtectionReq, opt ...options.Option) (*SetAdminBranchProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetAdminBranchProtectionReq)
	}
	resp := &SetAdminBranchProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranchAdminEnforced{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetAdminBranchProtection performs requests for "repos/set-admin-branch-protection"

Set admin branch protection.

  POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins

https://developer.github.com/v3/repos/branches/#set-admin-branch-protection
*/
func (c Client) SetAdminBranchProtection(ctx context.Context, req *SetAdminBranchProtectionReq, opt ...options.Option) (*SetAdminBranchProtectionResponse, error) {
	return SetAdminBranchProtection(ctx, req, append(c, opt...)...)
}

/*
SetAdminBranchProtectionReq is request data for Client.SetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#set-admin-branch-protection
*/
type SetAdminBranchProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch string
}

// HTTPRequest builds an *http.Request
func (r *SetAdminBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetAdminBranchProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "POST",
		OperationID:      "repos/set-admin-branch-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/enforce_admins", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetAdminBranchProtectionReq) Rel(link string, resp *SetAdminBranchProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetAdminBranchProtectionResponse is a response for SetAdminBranchProtection

https://developer.github.com/v3/repos/branches/#set-admin-branch-protection
*/
type SetAdminBranchProtectionResponse struct {
	common.Response
	request *SetAdminBranchProtectionReq
	Data    components.ProtectedBranchAdminEnforced
}

/*
SetAppAccessRestrictions performs requests for "repos/set-app-access-restrictions"

Set app access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
func SetAppAccessRestrictions(ctx context.Context, req *SetAppAccessRestrictionsReq, opt ...options.Option) (*SetAppAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetAppAccessRestrictionsReq)
	}
	resp := &SetAppAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Integration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetAppAccessRestrictions performs requests for "repos/set-app-access-restrictions"

Set app access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
func (c Client) SetAppAccessRestrictions(ctx context.Context, req *SetAppAccessRestrictionsReq, opt ...options.Option) (*SetAppAccessRestrictionsResponse, error) {
	return SetAppAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
SetAppAccessRestrictionsReq is request data for Client.SetAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
type SetAppAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody SetAppAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetAppAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetAppAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/set-app-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/apps", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetAppAccessRestrictionsReq) Rel(link string, resp *SetAppAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetAppAccessRestrictionsReqBody is a request body for repos/set-app-access-restrictions

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
type SetAppAccessRestrictionsReqBody []string

/*
SetAppAccessRestrictionsResponse is a response for SetAppAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-app-access-restrictions
*/
type SetAppAccessRestrictionsResponse struct {
	common.Response
	request *SetAppAccessRestrictionsReq
	Data    []components.Integration
}

/*
SetStatusCheckContexts performs requests for "repos/set-status-check-contexts"

Set status check contexts.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
func SetStatusCheckContexts(ctx context.Context, req *SetStatusCheckContextsReq, opt ...options.Option) (*SetStatusCheckContextsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetStatusCheckContextsReq)
	}
	resp := &SetStatusCheckContextsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = SetStatusCheckContextsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetStatusCheckContexts performs requests for "repos/set-status-check-contexts"

Set status check contexts.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
func (c Client) SetStatusCheckContexts(ctx context.Context, req *SetStatusCheckContextsReq, opt ...options.Option) (*SetStatusCheckContextsResponse, error) {
	return SetStatusCheckContexts(ctx, req, append(c, opt...)...)
}

/*
SetStatusCheckContextsReq is request data for Client.SetStatusCheckContexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
type SetStatusCheckContextsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody SetStatusCheckContextsReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetStatusCheckContextsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetStatusCheckContextsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/set-status-check-contexts",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks/contexts", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetStatusCheckContextsReq) Rel(link string, resp *SetStatusCheckContextsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetStatusCheckContextsReqBody is a request body for repos/set-status-check-contexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
type SetStatusCheckContextsReqBody []string

/*
SetStatusCheckContextsResponseBody is a response body for SetStatusCheckContexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
type SetStatusCheckContextsResponseBody []string

/*
SetStatusCheckContextsResponse is a response for SetStatusCheckContexts

https://developer.github.com/v3/repos/branches/#set-status-check-contexts
*/
type SetStatusCheckContextsResponse struct {
	common.Response
	request *SetStatusCheckContextsReq
	Data    SetStatusCheckContextsResponseBody
}

/*
SetTeamAccessRestrictions performs requests for "repos/set-team-access-restrictions"

Set team access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
func SetTeamAccessRestrictions(ctx context.Context, req *SetTeamAccessRestrictionsReq, opt ...options.Option) (*SetTeamAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetTeamAccessRestrictionsReq)
	}
	resp := &SetTeamAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetTeamAccessRestrictions performs requests for "repos/set-team-access-restrictions"

Set team access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
func (c Client) SetTeamAccessRestrictions(ctx context.Context, req *SetTeamAccessRestrictionsReq, opt ...options.Option) (*SetTeamAccessRestrictionsResponse, error) {
	return SetTeamAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
SetTeamAccessRestrictionsReq is request data for Client.SetTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
type SetTeamAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody SetTeamAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetTeamAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetTeamAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/set-team-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/teams", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetTeamAccessRestrictionsReq) Rel(link string, resp *SetTeamAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetTeamAccessRestrictionsReqBody is a request body for repos/set-team-access-restrictions

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
type SetTeamAccessRestrictionsReqBody []string

/*
SetTeamAccessRestrictionsResponse is a response for SetTeamAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-team-access-restrictions
*/
type SetTeamAccessRestrictionsResponse struct {
	common.Response
	request *SetTeamAccessRestrictionsReq
	Data    []components.Team
}

/*
SetUserAccessRestrictions performs requests for "repos/set-user-access-restrictions"

Set user access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
func SetUserAccessRestrictions(ctx context.Context, req *SetUserAccessRestrictionsReq, opt ...options.Option) (*SetUserAccessRestrictionsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetUserAccessRestrictionsReq)
	}
	resp := &SetUserAccessRestrictionsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetUserAccessRestrictions performs requests for "repos/set-user-access-restrictions"

Set user access restrictions.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
func (c Client) SetUserAccessRestrictions(ctx context.Context, req *SetUserAccessRestrictionsReq, opt ...options.Option) (*SetUserAccessRestrictionsResponse, error) {
	return SetUserAccessRestrictions(ctx, req, append(c, opt...)...)
}

/*
SetUserAccessRestrictionsReq is request data for Client.SetUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
type SetUserAccessRestrictionsReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody SetUserAccessRestrictionsReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetUserAccessRestrictionsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetUserAccessRestrictionsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/set-user-access-restrictions",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/restrictions/users", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetUserAccessRestrictionsReq) Rel(link string, resp *SetUserAccessRestrictionsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetUserAccessRestrictionsReqBody is a request body for repos/set-user-access-restrictions

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
type SetUserAccessRestrictionsReqBody []string

/*
SetUserAccessRestrictionsResponse is a response for SetUserAccessRestrictions

https://developer.github.com/v3/repos/branches/#set-user-access-restrictions
*/
type SetUserAccessRestrictionsResponse struct {
	common.Response
	request *SetUserAccessRestrictionsReq
	Data    []components.SimpleUser
}

/*
TestPushWebhook performs requests for "repos/test-push-webhook"

Test the push repository webhook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/tests

https://developer.github.com/v3/repos/hooks/#test-the-push-repository-webhook
*/
func TestPushWebhook(ctx context.Context, req *TestPushWebhookReq, opt ...options.Option) (*TestPushWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TestPushWebhookReq)
	}
	resp := &TestPushWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TestPushWebhook performs requests for "repos/test-push-webhook"

Test the push repository webhook.

  POST /repos/{owner}/{repo}/hooks/{hook_id}/tests

https://developer.github.com/v3/repos/hooks/#test-the-push-repository-webhook
*/
func (c Client) TestPushWebhook(ctx context.Context, req *TestPushWebhookReq, opt ...options.Option) (*TestPushWebhookResponse, error) {
	return TestPushWebhook(ctx, req, append(c, opt...)...)
}

/*
TestPushWebhookReq is request data for Client.TestPushWebhook

https://developer.github.com/v3/repos/hooks/#test-the-push-repository-webhook
*/
type TestPushWebhookReq struct {
	_url   string
	Owner  string
	Repo   string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *TestPushWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TestPushWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "POST",
		OperationID:      "repos/test-push-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks/%v/tests", r.Owner, r.Repo, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TestPushWebhookReq) Rel(link string, resp *TestPushWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TestPushWebhookResponse is a response for TestPushWebhook

https://developer.github.com/v3/repos/hooks/#test-the-push-repository-webhook
*/
type TestPushWebhookResponse struct {
	common.Response
	request *TestPushWebhookReq
	Data    bool
}

/*
Transfer performs requests for "repos/transfer"

Transfer a repository.

  POST /repos/{owner}/{repo}/transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
func Transfer(ctx context.Context, req *TransferReq, opt ...options.Option) (*TransferResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TransferReq)
	}
	resp := &TransferResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Repository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Transfer performs requests for "repos/transfer"

Transfer a repository.

  POST /repos/{owner}/{repo}/transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
func (c Client) Transfer(ctx context.Context, req *TransferReq, opt ...options.Option) (*TransferResponse, error) {
	return Transfer(ctx, req, append(c, opt...)...)
}

/*
TransferReq is request data for Client.Transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type TransferReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody TransferReqBody
}

// HTTPRequest builds an *http.Request
func (r *TransferReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TransferReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{202},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "repos/transfer",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/transfer", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{202},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TransferReq) Rel(link string, resp *TransferResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TransferReqBody is a request body for repos/transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type TransferReqBody struct {

	// **Required:** The username or organization name the repository will be transferred to.
	NewOwner *string `json:"new_owner,omitempty"`

	// ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
	TeamIds []int64 `json:"team_ids,omitempty"`
}

/*
TransferResponse is a response for Transfer

https://developer.github.com/v3/repos/#transfer-a-repository
*/
type TransferResponse struct {
	common.Response
	request *TransferReq
	Data    components.Repository
}

/*
Update performs requests for "repos/update"

Update a repository.

  PATCH /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#update-a-repository
*/
func Update(ctx context.Context, req *UpdateReq, opt ...options.Option) (*UpdateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateReq)
	}
	resp := &UpdateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.FullRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Update performs requests for "repos/update"

Update a repository.

  PATCH /repos/{owner}/{repo}

https://developer.github.com/v3/repos/#update-a-repository
*/
func (c Client) Update(ctx context.Context, req *UpdateReq, opt ...options.Option) (*UpdateResponse, error) {
	return Update(ctx, req, append(c, opt...)...)
}

/*
UpdateReq is request data for Client.Update

https://developer.github.com/v3/repos/#update-a-repository
*/
type UpdateReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody UpdateReqBody

	/*
	You can set the visibility of a repository using the new `visibility` parameter
	in the [Repositories API](https://developer.github.com/v3/repos/), and get a
	repository's visibility with a new response key. For more information, see the
	[blog
	post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes/).

	To access repository visibility during the preview period, you must set this to
	true.
	*/
	NebulaPreview bool

	/*
	The `is_template` and `template_repository` keys are currently available for
	developer to preview. See [Create a repository using a
	template](https://developer.github.com/v3/repos/#create-a-repository-using-a-template)
	to learn how to create template repositories. To access these new response keys
	during the preview period, you must set this to true.
	*/
	BaptistePreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"nebula", "baptiste"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:      "PATCH",
		OperationID: "repos/update",
		Previews: map[string]bool{
			"baptiste": r.BaptistePreview,
			"nebula":   r.NebulaPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReq) Rel(link string, resp *UpdateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateReqBody is a request body for repos/update

https://developer.github.com/v3/repos/#update-a-repository
*/
type UpdateReqBody struct {

	/*
	Either `true` to allow merging pull requests with a merge commit, or `false` to
	prevent merging pull requests with merge commits.
	*/
	AllowMergeCommit *bool `json:"allow_merge_commit,omitempty"`

	// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
	AllowRebaseMerge *bool `json:"allow_rebase_merge,omitempty"`

	// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
	AllowSquashMerge *bool `json:"allow_squash_merge,omitempty"`

	// `true` to archive this repository. **Note**: You cannot unarchive repositories through the API.
	Archived *bool `json:"archived,omitempty"`

	// Updates the default branch for this repository.
	DefaultBranch *string `json:"default_branch,omitempty"`

	/*
	Either `true` to allow automatically deleting head branches when pull requests
	are merged, or `false` to prevent automatic deletion.
	*/
	DeleteBranchOnMerge *bool `json:"delete_branch_on_merge,omitempty"`

	// A short description of the repository.
	Description *string `json:"description,omitempty"`

	// Either `true` to enable issues for this repository or `false` to disable them.
	HasIssues *bool `json:"has_issues,omitempty"`

	/*
	Either `true` to enable projects for this repository or `false` to disable them.
	**Note:** If you're creating a repository in an organization that has disabled
	repository projects, the default is `false`, and if you pass `true`, the API
	returns an error.
	*/
	HasProjects *bool `json:"has_projects,omitempty"`

	// Either `true` to enable the wiki for this repository or `false` to disable it.
	HasWiki *bool `json:"has_wiki,omitempty"`

	// A URL with more information about the repository.
	Homepage *string `json:"homepage,omitempty"`

	// Either `true` to make this repo available as a template repository or `false` to prevent it.
	IsTemplate *bool `json:"is_template,omitempty"`

	// The name of the repository.
	Name *string `json:"name,omitempty"`

	/*
	Either `true` to make the repository private or `false` to make it public.
	Default: `false`.
	**Note**: You will get a `422` error if the organization restricts [changing
	repository
	visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories)
	to organization owners and a non-owner tries to change the value of private.
	**Note**: You will get a `422` error if the organization restricts [changing
	repository
	visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories)
	to organization owners and a non-owner tries to change the value of private.
	*/
	Private *bool `json:"private,omitempty"`

	/*
	Can be `public` or `private`. If your organization is associated with an
	enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server
	2.20+, `visibility` can also be `internal`. The `visibility` parameter overrides
	the `private` parameter when you use both along with the `nebula-preview`
	preview header.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
UpdateResponse is a response for Update

https://developer.github.com/v3/repos/#update-a-repository
*/
type UpdateResponse struct {
	common.Response
	request *UpdateReq
	Data    components.FullRepository
}

/*
UpdateBranchProtection performs requests for "repos/update-branch-protection"

Update branch protection.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
func UpdateBranchProtection(ctx context.Context, req *UpdateBranchProtectionReq, opt ...options.Option) (*UpdateBranchProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateBranchProtectionReq)
	}
	resp := &UpdateBranchProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranch{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateBranchProtection performs requests for "repos/update-branch-protection"

Update branch protection.

  PUT /repos/{owner}/{repo}/branches/{branch}/protection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
func (c Client) UpdateBranchProtection(ctx context.Context, req *UpdateBranchProtectionReq, opt ...options.Option) (*UpdateBranchProtectionResponse, error) {
	return UpdateBranchProtection(ctx, req, append(c, opt...)...)
}

/*
UpdateBranchProtectionReq is request data for Client.UpdateBranchProtection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type UpdateBranchProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody UpdateBranchProtectionReqBody

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdateBranchProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateBranchProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"luke-cage"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "repos/update-branch-protection",
		Previews:         map[string]bool{"luke-cage": r.LukeCagePreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateBranchProtectionReq) Rel(link string, resp *UpdateBranchProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// UpdateBranchProtectionReqBodyRequiredPullRequestReviews is a value for UpdateBranchProtectionReqBody's RequiredPullRequestReviews field
type UpdateBranchProtectionReqBodyRequiredPullRequestReviews struct {

	// Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
	DismissStaleReviews *bool `json:"dismiss_stale_reviews,omitempty"`

	/*
	Specify which users and teams can dismiss pull request reviews. Pass an empty
	`dismissal_restrictions` object to disable. User and team
	`dismissal_restrictions` are only available for organization-owned repositories.
	Omit this parameter for personal repositories.
	*/
	DismissalRestrictions *UpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions `json:"dismissal_restrictions,omitempty"`

	// Blocks merging pull requests until [code owners](https://help.github.com/articles/about-code-owners/) review them.
	RequireCodeOwnerReviews *bool `json:"require_code_owner_reviews,omitempty"`

	// Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6.
	RequiredApprovingReviewCount *int64 `json:"required_approving_review_count,omitempty"`
}

// UpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions is a value for UpdateBranchProtectionReqBodyRequiredPullRequestReviews's DismissalRestrictions field
type UpdateBranchProtectionReqBodyRequiredPullRequestReviewsDismissalRestrictions struct {

	// The list of team `slug`s with dismissal access
	Teams []string `json:"teams,omitempty"`

	// The list of user `login`s with dismissal access
	Users []string `json:"users,omitempty"`
}

// UpdateBranchProtectionReqBodyRequiredStatusChecks is a value for UpdateBranchProtectionReqBody's RequiredStatusChecks field
type UpdateBranchProtectionReqBodyRequiredStatusChecks struct {

	// The list of status checks to require in order to merge into this branch
	Contexts []string `json:"contexts"`

	// Require branches to be up to date before merging.
	Strict *bool `json:"strict"`
}

// UpdateBranchProtectionReqBodyRestrictions is a value for UpdateBranchProtectionReqBody's Restrictions field
type UpdateBranchProtectionReqBodyRestrictions struct {

	// The list of app `slug`s with push access
	Apps []string `json:"apps,omitempty"`

	// The list of team `slug`s with push access
	Teams []string `json:"teams"`

	// The list of user `login`s with push access
	Users []string `json:"users"`
}

/*
UpdateBranchProtectionReqBody is a request body for repos/update-branch-protection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type UpdateBranchProtectionReqBody struct {

	/*
	Allows deletion of the protected branch by anyone with write access to the
	repository. Set to `false` to prevent deletion of the protected branch. Default:
	`false`. For more information, see "[Enabling force pushes to a protected
	branch](https://help.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)"
	in the GitHub Help documentation.
	*/
	AllowDeletions *bool `json:"allow_deletions,omitempty"`

	/*
	Permits force pushes to the protected branch by anyone with write access to the
	repository. Set to `true` to allow force pushes. Set to `false` or `null` to
	block force pushes. Default: `false`. For more information, see "[Enabling force
	pushes to a protected
	branch](https://help.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)"
	in the GitHub Help documentation."
	*/
	AllowForcePushes *bool `json:"allow_force_pushes,omitempty"`

	/*
	Enforce all configured restrictions for administrators. Set to `true` to enforce
	required status checks for repository administrators. Set to `null` to disable.
	*/
	EnforceAdmins *bool `json:"enforce_admins"`

	/*
	Enforces a linear commit Git history, which prevents anyone from pushing merge
	commits to a branch. Set to `true` to enforce a linear commit history. Set to
	`false` to disable a linear commit Git history. Your repository must allow
	squash merging or rebase merging before you can enable a linear commit history.
	Default: `false`. For more information, see "[Requiring a linear commit
	history](https://help.github.com/github/administering-a-repository/requiring-a-linear-commit-history)"
	in the GitHub Help documentation.
	*/
	RequiredLinearHistory *bool `json:"required_linear_history,omitempty"`

	// Require at least one approving review on a pull request, before merging. Set to `null` to disable.
	RequiredPullRequestReviews *UpdateBranchProtectionReqBodyRequiredPullRequestReviews `json:"required_pull_request_reviews"`

	// Require status checks to pass before merging. Set to `null` to disable.
	RequiredStatusChecks *UpdateBranchProtectionReqBodyRequiredStatusChecks `json:"required_status_checks"`

	/*
	Restrict who can push to the protected branch. User, app, and team
	`restrictions` are only available for organization-owned repositories. Set to
	`null` to disable.
	*/
	Restrictions *UpdateBranchProtectionReqBodyRestrictions `json:"restrictions"`
}

/*
UpdateBranchProtectionResponse is a response for UpdateBranchProtection

https://developer.github.com/v3/repos/branches/#update-branch-protection
*/
type UpdateBranchProtectionResponse struct {
	common.Response
	request *UpdateBranchProtectionReq
	Data    components.ProtectedBranch
}

/*
UpdateCommitComment performs requests for "repos/update-commit-comment"

Update a commit comment.

  PATCH /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
func UpdateCommitComment(ctx context.Context, req *UpdateCommitCommentReq, opt ...options.Option) (*UpdateCommitCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateCommitCommentReq)
	}
	resp := &UpdateCommitCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CommitComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateCommitComment performs requests for "repos/update-commit-comment"

Update a commit comment.

  PATCH /repos/{owner}/{repo}/comments/{comment_id}

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
func (c Client) UpdateCommitComment(ctx context.Context, req *UpdateCommitCommentReq, opt ...options.Option) (*UpdateCommitCommentResponse, error) {
	return UpdateCommitComment(ctx, req, append(c, opt...)...)
}

/*
UpdateCommitCommentReq is request data for Client.UpdateCommitComment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type UpdateCommitCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody UpdateCommitCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateCommitCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateCommitCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-commit-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateCommitCommentReq) Rel(link string, resp *UpdateCommitCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateCommitCommentReqBody is a request body for repos/update-commit-comment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type UpdateCommitCommentReqBody struct {

	// The contents of the comment
	Body *string `json:"body"`
}

/*
UpdateCommitCommentResponse is a response for UpdateCommitComment

https://developer.github.com/v3/repos/comments/#update-a-commit-comment
*/
type UpdateCommitCommentResponse struct {
	common.Response
	request *UpdateCommitCommentReq
	Data    components.CommitComment
}

/*
UpdateInformationAboutPagesSite performs requests for "repos/update-information-about-pages-site"

Update information about a GitHub Pages site.

  PUT /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
func UpdateInformationAboutPagesSite(ctx context.Context, req *UpdateInformationAboutPagesSiteReq, opt ...options.Option) (*UpdateInformationAboutPagesSiteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateInformationAboutPagesSiteReq)
	}
	resp := &UpdateInformationAboutPagesSiteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateInformationAboutPagesSite performs requests for "repos/update-information-about-pages-site"

Update information about a GitHub Pages site.

  PUT /repos/{owner}/{repo}/pages

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
func (c Client) UpdateInformationAboutPagesSite(ctx context.Context, req *UpdateInformationAboutPagesSiteReq, opt ...options.Option) (*UpdateInformationAboutPagesSiteResponse, error) {
	return UpdateInformationAboutPagesSite(ctx, req, append(c, opt...)...)
}

/*
UpdateInformationAboutPagesSiteReq is request data for Client.UpdateInformationAboutPagesSite

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
type UpdateInformationAboutPagesSiteReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody UpdateInformationAboutPagesSiteReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateInformationAboutPagesSiteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateInformationAboutPagesSiteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": internal.String("application/json")},
		Method:           "PUT",
		OperationID:      "repos/update-information-about-pages-site",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pages", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateInformationAboutPagesSiteReq) Rel(link string, resp *UpdateInformationAboutPagesSiteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateInformationAboutPagesSiteReqBody is a request body for repos/update-information-about-pages-site

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
type UpdateInformationAboutPagesSiteReqBody struct {

	/*
	Specify a custom domain for the repository. Sending a `null` value will remove
	the custom domain. For more about custom domains, see "[Using a custom domain
	with GitHub
	Pages](https://help.github.com/articles/using-a-custom-domain-with-github-pages/)."
	*/
	Cname  *string     `json:"cname,omitempty"`
	Source interface{} `json:"source,omitempty"`
}

/*
UpdateInformationAboutPagesSiteResponse is a response for UpdateInformationAboutPagesSite

https://developer.github.com/v3/repos/pages/#update-information-about-a-github-pages-site
*/
type UpdateInformationAboutPagesSiteResponse struct {
	common.Response
	request *UpdateInformationAboutPagesSiteReq
}

/*
UpdateInvitation performs requests for "repos/update-invitation"

Update a repository invitation.

  PATCH /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
func UpdateInvitation(ctx context.Context, req *UpdateInvitationReq, opt ...options.Option) (*UpdateInvitationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateInvitationReq)
	}
	resp := &UpdateInvitationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.RepositoryInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateInvitation performs requests for "repos/update-invitation"

Update a repository invitation.

  PATCH /repos/{owner}/{repo}/invitations/{invitation_id}

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
func (c Client) UpdateInvitation(ctx context.Context, req *UpdateInvitationReq, opt ...options.Option) (*UpdateInvitationResponse, error) {
	return UpdateInvitation(ctx, req, append(c, opt...)...)
}

/*
UpdateInvitationReq is request data for Client.UpdateInvitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type UpdateInvitationReq struct {
	_url  string
	Owner string
	Repo  string

	// invitation_id parameter
	InvitationId int64
	RequestBody  UpdateInvitationReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateInvitationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateInvitationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-invitation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/invitations/%v", r.Owner, r.Repo, r.InvitationId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateInvitationReq) Rel(link string, resp *UpdateInvitationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateInvitationReqBody is a request body for repos/update-invitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type UpdateInvitationReqBody struct {

	/*
	The permissions that the associated user will have on the repository. Valid
	values are `read`, `write`, `maintain`, `triage`, and `admin`.
	*/
	Permissions *string `json:"permissions,omitempty"`
}

/*
UpdateInvitationResponse is a response for UpdateInvitation

https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation
*/
type UpdateInvitationResponse struct {
	common.Response
	request *UpdateInvitationReq
	Data    components.RepositoryInvitation
}

/*
UpdatePullRequestReviewProtection performs requests for "repos/update-pull-request-review-protection"

Update pull request review protection.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
func UpdatePullRequestReviewProtection(ctx context.Context, req *UpdatePullRequestReviewProtectionReq, opt ...options.Option) (*UpdatePullRequestReviewProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdatePullRequestReviewProtectionReq)
	}
	resp := &UpdatePullRequestReviewProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProtectedBranchPullRequestReview{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdatePullRequestReviewProtection performs requests for "repos/update-pull-request-review-protection"

Update pull request review protection.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
func (c Client) UpdatePullRequestReviewProtection(ctx context.Context, req *UpdatePullRequestReviewProtectionReq, opt ...options.Option) (*UpdatePullRequestReviewProtectionResponse, error) {
	return UpdatePullRequestReviewProtection(ctx, req, append(c, opt...)...)
}

/*
UpdatePullRequestReviewProtectionReq is request data for Client.UpdatePullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
type UpdatePullRequestReviewProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody UpdatePullRequestReviewProtectionReqBody

	/*
	The Protected Branches API now has a setting for requiring a specified number of
	approving pull request reviews before merging. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-03-16-protected-branches-required-approving-reviews)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	LukeCagePreview bool
}

// HTTPRequest builds an *http.Request
func (r *UpdatePullRequestReviewProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdatePullRequestReviewProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"luke-cage"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-pull-request-review-protection",
		Previews:         map[string]bool{"luke-cage": r.LukeCagePreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_pull_request_reviews", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdatePullRequestReviewProtectionReq) Rel(link string, resp *UpdatePullRequestReviewProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// UpdatePullRequestReviewProtectionReqBodyDismissalRestrictions is a value for UpdatePullRequestReviewProtectionReqBody's DismissalRestrictions field
type UpdatePullRequestReviewProtectionReqBodyDismissalRestrictions struct {

	// The list of team `slug`s with dismissal access
	Teams []string `json:"teams,omitempty"`

	// The list of user `login`s with dismissal access
	Users []string `json:"users,omitempty"`
}

/*
UpdatePullRequestReviewProtectionReqBody is a request body for repos/update-pull-request-review-protection

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
type UpdatePullRequestReviewProtectionReqBody struct {

	// Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
	DismissStaleReviews *bool `json:"dismiss_stale_reviews,omitempty"`

	/*
	Specify which users and teams can dismiss pull request reviews. Pass an empty
	`dismissal_restrictions` object to disable. User and team
	`dismissal_restrictions` are only available for organization-owned repositories.
	Omit this parameter for personal repositories.
	*/
	DismissalRestrictions *UpdatePullRequestReviewProtectionReqBodyDismissalRestrictions `json:"dismissal_restrictions,omitempty"`

	// Blocks merging pull requests until [code owners](https://help.github.com/articles/about-code-owners/) have reviewed.
	RequireCodeOwnerReviews *bool `json:"require_code_owner_reviews,omitempty"`

	// Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6.
	RequiredApprovingReviewCount *int64 `json:"required_approving_review_count,omitempty"`
}

/*
UpdatePullRequestReviewProtectionResponse is a response for UpdatePullRequestReviewProtection

https://developer.github.com/v3/repos/branches/#update-pull-request-review-protection
*/
type UpdatePullRequestReviewProtectionResponse struct {
	common.Response
	request *UpdatePullRequestReviewProtectionReq
	Data    components.ProtectedBranchPullRequestReview
}

/*
UpdateRelease performs requests for "repos/update-release"

Update a release.

  PATCH /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#update-a-release
*/
func UpdateRelease(ctx context.Context, req *UpdateReleaseReq, opt ...options.Option) (*UpdateReleaseResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateReleaseReq)
	}
	resp := &UpdateReleaseResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Release{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateRelease performs requests for "repos/update-release"

Update a release.

  PATCH /repos/{owner}/{repo}/releases/{release_id}

https://developer.github.com/v3/repos/releases/#update-a-release
*/
func (c Client) UpdateRelease(ctx context.Context, req *UpdateReleaseReq, opt ...options.Option) (*UpdateReleaseResponse, error) {
	return UpdateRelease(ctx, req, append(c, opt...)...)
}

/*
UpdateReleaseReq is request data for Client.UpdateRelease

https://developer.github.com/v3/repos/releases/#update-a-release
*/
type UpdateReleaseReq struct {
	_url  string
	Owner string
	Repo  string

	// release_id parameter
	ReleaseId   int64
	RequestBody UpdateReleaseReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateReleaseReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateReleaseReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-release",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/%v", r.Owner, r.Repo, r.ReleaseId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReleaseReq) Rel(link string, resp *UpdateReleaseResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateReleaseReqBody is a request body for repos/update-release

https://developer.github.com/v3/repos/releases/#update-a-release
*/
type UpdateReleaseReqBody struct {

	// Text describing the contents of the tag.
	Body *string `json:"body,omitempty"`

	// `true` makes the release a draft, and `false` publishes the release.
	Draft *bool `json:"draft,omitempty"`

	// The name of the release.
	Name *string `json:"name,omitempty"`

	// `true` to identify the release as a prerelease, `false` to identify the release as a full release.
	Prerelease *bool `json:"prerelease,omitempty"`

	// The name of the tag.
	TagName *string `json:"tag_name,omitempty"`

	/*
	Specifies the commitish value that determines where the Git tag is created from.
	Can be any branch or commit SHA. Unused if the Git tag already exists. Default:
	the repository's default branch (usually `master`).
	*/
	TargetCommitish *string `json:"target_commitish,omitempty"`
}

/*
UpdateReleaseResponse is a response for UpdateRelease

https://developer.github.com/v3/repos/releases/#update-a-release
*/
type UpdateReleaseResponse struct {
	common.Response
	request *UpdateReleaseReq
	Data    components.Release
}

/*
UpdateReleaseAsset performs requests for "repos/update-release-asset"

Update a release asset.

  PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
func UpdateReleaseAsset(ctx context.Context, req *UpdateReleaseAssetReq, opt ...options.Option) (*UpdateReleaseAssetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateReleaseAssetReq)
	}
	resp := &UpdateReleaseAssetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ReleaseAsset{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateReleaseAsset performs requests for "repos/update-release-asset"

Update a release asset.

  PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
func (c Client) UpdateReleaseAsset(ctx context.Context, req *UpdateReleaseAssetReq, opt ...options.Option) (*UpdateReleaseAssetResponse, error) {
	return UpdateReleaseAsset(ctx, req, append(c, opt...)...)
}

/*
UpdateReleaseAssetReq is request data for Client.UpdateReleaseAsset

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
type UpdateReleaseAssetReq struct {
	_url  string
	Owner string
	Repo  string

	// asset_id parameter
	AssetId     int64
	RequestBody UpdateReleaseAssetReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateReleaseAssetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-release-asset",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/releases/assets/%v", r.Owner, r.Repo, r.AssetId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReleaseAssetReq) Rel(link string, resp *UpdateReleaseAssetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateReleaseAssetReqBody is a request body for repos/update-release-asset

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
type UpdateReleaseAssetReqBody struct {

	// An alternate short description of the asset. Used in place of the filename.
	Label *string `json:"label,omitempty"`

	// The file name of the asset.
	Name  *string `json:"name,omitempty"`
	State *string `json:"state,omitempty"`
}

/*
UpdateReleaseAssetResponse is a response for UpdateReleaseAsset

https://developer.github.com/v3/repos/releases/#update-a-release-asset
*/
type UpdateReleaseAssetResponse struct {
	common.Response
	request *UpdateReleaseAssetReq
	Data    components.ReleaseAsset
}

/*
UpdateStatusCheckProtection performs requests for "repos/update-status-check-protection"

Update status check protection.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
func UpdateStatusCheckProtection(ctx context.Context, req *UpdateStatusCheckProtectionReq, opt ...options.Option) (*UpdateStatusCheckProtectionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateStatusCheckProtectionReq)
	}
	resp := &UpdateStatusCheckProtectionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.StatusCheckPolicy{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateStatusCheckProtection performs requests for "repos/update-status-check-protection"

Update status check protection.

  PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
func (c Client) UpdateStatusCheckProtection(ctx context.Context, req *UpdateStatusCheckProtectionReq, opt ...options.Option) (*UpdateStatusCheckProtectionResponse, error) {
	return UpdateStatusCheckProtection(ctx, req, append(c, opt...)...)
}

/*
UpdateStatusCheckProtectionReq is request data for Client.UpdateStatusCheckProtection

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
type UpdateStatusCheckProtectionReq struct {
	_url  string
	Owner string
	Repo  string

	// branch+ parameter
	Branch      string
	RequestBody UpdateStatusCheckProtectionReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateStatusCheckProtectionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateStatusCheckProtectionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-status-check-protection",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/branches/%v/protection/required_status_checks", r.Owner, r.Repo, r.Branch),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateStatusCheckProtectionReq) Rel(link string, resp *UpdateStatusCheckProtectionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateStatusCheckProtectionReqBody is a request body for repos/update-status-check-protection

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
type UpdateStatusCheckProtectionReqBody struct {

	// The list of status checks to require in order to merge into this branch
	Contexts []string `json:"contexts,omitempty"`

	// Require branches to be up to date before merging.
	Strict *bool `json:"strict,omitempty"`
}

/*
UpdateStatusCheckProtectionResponse is a response for UpdateStatusCheckProtection

https://developer.github.com/v3/repos/branches/#update-status-check-potection
*/
type UpdateStatusCheckProtectionResponse struct {
	common.Response
	request *UpdateStatusCheckProtectionReq
	Data    components.StatusCheckPolicy
}

/*
UpdateWebhook performs requests for "repos/update-webhook"

Update a repository webhook.

  PATCH /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
func UpdateWebhook(ctx context.Context, req *UpdateWebhookReq, opt ...options.Option) (*UpdateWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateWebhookReq)
	}
	resp := &UpdateWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Hook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateWebhook performs requests for "repos/update-webhook"

Update a repository webhook.

  PATCH /repos/{owner}/{repo}/hooks/{hook_id}

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
func (c Client) UpdateWebhook(ctx context.Context, req *UpdateWebhookReq, opt ...options.Option) (*UpdateWebhookResponse, error) {
	return UpdateWebhook(ctx, req, append(c, opt...)...)
}

/*
UpdateWebhookReq is request data for Client.UpdateWebhook

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
type UpdateWebhookReq struct {
	_url        string
	Owner       string
	Repo        string
	HookId      int64
	RequestBody UpdateWebhookReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "repos/update-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/hooks/%v", r.Owner, r.Repo, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateWebhookReq) Rel(link string, resp *UpdateWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// UpdateWebhookReqBodyConfig is a value for UpdateWebhookReqBody's Config field
type UpdateWebhookReqBodyConfig struct {
	Address *string `json:"address,omitempty"`

	// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
	ContentType *string `json:"content_type,omitempty"`

	/*
	Determines whether the SSL certificate of the host for `url` will be verified
	when delivering payloads. Supported values include `0` (verification is
	performed) and `1` (verification is not performed). The default is `0`. **We
	strongly recommend not setting this to `1` as you are subject to
	man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`
	Room        *string `json:"room,omitempty"`

	/*
	If provided, the `secret` will be used as the `key` to generate the HMAC hex
	digest value in the
	[`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
UpdateWebhookReqBody is a request body for repos/update-webhook

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
type UpdateWebhookReqBody struct {

	// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
	Active *bool `json:"active,omitempty"`

	// Determines a list of events to be added to the list of events that the Hook triggers for.
	AddEvents []string `json:"add_events,omitempty"`

	/*
	Key/value pairs to provide settings for this webhook. [These are defined
	below](https://developer.github.com/v3/repos/hooks/#create-hook-config-params).
	*/
	Config *UpdateWebhookReqBodyConfig `json:"config,omitempty"`

	/*
	Determines what [events](https://developer.github.com/webhooks/event-payloads)
	the hook is triggered for. This replaces the entire array of events.
	*/
	Events []string `json:"events,omitempty"`

	// Determines a list of events to be removed from the list of events that the Hook triggers for.
	RemoveEvents []string `json:"remove_events,omitempty"`
}

/*
UpdateWebhookResponse is a response for UpdateWebhook

https://developer.github.com/v3/repos/hooks/#update-a-repository-webhook
*/
type UpdateWebhookResponse struct {
	common.Response
	request *UpdateWebhookReq
	Data    components.Hook
}

/*
UploadReleaseAsset performs requests for "repos/upload-release-asset"

Upload a release asset.

  POST /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
func UploadReleaseAsset(ctx context.Context, req *UploadReleaseAssetReq, opt ...options.Option) (*UploadReleaseAssetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UploadReleaseAssetReq)
	}
	resp := &UploadReleaseAssetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ReleaseAsset{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UploadReleaseAsset performs requests for "repos/upload-release-asset"

Upload a release asset.

  POST /repos/{owner}/{repo}/releases/{release_id}/assets

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
func (c Client) UploadReleaseAsset(ctx context.Context, req *UploadReleaseAssetReq, opt ...options.Option) (*UploadReleaseAssetResponse, error) {
	return UploadReleaseAsset(ctx, req, append(c, opt...)...)
}

/*
UploadReleaseAssetReq is request data for Client.UploadReleaseAsset

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
type UploadReleaseAssetReq struct {
	_url string

	// URL to query. This must be explicitly set for this endpoint and any base URL set in options will be ignored.
	URL string

	// name parameter
	Name *string

	// label parameter
	Label *string

	// http request's body
	RequestBody io.Reader

	// Content-Type for the uploaded file
	ContentTypeHeader *string
}

// HTTPRequest builds an *http.Request
func (r *UploadReleaseAssetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UploadReleaseAssetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Name != nil {
		query.Set("name", *r.Name)
	}
	if r.Label != nil {
		query.Set("label", *r.Label)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r.URL,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": r.ContentTypeHeader,
		},
		Method:           "POST",
		OperationID:      "repos/upload-release-asset",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          "",
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UploadReleaseAssetReq) Rel(link string, resp *UploadReleaseAssetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UploadReleaseAssetResponse is a response for UploadReleaseAsset

https://developer.github.com/v3/repos/releases/#upload-a-release-asset
*/
type UploadReleaseAssetResponse struct {
	common.Response
	request *UploadReleaseAssetReq
	Data    components.ReleaseAsset
}
