// Code generated by octo-go; DO NOT EDIT.

package search

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
Code performs requests for "search/code"

Search code.

  GET /search/code

https://developer.github.com/v3/search/#search-code
*/
func Code(ctx context.Context, req *CodeReq, opt ...requests.Option) (*CodeResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CodeReq)
	}
	resp := &CodeResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.Load(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Code performs requests for "search/code"

Search code.

  GET /search/code

https://developer.github.com/v3/search/#search-code

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Code(ctx context.Context, req *CodeReq, opt ...requests.Option) (*CodeResponse, error) {
	return Code(ctx, req, append(c, opt...)...)
}

/*
CodeReq is request data for Client.Code

https://developer.github.com/v3/search/#search-code

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CodeReq struct {
	_url string

	/*
	The query contains one or more search keywords and qualifiers. Qualifiers allow
	you to limit your search to specific areas of GitHub. The REST API supports the
	same qualifiers as GitHub.com. To learn more about the format of the query, see
	[Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query). See
	"[Searching code](https://help.github.com/articles/searching-code/)" for a
	detailed list of qualifiers.
	*/
	Q *string

	/*
	Sorts the results of your query. Can only be `indexed`, which indicates how
	recently a file has been indexed by the GitHub search infrastructure. Default:
	[best match](https://developer.github.com/v3/search/#ranking-search-results)
	*/
	Sort *string

	/*
	Determines whether the first search result returned is the highest number of
	matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored
	unless you provide `sort`.
	*/
	Order *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CodeReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Order != nil {
		query.Set("order", *r.Order)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/search/code"),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CodeReq) Rel(link string, resp *CodeResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CodeResponseBody is a response body for Code

https://developer.github.com/v3/search/#search-code
*/
type CodeResponseBody struct {
	IncompleteResults bool                              `json:"incomplete_results,omitempty"`
	Items             []components.CodeSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                             `json:"total_count,omitempty"`
}

/*
CodeResponse is a response for Code

https://developer.github.com/v3/search/#search-code
*/
type CodeResponse struct {
	httpResponse *http.Response
	Data         CodeResponseBody
}

// HTTPResponse returns the *http.Response
func (r *CodeResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// Load loads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CodeResponse) Load(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
Commits performs requests for "search/commits"

Search commits.

  GET /search/commits

https://developer.github.com/v3/search/#search-commits
*/
func Commits(ctx context.Context, req *CommitsReq, opt ...requests.Option) (*CommitsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CommitsReq)
	}
	resp := &CommitsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.Load(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Commits performs requests for "search/commits"

Search commits.

  GET /search/commits

https://developer.github.com/v3/search/#search-commits

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Commits(ctx context.Context, req *CommitsReq, opt ...requests.Option) (*CommitsResponse, error) {
	return Commits(ctx, req, append(c, opt...)...)
}

/*
CommitsReq is request data for Client.Commits

https://developer.github.com/v3/search/#search-commits

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CommitsReq struct {
	_url string

	/*
	The query contains one or more search keywords and qualifiers. Qualifiers allow
	you to limit your search to specific areas of GitHub. The REST API supports the
	same qualifiers as GitHub.com. To learn more about the format of the query, see
	[Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query). See
	"[Searching commits](https://help.github.com/articles/searching-commits/)" for a
	detailed list of qualifiers.
	*/
	Q *string

	/*
	Sorts the results of your query by `author-date` or `committer-date`. Default:
	[best match](https://developer.github.com/v3/search/#ranking-search-results)
	*/
	Sort *string

	/*
	Determines whether the first search result returned is the highest number of
	matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored
	unless you provide `sort`.
	*/
	Order *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Commit Search API is currently available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog post](https://developer.github.com/changes/2017-01-05-commit-search-api/)
	for full details.

	To access the API you must set this to true.
	*/
	CloakPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CommitsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Order != nil {
		query.Set("order", *r.Order)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{"cloak"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{"cloak": r.CloakPreview},
		RequiredPreviews:   []string{"cloak"},
		URLPath:            fmt.Sprintf("/search/commits"),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CommitsReq) Rel(link string, resp *CommitsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CommitsResponseBody is a response body for Commits

https://developer.github.com/v3/search/#search-commits
*/
type CommitsResponseBody struct {
	IncompleteResults bool                                `json:"incomplete_results,omitempty"`
	Items             []components.CommitSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                               `json:"total_count,omitempty"`
}

/*
CommitsResponse is a response for Commits

https://developer.github.com/v3/search/#search-commits
*/
type CommitsResponse struct {
	httpResponse *http.Response
	Data         CommitsResponseBody
}

// HTTPResponse returns the *http.Response
func (r *CommitsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// Load loads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CommitsResponse) Load(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
IssuesAndPullRequests performs requests for "search/issues-and-pull-requests"

Search issues and pull requests.

  GET /search/issues

https://developer.github.com/v3/search/#search-issues-and-pull-requests
*/
func IssuesAndPullRequests(ctx context.Context, req *IssuesAndPullRequestsReq, opt ...requests.Option) (*IssuesAndPullRequestsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(IssuesAndPullRequestsReq)
	}
	resp := &IssuesAndPullRequestsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.Load(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesAndPullRequests performs requests for "search/issues-and-pull-requests"

Search issues and pull requests.

  GET /search/issues

https://developer.github.com/v3/search/#search-issues-and-pull-requests

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) IssuesAndPullRequests(ctx context.Context, req *IssuesAndPullRequestsReq, opt ...requests.Option) (*IssuesAndPullRequestsResponse, error) {
	return IssuesAndPullRequests(ctx, req, append(c, opt...)...)
}

/*
IssuesAndPullRequestsReq is request data for Client.IssuesAndPullRequests

https://developer.github.com/v3/search/#search-issues-and-pull-requests

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type IssuesAndPullRequestsReq struct {
	_url string

	/*
	The query contains one or more search keywords and qualifiers. Qualifiers allow
	you to limit your search to specific areas of GitHub. The REST API supports the
	same qualifiers as GitHub.com. To learn more about the format of the query, see
	[Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query). See
	"[Searching issues and pull
	requests](https://help.github.com/articles/searching-issues-and-pull-requests/)"
	for a detailed list of qualifiers.
	*/
	Q *string

	/*
	Sorts the results of your query by the number of `comments`, `reactions`,
	`reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`,
	`reactions-heart`, `reactions-tada`, or `interactions`. You can also sort
	results by how recently the items were `created` or `updated`, Default: [best
	match](https://developer.github.com/v3/search/#ranking-search-results)
	*/
	Sort *string

	/*
	Determines whether the first search result returned is the highest number of
	matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored
	unless you provide `sort`.
	*/
	Order *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *IssuesAndPullRequestsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Order != nil {
		query.Set("order", *r.Order)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/search/issues"),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesAndPullRequestsReq) Rel(link string, resp *IssuesAndPullRequestsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesAndPullRequestsResponseBody is a response body for IssuesAndPullRequests

https://developer.github.com/v3/search/#search-issues-and-pull-requests
*/
type IssuesAndPullRequestsResponseBody struct {
	IncompleteResults bool                               `json:"incomplete_results,omitempty"`
	Items             []components.IssueSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                              `json:"total_count,omitempty"`
}

/*
IssuesAndPullRequestsResponse is a response for IssuesAndPullRequests

https://developer.github.com/v3/search/#search-issues-and-pull-requests
*/
type IssuesAndPullRequestsResponse struct {
	httpResponse *http.Response
	Data         IssuesAndPullRequestsResponseBody
}

// HTTPResponse returns the *http.Response
func (r *IssuesAndPullRequestsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// Load loads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *IssuesAndPullRequestsResponse) Load(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
Labels performs requests for "search/labels"

Search labels.

  GET /search/labels

https://developer.github.com/v3/search/#search-labels
*/
func Labels(ctx context.Context, req *LabelsReq, opt ...requests.Option) (*LabelsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(LabelsReq)
	}
	resp := &LabelsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.Load(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Labels performs requests for "search/labels"

Search labels.

  GET /search/labels

https://developer.github.com/v3/search/#search-labels

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Labels(ctx context.Context, req *LabelsReq, opt ...requests.Option) (*LabelsResponse, error) {
	return Labels(ctx, req, append(c, opt...)...)
}

/*
LabelsReq is request data for Client.Labels

https://developer.github.com/v3/search/#search-labels

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type LabelsReq struct {
	_url string

	// The id of the repository.
	RepositoryId *int64

	/*
	The search keywords. This endpoint does not accept qualifiers in the query. To
	learn more about the format of the query, see [Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query).
	*/
	Q *string

	/*
	Sorts the results of your query by when the label was `created` or `updated`.
	Default: [best
	match](https://developer.github.com/v3/search/#ranking-search-results)
	*/
	Sort *string

	/*
	Determines whether the first search result returned is the highest number of
	matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored
	unless you provide `sort`.
	*/
	Order *string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *LabelsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.RepositoryId != nil {
		query.Set("repository_id", strconv.FormatInt(*r.RepositoryId, 10))
	}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Order != nil {
		query.Set("order", *r.Order)
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/search/labels"),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *LabelsReq) Rel(link string, resp *LabelsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
LabelsResponseBody is a response body for Labels

https://developer.github.com/v3/search/#search-labels
*/
type LabelsResponseBody struct {
	IncompleteResults bool                               `json:"incomplete_results,omitempty"`
	Items             []components.LabelSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                              `json:"total_count,omitempty"`
}

/*
LabelsResponse is a response for Labels

https://developer.github.com/v3/search/#search-labels
*/
type LabelsResponse struct {
	httpResponse *http.Response
	Data         LabelsResponseBody
}

// HTTPResponse returns the *http.Response
func (r *LabelsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// Load loads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *LabelsResponse) Load(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
Repos performs requests for "search/repos"

Search repositories.

  GET /search/repositories

https://developer.github.com/v3/search/#search-repositories
*/
func Repos(ctx context.Context, req *ReposReq, opt ...requests.Option) (*ReposResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ReposReq)
	}
	resp := &ReposResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.Load(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Repos performs requests for "search/repos"

Search repositories.

  GET /search/repositories

https://developer.github.com/v3/search/#search-repositories

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Repos(ctx context.Context, req *ReposReq, opt ...requests.Option) (*ReposResponse, error) {
	return Repos(ctx, req, append(c, opt...)...)
}

/*
ReposReq is request data for Client.Repos

https://developer.github.com/v3/search/#search-repositories

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ReposReq struct {
	_url string

	/*
	The query contains one or more search keywords and qualifiers. Qualifiers allow
	you to limit your search to specific areas of GitHub. The REST API supports the
	same qualifiers as GitHub.com. To learn more about the format of the query, see
	[Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query). See
	"[Searching for
	repositories](https://help.github.com/articles/searching-for-repositories/)" for
	a detailed list of qualifiers.
	*/
	Q *string

	/*
	Sorts the results of your query by number of `stars`, `forks`, or
	`help-wanted-issues` or how recently the items were `updated`. Default: [best
	match](https://developer.github.com/v3/search/#ranking-search-results)
	*/
	Sort *string

	/*
	Determines whether the first search result returned is the highest number of
	matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored
	unless you provide `sort`.
	*/
	Order *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ReposReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Order != nil {
		query.Set("order", *r.Order)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{"mercy"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{"mercy": r.MercyPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/search/repositories"),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposReq) Rel(link string, resp *ReposResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposResponseBody is a response body for Repos

https://developer.github.com/v3/search/#search-repositories
*/
type ReposResponseBody struct {
	IncompleteResults bool                              `json:"incomplete_results,omitempty"`
	Items             []components.RepoSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                             `json:"total_count,omitempty"`
}

/*
ReposResponse is a response for Repos

https://developer.github.com/v3/search/#search-repositories
*/
type ReposResponse struct {
	httpResponse *http.Response
	Data         ReposResponseBody
}

// HTTPResponse returns the *http.Response
func (r *ReposResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// Load loads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ReposResponse) Load(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
Topics performs requests for "search/topics"

Search topics.

  GET /search/topics

https://developer.github.com/v3/search/#search-topics
*/
func Topics(ctx context.Context, req *TopicsReq, opt ...requests.Option) (*TopicsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(TopicsReq)
	}
	resp := &TopicsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.Load(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Topics performs requests for "search/topics"

Search topics.

  GET /search/topics

https://developer.github.com/v3/search/#search-topics

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Topics(ctx context.Context, req *TopicsReq, opt ...requests.Option) (*TopicsResponse, error) {
	return Topics(ctx, req, append(c, opt...)...)
}

/*
TopicsReq is request data for Client.Topics

https://developer.github.com/v3/search/#search-topics

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type TopicsReq struct {
	_url string

	/*
	The query contains one or more search keywords and qualifiers. Qualifiers allow
	you to limit your search to specific areas of GitHub. The REST API supports the
	same qualifiers as GitHub.com. To learn more about the format of the query, see
	[Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query).
	*/
	Q *string

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *TopicsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{"mercy"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{"mercy": r.MercyPreview},
		RequiredPreviews:   []string{"mercy"},
		URLPath:            fmt.Sprintf("/search/topics"),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TopicsReq) Rel(link string, resp *TopicsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TopicsResponseBody is a response body for Topics

https://developer.github.com/v3/search/#search-topics
*/
type TopicsResponseBody struct {
	IncompleteResults bool                               `json:"incomplete_results,omitempty"`
	Items             []components.TopicSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                              `json:"total_count,omitempty"`
}

/*
TopicsResponse is a response for Topics

https://developer.github.com/v3/search/#search-topics
*/
type TopicsResponse struct {
	httpResponse *http.Response
	Data         TopicsResponseBody
}

// HTTPResponse returns the *http.Response
func (r *TopicsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// Load loads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *TopicsResponse) Load(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
Users performs requests for "search/users"

Search users.

  GET /search/users

https://developer.github.com/v3/search/#search-users
*/
func Users(ctx context.Context, req *UsersReq, opt ...requests.Option) (*UsersResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UsersReq)
	}
	resp := &UsersResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.Load(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Users performs requests for "search/users"

Search users.

  GET /search/users

https://developer.github.com/v3/search/#search-users

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Users(ctx context.Context, req *UsersReq, opt ...requests.Option) (*UsersResponse, error) {
	return Users(ctx, req, append(c, opt...)...)
}

/*
UsersReq is request data for Client.Users

https://developer.github.com/v3/search/#search-users

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UsersReq struct {
	_url string

	/*
	The query contains one or more search keywords and qualifiers. Qualifiers allow
	you to limit your search to specific areas of GitHub. The REST API supports the
	same qualifiers as GitHub.com. To learn more about the format of the query, see
	[Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query). See
	"[Searching users](https://help.github.com/articles/searching-users/)" for a
	detailed list of qualifiers.
	*/
	Q *string

	/*
	Sorts the results of your query by number of `followers` or `repositories`, or
	when the person `joined` GitHub. Default: [best
	match](https://developer.github.com/v3/search/#ranking-search-results)
	*/
	Sort *string

	/*
	Determines whether the first search result returned is the highest number of
	matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored
	unless you provide `sort`.
	*/
	Order *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UsersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Order != nil {
		query.Set("order", *r.Order)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/search/users"),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersReq) Rel(link string, resp *UsersResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersResponseBody is a response body for Users

https://developer.github.com/v3/search/#search-users
*/
type UsersResponseBody struct {
	IncompleteResults bool                              `json:"incomplete_results,omitempty"`
	Items             []components.UserSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                             `json:"total_count,omitempty"`
}

/*
UsersResponse is a response for Users

https://developer.github.com/v3/search/#search-users
*/
type UsersResponse struct {
	httpResponse *http.Response
	Data         UsersResponseBody
}

// HTTPResponse returns the *http.Response
func (r *UsersResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// Load loads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UsersResponse) Load(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}
