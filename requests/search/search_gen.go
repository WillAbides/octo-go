// Code generated by octo-go; DO NOT EDIT.

package search

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
Code performs requests for "search/code"

Search code.

  GET /search/code

https://developer.github.com/v3/search/#search-code
*/
func Code(ctx context.Context, req *CodeReq, opt ...requests.Option) (*CodeResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CodeReq)
	}
	resp := &CodeResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = CodeResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Code performs requests for "search/code"

Search code.

  GET /search/code

https://developer.github.com/v3/search/#search-code
*/
func (c Client) Code(ctx context.Context, req *CodeReq, opt ...requests.Option) (*CodeResponse, error) {
	return Code(ctx, req, append(c, opt...)...)
}

/*
CodeReq is request data for Client.Code

https://developer.github.com/v3/search/#search-code
*/
type CodeReq struct {
	_url string

	/*
	The query contains one or more search keywords and qualifiers. Qualifiers allow
	you to limit your search to specific areas of GitHub. The REST API supports the
	same qualifiers as GitHub.com. To learn more about the format of the query, see
	[Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query). See
	"[Searching code](https://help.github.com/articles/searching-code/)" for a
	detailed list of qualifiers.
	*/
	Q *string

	/*
	Sorts the results of your query. Can only be `indexed`, which indicates how
	recently a file has been indexed by the GitHub search infrastructure. Default:
	[best match](https://developer.github.com/v3/search/#ranking-search-results)
	*/
	Sort *string

	/*
	Determines whether the first search result returned is the highest number of
	matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored
	unless you provide `sort`.
	*/
	Order *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *CodeReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CodeReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Order != nil {
		query.Set("order", *r.Order)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "search/code",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/search/code"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CodeReq) Rel(link string, resp *CodeResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CodeResponseBody is a response body for Code

https://developer.github.com/v3/search/#search-code
*/
type CodeResponseBody struct {
	IncompleteResults bool                              `json:"incomplete_results,omitempty"`
	Items             []components.CodeSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                             `json:"total_count,omitempty"`
}

/*
CodeResponse is a response for Code

https://developer.github.com/v3/search/#search-code
*/
type CodeResponse struct {
	requests.Response
	request *CodeReq
	Data    CodeResponseBody
}

/*
Commits performs requests for "search/commits"

Search commits.

  GET /search/commits

https://developer.github.com/v3/search/#search-commits
*/
func Commits(ctx context.Context, req *CommitsReq, opt ...requests.Option) (*CommitsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CommitsReq)
	}
	resp := &CommitsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = CommitsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Commits performs requests for "search/commits"

Search commits.

  GET /search/commits

https://developer.github.com/v3/search/#search-commits
*/
func (c Client) Commits(ctx context.Context, req *CommitsReq, opt ...requests.Option) (*CommitsResponse, error) {
	return Commits(ctx, req, append(c, opt...)...)
}

/*
CommitsReq is request data for Client.Commits

https://developer.github.com/v3/search/#search-commits
*/
type CommitsReq struct {
	_url string

	/*
	The query contains one or more search keywords and qualifiers. Qualifiers allow
	you to limit your search to specific areas of GitHub. The REST API supports the
	same qualifiers as GitHub.com. To learn more about the format of the query, see
	[Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query). See
	"[Searching commits](https://help.github.com/articles/searching-commits/)" for a
	detailed list of qualifiers.
	*/
	Q *string

	/*
	Sorts the results of your query by `author-date` or `committer-date`. Default:
	[best match](https://developer.github.com/v3/search/#ranking-search-results)
	*/
	Sort *string

	/*
	Determines whether the first search result returned is the highest number of
	matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored
	unless you provide `sort`.
	*/
	Order *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Commit Search API is currently available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog post](https://developer.github.com/changes/2017-01-05-commit-search-api/)
	for full details.

	To access the API you must set this to true.
	*/
	CloakPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CommitsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CommitsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Order != nil {
		query.Set("order", *r.Order)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"cloak"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "search/commits",
		Previews:         map[string]bool{"cloak": r.CloakPreview},
		RequiredPreviews: []string{"cloak"},
		URLPath:          fmt.Sprintf("/search/commits"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CommitsReq) Rel(link string, resp *CommitsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CommitsResponseBody is a response body for Commits

https://developer.github.com/v3/search/#search-commits
*/
type CommitsResponseBody struct {
	IncompleteResults bool                                `json:"incomplete_results,omitempty"`
	Items             []components.CommitSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                               `json:"total_count,omitempty"`
}

/*
CommitsResponse is a response for Commits

https://developer.github.com/v3/search/#search-commits
*/
type CommitsResponse struct {
	requests.Response
	request *CommitsReq
	Data    CommitsResponseBody
}

/*
IssuesAndPullRequests performs requests for "search/issues-and-pull-requests"

Search issues and pull requests.

  GET /search/issues

https://developer.github.com/v3/search/#search-issues-and-pull-requests
*/
func IssuesAndPullRequests(ctx context.Context, req *IssuesAndPullRequestsReq, opt ...requests.Option) (*IssuesAndPullRequestsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesAndPullRequestsReq)
	}
	resp := &IssuesAndPullRequestsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = IssuesAndPullRequestsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesAndPullRequests performs requests for "search/issues-and-pull-requests"

Search issues and pull requests.

  GET /search/issues

https://developer.github.com/v3/search/#search-issues-and-pull-requests
*/
func (c Client) IssuesAndPullRequests(ctx context.Context, req *IssuesAndPullRequestsReq, opt ...requests.Option) (*IssuesAndPullRequestsResponse, error) {
	return IssuesAndPullRequests(ctx, req, append(c, opt...)...)
}

/*
IssuesAndPullRequestsReq is request data for Client.IssuesAndPullRequests

https://developer.github.com/v3/search/#search-issues-and-pull-requests
*/
type IssuesAndPullRequestsReq struct {
	_url string

	/*
	The query contains one or more search keywords and qualifiers. Qualifiers allow
	you to limit your search to specific areas of GitHub. The REST API supports the
	same qualifiers as GitHub.com. To learn more about the format of the query, see
	[Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query). See
	"[Searching issues and pull
	requests](https://help.github.com/articles/searching-issues-and-pull-requests/)"
	for a detailed list of qualifiers.
	*/
	Q *string

	/*
	Sorts the results of your query by the number of `comments`, `reactions`,
	`reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`,
	`reactions-heart`, `reactions-tada`, or `interactions`. You can also sort
	results by how recently the items were `created` or `updated`, Default: [best
	match](https://developer.github.com/v3/search/#ranking-search-results)
	*/
	Sort *string

	/*
	Determines whether the first search result returned is the highest number of
	matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored
	unless you provide `sort`.
	*/
	Order *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *IssuesAndPullRequestsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesAndPullRequestsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Order != nil {
		query.Set("order", *r.Order)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "search/issues-and-pull-requests",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/search/issues"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesAndPullRequestsReq) Rel(link string, resp *IssuesAndPullRequestsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesAndPullRequestsResponseBody is a response body for IssuesAndPullRequests

https://developer.github.com/v3/search/#search-issues-and-pull-requests
*/
type IssuesAndPullRequestsResponseBody struct {
	IncompleteResults bool                               `json:"incomplete_results,omitempty"`
	Items             []components.IssueSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                              `json:"total_count,omitempty"`
}

/*
IssuesAndPullRequestsResponse is a response for IssuesAndPullRequests

https://developer.github.com/v3/search/#search-issues-and-pull-requests
*/
type IssuesAndPullRequestsResponse struct {
	requests.Response
	request *IssuesAndPullRequestsReq
	Data    IssuesAndPullRequestsResponseBody
}

/*
Labels performs requests for "search/labels"

Search labels.

  GET /search/labels

https://developer.github.com/v3/search/#search-labels
*/
func Labels(ctx context.Context, req *LabelsReq, opt ...requests.Option) (*LabelsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(LabelsReq)
	}
	resp := &LabelsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = LabelsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Labels performs requests for "search/labels"

Search labels.

  GET /search/labels

https://developer.github.com/v3/search/#search-labels
*/
func (c Client) Labels(ctx context.Context, req *LabelsReq, opt ...requests.Option) (*LabelsResponse, error) {
	return Labels(ctx, req, append(c, opt...)...)
}

/*
LabelsReq is request data for Client.Labels

https://developer.github.com/v3/search/#search-labels
*/
type LabelsReq struct {
	_url string

	// The id of the repository.
	RepositoryId *int64

	/*
	The search keywords. This endpoint does not accept qualifiers in the query. To
	learn more about the format of the query, see [Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query).
	*/
	Q *string

	/*
	Sorts the results of your query by when the label was `created` or `updated`.
	Default: [best
	match](https://developer.github.com/v3/search/#ranking-search-results)
	*/
	Sort *string

	/*
	Determines whether the first search result returned is the highest number of
	matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored
	unless you provide `sort`.
	*/
	Order *string
}

// HTTPRequest builds an *http.Request
func (r *LabelsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *LabelsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.RepositoryId != nil {
		query.Set("repository_id", strconv.FormatInt(*r.RepositoryId, 10))
	}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Order != nil {
		query.Set("order", *r.Order)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "search/labels",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/search/labels"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *LabelsReq) Rel(link string, resp *LabelsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
LabelsResponseBody is a response body for Labels

https://developer.github.com/v3/search/#search-labels
*/
type LabelsResponseBody struct {
	IncompleteResults bool                               `json:"incomplete_results,omitempty"`
	Items             []components.LabelSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                              `json:"total_count,omitempty"`
}

/*
LabelsResponse is a response for Labels

https://developer.github.com/v3/search/#search-labels
*/
type LabelsResponse struct {
	requests.Response
	request *LabelsReq
	Data    LabelsResponseBody
}

/*
Repos performs requests for "search/repos"

Search repositories.

  GET /search/repositories

https://developer.github.com/v3/search/#search-repositories
*/
func Repos(ctx context.Context, req *ReposReq, opt ...requests.Option) (*ReposResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ReposReq)
	}
	resp := &ReposResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ReposResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Repos performs requests for "search/repos"

Search repositories.

  GET /search/repositories

https://developer.github.com/v3/search/#search-repositories
*/
func (c Client) Repos(ctx context.Context, req *ReposReq, opt ...requests.Option) (*ReposResponse, error) {
	return Repos(ctx, req, append(c, opt...)...)
}

/*
ReposReq is request data for Client.Repos

https://developer.github.com/v3/search/#search-repositories
*/
type ReposReq struct {
	_url string

	/*
	The query contains one or more search keywords and qualifiers. Qualifiers allow
	you to limit your search to specific areas of GitHub. The REST API supports the
	same qualifiers as GitHub.com. To learn more about the format of the query, see
	[Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query). See
	"[Searching for
	repositories](https://help.github.com/articles/searching-for-repositories/)" for
	a detailed list of qualifiers.
	*/
	Q *string

	/*
	Sorts the results of your query by number of `stars`, `forks`, or
	`help-wanted-issues` or how recently the items were `updated`. Default: [best
	match](https://developer.github.com/v3/search/#ranking-search-results)
	*/
	Sort *string

	/*
	Determines whether the first search result returned is the highest number of
	matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored
	unless you provide `sort`.
	*/
	Order *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ReposReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ReposReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Order != nil {
		query.Set("order", *r.Order)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"mercy"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "search/repos",
		Previews:         map[string]bool{"mercy": r.MercyPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/search/repositories"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ReposReq) Rel(link string, resp *ReposResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ReposResponseBody is a response body for Repos

https://developer.github.com/v3/search/#search-repositories
*/
type ReposResponseBody struct {
	IncompleteResults bool                              `json:"incomplete_results,omitempty"`
	Items             []components.RepoSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                             `json:"total_count,omitempty"`
}

/*
ReposResponse is a response for Repos

https://developer.github.com/v3/search/#search-repositories
*/
type ReposResponse struct {
	requests.Response
	request *ReposReq
	Data    ReposResponseBody
}

/*
Topics performs requests for "search/topics"

Search topics.

  GET /search/topics

https://developer.github.com/v3/search/#search-topics
*/
func Topics(ctx context.Context, req *TopicsReq, opt ...requests.Option) (*TopicsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TopicsReq)
	}
	resp := &TopicsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = TopicsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Topics performs requests for "search/topics"

Search topics.

  GET /search/topics

https://developer.github.com/v3/search/#search-topics
*/
func (c Client) Topics(ctx context.Context, req *TopicsReq, opt ...requests.Option) (*TopicsResponse, error) {
	return Topics(ctx, req, append(c, opt...)...)
}

/*
TopicsReq is request data for Client.Topics

https://developer.github.com/v3/search/#search-topics
*/
type TopicsReq struct {
	_url string

	/*
	The query contains one or more search keywords and qualifiers. Qualifiers allow
	you to limit your search to specific areas of GitHub. The REST API supports the
	same qualifiers as GitHub.com. To learn more about the format of the query, see
	[Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query).
	*/
	Q *string

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TopicsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TopicsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"mercy"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "search/topics",
		Previews:         map[string]bool{"mercy": r.MercyPreview},
		RequiredPreviews: []string{"mercy"},
		URLPath:          fmt.Sprintf("/search/topics"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TopicsReq) Rel(link string, resp *TopicsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TopicsResponseBody is a response body for Topics

https://developer.github.com/v3/search/#search-topics
*/
type TopicsResponseBody struct {
	IncompleteResults bool                               `json:"incomplete_results,omitempty"`
	Items             []components.TopicSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                              `json:"total_count,omitempty"`
}

/*
TopicsResponse is a response for Topics

https://developer.github.com/v3/search/#search-topics
*/
type TopicsResponse struct {
	requests.Response
	request *TopicsReq
	Data    TopicsResponseBody
}

/*
Users performs requests for "search/users"

Search users.

  GET /search/users

https://developer.github.com/v3/search/#search-users
*/
func Users(ctx context.Context, req *UsersReq, opt ...requests.Option) (*UsersResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersReq)
	}
	resp := &UsersResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = UsersResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Users performs requests for "search/users"

Search users.

  GET /search/users

https://developer.github.com/v3/search/#search-users
*/
func (c Client) Users(ctx context.Context, req *UsersReq, opt ...requests.Option) (*UsersResponse, error) {
	return Users(ctx, req, append(c, opt...)...)
}

/*
UsersReq is request data for Client.Users

https://developer.github.com/v3/search/#search-users
*/
type UsersReq struct {
	_url string

	/*
	The query contains one or more search keywords and qualifiers. Qualifiers allow
	you to limit your search to specific areas of GitHub. The REST API supports the
	same qualifiers as GitHub.com. To learn more about the format of the query, see
	[Constructing a search
	query](https://developer.github.com/v3/search/#constructing-a-search-query). See
	"[Searching users](https://help.github.com/articles/searching-users/)" for a
	detailed list of qualifiers.
	*/
	Q *string

	/*
	Sorts the results of your query by number of `followers` or `repositories`, or
	when the person `joined` GitHub. Default: [best
	match](https://developer.github.com/v3/search/#ranking-search-results)
	*/
	Sort *string

	/*
	Determines whether the first search result returned is the highest number of
	matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored
	unless you provide `sort`.
	*/
	Order *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *UsersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Q != nil {
		query.Set("q", *r.Q)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Order != nil {
		query.Set("order", *r.Order)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "search/users",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/search/users"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersReq) Rel(link string, resp *UsersResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersResponseBody is a response body for Users

https://developer.github.com/v3/search/#search-users
*/
type UsersResponseBody struct {
	IncompleteResults bool                              `json:"incomplete_results,omitempty"`
	Items             []components.UserSearchResultItem `json:"items,omitempty"`
	TotalCount        int64                             `json:"total_count,omitempty"`
}

/*
UsersResponse is a response for Users

https://developer.github.com/v3/search/#search-users
*/
type UsersResponse struct {
	requests.Response
	request *UsersReq
	Data    UsersResponseBody
}
