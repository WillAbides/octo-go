// Code generated by octo-go; DO NOT EDIT.

package meta

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
Get performs requests for "meta/get"

Get GitHub meta information.

  GET /meta

https://developer.github.com/v3/meta/#get-github-meta-information
*/
func Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetReq)
	}
	resp := &GetResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetResponse(r, opts.PreserveResponseBody())
}

// NewGetResponse builds a new *GetResponse from an *http.Response
func NewGetResponse(resp *http.Response, preserveBody bool) (*GetResponse, error) {
	var result GetResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
Get performs requests for "meta/get"

Get GitHub meta information.

  GET /meta

https://developer.github.com/v3/meta/#get-github-meta-information
*/
func (c Client) Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	return Get(ctx, req, append(c, opt...)...)
}

/*
GetReq is request data for Client.Get

https://developer.github.com/v3/meta/#get-github-meta-information
*/
type GetReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *GetReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "meta/get",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/meta"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReq) Rel(link string, resp *GetResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetResponse is a response for Get

https://developer.github.com/v3/meta/#get-github-meta-information
*/
type GetResponse struct {
	httpResponse *http.Response
	Data         components.ApiOverview
}

func (r *GetResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetOctocat performs requests for "meta/get-octocat"

Get Octocat.

  GET /octocat

*/
func GetOctocat(ctx context.Context, req *GetOctocatReq, opt ...requests.Option) (*GetOctocatResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetOctocatReq)
	}
	resp := &GetOctocatResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetOctocatResponse(r, opts.PreserveResponseBody())
}

// NewGetOctocatResponse builds a new *GetOctocatResponse from an *http.Response
func NewGetOctocatResponse(resp *http.Response, preserveBody bool) (*GetOctocatResponse, error) {
	var result GetOctocatResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
GetOctocat performs requests for "meta/get-octocat"

Get Octocat.

  GET /octocat

*/
func (c Client) GetOctocat(ctx context.Context, req *GetOctocatReq, opt ...requests.Option) (*GetOctocatResponse, error) {
	return GetOctocat(ctx, req, append(c, opt...)...)
}

/*
GetOctocatReq is request data for Client.GetOctocat

*/
type GetOctocatReq struct {
	_url string

	// The words to show in Octocat's speech bubble
	S *string
}

// HTTPRequest builds an *http.Request
func (r *GetOctocatReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetOctocatReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.S != nil {
		query.Set("s", *r.S)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "meta/get-octocat",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/octocat"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetOctocatReq) Rel(link string, resp *GetOctocatResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetOctocatResponse is a response for GetOctocat

*/
type GetOctocatResponse struct {
	httpResponse *http.Response
}

func (r *GetOctocatResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetZen performs requests for "meta/get-zen"

Get the Zen of GitHub.

  GET /zen

*/
func GetZen(ctx context.Context, req *GetZenReq, opt ...requests.Option) (*GetZenResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetZenReq)
	}
	resp := &GetZenResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetZenResponse(r, opts.PreserveResponseBody())
}

// NewGetZenResponse builds a new *GetZenResponse from an *http.Response
func NewGetZenResponse(resp *http.Response, preserveBody bool) (*GetZenResponse, error) {
	var result GetZenResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
GetZen performs requests for "meta/get-zen"

Get the Zen of GitHub.

  GET /zen

*/
func (c Client) GetZen(ctx context.Context, req *GetZenReq, opt ...requests.Option) (*GetZenResponse, error) {
	return GetZen(ctx, req, append(c, opt...)...)
}

/*
GetZenReq is request data for Client.GetZen

*/
type GetZenReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *GetZenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetZenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "meta/get-zen",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/zen"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetZenReq) Rel(link string, resp *GetZenResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetZenResponse is a response for GetZen

*/
type GetZenResponse struct {
	httpResponse *http.Response
}

func (r *GetZenResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Root performs requests for "meta/root"

GitHub API Root.

  GET /

*/
func Root(ctx context.Context, req *RootReq, opt ...requests.Option) (*RootResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RootReq)
	}
	resp := &RootResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRootResponse(r, opts.PreserveResponseBody())
}

// NewRootResponse builds a new *RootResponse from an *http.Response
func NewRootResponse(resp *http.Response, preserveBody bool) (*RootResponse, error) {
	var result RootResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
Root performs requests for "meta/root"

GitHub API Root.

  GET /

*/
func (c Client) Root(ctx context.Context, req *RootReq, opt ...requests.Option) (*RootResponse, error) {
	return Root(ctx, req, append(c, opt...)...)
}

/*
RootReq is request data for Client.Root

*/
type RootReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *RootReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RootReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "meta/root",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RootReq) Rel(link string, resp *RootResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RootResponseBody is a response body for Root

*/
type RootResponseBody struct {
	AuthorizationsUrl                string `json:"authorizations_url"`
	CodeSearchUrl                    string `json:"code_search_url"`
	CommitSearchUrl                  string `json:"commit_search_url"`
	CurrentUserAuthorizationsHtmlUrl string `json:"current_user_authorizations_html_url"`
	CurrentUserRepositoriesUrl       string `json:"current_user_repositories_url"`
	CurrentUserUrl                   string `json:"current_user_url"`
	EmailsUrl                        string `json:"emails_url"`
	EmojisUrl                        string `json:"emojis_url"`
	EventsUrl                        string `json:"events_url"`
	FeedsUrl                         string `json:"feeds_url"`
	FollowersUrl                     string `json:"followers_url"`
	FollowingUrl                     string `json:"following_url"`
	GistsUrl                         string `json:"gists_url"`
	HubUrl                           string `json:"hub_url"`
	IssueSearchUrl                   string `json:"issue_search_url"`
	IssuesUrl                        string `json:"issues_url"`
	KeysUrl                          string `json:"keys_url"`
	LabelSearchUrl                   string `json:"label_search_url"`
	NotificationsUrl                 string `json:"notifications_url"`
	OrganizationRepositoriesUrl      string `json:"organization_repositories_url"`
	OrganizationTeamsUrl             string `json:"organization_teams_url"`
	OrganizationUrl                  string `json:"organization_url"`
	PublicGistsUrl                   string `json:"public_gists_url"`
	RateLimitUrl                     string `json:"rate_limit_url"`
	RepositorySearchUrl              string `json:"repository_search_url"`
	RepositoryUrl                    string `json:"repository_url"`
	StarredGistsUrl                  string `json:"starred_gists_url"`
	StarredUrl                       string `json:"starred_url"`
	TopicSearchUrl                   string `json:"topic_search_url,omitempty"`
	UserOrganizationsUrl             string `json:"user_organizations_url"`
	UserRepositoriesUrl              string `json:"user_repositories_url"`
	UserSearchUrl                    string `json:"user_search_url"`
	UserUrl                          string `json:"user_url"`
}

/*
RootResponse is a response for Root

*/
type RootResponse struct {
	httpResponse *http.Response
	Data         RootResponseBody
}

func (r *RootResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}
