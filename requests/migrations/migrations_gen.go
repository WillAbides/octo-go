// Code generated by octo-go; DO NOT EDIT.

package migrations

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
CancelImport performs requests for "migrations/cancel-import"

Cancel an import.

  DELETE /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
func CancelImport(ctx context.Context, req *CancelImportReq, opt ...requests.Option) (*CancelImportResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CancelImportReq)
	}
	resp := &CancelImportResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CancelImport performs requests for "migrations/cancel-import"

Cancel an import.

  DELETE /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CancelImport(ctx context.Context, req *CancelImportReq, opt ...requests.Option) (*CancelImportResponse, error) {
	return CancelImport(ctx, req, append(c, opt...)...)
}

/*
CancelImportReq is request data for Client.CancelImport

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CancelImportReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CancelImportReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CancelImportReq) Rel(link string, resp *CancelImportResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CancelImportResponse is a response for CancelImport

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
type CancelImportResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *CancelImportResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CancelImportResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteArchiveForAuthenticatedUser performs requests for "migrations/delete-archive-for-authenticated-user"

Delete a user migration archive.

  DELETE /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
func DeleteArchiveForAuthenticatedUser(ctx context.Context, req *DeleteArchiveForAuthenticatedUserReq, opt ...requests.Option) (*DeleteArchiveForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DeleteArchiveForAuthenticatedUserReq)
	}
	resp := &DeleteArchiveForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteArchiveForAuthenticatedUser performs requests for "migrations/delete-archive-for-authenticated-user"

Delete a user migration archive.

  DELETE /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) DeleteArchiveForAuthenticatedUser(ctx context.Context, req *DeleteArchiveForAuthenticatedUserReq, opt ...requests.Option) (*DeleteArchiveForAuthenticatedUserResponse, error) {
	return DeleteArchiveForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
DeleteArchiveForAuthenticatedUserReq is request data for Client.DeleteArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DeleteArchiveForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DeleteArchiveForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		Options:          opt,
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v/archive", r.MigrationId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteArchiveForAuthenticatedUserReq) Rel(link string, resp *DeleteArchiveForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteArchiveForAuthenticatedUserResponse is a response for DeleteArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
type DeleteArchiveForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *DeleteArchiveForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DeleteArchiveForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteArchiveForOrg performs requests for "migrations/delete-archive-for-org"

Delete an organization migration archive.

  DELETE /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
func DeleteArchiveForOrg(ctx context.Context, req *DeleteArchiveForOrgReq, opt ...requests.Option) (*DeleteArchiveForOrgResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DeleteArchiveForOrgReq)
	}
	resp := &DeleteArchiveForOrgResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteArchiveForOrg performs requests for "migrations/delete-archive-for-org"

Delete an organization migration archive.

  DELETE /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) DeleteArchiveForOrg(ctx context.Context, req *DeleteArchiveForOrgReq, opt ...requests.Option) (*DeleteArchiveForOrgResponse, error) {
	return DeleteArchiveForOrg(ctx, req, append(c, opt...)...)
}

/*
DeleteArchiveForOrgReq is request data for Client.DeleteArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DeleteArchiveForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DeleteArchiveForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		Options:          opt,
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v/archive", r.Org, r.MigrationId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteArchiveForOrgReq) Rel(link string, resp *DeleteArchiveForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteArchiveForOrgResponse is a response for DeleteArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
type DeleteArchiveForOrgResponse struct {
	httpResponse *http.Response
	Data         bool
}

// HTTPResponse returns the *http.Response
func (r *DeleteArchiveForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DeleteArchiveForOrgResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 404})
	if err != nil {
		return err
	}
	err = internal.SetBoolResult(resp, &r.Data)
	if err != nil {
		return err
	}
	return nil
}

/*
DownloadArchiveForOrg performs requests for "migrations/download-archive-for-org"

Download an organization migration archive.

  GET /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
func DownloadArchiveForOrg(ctx context.Context, req *DownloadArchiveForOrgReq, opt ...requests.Option) (*DownloadArchiveForOrgResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DownloadArchiveForOrgReq)
	}
	resp := &DownloadArchiveForOrgResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DownloadArchiveForOrg performs requests for "migrations/download-archive-for-org"

Download an organization migration archive.

  GET /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) DownloadArchiveForOrg(ctx context.Context, req *DownloadArchiveForOrgReq, opt ...requests.Option) (*DownloadArchiveForOrgResponse, error) {
	return DownloadArchiveForOrg(ctx, req, append(c, opt...)...)
}

/*
DownloadArchiveForOrgReq is request data for Client.DownloadArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DownloadArchiveForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DownloadArchiveForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v/archive", r.Org, r.MigrationId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DownloadArchiveForOrgReq) Rel(link string, resp *DownloadArchiveForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DownloadArchiveForOrgResponse is a response for DownloadArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
type DownloadArchiveForOrgResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *DownloadArchiveForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DownloadArchiveForOrgResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{302})
	if err != nil {
		return err
	}
	return nil
}

/*
GetArchiveForAuthenticatedUser performs requests for "migrations/get-archive-for-authenticated-user"

Download a user migration archive.

  GET /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
func GetArchiveForAuthenticatedUser(ctx context.Context, req *GetArchiveForAuthenticatedUserReq, opt ...requests.Option) (*GetArchiveForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetArchiveForAuthenticatedUserReq)
	}
	resp := &GetArchiveForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetArchiveForAuthenticatedUser performs requests for "migrations/get-archive-for-authenticated-user"

Download a user migration archive.

  GET /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetArchiveForAuthenticatedUser(ctx context.Context, req *GetArchiveForAuthenticatedUserReq, opt ...requests.Option) (*GetArchiveForAuthenticatedUserResponse, error) {
	return GetArchiveForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
GetArchiveForAuthenticatedUserReq is request data for Client.GetArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetArchiveForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetArchiveForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v/archive", r.MigrationId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetArchiveForAuthenticatedUserReq) Rel(link string, resp *GetArchiveForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetArchiveForAuthenticatedUserResponse is a response for GetArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
type GetArchiveForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *GetArchiveForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetArchiveForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{302, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
GetCommitAuthors performs requests for "migrations/get-commit-authors"

Get commit authors.

  GET /repos/{owner}/{repo}/import/authors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
func GetCommitAuthors(ctx context.Context, req *GetCommitAuthorsReq, opt ...requests.Option) (*GetCommitAuthorsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetCommitAuthorsReq)
	}
	resp := &GetCommitAuthorsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetCommitAuthors performs requests for "migrations/get-commit-authors"

Get commit authors.

  GET /repos/{owner}/{repo}/import/authors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetCommitAuthors(ctx context.Context, req *GetCommitAuthorsReq, opt ...requests.Option) (*GetCommitAuthorsResponse, error) {
	return GetCommitAuthors(ctx, req, append(c, opt...)...)
}

/*
GetCommitAuthorsReq is request data for Client.GetCommitAuthors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetCommitAuthorsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetCommitAuthorsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/import/authors", r.Owner, r.Repo),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCommitAuthorsReq) Rel(link string, resp *GetCommitAuthorsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCommitAuthorsResponse is a response for GetCommitAuthors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
type GetCommitAuthorsResponse struct {
	httpResponse *http.Response
	Data         []components.PorterAuthor
}

// HTTPResponse returns the *http.Response
func (r *GetCommitAuthorsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetCommitAuthorsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetImportStatus performs requests for "migrations/get-import-status"

Get an import status.

  GET /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
func GetImportStatus(ctx context.Context, req *GetImportStatusReq, opt ...requests.Option) (*GetImportStatusResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetImportStatusReq)
	}
	resp := &GetImportStatusResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetImportStatus performs requests for "migrations/get-import-status"

Get an import status.

  GET /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetImportStatus(ctx context.Context, req *GetImportStatusReq, opt ...requests.Option) (*GetImportStatusResponse, error) {
	return GetImportStatus(ctx, req, append(c, opt...)...)
}

/*
GetImportStatusReq is request data for Client.GetImportStatus

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetImportStatusReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetImportStatusReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetImportStatusReq) Rel(link string, resp *GetImportStatusResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetImportStatusResponse is a response for GetImportStatus

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
type GetImportStatusResponse struct {
	httpResponse *http.Response
	Data         components.Import
}

// HTTPResponse returns the *http.Response
func (r *GetImportStatusResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetImportStatusResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetLargeFiles performs requests for "migrations/get-large-files"

Get large files.

  GET /repos/{owner}/{repo}/import/large_files

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
func GetLargeFiles(ctx context.Context, req *GetLargeFilesReq, opt ...requests.Option) (*GetLargeFilesResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetLargeFilesReq)
	}
	resp := &GetLargeFilesResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetLargeFiles performs requests for "migrations/get-large-files"

Get large files.

  GET /repos/{owner}/{repo}/import/large_files

https://developer.github.com/v3/migrations/source_imports/#get-large-files

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetLargeFiles(ctx context.Context, req *GetLargeFilesReq, opt ...requests.Option) (*GetLargeFilesResponse, error) {
	return GetLargeFiles(ctx, req, append(c, opt...)...)
}

/*
GetLargeFilesReq is request data for Client.GetLargeFiles

https://developer.github.com/v3/migrations/source_imports/#get-large-files

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetLargeFilesReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetLargeFilesReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/import/large_files", r.Owner, r.Repo),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetLargeFilesReq) Rel(link string, resp *GetLargeFilesResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetLargeFilesResponse is a response for GetLargeFiles

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
type GetLargeFilesResponse struct {
	httpResponse *http.Response
	Data         []components.PorterLargeFile
}

// HTTPResponse returns the *http.Response
func (r *GetLargeFilesResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetLargeFilesResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetStatusForAuthenticatedUser performs requests for "migrations/get-status-for-authenticated-user"

Get a user migration status.

  GET /user/migrations/{migration_id}

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
func GetStatusForAuthenticatedUser(ctx context.Context, req *GetStatusForAuthenticatedUserReq, opt ...requests.Option) (*GetStatusForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetStatusForAuthenticatedUserReq)
	}
	resp := &GetStatusForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetStatusForAuthenticatedUser performs requests for "migrations/get-status-for-authenticated-user"

Get a user migration status.

  GET /user/migrations/{migration_id}

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetStatusForAuthenticatedUser(ctx context.Context, req *GetStatusForAuthenticatedUserReq, opt ...requests.Option) (*GetStatusForAuthenticatedUserResponse, error) {
	return GetStatusForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
GetStatusForAuthenticatedUserReq is request data for Client.GetStatusForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetStatusForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetStatusForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v", r.MigrationId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetStatusForAuthenticatedUserReq) Rel(link string, resp *GetStatusForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetStatusForAuthenticatedUserResponse is a response for GetStatusForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
type GetStatusForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         components.Migration
}

// HTTPResponse returns the *http.Response
func (r *GetStatusForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetStatusForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetStatusForOrg performs requests for "migrations/get-status-for-org"

Get an organization migration status.

  GET /orgs/{org}/migrations/{migration_id}

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
func GetStatusForOrg(ctx context.Context, req *GetStatusForOrgReq, opt ...requests.Option) (*GetStatusForOrgResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetStatusForOrgReq)
	}
	resp := &GetStatusForOrgResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetStatusForOrg performs requests for "migrations/get-status-for-org"

Get an organization migration status.

  GET /orgs/{org}/migrations/{migration_id}

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetStatusForOrg(ctx context.Context, req *GetStatusForOrgReq, opt ...requests.Option) (*GetStatusForOrgResponse, error) {
	return GetStatusForOrg(ctx, req, append(c, opt...)...)
}

/*
GetStatusForOrgReq is request data for Client.GetStatusForOrg

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetStatusForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetStatusForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v", r.Org, r.MigrationId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetStatusForOrgReq) Rel(link string, resp *GetStatusForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetStatusForOrgResponse is a response for GetStatusForOrg

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
type GetStatusForOrgResponse struct {
	httpResponse *http.Response
	Data         components.Migration
}

// HTTPResponse returns the *http.Response
func (r *GetStatusForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetStatusForOrgResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListForAuthenticatedUser performs requests for "migrations/list-for-authenticated-user"

List user migrations.

  GET /user/migrations

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
func ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListForAuthenticatedUserReq)
	}
	resp := &ListForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForAuthenticatedUser performs requests for "migrations/list-for-authenticated-user"

List user migrations.

  GET /user/migrations

https://developer.github.com/v3/migrations/users/#list-user-migrations

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	return ListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListForAuthenticatedUserReq is request data for Client.ListForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#list-user-migrations

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations"),
		URLQuery:         query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForAuthenticatedUserReq) Rel(link string, resp *ListForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForAuthenticatedUserResponse is a response for ListForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
type ListForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.Migration
}

// HTTPResponse returns the *http.Response
func (r *ListForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListForOrg performs requests for "migrations/list-for-org"

List organization migrations.

  GET /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
func ListForOrg(ctx context.Context, req *ListForOrgReq, opt ...requests.Option) (*ListForOrgResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListForOrgReq)
	}
	resp := &ListForOrgResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForOrg performs requests for "migrations/list-for-org"

List organization migrations.

  GET /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListForOrg(ctx context.Context, req *ListForOrgReq, opt ...requests.Option) (*ListForOrgResponse, error) {
	return ListForOrg(ctx, req, append(c, opt...)...)
}

/*
ListForOrgReq is request data for Client.ListForOrg

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations", r.Org),
		URLQuery:         query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForOrgReq) Rel(link string, resp *ListForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForOrgResponse is a response for ListForOrg

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
type ListForOrgResponse struct {
	httpResponse *http.Response
	Data         []components.Migration
}

// HTTPResponse returns the *http.Response
func (r *ListForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListForOrgResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListReposForOrg performs requests for "migrations/list-repos-for-org"

List repositories in an organization migration.

  GET /orgs/{org}/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
func ListReposForOrg(ctx context.Context, req *ListReposForOrgReq, opt ...requests.Option) (*ListReposForOrgResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReposForOrgReq)
	}
	resp := &ListReposForOrgResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposForOrg performs requests for "migrations/list-repos-for-org"

List repositories in an organization migration.

  GET /orgs/{org}/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListReposForOrg(ctx context.Context, req *ListReposForOrgReq, opt ...requests.Option) (*ListReposForOrgResponse, error) {
	return ListReposForOrg(ctx, req, append(c, opt...)...)
}

/*
ListReposForOrgReq is request data for Client.ListReposForOrg

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReposForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReposForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v/repositories", r.Org, r.MigrationId),
		URLQuery:         query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposForOrgReq) Rel(link string, resp *ListReposForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposForOrgResponse is a response for ListReposForOrg

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
type ListReposForOrgResponse struct {
	httpResponse *http.Response
	Data         []components.MinimalRepository
}

// HTTPResponse returns the *http.Response
func (r *ListReposForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListReposForOrgResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListReposForUser performs requests for "migrations/list-repos-for-user"

List repositories for a user migration.

  GET /user/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
func ListReposForUser(ctx context.Context, req *ListReposForUserReq, opt ...requests.Option) (*ListReposForUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReposForUserReq)
	}
	resp := &ListReposForUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposForUser performs requests for "migrations/list-repos-for-user"

List repositories for a user migration.

  GET /user/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListReposForUser(ctx context.Context, req *ListReposForUserReq, opt ...requests.Option) (*ListReposForUserResponse, error) {
	return ListReposForUser(ctx, req, append(c, opt...)...)
}

/*
ListReposForUserReq is request data for Client.ListReposForUser

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReposForUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReposForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v/repositories", r.MigrationId),
		URLQuery:         query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposForUserReq) Rel(link string, resp *ListReposForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposForUserResponse is a response for ListReposForUser

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
type ListReposForUserResponse struct {
	httpResponse *http.Response
	Data         []components.MinimalRepository
}

// HTTPResponse returns the *http.Response
func (r *ListReposForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListReposForUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
MapCommitAuthor performs requests for "migrations/map-commit-author"

Map a commit author.

  PATCH /repos/{owner}/{repo}/import/authors/{author_id}

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
func MapCommitAuthor(ctx context.Context, req *MapCommitAuthorReq, opt ...requests.Option) (*MapCommitAuthorResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(MapCommitAuthorReq)
	}
	resp := &MapCommitAuthorResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MapCommitAuthor performs requests for "migrations/map-commit-author"

Map a commit author.

  PATCH /repos/{owner}/{repo}/import/authors/{author_id}

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) MapCommitAuthor(ctx context.Context, req *MapCommitAuthorReq, opt ...requests.Option) (*MapCommitAuthorResponse, error) {
	return MapCommitAuthor(ctx, req, append(c, opt...)...)
}

/*
MapCommitAuthorReq is request data for Client.MapCommitAuthor

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type MapCommitAuthorReq struct {
	_url  string
	Owner string
	Repo  string

	// author_id parameter
	AuthorId    int64
	RequestBody MapCommitAuthorReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *MapCommitAuthorReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "PATCH",
		Options: opt,
		URLPath: fmt.Sprintf("/repos/%v/%v/import/authors/%v", r.Owner, r.Repo, r.AuthorId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MapCommitAuthorReq) Rel(link string, resp *MapCommitAuthorResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MapCommitAuthorReqBody is a request body for migrations/map-commit-author

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MapCommitAuthorReqBody struct {

	// The new Git author email.
	Email *string `json:"email,omitempty"`

	// The new Git author name.
	Name     *string `json:"name,omitempty"`
	RemoteId *string `json:"remote_id,omitempty"`
}

/*
MapCommitAuthorResponse is a response for MapCommitAuthor

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MapCommitAuthorResponse struct {
	httpResponse *http.Response
	Data         components.PorterAuthor
}

// HTTPResponse returns the *http.Response
func (r *MapCommitAuthorResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *MapCommitAuthorResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
SetLfsPreference performs requests for "migrations/set-lfs-preference"

Update Git LFS preference.

  PATCH /repos/{owner}/{repo}/import/lfs

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
func SetLfsPreference(ctx context.Context, req *SetLfsPreferenceReq, opt ...requests.Option) (*SetLfsPreferenceResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(SetLfsPreferenceReq)
	}
	resp := &SetLfsPreferenceResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetLfsPreference performs requests for "migrations/set-lfs-preference"

Update Git LFS preference.

  PATCH /repos/{owner}/{repo}/import/lfs

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) SetLfsPreference(ctx context.Context, req *SetLfsPreferenceReq, opt ...requests.Option) (*SetLfsPreferenceResponse, error) {
	return SetLfsPreference(ctx, req, append(c, opt...)...)
}

/*
SetLfsPreferenceReq is request data for Client.SetLfsPreference

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type SetLfsPreferenceReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody SetLfsPreferenceReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *SetLfsPreferenceReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "PATCH",
		Options: opt,
		URLPath: fmt.Sprintf("/repos/%v/%v/import/lfs", r.Owner, r.Repo),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetLfsPreferenceReq) Rel(link string, resp *SetLfsPreferenceResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetLfsPreferenceReqBody is a request body for migrations/set-lfs-preference

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
type SetLfsPreferenceReqBody struct {

	/*
	Can be one of `opt_in` (large files will be stored using Git LFS) or `opt_out`
	(large files will be removed during the import).
	*/
	UseLfs *string `json:"use_lfs"`
}

/*
SetLfsPreferenceResponse is a response for SetLfsPreference

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
type SetLfsPreferenceResponse struct {
	httpResponse *http.Response
	Data         components.Import
}

// HTTPResponse returns the *http.Response
func (r *SetLfsPreferenceResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *SetLfsPreferenceResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
StartForAuthenticatedUser performs requests for "migrations/start-for-authenticated-user"

Start a user migration.

  POST /user/migrations

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
func StartForAuthenticatedUser(ctx context.Context, req *StartForAuthenticatedUserReq, opt ...requests.Option) (*StartForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(StartForAuthenticatedUserReq)
	}
	resp := &StartForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
StartForAuthenticatedUser performs requests for "migrations/start-for-authenticated-user"

Start a user migration.

  POST /user/migrations

https://developer.github.com/v3/migrations/users/#start-a-user-migration

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) StartForAuthenticatedUser(ctx context.Context, req *StartForAuthenticatedUserReq, opt ...requests.Option) (*StartForAuthenticatedUserResponse, error) {
	return StartForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
StartForAuthenticatedUserReq is request data for Client.StartForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#start-a-user-migration

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type StartForAuthenticatedUserReq struct {
	_url        string
	RequestBody StartForAuthenticatedUserReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *StartForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "POST",
		Options: opt,
		URLPath: fmt.Sprintf("/user/migrations"),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StartForAuthenticatedUserReq) Rel(link string, resp *StartForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StartForAuthenticatedUserReqBody is a request body for migrations/start-for-authenticated-user

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type StartForAuthenticatedUserReqBody struct {

	// Exclude attributes from the API response to improve performance
	Exclude []string `json:"exclude,omitempty"`

	// Do not include attachments in the migration
	ExcludeAttachments *bool `json:"exclude_attachments,omitempty"`

	// Lock the repositories being migrated at the start of the migration
	LockRepositories *bool    `json:"lock_repositories,omitempty"`
	Repositories     []string `json:"repositories"`
}

/*
StartForAuthenticatedUserResponse is a response for StartForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type StartForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         components.Migration
}

// HTTPResponse returns the *http.Response
func (r *StartForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *StartForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{201, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
StartForOrg performs requests for "migrations/start-for-org"

Start an organization migration.

  POST /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
func StartForOrg(ctx context.Context, req *StartForOrgReq, opt ...requests.Option) (*StartForOrgResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(StartForOrgReq)
	}
	resp := &StartForOrgResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
StartForOrg performs requests for "migrations/start-for-org"

Start an organization migration.

  POST /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) StartForOrg(ctx context.Context, req *StartForOrgReq, opt ...requests.Option) (*StartForOrgResponse, error) {
	return StartForOrg(ctx, req, append(c, opt...)...)
}

/*
StartForOrgReq is request data for Client.StartForOrg

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type StartForOrgReq struct {
	_url        string
	Org         string
	RequestBody StartForOrgReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *StartForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "POST",
		Options: opt,
		URLPath: fmt.Sprintf("/orgs/%v/migrations", r.Org),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StartForOrgReq) Rel(link string, resp *StartForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StartForOrgReqBody is a request body for migrations/start-for-org

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type StartForOrgReqBody struct {
	Exclude []string `json:"exclude,omitempty"`

	// Indicates whether attachments should be excluded from the migration (to reduce migration archive file size).
	ExcludeAttachments *bool `json:"exclude_attachments,omitempty"`

	// Indicates whether repositories should be locked (to prevent manipulation) while migrating data.
	LockRepositories *bool `json:"lock_repositories,omitempty"`

	// A list of arrays indicating which repositories should be migrated.
	Repositories []string `json:"repositories"`
}

/*
StartForOrgResponse is a response for StartForOrg

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type StartForOrgResponse struct {
	httpResponse *http.Response
	Data         components.Migration
}

// HTTPResponse returns the *http.Response
func (r *StartForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *StartForOrgResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{201})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
StartImport performs requests for "migrations/start-import"

Start an import.

  PUT /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
func StartImport(ctx context.Context, req *StartImportReq, opt ...requests.Option) (*StartImportResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(StartImportReq)
	}
	resp := &StartImportResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
StartImport performs requests for "migrations/start-import"

Start an import.

  PUT /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#start-an-import

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) StartImport(ctx context.Context, req *StartImportReq, opt ...requests.Option) (*StartImportResponse, error) {
	return StartImport(ctx, req, append(c, opt...)...)
}

/*
StartImportReq is request data for Client.StartImport

https://developer.github.com/v3/migrations/source_imports/#start-an-import

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type StartImportReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody StartImportReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *StartImportReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "PUT",
		Options: opt,
		URLPath: fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StartImportReq) Rel(link string, resp *StartImportResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StartImportReqBody is a request body for migrations/start-import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type StartImportReqBody struct {

	// For a tfvc import, the name of the project that is being imported.
	TfvcProject *string `json:"tfvc_project,omitempty"`

	/*
	The originating VCS type. Can be one of `subversion`, `git`, `mercurial`, or
	`tfvc`. Please be aware that without this parameter, the import job will take
	additional time to detect the VCS type before beginning the import. This
	detection step will be reflected in the response.
	*/
	Vcs *string `json:"vcs,omitempty"`

	// If authentication is required, the password to provide to `vcs_url`.
	VcsPassword *string `json:"vcs_password,omitempty"`

	// The URL of the originating repository.
	VcsUrl *string `json:"vcs_url"`

	// If authentication is required, the username to provide to `vcs_url`.
	VcsUsername *string `json:"vcs_username,omitempty"`
}

/*
StartImportResponse is a response for StartImport

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type StartImportResponse struct {
	httpResponse *http.Response
	Data         components.Import
}

// HTTPResponse returns the *http.Response
func (r *StartImportResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *StartImportResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{201})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
UnlockRepoForAuthenticatedUser performs requests for "migrations/unlock-repo-for-authenticated-user"

Unlock a user repository.

  DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
func UnlockRepoForAuthenticatedUser(ctx context.Context, req *UnlockRepoForAuthenticatedUserReq, opt ...requests.Option) (*UnlockRepoForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UnlockRepoForAuthenticatedUserReq)
	}
	resp := &UnlockRepoForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UnlockRepoForAuthenticatedUser performs requests for "migrations/unlock-repo-for-authenticated-user"

Unlock a user repository.

  DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) UnlockRepoForAuthenticatedUser(ctx context.Context, req *UnlockRepoForAuthenticatedUserReq, opt ...requests.Option) (*UnlockRepoForAuthenticatedUserResponse, error) {
	return UnlockRepoForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
UnlockRepoForAuthenticatedUserReq is request data for Client.UnlockRepoForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UnlockRepoForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// repo_name parameter
	RepoName string

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UnlockRepoForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		Options:          opt,
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v/repos/%v/lock", r.MigrationId, r.RepoName),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnlockRepoForAuthenticatedUserReq) Rel(link string, resp *UnlockRepoForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnlockRepoForAuthenticatedUserResponse is a response for UnlockRepoForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
type UnlockRepoForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *UnlockRepoForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UnlockRepoForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
UnlockRepoForOrg performs requests for "migrations/unlock-repo-for-org"

Unlock an organization repository.

  DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
func UnlockRepoForOrg(ctx context.Context, req *UnlockRepoForOrgReq, opt ...requests.Option) (*UnlockRepoForOrgResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UnlockRepoForOrgReq)
	}
	resp := &UnlockRepoForOrgResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UnlockRepoForOrg performs requests for "migrations/unlock-repo-for-org"

Unlock an organization repository.

  DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) UnlockRepoForOrg(ctx context.Context, req *UnlockRepoForOrgReq, opt ...requests.Option) (*UnlockRepoForOrgResponse, error) {
	return UnlockRepoForOrg(ctx, req, append(c, opt...)...)
}

/*
UnlockRepoForOrgReq is request data for Client.UnlockRepoForOrg

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UnlockRepoForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// repo_name parameter
	RepoName string

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UnlockRepoForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		Options:          opt,
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v/repos/%v/lock", r.Org, r.MigrationId, r.RepoName),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnlockRepoForOrgReq) Rel(link string, resp *UnlockRepoForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnlockRepoForOrgResponse is a response for UnlockRepoForOrg

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
type UnlockRepoForOrgResponse struct {
	httpResponse *http.Response
	Data         bool
}

// HTTPResponse returns the *http.Response
func (r *UnlockRepoForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UnlockRepoForOrgResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 404})
	if err != nil {
		return err
	}
	err = internal.SetBoolResult(resp, &r.Data)
	if err != nil {
		return err
	}
	return nil
}

/*
UpdateImport performs requests for "migrations/update-import"

Update an import.

  PATCH /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
func UpdateImport(ctx context.Context, req *UpdateImportReq, opt ...requests.Option) (*UpdateImportResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UpdateImportReq)
	}
	resp := &UpdateImportResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateImport performs requests for "migrations/update-import"

Update an import.

  PATCH /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#update-an-import

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) UpdateImport(ctx context.Context, req *UpdateImportReq, opt ...requests.Option) (*UpdateImportResponse, error) {
	return UpdateImport(ctx, req, append(c, opt...)...)
}

/*
UpdateImportReq is request data for Client.UpdateImport

https://developer.github.com/v3/migrations/source_imports/#update-an-import

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UpdateImportReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody UpdateImportReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UpdateImportReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "PATCH",
		Options: opt,
		URLPath: fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateImportReq) Rel(link string, resp *UpdateImportResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateImportReqBody is a request body for migrations/update-import

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
type UpdateImportReqBody struct {
	TfvcProject *string `json:"tfvc_project,omitempty"`
	Vcs         *string `json:"vcs,omitempty"`

	// The password to provide to the originating repository.
	VcsPassword *string `json:"vcs_password,omitempty"`

	// The username to provide to the originating repository.
	VcsUsername *string `json:"vcs_username,omitempty"`
}

/*
UpdateImportResponse is a response for UpdateImport

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
type UpdateImportResponse struct {
	httpResponse *http.Response
	Data         components.Import
}

// HTTPResponse returns the *http.Response
func (r *UpdateImportResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UpdateImportResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}
