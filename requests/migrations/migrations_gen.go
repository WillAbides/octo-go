// Code generated by octo-go; DO NOT EDIT.

package migrations

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

// Apply implements options.Option
func (c Client) Apply(opts *requests.Options) error {
	for _, o := range c {
		err := o.Apply(opts)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
CancelImport performs requests for "migrations/cancel-import"

Cancel an import.

  DELETE /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
func CancelImport(ctx context.Context, req *CancelImportReq, opt ...requests.Option) (*CancelImportResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CancelImportReq)
	}
	resp := &CancelImportResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CancelImport performs requests for "migrations/cancel-import"

Cancel an import.

  DELETE /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
func (c Client) CancelImport(ctx context.Context, req *CancelImportReq, opt ...requests.Option) (*CancelImportResponse, error) {
	return CancelImport(ctx, req, append(c, opt...)...)
}

/*
CancelImportReq is request data for Client.CancelImport

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
type CancelImportReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *CancelImportReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CancelImportReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "migrations/cancel-import",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CancelImportReq) Rel(link string, resp *CancelImportResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CancelImportResponse is a response for CancelImport

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
type CancelImportResponse struct {
	requests.Response
	request *CancelImportReq
}

/*
DeleteArchiveForAuthenticatedUser performs requests for "migrations/delete-archive-for-authenticated-user"

Delete a user migration archive.

  DELETE /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
func DeleteArchiveForAuthenticatedUser(ctx context.Context, req *DeleteArchiveForAuthenticatedUserReq, opt ...requests.Option) (*DeleteArchiveForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteArchiveForAuthenticatedUserReq)
	}
	resp := &DeleteArchiveForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteArchiveForAuthenticatedUser performs requests for "migrations/delete-archive-for-authenticated-user"

Delete a user migration archive.

  DELETE /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
func (c Client) DeleteArchiveForAuthenticatedUser(ctx context.Context, req *DeleteArchiveForAuthenticatedUserReq, opt ...requests.Option) (*DeleteArchiveForAuthenticatedUserResponse, error) {
	return DeleteArchiveForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
DeleteArchiveForAuthenticatedUserReq is request data for Client.DeleteArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
type DeleteArchiveForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteArchiveForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteArchiveForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "migrations/delete-archive-for-authenticated-user",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v/archive", r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteArchiveForAuthenticatedUserReq) Rel(link string, resp *DeleteArchiveForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteArchiveForAuthenticatedUserResponse is a response for DeleteArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
type DeleteArchiveForAuthenticatedUserResponse struct {
	requests.Response
	request *DeleteArchiveForAuthenticatedUserReq
}

/*
DeleteArchiveForOrg performs requests for "migrations/delete-archive-for-org"

Delete an organization migration archive.

  DELETE /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
func DeleteArchiveForOrg(ctx context.Context, req *DeleteArchiveForOrgReq, opt ...requests.Option) (*DeleteArchiveForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteArchiveForOrgReq)
	}
	resp := &DeleteArchiveForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteArchiveForOrg performs requests for "migrations/delete-archive-for-org"

Delete an organization migration archive.

  DELETE /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
func (c Client) DeleteArchiveForOrg(ctx context.Context, req *DeleteArchiveForOrgReq, opt ...requests.Option) (*DeleteArchiveForOrgResponse, error) {
	return DeleteArchiveForOrg(ctx, req, append(c, opt...)...)
}

/*
DeleteArchiveForOrgReq is request data for Client.DeleteArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
type DeleteArchiveForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteArchiveForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteArchiveForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "migrations/delete-archive-for-org",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v/archive", r.Org, r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteArchiveForOrgReq) Rel(link string, resp *DeleteArchiveForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteArchiveForOrgResponse is a response for DeleteArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
type DeleteArchiveForOrgResponse struct {
	requests.Response
	request *DeleteArchiveForOrgReq
	Data    bool
}

/*
DownloadArchiveForOrg performs requests for "migrations/download-archive-for-org"

Download an organization migration archive.

  GET /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
func DownloadArchiveForOrg(ctx context.Context, req *DownloadArchiveForOrgReq, opt ...requests.Option) (*DownloadArchiveForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DownloadArchiveForOrgReq)
	}
	resp := &DownloadArchiveForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DownloadArchiveForOrg performs requests for "migrations/download-archive-for-org"

Download an organization migration archive.

  GET /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
func (c Client) DownloadArchiveForOrg(ctx context.Context, req *DownloadArchiveForOrgReq, opt ...requests.Option) (*DownloadArchiveForOrgResponse, error) {
	return DownloadArchiveForOrg(ctx, req, append(c, opt...)...)
}

/*
DownloadArchiveForOrgReq is request data for Client.DownloadArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
type DownloadArchiveForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *DownloadArchiveForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DownloadArchiveForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "migrations/download-archive-for-org",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v/archive", r.Org, r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DownloadArchiveForOrgReq) Rel(link string, resp *DownloadArchiveForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DownloadArchiveForOrgResponse is a response for DownloadArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
type DownloadArchiveForOrgResponse struct {
	requests.Response
	request *DownloadArchiveForOrgReq
}

/*
GetArchiveForAuthenticatedUser performs requests for "migrations/get-archive-for-authenticated-user"

Download a user migration archive.

  GET /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
func GetArchiveForAuthenticatedUser(ctx context.Context, req *GetArchiveForAuthenticatedUserReq, opt ...requests.Option) (*GetArchiveForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetArchiveForAuthenticatedUserReq)
	}
	resp := &GetArchiveForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetArchiveForAuthenticatedUser performs requests for "migrations/get-archive-for-authenticated-user"

Download a user migration archive.

  GET /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
func (c Client) GetArchiveForAuthenticatedUser(ctx context.Context, req *GetArchiveForAuthenticatedUserReq, opt ...requests.Option) (*GetArchiveForAuthenticatedUserResponse, error) {
	return GetArchiveForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
GetArchiveForAuthenticatedUserReq is request data for Client.GetArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
type GetArchiveForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetArchiveForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetArchiveForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "migrations/get-archive-for-authenticated-user",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v/archive", r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{302, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetArchiveForAuthenticatedUserReq) Rel(link string, resp *GetArchiveForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetArchiveForAuthenticatedUserResponse is a response for GetArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
type GetArchiveForAuthenticatedUserResponse struct {
	requests.Response
	request *GetArchiveForAuthenticatedUserReq
}

/*
GetCommitAuthors performs requests for "migrations/get-commit-authors"

Get commit authors.

  GET /repos/{owner}/{repo}/import/authors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
func GetCommitAuthors(ctx context.Context, req *GetCommitAuthorsReq, opt ...requests.Option) (*GetCommitAuthorsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCommitAuthorsReq)
	}
	resp := &GetCommitAuthorsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.PorterAuthor{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetCommitAuthors performs requests for "migrations/get-commit-authors"

Get commit authors.

  GET /repos/{owner}/{repo}/import/authors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
func (c Client) GetCommitAuthors(ctx context.Context, req *GetCommitAuthorsReq, opt ...requests.Option) (*GetCommitAuthorsResponse, error) {
	return GetCommitAuthors(ctx, req, append(c, opt...)...)
}

/*
GetCommitAuthorsReq is request data for Client.GetCommitAuthors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
type GetCommitAuthorsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string
}

// HTTPRequest builds an *http.Request
func (r *GetCommitAuthorsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCommitAuthorsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/get-commit-authors",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import/authors", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCommitAuthorsReq) Rel(link string, resp *GetCommitAuthorsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCommitAuthorsResponse is a response for GetCommitAuthors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
type GetCommitAuthorsResponse struct {
	requests.Response
	request *GetCommitAuthorsReq
	Data    []components.PorterAuthor
}

/*
GetImportStatus performs requests for "migrations/get-import-status"

Get an import status.

  GET /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
func GetImportStatus(ctx context.Context, req *GetImportStatusReq, opt ...requests.Option) (*GetImportStatusResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetImportStatusReq)
	}
	resp := &GetImportStatusResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Import{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetImportStatus performs requests for "migrations/get-import-status"

Get an import status.

  GET /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
func (c Client) GetImportStatus(ctx context.Context, req *GetImportStatusReq, opt ...requests.Option) (*GetImportStatusResponse, error) {
	return GetImportStatus(ctx, req, append(c, opt...)...)
}

/*
GetImportStatusReq is request data for Client.GetImportStatus

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
type GetImportStatusReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetImportStatusReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetImportStatusReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/get-import-status",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetImportStatusReq) Rel(link string, resp *GetImportStatusResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetImportStatusResponse is a response for GetImportStatus

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
type GetImportStatusResponse struct {
	requests.Response
	request *GetImportStatusReq
	Data    components.Import
}

/*
GetLargeFiles performs requests for "migrations/get-large-files"

Get large files.

  GET /repos/{owner}/{repo}/import/large_files

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
func GetLargeFiles(ctx context.Context, req *GetLargeFilesReq, opt ...requests.Option) (*GetLargeFilesResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetLargeFilesReq)
	}
	resp := &GetLargeFilesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.PorterLargeFile{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetLargeFiles performs requests for "migrations/get-large-files"

Get large files.

  GET /repos/{owner}/{repo}/import/large_files

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
func (c Client) GetLargeFiles(ctx context.Context, req *GetLargeFilesReq, opt ...requests.Option) (*GetLargeFilesResponse, error) {
	return GetLargeFiles(ctx, req, append(c, opt...)...)
}

/*
GetLargeFilesReq is request data for Client.GetLargeFiles

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
type GetLargeFilesReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetLargeFilesReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetLargeFilesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/get-large-files",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import/large_files", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetLargeFilesReq) Rel(link string, resp *GetLargeFilesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetLargeFilesResponse is a response for GetLargeFiles

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
type GetLargeFilesResponse struct {
	requests.Response
	request *GetLargeFilesReq
	Data    []components.PorterLargeFile
}

/*
GetStatusForAuthenticatedUser performs requests for "migrations/get-status-for-authenticated-user"

Get a user migration status.

  GET /user/migrations/{migration_id}

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
func GetStatusForAuthenticatedUser(ctx context.Context, req *GetStatusForAuthenticatedUserReq, opt ...requests.Option) (*GetStatusForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetStatusForAuthenticatedUserReq)
	}
	resp := &GetStatusForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Migration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetStatusForAuthenticatedUser performs requests for "migrations/get-status-for-authenticated-user"

Get a user migration status.

  GET /user/migrations/{migration_id}

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
func (c Client) GetStatusForAuthenticatedUser(ctx context.Context, req *GetStatusForAuthenticatedUserReq, opt ...requests.Option) (*GetStatusForAuthenticatedUserResponse, error) {
	return GetStatusForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
GetStatusForAuthenticatedUserReq is request data for Client.GetStatusForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
type GetStatusForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetStatusForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetStatusForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/get-status-for-authenticated-user",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v", r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetStatusForAuthenticatedUserReq) Rel(link string, resp *GetStatusForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetStatusForAuthenticatedUserResponse is a response for GetStatusForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
type GetStatusForAuthenticatedUserResponse struct {
	requests.Response
	request *GetStatusForAuthenticatedUserReq
	Data    components.Migration
}

/*
GetStatusForOrg performs requests for "migrations/get-status-for-org"

Get an organization migration status.

  GET /orgs/{org}/migrations/{migration_id}

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
func GetStatusForOrg(ctx context.Context, req *GetStatusForOrgReq, opt ...requests.Option) (*GetStatusForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetStatusForOrgReq)
	}
	resp := &GetStatusForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Migration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetStatusForOrg performs requests for "migrations/get-status-for-org"

Get an organization migration status.

  GET /orgs/{org}/migrations/{migration_id}

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
func (c Client) GetStatusForOrg(ctx context.Context, req *GetStatusForOrgReq, opt ...requests.Option) (*GetStatusForOrgResponse, error) {
	return GetStatusForOrg(ctx, req, append(c, opt...)...)
}

/*
GetStatusForOrgReq is request data for Client.GetStatusForOrg

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
type GetStatusForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetStatusForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetStatusForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/get-status-for-org",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v", r.Org, r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetStatusForOrgReq) Rel(link string, resp *GetStatusForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetStatusForOrgResponse is a response for GetStatusForOrg

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
type GetStatusForOrgResponse struct {
	requests.Response
	request *GetStatusForOrgReq
	Data    components.Migration
}

/*
ListForAuthenticatedUser performs requests for "migrations/list-for-authenticated-user"

List user migrations.

  GET /user/migrations

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
func ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForAuthenticatedUserReq)
	}
	resp := &ListForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Migration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForAuthenticatedUser performs requests for "migrations/list-for-authenticated-user"

List user migrations.

  GET /user/migrations

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
func (c Client) ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	return ListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListForAuthenticatedUserReq is request data for Client.ListForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
type ListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/list-for-authenticated-user",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForAuthenticatedUserReq) Rel(link string, resp *ListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForAuthenticatedUserResponse is a response for ListForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
type ListForAuthenticatedUserResponse struct {
	requests.Response
	request *ListForAuthenticatedUserReq
	Data    []components.Migration
}

/*
ListForOrg performs requests for "migrations/list-for-org"

List organization migrations.

  GET /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
func ListForOrg(ctx context.Context, req *ListForOrgReq, opt ...requests.Option) (*ListForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForOrgReq)
	}
	resp := &ListForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Migration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForOrg performs requests for "migrations/list-for-org"

List organization migrations.

  GET /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
func (c Client) ListForOrg(ctx context.Context, req *ListForOrgReq, opt ...requests.Option) (*ListForOrgResponse, error) {
	return ListForOrg(ctx, req, append(c, opt...)...)
}

/*
ListForOrgReq is request data for Client.ListForOrg

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
type ListForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/list-for-org",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForOrgReq) Rel(link string, resp *ListForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForOrgResponse is a response for ListForOrg

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
type ListForOrgResponse struct {
	requests.Response
	request *ListForOrgReq
	Data    []components.Migration
}

/*
ListReposForOrg performs requests for "migrations/list-repos-for-org"

List repositories in an organization migration.

  GET /orgs/{org}/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
func ListReposForOrg(ctx context.Context, req *ListReposForOrgReq, opt ...requests.Option) (*ListReposForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposForOrgReq)
	}
	resp := &ListReposForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposForOrg performs requests for "migrations/list-repos-for-org"

List repositories in an organization migration.

  GET /orgs/{org}/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
func (c Client) ListReposForOrg(ctx context.Context, req *ListReposForOrgReq, opt ...requests.Option) (*ListReposForOrgResponse, error) {
	return ListReposForOrg(ctx, req, append(c, opt...)...)
}

/*
ListReposForOrgReq is request data for Client.ListReposForOrg

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
type ListReposForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListReposForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/list-repos-for-org",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v/repositories", r.Org, r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposForOrgReq) Rel(link string, resp *ListReposForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposForOrgResponse is a response for ListReposForOrg

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
type ListReposForOrgResponse struct {
	requests.Response
	request *ListReposForOrgReq
	Data    []components.MinimalRepository
}

/*
ListReposForUser performs requests for "migrations/list-repos-for-user"

List repositories for a user migration.

  GET /user/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
func ListReposForUser(ctx context.Context, req *ListReposForUserReq, opt ...requests.Option) (*ListReposForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposForUserReq)
	}
	resp := &ListReposForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposForUser performs requests for "migrations/list-repos-for-user"

List repositories for a user migration.

  GET /user/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
func (c Client) ListReposForUser(ctx context.Context, req *ListReposForUserReq, opt ...requests.Option) (*ListReposForUserResponse, error) {
	return ListReposForUser(ctx, req, append(c, opt...)...)
}

/*
ListReposForUserReq is request data for Client.ListReposForUser

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
type ListReposForUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListReposForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/list-repos-for-user",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v/repositories", r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposForUserReq) Rel(link string, resp *ListReposForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposForUserResponse is a response for ListReposForUser

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
type ListReposForUserResponse struct {
	requests.Response
	request *ListReposForUserReq
	Data    []components.MinimalRepository
}

/*
MapCommitAuthor performs requests for "migrations/map-commit-author"

Map a commit author.

  PATCH /repos/{owner}/{repo}/import/authors/{author_id}

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
func MapCommitAuthor(ctx context.Context, req *MapCommitAuthorReq, opt ...requests.Option) (*MapCommitAuthorResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MapCommitAuthorReq)
	}
	resp := &MapCommitAuthorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PorterAuthor{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MapCommitAuthor performs requests for "migrations/map-commit-author"

Map a commit author.

  PATCH /repos/{owner}/{repo}/import/authors/{author_id}

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
func (c Client) MapCommitAuthor(ctx context.Context, req *MapCommitAuthorReq, opt ...requests.Option) (*MapCommitAuthorResponse, error) {
	return MapCommitAuthor(ctx, req, append(c, opt...)...)
}

/*
MapCommitAuthorReq is request data for Client.MapCommitAuthor

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MapCommitAuthorReq struct {
	_url  string
	Owner string
	Repo  string

	// author_id parameter
	AuthorId    int64
	RequestBody MapCommitAuthorReqBody
}

// HTTPRequest builds an *http.Request
func (r *MapCommitAuthorReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MapCommitAuthorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "migrations/map-commit-author",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import/authors/%v", r.Owner, r.Repo, r.AuthorId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MapCommitAuthorReq) Rel(link string, resp *MapCommitAuthorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MapCommitAuthorReqBody is a request body for migrations/map-commit-author

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MapCommitAuthorReqBody struct {

	// The new Git author email.
	Email *string `json:"email,omitempty"`

	// The new Git author name.
	Name     *string `json:"name,omitempty"`
	RemoteId *string `json:"remote_id,omitempty"`
}

/*
MapCommitAuthorResponse is a response for MapCommitAuthor

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MapCommitAuthorResponse struct {
	requests.Response
	request *MapCommitAuthorReq
	Data    components.PorterAuthor
}

/*
SetLfsPreference performs requests for "migrations/set-lfs-preference"

Update Git LFS preference.

  PATCH /repos/{owner}/{repo}/import/lfs

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
func SetLfsPreference(ctx context.Context, req *SetLfsPreferenceReq, opt ...requests.Option) (*SetLfsPreferenceResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetLfsPreferenceReq)
	}
	resp := &SetLfsPreferenceResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Import{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetLfsPreference performs requests for "migrations/set-lfs-preference"

Update Git LFS preference.

  PATCH /repos/{owner}/{repo}/import/lfs

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
func (c Client) SetLfsPreference(ctx context.Context, req *SetLfsPreferenceReq, opt ...requests.Option) (*SetLfsPreferenceResponse, error) {
	return SetLfsPreference(ctx, req, append(c, opt...)...)
}

/*
SetLfsPreferenceReq is request data for Client.SetLfsPreference

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
type SetLfsPreferenceReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody SetLfsPreferenceReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetLfsPreferenceReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetLfsPreferenceReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "migrations/set-lfs-preference",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import/lfs", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetLfsPreferenceReq) Rel(link string, resp *SetLfsPreferenceResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetLfsPreferenceReqBody is a request body for migrations/set-lfs-preference

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
type SetLfsPreferenceReqBody struct {

	/*
	Can be one of `opt_in` (large files will be stored using Git LFS) or `opt_out`
	(large files will be removed during the import).
	*/
	UseLfs *string `json:"use_lfs"`
}

/*
SetLfsPreferenceResponse is a response for SetLfsPreference

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
type SetLfsPreferenceResponse struct {
	requests.Response
	request *SetLfsPreferenceReq
	Data    components.Import
}

/*
StartForAuthenticatedUser performs requests for "migrations/start-for-authenticated-user"

Start a user migration.

  POST /user/migrations

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
func StartForAuthenticatedUser(ctx context.Context, req *StartForAuthenticatedUserReq, opt ...requests.Option) (*StartForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(StartForAuthenticatedUserReq)
	}
	resp := &StartForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Migration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
StartForAuthenticatedUser performs requests for "migrations/start-for-authenticated-user"

Start a user migration.

  POST /user/migrations

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
func (c Client) StartForAuthenticatedUser(ctx context.Context, req *StartForAuthenticatedUserReq, opt ...requests.Option) (*StartForAuthenticatedUserResponse, error) {
	return StartForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
StartForAuthenticatedUserReq is request data for Client.StartForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type StartForAuthenticatedUserReq struct {
	_url        string
	RequestBody StartForAuthenticatedUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *StartForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *StartForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "migrations/start-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/migrations"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StartForAuthenticatedUserReq) Rel(link string, resp *StartForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StartForAuthenticatedUserReqBody is a request body for migrations/start-for-authenticated-user

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type StartForAuthenticatedUserReqBody struct {

	// Exclude attributes from the API response to improve performance
	Exclude []string `json:"exclude,omitempty"`

	// Do not include attachments in the migration
	ExcludeAttachments *bool `json:"exclude_attachments,omitempty"`

	// Lock the repositories being migrated at the start of the migration
	LockRepositories *bool    `json:"lock_repositories,omitempty"`
	Repositories     []string `json:"repositories"`
}

/*
StartForAuthenticatedUserResponse is a response for StartForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type StartForAuthenticatedUserResponse struct {
	requests.Response
	request *StartForAuthenticatedUserReq
	Data    components.Migration
}

/*
StartForOrg performs requests for "migrations/start-for-org"

Start an organization migration.

  POST /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
func StartForOrg(ctx context.Context, req *StartForOrgReq, opt ...requests.Option) (*StartForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(StartForOrgReq)
	}
	resp := &StartForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Migration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
StartForOrg performs requests for "migrations/start-for-org"

Start an organization migration.

  POST /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
func (c Client) StartForOrg(ctx context.Context, req *StartForOrgReq, opt ...requests.Option) (*StartForOrgResponse, error) {
	return StartForOrg(ctx, req, append(c, opt...)...)
}

/*
StartForOrgReq is request data for Client.StartForOrg

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type StartForOrgReq struct {
	_url        string
	Org         string
	RequestBody StartForOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *StartForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *StartForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "migrations/start-for-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StartForOrgReq) Rel(link string, resp *StartForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StartForOrgReqBody is a request body for migrations/start-for-org

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type StartForOrgReqBody struct {
	Exclude []string `json:"exclude,omitempty"`

	// Indicates whether attachments should be excluded from the migration (to reduce migration archive file size).
	ExcludeAttachments *bool `json:"exclude_attachments,omitempty"`

	// Indicates whether repositories should be locked (to prevent manipulation) while migrating data.
	LockRepositories *bool `json:"lock_repositories,omitempty"`

	// A list of arrays indicating which repositories should be migrated.
	Repositories []string `json:"repositories"`
}

/*
StartForOrgResponse is a response for StartForOrg

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type StartForOrgResponse struct {
	requests.Response
	request *StartForOrgReq
	Data    components.Migration
}

/*
StartImport performs requests for "migrations/start-import"

Start an import.

  PUT /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
func StartImport(ctx context.Context, req *StartImportReq, opt ...requests.Option) (*StartImportResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(StartImportReq)
	}
	resp := &StartImportResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Import{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
StartImport performs requests for "migrations/start-import"

Start an import.

  PUT /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
func (c Client) StartImport(ctx context.Context, req *StartImportReq, opt ...requests.Option) (*StartImportResponse, error) {
	return StartImport(ctx, req, append(c, opt...)...)
}

/*
StartImportReq is request data for Client.StartImport

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type StartImportReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody StartImportReqBody
}

// HTTPRequest builds an *http.Request
func (r *StartImportReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *StartImportReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "migrations/start-import",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StartImportReq) Rel(link string, resp *StartImportResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StartImportReqBody is a request body for migrations/start-import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type StartImportReqBody struct {

	// For a tfvc import, the name of the project that is being imported.
	TfvcProject *string `json:"tfvc_project,omitempty"`

	/*
	The originating VCS type. Can be one of `subversion`, `git`, `mercurial`, or
	`tfvc`. Please be aware that without this parameter, the import job will take
	additional time to detect the VCS type before beginning the import. This
	detection step will be reflected in the response.
	*/
	Vcs *string `json:"vcs,omitempty"`

	// If authentication is required, the password to provide to `vcs_url`.
	VcsPassword *string `json:"vcs_password,omitempty"`

	// The URL of the originating repository.
	VcsUrl *string `json:"vcs_url"`

	// If authentication is required, the username to provide to `vcs_url`.
	VcsUsername *string `json:"vcs_username,omitempty"`
}

/*
StartImportResponse is a response for StartImport

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type StartImportResponse struct {
	requests.Response
	request *StartImportReq
	Data    components.Import
}

/*
UnlockRepoForAuthenticatedUser performs requests for "migrations/unlock-repo-for-authenticated-user"

Unlock a user repository.

  DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
func UnlockRepoForAuthenticatedUser(ctx context.Context, req *UnlockRepoForAuthenticatedUserReq, opt ...requests.Option) (*UnlockRepoForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnlockRepoForAuthenticatedUserReq)
	}
	resp := &UnlockRepoForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UnlockRepoForAuthenticatedUser performs requests for "migrations/unlock-repo-for-authenticated-user"

Unlock a user repository.

  DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
func (c Client) UnlockRepoForAuthenticatedUser(ctx context.Context, req *UnlockRepoForAuthenticatedUserReq, opt ...requests.Option) (*UnlockRepoForAuthenticatedUserResponse, error) {
	return UnlockRepoForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
UnlockRepoForAuthenticatedUserReq is request data for Client.UnlockRepoForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
type UnlockRepoForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// repo_name parameter
	RepoName string

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *UnlockRepoForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnlockRepoForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "migrations/unlock-repo-for-authenticated-user",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v/repos/%v/lock", r.MigrationId, r.RepoName),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnlockRepoForAuthenticatedUserReq) Rel(link string, resp *UnlockRepoForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnlockRepoForAuthenticatedUserResponse is a response for UnlockRepoForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
type UnlockRepoForAuthenticatedUserResponse struct {
	requests.Response
	request *UnlockRepoForAuthenticatedUserReq
}

/*
UnlockRepoForOrg performs requests for "migrations/unlock-repo-for-org"

Unlock an organization repository.

  DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
func UnlockRepoForOrg(ctx context.Context, req *UnlockRepoForOrgReq, opt ...requests.Option) (*UnlockRepoForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnlockRepoForOrgReq)
	}
	resp := &UnlockRepoForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UnlockRepoForOrg performs requests for "migrations/unlock-repo-for-org"

Unlock an organization repository.

  DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
func (c Client) UnlockRepoForOrg(ctx context.Context, req *UnlockRepoForOrgReq, opt ...requests.Option) (*UnlockRepoForOrgResponse, error) {
	return UnlockRepoForOrg(ctx, req, append(c, opt...)...)
}

/*
UnlockRepoForOrgReq is request data for Client.UnlockRepoForOrg

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
type UnlockRepoForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// repo_name parameter
	RepoName string

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *UnlockRepoForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnlockRepoForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "migrations/unlock-repo-for-org",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v/repos/%v/lock", r.Org, r.MigrationId, r.RepoName),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnlockRepoForOrgReq) Rel(link string, resp *UnlockRepoForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnlockRepoForOrgResponse is a response for UnlockRepoForOrg

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
type UnlockRepoForOrgResponse struct {
	requests.Response
	request *UnlockRepoForOrgReq
	Data    bool
}

/*
UpdateImport performs requests for "migrations/update-import"

Update an import.

  PATCH /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
func UpdateImport(ctx context.Context, req *UpdateImportReq, opt ...requests.Option) (*UpdateImportResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateImportReq)
	}
	resp := &UpdateImportResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Import{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateImport performs requests for "migrations/update-import"

Update an import.

  PATCH /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
func (c Client) UpdateImport(ctx context.Context, req *UpdateImportReq, opt ...requests.Option) (*UpdateImportResponse, error) {
	return UpdateImport(ctx, req, append(c, opt...)...)
}

/*
UpdateImportReq is request data for Client.UpdateImport

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
type UpdateImportReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody UpdateImportReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateImportReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateImportReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "migrations/update-import",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateImportReq) Rel(link string, resp *UpdateImportResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateImportReqBody is a request body for migrations/update-import

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
type UpdateImportReqBody struct {
	TfvcProject *string `json:"tfvc_project,omitempty"`
	Vcs         *string `json:"vcs,omitempty"`

	// The password to provide to the originating repository.
	VcsPassword *string `json:"vcs_password,omitempty"`

	// The username to provide to the originating repository.
	VcsUsername *string `json:"vcs_username,omitempty"`
}

/*
UpdateImportResponse is a response for UpdateImport

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
type UpdateImportResponse struct {
	requests.Response
	request *UpdateImportReq
	Data    components.Import
}
