// Code generated by octo-go; DO NOT EDIT.

package migrations

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
CancelImport performs requests for "migrations/cancel-import"

Cancel an import.

  DELETE /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
func CancelImport(ctx context.Context, req *CancelImportReq, opt ...requests.Option) (*CancelImportResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CancelImportReq)
	}
	resp := &CancelImportResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCancelImportResponse(r, opts.PreserveResponseBody())
}

// NewCancelImportResponse builds a new *CancelImportResponse from an *http.Response
func NewCancelImportResponse(resp *http.Response, preserveBody bool) (*CancelImportResponse, error) {
	var result CancelImportResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CancelImport performs requests for "migrations/cancel-import"

Cancel an import.

  DELETE /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
func (c Client) CancelImport(ctx context.Context, req *CancelImportReq, opt ...requests.Option) (*CancelImportResponse, error) {
	return CancelImport(ctx, req, append(c, opt...)...)
}

/*
CancelImportReq is request data for Client.CancelImport

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
type CancelImportReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *CancelImportReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CancelImportReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "migrations/cancel-import",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CancelImportReq) Rel(link string, resp *CancelImportResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CancelImportResponse is a response for CancelImport

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
type CancelImportResponse struct {
	httpResponse *http.Response
}

func (r *CancelImportResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteArchiveForAuthenticatedUser performs requests for "migrations/delete-archive-for-authenticated-user"

Delete a user migration archive.

  DELETE /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
func DeleteArchiveForAuthenticatedUser(ctx context.Context, req *DeleteArchiveForAuthenticatedUserReq, opt ...requests.Option) (*DeleteArchiveForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteArchiveForAuthenticatedUserReq)
	}
	resp := &DeleteArchiveForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteArchiveForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewDeleteArchiveForAuthenticatedUserResponse builds a new *DeleteArchiveForAuthenticatedUserResponse from an *http.Response
func NewDeleteArchiveForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*DeleteArchiveForAuthenticatedUserResponse, error) {
	var result DeleteArchiveForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteArchiveForAuthenticatedUser performs requests for "migrations/delete-archive-for-authenticated-user"

Delete a user migration archive.

  DELETE /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
func (c Client) DeleteArchiveForAuthenticatedUser(ctx context.Context, req *DeleteArchiveForAuthenticatedUserReq, opt ...requests.Option) (*DeleteArchiveForAuthenticatedUserResponse, error) {
	return DeleteArchiveForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
DeleteArchiveForAuthenticatedUserReq is request data for Client.DeleteArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
type DeleteArchiveForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteArchiveForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteArchiveForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"wyandotte"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "migrations/delete-archive-for-authenticated-user",
		Previews:           map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews:   []string{"wyandotte"},
		URLPath:            fmt.Sprintf("/user/migrations/%v/archive", r.MigrationId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteArchiveForAuthenticatedUserReq) Rel(link string, resp *DeleteArchiveForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteArchiveForAuthenticatedUserResponse is a response for DeleteArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
type DeleteArchiveForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

func (r *DeleteArchiveForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteArchiveForOrg performs requests for "migrations/delete-archive-for-org"

Delete an organization migration archive.

  DELETE /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
func DeleteArchiveForOrg(ctx context.Context, req *DeleteArchiveForOrgReq, opt ...requests.Option) (*DeleteArchiveForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteArchiveForOrgReq)
	}
	resp := &DeleteArchiveForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteArchiveForOrgResponse(r, opts.PreserveResponseBody())
}

// NewDeleteArchiveForOrgResponse builds a new *DeleteArchiveForOrgResponse from an *http.Response
func NewDeleteArchiveForOrgResponse(resp *http.Response, preserveBody bool) (*DeleteArchiveForOrgResponse, error) {
	var result DeleteArchiveForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteArchiveForOrg performs requests for "migrations/delete-archive-for-org"

Delete an organization migration archive.

  DELETE /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
func (c Client) DeleteArchiveForOrg(ctx context.Context, req *DeleteArchiveForOrgReq, opt ...requests.Option) (*DeleteArchiveForOrgResponse, error) {
	return DeleteArchiveForOrg(ctx, req, append(c, opt...)...)
}

/*
DeleteArchiveForOrgReq is request data for Client.DeleteArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
type DeleteArchiveForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteArchiveForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteArchiveForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"wyandotte"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "migrations/delete-archive-for-org",
		Previews:           map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews:   []string{"wyandotte"},
		URLPath:            fmt.Sprintf("/orgs/%v/migrations/%v/archive", r.Org, r.MigrationId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteArchiveForOrgReq) Rel(link string, resp *DeleteArchiveForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteArchiveForOrgResponse is a response for DeleteArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
type DeleteArchiveForOrgResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *DeleteArchiveForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DownloadArchiveForOrg performs requests for "migrations/download-archive-for-org"

Download an organization migration archive.

  GET /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
func DownloadArchiveForOrg(ctx context.Context, req *DownloadArchiveForOrgReq, opt ...requests.Option) (*DownloadArchiveForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DownloadArchiveForOrgReq)
	}
	resp := &DownloadArchiveForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDownloadArchiveForOrgResponse(r, opts.PreserveResponseBody())
}

// NewDownloadArchiveForOrgResponse builds a new *DownloadArchiveForOrgResponse from an *http.Response
func NewDownloadArchiveForOrgResponse(resp *http.Response, preserveBody bool) (*DownloadArchiveForOrgResponse, error) {
	var result DownloadArchiveForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{302})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DownloadArchiveForOrg performs requests for "migrations/download-archive-for-org"

Download an organization migration archive.

  GET /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
func (c Client) DownloadArchiveForOrg(ctx context.Context, req *DownloadArchiveForOrgReq, opt ...requests.Option) (*DownloadArchiveForOrgResponse, error) {
	return DownloadArchiveForOrg(ctx, req, append(c, opt...)...)
}

/*
DownloadArchiveForOrgReq is request data for Client.DownloadArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
type DownloadArchiveForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *DownloadArchiveForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DownloadArchiveForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"wyandotte"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "migrations/download-archive-for-org",
		Previews:           map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews:   []string{"wyandotte"},
		URLPath:            fmt.Sprintf("/orgs/%v/migrations/%v/archive", r.Org, r.MigrationId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DownloadArchiveForOrgReq) Rel(link string, resp *DownloadArchiveForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DownloadArchiveForOrgResponse is a response for DownloadArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
type DownloadArchiveForOrgResponse struct {
	httpResponse *http.Response
}

func (r *DownloadArchiveForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetArchiveForAuthenticatedUser performs requests for "migrations/get-archive-for-authenticated-user"

Download a user migration archive.

  GET /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
func GetArchiveForAuthenticatedUser(ctx context.Context, req *GetArchiveForAuthenticatedUserReq, opt ...requests.Option) (*GetArchiveForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetArchiveForAuthenticatedUserReq)
	}
	resp := &GetArchiveForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetArchiveForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewGetArchiveForAuthenticatedUserResponse builds a new *GetArchiveForAuthenticatedUserResponse from an *http.Response
func NewGetArchiveForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*GetArchiveForAuthenticatedUserResponse, error) {
	var result GetArchiveForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{302, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
GetArchiveForAuthenticatedUser performs requests for "migrations/get-archive-for-authenticated-user"

Download a user migration archive.

  GET /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
func (c Client) GetArchiveForAuthenticatedUser(ctx context.Context, req *GetArchiveForAuthenticatedUserReq, opt ...requests.Option) (*GetArchiveForAuthenticatedUserResponse, error) {
	return GetArchiveForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
GetArchiveForAuthenticatedUserReq is request data for Client.GetArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
type GetArchiveForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetArchiveForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetArchiveForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"wyandotte"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "migrations/get-archive-for-authenticated-user",
		Previews:           map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews:   []string{"wyandotte"},
		URLPath:            fmt.Sprintf("/user/migrations/%v/archive", r.MigrationId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetArchiveForAuthenticatedUserReq) Rel(link string, resp *GetArchiveForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetArchiveForAuthenticatedUserResponse is a response for GetArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
type GetArchiveForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

func (r *GetArchiveForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetCommitAuthors performs requests for "migrations/get-commit-authors"

Get commit authors.

  GET /repos/{owner}/{repo}/import/authors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
func GetCommitAuthors(ctx context.Context, req *GetCommitAuthorsReq, opt ...requests.Option) (*GetCommitAuthorsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCommitAuthorsReq)
	}
	resp := &GetCommitAuthorsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetCommitAuthorsResponse(r, opts.PreserveResponseBody())
}

// NewGetCommitAuthorsResponse builds a new *GetCommitAuthorsResponse from an *http.Response
func NewGetCommitAuthorsResponse(resp *http.Response, preserveBody bool) (*GetCommitAuthorsResponse, error) {
	var result GetCommitAuthorsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetCommitAuthors performs requests for "migrations/get-commit-authors"

Get commit authors.

  GET /repos/{owner}/{repo}/import/authors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
func (c Client) GetCommitAuthors(ctx context.Context, req *GetCommitAuthorsReq, opt ...requests.Option) (*GetCommitAuthorsResponse, error) {
	return GetCommitAuthors(ctx, req, append(c, opt...)...)
}

/*
GetCommitAuthorsReq is request data for Client.GetCommitAuthors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
type GetCommitAuthorsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string
}

// HTTPRequest builds an *http.Request
func (r *GetCommitAuthorsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCommitAuthorsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "migrations/get-commit-authors",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/import/authors", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCommitAuthorsReq) Rel(link string, resp *GetCommitAuthorsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCommitAuthorsResponse is a response for GetCommitAuthors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
type GetCommitAuthorsResponse struct {
	httpResponse *http.Response
	Data         []components.PorterAuthor
}

func (r *GetCommitAuthorsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetImportStatus performs requests for "migrations/get-import-status"

Get an import status.

  GET /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
func GetImportStatus(ctx context.Context, req *GetImportStatusReq, opt ...requests.Option) (*GetImportStatusResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetImportStatusReq)
	}
	resp := &GetImportStatusResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetImportStatusResponse(r, opts.PreserveResponseBody())
}

// NewGetImportStatusResponse builds a new *GetImportStatusResponse from an *http.Response
func NewGetImportStatusResponse(resp *http.Response, preserveBody bool) (*GetImportStatusResponse, error) {
	var result GetImportStatusResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetImportStatus performs requests for "migrations/get-import-status"

Get an import status.

  GET /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
func (c Client) GetImportStatus(ctx context.Context, req *GetImportStatusReq, opt ...requests.Option) (*GetImportStatusResponse, error) {
	return GetImportStatus(ctx, req, append(c, opt...)...)
}

/*
GetImportStatusReq is request data for Client.GetImportStatus

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
type GetImportStatusReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetImportStatusReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetImportStatusReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "migrations/get-import-status",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetImportStatusReq) Rel(link string, resp *GetImportStatusResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetImportStatusResponse is a response for GetImportStatus

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
type GetImportStatusResponse struct {
	httpResponse *http.Response
	Data         components.Import
}

func (r *GetImportStatusResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetLargeFiles performs requests for "migrations/get-large-files"

Get large files.

  GET /repos/{owner}/{repo}/import/large_files

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
func GetLargeFiles(ctx context.Context, req *GetLargeFilesReq, opt ...requests.Option) (*GetLargeFilesResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetLargeFilesReq)
	}
	resp := &GetLargeFilesResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetLargeFilesResponse(r, opts.PreserveResponseBody())
}

// NewGetLargeFilesResponse builds a new *GetLargeFilesResponse from an *http.Response
func NewGetLargeFilesResponse(resp *http.Response, preserveBody bool) (*GetLargeFilesResponse, error) {
	var result GetLargeFilesResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetLargeFiles performs requests for "migrations/get-large-files"

Get large files.

  GET /repos/{owner}/{repo}/import/large_files

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
func (c Client) GetLargeFiles(ctx context.Context, req *GetLargeFilesReq, opt ...requests.Option) (*GetLargeFilesResponse, error) {
	return GetLargeFiles(ctx, req, append(c, opt...)...)
}

/*
GetLargeFilesReq is request data for Client.GetLargeFiles

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
type GetLargeFilesReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetLargeFilesReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetLargeFilesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "migrations/get-large-files",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/import/large_files", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetLargeFilesReq) Rel(link string, resp *GetLargeFilesResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetLargeFilesResponse is a response for GetLargeFiles

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
type GetLargeFilesResponse struct {
	httpResponse *http.Response
	Data         []components.PorterLargeFile
}

func (r *GetLargeFilesResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetStatusForAuthenticatedUser performs requests for "migrations/get-status-for-authenticated-user"

Get a user migration status.

  GET /user/migrations/{migration_id}

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
func GetStatusForAuthenticatedUser(ctx context.Context, req *GetStatusForAuthenticatedUserReq, opt ...requests.Option) (*GetStatusForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetStatusForAuthenticatedUserReq)
	}
	resp := &GetStatusForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetStatusForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewGetStatusForAuthenticatedUserResponse builds a new *GetStatusForAuthenticatedUserResponse from an *http.Response
func NewGetStatusForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*GetStatusForAuthenticatedUserResponse, error) {
	var result GetStatusForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetStatusForAuthenticatedUser performs requests for "migrations/get-status-for-authenticated-user"

Get a user migration status.

  GET /user/migrations/{migration_id}

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
func (c Client) GetStatusForAuthenticatedUser(ctx context.Context, req *GetStatusForAuthenticatedUserReq, opt ...requests.Option) (*GetStatusForAuthenticatedUserResponse, error) {
	return GetStatusForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
GetStatusForAuthenticatedUserReq is request data for Client.GetStatusForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
type GetStatusForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetStatusForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetStatusForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"wyandotte"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "migrations/get-status-for-authenticated-user",
		Previews:           map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews:   []string{"wyandotte"},
		URLPath:            fmt.Sprintf("/user/migrations/%v", r.MigrationId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetStatusForAuthenticatedUserReq) Rel(link string, resp *GetStatusForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetStatusForAuthenticatedUserResponse is a response for GetStatusForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
type GetStatusForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         components.Migration
}

func (r *GetStatusForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetStatusForOrg performs requests for "migrations/get-status-for-org"

Get an organization migration status.

  GET /orgs/{org}/migrations/{migration_id}

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
func GetStatusForOrg(ctx context.Context, req *GetStatusForOrgReq, opt ...requests.Option) (*GetStatusForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetStatusForOrgReq)
	}
	resp := &GetStatusForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetStatusForOrgResponse(r, opts.PreserveResponseBody())
}

// NewGetStatusForOrgResponse builds a new *GetStatusForOrgResponse from an *http.Response
func NewGetStatusForOrgResponse(resp *http.Response, preserveBody bool) (*GetStatusForOrgResponse, error) {
	var result GetStatusForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetStatusForOrg performs requests for "migrations/get-status-for-org"

Get an organization migration status.

  GET /orgs/{org}/migrations/{migration_id}

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
func (c Client) GetStatusForOrg(ctx context.Context, req *GetStatusForOrgReq, opt ...requests.Option) (*GetStatusForOrgResponse, error) {
	return GetStatusForOrg(ctx, req, append(c, opt...)...)
}

/*
GetStatusForOrgReq is request data for Client.GetStatusForOrg

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
type GetStatusForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetStatusForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetStatusForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"wyandotte"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "migrations/get-status-for-org",
		Previews:           map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews:   []string{"wyandotte"},
		URLPath:            fmt.Sprintf("/orgs/%v/migrations/%v", r.Org, r.MigrationId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetStatusForOrgReq) Rel(link string, resp *GetStatusForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetStatusForOrgResponse is a response for GetStatusForOrg

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
type GetStatusForOrgResponse struct {
	httpResponse *http.Response
	Data         components.Migration
}

func (r *GetStatusForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListForAuthenticatedUser performs requests for "migrations/list-for-authenticated-user"

List user migrations.

  GET /user/migrations

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
func ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForAuthenticatedUserReq)
	}
	resp := &ListForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListForAuthenticatedUserResponse builds a new *ListForAuthenticatedUserResponse from an *http.Response
func NewListForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListForAuthenticatedUserResponse, error) {
	var result ListForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListForAuthenticatedUser performs requests for "migrations/list-for-authenticated-user"

List user migrations.

  GET /user/migrations

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
func (c Client) ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	return ListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListForAuthenticatedUserReq is request data for Client.ListForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
type ListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"wyandotte"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "migrations/list-for-authenticated-user",
		Previews:           map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews:   []string{"wyandotte"},
		URLPath:            fmt.Sprintf("/user/migrations"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForAuthenticatedUserReq) Rel(link string, resp *ListForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForAuthenticatedUserResponse is a response for ListForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
type ListForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.Migration
}

func (r *ListForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListForOrg performs requests for "migrations/list-for-org"

List organization migrations.

  GET /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
func ListForOrg(ctx context.Context, req *ListForOrgReq, opt ...requests.Option) (*ListForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForOrgReq)
	}
	resp := &ListForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListForOrgResponse(r, opts.PreserveResponseBody())
}

// NewListForOrgResponse builds a new *ListForOrgResponse from an *http.Response
func NewListForOrgResponse(resp *http.Response, preserveBody bool) (*ListForOrgResponse, error) {
	var result ListForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListForOrg performs requests for "migrations/list-for-org"

List organization migrations.

  GET /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
func (c Client) ListForOrg(ctx context.Context, req *ListForOrgReq, opt ...requests.Option) (*ListForOrgResponse, error) {
	return ListForOrg(ctx, req, append(c, opt...)...)
}

/*
ListForOrgReq is request data for Client.ListForOrg

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
type ListForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"wyandotte"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "migrations/list-for-org",
		Previews:           map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews:   []string{"wyandotte"},
		URLPath:            fmt.Sprintf("/orgs/%v/migrations", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForOrgReq) Rel(link string, resp *ListForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForOrgResponse is a response for ListForOrg

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
type ListForOrgResponse struct {
	httpResponse *http.Response
	Data         []components.Migration
}

func (r *ListForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListReposForOrg performs requests for "migrations/list-repos-for-org"

List repositories in an organization migration.

  GET /orgs/{org}/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
func ListReposForOrg(ctx context.Context, req *ListReposForOrgReq, opt ...requests.Option) (*ListReposForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposForOrgReq)
	}
	resp := &ListReposForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListReposForOrgResponse(r, opts.PreserveResponseBody())
}

// NewListReposForOrgResponse builds a new *ListReposForOrgResponse from an *http.Response
func NewListReposForOrgResponse(resp *http.Response, preserveBody bool) (*ListReposForOrgResponse, error) {
	var result ListReposForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListReposForOrg performs requests for "migrations/list-repos-for-org"

List repositories in an organization migration.

  GET /orgs/{org}/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
func (c Client) ListReposForOrg(ctx context.Context, req *ListReposForOrgReq, opt ...requests.Option) (*ListReposForOrgResponse, error) {
	return ListReposForOrg(ctx, req, append(c, opt...)...)
}

/*
ListReposForOrgReq is request data for Client.ListReposForOrg

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
type ListReposForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListReposForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"wyandotte"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "migrations/list-repos-for-org",
		Previews:           map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews:   []string{"wyandotte"},
		URLPath:            fmt.Sprintf("/orgs/%v/migrations/%v/repositories", r.Org, r.MigrationId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposForOrgReq) Rel(link string, resp *ListReposForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposForOrgResponse is a response for ListReposForOrg

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
type ListReposForOrgResponse struct {
	httpResponse *http.Response
	Data         []components.MinimalRepository
}

func (r *ListReposForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListReposForUser performs requests for "migrations/list-repos-for-user"

List repositories for a user migration.

  GET /user/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
func ListReposForUser(ctx context.Context, req *ListReposForUserReq, opt ...requests.Option) (*ListReposForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposForUserReq)
	}
	resp := &ListReposForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListReposForUserResponse(r, opts.PreserveResponseBody())
}

// NewListReposForUserResponse builds a new *ListReposForUserResponse from an *http.Response
func NewListReposForUserResponse(resp *http.Response, preserveBody bool) (*ListReposForUserResponse, error) {
	var result ListReposForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListReposForUser performs requests for "migrations/list-repos-for-user"

List repositories for a user migration.

  GET /user/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
func (c Client) ListReposForUser(ctx context.Context, req *ListReposForUserReq, opt ...requests.Option) (*ListReposForUserResponse, error) {
	return ListReposForUser(ctx, req, append(c, opt...)...)
}

/*
ListReposForUserReq is request data for Client.ListReposForUser

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
type ListReposForUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListReposForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"wyandotte"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "migrations/list-repos-for-user",
		Previews:           map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews:   []string{"wyandotte"},
		URLPath:            fmt.Sprintf("/user/migrations/%v/repositories", r.MigrationId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposForUserReq) Rel(link string, resp *ListReposForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposForUserResponse is a response for ListReposForUser

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
type ListReposForUserResponse struct {
	httpResponse *http.Response
	Data         []components.MinimalRepository
}

func (r *ListReposForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
MapCommitAuthor performs requests for "migrations/map-commit-author"

Map a commit author.

  PATCH /repos/{owner}/{repo}/import/authors/{author_id}

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
func MapCommitAuthor(ctx context.Context, req *MapCommitAuthorReq, opt ...requests.Option) (*MapCommitAuthorResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MapCommitAuthorReq)
	}
	resp := &MapCommitAuthorResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewMapCommitAuthorResponse(r, opts.PreserveResponseBody())
}

// NewMapCommitAuthorResponse builds a new *MapCommitAuthorResponse from an *http.Response
func NewMapCommitAuthorResponse(resp *http.Response, preserveBody bool) (*MapCommitAuthorResponse, error) {
	var result MapCommitAuthorResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
MapCommitAuthor performs requests for "migrations/map-commit-author"

Map a commit author.

  PATCH /repos/{owner}/{repo}/import/authors/{author_id}

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
func (c Client) MapCommitAuthor(ctx context.Context, req *MapCommitAuthorReq, opt ...requests.Option) (*MapCommitAuthorResponse, error) {
	return MapCommitAuthor(ctx, req, append(c, opt...)...)
}

/*
MapCommitAuthorReq is request data for Client.MapCommitAuthor

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MapCommitAuthorReq struct {
	_url  string
	Owner string
	Repo  string

	// author_id parameter
	AuthorId    int64
	RequestBody MapCommitAuthorReqBody
}

// HTTPRequest builds an *http.Request
func (r *MapCommitAuthorReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MapCommitAuthorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "migrations/map-commit-author",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import/authors/%v", r.Owner, r.Repo, r.AuthorId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MapCommitAuthorReq) Rel(link string, resp *MapCommitAuthorResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MapCommitAuthorReqBody is a request body for migrations/map-commit-author

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MapCommitAuthorReqBody struct {

	// The new Git author email.
	Email *string `json:"email,omitempty"`

	// The new Git author name.
	Name     *string `json:"name,omitempty"`
	RemoteId *string `json:"remote_id,omitempty"`
}

/*
MapCommitAuthorResponse is a response for MapCommitAuthor

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MapCommitAuthorResponse struct {
	httpResponse *http.Response
	Data         components.PorterAuthor
}

func (r *MapCommitAuthorResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
SetLfsPreference performs requests for "migrations/set-lfs-preference"

Update Git LFS preference.

  PATCH /repos/{owner}/{repo}/import/lfs

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
func SetLfsPreference(ctx context.Context, req *SetLfsPreferenceReq, opt ...requests.Option) (*SetLfsPreferenceResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetLfsPreferenceReq)
	}
	resp := &SetLfsPreferenceResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewSetLfsPreferenceResponse(r, opts.PreserveResponseBody())
}

// NewSetLfsPreferenceResponse builds a new *SetLfsPreferenceResponse from an *http.Response
func NewSetLfsPreferenceResponse(resp *http.Response, preserveBody bool) (*SetLfsPreferenceResponse, error) {
	var result SetLfsPreferenceResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
SetLfsPreference performs requests for "migrations/set-lfs-preference"

Update Git LFS preference.

  PATCH /repos/{owner}/{repo}/import/lfs

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
func (c Client) SetLfsPreference(ctx context.Context, req *SetLfsPreferenceReq, opt ...requests.Option) (*SetLfsPreferenceResponse, error) {
	return SetLfsPreference(ctx, req, append(c, opt...)...)
}

/*
SetLfsPreferenceReq is request data for Client.SetLfsPreference

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
type SetLfsPreferenceReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody SetLfsPreferenceReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetLfsPreferenceReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetLfsPreferenceReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "migrations/set-lfs-preference",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import/lfs", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetLfsPreferenceReq) Rel(link string, resp *SetLfsPreferenceResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetLfsPreferenceReqBody is a request body for migrations/set-lfs-preference

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
type SetLfsPreferenceReqBody struct {

	/*
	Can be one of `opt_in` (large files will be stored using Git LFS) or `opt_out`
	(large files will be removed during the import).
	*/
	UseLfs *string `json:"use_lfs"`
}

/*
SetLfsPreferenceResponse is a response for SetLfsPreference

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
type SetLfsPreferenceResponse struct {
	httpResponse *http.Response
	Data         components.Import
}

func (r *SetLfsPreferenceResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
StartForAuthenticatedUser performs requests for "migrations/start-for-authenticated-user"

Start a user migration.

  POST /user/migrations

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
func StartForAuthenticatedUser(ctx context.Context, req *StartForAuthenticatedUserReq, opt ...requests.Option) (*StartForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(StartForAuthenticatedUserReq)
	}
	resp := &StartForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewStartForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewStartForAuthenticatedUserResponse builds a new *StartForAuthenticatedUserResponse from an *http.Response
func NewStartForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*StartForAuthenticatedUserResponse, error) {
	var result StartForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
StartForAuthenticatedUser performs requests for "migrations/start-for-authenticated-user"

Start a user migration.

  POST /user/migrations

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
func (c Client) StartForAuthenticatedUser(ctx context.Context, req *StartForAuthenticatedUserReq, opt ...requests.Option) (*StartForAuthenticatedUserResponse, error) {
	return StartForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
StartForAuthenticatedUserReq is request data for Client.StartForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type StartForAuthenticatedUserReq struct {
	_url        string
	RequestBody StartForAuthenticatedUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *StartForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *StartForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "migrations/start-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/migrations"),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StartForAuthenticatedUserReq) Rel(link string, resp *StartForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StartForAuthenticatedUserReqBody is a request body for migrations/start-for-authenticated-user

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type StartForAuthenticatedUserReqBody struct {

	// Exclude attributes from the API response to improve performance
	Exclude []string `json:"exclude,omitempty"`

	// Do not include attachments in the migration
	ExcludeAttachments *bool `json:"exclude_attachments,omitempty"`

	// Lock the repositories being migrated at the start of the migration
	LockRepositories *bool    `json:"lock_repositories,omitempty"`
	Repositories     []string `json:"repositories"`
}

/*
StartForAuthenticatedUserResponse is a response for StartForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type StartForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         components.Migration
}

func (r *StartForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
StartForOrg performs requests for "migrations/start-for-org"

Start an organization migration.

  POST /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
func StartForOrg(ctx context.Context, req *StartForOrgReq, opt ...requests.Option) (*StartForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(StartForOrgReq)
	}
	resp := &StartForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewStartForOrgResponse(r, opts.PreserveResponseBody())
}

// NewStartForOrgResponse builds a new *StartForOrgResponse from an *http.Response
func NewStartForOrgResponse(resp *http.Response, preserveBody bool) (*StartForOrgResponse, error) {
	var result StartForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
StartForOrg performs requests for "migrations/start-for-org"

Start an organization migration.

  POST /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
func (c Client) StartForOrg(ctx context.Context, req *StartForOrgReq, opt ...requests.Option) (*StartForOrgResponse, error) {
	return StartForOrg(ctx, req, append(c, opt...)...)
}

/*
StartForOrgReq is request data for Client.StartForOrg

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type StartForOrgReq struct {
	_url        string
	Org         string
	RequestBody StartForOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *StartForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *StartForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "migrations/start-for-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations", r.Org),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StartForOrgReq) Rel(link string, resp *StartForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StartForOrgReqBody is a request body for migrations/start-for-org

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type StartForOrgReqBody struct {
	Exclude []string `json:"exclude,omitempty"`

	// Indicates whether attachments should be excluded from the migration (to reduce migration archive file size).
	ExcludeAttachments *bool `json:"exclude_attachments,omitempty"`

	// Indicates whether repositories should be locked (to prevent manipulation) while migrating data.
	LockRepositories *bool `json:"lock_repositories,omitempty"`

	// A list of arrays indicating which repositories should be migrated.
	Repositories []string `json:"repositories"`
}

/*
StartForOrgResponse is a response for StartForOrg

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type StartForOrgResponse struct {
	httpResponse *http.Response
	Data         components.Migration
}

func (r *StartForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
StartImport performs requests for "migrations/start-import"

Start an import.

  PUT /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
func StartImport(ctx context.Context, req *StartImportReq, opt ...requests.Option) (*StartImportResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(StartImportReq)
	}
	resp := &StartImportResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewStartImportResponse(r, opts.PreserveResponseBody())
}

// NewStartImportResponse builds a new *StartImportResponse from an *http.Response
func NewStartImportResponse(resp *http.Response, preserveBody bool) (*StartImportResponse, error) {
	var result StartImportResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
StartImport performs requests for "migrations/start-import"

Start an import.

  PUT /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
func (c Client) StartImport(ctx context.Context, req *StartImportReq, opt ...requests.Option) (*StartImportResponse, error) {
	return StartImport(ctx, req, append(c, opt...)...)
}

/*
StartImportReq is request data for Client.StartImport

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type StartImportReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody StartImportReqBody
}

// HTTPRequest builds an *http.Request
func (r *StartImportReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *StartImportReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "migrations/start-import",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StartImportReq) Rel(link string, resp *StartImportResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StartImportReqBody is a request body for migrations/start-import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type StartImportReqBody struct {

	// For a tfvc import, the name of the project that is being imported.
	TfvcProject *string `json:"tfvc_project,omitempty"`

	/*
	The originating VCS type. Can be one of `subversion`, `git`, `mercurial`, or
	`tfvc`. Please be aware that without this parameter, the import job will take
	additional time to detect the VCS type before beginning the import. This
	detection step will be reflected in the response.
	*/
	Vcs *string `json:"vcs,omitempty"`

	// If authentication is required, the password to provide to `vcs_url`.
	VcsPassword *string `json:"vcs_password,omitempty"`

	// The URL of the originating repository.
	VcsUrl *string `json:"vcs_url"`

	// If authentication is required, the username to provide to `vcs_url`.
	VcsUsername *string `json:"vcs_username,omitempty"`
}

/*
StartImportResponse is a response for StartImport

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type StartImportResponse struct {
	httpResponse *http.Response
	Data         components.Import
}

func (r *StartImportResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UnlockRepoForAuthenticatedUser performs requests for "migrations/unlock-repo-for-authenticated-user"

Unlock a user repository.

  DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
func UnlockRepoForAuthenticatedUser(ctx context.Context, req *UnlockRepoForAuthenticatedUserReq, opt ...requests.Option) (*UnlockRepoForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnlockRepoForAuthenticatedUserReq)
	}
	resp := &UnlockRepoForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUnlockRepoForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewUnlockRepoForAuthenticatedUserResponse builds a new *UnlockRepoForAuthenticatedUserResponse from an *http.Response
func NewUnlockRepoForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*UnlockRepoForAuthenticatedUserResponse, error) {
	var result UnlockRepoForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
UnlockRepoForAuthenticatedUser performs requests for "migrations/unlock-repo-for-authenticated-user"

Unlock a user repository.

  DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
func (c Client) UnlockRepoForAuthenticatedUser(ctx context.Context, req *UnlockRepoForAuthenticatedUserReq, opt ...requests.Option) (*UnlockRepoForAuthenticatedUserResponse, error) {
	return UnlockRepoForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
UnlockRepoForAuthenticatedUserReq is request data for Client.UnlockRepoForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
type UnlockRepoForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// repo_name parameter
	RepoName string

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *UnlockRepoForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnlockRepoForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"wyandotte"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "migrations/unlock-repo-for-authenticated-user",
		Previews:           map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews:   []string{"wyandotte"},
		URLPath:            fmt.Sprintf("/user/migrations/%v/repos/%v/lock", r.MigrationId, r.RepoName),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnlockRepoForAuthenticatedUserReq) Rel(link string, resp *UnlockRepoForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnlockRepoForAuthenticatedUserResponse is a response for UnlockRepoForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
type UnlockRepoForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

func (r *UnlockRepoForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UnlockRepoForOrg performs requests for "migrations/unlock-repo-for-org"

Unlock an organization repository.

  DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
func UnlockRepoForOrg(ctx context.Context, req *UnlockRepoForOrgReq, opt ...requests.Option) (*UnlockRepoForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnlockRepoForOrgReq)
	}
	resp := &UnlockRepoForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUnlockRepoForOrgResponse(r, opts.PreserveResponseBody())
}

// NewUnlockRepoForOrgResponse builds a new *UnlockRepoForOrgResponse from an *http.Response
func NewUnlockRepoForOrgResponse(resp *http.Response, preserveBody bool) (*UnlockRepoForOrgResponse, error) {
	var result UnlockRepoForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
UnlockRepoForOrg performs requests for "migrations/unlock-repo-for-org"

Unlock an organization repository.

  DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
func (c Client) UnlockRepoForOrg(ctx context.Context, req *UnlockRepoForOrgReq, opt ...requests.Option) (*UnlockRepoForOrgResponse, error) {
	return UnlockRepoForOrg(ctx, req, append(c, opt...)...)
}

/*
UnlockRepoForOrgReq is request data for Client.UnlockRepoForOrg

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
type UnlockRepoForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// repo_name parameter
	RepoName string

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *UnlockRepoForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnlockRepoForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"wyandotte"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "migrations/unlock-repo-for-org",
		Previews:           map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews:   []string{"wyandotte"},
		URLPath:            fmt.Sprintf("/orgs/%v/migrations/%v/repos/%v/lock", r.Org, r.MigrationId, r.RepoName),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnlockRepoForOrgReq) Rel(link string, resp *UnlockRepoForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnlockRepoForOrgResponse is a response for UnlockRepoForOrg

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
type UnlockRepoForOrgResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *UnlockRepoForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateImport performs requests for "migrations/update-import"

Update an import.

  PATCH /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
func UpdateImport(ctx context.Context, req *UpdateImportReq, opt ...requests.Option) (*UpdateImportResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateImportReq)
	}
	resp := &UpdateImportResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateImportResponse(r, opts.PreserveResponseBody())
}

// NewUpdateImportResponse builds a new *UpdateImportResponse from an *http.Response
func NewUpdateImportResponse(resp *http.Response, preserveBody bool) (*UpdateImportResponse, error) {
	var result UpdateImportResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateImport performs requests for "migrations/update-import"

Update an import.

  PATCH /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
func (c Client) UpdateImport(ctx context.Context, req *UpdateImportReq, opt ...requests.Option) (*UpdateImportResponse, error) {
	return UpdateImport(ctx, req, append(c, opt...)...)
}

/*
UpdateImportReq is request data for Client.UpdateImport

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
type UpdateImportReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody UpdateImportReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateImportReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateImportReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "migrations/update-import",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateImportReq) Rel(link string, resp *UpdateImportResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateImportReqBody is a request body for migrations/update-import

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
type UpdateImportReqBody struct {
	TfvcProject *string `json:"tfvc_project,omitempty"`
	Vcs         *string `json:"vcs,omitempty"`

	// The password to provide to the originating repository.
	VcsPassword *string `json:"vcs_password,omitempty"`

	// The username to provide to the originating repository.
	VcsUsername *string `json:"vcs_username,omitempty"`
}

/*
UpdateImportResponse is a response for UpdateImport

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
type UpdateImportResponse struct {
	httpResponse *http.Response
	Data         components.Import
}

func (r *UpdateImportResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}
