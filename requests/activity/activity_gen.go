// Code generated by octo-go; DO NOT EDIT.

package activity

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
CheckRepoIsStarredByAuthenticatedUser performs requests for "activity/check-repo-is-starred-by-authenticated-user"

Check if a repository is starred by the authenticated user.

  GET /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
func CheckRepoIsStarredByAuthenticatedUser(ctx context.Context, req *CheckRepoIsStarredByAuthenticatedUserReq, opt ...requests.Option) (*CheckRepoIsStarredByAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckRepoIsStarredByAuthenticatedUserReq)
	}
	resp := &CheckRepoIsStarredByAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckRepoIsStarredByAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewCheckRepoIsStarredByAuthenticatedUserResponse builds a new *CheckRepoIsStarredByAuthenticatedUserResponse from an *http.Response
func NewCheckRepoIsStarredByAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*CheckRepoIsStarredByAuthenticatedUserResponse, error) {
	var result CheckRepoIsStarredByAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CheckRepoIsStarredByAuthenticatedUser performs requests for "activity/check-repo-is-starred-by-authenticated-user"

Check if a repository is starred by the authenticated user.

  GET /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
func (c Client) CheckRepoIsStarredByAuthenticatedUser(ctx context.Context, req *CheckRepoIsStarredByAuthenticatedUserReq, opt ...requests.Option) (*CheckRepoIsStarredByAuthenticatedUserResponse, error) {
	return CheckRepoIsStarredByAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
CheckRepoIsStarredByAuthenticatedUserReq is request data for Client.CheckRepoIsStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
type CheckRepoIsStarredByAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *CheckRepoIsStarredByAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckRepoIsStarredByAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "activity/check-repo-is-starred-by-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckRepoIsStarredByAuthenticatedUserReq) Rel(link string, resp *CheckRepoIsStarredByAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckRepoIsStarredByAuthenticatedUserResponse is a response for CheckRepoIsStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
type CheckRepoIsStarredByAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

func (r *CheckRepoIsStarredByAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteRepoSubscription performs requests for "activity/delete-repo-subscription"

Delete a repository subscription.

  DELETE /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
func DeleteRepoSubscription(ctx context.Context, req *DeleteRepoSubscriptionReq, opt ...requests.Option) (*DeleteRepoSubscriptionResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteRepoSubscriptionReq)
	}
	resp := &DeleteRepoSubscriptionResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteRepoSubscriptionResponse(r, opts.PreserveResponseBody())
}

// NewDeleteRepoSubscriptionResponse builds a new *DeleteRepoSubscriptionResponse from an *http.Response
func NewDeleteRepoSubscriptionResponse(resp *http.Response, preserveBody bool) (*DeleteRepoSubscriptionResponse, error) {
	var result DeleteRepoSubscriptionResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteRepoSubscription performs requests for "activity/delete-repo-subscription"

Delete a repository subscription.

  DELETE /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
func (c Client) DeleteRepoSubscription(ctx context.Context, req *DeleteRepoSubscriptionReq, opt ...requests.Option) (*DeleteRepoSubscriptionResponse, error) {
	return DeleteRepoSubscription(ctx, req, append(c, opt...)...)
}

/*
DeleteRepoSubscriptionReq is request data for Client.DeleteRepoSubscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
type DeleteRepoSubscriptionReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *DeleteRepoSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteRepoSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "activity/delete-repo-subscription",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteRepoSubscriptionReq) Rel(link string, resp *DeleteRepoSubscriptionResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteRepoSubscriptionResponse is a response for DeleteRepoSubscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
type DeleteRepoSubscriptionResponse struct {
	httpResponse *http.Response
}

func (r *DeleteRepoSubscriptionResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteThreadSubscription performs requests for "activity/delete-thread-subscription"

Delete a thread subscription.

  DELETE /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
func DeleteThreadSubscription(ctx context.Context, req *DeleteThreadSubscriptionReq, opt ...requests.Option) (*DeleteThreadSubscriptionResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteThreadSubscriptionReq)
	}
	resp := &DeleteThreadSubscriptionResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteThreadSubscriptionResponse(r, opts.PreserveResponseBody())
}

// NewDeleteThreadSubscriptionResponse builds a new *DeleteThreadSubscriptionResponse from an *http.Response
func NewDeleteThreadSubscriptionResponse(resp *http.Response, preserveBody bool) (*DeleteThreadSubscriptionResponse, error) {
	var result DeleteThreadSubscriptionResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteThreadSubscription performs requests for "activity/delete-thread-subscription"

Delete a thread subscription.

  DELETE /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
func (c Client) DeleteThreadSubscription(ctx context.Context, req *DeleteThreadSubscriptionReq, opt ...requests.Option) (*DeleteThreadSubscriptionResponse, error) {
	return DeleteThreadSubscription(ctx, req, append(c, opt...)...)
}

/*
DeleteThreadSubscriptionReq is request data for Client.DeleteThreadSubscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
type DeleteThreadSubscriptionReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteThreadSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteThreadSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "activity/delete-thread-subscription",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteThreadSubscriptionReq) Rel(link string, resp *DeleteThreadSubscriptionResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteThreadSubscriptionResponse is a response for DeleteThreadSubscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
type DeleteThreadSubscriptionResponse struct {
	httpResponse *http.Response
}

func (r *DeleteThreadSubscriptionResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetFeeds performs requests for "activity/get-feeds"

Get feeds.

  GET /feeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
func GetFeeds(ctx context.Context, req *GetFeedsReq, opt ...requests.Option) (*GetFeedsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetFeedsReq)
	}
	resp := &GetFeedsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetFeedsResponse(r, opts.PreserveResponseBody())
}

// NewGetFeedsResponse builds a new *GetFeedsResponse from an *http.Response
func NewGetFeedsResponse(resp *http.Response, preserveBody bool) (*GetFeedsResponse, error) {
	var result GetFeedsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetFeeds performs requests for "activity/get-feeds"

Get feeds.

  GET /feeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
func (c Client) GetFeeds(ctx context.Context, req *GetFeedsReq, opt ...requests.Option) (*GetFeedsResponse, error) {
	return GetFeeds(ctx, req, append(c, opt...)...)
}

/*
GetFeedsReq is request data for Client.GetFeeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
type GetFeedsReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *GetFeedsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetFeedsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/get-feeds",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/feeds"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetFeedsReq) Rel(link string, resp *GetFeedsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetFeedsResponse is a response for GetFeeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
type GetFeedsResponse struct {
	httpResponse *http.Response
	Data         components.Feed
}

func (r *GetFeedsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetRepoSubscription performs requests for "activity/get-repo-subscription"

Get a repository subscription.

  GET /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
func GetRepoSubscription(ctx context.Context, req *GetRepoSubscriptionReq, opt ...requests.Option) (*GetRepoSubscriptionResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetRepoSubscriptionReq)
	}
	resp := &GetRepoSubscriptionResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetRepoSubscriptionResponse(r, opts.PreserveResponseBody())
}

// NewGetRepoSubscriptionResponse builds a new *GetRepoSubscriptionResponse from an *http.Response
func NewGetRepoSubscriptionResponse(resp *http.Response, preserveBody bool) (*GetRepoSubscriptionResponse, error) {
	var result GetRepoSubscriptionResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetRepoSubscription performs requests for "activity/get-repo-subscription"

Get a repository subscription.

  GET /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
func (c Client) GetRepoSubscription(ctx context.Context, req *GetRepoSubscriptionReq, opt ...requests.Option) (*GetRepoSubscriptionResponse, error) {
	return GetRepoSubscription(ctx, req, append(c, opt...)...)
}

/*
GetRepoSubscriptionReq is request data for Client.GetRepoSubscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
type GetRepoSubscriptionReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetRepoSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetRepoSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/get-repo-subscription",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetRepoSubscriptionReq) Rel(link string, resp *GetRepoSubscriptionResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetRepoSubscriptionResponse is a response for GetRepoSubscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
type GetRepoSubscriptionResponse struct {
	httpResponse *http.Response
	Data         components.RepositorySubscription
}

func (r *GetRepoSubscriptionResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetThread performs requests for "activity/get-thread"

Get a thread.

  GET /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
func GetThread(ctx context.Context, req *GetThreadReq, opt ...requests.Option) (*GetThreadResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetThreadReq)
	}
	resp := &GetThreadResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetThreadResponse(r, opts.PreserveResponseBody())
}

// NewGetThreadResponse builds a new *GetThreadResponse from an *http.Response
func NewGetThreadResponse(resp *http.Response, preserveBody bool) (*GetThreadResponse, error) {
	var result GetThreadResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetThread performs requests for "activity/get-thread"

Get a thread.

  GET /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
func (c Client) GetThread(ctx context.Context, req *GetThreadReq, opt ...requests.Option) (*GetThreadResponse, error) {
	return GetThread(ctx, req, append(c, opt...)...)
}

/*
GetThreadReq is request data for Client.GetThread

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
type GetThreadReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request
func (r *GetThreadReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetThreadReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/get-thread",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/notifications/threads/%v", r.ThreadId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetThreadReq) Rel(link string, resp *GetThreadResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetThreadResponse is a response for GetThread

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
type GetThreadResponse struct {
	httpResponse *http.Response
	Data         components.Thread
}

func (r *GetThreadResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetThreadSubscriptionForAuthenticatedUser performs requests for "activity/get-thread-subscription-for-authenticated-user"

Get a thread subscription for the authenticated user.

  GET /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
func GetThreadSubscriptionForAuthenticatedUser(ctx context.Context, req *GetThreadSubscriptionForAuthenticatedUserReq, opt ...requests.Option) (*GetThreadSubscriptionForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetThreadSubscriptionForAuthenticatedUserReq)
	}
	resp := &GetThreadSubscriptionForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetThreadSubscriptionForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewGetThreadSubscriptionForAuthenticatedUserResponse builds a new *GetThreadSubscriptionForAuthenticatedUserResponse from an *http.Response
func NewGetThreadSubscriptionForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*GetThreadSubscriptionForAuthenticatedUserResponse, error) {
	var result GetThreadSubscriptionForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetThreadSubscriptionForAuthenticatedUser performs requests for "activity/get-thread-subscription-for-authenticated-user"

Get a thread subscription for the authenticated user.

  GET /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
func (c Client) GetThreadSubscriptionForAuthenticatedUser(ctx context.Context, req *GetThreadSubscriptionForAuthenticatedUserReq, opt ...requests.Option) (*GetThreadSubscriptionForAuthenticatedUserResponse, error) {
	return GetThreadSubscriptionForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
GetThreadSubscriptionForAuthenticatedUserReq is request data for Client.GetThreadSubscriptionForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
type GetThreadSubscriptionForAuthenticatedUserReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request
func (r *GetThreadSubscriptionForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetThreadSubscriptionForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/get-thread-subscription-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetThreadSubscriptionForAuthenticatedUserReq) Rel(link string, resp *GetThreadSubscriptionForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetThreadSubscriptionForAuthenticatedUserResponse is a response for GetThreadSubscriptionForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
type GetThreadSubscriptionForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         components.ThreadSubscription
}

func (r *GetThreadSubscriptionForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListEventsForAuthenticatedUser performs requests for "activity/list-events-for-authenticated-user"

List events for the authenticated user.

  GET /users/{username}/events

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
func ListEventsForAuthenticatedUser(ctx context.Context, req *ListEventsForAuthenticatedUserReq, opt ...requests.Option) (*ListEventsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListEventsForAuthenticatedUserReq)
	}
	resp := &ListEventsForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListEventsForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListEventsForAuthenticatedUserResponse builds a new *ListEventsForAuthenticatedUserResponse from an *http.Response
func NewListEventsForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListEventsForAuthenticatedUserResponse, error) {
	var result ListEventsForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListEventsForAuthenticatedUser performs requests for "activity/list-events-for-authenticated-user"

List events for the authenticated user.

  GET /users/{username}/events

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
func (c Client) ListEventsForAuthenticatedUser(ctx context.Context, req *ListEventsForAuthenticatedUserReq, opt ...requests.Option) (*ListEventsForAuthenticatedUserResponse, error) {
	return ListEventsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListEventsForAuthenticatedUserReq is request data for Client.ListEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
type ListEventsForAuthenticatedUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListEventsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListEventsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-events-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/events", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListEventsForAuthenticatedUserReq) Rel(link string, resp *ListEventsForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListEventsForAuthenticatedUserResponse is a response for ListEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
type ListEventsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

func (r *ListEventsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListNotificationsForAuthenticatedUser performs requests for "activity/list-notifications-for-authenticated-user"

List notifications for the authenticated user.

  GET /notifications

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
func ListNotificationsForAuthenticatedUser(ctx context.Context, req *ListNotificationsForAuthenticatedUserReq, opt ...requests.Option) (*ListNotificationsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListNotificationsForAuthenticatedUserReq)
	}
	resp := &ListNotificationsForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListNotificationsForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListNotificationsForAuthenticatedUserResponse builds a new *ListNotificationsForAuthenticatedUserResponse from an *http.Response
func NewListNotificationsForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListNotificationsForAuthenticatedUserResponse, error) {
	var result ListNotificationsForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListNotificationsForAuthenticatedUser performs requests for "activity/list-notifications-for-authenticated-user"

List notifications for the authenticated user.

  GET /notifications

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
func (c Client) ListNotificationsForAuthenticatedUser(ctx context.Context, req *ListNotificationsForAuthenticatedUserReq, opt ...requests.Option) (*ListNotificationsForAuthenticatedUserResponse, error) {
	return ListNotificationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListNotificationsForAuthenticatedUserReq is request data for Client.ListNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
type ListNotificationsForAuthenticatedUserReq struct {
	_url string

	// If `true`, show notifications marked as read.
	All *bool

	/*
	If `true`, only shows notifications in which the user is directly participating
	or mentioned.
	*/
	Participating *bool

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only show notifications updated before the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Before *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListNotificationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListNotificationsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.All != nil {
		query.Set("all", strconv.FormatBool(*r.All))
	}
	if r.Participating != nil {
		query.Set("participating", strconv.FormatBool(*r.Participating))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Before != nil {
		query.Set("before", *r.Before)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-notifications-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/notifications"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListNotificationsForAuthenticatedUserReq) Rel(link string, resp *ListNotificationsForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListNotificationsForAuthenticatedUserResponse is a response for ListNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
type ListNotificationsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.Thread
}

func (r *ListNotificationsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListOrgEventsForAuthenticatedUser performs requests for "activity/list-org-events-for-authenticated-user"

List organization events for the authenticated user.

  GET /users/{username}/events/orgs/{org}

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
func ListOrgEventsForAuthenticatedUser(ctx context.Context, req *ListOrgEventsForAuthenticatedUserReq, opt ...requests.Option) (*ListOrgEventsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListOrgEventsForAuthenticatedUserReq)
	}
	resp := &ListOrgEventsForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListOrgEventsForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListOrgEventsForAuthenticatedUserResponse builds a new *ListOrgEventsForAuthenticatedUserResponse from an *http.Response
func NewListOrgEventsForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListOrgEventsForAuthenticatedUserResponse, error) {
	var result ListOrgEventsForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListOrgEventsForAuthenticatedUser performs requests for "activity/list-org-events-for-authenticated-user"

List organization events for the authenticated user.

  GET /users/{username}/events/orgs/{org}

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
func (c Client) ListOrgEventsForAuthenticatedUser(ctx context.Context, req *ListOrgEventsForAuthenticatedUserReq, opt ...requests.Option) (*ListOrgEventsForAuthenticatedUserResponse, error) {
	return ListOrgEventsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListOrgEventsForAuthenticatedUserReq is request data for Client.ListOrgEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
type ListOrgEventsForAuthenticatedUserReq struct {
	_url     string
	Username string
	Org      string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListOrgEventsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListOrgEventsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-org-events-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/events/orgs/%v", r.Username, r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListOrgEventsForAuthenticatedUserReq) Rel(link string, resp *ListOrgEventsForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListOrgEventsForAuthenticatedUserResponse is a response for ListOrgEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
type ListOrgEventsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

func (r *ListOrgEventsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPublicEvents performs requests for "activity/list-public-events"

List public events.

  GET /events

https://developer.github.com/v3/activity/events/#list-public-events
*/
func ListPublicEvents(ctx context.Context, req *ListPublicEventsReq, opt ...requests.Option) (*ListPublicEventsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicEventsReq)
	}
	resp := &ListPublicEventsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPublicEventsResponse(r, opts.PreserveResponseBody())
}

// NewListPublicEventsResponse builds a new *ListPublicEventsResponse from an *http.Response
func NewListPublicEventsResponse(resp *http.Response, preserveBody bool) (*ListPublicEventsResponse, error) {
	var result ListPublicEventsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPublicEvents performs requests for "activity/list-public-events"

List public events.

  GET /events

https://developer.github.com/v3/activity/events/#list-public-events
*/
func (c Client) ListPublicEvents(ctx context.Context, req *ListPublicEventsReq, opt ...requests.Option) (*ListPublicEventsResponse, error) {
	return ListPublicEvents(ctx, req, append(c, opt...)...)
}

/*
ListPublicEventsReq is request data for Client.ListPublicEvents

https://developer.github.com/v3/activity/events/#list-public-events
*/
type ListPublicEventsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicEventsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicEventsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-public-events",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/events"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicEventsReq) Rel(link string, resp *ListPublicEventsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicEventsResponse is a response for ListPublicEvents

https://developer.github.com/v3/activity/events/#list-public-events
*/
type ListPublicEventsResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

func (r *ListPublicEventsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPublicEventsForRepoNetwork performs requests for "activity/list-public-events-for-repo-network"

List public events for a network of repositories.

  GET /networks/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
func ListPublicEventsForRepoNetwork(ctx context.Context, req *ListPublicEventsForRepoNetworkReq, opt ...requests.Option) (*ListPublicEventsForRepoNetworkResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicEventsForRepoNetworkReq)
	}
	resp := &ListPublicEventsForRepoNetworkResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPublicEventsForRepoNetworkResponse(r, opts.PreserveResponseBody())
}

// NewListPublicEventsForRepoNetworkResponse builds a new *ListPublicEventsForRepoNetworkResponse from an *http.Response
func NewListPublicEventsForRepoNetworkResponse(resp *http.Response, preserveBody bool) (*ListPublicEventsForRepoNetworkResponse, error) {
	var result ListPublicEventsForRepoNetworkResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 301, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPublicEventsForRepoNetwork performs requests for "activity/list-public-events-for-repo-network"

List public events for a network of repositories.

  GET /networks/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
func (c Client) ListPublicEventsForRepoNetwork(ctx context.Context, req *ListPublicEventsForRepoNetworkReq, opt ...requests.Option) (*ListPublicEventsForRepoNetworkResponse, error) {
	return ListPublicEventsForRepoNetwork(ctx, req, append(c, opt...)...)
}

/*
ListPublicEventsForRepoNetworkReq is request data for Client.ListPublicEventsForRepoNetwork

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
type ListPublicEventsForRepoNetworkReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicEventsForRepoNetworkReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicEventsForRepoNetworkReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-public-events-for-repo-network",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/networks/%v/%v/events", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicEventsForRepoNetworkReq) Rel(link string, resp *ListPublicEventsForRepoNetworkResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicEventsForRepoNetworkResponse is a response for ListPublicEventsForRepoNetwork

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
type ListPublicEventsForRepoNetworkResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

func (r *ListPublicEventsForRepoNetworkResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPublicEventsForUser performs requests for "activity/list-public-events-for-user"

List public events for a user.

  GET /users/{username}/events/public

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
func ListPublicEventsForUser(ctx context.Context, req *ListPublicEventsForUserReq, opt ...requests.Option) (*ListPublicEventsForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicEventsForUserReq)
	}
	resp := &ListPublicEventsForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPublicEventsForUserResponse(r, opts.PreserveResponseBody())
}

// NewListPublicEventsForUserResponse builds a new *ListPublicEventsForUserResponse from an *http.Response
func NewListPublicEventsForUserResponse(resp *http.Response, preserveBody bool) (*ListPublicEventsForUserResponse, error) {
	var result ListPublicEventsForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPublicEventsForUser performs requests for "activity/list-public-events-for-user"

List public events for a user.

  GET /users/{username}/events/public

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
func (c Client) ListPublicEventsForUser(ctx context.Context, req *ListPublicEventsForUserReq, opt ...requests.Option) (*ListPublicEventsForUserResponse, error) {
	return ListPublicEventsForUser(ctx, req, append(c, opt...)...)
}

/*
ListPublicEventsForUserReq is request data for Client.ListPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
type ListPublicEventsForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicEventsForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicEventsForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-public-events-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/events/public", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicEventsForUserReq) Rel(link string, resp *ListPublicEventsForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicEventsForUserResponse is a response for ListPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
type ListPublicEventsForUserResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

func (r *ListPublicEventsForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPublicOrgEvents performs requests for "activity/list-public-org-events"

List public organization events.

  GET /orgs/{org}/events

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
func ListPublicOrgEvents(ctx context.Context, req *ListPublicOrgEventsReq, opt ...requests.Option) (*ListPublicOrgEventsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicOrgEventsReq)
	}
	resp := &ListPublicOrgEventsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPublicOrgEventsResponse(r, opts.PreserveResponseBody())
}

// NewListPublicOrgEventsResponse builds a new *ListPublicOrgEventsResponse from an *http.Response
func NewListPublicOrgEventsResponse(resp *http.Response, preserveBody bool) (*ListPublicOrgEventsResponse, error) {
	var result ListPublicOrgEventsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPublicOrgEvents performs requests for "activity/list-public-org-events"

List public organization events.

  GET /orgs/{org}/events

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
func (c Client) ListPublicOrgEvents(ctx context.Context, req *ListPublicOrgEventsReq, opt ...requests.Option) (*ListPublicOrgEventsResponse, error) {
	return ListPublicOrgEvents(ctx, req, append(c, opt...)...)
}

/*
ListPublicOrgEventsReq is request data for Client.ListPublicOrgEvents

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
type ListPublicOrgEventsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicOrgEventsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicOrgEventsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-public-org-events",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/events", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicOrgEventsReq) Rel(link string, resp *ListPublicOrgEventsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicOrgEventsResponse is a response for ListPublicOrgEvents

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
type ListPublicOrgEventsResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

func (r *ListPublicOrgEventsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListReceivedEventsForUser performs requests for "activity/list-received-events-for-user"

List events received by the authenticated user.

  GET /users/{username}/received_events

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
func ListReceivedEventsForUser(ctx context.Context, req *ListReceivedEventsForUserReq, opt ...requests.Option) (*ListReceivedEventsForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReceivedEventsForUserReq)
	}
	resp := &ListReceivedEventsForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListReceivedEventsForUserResponse(r, opts.PreserveResponseBody())
}

// NewListReceivedEventsForUserResponse builds a new *ListReceivedEventsForUserResponse from an *http.Response
func NewListReceivedEventsForUserResponse(resp *http.Response, preserveBody bool) (*ListReceivedEventsForUserResponse, error) {
	var result ListReceivedEventsForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListReceivedEventsForUser performs requests for "activity/list-received-events-for-user"

List events received by the authenticated user.

  GET /users/{username}/received_events

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
func (c Client) ListReceivedEventsForUser(ctx context.Context, req *ListReceivedEventsForUserReq, opt ...requests.Option) (*ListReceivedEventsForUserResponse, error) {
	return ListReceivedEventsForUser(ctx, req, append(c, opt...)...)
}

/*
ListReceivedEventsForUserReq is request data for Client.ListReceivedEventsForUser

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
type ListReceivedEventsForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReceivedEventsForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReceivedEventsForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-received-events-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/received_events", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReceivedEventsForUserReq) Rel(link string, resp *ListReceivedEventsForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReceivedEventsForUserResponse is a response for ListReceivedEventsForUser

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
type ListReceivedEventsForUserResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

func (r *ListReceivedEventsForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListReceivedPublicEventsForUser performs requests for "activity/list-received-public-events-for-user"

List public events received by a user.

  GET /users/{username}/received_events/public

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
func ListReceivedPublicEventsForUser(ctx context.Context, req *ListReceivedPublicEventsForUserReq, opt ...requests.Option) (*ListReceivedPublicEventsForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReceivedPublicEventsForUserReq)
	}
	resp := &ListReceivedPublicEventsForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListReceivedPublicEventsForUserResponse(r, opts.PreserveResponseBody())
}

// NewListReceivedPublicEventsForUserResponse builds a new *ListReceivedPublicEventsForUserResponse from an *http.Response
func NewListReceivedPublicEventsForUserResponse(resp *http.Response, preserveBody bool) (*ListReceivedPublicEventsForUserResponse, error) {
	var result ListReceivedPublicEventsForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListReceivedPublicEventsForUser performs requests for "activity/list-received-public-events-for-user"

List public events received by a user.

  GET /users/{username}/received_events/public

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
func (c Client) ListReceivedPublicEventsForUser(ctx context.Context, req *ListReceivedPublicEventsForUserReq, opt ...requests.Option) (*ListReceivedPublicEventsForUserResponse, error) {
	return ListReceivedPublicEventsForUser(ctx, req, append(c, opt...)...)
}

/*
ListReceivedPublicEventsForUserReq is request data for Client.ListReceivedPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
type ListReceivedPublicEventsForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReceivedPublicEventsForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReceivedPublicEventsForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-received-public-events-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/received_events/public", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReceivedPublicEventsForUserReq) Rel(link string, resp *ListReceivedPublicEventsForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReceivedPublicEventsForUserResponse is a response for ListReceivedPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
type ListReceivedPublicEventsForUserResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

func (r *ListReceivedPublicEventsForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListRepoEvents performs requests for "activity/list-repo-events"

List repository events.

  GET /repos/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-repository-events
*/
func ListRepoEvents(ctx context.Context, req *ListRepoEventsReq, opt ...requests.Option) (*ListRepoEventsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListRepoEventsReq)
	}
	resp := &ListRepoEventsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListRepoEventsResponse(r, opts.PreserveResponseBody())
}

// NewListRepoEventsResponse builds a new *ListRepoEventsResponse from an *http.Response
func NewListRepoEventsResponse(resp *http.Response, preserveBody bool) (*ListRepoEventsResponse, error) {
	var result ListRepoEventsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListRepoEvents performs requests for "activity/list-repo-events"

List repository events.

  GET /repos/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-repository-events
*/
func (c Client) ListRepoEvents(ctx context.Context, req *ListRepoEventsReq, opt ...requests.Option) (*ListRepoEventsResponse, error) {
	return ListRepoEvents(ctx, req, append(c, opt...)...)
}

/*
ListRepoEventsReq is request data for Client.ListRepoEvents

https://developer.github.com/v3/activity/events/#list-repository-events
*/
type ListRepoEventsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListRepoEventsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListRepoEventsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-repo-events",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/events", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListRepoEventsReq) Rel(link string, resp *ListRepoEventsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListRepoEventsResponse is a response for ListRepoEvents

https://developer.github.com/v3/activity/events/#list-repository-events
*/
type ListRepoEventsResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

func (r *ListRepoEventsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListRepoNotificationsForAuthenticatedUser performs requests for "activity/list-repo-notifications-for-authenticated-user"

List repository notifications for the authenticated user.

  GET /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
func ListRepoNotificationsForAuthenticatedUser(ctx context.Context, req *ListRepoNotificationsForAuthenticatedUserReq, opt ...requests.Option) (*ListRepoNotificationsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListRepoNotificationsForAuthenticatedUserReq)
	}
	resp := &ListRepoNotificationsForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListRepoNotificationsForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListRepoNotificationsForAuthenticatedUserResponse builds a new *ListRepoNotificationsForAuthenticatedUserResponse from an *http.Response
func NewListRepoNotificationsForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListRepoNotificationsForAuthenticatedUserResponse, error) {
	var result ListRepoNotificationsForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListRepoNotificationsForAuthenticatedUser performs requests for "activity/list-repo-notifications-for-authenticated-user"

List repository notifications for the authenticated user.

  GET /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
func (c Client) ListRepoNotificationsForAuthenticatedUser(ctx context.Context, req *ListRepoNotificationsForAuthenticatedUserReq, opt ...requests.Option) (*ListRepoNotificationsForAuthenticatedUserResponse, error) {
	return ListRepoNotificationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListRepoNotificationsForAuthenticatedUserReq is request data for Client.ListRepoNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
type ListRepoNotificationsForAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string

	// If `true`, show notifications marked as read.
	All *bool

	/*
	If `true`, only shows notifications in which the user is directly participating
	or mentioned.
	*/
	Participating *bool

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only show notifications updated before the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Before *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListRepoNotificationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListRepoNotificationsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.All != nil {
		query.Set("all", strconv.FormatBool(*r.All))
	}
	if r.Participating != nil {
		query.Set("participating", strconv.FormatBool(*r.Participating))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Before != nil {
		query.Set("before", *r.Before)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-repo-notifications-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/notifications", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListRepoNotificationsForAuthenticatedUserReq) Rel(link string, resp *ListRepoNotificationsForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListRepoNotificationsForAuthenticatedUserResponse is a response for ListRepoNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
type ListRepoNotificationsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.Thread
}

func (r *ListRepoNotificationsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListReposStarredByAuthenticatedUser performs requests for "activity/list-repos-starred-by-authenticated-user"

List repositories starred by the authenticated user.

  GET /user/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
func ListReposStarredByAuthenticatedUser(ctx context.Context, req *ListReposStarredByAuthenticatedUserReq, opt ...requests.Option) (*ListReposStarredByAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposStarredByAuthenticatedUserReq)
	}
	resp := &ListReposStarredByAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListReposStarredByAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListReposStarredByAuthenticatedUserResponse builds a new *ListReposStarredByAuthenticatedUserResponse from an *http.Response
func NewListReposStarredByAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListReposStarredByAuthenticatedUserResponse, error) {
	var result ListReposStarredByAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListReposStarredByAuthenticatedUser performs requests for "activity/list-repos-starred-by-authenticated-user"

List repositories starred by the authenticated user.

  GET /user/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
func (c Client) ListReposStarredByAuthenticatedUser(ctx context.Context, req *ListReposStarredByAuthenticatedUserReq, opt ...requests.Option) (*ListReposStarredByAuthenticatedUserResponse, error) {
	return ListReposStarredByAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListReposStarredByAuthenticatedUserReq is request data for Client.ListReposStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
type ListReposStarredByAuthenticatedUserReq struct {
	_url string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReposStarredByAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposStarredByAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/vnd.github.v3.star+json")},
		Method:             "GET",
		OperationID:        "activity/list-repos-starred-by-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/starred"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposStarredByAuthenticatedUserReq) Rel(link string, resp *ListReposStarredByAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposStarredByAuthenticatedUserResponse is a response for ListReposStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
type ListReposStarredByAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.StarredRepository
}

func (r *ListReposStarredByAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListReposStarredByUser performs requests for "activity/list-repos-starred-by-user"

List repositories starred by a user.

  GET /users/{username}/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
func ListReposStarredByUser(ctx context.Context, req *ListReposStarredByUserReq, opt ...requests.Option) (*ListReposStarredByUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposStarredByUserReq)
	}
	resp := &ListReposStarredByUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListReposStarredByUserResponse(r, opts.PreserveResponseBody())
}

// NewListReposStarredByUserResponse builds a new *ListReposStarredByUserResponse from an *http.Response
func NewListReposStarredByUserResponse(resp *http.Response, preserveBody bool) (*ListReposStarredByUserResponse, error) {
	var result ListReposStarredByUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListReposStarredByUser performs requests for "activity/list-repos-starred-by-user"

List repositories starred by a user.

  GET /users/{username}/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
func (c Client) ListReposStarredByUser(ctx context.Context, req *ListReposStarredByUserReq, opt ...requests.Option) (*ListReposStarredByUserResponse, error) {
	return ListReposStarredByUser(ctx, req, append(c, opt...)...)
}

/*
ListReposStarredByUserReq is request data for Client.ListReposStarredByUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
type ListReposStarredByUserReq struct {
	_url     string
	Username string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReposStarredByUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposStarredByUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/vnd.github.v3.star+json")},
		Method:             "GET",
		OperationID:        "activity/list-repos-starred-by-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/starred", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposStarredByUserReq) Rel(link string, resp *ListReposStarredByUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposStarredByUserResponse is a response for ListReposStarredByUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
type ListReposStarredByUserResponse struct {
	httpResponse *http.Response
	Data         []components.StarredRepository
}

func (r *ListReposStarredByUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListReposWatchedByUser performs requests for "activity/list-repos-watched-by-user"

List repositories watched by a user.

  GET /users/{username}/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
func ListReposWatchedByUser(ctx context.Context, req *ListReposWatchedByUserReq, opt ...requests.Option) (*ListReposWatchedByUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposWatchedByUserReq)
	}
	resp := &ListReposWatchedByUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListReposWatchedByUserResponse(r, opts.PreserveResponseBody())
}

// NewListReposWatchedByUserResponse builds a new *ListReposWatchedByUserResponse from an *http.Response
func NewListReposWatchedByUserResponse(resp *http.Response, preserveBody bool) (*ListReposWatchedByUserResponse, error) {
	var result ListReposWatchedByUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListReposWatchedByUser performs requests for "activity/list-repos-watched-by-user"

List repositories watched by a user.

  GET /users/{username}/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
func (c Client) ListReposWatchedByUser(ctx context.Context, req *ListReposWatchedByUserReq, opt ...requests.Option) (*ListReposWatchedByUserResponse, error) {
	return ListReposWatchedByUser(ctx, req, append(c, opt...)...)
}

/*
ListReposWatchedByUserReq is request data for Client.ListReposWatchedByUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
type ListReposWatchedByUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReposWatchedByUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposWatchedByUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-repos-watched-by-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/subscriptions", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposWatchedByUserReq) Rel(link string, resp *ListReposWatchedByUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposWatchedByUserResponse is a response for ListReposWatchedByUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
type ListReposWatchedByUserResponse struct {
	httpResponse *http.Response
	Data         []components.MinimalRepository
}

func (r *ListReposWatchedByUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListStargazersForRepo performs requests for "activity/list-stargazers-for-repo"

List stargazers.

  GET /repos/{owner}/{repo}/stargazers

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
func ListStargazersForRepo(ctx context.Context, req *ListStargazersForRepoReq, opt ...requests.Option) (*ListStargazersForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListStargazersForRepoReq)
	}
	resp := &ListStargazersForRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListStargazersForRepoResponse(r, opts.PreserveResponseBody())
}

// NewListStargazersForRepoResponse builds a new *ListStargazersForRepoResponse from an *http.Response
func NewListStargazersForRepoResponse(resp *http.Response, preserveBody bool) (*ListStargazersForRepoResponse, error) {
	var result ListStargazersForRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListStargazersForRepo performs requests for "activity/list-stargazers-for-repo"

List stargazers.

  GET /repos/{owner}/{repo}/stargazers

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
func (c Client) ListStargazersForRepo(ctx context.Context, req *ListStargazersForRepoReq, opt ...requests.Option) (*ListStargazersForRepoResponse, error) {
	return ListStargazersForRepo(ctx, req, append(c, opt...)...)
}

/*
ListStargazersForRepoReq is request data for Client.ListStargazersForRepo

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
type ListStargazersForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListStargazersForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListStargazersForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/vnd.github.v3.star+json")},
		Method:             "GET",
		OperationID:        "activity/list-stargazers-for-repo",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/stargazers", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListStargazersForRepoReq) Rel(link string, resp *ListStargazersForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListStargazersForRepoResponse is a response for ListStargazersForRepo

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
type ListStargazersForRepoResponse struct {
	httpResponse *http.Response
	Data         []components.Stargazer
}

func (r *ListStargazersForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListWatchedReposForAuthenticatedUser performs requests for "activity/list-watched-repos-for-authenticated-user"

List repositories watched by the authenticated user.

  GET /user/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
func ListWatchedReposForAuthenticatedUser(ctx context.Context, req *ListWatchedReposForAuthenticatedUserReq, opt ...requests.Option) (*ListWatchedReposForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListWatchedReposForAuthenticatedUserReq)
	}
	resp := &ListWatchedReposForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListWatchedReposForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListWatchedReposForAuthenticatedUserResponse builds a new *ListWatchedReposForAuthenticatedUserResponse from an *http.Response
func NewListWatchedReposForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListWatchedReposForAuthenticatedUserResponse, error) {
	var result ListWatchedReposForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListWatchedReposForAuthenticatedUser performs requests for "activity/list-watched-repos-for-authenticated-user"

List repositories watched by the authenticated user.

  GET /user/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
func (c Client) ListWatchedReposForAuthenticatedUser(ctx context.Context, req *ListWatchedReposForAuthenticatedUserReq, opt ...requests.Option) (*ListWatchedReposForAuthenticatedUserResponse, error) {
	return ListWatchedReposForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListWatchedReposForAuthenticatedUserReq is request data for Client.ListWatchedReposForAuthenticatedUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
type ListWatchedReposForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListWatchedReposForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListWatchedReposForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-watched-repos-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/subscriptions"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListWatchedReposForAuthenticatedUserReq) Rel(link string, resp *ListWatchedReposForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListWatchedReposForAuthenticatedUserResponse is a response for ListWatchedReposForAuthenticatedUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
type ListWatchedReposForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.MinimalRepository
}

func (r *ListWatchedReposForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListWatchersForRepo performs requests for "activity/list-watchers-for-repo"

List watchers.

  GET /repos/{owner}/{repo}/subscribers

https://developer.github.com/v3/activity/watching/#list-watchers
*/
func ListWatchersForRepo(ctx context.Context, req *ListWatchersForRepoReq, opt ...requests.Option) (*ListWatchersForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListWatchersForRepoReq)
	}
	resp := &ListWatchersForRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListWatchersForRepoResponse(r, opts.PreserveResponseBody())
}

// NewListWatchersForRepoResponse builds a new *ListWatchersForRepoResponse from an *http.Response
func NewListWatchersForRepoResponse(resp *http.Response, preserveBody bool) (*ListWatchersForRepoResponse, error) {
	var result ListWatchersForRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListWatchersForRepo performs requests for "activity/list-watchers-for-repo"

List watchers.

  GET /repos/{owner}/{repo}/subscribers

https://developer.github.com/v3/activity/watching/#list-watchers
*/
func (c Client) ListWatchersForRepo(ctx context.Context, req *ListWatchersForRepoReq, opt ...requests.Option) (*ListWatchersForRepoResponse, error) {
	return ListWatchersForRepo(ctx, req, append(c, opt...)...)
}

/*
ListWatchersForRepoReq is request data for Client.ListWatchersForRepo

https://developer.github.com/v3/activity/watching/#list-watchers
*/
type ListWatchersForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListWatchersForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListWatchersForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "activity/list-watchers-for-repo",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/subscribers", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListWatchersForRepoReq) Rel(link string, resp *ListWatchersForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListWatchersForRepoResponse is a response for ListWatchersForRepo

https://developer.github.com/v3/activity/watching/#list-watchers
*/
type ListWatchersForRepoResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListWatchersForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
MarkNotificationsAsRead performs requests for "activity/mark-notifications-as-read"

Mark notifications as read.

  PUT /notifications

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
func MarkNotificationsAsRead(ctx context.Context, req *MarkNotificationsAsReadReq, opt ...requests.Option) (*MarkNotificationsAsReadResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MarkNotificationsAsReadReq)
	}
	resp := &MarkNotificationsAsReadResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewMarkNotificationsAsReadResponse(r, opts.PreserveResponseBody())
}

// NewMarkNotificationsAsReadResponse builds a new *MarkNotificationsAsReadResponse from an *http.Response
func NewMarkNotificationsAsReadResponse(resp *http.Response, preserveBody bool) (*MarkNotificationsAsReadResponse, error) {
	var result MarkNotificationsAsReadResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{202, 205, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{202}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
MarkNotificationsAsRead performs requests for "activity/mark-notifications-as-read"

Mark notifications as read.

  PUT /notifications

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
func (c Client) MarkNotificationsAsRead(ctx context.Context, req *MarkNotificationsAsReadReq, opt ...requests.Option) (*MarkNotificationsAsReadResponse, error) {
	return MarkNotificationsAsRead(ctx, req, append(c, opt...)...)
}

/*
MarkNotificationsAsReadReq is request data for Client.MarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type MarkNotificationsAsReadReq struct {
	_url        string
	RequestBody MarkNotificationsAsReadReqBody
}

// HTTPRequest builds an *http.Request
func (r *MarkNotificationsAsReadReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MarkNotificationsAsReadReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "activity/mark-notifications-as-read",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications"),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MarkNotificationsAsReadReq) Rel(link string, resp *MarkNotificationsAsReadResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MarkNotificationsAsReadReqBody is a request body for activity/mark-notifications-as-read

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type MarkNotificationsAsReadReqBody struct {

	// Describes the last point that notifications were checked.
	LastReadAt *string `json:"last_read_at,omitempty"`

	// Whether the notification has been read.
	Read *bool `json:"read,omitempty"`
}

/*
MarkNotificationsAsReadResponseBody is a response body for MarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type MarkNotificationsAsReadResponseBody struct {
	Message string `json:"message,omitempty"`
}

/*
MarkNotificationsAsReadResponse is a response for MarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type MarkNotificationsAsReadResponse struct {
	httpResponse *http.Response
	Data         MarkNotificationsAsReadResponseBody
}

func (r *MarkNotificationsAsReadResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
MarkRepoNotificationsAsRead performs requests for "activity/mark-repo-notifications-as-read"

Mark repository notifications as read.

  PUT /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
func MarkRepoNotificationsAsRead(ctx context.Context, req *MarkRepoNotificationsAsReadReq, opt ...requests.Option) (*MarkRepoNotificationsAsReadResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MarkRepoNotificationsAsReadReq)
	}
	resp := &MarkRepoNotificationsAsReadResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewMarkRepoNotificationsAsReadResponse(r, opts.PreserveResponseBody())
}

// NewMarkRepoNotificationsAsReadResponse builds a new *MarkRepoNotificationsAsReadResponse from an *http.Response
func NewMarkRepoNotificationsAsReadResponse(resp *http.Response, preserveBody bool) (*MarkRepoNotificationsAsReadResponse, error) {
	var result MarkRepoNotificationsAsReadResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{202})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
MarkRepoNotificationsAsRead performs requests for "activity/mark-repo-notifications-as-read"

Mark repository notifications as read.

  PUT /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
func (c Client) MarkRepoNotificationsAsRead(ctx context.Context, req *MarkRepoNotificationsAsReadReq, opt ...requests.Option) (*MarkRepoNotificationsAsReadResponse, error) {
	return MarkRepoNotificationsAsRead(ctx, req, append(c, opt...)...)
}

/*
MarkRepoNotificationsAsReadReq is request data for Client.MarkRepoNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type MarkRepoNotificationsAsReadReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody MarkRepoNotificationsAsReadReqBody
}

// HTTPRequest builds an *http.Request
func (r *MarkRepoNotificationsAsReadReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MarkRepoNotificationsAsReadReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "PUT",
		OperationID:        "activity/mark-repo-notifications-as-read",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/notifications", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MarkRepoNotificationsAsReadReq) Rel(link string, resp *MarkRepoNotificationsAsReadResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MarkRepoNotificationsAsReadReqBody is a request body for activity/mark-repo-notifications-as-read

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type MarkRepoNotificationsAsReadReqBody struct {

	/*
	Describes the last point that notifications were checked. Anything updated since
	this time will not be marked as read. If you omit this parameter, all
	notifications are marked as read. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Default: The current timestamp.
	*/
	LastReadAt *string `json:"last_read_at,omitempty"`
}

/*
MarkRepoNotificationsAsReadResponse is a response for MarkRepoNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type MarkRepoNotificationsAsReadResponse struct {
	httpResponse *http.Response
}

func (r *MarkRepoNotificationsAsReadResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
MarkThreadAsRead performs requests for "activity/mark-thread-as-read"

Mark a thread as read.

  PATCH /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
func MarkThreadAsRead(ctx context.Context, req *MarkThreadAsReadReq, opt ...requests.Option) (*MarkThreadAsReadResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MarkThreadAsReadReq)
	}
	resp := &MarkThreadAsReadResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewMarkThreadAsReadResponse(r, opts.PreserveResponseBody())
}

// NewMarkThreadAsReadResponse builds a new *MarkThreadAsReadResponse from an *http.Response
func NewMarkThreadAsReadResponse(resp *http.Response, preserveBody bool) (*MarkThreadAsReadResponse, error) {
	var result MarkThreadAsReadResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{205, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
MarkThreadAsRead performs requests for "activity/mark-thread-as-read"

Mark a thread as read.

  PATCH /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
func (c Client) MarkThreadAsRead(ctx context.Context, req *MarkThreadAsReadReq, opt ...requests.Option) (*MarkThreadAsReadResponse, error) {
	return MarkThreadAsRead(ctx, req, append(c, opt...)...)
}

/*
MarkThreadAsReadReq is request data for Client.MarkThreadAsRead

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
type MarkThreadAsReadReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request
func (r *MarkThreadAsReadReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MarkThreadAsReadReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PATCH",
		OperationID:        "activity/mark-thread-as-read",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/notifications/threads/%v", r.ThreadId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MarkThreadAsReadReq) Rel(link string, resp *MarkThreadAsReadResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MarkThreadAsReadResponse is a response for MarkThreadAsRead

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
type MarkThreadAsReadResponse struct {
	httpResponse *http.Response
}

func (r *MarkThreadAsReadResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
SetRepoSubscription performs requests for "activity/set-repo-subscription"

Set a repository subscription.

  PUT /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
func SetRepoSubscription(ctx context.Context, req *SetRepoSubscriptionReq, opt ...requests.Option) (*SetRepoSubscriptionResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetRepoSubscriptionReq)
	}
	resp := &SetRepoSubscriptionResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewSetRepoSubscriptionResponse(r, opts.PreserveResponseBody())
}

// NewSetRepoSubscriptionResponse builds a new *SetRepoSubscriptionResponse from an *http.Response
func NewSetRepoSubscriptionResponse(resp *http.Response, preserveBody bool) (*SetRepoSubscriptionResponse, error) {
	var result SetRepoSubscriptionResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
SetRepoSubscription performs requests for "activity/set-repo-subscription"

Set a repository subscription.

  PUT /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
func (c Client) SetRepoSubscription(ctx context.Context, req *SetRepoSubscriptionReq, opt ...requests.Option) (*SetRepoSubscriptionResponse, error) {
	return SetRepoSubscription(ctx, req, append(c, opt...)...)
}

/*
SetRepoSubscriptionReq is request data for Client.SetRepoSubscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type SetRepoSubscriptionReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody SetRepoSubscriptionReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetRepoSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetRepoSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "activity/set-repo-subscription",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetRepoSubscriptionReq) Rel(link string, resp *SetRepoSubscriptionResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetRepoSubscriptionReqBody is a request body for activity/set-repo-subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type SetRepoSubscriptionReqBody struct {

	// Determines if all notifications should be blocked from this repository.
	Ignored *bool `json:"ignored,omitempty"`

	// Determines if notifications should be received from this repository.
	Subscribed *bool `json:"subscribed,omitempty"`
}

/*
SetRepoSubscriptionResponse is a response for SetRepoSubscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type SetRepoSubscriptionResponse struct {
	httpResponse *http.Response
	Data         components.RepositorySubscription
}

func (r *SetRepoSubscriptionResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
SetThreadSubscription performs requests for "activity/set-thread-subscription"

Set a thread subscription.

  PUT /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
func SetThreadSubscription(ctx context.Context, req *SetThreadSubscriptionReq, opt ...requests.Option) (*SetThreadSubscriptionResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetThreadSubscriptionReq)
	}
	resp := &SetThreadSubscriptionResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewSetThreadSubscriptionResponse(r, opts.PreserveResponseBody())
}

// NewSetThreadSubscriptionResponse builds a new *SetThreadSubscriptionResponse from an *http.Response
func NewSetThreadSubscriptionResponse(resp *http.Response, preserveBody bool) (*SetThreadSubscriptionResponse, error) {
	var result SetThreadSubscriptionResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
SetThreadSubscription performs requests for "activity/set-thread-subscription"

Set a thread subscription.

  PUT /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
func (c Client) SetThreadSubscription(ctx context.Context, req *SetThreadSubscriptionReq, opt ...requests.Option) (*SetThreadSubscriptionResponse, error) {
	return SetThreadSubscription(ctx, req, append(c, opt...)...)
}

/*
SetThreadSubscriptionReq is request data for Client.SetThreadSubscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type SetThreadSubscriptionReq struct {
	_url string

	// thread_id parameter
	ThreadId    int64
	RequestBody SetThreadSubscriptionReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetThreadSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetThreadSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "activity/set-thread-subscription",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetThreadSubscriptionReq) Rel(link string, resp *SetThreadSubscriptionResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetThreadSubscriptionReqBody is a request body for activity/set-thread-subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type SetThreadSubscriptionReqBody struct {

	// Whether to block all notifications from a thread.
	Ignored *bool `json:"ignored,omitempty"`
}

/*
SetThreadSubscriptionResponse is a response for SetThreadSubscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type SetThreadSubscriptionResponse struct {
	httpResponse *http.Response
	Data         components.ThreadSubscription
}

func (r *SetThreadSubscriptionResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
StarRepoForAuthenticatedUser performs requests for "activity/star-repo-for-authenticated-user"

Star a repository for the authenticated user.

  PUT /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
func StarRepoForAuthenticatedUser(ctx context.Context, req *StarRepoForAuthenticatedUserReq, opt ...requests.Option) (*StarRepoForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(StarRepoForAuthenticatedUserReq)
	}
	resp := &StarRepoForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewStarRepoForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewStarRepoForAuthenticatedUserResponse builds a new *StarRepoForAuthenticatedUserResponse from an *http.Response
func NewStarRepoForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*StarRepoForAuthenticatedUserResponse, error) {
	var result StarRepoForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
StarRepoForAuthenticatedUser performs requests for "activity/star-repo-for-authenticated-user"

Star a repository for the authenticated user.

  PUT /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
func (c Client) StarRepoForAuthenticatedUser(ctx context.Context, req *StarRepoForAuthenticatedUserReq, opt ...requests.Option) (*StarRepoForAuthenticatedUserResponse, error) {
	return StarRepoForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
StarRepoForAuthenticatedUserReq is request data for Client.StarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
type StarRepoForAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *StarRepoForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *StarRepoForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "activity/star-repo-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StarRepoForAuthenticatedUserReq) Rel(link string, resp *StarRepoForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StarRepoForAuthenticatedUserResponse is a response for StarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
type StarRepoForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

func (r *StarRepoForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UnstarRepoForAuthenticatedUser performs requests for "activity/unstar-repo-for-authenticated-user"

Unstar a repository for the authenticated user.

  DELETE /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
func UnstarRepoForAuthenticatedUser(ctx context.Context, req *UnstarRepoForAuthenticatedUserReq, opt ...requests.Option) (*UnstarRepoForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnstarRepoForAuthenticatedUserReq)
	}
	resp := &UnstarRepoForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUnstarRepoForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewUnstarRepoForAuthenticatedUserResponse builds a new *UnstarRepoForAuthenticatedUserResponse from an *http.Response
func NewUnstarRepoForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*UnstarRepoForAuthenticatedUserResponse, error) {
	var result UnstarRepoForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
UnstarRepoForAuthenticatedUser performs requests for "activity/unstar-repo-for-authenticated-user"

Unstar a repository for the authenticated user.

  DELETE /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
func (c Client) UnstarRepoForAuthenticatedUser(ctx context.Context, req *UnstarRepoForAuthenticatedUserReq, opt ...requests.Option) (*UnstarRepoForAuthenticatedUserResponse, error) {
	return UnstarRepoForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
UnstarRepoForAuthenticatedUserReq is request data for Client.UnstarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
type UnstarRepoForAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *UnstarRepoForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnstarRepoForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "activity/unstar-repo-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnstarRepoForAuthenticatedUserReq) Rel(link string, resp *UnstarRepoForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnstarRepoForAuthenticatedUserResponse is a response for UnstarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
type UnstarRepoForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

func (r *UnstarRepoForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}
