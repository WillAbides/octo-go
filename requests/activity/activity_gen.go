// Code generated by octo-go; DO NOT EDIT.

package activity

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
CheckRepoIsStarredByAuthenticatedUser performs requests for "activity/check-repo-is-starred-by-authenticated-user"

Check if a repository is starred by the authenticated user.

  GET /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
func CheckRepoIsStarredByAuthenticatedUser(ctx context.Context, req *CheckRepoIsStarredByAuthenticatedUserReq, opt ...requests.Option) (*CheckRepoIsStarredByAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CheckRepoIsStarredByAuthenticatedUserReq)
	}
	resp := &CheckRepoIsStarredByAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckRepoIsStarredByAuthenticatedUser performs requests for "activity/check-repo-is-starred-by-authenticated-user"

Check if a repository is starred by the authenticated user.

  GET /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CheckRepoIsStarredByAuthenticatedUser(ctx context.Context, req *CheckRepoIsStarredByAuthenticatedUserReq, opt ...requests.Option) (*CheckRepoIsStarredByAuthenticatedUserResponse, error) {
	return CheckRepoIsStarredByAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
CheckRepoIsStarredByAuthenticatedUserReq is request data for Client.CheckRepoIsStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CheckRepoIsStarredByAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CheckRepoIsStarredByAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckRepoIsStarredByAuthenticatedUserReq) Rel(link string, resp *CheckRepoIsStarredByAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckRepoIsStarredByAuthenticatedUserResponse is a response for CheckRepoIsStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
type CheckRepoIsStarredByAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *CheckRepoIsStarredByAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CheckRepoIsStarredByAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteRepoSubscription performs requests for "activity/delete-repo-subscription"

Delete a repository subscription.

  DELETE /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
func DeleteRepoSubscription(ctx context.Context, req *DeleteRepoSubscriptionReq, opt ...requests.Option) (*DeleteRepoSubscriptionResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DeleteRepoSubscriptionReq)
	}
	resp := &DeleteRepoSubscriptionResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteRepoSubscription performs requests for "activity/delete-repo-subscription"

Delete a repository subscription.

  DELETE /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) DeleteRepoSubscription(ctx context.Context, req *DeleteRepoSubscriptionReq, opt ...requests.Option) (*DeleteRepoSubscriptionResponse, error) {
	return DeleteRepoSubscription(ctx, req, append(c, opt...)...)
}

/*
DeleteRepoSubscriptionReq is request data for Client.DeleteRepoSubscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DeleteRepoSubscriptionReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DeleteRepoSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteRepoSubscriptionReq) Rel(link string, resp *DeleteRepoSubscriptionResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteRepoSubscriptionResponse is a response for DeleteRepoSubscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
type DeleteRepoSubscriptionResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *DeleteRepoSubscriptionResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DeleteRepoSubscriptionResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteThreadSubscription performs requests for "activity/delete-thread-subscription"

Delete a thread subscription.

  DELETE /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
func DeleteThreadSubscription(ctx context.Context, req *DeleteThreadSubscriptionReq, opt ...requests.Option) (*DeleteThreadSubscriptionResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DeleteThreadSubscriptionReq)
	}
	resp := &DeleteThreadSubscriptionResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteThreadSubscription performs requests for "activity/delete-thread-subscription"

Delete a thread subscription.

  DELETE /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) DeleteThreadSubscription(ctx context.Context, req *DeleteThreadSubscriptionReq, opt ...requests.Option) (*DeleteThreadSubscriptionResponse, error) {
	return DeleteThreadSubscription(ctx, req, append(c, opt...)...)
}

/*
DeleteThreadSubscriptionReq is request data for Client.DeleteThreadSubscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DeleteThreadSubscriptionReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DeleteThreadSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteThreadSubscriptionReq) Rel(link string, resp *DeleteThreadSubscriptionResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteThreadSubscriptionResponse is a response for DeleteThreadSubscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
type DeleteThreadSubscriptionResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *DeleteThreadSubscriptionResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DeleteThreadSubscriptionResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
GetFeeds performs requests for "activity/get-feeds"

Get feeds.

  GET /feeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
func GetFeeds(ctx context.Context, req *GetFeedsReq, opt ...requests.Option) (*GetFeedsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetFeedsReq)
	}
	resp := &GetFeedsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetFeeds performs requests for "activity/get-feeds"

Get feeds.

  GET /feeds

https://developer.github.com/v3/activity/feeds/#get-feeds

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetFeeds(ctx context.Context, req *GetFeedsReq, opt ...requests.Option) (*GetFeedsResponse, error) {
	return GetFeeds(ctx, req, append(c, opt...)...)
}

/*
GetFeedsReq is request data for Client.GetFeeds

https://developer.github.com/v3/activity/feeds/#get-feeds

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetFeedsReq struct {
	_url string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetFeedsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/feeds"),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetFeedsReq) Rel(link string, resp *GetFeedsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetFeedsResponse is a response for GetFeeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
type GetFeedsResponse struct {
	httpResponse *http.Response
	Data         components.Feed
}

// HTTPResponse returns the *http.Response
func (r *GetFeedsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetFeedsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetRepoSubscription performs requests for "activity/get-repo-subscription"

Get a repository subscription.

  GET /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
func GetRepoSubscription(ctx context.Context, req *GetRepoSubscriptionReq, opt ...requests.Option) (*GetRepoSubscriptionResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetRepoSubscriptionReq)
	}
	resp := &GetRepoSubscriptionResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetRepoSubscription performs requests for "activity/get-repo-subscription"

Get a repository subscription.

  GET /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetRepoSubscription(ctx context.Context, req *GetRepoSubscriptionReq, opt ...requests.Option) (*GetRepoSubscriptionResponse, error) {
	return GetRepoSubscription(ctx, req, append(c, opt...)...)
}

/*
GetRepoSubscriptionReq is request data for Client.GetRepoSubscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetRepoSubscriptionReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetRepoSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetRepoSubscriptionReq) Rel(link string, resp *GetRepoSubscriptionResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetRepoSubscriptionResponse is a response for GetRepoSubscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
type GetRepoSubscriptionResponse struct {
	httpResponse *http.Response
	Data         components.RepositorySubscription
}

// HTTPResponse returns the *http.Response
func (r *GetRepoSubscriptionResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetRepoSubscriptionResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetThread performs requests for "activity/get-thread"

Get a thread.

  GET /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
func GetThread(ctx context.Context, req *GetThreadReq, opt ...requests.Option) (*GetThreadResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetThreadReq)
	}
	resp := &GetThreadResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetThread performs requests for "activity/get-thread"

Get a thread.

  GET /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#get-a-thread

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetThread(ctx context.Context, req *GetThreadReq, opt ...requests.Option) (*GetThreadResponse, error) {
	return GetThread(ctx, req, append(c, opt...)...)
}

/*
GetThreadReq is request data for Client.GetThread

https://developer.github.com/v3/activity/notifications/#get-a-thread

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetThreadReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetThreadReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/notifications/threads/%v", r.ThreadId),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetThreadReq) Rel(link string, resp *GetThreadResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetThreadResponse is a response for GetThread

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
type GetThreadResponse struct {
	httpResponse *http.Response
	Data         components.Thread
}

// HTTPResponse returns the *http.Response
func (r *GetThreadResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetThreadResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetThreadSubscriptionForAuthenticatedUser performs requests for "activity/get-thread-subscription-for-authenticated-user"

Get a thread subscription for the authenticated user.

  GET /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
func GetThreadSubscriptionForAuthenticatedUser(ctx context.Context, req *GetThreadSubscriptionForAuthenticatedUserReq, opt ...requests.Option) (*GetThreadSubscriptionForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetThreadSubscriptionForAuthenticatedUserReq)
	}
	resp := &GetThreadSubscriptionForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetThreadSubscriptionForAuthenticatedUser performs requests for "activity/get-thread-subscription-for-authenticated-user"

Get a thread subscription for the authenticated user.

  GET /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetThreadSubscriptionForAuthenticatedUser(ctx context.Context, req *GetThreadSubscriptionForAuthenticatedUserReq, opt ...requests.Option) (*GetThreadSubscriptionForAuthenticatedUserResponse, error) {
	return GetThreadSubscriptionForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
GetThreadSubscriptionForAuthenticatedUserReq is request data for Client.GetThreadSubscriptionForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetThreadSubscriptionForAuthenticatedUserReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetThreadSubscriptionForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetThreadSubscriptionForAuthenticatedUserReq) Rel(link string, resp *GetThreadSubscriptionForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetThreadSubscriptionForAuthenticatedUserResponse is a response for GetThreadSubscriptionForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
type GetThreadSubscriptionForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         components.ThreadSubscription
}

// HTTPResponse returns the *http.Response
func (r *GetThreadSubscriptionForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetThreadSubscriptionForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListEventsForAuthenticatedUser performs requests for "activity/list-events-for-authenticated-user"

List events for the authenticated user.

  GET /users/{username}/events

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
func ListEventsForAuthenticatedUser(ctx context.Context, req *ListEventsForAuthenticatedUserReq, opt ...requests.Option) (*ListEventsForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListEventsForAuthenticatedUserReq)
	}
	resp := &ListEventsForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListEventsForAuthenticatedUser performs requests for "activity/list-events-for-authenticated-user"

List events for the authenticated user.

  GET /users/{username}/events

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListEventsForAuthenticatedUser(ctx context.Context, req *ListEventsForAuthenticatedUserReq, opt ...requests.Option) (*ListEventsForAuthenticatedUserResponse, error) {
	return ListEventsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListEventsForAuthenticatedUserReq is request data for Client.ListEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListEventsForAuthenticatedUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListEventsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/events", r.Username),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListEventsForAuthenticatedUserReq) Rel(link string, resp *ListEventsForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListEventsForAuthenticatedUserResponse is a response for ListEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
type ListEventsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

// HTTPResponse returns the *http.Response
func (r *ListEventsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListEventsForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListNotificationsForAuthenticatedUser performs requests for "activity/list-notifications-for-authenticated-user"

List notifications for the authenticated user.

  GET /notifications

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
func ListNotificationsForAuthenticatedUser(ctx context.Context, req *ListNotificationsForAuthenticatedUserReq, opt ...requests.Option) (*ListNotificationsForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListNotificationsForAuthenticatedUserReq)
	}
	resp := &ListNotificationsForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListNotificationsForAuthenticatedUser performs requests for "activity/list-notifications-for-authenticated-user"

List notifications for the authenticated user.

  GET /notifications

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListNotificationsForAuthenticatedUser(ctx context.Context, req *ListNotificationsForAuthenticatedUserReq, opt ...requests.Option) (*ListNotificationsForAuthenticatedUserResponse, error) {
	return ListNotificationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListNotificationsForAuthenticatedUserReq is request data for Client.ListNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListNotificationsForAuthenticatedUserReq struct {
	_url string

	// If `true`, show notifications marked as read.
	All *bool

	/*
	If `true`, only shows notifications in which the user is directly participating
	or mentioned.
	*/
	Participating *bool

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only show notifications updated before the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Before *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListNotificationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.All != nil {
		query.Set("all", strconv.FormatBool(*r.All))
	}
	if r.Participating != nil {
		query.Set("participating", strconv.FormatBool(*r.Participating))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Before != nil {
		query.Set("before", *r.Before)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/notifications"),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListNotificationsForAuthenticatedUserReq) Rel(link string, resp *ListNotificationsForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListNotificationsForAuthenticatedUserResponse is a response for ListNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
type ListNotificationsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.Thread
}

// HTTPResponse returns the *http.Response
func (r *ListNotificationsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListNotificationsForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListOrgEventsForAuthenticatedUser performs requests for "activity/list-org-events-for-authenticated-user"

List organization events for the authenticated user.

  GET /users/{username}/events/orgs/{org}

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
func ListOrgEventsForAuthenticatedUser(ctx context.Context, req *ListOrgEventsForAuthenticatedUserReq, opt ...requests.Option) (*ListOrgEventsForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListOrgEventsForAuthenticatedUserReq)
	}
	resp := &ListOrgEventsForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListOrgEventsForAuthenticatedUser performs requests for "activity/list-org-events-for-authenticated-user"

List organization events for the authenticated user.

  GET /users/{username}/events/orgs/{org}

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListOrgEventsForAuthenticatedUser(ctx context.Context, req *ListOrgEventsForAuthenticatedUserReq, opt ...requests.Option) (*ListOrgEventsForAuthenticatedUserResponse, error) {
	return ListOrgEventsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListOrgEventsForAuthenticatedUserReq is request data for Client.ListOrgEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListOrgEventsForAuthenticatedUserReq struct {
	_url     string
	Username string
	Org      string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListOrgEventsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/events/orgs/%v", r.Username, r.Org),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListOrgEventsForAuthenticatedUserReq) Rel(link string, resp *ListOrgEventsForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListOrgEventsForAuthenticatedUserResponse is a response for ListOrgEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
type ListOrgEventsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

// HTTPResponse returns the *http.Response
func (r *ListOrgEventsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListOrgEventsForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListPublicEvents performs requests for "activity/list-public-events"

List public events.

  GET /events

https://developer.github.com/v3/activity/events/#list-public-events
*/
func ListPublicEvents(ctx context.Context, req *ListPublicEventsReq, opt ...requests.Option) (*ListPublicEventsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListPublicEventsReq)
	}
	resp := &ListPublicEventsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublicEvents performs requests for "activity/list-public-events"

List public events.

  GET /events

https://developer.github.com/v3/activity/events/#list-public-events

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListPublicEvents(ctx context.Context, req *ListPublicEventsReq, opt ...requests.Option) (*ListPublicEventsResponse, error) {
	return ListPublicEvents(ctx, req, append(c, opt...)...)
}

/*
ListPublicEventsReq is request data for Client.ListPublicEvents

https://developer.github.com/v3/activity/events/#list-public-events

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListPublicEventsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListPublicEventsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/events"),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicEventsReq) Rel(link string, resp *ListPublicEventsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicEventsResponse is a response for ListPublicEvents

https://developer.github.com/v3/activity/events/#list-public-events
*/
type ListPublicEventsResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

// HTTPResponse returns the *http.Response
func (r *ListPublicEventsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListPublicEventsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListPublicEventsForRepoNetwork performs requests for "activity/list-public-events-for-repo-network"

List public events for a network of repositories.

  GET /networks/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
func ListPublicEventsForRepoNetwork(ctx context.Context, req *ListPublicEventsForRepoNetworkReq, opt ...requests.Option) (*ListPublicEventsForRepoNetworkResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListPublicEventsForRepoNetworkReq)
	}
	resp := &ListPublicEventsForRepoNetworkResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublicEventsForRepoNetwork performs requests for "activity/list-public-events-for-repo-network"

List public events for a network of repositories.

  GET /networks/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListPublicEventsForRepoNetwork(ctx context.Context, req *ListPublicEventsForRepoNetworkReq, opt ...requests.Option) (*ListPublicEventsForRepoNetworkResponse, error) {
	return ListPublicEventsForRepoNetwork(ctx, req, append(c, opt...)...)
}

/*
ListPublicEventsForRepoNetworkReq is request data for Client.ListPublicEventsForRepoNetwork

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListPublicEventsForRepoNetworkReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListPublicEventsForRepoNetworkReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/networks/%v/%v/events", r.Owner, r.Repo),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicEventsForRepoNetworkReq) Rel(link string, resp *ListPublicEventsForRepoNetworkResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicEventsForRepoNetworkResponse is a response for ListPublicEventsForRepoNetwork

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
type ListPublicEventsForRepoNetworkResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

// HTTPResponse returns the *http.Response
func (r *ListPublicEventsForRepoNetworkResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListPublicEventsForRepoNetworkResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 301, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListPublicEventsForUser performs requests for "activity/list-public-events-for-user"

List public events for a user.

  GET /users/{username}/events/public

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
func ListPublicEventsForUser(ctx context.Context, req *ListPublicEventsForUserReq, opt ...requests.Option) (*ListPublicEventsForUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListPublicEventsForUserReq)
	}
	resp := &ListPublicEventsForUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublicEventsForUser performs requests for "activity/list-public-events-for-user"

List public events for a user.

  GET /users/{username}/events/public

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListPublicEventsForUser(ctx context.Context, req *ListPublicEventsForUserReq, opt ...requests.Option) (*ListPublicEventsForUserResponse, error) {
	return ListPublicEventsForUser(ctx, req, append(c, opt...)...)
}

/*
ListPublicEventsForUserReq is request data for Client.ListPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListPublicEventsForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListPublicEventsForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/events/public", r.Username),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicEventsForUserReq) Rel(link string, resp *ListPublicEventsForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicEventsForUserResponse is a response for ListPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
type ListPublicEventsForUserResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

// HTTPResponse returns the *http.Response
func (r *ListPublicEventsForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListPublicEventsForUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListPublicOrgEvents performs requests for "activity/list-public-org-events"

List public organization events.

  GET /orgs/{org}/events

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
func ListPublicOrgEvents(ctx context.Context, req *ListPublicOrgEventsReq, opt ...requests.Option) (*ListPublicOrgEventsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListPublicOrgEventsReq)
	}
	resp := &ListPublicOrgEventsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublicOrgEvents performs requests for "activity/list-public-org-events"

List public organization events.

  GET /orgs/{org}/events

https://developer.github.com/v3/activity/events/#list-public-organization-events

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListPublicOrgEvents(ctx context.Context, req *ListPublicOrgEventsReq, opt ...requests.Option) (*ListPublicOrgEventsResponse, error) {
	return ListPublicOrgEvents(ctx, req, append(c, opt...)...)
}

/*
ListPublicOrgEventsReq is request data for Client.ListPublicOrgEvents

https://developer.github.com/v3/activity/events/#list-public-organization-events

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListPublicOrgEventsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListPublicOrgEventsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/orgs/%v/events", r.Org),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicOrgEventsReq) Rel(link string, resp *ListPublicOrgEventsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicOrgEventsResponse is a response for ListPublicOrgEvents

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
type ListPublicOrgEventsResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

// HTTPResponse returns the *http.Response
func (r *ListPublicOrgEventsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListPublicOrgEventsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListReceivedEventsForUser performs requests for "activity/list-received-events-for-user"

List events received by the authenticated user.

  GET /users/{username}/received_events

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
func ListReceivedEventsForUser(ctx context.Context, req *ListReceivedEventsForUserReq, opt ...requests.Option) (*ListReceivedEventsForUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReceivedEventsForUserReq)
	}
	resp := &ListReceivedEventsForUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReceivedEventsForUser performs requests for "activity/list-received-events-for-user"

List events received by the authenticated user.

  GET /users/{username}/received_events

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListReceivedEventsForUser(ctx context.Context, req *ListReceivedEventsForUserReq, opt ...requests.Option) (*ListReceivedEventsForUserResponse, error) {
	return ListReceivedEventsForUser(ctx, req, append(c, opt...)...)
}

/*
ListReceivedEventsForUserReq is request data for Client.ListReceivedEventsForUser

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReceivedEventsForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReceivedEventsForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/received_events", r.Username),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReceivedEventsForUserReq) Rel(link string, resp *ListReceivedEventsForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReceivedEventsForUserResponse is a response for ListReceivedEventsForUser

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
type ListReceivedEventsForUserResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

// HTTPResponse returns the *http.Response
func (r *ListReceivedEventsForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListReceivedEventsForUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListReceivedPublicEventsForUser performs requests for "activity/list-received-public-events-for-user"

List public events received by a user.

  GET /users/{username}/received_events/public

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
func ListReceivedPublicEventsForUser(ctx context.Context, req *ListReceivedPublicEventsForUserReq, opt ...requests.Option) (*ListReceivedPublicEventsForUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReceivedPublicEventsForUserReq)
	}
	resp := &ListReceivedPublicEventsForUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReceivedPublicEventsForUser performs requests for "activity/list-received-public-events-for-user"

List public events received by a user.

  GET /users/{username}/received_events/public

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListReceivedPublicEventsForUser(ctx context.Context, req *ListReceivedPublicEventsForUserReq, opt ...requests.Option) (*ListReceivedPublicEventsForUserResponse, error) {
	return ListReceivedPublicEventsForUser(ctx, req, append(c, opt...)...)
}

/*
ListReceivedPublicEventsForUserReq is request data for Client.ListReceivedPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReceivedPublicEventsForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReceivedPublicEventsForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/received_events/public", r.Username),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReceivedPublicEventsForUserReq) Rel(link string, resp *ListReceivedPublicEventsForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReceivedPublicEventsForUserResponse is a response for ListReceivedPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
type ListReceivedPublicEventsForUserResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

// HTTPResponse returns the *http.Response
func (r *ListReceivedPublicEventsForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListReceivedPublicEventsForUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListRepoEvents performs requests for "activity/list-repo-events"

List repository events.

  GET /repos/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-repository-events
*/
func ListRepoEvents(ctx context.Context, req *ListRepoEventsReq, opt ...requests.Option) (*ListRepoEventsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListRepoEventsReq)
	}
	resp := &ListRepoEventsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListRepoEvents performs requests for "activity/list-repo-events"

List repository events.

  GET /repos/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-repository-events

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListRepoEvents(ctx context.Context, req *ListRepoEventsReq, opt ...requests.Option) (*ListRepoEventsResponse, error) {
	return ListRepoEvents(ctx, req, append(c, opt...)...)
}

/*
ListRepoEventsReq is request data for Client.ListRepoEvents

https://developer.github.com/v3/activity/events/#list-repository-events

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListRepoEventsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListRepoEventsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/events", r.Owner, r.Repo),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListRepoEventsReq) Rel(link string, resp *ListRepoEventsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListRepoEventsResponse is a response for ListRepoEvents

https://developer.github.com/v3/activity/events/#list-repository-events
*/
type ListRepoEventsResponse struct {
	httpResponse *http.Response
	Data         []components.Event
}

// HTTPResponse returns the *http.Response
func (r *ListRepoEventsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListRepoEventsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListRepoNotificationsForAuthenticatedUser performs requests for "activity/list-repo-notifications-for-authenticated-user"

List repository notifications for the authenticated user.

  GET /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
func ListRepoNotificationsForAuthenticatedUser(ctx context.Context, req *ListRepoNotificationsForAuthenticatedUserReq, opt ...requests.Option) (*ListRepoNotificationsForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListRepoNotificationsForAuthenticatedUserReq)
	}
	resp := &ListRepoNotificationsForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListRepoNotificationsForAuthenticatedUser performs requests for "activity/list-repo-notifications-for-authenticated-user"

List repository notifications for the authenticated user.

  GET /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListRepoNotificationsForAuthenticatedUser(ctx context.Context, req *ListRepoNotificationsForAuthenticatedUserReq, opt ...requests.Option) (*ListRepoNotificationsForAuthenticatedUserResponse, error) {
	return ListRepoNotificationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListRepoNotificationsForAuthenticatedUserReq is request data for Client.ListRepoNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListRepoNotificationsForAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string

	// If `true`, show notifications marked as read.
	All *bool

	/*
	If `true`, only shows notifications in which the user is directly participating
	or mentioned.
	*/
	Participating *bool

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only show notifications updated before the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Before *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListRepoNotificationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.All != nil {
		query.Set("all", strconv.FormatBool(*r.All))
	}
	if r.Participating != nil {
		query.Set("participating", strconv.FormatBool(*r.Participating))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Before != nil {
		query.Set("before", *r.Before)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/notifications", r.Owner, r.Repo),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListRepoNotificationsForAuthenticatedUserReq) Rel(link string, resp *ListRepoNotificationsForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListRepoNotificationsForAuthenticatedUserResponse is a response for ListRepoNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
type ListRepoNotificationsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.Thread
}

// HTTPResponse returns the *http.Response
func (r *ListRepoNotificationsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListRepoNotificationsForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListReposStarredByAuthenticatedUser performs requests for "activity/list-repos-starred-by-authenticated-user"

List repositories starred by the authenticated user.

  GET /user/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
func ListReposStarredByAuthenticatedUser(ctx context.Context, req *ListReposStarredByAuthenticatedUserReq, opt ...requests.Option) (*ListReposStarredByAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReposStarredByAuthenticatedUserReq)
	}
	resp := &ListReposStarredByAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposStarredByAuthenticatedUser performs requests for "activity/list-repos-starred-by-authenticated-user"

List repositories starred by the authenticated user.

  GET /user/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListReposStarredByAuthenticatedUser(ctx context.Context, req *ListReposStarredByAuthenticatedUserReq, opt ...requests.Option) (*ListReposStarredByAuthenticatedUserResponse, error) {
	return ListReposStarredByAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListReposStarredByAuthenticatedUserReq is request data for Client.ListReposStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReposStarredByAuthenticatedUserReq struct {
	_url string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReposStarredByAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/vnd.github.v3.star+json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/starred"),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposStarredByAuthenticatedUserReq) Rel(link string, resp *ListReposStarredByAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposStarredByAuthenticatedUserResponse is a response for ListReposStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
type ListReposStarredByAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.StarredRepository
}

// HTTPResponse returns the *http.Response
func (r *ListReposStarredByAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListReposStarredByAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListReposStarredByUser performs requests for "activity/list-repos-starred-by-user"

List repositories starred by a user.

  GET /users/{username}/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
func ListReposStarredByUser(ctx context.Context, req *ListReposStarredByUserReq, opt ...requests.Option) (*ListReposStarredByUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReposStarredByUserReq)
	}
	resp := &ListReposStarredByUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposStarredByUser performs requests for "activity/list-repos-starred-by-user"

List repositories starred by a user.

  GET /users/{username}/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListReposStarredByUser(ctx context.Context, req *ListReposStarredByUserReq, opt ...requests.Option) (*ListReposStarredByUserResponse, error) {
	return ListReposStarredByUser(ctx, req, append(c, opt...)...)
}

/*
ListReposStarredByUserReq is request data for Client.ListReposStarredByUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReposStarredByUserReq struct {
	_url     string
	Username string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReposStarredByUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/vnd.github.v3.star+json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/starred", r.Username),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposStarredByUserReq) Rel(link string, resp *ListReposStarredByUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposStarredByUserResponse is a response for ListReposStarredByUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
type ListReposStarredByUserResponse struct {
	httpResponse *http.Response
	Data         []components.StarredRepository
}

// HTTPResponse returns the *http.Response
func (r *ListReposStarredByUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListReposStarredByUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListReposWatchedByUser performs requests for "activity/list-repos-watched-by-user"

List repositories watched by a user.

  GET /users/{username}/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
func ListReposWatchedByUser(ctx context.Context, req *ListReposWatchedByUserReq, opt ...requests.Option) (*ListReposWatchedByUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReposWatchedByUserReq)
	}
	resp := &ListReposWatchedByUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposWatchedByUser performs requests for "activity/list-repos-watched-by-user"

List repositories watched by a user.

  GET /users/{username}/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListReposWatchedByUser(ctx context.Context, req *ListReposWatchedByUserReq, opt ...requests.Option) (*ListReposWatchedByUserResponse, error) {
	return ListReposWatchedByUser(ctx, req, append(c, opt...)...)
}

/*
ListReposWatchedByUserReq is request data for Client.ListReposWatchedByUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReposWatchedByUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReposWatchedByUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/subscriptions", r.Username),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposWatchedByUserReq) Rel(link string, resp *ListReposWatchedByUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposWatchedByUserResponse is a response for ListReposWatchedByUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
type ListReposWatchedByUserResponse struct {
	httpResponse *http.Response
	Data         []components.MinimalRepository
}

// HTTPResponse returns the *http.Response
func (r *ListReposWatchedByUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListReposWatchedByUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListStargazersForRepo performs requests for "activity/list-stargazers-for-repo"

List stargazers.

  GET /repos/{owner}/{repo}/stargazers

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
func ListStargazersForRepo(ctx context.Context, req *ListStargazersForRepoReq, opt ...requests.Option) (*ListStargazersForRepoResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListStargazersForRepoReq)
	}
	resp := &ListStargazersForRepoResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListStargazersForRepo performs requests for "activity/list-stargazers-for-repo"

List stargazers.

  GET /repos/{owner}/{repo}/stargazers

https://developer.github.com/v3/activity/starring/#list-stargazers

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListStargazersForRepo(ctx context.Context, req *ListStargazersForRepoReq, opt ...requests.Option) (*ListStargazersForRepoResponse, error) {
	return ListStargazersForRepo(ctx, req, append(c, opt...)...)
}

/*
ListStargazersForRepoReq is request data for Client.ListStargazersForRepo

https://developer.github.com/v3/activity/starring/#list-stargazers

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListStargazersForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListStargazersForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/vnd.github.v3.star+json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/stargazers", r.Owner, r.Repo),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListStargazersForRepoReq) Rel(link string, resp *ListStargazersForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListStargazersForRepoResponse is a response for ListStargazersForRepo

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
type ListStargazersForRepoResponse struct {
	httpResponse *http.Response
	Data         []components.Stargazer
}

// HTTPResponse returns the *http.Response
func (r *ListStargazersForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListStargazersForRepoResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListWatchedReposForAuthenticatedUser performs requests for "activity/list-watched-repos-for-authenticated-user"

List repositories watched by the authenticated user.

  GET /user/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
func ListWatchedReposForAuthenticatedUser(ctx context.Context, req *ListWatchedReposForAuthenticatedUserReq, opt ...requests.Option) (*ListWatchedReposForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListWatchedReposForAuthenticatedUserReq)
	}
	resp := &ListWatchedReposForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListWatchedReposForAuthenticatedUser performs requests for "activity/list-watched-repos-for-authenticated-user"

List repositories watched by the authenticated user.

  GET /user/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListWatchedReposForAuthenticatedUser(ctx context.Context, req *ListWatchedReposForAuthenticatedUserReq, opt ...requests.Option) (*ListWatchedReposForAuthenticatedUserResponse, error) {
	return ListWatchedReposForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListWatchedReposForAuthenticatedUserReq is request data for Client.ListWatchedReposForAuthenticatedUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListWatchedReposForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListWatchedReposForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/subscriptions"),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListWatchedReposForAuthenticatedUserReq) Rel(link string, resp *ListWatchedReposForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListWatchedReposForAuthenticatedUserResponse is a response for ListWatchedReposForAuthenticatedUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
type ListWatchedReposForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.MinimalRepository
}

// HTTPResponse returns the *http.Response
func (r *ListWatchedReposForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListWatchedReposForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListWatchersForRepo performs requests for "activity/list-watchers-for-repo"

List watchers.

  GET /repos/{owner}/{repo}/subscribers

https://developer.github.com/v3/activity/watching/#list-watchers
*/
func ListWatchersForRepo(ctx context.Context, req *ListWatchersForRepoReq, opt ...requests.Option) (*ListWatchersForRepoResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListWatchersForRepoReq)
	}
	resp := &ListWatchersForRepoResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListWatchersForRepo performs requests for "activity/list-watchers-for-repo"

List watchers.

  GET /repos/{owner}/{repo}/subscribers

https://developer.github.com/v3/activity/watching/#list-watchers

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListWatchersForRepo(ctx context.Context, req *ListWatchersForRepoReq, opt ...requests.Option) (*ListWatchersForRepoResponse, error) {
	return ListWatchersForRepo(ctx, req, append(c, opt...)...)
}

/*
ListWatchersForRepoReq is request data for Client.ListWatchersForRepo

https://developer.github.com/v3/activity/watching/#list-watchers

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListWatchersForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListWatchersForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/subscribers", r.Owner, r.Repo),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListWatchersForRepoReq) Rel(link string, resp *ListWatchersForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListWatchersForRepoResponse is a response for ListWatchersForRepo

https://developer.github.com/v3/activity/watching/#list-watchers
*/
type ListWatchersForRepoResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

// HTTPResponse returns the *http.Response
func (r *ListWatchersForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListWatchersForRepoResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
MarkNotificationsAsRead performs requests for "activity/mark-notifications-as-read"

Mark notifications as read.

  PUT /notifications

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
func MarkNotificationsAsRead(ctx context.Context, req *MarkNotificationsAsReadReq, opt ...requests.Option) (*MarkNotificationsAsReadResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(MarkNotificationsAsReadReq)
	}
	resp := &MarkNotificationsAsReadResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MarkNotificationsAsRead performs requests for "activity/mark-notifications-as-read"

Mark notifications as read.

  PUT /notifications

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) MarkNotificationsAsRead(ctx context.Context, req *MarkNotificationsAsReadReq, opt ...requests.Option) (*MarkNotificationsAsReadResponse, error) {
	return MarkNotificationsAsRead(ctx, req, append(c, opt...)...)
}

/*
MarkNotificationsAsReadReq is request data for Client.MarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type MarkNotificationsAsReadReq struct {
	_url        string
	RequestBody MarkNotificationsAsReadReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *MarkNotificationsAsReadReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		Options:          opt,
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications"),
		URLQuery:         query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MarkNotificationsAsReadReq) Rel(link string, resp *MarkNotificationsAsReadResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MarkNotificationsAsReadReqBody is a request body for activity/mark-notifications-as-read

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type MarkNotificationsAsReadReqBody struct {

	// Describes the last point that notifications were checked.
	LastReadAt *string `json:"last_read_at,omitempty"`

	// Whether the notification has been read.
	Read *bool `json:"read,omitempty"`
}

/*
MarkNotificationsAsReadResponseBody is a response body for MarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type MarkNotificationsAsReadResponseBody struct {
	Message string `json:"message,omitempty"`
}

/*
MarkNotificationsAsReadResponse is a response for MarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type MarkNotificationsAsReadResponse struct {
	httpResponse *http.Response
	Data         MarkNotificationsAsReadResponseBody
}

// HTTPResponse returns the *http.Response
func (r *MarkNotificationsAsReadResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *MarkNotificationsAsReadResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{202, 205, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{202}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
MarkRepoNotificationsAsRead performs requests for "activity/mark-repo-notifications-as-read"

Mark repository notifications as read.

  PUT /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
func MarkRepoNotificationsAsRead(ctx context.Context, req *MarkRepoNotificationsAsReadReq, opt ...requests.Option) (*MarkRepoNotificationsAsReadResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(MarkRepoNotificationsAsReadReq)
	}
	resp := &MarkRepoNotificationsAsReadResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MarkRepoNotificationsAsRead performs requests for "activity/mark-repo-notifications-as-read"

Mark repository notifications as read.

  PUT /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) MarkRepoNotificationsAsRead(ctx context.Context, req *MarkRepoNotificationsAsReadReq, opt ...requests.Option) (*MarkRepoNotificationsAsReadResponse, error) {
	return MarkRepoNotificationsAsRead(ctx, req, append(c, opt...)...)
}

/*
MarkRepoNotificationsAsReadReq is request data for Client.MarkRepoNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type MarkRepoNotificationsAsReadReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody MarkRepoNotificationsAsReadReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *MarkRepoNotificationsAsReadReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "PUT",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/notifications", r.Owner, r.Repo),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MarkRepoNotificationsAsReadReq) Rel(link string, resp *MarkRepoNotificationsAsReadResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MarkRepoNotificationsAsReadReqBody is a request body for activity/mark-repo-notifications-as-read

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type MarkRepoNotificationsAsReadReqBody struct {

	/*
	Describes the last point that notifications were checked. Anything updated since
	this time will not be marked as read. If you omit this parameter, all
	notifications are marked as read. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Default: The current timestamp.
	*/
	LastReadAt *string `json:"last_read_at,omitempty"`
}

/*
MarkRepoNotificationsAsReadResponse is a response for MarkRepoNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type MarkRepoNotificationsAsReadResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *MarkRepoNotificationsAsReadResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *MarkRepoNotificationsAsReadResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{202})
	if err != nil {
		return err
	}
	return nil
}

/*
MarkThreadAsRead performs requests for "activity/mark-thread-as-read"

Mark a thread as read.

  PATCH /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
func MarkThreadAsRead(ctx context.Context, req *MarkThreadAsReadReq, opt ...requests.Option) (*MarkThreadAsReadResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(MarkThreadAsReadReq)
	}
	resp := &MarkThreadAsReadResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MarkThreadAsRead performs requests for "activity/mark-thread-as-read"

Mark a thread as read.

  PATCH /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) MarkThreadAsRead(ctx context.Context, req *MarkThreadAsReadReq, opt ...requests.Option) (*MarkThreadAsReadResponse, error) {
	return MarkThreadAsRead(ctx, req, append(c, opt...)...)
}

/*
MarkThreadAsReadReq is request data for Client.MarkThreadAsRead

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type MarkThreadAsReadReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *MarkThreadAsReadReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PATCH",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/notifications/threads/%v", r.ThreadId),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MarkThreadAsReadReq) Rel(link string, resp *MarkThreadAsReadResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MarkThreadAsReadResponse is a response for MarkThreadAsRead

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
type MarkThreadAsReadResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *MarkThreadAsReadResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *MarkThreadAsReadResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{205, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
SetRepoSubscription performs requests for "activity/set-repo-subscription"

Set a repository subscription.

  PUT /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
func SetRepoSubscription(ctx context.Context, req *SetRepoSubscriptionReq, opt ...requests.Option) (*SetRepoSubscriptionResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(SetRepoSubscriptionReq)
	}
	resp := &SetRepoSubscriptionResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetRepoSubscription performs requests for "activity/set-repo-subscription"

Set a repository subscription.

  PUT /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) SetRepoSubscription(ctx context.Context, req *SetRepoSubscriptionReq, opt ...requests.Option) (*SetRepoSubscriptionResponse, error) {
	return SetRepoSubscription(ctx, req, append(c, opt...)...)
}

/*
SetRepoSubscriptionReq is request data for Client.SetRepoSubscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type SetRepoSubscriptionReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody SetRepoSubscriptionReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *SetRepoSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		Options:          opt,
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo),
		URLQuery:         query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetRepoSubscriptionReq) Rel(link string, resp *SetRepoSubscriptionResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetRepoSubscriptionReqBody is a request body for activity/set-repo-subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type SetRepoSubscriptionReqBody struct {

	// Determines if all notifications should be blocked from this repository.
	Ignored *bool `json:"ignored,omitempty"`

	// Determines if notifications should be received from this repository.
	Subscribed *bool `json:"subscribed,omitempty"`
}

/*
SetRepoSubscriptionResponse is a response for SetRepoSubscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type SetRepoSubscriptionResponse struct {
	httpResponse *http.Response
	Data         components.RepositorySubscription
}

// HTTPResponse returns the *http.Response
func (r *SetRepoSubscriptionResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *SetRepoSubscriptionResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
SetThreadSubscription performs requests for "activity/set-thread-subscription"

Set a thread subscription.

  PUT /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
func SetThreadSubscription(ctx context.Context, req *SetThreadSubscriptionReq, opt ...requests.Option) (*SetThreadSubscriptionResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(SetThreadSubscriptionReq)
	}
	resp := &SetThreadSubscriptionResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetThreadSubscription performs requests for "activity/set-thread-subscription"

Set a thread subscription.

  PUT /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) SetThreadSubscription(ctx context.Context, req *SetThreadSubscriptionReq, opt ...requests.Option) (*SetThreadSubscriptionResponse, error) {
	return SetThreadSubscription(ctx, req, append(c, opt...)...)
}

/*
SetThreadSubscriptionReq is request data for Client.SetThreadSubscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type SetThreadSubscriptionReq struct {
	_url string

	// thread_id parameter
	ThreadId    int64
	RequestBody SetThreadSubscriptionReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *SetThreadSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		Options:          opt,
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId),
		URLQuery:         query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetThreadSubscriptionReq) Rel(link string, resp *SetThreadSubscriptionResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetThreadSubscriptionReqBody is a request body for activity/set-thread-subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type SetThreadSubscriptionReqBody struct {

	// Whether to block all notifications from a thread.
	Ignored *bool `json:"ignored,omitempty"`
}

/*
SetThreadSubscriptionResponse is a response for SetThreadSubscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type SetThreadSubscriptionResponse struct {
	httpResponse *http.Response
	Data         components.ThreadSubscription
}

// HTTPResponse returns the *http.Response
func (r *SetThreadSubscriptionResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *SetThreadSubscriptionResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
StarRepoForAuthenticatedUser performs requests for "activity/star-repo-for-authenticated-user"

Star a repository for the authenticated user.

  PUT /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
func StarRepoForAuthenticatedUser(ctx context.Context, req *StarRepoForAuthenticatedUserReq, opt ...requests.Option) (*StarRepoForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(StarRepoForAuthenticatedUserReq)
	}
	resp := &StarRepoForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
StarRepoForAuthenticatedUser performs requests for "activity/star-repo-for-authenticated-user"

Star a repository for the authenticated user.

  PUT /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) StarRepoForAuthenticatedUser(ctx context.Context, req *StarRepoForAuthenticatedUserReq, opt ...requests.Option) (*StarRepoForAuthenticatedUserResponse, error) {
	return StarRepoForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
StarRepoForAuthenticatedUserReq is request data for Client.StarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type StarRepoForAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *StarRepoForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StarRepoForAuthenticatedUserReq) Rel(link string, resp *StarRepoForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StarRepoForAuthenticatedUserResponse is a response for StarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
type StarRepoForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *StarRepoForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *StarRepoForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
UnstarRepoForAuthenticatedUser performs requests for "activity/unstar-repo-for-authenticated-user"

Unstar a repository for the authenticated user.

  DELETE /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
func UnstarRepoForAuthenticatedUser(ctx context.Context, req *UnstarRepoForAuthenticatedUserReq, opt ...requests.Option) (*UnstarRepoForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UnstarRepoForAuthenticatedUserReq)
	}
	resp := &UnstarRepoForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UnstarRepoForAuthenticatedUser performs requests for "activity/unstar-repo-for-authenticated-user"

Unstar a repository for the authenticated user.

  DELETE /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) UnstarRepoForAuthenticatedUser(ctx context.Context, req *UnstarRepoForAuthenticatedUserReq, opt ...requests.Option) (*UnstarRepoForAuthenticatedUserResponse, error) {
	return UnstarRepoForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
UnstarRepoForAuthenticatedUserReq is request data for Client.UnstarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UnstarRepoForAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UnstarRepoForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		Options:            opt,
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo),
		URLQuery:           query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnstarRepoForAuthenticatedUserReq) Rel(link string, resp *UnstarRepoForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnstarRepoForAuthenticatedUserResponse is a response for UnstarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
type UnstarRepoForAuthenticatedUserResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *UnstarRepoForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UnstarRepoForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 304})
	if err != nil {
		return err
	}
	return nil
}
