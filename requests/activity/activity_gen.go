// Code generated by octo-go; DO NOT EDIT.

package activity

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
CheckRepoIsStarredByAuthenticatedUser performs requests for "activity/check-repo-is-starred-by-authenticated-user"

Check if a repository is starred by the authenticated user.

  GET /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
func CheckRepoIsStarredByAuthenticatedUser(ctx context.Context, req *CheckRepoIsStarredByAuthenticatedUserReq, opt ...requests.Option) (*CheckRepoIsStarredByAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckRepoIsStarredByAuthenticatedUserReq)
	}
	resp := &CheckRepoIsStarredByAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckRepoIsStarredByAuthenticatedUser performs requests for "activity/check-repo-is-starred-by-authenticated-user"

Check if a repository is starred by the authenticated user.

  GET /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
func (c Client) CheckRepoIsStarredByAuthenticatedUser(ctx context.Context, req *CheckRepoIsStarredByAuthenticatedUserReq, opt ...requests.Option) (*CheckRepoIsStarredByAuthenticatedUserResponse, error) {
	return CheckRepoIsStarredByAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
CheckRepoIsStarredByAuthenticatedUserReq is request data for Client.CheckRepoIsStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
type CheckRepoIsStarredByAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *CheckRepoIsStarredByAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckRepoIsStarredByAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "activity/check-repo-is-starred-by-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckRepoIsStarredByAuthenticatedUserReq) Rel(link string, resp *CheckRepoIsStarredByAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckRepoIsStarredByAuthenticatedUserResponse is a response for CheckRepoIsStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#check-if-a-repository-is-starred-by-the-authenticated-user
*/
type CheckRepoIsStarredByAuthenticatedUserResponse struct {
	requests.Response
	request *CheckRepoIsStarredByAuthenticatedUserReq
}

/*
DeleteRepoSubscription performs requests for "activity/delete-repo-subscription"

Delete a repository subscription.

  DELETE /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
func DeleteRepoSubscription(ctx context.Context, req *DeleteRepoSubscriptionReq, opt ...requests.Option) (*DeleteRepoSubscriptionResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteRepoSubscriptionReq)
	}
	resp := &DeleteRepoSubscriptionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteRepoSubscription performs requests for "activity/delete-repo-subscription"

Delete a repository subscription.

  DELETE /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
func (c Client) DeleteRepoSubscription(ctx context.Context, req *DeleteRepoSubscriptionReq, opt ...requests.Option) (*DeleteRepoSubscriptionResponse, error) {
	return DeleteRepoSubscription(ctx, req, append(c, opt...)...)
}

/*
DeleteRepoSubscriptionReq is request data for Client.DeleteRepoSubscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
type DeleteRepoSubscriptionReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *DeleteRepoSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteRepoSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "activity/delete-repo-subscription",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteRepoSubscriptionReq) Rel(link string, resp *DeleteRepoSubscriptionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteRepoSubscriptionResponse is a response for DeleteRepoSubscription

https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
*/
type DeleteRepoSubscriptionResponse struct {
	requests.Response
	request *DeleteRepoSubscriptionReq
}

/*
DeleteThreadSubscription performs requests for "activity/delete-thread-subscription"

Delete a thread subscription.

  DELETE /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
func DeleteThreadSubscription(ctx context.Context, req *DeleteThreadSubscriptionReq, opt ...requests.Option) (*DeleteThreadSubscriptionResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteThreadSubscriptionReq)
	}
	resp := &DeleteThreadSubscriptionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteThreadSubscription performs requests for "activity/delete-thread-subscription"

Delete a thread subscription.

  DELETE /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
func (c Client) DeleteThreadSubscription(ctx context.Context, req *DeleteThreadSubscriptionReq, opt ...requests.Option) (*DeleteThreadSubscriptionResponse, error) {
	return DeleteThreadSubscription(ctx, req, append(c, opt...)...)
}

/*
DeleteThreadSubscriptionReq is request data for Client.DeleteThreadSubscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
type DeleteThreadSubscriptionReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteThreadSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteThreadSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "activity/delete-thread-subscription",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteThreadSubscriptionReq) Rel(link string, resp *DeleteThreadSubscriptionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteThreadSubscriptionResponse is a response for DeleteThreadSubscription

https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
*/
type DeleteThreadSubscriptionResponse struct {
	requests.Response
	request *DeleteThreadSubscriptionReq
}

/*
GetFeeds performs requests for "activity/get-feeds"

Get feeds.

  GET /feeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
func GetFeeds(ctx context.Context, req *GetFeedsReq, opt ...requests.Option) (*GetFeedsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetFeedsReq)
	}
	resp := &GetFeedsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Feed{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetFeeds performs requests for "activity/get-feeds"

Get feeds.

  GET /feeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
func (c Client) GetFeeds(ctx context.Context, req *GetFeedsReq, opt ...requests.Option) (*GetFeedsResponse, error) {
	return GetFeeds(ctx, req, append(c, opt...)...)
}

/*
GetFeedsReq is request data for Client.GetFeeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
type GetFeedsReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *GetFeedsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetFeedsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/get-feeds",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/feeds"),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetFeedsReq) Rel(link string, resp *GetFeedsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetFeedsResponse is a response for GetFeeds

https://developer.github.com/v3/activity/feeds/#get-feeds
*/
type GetFeedsResponse struct {
	requests.Response
	request *GetFeedsReq
	Data    components.Feed
}

/*
GetRepoSubscription performs requests for "activity/get-repo-subscription"

Get a repository subscription.

  GET /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
func GetRepoSubscription(ctx context.Context, req *GetRepoSubscriptionReq, opt ...requests.Option) (*GetRepoSubscriptionResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetRepoSubscriptionReq)
	}
	resp := &GetRepoSubscriptionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.RepositorySubscription{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetRepoSubscription performs requests for "activity/get-repo-subscription"

Get a repository subscription.

  GET /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
func (c Client) GetRepoSubscription(ctx context.Context, req *GetRepoSubscriptionReq, opt ...requests.Option) (*GetRepoSubscriptionResponse, error) {
	return GetRepoSubscription(ctx, req, append(c, opt...)...)
}

/*
GetRepoSubscriptionReq is request data for Client.GetRepoSubscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
type GetRepoSubscriptionReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *GetRepoSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetRepoSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/get-repo-subscription",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetRepoSubscriptionReq) Rel(link string, resp *GetRepoSubscriptionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetRepoSubscriptionResponse is a response for GetRepoSubscription

https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
*/
type GetRepoSubscriptionResponse struct {
	requests.Response
	request *GetRepoSubscriptionReq
	Data    components.RepositorySubscription
}

/*
GetThread performs requests for "activity/get-thread"

Get a thread.

  GET /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
func GetThread(ctx context.Context, req *GetThreadReq, opt ...requests.Option) (*GetThreadResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetThreadReq)
	}
	resp := &GetThreadResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Thread{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetThread performs requests for "activity/get-thread"

Get a thread.

  GET /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
func (c Client) GetThread(ctx context.Context, req *GetThreadReq, opt ...requests.Option) (*GetThreadResponse, error) {
	return GetThread(ctx, req, append(c, opt...)...)
}

/*
GetThreadReq is request data for Client.GetThread

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
type GetThreadReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request
func (r *GetThreadReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetThreadReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/get-thread",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications/threads/%v", r.ThreadId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetThreadReq) Rel(link string, resp *GetThreadResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetThreadResponse is a response for GetThread

https://developer.github.com/v3/activity/notifications/#get-a-thread
*/
type GetThreadResponse struct {
	requests.Response
	request *GetThreadReq
	Data    components.Thread
}

/*
GetThreadSubscriptionForAuthenticatedUser performs requests for "activity/get-thread-subscription-for-authenticated-user"

Get a thread subscription for the authenticated user.

  GET /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
func GetThreadSubscriptionForAuthenticatedUser(ctx context.Context, req *GetThreadSubscriptionForAuthenticatedUserReq, opt ...requests.Option) (*GetThreadSubscriptionForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetThreadSubscriptionForAuthenticatedUserReq)
	}
	resp := &GetThreadSubscriptionForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ThreadSubscription{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetThreadSubscriptionForAuthenticatedUser performs requests for "activity/get-thread-subscription-for-authenticated-user"

Get a thread subscription for the authenticated user.

  GET /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
func (c Client) GetThreadSubscriptionForAuthenticatedUser(ctx context.Context, req *GetThreadSubscriptionForAuthenticatedUserReq, opt ...requests.Option) (*GetThreadSubscriptionForAuthenticatedUserResponse, error) {
	return GetThreadSubscriptionForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
GetThreadSubscriptionForAuthenticatedUserReq is request data for Client.GetThreadSubscriptionForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
type GetThreadSubscriptionForAuthenticatedUserReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request
func (r *GetThreadSubscriptionForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetThreadSubscriptionForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/get-thread-subscription-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetThreadSubscriptionForAuthenticatedUserReq) Rel(link string, resp *GetThreadSubscriptionForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetThreadSubscriptionForAuthenticatedUserResponse is a response for GetThreadSubscriptionForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription-for-the-authenticated-user
*/
type GetThreadSubscriptionForAuthenticatedUserResponse struct {
	requests.Response
	request *GetThreadSubscriptionForAuthenticatedUserReq
	Data    components.ThreadSubscription
}

/*
ListEventsForAuthenticatedUser performs requests for "activity/list-events-for-authenticated-user"

List events for the authenticated user.

  GET /users/{username}/events

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
func ListEventsForAuthenticatedUser(ctx context.Context, req *ListEventsForAuthenticatedUserReq, opt ...requests.Option) (*ListEventsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListEventsForAuthenticatedUserReq)
	}
	resp := &ListEventsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListEventsForAuthenticatedUser performs requests for "activity/list-events-for-authenticated-user"

List events for the authenticated user.

  GET /users/{username}/events

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
func (c Client) ListEventsForAuthenticatedUser(ctx context.Context, req *ListEventsForAuthenticatedUserReq, opt ...requests.Option) (*ListEventsForAuthenticatedUserResponse, error) {
	return ListEventsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListEventsForAuthenticatedUserReq is request data for Client.ListEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
type ListEventsForAuthenticatedUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListEventsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListEventsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-events-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/events", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListEventsForAuthenticatedUserReq) Rel(link string, resp *ListEventsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListEventsForAuthenticatedUserResponse is a response for ListEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-events-for-the-authenticated-user
*/
type ListEventsForAuthenticatedUserResponse struct {
	requests.Response
	request *ListEventsForAuthenticatedUserReq
	Data    []components.Event
}

/*
ListNotificationsForAuthenticatedUser performs requests for "activity/list-notifications-for-authenticated-user"

List notifications for the authenticated user.

  GET /notifications

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
func ListNotificationsForAuthenticatedUser(ctx context.Context, req *ListNotificationsForAuthenticatedUserReq, opt ...requests.Option) (*ListNotificationsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListNotificationsForAuthenticatedUserReq)
	}
	resp := &ListNotificationsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Thread{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListNotificationsForAuthenticatedUser performs requests for "activity/list-notifications-for-authenticated-user"

List notifications for the authenticated user.

  GET /notifications

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
func (c Client) ListNotificationsForAuthenticatedUser(ctx context.Context, req *ListNotificationsForAuthenticatedUserReq, opt ...requests.Option) (*ListNotificationsForAuthenticatedUserResponse, error) {
	return ListNotificationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListNotificationsForAuthenticatedUserReq is request data for Client.ListNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
type ListNotificationsForAuthenticatedUserReq struct {
	_url string

	// If `true`, show notifications marked as read.
	All *bool

	/*
	If `true`, only shows notifications in which the user is directly participating
	or mentioned.
	*/
	Participating *bool

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only show notifications updated before the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Before *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListNotificationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListNotificationsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.All != nil {
		query.Set("all", strconv.FormatBool(*r.All))
	}
	if r.Participating != nil {
		query.Set("participating", strconv.FormatBool(*r.Participating))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Before != nil {
		query.Set("before", *r.Before)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-notifications-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListNotificationsForAuthenticatedUserReq) Rel(link string, resp *ListNotificationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListNotificationsForAuthenticatedUserResponse is a response for ListNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-notifications-for-the-authenticated-user
*/
type ListNotificationsForAuthenticatedUserResponse struct {
	requests.Response
	request *ListNotificationsForAuthenticatedUserReq
	Data    []components.Thread
}

/*
ListOrgEventsForAuthenticatedUser performs requests for "activity/list-org-events-for-authenticated-user"

List organization events for the authenticated user.

  GET /users/{username}/events/orgs/{org}

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
func ListOrgEventsForAuthenticatedUser(ctx context.Context, req *ListOrgEventsForAuthenticatedUserReq, opt ...requests.Option) (*ListOrgEventsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListOrgEventsForAuthenticatedUserReq)
	}
	resp := &ListOrgEventsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListOrgEventsForAuthenticatedUser performs requests for "activity/list-org-events-for-authenticated-user"

List organization events for the authenticated user.

  GET /users/{username}/events/orgs/{org}

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
func (c Client) ListOrgEventsForAuthenticatedUser(ctx context.Context, req *ListOrgEventsForAuthenticatedUserReq, opt ...requests.Option) (*ListOrgEventsForAuthenticatedUserResponse, error) {
	return ListOrgEventsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListOrgEventsForAuthenticatedUserReq is request data for Client.ListOrgEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
type ListOrgEventsForAuthenticatedUserReq struct {
	_url     string
	Username string
	Org      string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListOrgEventsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListOrgEventsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-org-events-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/events/orgs/%v", r.Username, r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListOrgEventsForAuthenticatedUserReq) Rel(link string, resp *ListOrgEventsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListOrgEventsForAuthenticatedUserResponse is a response for ListOrgEventsForAuthenticatedUser

https://developer.github.com/v3/activity/events/#list-organization-events-for-the-authenticated-user
*/
type ListOrgEventsForAuthenticatedUserResponse struct {
	requests.Response
	request *ListOrgEventsForAuthenticatedUserReq
	Data    []components.Event
}

/*
ListPublicEvents performs requests for "activity/list-public-events"

List public events.

  GET /events

https://developer.github.com/v3/activity/events/#list-public-events
*/
func ListPublicEvents(ctx context.Context, req *ListPublicEventsReq, opt ...requests.Option) (*ListPublicEventsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicEventsReq)
	}
	resp := &ListPublicEventsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublicEvents performs requests for "activity/list-public-events"

List public events.

  GET /events

https://developer.github.com/v3/activity/events/#list-public-events
*/
func (c Client) ListPublicEvents(ctx context.Context, req *ListPublicEventsReq, opt ...requests.Option) (*ListPublicEventsResponse, error) {
	return ListPublicEvents(ctx, req, append(c, opt...)...)
}

/*
ListPublicEventsReq is request data for Client.ListPublicEvents

https://developer.github.com/v3/activity/events/#list-public-events
*/
type ListPublicEventsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicEventsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicEventsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-public-events",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/events"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicEventsReq) Rel(link string, resp *ListPublicEventsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicEventsResponse is a response for ListPublicEvents

https://developer.github.com/v3/activity/events/#list-public-events
*/
type ListPublicEventsResponse struct {
	requests.Response
	request *ListPublicEventsReq
	Data    []components.Event
}

/*
ListPublicEventsForRepoNetwork performs requests for "activity/list-public-events-for-repo-network"

List public events for a network of repositories.

  GET /networks/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
func ListPublicEventsForRepoNetwork(ctx context.Context, req *ListPublicEventsForRepoNetworkReq, opt ...requests.Option) (*ListPublicEventsForRepoNetworkResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicEventsForRepoNetworkReq)
	}
	resp := &ListPublicEventsForRepoNetworkResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublicEventsForRepoNetwork performs requests for "activity/list-public-events-for-repo-network"

List public events for a network of repositories.

  GET /networks/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
func (c Client) ListPublicEventsForRepoNetwork(ctx context.Context, req *ListPublicEventsForRepoNetworkReq, opt ...requests.Option) (*ListPublicEventsForRepoNetworkResponse, error) {
	return ListPublicEventsForRepoNetwork(ctx, req, append(c, opt...)...)
}

/*
ListPublicEventsForRepoNetworkReq is request data for Client.ListPublicEventsForRepoNetwork

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
type ListPublicEventsForRepoNetworkReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicEventsForRepoNetworkReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicEventsForRepoNetworkReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-public-events-for-repo-network",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/networks/%v/%v/events", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 301, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicEventsForRepoNetworkReq) Rel(link string, resp *ListPublicEventsForRepoNetworkResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicEventsForRepoNetworkResponse is a response for ListPublicEventsForRepoNetwork

https://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
*/
type ListPublicEventsForRepoNetworkResponse struct {
	requests.Response
	request *ListPublicEventsForRepoNetworkReq
	Data    []components.Event
}

/*
ListPublicEventsForUser performs requests for "activity/list-public-events-for-user"

List public events for a user.

  GET /users/{username}/events/public

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
func ListPublicEventsForUser(ctx context.Context, req *ListPublicEventsForUserReq, opt ...requests.Option) (*ListPublicEventsForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicEventsForUserReq)
	}
	resp := &ListPublicEventsForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublicEventsForUser performs requests for "activity/list-public-events-for-user"

List public events for a user.

  GET /users/{username}/events/public

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
func (c Client) ListPublicEventsForUser(ctx context.Context, req *ListPublicEventsForUserReq, opt ...requests.Option) (*ListPublicEventsForUserResponse, error) {
	return ListPublicEventsForUser(ctx, req, append(c, opt...)...)
}

/*
ListPublicEventsForUserReq is request data for Client.ListPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
type ListPublicEventsForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicEventsForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicEventsForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-public-events-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/events/public", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicEventsForUserReq) Rel(link string, resp *ListPublicEventsForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicEventsForUserResponse is a response for ListPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-for-a-user
*/
type ListPublicEventsForUserResponse struct {
	requests.Response
	request *ListPublicEventsForUserReq
	Data    []components.Event
}

/*
ListPublicOrgEvents performs requests for "activity/list-public-org-events"

List public organization events.

  GET /orgs/{org}/events

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
func ListPublicOrgEvents(ctx context.Context, req *ListPublicOrgEventsReq, opt ...requests.Option) (*ListPublicOrgEventsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicOrgEventsReq)
	}
	resp := &ListPublicOrgEventsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublicOrgEvents performs requests for "activity/list-public-org-events"

List public organization events.

  GET /orgs/{org}/events

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
func (c Client) ListPublicOrgEvents(ctx context.Context, req *ListPublicOrgEventsReq, opt ...requests.Option) (*ListPublicOrgEventsResponse, error) {
	return ListPublicOrgEvents(ctx, req, append(c, opt...)...)
}

/*
ListPublicOrgEventsReq is request data for Client.ListPublicOrgEvents

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
type ListPublicOrgEventsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicOrgEventsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicOrgEventsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-public-org-events",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/events", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicOrgEventsReq) Rel(link string, resp *ListPublicOrgEventsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicOrgEventsResponse is a response for ListPublicOrgEvents

https://developer.github.com/v3/activity/events/#list-public-organization-events
*/
type ListPublicOrgEventsResponse struct {
	requests.Response
	request *ListPublicOrgEventsReq
	Data    []components.Event
}

/*
ListReceivedEventsForUser performs requests for "activity/list-received-events-for-user"

List events received by the authenticated user.

  GET /users/{username}/received_events

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
func ListReceivedEventsForUser(ctx context.Context, req *ListReceivedEventsForUserReq, opt ...requests.Option) (*ListReceivedEventsForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReceivedEventsForUserReq)
	}
	resp := &ListReceivedEventsForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReceivedEventsForUser performs requests for "activity/list-received-events-for-user"

List events received by the authenticated user.

  GET /users/{username}/received_events

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
func (c Client) ListReceivedEventsForUser(ctx context.Context, req *ListReceivedEventsForUserReq, opt ...requests.Option) (*ListReceivedEventsForUserResponse, error) {
	return ListReceivedEventsForUser(ctx, req, append(c, opt...)...)
}

/*
ListReceivedEventsForUserReq is request data for Client.ListReceivedEventsForUser

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
type ListReceivedEventsForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReceivedEventsForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReceivedEventsForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-received-events-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/received_events", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReceivedEventsForUserReq) Rel(link string, resp *ListReceivedEventsForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReceivedEventsForUserResponse is a response for ListReceivedEventsForUser

https://developer.github.com/v3/activity/events/#list-events-received-by-the-authenticated-user
*/
type ListReceivedEventsForUserResponse struct {
	requests.Response
	request *ListReceivedEventsForUserReq
	Data    []components.Event
}

/*
ListReceivedPublicEventsForUser performs requests for "activity/list-received-public-events-for-user"

List public events received by a user.

  GET /users/{username}/received_events/public

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
func ListReceivedPublicEventsForUser(ctx context.Context, req *ListReceivedPublicEventsForUserReq, opt ...requests.Option) (*ListReceivedPublicEventsForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReceivedPublicEventsForUserReq)
	}
	resp := &ListReceivedPublicEventsForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReceivedPublicEventsForUser performs requests for "activity/list-received-public-events-for-user"

List public events received by a user.

  GET /users/{username}/received_events/public

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
func (c Client) ListReceivedPublicEventsForUser(ctx context.Context, req *ListReceivedPublicEventsForUserReq, opt ...requests.Option) (*ListReceivedPublicEventsForUserResponse, error) {
	return ListReceivedPublicEventsForUser(ctx, req, append(c, opt...)...)
}

/*
ListReceivedPublicEventsForUserReq is request data for Client.ListReceivedPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
type ListReceivedPublicEventsForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReceivedPublicEventsForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReceivedPublicEventsForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-received-public-events-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/received_events/public", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReceivedPublicEventsForUserReq) Rel(link string, resp *ListReceivedPublicEventsForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReceivedPublicEventsForUserResponse is a response for ListReceivedPublicEventsForUser

https://developer.github.com/v3/activity/events/#list-public-events-received-by-a-user
*/
type ListReceivedPublicEventsForUserResponse struct {
	requests.Response
	request *ListReceivedPublicEventsForUserReq
	Data    []components.Event
}

/*
ListRepoEvents performs requests for "activity/list-repo-events"

List repository events.

  GET /repos/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-repository-events
*/
func ListRepoEvents(ctx context.Context, req *ListRepoEventsReq, opt ...requests.Option) (*ListRepoEventsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListRepoEventsReq)
	}
	resp := &ListRepoEventsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Event{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListRepoEvents performs requests for "activity/list-repo-events"

List repository events.

  GET /repos/{owner}/{repo}/events

https://developer.github.com/v3/activity/events/#list-repository-events
*/
func (c Client) ListRepoEvents(ctx context.Context, req *ListRepoEventsReq, opt ...requests.Option) (*ListRepoEventsResponse, error) {
	return ListRepoEvents(ctx, req, append(c, opt...)...)
}

/*
ListRepoEventsReq is request data for Client.ListRepoEvents

https://developer.github.com/v3/activity/events/#list-repository-events
*/
type ListRepoEventsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListRepoEventsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListRepoEventsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-repo-events",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/events", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListRepoEventsReq) Rel(link string, resp *ListRepoEventsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListRepoEventsResponse is a response for ListRepoEvents

https://developer.github.com/v3/activity/events/#list-repository-events
*/
type ListRepoEventsResponse struct {
	requests.Response
	request *ListRepoEventsReq
	Data    []components.Event
}

/*
ListRepoNotificationsForAuthenticatedUser performs requests for "activity/list-repo-notifications-for-authenticated-user"

List repository notifications for the authenticated user.

  GET /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
func ListRepoNotificationsForAuthenticatedUser(ctx context.Context, req *ListRepoNotificationsForAuthenticatedUserReq, opt ...requests.Option) (*ListRepoNotificationsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListRepoNotificationsForAuthenticatedUserReq)
	}
	resp := &ListRepoNotificationsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Thread{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListRepoNotificationsForAuthenticatedUser performs requests for "activity/list-repo-notifications-for-authenticated-user"

List repository notifications for the authenticated user.

  GET /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
func (c Client) ListRepoNotificationsForAuthenticatedUser(ctx context.Context, req *ListRepoNotificationsForAuthenticatedUserReq, opt ...requests.Option) (*ListRepoNotificationsForAuthenticatedUserResponse, error) {
	return ListRepoNotificationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListRepoNotificationsForAuthenticatedUserReq is request data for Client.ListRepoNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
type ListRepoNotificationsForAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string

	// If `true`, show notifications marked as read.
	All *bool

	/*
	If `true`, only shows notifications in which the user is directly participating
	or mentioned.
	*/
	Participating *bool

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	/*
	Only show notifications updated before the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Before *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListRepoNotificationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListRepoNotificationsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.All != nil {
		query.Set("all", strconv.FormatBool(*r.All))
	}
	if r.Participating != nil {
		query.Set("participating", strconv.FormatBool(*r.Participating))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Before != nil {
		query.Set("before", *r.Before)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-repo-notifications-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/notifications", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListRepoNotificationsForAuthenticatedUserReq) Rel(link string, resp *ListRepoNotificationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListRepoNotificationsForAuthenticatedUserResponse is a response for ListRepoNotificationsForAuthenticatedUser

https://developer.github.com/v3/activity/notifications/#list-repository-notifications-for-the-authenticated-user
*/
type ListRepoNotificationsForAuthenticatedUserResponse struct {
	requests.Response
	request *ListRepoNotificationsForAuthenticatedUserReq
	Data    []components.Thread
}

/*
ListReposStarredByAuthenticatedUser performs requests for "activity/list-repos-starred-by-authenticated-user"

List repositories starred by the authenticated user.

  GET /user/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
func ListReposStarredByAuthenticatedUser(ctx context.Context, req *ListReposStarredByAuthenticatedUserReq, opt ...requests.Option) (*ListReposStarredByAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposStarredByAuthenticatedUserReq)
	}
	resp := &ListReposStarredByAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.StarredRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposStarredByAuthenticatedUser performs requests for "activity/list-repos-starred-by-authenticated-user"

List repositories starred by the authenticated user.

  GET /user/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
func (c Client) ListReposStarredByAuthenticatedUser(ctx context.Context, req *ListReposStarredByAuthenticatedUserReq, opt ...requests.Option) (*ListReposStarredByAuthenticatedUserResponse, error) {
	return ListReposStarredByAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListReposStarredByAuthenticatedUserReq is request data for Client.ListReposStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
type ListReposStarredByAuthenticatedUserReq struct {
	_url string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReposStarredByAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposStarredByAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/vnd.github.v3.star+json")},
		Method:           "GET",
		OperationID:      "activity/list-repos-starred-by-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/starred"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposStarredByAuthenticatedUserReq) Rel(link string, resp *ListReposStarredByAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposStarredByAuthenticatedUserResponse is a response for ListReposStarredByAuthenticatedUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-the-authenticated-user
*/
type ListReposStarredByAuthenticatedUserResponse struct {
	requests.Response
	request *ListReposStarredByAuthenticatedUserReq
	Data    []components.StarredRepository
}

/*
ListReposStarredByUser performs requests for "activity/list-repos-starred-by-user"

List repositories starred by a user.

  GET /users/{username}/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
func ListReposStarredByUser(ctx context.Context, req *ListReposStarredByUserReq, opt ...requests.Option) (*ListReposStarredByUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposStarredByUserReq)
	}
	resp := &ListReposStarredByUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.StarredRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposStarredByUser performs requests for "activity/list-repos-starred-by-user"

List repositories starred by a user.

  GET /users/{username}/starred

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
func (c Client) ListReposStarredByUser(ctx context.Context, req *ListReposStarredByUserReq, opt ...requests.Option) (*ListReposStarredByUserResponse, error) {
	return ListReposStarredByUser(ctx, req, append(c, opt...)...)
}

/*
ListReposStarredByUserReq is request data for Client.ListReposStarredByUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
type ListReposStarredByUserReq struct {
	_url     string
	Username string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReposStarredByUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposStarredByUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/vnd.github.v3.star+json")},
		Method:           "GET",
		OperationID:      "activity/list-repos-starred-by-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/starred", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposStarredByUserReq) Rel(link string, resp *ListReposStarredByUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposStarredByUserResponse is a response for ListReposStarredByUser

https://developer.github.com/v3/activity/starring/#list-repositories-starred-by-a-user
*/
type ListReposStarredByUserResponse struct {
	requests.Response
	request *ListReposStarredByUserReq
	Data    []components.StarredRepository
}

/*
ListReposWatchedByUser performs requests for "activity/list-repos-watched-by-user"

List repositories watched by a user.

  GET /users/{username}/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
func ListReposWatchedByUser(ctx context.Context, req *ListReposWatchedByUserReq, opt ...requests.Option) (*ListReposWatchedByUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposWatchedByUserReq)
	}
	resp := &ListReposWatchedByUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposWatchedByUser performs requests for "activity/list-repos-watched-by-user"

List repositories watched by a user.

  GET /users/{username}/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
func (c Client) ListReposWatchedByUser(ctx context.Context, req *ListReposWatchedByUserReq, opt ...requests.Option) (*ListReposWatchedByUserResponse, error) {
	return ListReposWatchedByUser(ctx, req, append(c, opt...)...)
}

/*
ListReposWatchedByUserReq is request data for Client.ListReposWatchedByUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
type ListReposWatchedByUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReposWatchedByUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposWatchedByUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-repos-watched-by-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/subscriptions", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposWatchedByUserReq) Rel(link string, resp *ListReposWatchedByUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposWatchedByUserResponse is a response for ListReposWatchedByUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-a-user
*/
type ListReposWatchedByUserResponse struct {
	requests.Response
	request *ListReposWatchedByUserReq
	Data    []components.MinimalRepository
}

/*
ListStargazersForRepo performs requests for "activity/list-stargazers-for-repo"

List stargazers.

  GET /repos/{owner}/{repo}/stargazers

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
func ListStargazersForRepo(ctx context.Context, req *ListStargazersForRepoReq, opt ...requests.Option) (*ListStargazersForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListStargazersForRepoReq)
	}
	resp := &ListStargazersForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Stargazer{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListStargazersForRepo performs requests for "activity/list-stargazers-for-repo"

List stargazers.

  GET /repos/{owner}/{repo}/stargazers

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
func (c Client) ListStargazersForRepo(ctx context.Context, req *ListStargazersForRepoReq, opt ...requests.Option) (*ListStargazersForRepoResponse, error) {
	return ListStargazersForRepo(ctx, req, append(c, opt...)...)
}

/*
ListStargazersForRepoReq is request data for Client.ListStargazersForRepo

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
type ListStargazersForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListStargazersForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListStargazersForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/vnd.github.v3.star+json")},
		Method:           "GET",
		OperationID:      "activity/list-stargazers-for-repo",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/stargazers", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListStargazersForRepoReq) Rel(link string, resp *ListStargazersForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListStargazersForRepoResponse is a response for ListStargazersForRepo

https://developer.github.com/v3/activity/starring/#list-stargazers
*/
type ListStargazersForRepoResponse struct {
	requests.Response
	request *ListStargazersForRepoReq
	Data    []components.Stargazer
}

/*
ListWatchedReposForAuthenticatedUser performs requests for "activity/list-watched-repos-for-authenticated-user"

List repositories watched by the authenticated user.

  GET /user/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
func ListWatchedReposForAuthenticatedUser(ctx context.Context, req *ListWatchedReposForAuthenticatedUserReq, opt ...requests.Option) (*ListWatchedReposForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListWatchedReposForAuthenticatedUserReq)
	}
	resp := &ListWatchedReposForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListWatchedReposForAuthenticatedUser performs requests for "activity/list-watched-repos-for-authenticated-user"

List repositories watched by the authenticated user.

  GET /user/subscriptions

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
func (c Client) ListWatchedReposForAuthenticatedUser(ctx context.Context, req *ListWatchedReposForAuthenticatedUserReq, opt ...requests.Option) (*ListWatchedReposForAuthenticatedUserResponse, error) {
	return ListWatchedReposForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListWatchedReposForAuthenticatedUserReq is request data for Client.ListWatchedReposForAuthenticatedUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
type ListWatchedReposForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListWatchedReposForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListWatchedReposForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-watched-repos-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/subscriptions"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListWatchedReposForAuthenticatedUserReq) Rel(link string, resp *ListWatchedReposForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListWatchedReposForAuthenticatedUserResponse is a response for ListWatchedReposForAuthenticatedUser

https://developer.github.com/v3/activity/watching/#list-repositories-watched-by-the-authenticated-user
*/
type ListWatchedReposForAuthenticatedUserResponse struct {
	requests.Response
	request *ListWatchedReposForAuthenticatedUserReq
	Data    []components.MinimalRepository
}

/*
ListWatchersForRepo performs requests for "activity/list-watchers-for-repo"

List watchers.

  GET /repos/{owner}/{repo}/subscribers

https://developer.github.com/v3/activity/watching/#list-watchers
*/
func ListWatchersForRepo(ctx context.Context, req *ListWatchersForRepoReq, opt ...requests.Option) (*ListWatchersForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListWatchersForRepoReq)
	}
	resp := &ListWatchersForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListWatchersForRepo performs requests for "activity/list-watchers-for-repo"

List watchers.

  GET /repos/{owner}/{repo}/subscribers

https://developer.github.com/v3/activity/watching/#list-watchers
*/
func (c Client) ListWatchersForRepo(ctx context.Context, req *ListWatchersForRepoReq, opt ...requests.Option) (*ListWatchersForRepoResponse, error) {
	return ListWatchersForRepo(ctx, req, append(c, opt...)...)
}

/*
ListWatchersForRepoReq is request data for Client.ListWatchersForRepo

https://developer.github.com/v3/activity/watching/#list-watchers
*/
type ListWatchersForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListWatchersForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListWatchersForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "activity/list-watchers-for-repo",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/subscribers", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListWatchersForRepoReq) Rel(link string, resp *ListWatchersForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListWatchersForRepoResponse is a response for ListWatchersForRepo

https://developer.github.com/v3/activity/watching/#list-watchers
*/
type ListWatchersForRepoResponse struct {
	requests.Response
	request *ListWatchersForRepoReq
	Data    []components.SimpleUser
}

/*
MarkNotificationsAsRead performs requests for "activity/mark-notifications-as-read"

Mark notifications as read.

  PUT /notifications

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
func MarkNotificationsAsRead(ctx context.Context, req *MarkNotificationsAsReadReq, opt ...requests.Option) (*MarkNotificationsAsReadResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MarkNotificationsAsReadReq)
	}
	resp := &MarkNotificationsAsReadResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = MarkNotificationsAsReadResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MarkNotificationsAsRead performs requests for "activity/mark-notifications-as-read"

Mark notifications as read.

  PUT /notifications

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
func (c Client) MarkNotificationsAsRead(ctx context.Context, req *MarkNotificationsAsReadReq, opt ...requests.Option) (*MarkNotificationsAsReadResponse, error) {
	return MarkNotificationsAsRead(ctx, req, append(c, opt...)...)
}

/*
MarkNotificationsAsReadReq is request data for Client.MarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type MarkNotificationsAsReadReq struct {
	_url        string
	RequestBody MarkNotificationsAsReadReqBody
}

// HTTPRequest builds an *http.Request
func (r *MarkNotificationsAsReadReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MarkNotificationsAsReadReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{202},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "activity/mark-notifications-as-read",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications"),
		URLQuery:         query,
		ValidStatuses:    []int{202, 205, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MarkNotificationsAsReadReq) Rel(link string, resp *MarkNotificationsAsReadResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MarkNotificationsAsReadReqBody is a request body for activity/mark-notifications-as-read

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type MarkNotificationsAsReadReqBody struct {

	// Describes the last point that notifications were checked.
	LastReadAt *string `json:"last_read_at,omitempty"`

	// Whether the notification has been read.
	Read *bool `json:"read,omitempty"`
}

/*
MarkNotificationsAsReadResponseBody is a response body for MarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type MarkNotificationsAsReadResponseBody struct {
	Message string `json:"message,omitempty"`
}

/*
MarkNotificationsAsReadResponse is a response for MarkNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read
*/
type MarkNotificationsAsReadResponse struct {
	requests.Response
	request *MarkNotificationsAsReadReq
	Data    MarkNotificationsAsReadResponseBody
}

/*
MarkRepoNotificationsAsRead performs requests for "activity/mark-repo-notifications-as-read"

Mark repository notifications as read.

  PUT /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
func MarkRepoNotificationsAsRead(ctx context.Context, req *MarkRepoNotificationsAsReadReq, opt ...requests.Option) (*MarkRepoNotificationsAsReadResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MarkRepoNotificationsAsReadReq)
	}
	resp := &MarkRepoNotificationsAsReadResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MarkRepoNotificationsAsRead performs requests for "activity/mark-repo-notifications-as-read"

Mark repository notifications as read.

  PUT /repos/{owner}/{repo}/notifications

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
func (c Client) MarkRepoNotificationsAsRead(ctx context.Context, req *MarkRepoNotificationsAsReadReq, opt ...requests.Option) (*MarkRepoNotificationsAsReadResponse, error) {
	return MarkRepoNotificationsAsRead(ctx, req, append(c, opt...)...)
}

/*
MarkRepoNotificationsAsReadReq is request data for Client.MarkRepoNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type MarkRepoNotificationsAsReadReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody MarkRepoNotificationsAsReadReqBody
}

// HTTPRequest builds an *http.Request
func (r *MarkRepoNotificationsAsReadReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MarkRepoNotificationsAsReadReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": internal.String("application/json")},
		Method:           "PUT",
		OperationID:      "activity/mark-repo-notifications-as-read",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/notifications", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{202},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MarkRepoNotificationsAsReadReq) Rel(link string, resp *MarkRepoNotificationsAsReadResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MarkRepoNotificationsAsReadReqBody is a request body for activity/mark-repo-notifications-as-read

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type MarkRepoNotificationsAsReadReqBody struct {

	/*
	Describes the last point that notifications were checked. Anything updated since
	this time will not be marked as read. If you omit this parameter, all
	notifications are marked as read. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Default: The current timestamp.
	*/
	LastReadAt *string `json:"last_read_at,omitempty"`
}

/*
MarkRepoNotificationsAsReadResponse is a response for MarkRepoNotificationsAsRead

https://developer.github.com/v3/activity/notifications/#mark-repository-notifications-as-read
*/
type MarkRepoNotificationsAsReadResponse struct {
	requests.Response
	request *MarkRepoNotificationsAsReadReq
}

/*
MarkThreadAsRead performs requests for "activity/mark-thread-as-read"

Mark a thread as read.

  PATCH /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
func MarkThreadAsRead(ctx context.Context, req *MarkThreadAsReadReq, opt ...requests.Option) (*MarkThreadAsReadResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MarkThreadAsReadReq)
	}
	resp := &MarkThreadAsReadResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MarkThreadAsRead performs requests for "activity/mark-thread-as-read"

Mark a thread as read.

  PATCH /notifications/threads/{thread_id}

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
func (c Client) MarkThreadAsRead(ctx context.Context, req *MarkThreadAsReadReq, opt ...requests.Option) (*MarkThreadAsReadResponse, error) {
	return MarkThreadAsRead(ctx, req, append(c, opt...)...)
}

/*
MarkThreadAsReadReq is request data for Client.MarkThreadAsRead

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
type MarkThreadAsReadReq struct {
	_url string

	// thread_id parameter
	ThreadId int64
}

// HTTPRequest builds an *http.Request
func (r *MarkThreadAsReadReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MarkThreadAsReadReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PATCH",
		OperationID:      "activity/mark-thread-as-read",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications/threads/%v", r.ThreadId),
		URLQuery:         query,
		ValidStatuses:    []int{205, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MarkThreadAsReadReq) Rel(link string, resp *MarkThreadAsReadResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MarkThreadAsReadResponse is a response for MarkThreadAsRead

https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
*/
type MarkThreadAsReadResponse struct {
	requests.Response
	request *MarkThreadAsReadReq
}

/*
SetRepoSubscription performs requests for "activity/set-repo-subscription"

Set a repository subscription.

  PUT /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
func SetRepoSubscription(ctx context.Context, req *SetRepoSubscriptionReq, opt ...requests.Option) (*SetRepoSubscriptionResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetRepoSubscriptionReq)
	}
	resp := &SetRepoSubscriptionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.RepositorySubscription{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetRepoSubscription performs requests for "activity/set-repo-subscription"

Set a repository subscription.

  PUT /repos/{owner}/{repo}/subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
func (c Client) SetRepoSubscription(ctx context.Context, req *SetRepoSubscriptionReq, opt ...requests.Option) (*SetRepoSubscriptionResponse, error) {
	return SetRepoSubscription(ctx, req, append(c, opt...)...)
}

/*
SetRepoSubscriptionReq is request data for Client.SetRepoSubscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type SetRepoSubscriptionReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody SetRepoSubscriptionReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetRepoSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetRepoSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "activity/set-repo-subscription",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/subscription", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetRepoSubscriptionReq) Rel(link string, resp *SetRepoSubscriptionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetRepoSubscriptionReqBody is a request body for activity/set-repo-subscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type SetRepoSubscriptionReqBody struct {

	// Determines if all notifications should be blocked from this repository.
	Ignored *bool `json:"ignored,omitempty"`

	// Determines if notifications should be received from this repository.
	Subscribed *bool `json:"subscribed,omitempty"`
}

/*
SetRepoSubscriptionResponse is a response for SetRepoSubscription

https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
*/
type SetRepoSubscriptionResponse struct {
	requests.Response
	request *SetRepoSubscriptionReq
	Data    components.RepositorySubscription
}

/*
SetThreadSubscription performs requests for "activity/set-thread-subscription"

Set a thread subscription.

  PUT /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
func SetThreadSubscription(ctx context.Context, req *SetThreadSubscriptionReq, opt ...requests.Option) (*SetThreadSubscriptionResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetThreadSubscriptionReq)
	}
	resp := &SetThreadSubscriptionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ThreadSubscription{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetThreadSubscription performs requests for "activity/set-thread-subscription"

Set a thread subscription.

  PUT /notifications/threads/{thread_id}/subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
func (c Client) SetThreadSubscription(ctx context.Context, req *SetThreadSubscriptionReq, opt ...requests.Option) (*SetThreadSubscriptionResponse, error) {
	return SetThreadSubscription(ctx, req, append(c, opt...)...)
}

/*
SetThreadSubscriptionReq is request data for Client.SetThreadSubscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type SetThreadSubscriptionReq struct {
	_url string

	// thread_id parameter
	ThreadId    int64
	RequestBody SetThreadSubscriptionReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetThreadSubscriptionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetThreadSubscriptionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "activity/set-thread-subscription",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/notifications/threads/%v/subscription", r.ThreadId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetThreadSubscriptionReq) Rel(link string, resp *SetThreadSubscriptionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetThreadSubscriptionReqBody is a request body for activity/set-thread-subscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type SetThreadSubscriptionReqBody struct {

	// Whether to block all notifications from a thread.
	Ignored *bool `json:"ignored,omitempty"`
}

/*
SetThreadSubscriptionResponse is a response for SetThreadSubscription

https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
*/
type SetThreadSubscriptionResponse struct {
	requests.Response
	request *SetThreadSubscriptionReq
	Data    components.ThreadSubscription
}

/*
StarRepoForAuthenticatedUser performs requests for "activity/star-repo-for-authenticated-user"

Star a repository for the authenticated user.

  PUT /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
func StarRepoForAuthenticatedUser(ctx context.Context, req *StarRepoForAuthenticatedUserReq, opt ...requests.Option) (*StarRepoForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(StarRepoForAuthenticatedUserReq)
	}
	resp := &StarRepoForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
StarRepoForAuthenticatedUser performs requests for "activity/star-repo-for-authenticated-user"

Star a repository for the authenticated user.

  PUT /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
func (c Client) StarRepoForAuthenticatedUser(ctx context.Context, req *StarRepoForAuthenticatedUserReq, opt ...requests.Option) (*StarRepoForAuthenticatedUserResponse, error) {
	return StarRepoForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
StarRepoForAuthenticatedUserReq is request data for Client.StarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
type StarRepoForAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *StarRepoForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *StarRepoForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "activity/star-repo-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StarRepoForAuthenticatedUserReq) Rel(link string, resp *StarRepoForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StarRepoForAuthenticatedUserResponse is a response for StarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#star-a-repository-for-the-authenticated-user
*/
type StarRepoForAuthenticatedUserResponse struct {
	requests.Response
	request *StarRepoForAuthenticatedUserReq
}

/*
UnstarRepoForAuthenticatedUser performs requests for "activity/unstar-repo-for-authenticated-user"

Unstar a repository for the authenticated user.

  DELETE /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
func UnstarRepoForAuthenticatedUser(ctx context.Context, req *UnstarRepoForAuthenticatedUserReq, opt ...requests.Option) (*UnstarRepoForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnstarRepoForAuthenticatedUserReq)
	}
	resp := &UnstarRepoForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UnstarRepoForAuthenticatedUser performs requests for "activity/unstar-repo-for-authenticated-user"

Unstar a repository for the authenticated user.

  DELETE /user/starred/{owner}/{repo}

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
func (c Client) UnstarRepoForAuthenticatedUser(ctx context.Context, req *UnstarRepoForAuthenticatedUserReq, opt ...requests.Option) (*UnstarRepoForAuthenticatedUserResponse, error) {
	return UnstarRepoForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
UnstarRepoForAuthenticatedUserReq is request data for Client.UnstarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
type UnstarRepoForAuthenticatedUserReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *UnstarRepoForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnstarRepoForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "activity/unstar-repo-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/starred/%v/%v", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnstarRepoForAuthenticatedUserReq) Rel(link string, resp *UnstarRepoForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnstarRepoForAuthenticatedUserResponse is a response for UnstarRepoForAuthenticatedUser

https://developer.github.com/v3/activity/starring/#unstar-a-repository-for-the-authenticated-user
*/
type UnstarRepoForAuthenticatedUserResponse struct {
	requests.Response
	request *UnstarRepoForAuthenticatedUserReq
}
