// Code generated by octo-go; DO NOT EDIT.

package pulls

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
CheckIfMerged performs requests for "pulls/check-if-merged"

Check if a pull request has been merged.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#check-if-a-pull-request-has-been-merged
*/
func CheckIfMerged(ctx context.Context, req *CheckIfMergedReq, opt ...requests.Option) (*CheckIfMergedResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CheckIfMergedReq)
	}
	resp := &CheckIfMergedResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckIfMerged performs requests for "pulls/check-if-merged"

Check if a pull request has been merged.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#check-if-a-pull-request-has-been-merged

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CheckIfMerged(ctx context.Context, req *CheckIfMergedReq, opt ...requests.Option) (*CheckIfMergedResponse, error) {
	return CheckIfMerged(ctx, req, append(c, opt...)...)
}

/*
CheckIfMergedReq is request data for Client.CheckIfMerged

https://developer.github.com/v3/pulls/#check-if-a-pull-request-has-been-merged

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CheckIfMergedReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CheckIfMergedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/pulls/%v/merge", r.Owner, r.Repo, r.PullNumber),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckIfMergedReq) Rel(link string, resp *CheckIfMergedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckIfMergedResponse is a response for CheckIfMerged

https://developer.github.com/v3/pulls/#check-if-a-pull-request-has-been-merged
*/
type CheckIfMergedResponse struct {
	httpResponse *http.Response
	Data         bool
}

// HTTPResponse returns the *http.Response
func (r *CheckIfMergedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CheckIfMergedResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 404})
	if err != nil {
		return err
	}
	err = internal.SetBoolResult(resp, &r.Data)
	if err != nil {
		return err
	}
	return nil
}

/*
Create performs requests for "pulls/create"

Create a pull request.

  POST /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
func Create(ctx context.Context, req *CreateReq, opt ...requests.Option) (*CreateResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CreateReq)
	}
	resp := &CreateResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Create performs requests for "pulls/create"

Create a pull request.

  POST /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#create-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Create(ctx context.Context, req *CreateReq, opt ...requests.Option) (*CreateResponse, error) {
	return Create(ctx, req, append(c, opt...)...)
}

/*
CreateReq is request data for Client.Create

https://developer.github.com/v3/pulls/#create-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CreateReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateReqBody

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CreateReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews: []string{"sailor-v"},
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:   "POST",
		Options:  opt,
		Previews: map[string]bool{"sailor-v": r.SailorVPreview},
		URLPath:  fmt.Sprintf("/repos/%v/%v/pulls", r.Owner, r.Repo),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateReq) Rel(link string, resp *CreateResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateReqBody is a request body for pulls/create

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
type CreateReqBody struct {

	/*
	The name of the branch you want the changes pulled into. This should be an
	existing branch on the current repository. You cannot submit a pull request to
	one repository that requests a merge to a base of another repository.
	*/
	Base *string `json:"base"`

	// The contents of the pull request.
	Body *string `json:"body,omitempty"`

	/*
	Indicates whether the pull request is a draft. See "[Draft Pull
	Requests](https://help.github.com/en/articles/about-pull-requests#draft-pull-requests)"
	in the GitHub Help documentation to learn more.
	*/
	Draft *bool `json:"draft,omitempty"`

	/*
	The name of the branch where your changes are implemented. For cross-repository
	pull requests in the same network, namespace `head` with a user like this:
	`username:branch`.
	*/
	Head  *string `json:"head"`
	Issue *int64  `json:"issue,omitempty"`

	/*
	Indicates whether [maintainers can
	modify](https://help.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/)
	the pull request.
	*/
	MaintainerCanModify *bool `json:"maintainer_can_modify,omitempty"`

	// The title of the new pull request.
	Title *string `json:"title,omitempty"`
}

/*
CreateResponse is a response for Create

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
type CreateResponse struct {
	httpResponse *http.Response
	Data         components.PullRequest
}

// HTTPResponse returns the *http.Response
func (r *CreateResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CreateResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{201})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
CreateReplyForReviewComment performs requests for "pulls/create-reply-for-review-comment"

Create a reply for a review comment.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
func CreateReplyForReviewComment(ctx context.Context, req *CreateReplyForReviewCommentReq, opt ...requests.Option) (*CreateReplyForReviewCommentResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CreateReplyForReviewCommentReq)
	}
	resp := &CreateReplyForReviewCommentResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateReplyForReviewComment performs requests for "pulls/create-reply-for-review-comment"

Create a reply for a review comment.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CreateReplyForReviewComment(ctx context.Context, req *CreateReplyForReviewCommentReq, opt ...requests.Option) (*CreateReplyForReviewCommentResponse, error) {
	return CreateReplyForReviewComment(ctx, req, append(c, opt...)...)
}

/*
CreateReplyForReviewCommentReq is request data for Client.CreateReplyForReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CreateReplyForReviewCommentReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// comment_id parameter
	CommentId   int64
	RequestBody CreateReplyForReviewCommentReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CreateReplyForReviewCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "POST",
		Options: opt,
		URLPath: fmt.Sprintf("/repos/%v/%v/pulls/%v/comments/%v/replies", r.Owner, r.Repo, r.PullNumber, r.CommentId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateReplyForReviewCommentReq) Rel(link string, resp *CreateReplyForReviewCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateReplyForReviewCommentReqBody is a request body for pulls/create-reply-for-review-comment

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
type CreateReplyForReviewCommentReqBody struct {

	// The text of the review comment.
	Body *string `json:"body"`
}

/*
CreateReplyForReviewCommentResponse is a response for CreateReplyForReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
type CreateReplyForReviewCommentResponse struct {
	httpResponse *http.Response
	Data         components.PullRequestReviewComment
}

// HTTPResponse returns the *http.Response
func (r *CreateReplyForReviewCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CreateReplyForReviewCommentResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{201})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
CreateReview performs requests for "pulls/create-review"

Create a review for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
func CreateReview(ctx context.Context, req *CreateReviewReq, opt ...requests.Option) (*CreateReviewResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CreateReviewReq)
	}
	resp := &CreateReviewResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateReview performs requests for "pulls/create-review"

Create a review for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CreateReview(ctx context.Context, req *CreateReviewReq, opt ...requests.Option) (*CreateReviewResponse, error) {
	return CreateReview(ctx, req, append(c, opt...)...)
}

/*
CreateReviewReq is request data for Client.CreateReview

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CreateReviewReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody CreateReviewReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CreateReviewReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "POST",
		Options: opt,
		URLPath: fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews", r.Owner, r.Repo, r.PullNumber),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateReviewReq) Rel(link string, resp *CreateReviewResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateReviewReqBodyComments is a value for CreateReviewReqBody's Comments field
type CreateReviewReqBodyComments struct {

	// Text of the review comment.
	Body *string `json:"body"`
	Line *int64  `json:"line,omitempty"`

	// The relative path to the file that necessitates a review comment.
	Path *string `json:"path"`

	/*
	The position in the diff where you want to add a review comment. Note this value
	is not the same as the line number in the file. For help finding the position
	value, read the note below.
	*/
	Position  *int64  `json:"position,omitempty"`
	Side      *string `json:"side,omitempty"`
	StartLine *int64  `json:"start_line,omitempty"`
	StartSide *string `json:"start_side,omitempty"`
}

/*
CreateReviewReqBody is a request body for pulls/create-review

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
type CreateReviewReqBody struct {

	/*
	**Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event`
	parameter. The body text of the pull request review.
	*/
	Body *string `json:"body,omitempty"`

	// Use the following table to specify the location, destination, and contents of the draft review comment.
	Comments []CreateReviewReqBodyComments `json:"comments,omitempty"`

	/*
	The SHA of the commit that needs a review. Not using the latest commit SHA may
	render your review comment outdated if a subsequent commit modifies the line you
	specify as the `position`. Defaults to the most recent commit in the pull
	request when you do not specify a value.
	*/
	CommitId *string `json:"commit_id,omitempty"`

	/*
	The review action you want to perform. The review actions include: `APPROVE`,
	`REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review
	action state to `PENDING`, which means you will need to [submit the pull request
	review](https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request)
	when you are ready.
	*/
	Event *string `json:"event,omitempty"`
}

/*
CreateReviewResponse is a response for CreateReview

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
type CreateReviewResponse struct {
	httpResponse *http.Response
	Data         components.PullRequestReview
}

// HTTPResponse returns the *http.Response
func (r *CreateReviewResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CreateReviewResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
CreateReviewComment performs requests for "pulls/create-review-comment"

Create a review comment for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
func CreateReviewComment(ctx context.Context, req *CreateReviewCommentReq, opt ...requests.Option) (*CreateReviewCommentResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CreateReviewCommentReq)
	}
	resp := &CreateReviewCommentResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateReviewComment performs requests for "pulls/create-review-comment"

Create a review comment for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CreateReviewComment(ctx context.Context, req *CreateReviewCommentReq, opt ...requests.Option) (*CreateReviewCommentResponse, error) {
	return CreateReviewComment(ctx, req, append(c, opt...)...)
}

/*
CreateReviewCommentReq is request data for Client.CreateReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CreateReviewCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody CreateReviewCommentReqBody

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CreateReviewCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews: []string{"comfort-fade"},
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:   "POST",
		Options:  opt,
		Previews: map[string]bool{"comfort-fade": r.ComfortFadePreview},
		URLPath:  fmt.Sprintf("/repos/%v/%v/pulls/%v/comments", r.Owner, r.Repo, r.PullNumber),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateReviewCommentReq) Rel(link string, resp *CreateReviewCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateReviewCommentReqBody is a request body for pulls/create-review-comment

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
type CreateReviewCommentReqBody struct {

	// The text of the review comment.
	Body *string `json:"body"`

	/*
	The SHA of the commit needing a comment. Not using the latest commit SHA may
	render your comment outdated if a subsequent commit modifies the line you
	specify as the `position`.
	*/
	CommitId  *string `json:"commit_id,omitempty"`
	InReplyTo *int64  `json:"in_reply_to,omitempty"`

	/*
	**Required with `comfort-fade` preview**. The line of the blob in the pull
	request diff that the comment applies to. For a multi-line comment, the last
	line of the range that your comment applies to.
	*/
	Line *int64 `json:"line,omitempty"`

	// The relative path to the file that necessitates a comment.
	Path *string `json:"path"`

	/*
	**Required without `comfort-fade` preview**. The position in the diff where you
	want to add a review comment. Note this value is not the same as the line number
	in the file. For help finding the position value, read the note above.
	*/
	Position *int64 `json:"position,omitempty"`

	/*
	**Required with `comfort-fade` preview**. In a split diff view, the side of the
	diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use
	`LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear
	in green or unchanged lines that appear in white and are shown for context. For
	a multi-line comment, side represents whether the last line of the comment range
	is a deletion or addition. For more information, see "[Diff view
	options](https://help.github.com/en/articles/about-comparing-branches-in-pull-requests#diff-view-options)"
	in the GitHub Help documentation.
	*/
	Side *string `json:"side,omitempty"`

	/*
	**Required when using multi-line comments**. To create multi-line comments, you
	must use the `comfort-fade` preview header. The `start_line` is the first line
	in the pull request diff that your multi-line comment applies to. To learn more
	about multi-line comments, see "[Commenting on a pull
	request](https://help.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)"
	in the GitHub Help documentation.
	*/
	StartLine *int64 `json:"start_line,omitempty"`

	/*
	**Required when using multi-line comments**. To create multi-line comments, you
	must use the `comfort-fade` preview header. The `start_side` is the starting
	side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn
	more about multi-line comments, see "[Commenting on a pull
	request](https://help.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)"
	in the GitHub Help documentation. See `side` in this table for additional
	context.
	*/
	StartSide *string `json:"start_side,omitempty"`
}

/*
CreateReviewCommentResponse is a response for CreateReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
type CreateReviewCommentResponse struct {
	httpResponse *http.Response
	Data         components.PullRequestReviewComment
}

// HTTPResponse returns the *http.Response
func (r *CreateReviewCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CreateReviewCommentResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{201})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
DeletePendingReview performs requests for "pulls/delete-pending-review"

Delete a pending review for a pull request.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review-for-a-pull-request
*/
func DeletePendingReview(ctx context.Context, req *DeletePendingReviewReq, opt ...requests.Option) (*DeletePendingReviewResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DeletePendingReviewReq)
	}
	resp := &DeletePendingReviewResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeletePendingReview performs requests for "pulls/delete-pending-review"

Delete a pending review for a pull request.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) DeletePendingReview(ctx context.Context, req *DeletePendingReviewReq, opt ...requests.Option) (*DeletePendingReviewResponse, error) {
	return DeletePendingReview(ctx, req, append(c, opt...)...)
}

/*
DeletePendingReviewReq is request data for Client.DeletePendingReview

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DeletePendingReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// review_id parameter
	ReviewId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DeletePendingReviewReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v", r.Owner, r.Repo, r.PullNumber, r.ReviewId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeletePendingReviewReq) Rel(link string, resp *DeletePendingReviewResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeletePendingReviewResponse is a response for DeletePendingReview

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review-for-a-pull-request
*/
type DeletePendingReviewResponse struct {
	httpResponse *http.Response
	Data         components.PullRequestReview
}

// HTTPResponse returns the *http.Response
func (r *DeletePendingReviewResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DeletePendingReviewResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
DeleteReviewComment performs requests for "pulls/delete-review-comment"

Delete a review comment for a pull request.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#delete-a-review-comment-for-a-pull-request
*/
func DeleteReviewComment(ctx context.Context, req *DeleteReviewCommentReq, opt ...requests.Option) (*DeleteReviewCommentResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DeleteReviewCommentReq)
	}
	resp := &DeleteReviewCommentResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteReviewComment performs requests for "pulls/delete-review-comment"

Delete a review comment for a pull request.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#delete-a-review-comment-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) DeleteReviewComment(ctx context.Context, req *DeleteReviewCommentReq, opt ...requests.Option) (*DeleteReviewCommentResponse, error) {
	return DeleteReviewComment(ctx, req, append(c, opt...)...)
}

/*
DeleteReviewCommentReq is request data for Client.DeleteReviewComment

https://developer.github.com/v3/pulls/comments/#delete-a-review-comment-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DeleteReviewCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DeleteReviewCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{},
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/pulls/comments/%v", r.Owner, r.Repo, r.CommentId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteReviewCommentReq) Rel(link string, resp *DeleteReviewCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteReviewCommentResponse is a response for DeleteReviewComment

https://developer.github.com/v3/pulls/comments/#delete-a-review-comment-for-a-pull-request
*/
type DeleteReviewCommentResponse struct {
	httpResponse *http.Response
	Data         bool
}

// HTTPResponse returns the *http.Response
func (r *DeleteReviewCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DeleteReviewCommentResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 404})
	if err != nil {
		return err
	}
	err = internal.SetBoolResult(resp, &r.Data)
	if err != nil {
		return err
	}
	return nil
}

/*
DismissReview performs requests for "pulls/dismiss-review"

Dismiss a review for a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
func DismissReview(ctx context.Context, req *DismissReviewReq, opt ...requests.Option) (*DismissReviewResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DismissReviewReq)
	}
	resp := &DismissReviewResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DismissReview performs requests for "pulls/dismiss-review"

Dismiss a review for a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) DismissReview(ctx context.Context, req *DismissReviewReq, opt ...requests.Option) (*DismissReviewResponse, error) {
	return DismissReview(ctx, req, append(c, opt...)...)
}

/*
DismissReviewReq is request data for Client.DismissReview

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DismissReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// review_id parameter
	ReviewId    int64
	RequestBody DismissReviewReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DismissReviewReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "PUT",
		Options: opt,
		URLPath: fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v/dismissals", r.Owner, r.Repo, r.PullNumber, r.ReviewId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DismissReviewReq) Rel(link string, resp *DismissReviewResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DismissReviewReqBody is a request body for pulls/dismiss-review

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
type DismissReviewReqBody struct {
	Event *string `json:"event,omitempty"`

	// The message for the pull request review dismissal
	Message *string `json:"message"`
}

/*
DismissReviewResponse is a response for DismissReview

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
type DismissReviewResponse struct {
	httpResponse *http.Response
	Data         components.PullRequestReview
}

// HTTPResponse returns the *http.Response
func (r *DismissReviewResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DismissReviewResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
Get performs requests for "pulls/get"

Get a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#get-a-pull-request
*/
func Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetReq)
	}
	resp := &GetResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Get performs requests for "pulls/get"

Get a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#get-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	return Get(ctx, req, append(c, opt...)...)
}

/*
GetReq is request data for Client.Get

https://developer.github.com/v3/pulls/#get-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews: []string{"sailor-v"},
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		Previews:    map[string]bool{"sailor-v": r.SailorVPreview},
		URLPath:     fmt.Sprintf("/repos/%v/%v/pulls/%v", r.Owner, r.Repo, r.PullNumber),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReq) Rel(link string, resp *GetResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetResponse is a response for Get

https://developer.github.com/v3/pulls/#get-a-pull-request
*/
type GetResponse struct {
	httpResponse *http.Response
	Data         components.PullRequest
}

// HTTPResponse returns the *http.Response
func (r *GetResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetReview performs requests for "pulls/get-review"

Get a review for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#get-a-review-for-a-pull-request
*/
func GetReview(ctx context.Context, req *GetReviewReq, opt ...requests.Option) (*GetReviewResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetReviewReq)
	}
	resp := &GetReviewResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetReview performs requests for "pulls/get-review"

Get a review for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#get-a-review-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetReview(ctx context.Context, req *GetReviewReq, opt ...requests.Option) (*GetReviewResponse, error) {
	return GetReview(ctx, req, append(c, opt...)...)
}

/*
GetReviewReq is request data for Client.GetReview

https://developer.github.com/v3/pulls/reviews/#get-a-review-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// review_id parameter
	ReviewId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetReviewReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v", r.Owner, r.Repo, r.PullNumber, r.ReviewId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReviewReq) Rel(link string, resp *GetReviewResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetReviewResponse is a response for GetReview

https://developer.github.com/v3/pulls/reviews/#get-a-review-for-a-pull-request
*/
type GetReviewResponse struct {
	httpResponse *http.Response
	Data         components.PullRequestReview
}

// HTTPResponse returns the *http.Response
func (r *GetReviewResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetReviewResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetReviewComment performs requests for "pulls/get-review-comment"

Get a review comment for a pull request.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#get-a-review-comment-for-a-pull-request
*/
func GetReviewComment(ctx context.Context, req *GetReviewCommentReq, opt ...requests.Option) (*GetReviewCommentResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetReviewCommentReq)
	}
	resp := &GetReviewCommentResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetReviewComment performs requests for "pulls/get-review-comment"

Get a review comment for a pull request.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#get-a-review-comment-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetReviewComment(ctx context.Context, req *GetReviewCommentReq, opt ...requests.Option) (*GetReviewCommentResponse, error) {
	return GetReviewComment(ctx, req, append(c, opt...)...)
}

/*
GetReviewCommentReq is request data for Client.GetReviewComment

https://developer.github.com/v3/pulls/comments/#get-a-review-comment-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetReviewCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetReviewCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews: []string{"comfort-fade", "squirrel-girl"},
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		Previews: map[string]bool{
			"comfort-fade":  r.ComfortFadePreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		URLPath: fmt.Sprintf("/repos/%v/%v/pulls/comments/%v", r.Owner, r.Repo, r.CommentId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReviewCommentReq) Rel(link string, resp *GetReviewCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetReviewCommentResponse is a response for GetReviewComment

https://developer.github.com/v3/pulls/comments/#get-a-review-comment-for-a-pull-request
*/
type GetReviewCommentResponse struct {
	httpResponse *http.Response
	Data         components.PullRequestReviewComment
}

// HTTPResponse returns the *http.Response
func (r *GetReviewCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetReviewCommentResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
List performs requests for "pulls/list"

List pull requests.

  GET /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#list-pull-requests
*/
func List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReq)
	}
	resp := &ListResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
List performs requests for "pulls/list"

List pull requests.

  GET /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#list-pull-requests

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	return List(ctx, req, append(c, opt...)...)
}

/*
ListReq is request data for Client.List

https://developer.github.com/v3/pulls/#list-pull-requests

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReq struct {
	_url  string
	Owner string
	Repo  string

	// Either `open`, `closed`, or `all` to filter by state.
	State *string

	/*
	Filter pulls by head user or head organization and branch name in the format of
	`user:ref-name` or `organization:ref-name`. For example:
	`github:new-script-format` or `octocat:test-branch`.
	*/
	Head *string

	// Filter pulls by base branch name. Example: `gh-pages`.
	Base *string

	/*
	What to sort results by. Can be either `created`, `updated`, `popularity`
	(comment count) or `long-running` (age, filtering by pulls updated in the last
	month).
	*/
	Sort *string

	/*
	The direction of the sort. Can be either `asc` or `desc`. Default: `desc` when
	sort is `created` or sort is not specified, otherwise `asc`.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Head != nil {
		query.Set("head", *r.Head)
	}
	if r.Base != nil {
		query.Set("base", *r.Base)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews: []string{"sailor-v"},
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		Previews:    map[string]bool{"sailor-v": r.SailorVPreview},
		URLPath:     fmt.Sprintf("/repos/%v/%v/pulls", r.Owner, r.Repo),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReq) Rel(link string, resp *ListResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListResponse is a response for List

https://developer.github.com/v3/pulls/#list-pull-requests
*/
type ListResponse struct {
	httpResponse *http.Response
	Data         []components.PullRequestSimple
}

// HTTPResponse returns the *http.Response
func (r *ListResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListCommentsForReview performs requests for "pulls/list-comments-for-review"

List comments for a pull request review.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments

https://developer.github.com/v3/pulls/reviews/#list-comments-for-a-pull-request-review
*/
func ListCommentsForReview(ctx context.Context, req *ListCommentsForReviewReq, opt ...requests.Option) (*ListCommentsForReviewResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListCommentsForReviewReq)
	}
	resp := &ListCommentsForReviewResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListCommentsForReview performs requests for "pulls/list-comments-for-review"

List comments for a pull request review.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments

https://developer.github.com/v3/pulls/reviews/#list-comments-for-a-pull-request-review

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListCommentsForReview(ctx context.Context, req *ListCommentsForReviewReq, opt ...requests.Option) (*ListCommentsForReviewResponse, error) {
	return ListCommentsForReview(ctx, req, append(c, opt...)...)
}

/*
ListCommentsForReviewReq is request data for Client.ListCommentsForReview

https://developer.github.com/v3/pulls/reviews/#list-comments-for-a-pull-request-review

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListCommentsForReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// review_id parameter
	ReviewId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListCommentsForReviewReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v/comments", r.Owner, r.Repo, r.PullNumber, r.ReviewId),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommentsForReviewReq) Rel(link string, resp *ListCommentsForReviewResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommentsForReviewResponse is a response for ListCommentsForReview

https://developer.github.com/v3/pulls/reviews/#list-comments-for-a-pull-request-review
*/
type ListCommentsForReviewResponse struct {
	httpResponse *http.Response
	Data         []components.ReviewComment
}

// HTTPResponse returns the *http.Response
func (r *ListCommentsForReviewResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListCommentsForReviewResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListCommits performs requests for "pulls/list-commits"

List commits on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/commits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
func ListCommits(ctx context.Context, req *ListCommitsReq, opt ...requests.Option) (*ListCommitsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListCommitsReq)
	}
	resp := &ListCommitsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListCommits performs requests for "pulls/list-commits"

List commits on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/commits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListCommits(ctx context.Context, req *ListCommitsReq, opt ...requests.Option) (*ListCommitsResponse, error) {
	return ListCommits(ctx, req, append(c, opt...)...)
}

/*
ListCommitsReq is request data for Client.ListCommits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListCommitsReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListCommitsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/pulls/%v/commits", r.Owner, r.Repo, r.PullNumber),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommitsReq) Rel(link string, resp *ListCommitsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommitsResponse is a response for ListCommits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
type ListCommitsResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleCommit
}

// HTTPResponse returns the *http.Response
func (r *ListCommitsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListCommitsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListFiles performs requests for "pulls/list-files"

List pull requests files.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/files

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
func ListFiles(ctx context.Context, req *ListFilesReq, opt ...requests.Option) (*ListFilesResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListFilesReq)
	}
	resp := &ListFilesResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListFiles performs requests for "pulls/list-files"

List pull requests files.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/files

https://developer.github.com/v3/pulls/#list-pull-requests-files

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListFiles(ctx context.Context, req *ListFilesReq, opt ...requests.Option) (*ListFilesResponse, error) {
	return ListFiles(ctx, req, append(c, opt...)...)
}

/*
ListFilesReq is request data for Client.ListFiles

https://developer.github.com/v3/pulls/#list-pull-requests-files

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListFilesReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListFilesReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/pulls/%v/files", r.Owner, r.Repo, r.PullNumber),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListFilesReq) Rel(link string, resp *ListFilesResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListFilesResponse is a response for ListFiles

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
type ListFilesResponse struct {
	httpResponse *http.Response
	Data         []components.DiffEntry
}

// HTTPResponse returns the *http.Response
func (r *ListFilesResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListFilesResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListRequestedReviewers performs requests for "pulls/list-requested-reviewers"

List requested reviewers for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#list-requested-reviewers-for-a-pull-request
*/
func ListRequestedReviewers(ctx context.Context, req *ListRequestedReviewersReq, opt ...requests.Option) (*ListRequestedReviewersResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListRequestedReviewersReq)
	}
	resp := &ListRequestedReviewersResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListRequestedReviewers performs requests for "pulls/list-requested-reviewers"

List requested reviewers for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#list-requested-reviewers-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListRequestedReviewers(ctx context.Context, req *ListRequestedReviewersReq, opt ...requests.Option) (*ListRequestedReviewersResponse, error) {
	return ListRequestedReviewers(ctx, req, append(c, opt...)...)
}

/*
ListRequestedReviewersReq is request data for Client.ListRequestedReviewers

https://developer.github.com/v3/pulls/review_requests/#list-requested-reviewers-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListRequestedReviewersReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListRequestedReviewersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/pulls/%v/requested_reviewers", r.Owner, r.Repo, r.PullNumber),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListRequestedReviewersReq) Rel(link string, resp *ListRequestedReviewersResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListRequestedReviewersResponse is a response for ListRequestedReviewers

https://developer.github.com/v3/pulls/review_requests/#list-requested-reviewers-for-a-pull-request
*/
type ListRequestedReviewersResponse struct {
	httpResponse *http.Response
	Data         components.PullRequestReviewRequest
}

// HTTPResponse returns the *http.Response
func (r *ListRequestedReviewersResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListRequestedReviewersResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListReviewComments performs requests for "pulls/list-review-comments"

List review comments on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#list-review-comments-on-a-pull-request
*/
func ListReviewComments(ctx context.Context, req *ListReviewCommentsReq, opt ...requests.Option) (*ListReviewCommentsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReviewCommentsReq)
	}
	resp := &ListReviewCommentsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReviewComments performs requests for "pulls/list-review-comments"

List review comments on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#list-review-comments-on-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListReviewComments(ctx context.Context, req *ListReviewCommentsReq, opt ...requests.Option) (*ListReviewCommentsResponse, error) {
	return ListReviewComments(ctx, req, append(c, opt...)...)
}

/*
ListReviewCommentsReq is request data for Client.ListReviewComments

https://developer.github.com/v3/pulls/comments/#list-review-comments-on-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReviewCommentsReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// Can be either `asc` or `desc`. Ignored without `sort` parameter.
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReviewCommentsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews: []string{"comfort-fade", "squirrel-girl"},
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		Previews: map[string]bool{
			"comfort-fade":  r.ComfortFadePreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		URLPath:  fmt.Sprintf("/repos/%v/%v/pulls/%v/comments", r.Owner, r.Repo, r.PullNumber),
		URLQuery: query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReviewCommentsReq) Rel(link string, resp *ListReviewCommentsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReviewCommentsResponse is a response for ListReviewComments

https://developer.github.com/v3/pulls/comments/#list-review-comments-on-a-pull-request
*/
type ListReviewCommentsResponse struct {
	httpResponse *http.Response
	Data         []components.PullRequestReviewComment
}

// HTTPResponse returns the *http.Response
func (r *ListReviewCommentsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListReviewCommentsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListReviewCommentsForRepo performs requests for "pulls/list-review-comments-for-repo"

List review comments in a repository.

  GET /repos/{owner}/{repo}/pulls/comments

https://developer.github.com/v3/pulls/comments/#list-review-comments-in-a-repository
*/
func ListReviewCommentsForRepo(ctx context.Context, req *ListReviewCommentsForRepoReq, opt ...requests.Option) (*ListReviewCommentsForRepoResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReviewCommentsForRepoReq)
	}
	resp := &ListReviewCommentsForRepoResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReviewCommentsForRepo performs requests for "pulls/list-review-comments-for-repo"

List review comments in a repository.

  GET /repos/{owner}/{repo}/pulls/comments

https://developer.github.com/v3/pulls/comments/#list-review-comments-in-a-repository

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListReviewCommentsForRepo(ctx context.Context, req *ListReviewCommentsForRepoReq, opt ...requests.Option) (*ListReviewCommentsForRepoResponse, error) {
	return ListReviewCommentsForRepo(ctx, req, append(c, opt...)...)
}

/*
ListReviewCommentsForRepoReq is request data for Client.ListReviewCommentsForRepo

https://developer.github.com/v3/pulls/comments/#list-review-comments-in-a-repository

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReviewCommentsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// Can be either `asc` or `desc`. Ignored without `sort` parameter.
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReviewCommentsForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews: []string{"comfort-fade", "squirrel-girl"},
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		Previews: map[string]bool{
			"comfort-fade":  r.ComfortFadePreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		URLPath:  fmt.Sprintf("/repos/%v/%v/pulls/comments", r.Owner, r.Repo),
		URLQuery: query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReviewCommentsForRepoReq) Rel(link string, resp *ListReviewCommentsForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReviewCommentsForRepoResponse is a response for ListReviewCommentsForRepo

https://developer.github.com/v3/pulls/comments/#list-review-comments-in-a-repository
*/
type ListReviewCommentsForRepoResponse struct {
	httpResponse *http.Response
	Data         []components.PullRequestReviewComment
}

// HTTPResponse returns the *http.Response
func (r *ListReviewCommentsForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListReviewCommentsForRepoResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListReviews performs requests for "pulls/list-reviews"

List reviews for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-for-a-pull-request
*/
func ListReviews(ctx context.Context, req *ListReviewsReq, opt ...requests.Option) (*ListReviewsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReviewsReq)
	}
	resp := &ListReviewsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReviews performs requests for "pulls/list-reviews"

List reviews for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListReviews(ctx context.Context, req *ListReviewsReq, opt ...requests.Option) (*ListReviewsResponse, error) {
	return ListReviews(ctx, req, append(c, opt...)...)
}

/*
ListReviewsReq is request data for Client.ListReviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReviewsReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReviewsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        nil,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews", r.Owner, r.Repo, r.PullNumber),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReviewsReq) Rel(link string, resp *ListReviewsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReviewsResponse is a response for ListReviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-for-a-pull-request
*/
type ListReviewsResponse struct {
	httpResponse *http.Response
	Data         []components.PullRequestReview
}

// HTTPResponse returns the *http.Response
func (r *ListReviewsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListReviewsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
Merge performs requests for "pulls/merge"

Merge a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
func Merge(ctx context.Context, req *MergeReq, opt ...requests.Option) (*MergeResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(MergeReq)
	}
	resp := &MergeResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Merge performs requests for "pulls/merge"

Merge a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#merge-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Merge(ctx context.Context, req *MergeReq, opt ...requests.Option) (*MergeResponse, error) {
	return Merge(ctx, req, append(c, opt...)...)
}

/*
MergeReq is request data for Client.Merge

https://developer.github.com/v3/pulls/#merge-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type MergeReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody MergeReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *MergeReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "PUT",
		Options: opt,
		URLPath: fmt.Sprintf("/repos/%v/%v/pulls/%v/merge", r.Owner, r.Repo, r.PullNumber),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MergeReq) Rel(link string, resp *MergeResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MergeReqBody is a request body for pulls/merge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
type MergeReqBody struct {

	// Extra detail to append to automatic commit message.
	CommitMessage *string `json:"commit_message,omitempty"`

	// Title for the automatic commit message.
	CommitTitle *string `json:"commit_title,omitempty"`

	// Merge method to use. Possible values are `merge`, `squash` or `rebase`. Default is `merge`.
	MergeMethod *string `json:"merge_method,omitempty"`

	// SHA that pull request head must match to allow merge.
	Sha *string `json:"sha,omitempty"`
}

/*
MergeResponse is a response for Merge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
type MergeResponse struct {
	httpResponse *http.Response
	Data         components.PullRequestMergeResult
}

// HTTPResponse returns the *http.Response
func (r *MergeResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *MergeResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
RemoveRequestedReviewers performs requests for "pulls/remove-requested-reviewers"

Remove requested reviewers from a pull request.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request
*/
func RemoveRequestedReviewers(ctx context.Context, req *RemoveRequestedReviewersReq, opt ...requests.Option) (*RemoveRequestedReviewersResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(RemoveRequestedReviewersReq)
	}
	resp := &RemoveRequestedReviewersResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveRequestedReviewers performs requests for "pulls/remove-requested-reviewers"

Remove requested reviewers from a pull request.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) RemoveRequestedReviewers(ctx context.Context, req *RemoveRequestedReviewersReq, opt ...requests.Option) (*RemoveRequestedReviewersResponse, error) {
	return RemoveRequestedReviewers(ctx, req, append(c, opt...)...)
}

/*
RemoveRequestedReviewersReq is request data for Client.RemoveRequestedReviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type RemoveRequestedReviewersReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody RemoveRequestedReviewersReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *RemoveRequestedReviewersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"content-type": internal.String("application/json")},
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/repos/%v/%v/pulls/%v/requested_reviewers", r.Owner, r.Repo, r.PullNumber),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveRequestedReviewersReq) Rel(link string, resp *RemoveRequestedReviewersResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveRequestedReviewersReqBody is a request body for pulls/remove-requested-reviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request
*/
type RemoveRequestedReviewersReqBody struct {

	// An array of user `login`s that will be removed.
	Reviewers []string `json:"reviewers,omitempty"`

	// An array of team `slug`s that will be removed.
	TeamReviewers []string `json:"team_reviewers,omitempty"`
}

/*
RemoveRequestedReviewersResponse is a response for RemoveRequestedReviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request
*/
type RemoveRequestedReviewersResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *RemoveRequestedReviewersResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *RemoveRequestedReviewersResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	return nil
}

/*
RequestReviewers performs requests for "pulls/request-reviewers"

Request reviewers for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
func RequestReviewers(ctx context.Context, req *RequestReviewersReq, opt ...requests.Option) (*RequestReviewersResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(RequestReviewersReq)
	}
	resp := &RequestReviewersResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RequestReviewers performs requests for "pulls/request-reviewers"

Request reviewers for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) RequestReviewers(ctx context.Context, req *RequestReviewersReq, opt ...requests.Option) (*RequestReviewersResponse, error) {
	return RequestReviewers(ctx, req, append(c, opt...)...)
}

/*
RequestReviewersReq is request data for Client.RequestReviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type RequestReviewersReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody RequestReviewersReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *RequestReviewersReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "POST",
		Options: opt,
		URLPath: fmt.Sprintf("/repos/%v/%v/pulls/%v/requested_reviewers", r.Owner, r.Repo, r.PullNumber),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RequestReviewersReq) Rel(link string, resp *RequestReviewersResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RequestReviewersReqBody is a request body for pulls/request-reviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
type RequestReviewersReqBody struct {

	// An array of user `login`s that will be requested.
	Reviewers []string `json:"reviewers,omitempty"`

	// An array of team `slug`s that will be requested.
	TeamReviewers []string `json:"team_reviewers,omitempty"`
}

/*
RequestReviewersResponse is a response for RequestReviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
type RequestReviewersResponse struct {
	httpResponse *http.Response
	Data         components.PullRequestSimple
}

// HTTPResponse returns the *http.Response
func (r *RequestReviewersResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *RequestReviewersResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{201})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
SubmitReview performs requests for "pulls/submit-review"

Submit a review for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
func SubmitReview(ctx context.Context, req *SubmitReviewReq, opt ...requests.Option) (*SubmitReviewResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(SubmitReviewReq)
	}
	resp := &SubmitReviewResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SubmitReview performs requests for "pulls/submit-review"

Submit a review for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) SubmitReview(ctx context.Context, req *SubmitReviewReq, opt ...requests.Option) (*SubmitReviewResponse, error) {
	return SubmitReview(ctx, req, append(c, opt...)...)
}

/*
SubmitReviewReq is request data for Client.SubmitReview

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type SubmitReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// review_id parameter
	ReviewId    int64
	RequestBody SubmitReviewReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *SubmitReviewReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "POST",
		Options: opt,
		URLPath: fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v/events", r.Owner, r.Repo, r.PullNumber, r.ReviewId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SubmitReviewReq) Rel(link string, resp *SubmitReviewResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SubmitReviewReqBody is a request body for pulls/submit-review

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
type SubmitReviewReqBody struct {

	// The body text of the pull request review
	Body *string `json:"body,omitempty"`

	/*
	The review action you want to perform. The review actions include: `APPROVE`,
	`REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns
	_HTTP 422 (Unrecognizable entity)_ and sets the review action state to
	`PENDING`, which means you will need to re-submit the pull request review using
	a review action.
	*/
	Event *string `json:"event"`
}

/*
SubmitReviewResponse is a response for SubmitReview

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
type SubmitReviewResponse struct {
	httpResponse *http.Response
	Data         components.PullRequestReview
}

// HTTPResponse returns the *http.Response
func (r *SubmitReviewResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *SubmitReviewResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
Update performs requests for "pulls/update"

Update a pull request.

  PATCH /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
func Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UpdateReq)
	}
	resp := &UpdateResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Update performs requests for "pulls/update"

Update a pull request.

  PATCH /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#update-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	return Update(ctx, req, append(c, opt...)...)
}

/*
UpdateReq is request data for Client.Update

https://developer.github.com/v3/pulls/#update-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UpdateReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody UpdateReqBody

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UpdateReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews: []string{"sailor-v"},
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:   "PATCH",
		Options:  opt,
		Previews: map[string]bool{"sailor-v": r.SailorVPreview},
		URLPath:  fmt.Sprintf("/repos/%v/%v/pulls/%v", r.Owner, r.Repo, r.PullNumber),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReq) Rel(link string, resp *UpdateResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateReqBody is a request body for pulls/update

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
type UpdateReqBody struct {

	/*
	The name of the branch you want your changes pulled into. This should be an
	existing branch on the current repository. You cannot update the base branch on
	a pull request to point to another repository.
	*/
	Base *string `json:"base,omitempty"`

	// The contents of the pull request.
	Body *string `json:"body,omitempty"`

	/*
	Indicates whether [maintainers can
	modify](https://help.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/)
	the pull request.
	*/
	MaintainerCanModify *bool `json:"maintainer_can_modify,omitempty"`

	// State of this Pull Request. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the pull request.
	Title *string `json:"title,omitempty"`
}

/*
UpdateResponse is a response for Update

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
type UpdateResponse struct {
	httpResponse *http.Response
	Data         components.PullRequest
}

// HTTPResponse returns the *http.Response
func (r *UpdateResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UpdateResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
UpdateBranch performs requests for "pulls/update-branch"

Update a pull request branch.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
func UpdateBranch(ctx context.Context, req *UpdateBranchReq, opt ...requests.Option) (*UpdateBranchResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UpdateBranchReq)
	}
	resp := &UpdateBranchResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateBranch performs requests for "pulls/update-branch"

Update a pull request branch.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) UpdateBranch(ctx context.Context, req *UpdateBranchReq, opt ...requests.Option) (*UpdateBranchResponse, error) {
	return UpdateBranch(ctx, req, append(c, opt...)...)
}

/*
UpdateBranchReq is request data for Client.UpdateBranch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UpdateBranchReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody UpdateBranchReqBody

	/*
	Updating the pull request branch with latest upstream changes is currently
	available for developers to preview. To access this new endpoint during the
	preview period, you must set this to true.
	*/
	LydianPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UpdateBranchReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews: []string{"lydian"},
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		Options:          opt,
		Previews:         map[string]bool{"lydian": r.LydianPreview},
		RequiredPreviews: []string{"lydian"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/update-branch", r.Owner, r.Repo, r.PullNumber),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateBranchReq) Rel(link string, resp *UpdateBranchResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateBranchReqBody is a request body for pulls/update-branch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type UpdateBranchReqBody struct {

	/*
	The expected SHA of the pull request's HEAD ref. This is the most recent commit
	on the pull request's branch. If the expected SHA does not match the pull
	request's HEAD, you will receive a `422 Unprocessable Entity` status. You can
	use the "[List
	commits](https://developer.github.com/v3/repos/commits/#list-commits)" endpoint
	to find the most recent commit SHA. Default: SHA of the pull request's current
	HEAD ref.
	*/
	ExpectedHeadSha *string `json:"expected_head_sha,omitempty"`
}

/*
UpdateBranchResponseBody is a response body for UpdateBranch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type UpdateBranchResponseBody struct {
	Message string `json:"message,omitempty"`
	Url     string `json:"url,omitempty"`
}

/*
UpdateBranchResponse is a response for UpdateBranch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type UpdateBranchResponse struct {
	httpResponse *http.Response
	Data         UpdateBranchResponseBody
}

// HTTPResponse returns the *http.Response
func (r *UpdateBranchResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UpdateBranchResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{202})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{202}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
UpdateReview performs requests for "pulls/update-review"

Update a review for a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
func UpdateReview(ctx context.Context, req *UpdateReviewReq, opt ...requests.Option) (*UpdateReviewResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UpdateReviewReq)
	}
	resp := &UpdateReviewResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateReview performs requests for "pulls/update-review"

Update a review for a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) UpdateReview(ctx context.Context, req *UpdateReviewReq, opt ...requests.Option) (*UpdateReviewResponse, error) {
	return UpdateReview(ctx, req, append(c, opt...)...)
}

/*
UpdateReviewReq is request data for Client.UpdateReview

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UpdateReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// review_id parameter
	ReviewId    int64
	RequestBody UpdateReviewReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UpdateReviewReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "PUT",
		Options: opt,
		URLPath: fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v", r.Owner, r.Repo, r.PullNumber, r.ReviewId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReviewReq) Rel(link string, resp *UpdateReviewResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateReviewReqBody is a request body for pulls/update-review

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
type UpdateReviewReqBody struct {

	// The body text of the pull request review.
	Body *string `json:"body"`
}

/*
UpdateReviewResponse is a response for UpdateReview

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
type UpdateReviewResponse struct {
	httpResponse *http.Response
	Data         components.PullRequestReview
}

// HTTPResponse returns the *http.Response
func (r *UpdateReviewResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UpdateReviewResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
UpdateReviewComment performs requests for "pulls/update-review-comment"

Update a review comment for a pull request.

  PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
func UpdateReviewComment(ctx context.Context, req *UpdateReviewCommentReq, opt ...requests.Option) (*UpdateReviewCommentResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UpdateReviewCommentReq)
	}
	resp := &UpdateReviewCommentResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateReviewComment performs requests for "pulls/update-review-comment"

Update a review comment for a pull request.

  PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) UpdateReviewComment(ctx context.Context, req *UpdateReviewCommentReq, opt ...requests.Option) (*UpdateReviewCommentResponse, error) {
	return UpdateReviewComment(ctx, req, append(c, opt...)...)
}

/*
UpdateReviewCommentReq is request data for Client.UpdateReviewComment

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UpdateReviewCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody UpdateReviewCommentReqBody

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UpdateReviewCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		AllPreviews: []string{"comfort-fade"},
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:   "PATCH",
		Options:  opt,
		Previews: map[string]bool{"comfort-fade": r.ComfortFadePreview},
		URLPath:  fmt.Sprintf("/repos/%v/%v/pulls/comments/%v", r.Owner, r.Repo, r.CommentId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReviewCommentReq) Rel(link string, resp *UpdateReviewCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateReviewCommentReqBody is a request body for pulls/update-review-comment

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
type UpdateReviewCommentReqBody struct {

	// The text of the reply to the review comment.
	Body *string `json:"body"`
}

/*
UpdateReviewCommentResponse is a response for UpdateReviewComment

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
type UpdateReviewCommentResponse struct {
	httpResponse *http.Response
	Data         components.PullRequestReviewComment
}

// HTTPResponse returns the *http.Response
func (r *UpdateReviewCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UpdateReviewCommentResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}
