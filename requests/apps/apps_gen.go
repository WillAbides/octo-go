// Code generated by octo-go; DO NOT EDIT.

package apps

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
AddRepoToInstallation performs requests for "apps/add-repo-to-installation"

Add a repository to an app installation.

  PUT /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
func AddRepoToInstallation(ctx context.Context, req *AddRepoToInstallationReq, opt ...requests.Option) (*AddRepoToInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddRepoToInstallationReq)
	}
	resp := &AddRepoToInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddRepoToInstallation performs requests for "apps/add-repo-to-installation"

Add a repository to an app installation.

  PUT /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
func (c Client) AddRepoToInstallation(ctx context.Context, req *AddRepoToInstallationReq, opt ...requests.Option) (*AddRepoToInstallationResponse, error) {
	return AddRepoToInstallation(ctx, req, append(c, opt...)...)
}

/*
AddRepoToInstallationReq is request data for Client.AddRepoToInstallation

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
type AddRepoToInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	// repository_id parameter
	RepositoryId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AddRepoToInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddRepoToInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "apps/add-repo-to-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddRepoToInstallationReq) Rel(link string, resp *AddRepoToInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddRepoToInstallationResponse is a response for AddRepoToInstallation

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
type AddRepoToInstallationResponse struct {
	requests.Response
	request *AddRepoToInstallationReq
}

/*
CheckAuthorization performs requests for "apps/check-authorization"

Check an authorization.

  GET /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
func CheckAuthorization(ctx context.Context, req *CheckAuthorizationReq, opt ...requests.Option) (*CheckAuthorizationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckAuthorizationReq)
	}
	resp := &CheckAuthorizationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = CheckAuthorizationResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckAuthorization performs requests for "apps/check-authorization"

Check an authorization.

  GET /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
func (c Client) CheckAuthorization(ctx context.Context, req *CheckAuthorizationReq, opt ...requests.Option) (*CheckAuthorizationResponse, error) {
	return CheckAuthorization(ctx, req, append(c, opt...)...)
}

/*
CheckAuthorizationReq is request data for Client.CheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type CheckAuthorizationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request
func (r *CheckAuthorizationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/check-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckAuthorizationReq) Rel(link string, resp *CheckAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckAuthorizationResponseBody is a response body for CheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type CheckAuthorizationResponseBody struct {
	App struct {
		ClientId string `json:"client_id"`
		Name     string `json:"name"`
		Url      string `json:"url"`
	} `json:"app,omitempty"`
	CreatedAt    string `json:"created_at,omitempty"`
	Fingerprint  string `json:"fingerprint,omitempty"`
	HashedToken  string `json:"hashed_token,omitempty"`
	Id           int64  `json:"id,omitempty"`
	Installation struct {

		// Simple User
		Account         components.SimpleUser `json:"account,omitempty"`
		Permissions     interface{}           `json:"permissions,omitempty"`
		RepositoriesUrl string                `json:"repositories_url,omitempty"`

		// Describe whether all repositories have been selected or there's a selection involved
		RepositorySelection string `json:"repository_selection,omitempty"`
		SingleFileName      string `json:"single_file_name,omitempty"`
	} `json:"installation,omitempty"`
	Note    string `json:"note,omitempty"`
	NoteUrl string `json:"note_url,omitempty"`

	// A list of scopes that this authorization is in.
	Scopes         []string `json:"scopes,omitempty"`
	Token          string   `json:"token,omitempty"`
	TokenLastEight string   `json:"token_last_eight,omitempty"`
	UpdatedAt      string   `json:"updated_at,omitempty"`
	Url            string   `json:"url,omitempty"`
	User           struct {
		AvatarUrl         string `json:"avatar_url,omitempty"`
		EventsUrl         string `json:"events_url,omitempty"`
		FollowersUrl      string `json:"followers_url,omitempty"`
		FollowingUrl      string `json:"following_url,omitempty"`
		GistsUrl          string `json:"gists_url,omitempty"`
		GravatarId        string `json:"gravatar_id,omitempty"`
		HtmlUrl           string `json:"html_url,omitempty"`
		Id                int64  `json:"id,omitempty"`
		Login             string `json:"login,omitempty"`
		NodeId            string `json:"node_id,omitempty"`
		OrganizationsUrl  string `json:"organizations_url,omitempty"`
		ReceivedEventsUrl string `json:"received_events_url,omitempty"`
		ReposUrl          string `json:"repos_url,omitempty"`
		SiteAdmin         bool   `json:"site_admin,omitempty"`
		StarredAt         string `json:"starred_at,omitempty"`
		StarredUrl        string `json:"starred_url,omitempty"`
		SubscriptionsUrl  string `json:"subscriptions_url,omitempty"`
		Type              string `json:"type,omitempty"`
		Url               string `json:"url,omitempty"`
	} `json:"user,omitempty"`
}

/*
CheckAuthorizationResponse is a response for CheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type CheckAuthorizationResponse struct {
	requests.Response
	request *CheckAuthorizationReq
	Data    CheckAuthorizationResponseBody
}

/*
CheckToken performs requests for "apps/check-token"

Check a token.

  POST /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
func CheckToken(ctx context.Context, req *CheckTokenReq, opt ...requests.Option) (*CheckTokenResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckTokenReq)
	}
	resp := &CheckTokenResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckToken performs requests for "apps/check-token"

Check a token.

  POST /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
func (c Client) CheckToken(ctx context.Context, req *CheckTokenReq, opt ...requests.Option) (*CheckTokenResponse, error) {
	return CheckToken(ctx, req, append(c, opt...)...)
}

/*
CheckTokenReq is request data for Client.CheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type CheckTokenReq struct {
	_url        string
	ClientId    string
	RequestBody CheckTokenReqBody
}

// HTTPRequest builds an *http.Request
func (r *CheckTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "apps/check-token",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/token", r.ClientId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckTokenReq) Rel(link string, resp *CheckTokenResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckTokenReqBody is a request body for apps/check-token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type CheckTokenReqBody struct {

	// The access_token of the OAuth application.
	AccessToken *string `json:"access_token"`
}

/*
CheckTokenResponse is a response for CheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type CheckTokenResponse struct {
	requests.Response
	request *CheckTokenReq
	Data    components.Authorization
}

/*
CreateContentAttachment performs requests for "apps/create-content-attachment"

Create a content attachment.

  POST /content_references/{content_reference_id}/attachments

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
func CreateContentAttachment(ctx context.Context, req *CreateContentAttachmentReq, opt ...requests.Option) (*CreateContentAttachmentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateContentAttachmentReq)
	}
	resp := &CreateContentAttachmentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ContentReferenceAttachment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateContentAttachment performs requests for "apps/create-content-attachment"

Create a content attachment.

  POST /content_references/{content_reference_id}/attachments

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
func (c Client) CreateContentAttachment(ctx context.Context, req *CreateContentAttachmentReq, opt ...requests.Option) (*CreateContentAttachmentResponse, error) {
	return CreateContentAttachment(ctx, req, append(c, opt...)...)
}

/*
CreateContentAttachmentReq is request data for Client.CreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type CreateContentAttachmentReq struct {
	_url string

	// content_reference_id parameter
	ContentReferenceId int64
	RequestBody        CreateContentAttachmentReqBody

	/*
	To access the Content Attachments API during the preview period, you must set
	this to true.
	*/
	CorsairPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateContentAttachmentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateContentAttachmentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"corsair"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "apps/create-content-attachment",
		Previews:         map[string]bool{"corsair": r.CorsairPreview},
		RequiredPreviews: []string{"corsair"},
		URLPath:          fmt.Sprintf("/content_references/%v/attachments", r.ContentReferenceId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateContentAttachmentReq) Rel(link string, resp *CreateContentAttachmentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateContentAttachmentReqBody is a request body for apps/create-content-attachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type CreateContentAttachmentReqBody struct {

	// The body of the attachment
	Body *string `json:"body"`

	// The title of the attachment
	Title *string `json:"title"`
}

/*
CreateContentAttachmentResponse is a response for CreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type CreateContentAttachmentResponse struct {
	requests.Response
	request *CreateContentAttachmentReq
	Data    components.ContentReferenceAttachment
}

/*
CreateFromManifest performs requests for "apps/create-from-manifest"

Create a GitHub App from a manifest.

  POST /app-manifests/{code}/conversions

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
func CreateFromManifest(ctx context.Context, req *CreateFromManifestReq, opt ...requests.Option) (*CreateFromManifestResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateFromManifestReq)
	}
	resp := &CreateFromManifestResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = CreateFromManifestResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateFromManifest performs requests for "apps/create-from-manifest"

Create a GitHub App from a manifest.

  POST /app-manifests/{code}/conversions

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
func (c Client) CreateFromManifest(ctx context.Context, req *CreateFromManifestReq, opt ...requests.Option) (*CreateFromManifestResponse, error) {
	return CreateFromManifest(ctx, req, append(c, opt...)...)
}

/*
CreateFromManifestReq is request data for Client.CreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type CreateFromManifestReq struct {
	_url string

	// code parameter
	Code string
}

// HTTPRequest builds an *http.Request
func (r *CreateFromManifestReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateFromManifestReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{201},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "POST",
		OperationID:      "apps/create-from-manifest",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/app-manifests/%v/conversions", r.Code),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateFromManifestReq) Rel(link string, resp *CreateFromManifestResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateFromManifestResponseBody is a response body for CreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type CreateFromManifestResponseBody struct {
	ClientId     string `json:"client_id,omitempty"`
	ClientSecret string `json:"client_secret,omitempty"`
	CreatedAt    string `json:"created_at,omitempty"`
	Description  string `json:"description,omitempty"`

	// The list of events for the GitHub app
	Events      []string `json:"events,omitempty"`
	ExternalUrl string   `json:"external_url,omitempty"`
	HtmlUrl     string   `json:"html_url,omitempty"`

	// Unique identifier of the GitHub app
	Id int64 `json:"id,omitempty"`

	// The number of installations associated with the GitHub app
	InstallationsCount int64 `json:"installations_count,omitempty"`

	// The name of the GitHub app
	Name   string `json:"name,omitempty"`
	NodeId string `json:"node_id,omitempty"`
	Owner  struct {
		AvatarUrl         string `json:"avatar_url,omitempty"`
		EventsUrl         string `json:"events_url,omitempty"`
		FollowersUrl      string `json:"followers_url,omitempty"`
		FollowingUrl      string `json:"following_url,omitempty"`
		GistsUrl          string `json:"gists_url,omitempty"`
		GravatarId        string `json:"gravatar_id,omitempty"`
		HtmlUrl           string `json:"html_url,omitempty"`
		Id                int64  `json:"id,omitempty"`
		Login             string `json:"login,omitempty"`
		NodeId            string `json:"node_id,omitempty"`
		OrganizationsUrl  string `json:"organizations_url,omitempty"`
		ReceivedEventsUrl string `json:"received_events_url,omitempty"`
		ReposUrl          string `json:"repos_url,omitempty"`
		SiteAdmin         bool   `json:"site_admin,omitempty"`
		StarredAt         string `json:"starred_at,omitempty"`
		StarredUrl        string `json:"starred_url,omitempty"`
		SubscriptionsUrl  string `json:"subscriptions_url,omitempty"`
		Type              string `json:"type,omitempty"`
		Url               string `json:"url,omitempty"`
	} `json:"owner,omitempty"`
	Pem string `json:"pem,omitempty"`

	// The set of permissions for the GitHub app
	Permissions map[string]string `json:"permissions,omitempty"`

	// The slug name of the GitHub app
	Slug          string `json:"slug,omitempty"`
	UpdatedAt     string `json:"updated_at,omitempty"`
	WebhookSecret string `json:"webhook_secret,omitempty"`
}

/*
CreateFromManifestResponse is a response for CreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type CreateFromManifestResponse struct {
	requests.Response
	request *CreateFromManifestReq
	Data    CreateFromManifestResponseBody
}

/*
CreateInstallationAccessToken performs requests for "apps/create-installation-access-token"

Create an installation access token for an app.

  POST /app/installations/{installation_id}/access_tokens

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
func CreateInstallationAccessToken(ctx context.Context, req *CreateInstallationAccessTokenReq, opt ...requests.Option) (*CreateInstallationAccessTokenResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateInstallationAccessTokenReq)
	}
	resp := &CreateInstallationAccessTokenResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.InstallationToken{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateInstallationAccessToken performs requests for "apps/create-installation-access-token"

Create an installation access token for an app.

  POST /app/installations/{installation_id}/access_tokens

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
func (c Client) CreateInstallationAccessToken(ctx context.Context, req *CreateInstallationAccessTokenReq, opt ...requests.Option) (*CreateInstallationAccessTokenResponse, error) {
	return CreateInstallationAccessToken(ctx, req, append(c, opt...)...)
}

/*
CreateInstallationAccessTokenReq is request data for Client.CreateInstallationAccessToken

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
type CreateInstallationAccessTokenReq struct {
	_url string

	// installation_id parameter
	InstallationId int64
	RequestBody    CreateInstallationAccessTokenReqBody

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateInstallationAccessTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateInstallationAccessTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "apps/create-installation-access-token",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app/installations/%v/access_tokens", r.InstallationId),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateInstallationAccessTokenReq) Rel(link string, resp *CreateInstallationAccessTokenResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateInstallationAccessTokenReqBodyPermissions is a value for CreateInstallationAccessTokenReqBody's Permissions field
type CreateInstallationAccessTokenReqBodyPermissions map[string]string

/*
CreateInstallationAccessTokenReqBody is a request body for apps/create-installation-access-token

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
type CreateInstallationAccessTokenReqBody struct {
	Permissions map[string]string `json:"permissions,omitempty"`

	// List of repository names that the token should have access to
	Repositories []string `json:"repositories,omitempty"`

	// List of repository IDs that the token should have access to
	RepositoryIds []int64 `json:"repository_ids,omitempty"`
}

/*
CreateInstallationAccessTokenResponse is a response for CreateInstallationAccessToken

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
type CreateInstallationAccessTokenResponse struct {
	requests.Response
	request *CreateInstallationAccessTokenReq
	Data    components.InstallationToken
}

/*
DeleteAuthorization performs requests for "apps/delete-authorization"

Delete an app authorization.

  DELETE /applications/{client_id}/grant

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
func DeleteAuthorization(ctx context.Context, req *DeleteAuthorizationReq, opt ...requests.Option) (*DeleteAuthorizationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteAuthorizationReq)
	}
	resp := &DeleteAuthorizationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteAuthorization performs requests for "apps/delete-authorization"

Delete an app authorization.

  DELETE /applications/{client_id}/grant

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
func (c Client) DeleteAuthorization(ctx context.Context, req *DeleteAuthorizationReq, opt ...requests.Option) (*DeleteAuthorizationResponse, error) {
	return DeleteAuthorization(ctx, req, append(c, opt...)...)
}

/*
DeleteAuthorizationReq is request data for Client.DeleteAuthorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type DeleteAuthorizationReq struct {
	_url        string
	ClientId    string
	RequestBody DeleteAuthorizationReqBody
}

// HTTPRequest builds an *http.Request
func (r *DeleteAuthorizationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": internal.String("application/json")},
		Method:           "DELETE",
		OperationID:      "apps/delete-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/grant", r.ClientId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteAuthorizationReq) Rel(link string, resp *DeleteAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteAuthorizationReqBody is a request body for apps/delete-authorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type DeleteAuthorizationReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
DeleteAuthorizationResponse is a response for DeleteAuthorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type DeleteAuthorizationResponse struct {
	requests.Response
	request *DeleteAuthorizationReq
}

/*
DeleteInstallation performs requests for "apps/delete-installation"

Delete an installation for the authenticated app.

  DELETE /app/installations/{installation_id}

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
func DeleteInstallation(ctx context.Context, req *DeleteInstallationReq, opt ...requests.Option) (*DeleteInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteInstallationReq)
	}
	resp := &DeleteInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteInstallation performs requests for "apps/delete-installation"

Delete an installation for the authenticated app.

  DELETE /app/installations/{installation_id}

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
func (c Client) DeleteInstallation(ctx context.Context, req *DeleteInstallationReq, opt ...requests.Option) (*DeleteInstallationResponse, error) {
	return DeleteInstallation(ctx, req, append(c, opt...)...)
}

/*
DeleteInstallationReq is request data for Client.DeleteInstallation

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
type DeleteInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "apps/delete-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app/installations/%v", r.InstallationId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteInstallationReq) Rel(link string, resp *DeleteInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteInstallationResponse is a response for DeleteInstallation

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
type DeleteInstallationResponse struct {
	requests.Response
	request *DeleteInstallationReq
	Data    bool
}

/*
DeleteToken performs requests for "apps/delete-token"

Delete an app token.

  DELETE /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
func DeleteToken(ctx context.Context, req *DeleteTokenReq, opt ...requests.Option) (*DeleteTokenResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteTokenReq)
	}
	resp := &DeleteTokenResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteToken performs requests for "apps/delete-token"

Delete an app token.

  DELETE /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
func (c Client) DeleteToken(ctx context.Context, req *DeleteTokenReq, opt ...requests.Option) (*DeleteTokenResponse, error) {
	return DeleteToken(ctx, req, append(c, opt...)...)
}

/*
DeleteTokenReq is request data for Client.DeleteToken

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type DeleteTokenReq struct {
	_url        string
	ClientId    string
	RequestBody DeleteTokenReqBody
}

// HTTPRequest builds an *http.Request
func (r *DeleteTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": internal.String("application/json")},
		Method:           "DELETE",
		OperationID:      "apps/delete-token",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/token", r.ClientId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteTokenReq) Rel(link string, resp *DeleteTokenResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteTokenReqBody is a request body for apps/delete-token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type DeleteTokenReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
DeleteTokenResponse is a response for DeleteToken

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type DeleteTokenResponse struct {
	requests.Response
	request *DeleteTokenReq
}

/*
GetAuthenticated performs requests for "apps/get-authenticated"

Get the authenticated app.

  GET /app

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
func GetAuthenticated(ctx context.Context, req *GetAuthenticatedReq, opt ...requests.Option) (*GetAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetAuthenticatedReq)
	}
	resp := &GetAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Integration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetAuthenticated performs requests for "apps/get-authenticated"

Get the authenticated app.

  GET /app

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
func (c Client) GetAuthenticated(ctx context.Context, req *GetAuthenticatedReq, opt ...requests.Option) (*GetAuthenticatedResponse, error) {
	return GetAuthenticated(ctx, req, append(c, opt...)...)
}

/*
GetAuthenticatedReq is request data for Client.GetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
type GetAuthenticatedReq struct {
	_url string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-authenticated",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app"),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetAuthenticatedReq) Rel(link string, resp *GetAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetAuthenticatedResponse is a response for GetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
type GetAuthenticatedResponse struct {
	requests.Response
	request *GetAuthenticatedReq
	Data    components.Integration
}

/*
GetBySlug performs requests for "apps/get-by-slug"

Get an app.

  GET /apps/{app_slug}

https://developer.github.com/v3/apps/#get-an-app
*/
func GetBySlug(ctx context.Context, req *GetBySlugReq, opt ...requests.Option) (*GetBySlugResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetBySlugReq)
	}
	resp := &GetBySlugResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Integration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetBySlug performs requests for "apps/get-by-slug"

Get an app.

  GET /apps/{app_slug}

https://developer.github.com/v3/apps/#get-an-app
*/
func (c Client) GetBySlug(ctx context.Context, req *GetBySlugReq, opt ...requests.Option) (*GetBySlugResponse, error) {
	return GetBySlug(ctx, req, append(c, opt...)...)
}

/*
GetBySlugReq is request data for Client.GetBySlug

https://developer.github.com/v3/apps/#get-an-app
*/
type GetBySlugReq struct {
	_url string

	// app_slug parameter
	AppSlug string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetBySlugReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetBySlugReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-by-slug",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/apps/%v", r.AppSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetBySlugReq) Rel(link string, resp *GetBySlugResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetBySlugResponse is a response for GetBySlug

https://developer.github.com/v3/apps/#get-an-app
*/
type GetBySlugResponse struct {
	requests.Response
	request *GetBySlugReq
	Data    components.Integration
}

/*
GetInstallation performs requests for "apps/get-installation"

Get an installation for the authenticated app.

  GET /app/installations/{installation_id}

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
func GetInstallation(ctx context.Context, req *GetInstallationReq, opt ...requests.Option) (*GetInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetInstallationReq)
	}
	resp := &GetInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Installation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetInstallation performs requests for "apps/get-installation"

Get an installation for the authenticated app.

  GET /app/installations/{installation_id}

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
func (c Client) GetInstallation(ctx context.Context, req *GetInstallationReq, opt ...requests.Option) (*GetInstallationResponse, error) {
	return GetInstallation(ctx, req, append(c, opt...)...)
}

/*
GetInstallationReq is request data for Client.GetInstallation

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
type GetInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app/installations/%v", r.InstallationId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetInstallationReq) Rel(link string, resp *GetInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetInstallationResponse is a response for GetInstallation

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
type GetInstallationResponse struct {
	requests.Response
	request *GetInstallationReq
	Data    components.Installation
}

/*
GetOrgInstallation performs requests for "apps/get-org-installation"

Get an organization installation for the authenticated app.

  GET /orgs/{org}/installation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
func GetOrgInstallation(ctx context.Context, req *GetOrgInstallationReq, opt ...requests.Option) (*GetOrgInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetOrgInstallationReq)
	}
	resp := &GetOrgInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Installation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetOrgInstallation performs requests for "apps/get-org-installation"

Get an organization installation for the authenticated app.

  GET /orgs/{org}/installation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
func (c Client) GetOrgInstallation(ctx context.Context, req *GetOrgInstallationReq, opt ...requests.Option) (*GetOrgInstallationResponse, error) {
	return GetOrgInstallation(ctx, req, append(c, opt...)...)
}

/*
GetOrgInstallationReq is request data for Client.GetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
type GetOrgInstallationReq struct {
	_url string
	Org  string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetOrgInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetOrgInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-org-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/orgs/%v/installation", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetOrgInstallationReq) Rel(link string, resp *GetOrgInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetOrgInstallationResponse is a response for GetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
type GetOrgInstallationResponse struct {
	requests.Response
	request *GetOrgInstallationReq
	Data    components.Installation
}

/*
GetRepoInstallation performs requests for "apps/get-repo-installation"

Get a repository installation for the authenticated app.

  GET /repos/{owner}/{repo}/installation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
func GetRepoInstallation(ctx context.Context, req *GetRepoInstallationReq, opt ...requests.Option) (*GetRepoInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetRepoInstallationReq)
	}
	resp := &GetRepoInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Installation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetRepoInstallation performs requests for "apps/get-repo-installation"

Get a repository installation for the authenticated app.

  GET /repos/{owner}/{repo}/installation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
func (c Client) GetRepoInstallation(ctx context.Context, req *GetRepoInstallationReq, opt ...requests.Option) (*GetRepoInstallationResponse, error) {
	return GetRepoInstallation(ctx, req, append(c, opt...)...)
}

/*
GetRepoInstallationReq is request data for Client.GetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
type GetRepoInstallationReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetRepoInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetRepoInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-repo-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/installation", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 301},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetRepoInstallationReq) Rel(link string, resp *GetRepoInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetRepoInstallationResponse is a response for GetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
type GetRepoInstallationResponse struct {
	requests.Response
	request *GetRepoInstallationReq
	Data    components.Installation
}

/*
GetSubscriptionPlanForAccount performs requests for "apps/get-subscription-plan-for-account"

Get a subscription plan for an account.

  GET /marketplace_listing/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
func GetSubscriptionPlanForAccount(ctx context.Context, req *GetSubscriptionPlanForAccountReq, opt ...requests.Option) (*GetSubscriptionPlanForAccountResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetSubscriptionPlanForAccountReq)
	}
	resp := &GetSubscriptionPlanForAccountResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.MarketplacePurchase{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetSubscriptionPlanForAccount performs requests for "apps/get-subscription-plan-for-account"

Get a subscription plan for an account.

  GET /marketplace_listing/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
func (c Client) GetSubscriptionPlanForAccount(ctx context.Context, req *GetSubscriptionPlanForAccountReq, opt ...requests.Option) (*GetSubscriptionPlanForAccountResponse, error) {
	return GetSubscriptionPlanForAccount(ctx, req, append(c, opt...)...)
}

/*
GetSubscriptionPlanForAccountReq is request data for Client.GetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type GetSubscriptionPlanForAccountReq struct {
	_url string

	// account_id parameter
	AccountId int64
}

// HTTPRequest builds an *http.Request
func (r *GetSubscriptionPlanForAccountReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetSubscriptionPlanForAccountReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-subscription-plan-for-account",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/marketplace_listing/accounts/%v", r.AccountId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetSubscriptionPlanForAccountReq) Rel(link string, resp *GetSubscriptionPlanForAccountResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetSubscriptionPlanForAccountResponse is a response for GetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type GetSubscriptionPlanForAccountResponse struct {
	requests.Response
	request *GetSubscriptionPlanForAccountReq
	Data    components.MarketplacePurchase
}

/*
GetSubscriptionPlanForAccountStubbed performs requests for "apps/get-subscription-plan-for-account-stubbed"

Get a subscription plan for an account (stubbed).

  GET /marketplace_listing/stubbed/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
func GetSubscriptionPlanForAccountStubbed(ctx context.Context, req *GetSubscriptionPlanForAccountStubbedReq, opt ...requests.Option) (*GetSubscriptionPlanForAccountStubbedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetSubscriptionPlanForAccountStubbedReq)
	}
	resp := &GetSubscriptionPlanForAccountStubbedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.MarketplacePurchase{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetSubscriptionPlanForAccountStubbed performs requests for "apps/get-subscription-plan-for-account-stubbed"

Get a subscription plan for an account (stubbed).

  GET /marketplace_listing/stubbed/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
func (c Client) GetSubscriptionPlanForAccountStubbed(ctx context.Context, req *GetSubscriptionPlanForAccountStubbedReq, opt ...requests.Option) (*GetSubscriptionPlanForAccountStubbedResponse, error) {
	return GetSubscriptionPlanForAccountStubbed(ctx, req, append(c, opt...)...)
}

/*
GetSubscriptionPlanForAccountStubbedReq is request data for Client.GetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type GetSubscriptionPlanForAccountStubbedReq struct {
	_url string

	// account_id parameter
	AccountId int64
}

// HTTPRequest builds an *http.Request
func (r *GetSubscriptionPlanForAccountStubbedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetSubscriptionPlanForAccountStubbedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-subscription-plan-for-account-stubbed",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/marketplace_listing/stubbed/accounts/%v", r.AccountId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetSubscriptionPlanForAccountStubbedReq) Rel(link string, resp *GetSubscriptionPlanForAccountStubbedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetSubscriptionPlanForAccountStubbedResponse is a response for GetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type GetSubscriptionPlanForAccountStubbedResponse struct {
	requests.Response
	request *GetSubscriptionPlanForAccountStubbedReq
	Data    components.MarketplacePurchase
}

/*
GetUserInstallation performs requests for "apps/get-user-installation"

Get a user installation for the authenticated app.

  GET /users/{username}/installation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
func GetUserInstallation(ctx context.Context, req *GetUserInstallationReq, opt ...requests.Option) (*GetUserInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetUserInstallationReq)
	}
	resp := &GetUserInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Installation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetUserInstallation performs requests for "apps/get-user-installation"

Get a user installation for the authenticated app.

  GET /users/{username}/installation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
func (c Client) GetUserInstallation(ctx context.Context, req *GetUserInstallationReq, opt ...requests.Option) (*GetUserInstallationResponse, error) {
	return GetUserInstallation(ctx, req, append(c, opt...)...)
}

/*
GetUserInstallationReq is request data for Client.GetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
type GetUserInstallationReq struct {
	_url     string
	Username string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetUserInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetUserInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/get-user-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/users/%v/installation", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetUserInstallationReq) Rel(link string, resp *GetUserInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetUserInstallationResponse is a response for GetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
type GetUserInstallationResponse struct {
	requests.Response
	request *GetUserInstallationReq
	Data    components.Installation
}

/*
ListAccountsForPlan performs requests for "apps/list-accounts-for-plan"

List accounts for a plan.

  GET /marketplace_listing/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
func ListAccountsForPlan(ctx context.Context, req *ListAccountsForPlanReq, opt ...requests.Option) (*ListAccountsForPlanResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListAccountsForPlanReq)
	}
	resp := &ListAccountsForPlanResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MarketplacePurchase{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListAccountsForPlan performs requests for "apps/list-accounts-for-plan"

List accounts for a plan.

  GET /marketplace_listing/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
func (c Client) ListAccountsForPlan(ctx context.Context, req *ListAccountsForPlanReq, opt ...requests.Option) (*ListAccountsForPlanResponse, error) {
	return ListAccountsForPlan(ctx, req, append(c, opt...)...)
}

/*
ListAccountsForPlanReq is request data for Client.ListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type ListAccountsForPlanReq struct {
	_url string

	// plan_id parameter
	PlanId int64

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListAccountsForPlanReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListAccountsForPlanReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-accounts-for-plan",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/marketplace_listing/plans/%v/accounts", r.PlanId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListAccountsForPlanReq) Rel(link string, resp *ListAccountsForPlanResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListAccountsForPlanResponse is a response for ListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type ListAccountsForPlanResponse struct {
	requests.Response
	request *ListAccountsForPlanReq
	Data    []components.MarketplacePurchase
}

/*
ListAccountsForPlanStubbed performs requests for "apps/list-accounts-for-plan-stubbed"

List accounts for a plan (stubbed).

  GET /marketplace_listing/stubbed/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
func ListAccountsForPlanStubbed(ctx context.Context, req *ListAccountsForPlanStubbedReq, opt ...requests.Option) (*ListAccountsForPlanStubbedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListAccountsForPlanStubbedReq)
	}
	resp := &ListAccountsForPlanStubbedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MarketplacePurchase{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListAccountsForPlanStubbed performs requests for "apps/list-accounts-for-plan-stubbed"

List accounts for a plan (stubbed).

  GET /marketplace_listing/stubbed/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
func (c Client) ListAccountsForPlanStubbed(ctx context.Context, req *ListAccountsForPlanStubbedReq, opt ...requests.Option) (*ListAccountsForPlanStubbedResponse, error) {
	return ListAccountsForPlanStubbed(ctx, req, append(c, opt...)...)
}

/*
ListAccountsForPlanStubbedReq is request data for Client.ListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type ListAccountsForPlanStubbedReq struct {
	_url string

	// plan_id parameter
	PlanId int64

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListAccountsForPlanStubbedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListAccountsForPlanStubbedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-accounts-for-plan-stubbed",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/marketplace_listing/stubbed/plans/%v/accounts", r.PlanId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListAccountsForPlanStubbedReq) Rel(link string, resp *ListAccountsForPlanStubbedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListAccountsForPlanStubbedResponse is a response for ListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type ListAccountsForPlanStubbedResponse struct {
	requests.Response
	request *ListAccountsForPlanStubbedReq
	Data    []components.MarketplacePurchase
}

/*
ListInstallationReposForAuthenticatedUser performs requests for "apps/list-installation-repos-for-authenticated-user"

List repositories accessible to the user access token.

  GET /user/installations/{installation_id}/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
func ListInstallationReposForAuthenticatedUser(ctx context.Context, req *ListInstallationReposForAuthenticatedUserReq, opt ...requests.Option) (*ListInstallationReposForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListInstallationReposForAuthenticatedUserReq)
	}
	resp := &ListInstallationReposForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ListInstallationReposForAuthenticatedUserResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListInstallationReposForAuthenticatedUser performs requests for "apps/list-installation-repos-for-authenticated-user"

List repositories accessible to the user access token.

  GET /user/installations/{installation_id}/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
func (c Client) ListInstallationReposForAuthenticatedUser(ctx context.Context, req *ListInstallationReposForAuthenticatedUserReq, opt ...requests.Option) (*ListInstallationReposForAuthenticatedUserResponse, error) {
	return ListInstallationReposForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListInstallationReposForAuthenticatedUserReq is request data for Client.ListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
type ListInstallationReposForAuthenticatedUserReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListInstallationReposForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListInstallationReposForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man", "mercy"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": internal.String("application/json")},
		Method:       "GET",
		OperationID:  "apps/list-installation-repos-for-authenticated-user",
		Previews: map[string]bool{
			"machine-man": r.MachineManPreview,
			"mercy":       r.MercyPreview,
		},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/user/installations/%v/repositories", r.InstallationId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInstallationReposForAuthenticatedUserReq) Rel(link string, resp *ListInstallationReposForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInstallationReposForAuthenticatedUserResponseBody is a response body for ListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
type ListInstallationReposForAuthenticatedUserResponseBody struct {
	Repositories        []components.Repository `json:"repositories,omitempty"`
	RepositorySelection string                  `json:"repository_selection,omitempty"`
	TotalCount          int64                   `json:"total_count,omitempty"`
}

/*
ListInstallationReposForAuthenticatedUserResponse is a response for ListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
type ListInstallationReposForAuthenticatedUserResponse struct {
	requests.Response
	request *ListInstallationReposForAuthenticatedUserReq
	Data    ListInstallationReposForAuthenticatedUserResponseBody
}

/*
ListInstallations performs requests for "apps/list-installations"

List installations for the authenticated app.

  GET /app/installations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
func ListInstallations(ctx context.Context, req *ListInstallationsReq, opt ...requests.Option) (*ListInstallationsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListInstallationsReq)
	}
	resp := &ListInstallationsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Installation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListInstallations performs requests for "apps/list-installations"

List installations for the authenticated app.

  GET /app/installations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
func (c Client) ListInstallations(ctx context.Context, req *ListInstallationsReq, opt ...requests.Option) (*ListInstallationsResponse, error) {
	return ListInstallations(ctx, req, append(c, opt...)...)
}

/*
ListInstallationsReq is request data for Client.ListInstallations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
type ListInstallationsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since    *string
	Outdated *string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListInstallationsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListInstallationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Outdated != nil {
		query.Set("outdated", *r.Outdated)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-installations",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app/installations"),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInstallationsReq) Rel(link string, resp *ListInstallationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInstallationsResponse is a response for ListInstallations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
type ListInstallationsResponse struct {
	requests.Response
	request *ListInstallationsReq
	Data    []components.Installation
}

/*
ListInstallationsForAuthenticatedUser performs requests for "apps/list-installations-for-authenticated-user"

List app installations accessible to the user access token.

  GET /user/installations

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
func ListInstallationsForAuthenticatedUser(ctx context.Context, req *ListInstallationsForAuthenticatedUserReq, opt ...requests.Option) (*ListInstallationsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListInstallationsForAuthenticatedUserReq)
	}
	resp := &ListInstallationsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ListInstallationsForAuthenticatedUserResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListInstallationsForAuthenticatedUser performs requests for "apps/list-installations-for-authenticated-user"

List app installations accessible to the user access token.

  GET /user/installations

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
func (c Client) ListInstallationsForAuthenticatedUser(ctx context.Context, req *ListInstallationsForAuthenticatedUserReq, opt ...requests.Option) (*ListInstallationsForAuthenticatedUserResponse, error) {
	return ListInstallationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListInstallationsForAuthenticatedUserReq is request data for Client.ListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
type ListInstallationsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListInstallationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListInstallationsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-installations-for-authenticated-user",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/user/installations"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInstallationsForAuthenticatedUserReq) Rel(link string, resp *ListInstallationsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInstallationsForAuthenticatedUserResponseBody is a response body for ListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
type ListInstallationsForAuthenticatedUserResponseBody struct {
	Installations []components.Installation `json:"installations,omitempty"`
	TotalCount    int64                     `json:"total_count,omitempty"`
}

/*
ListInstallationsForAuthenticatedUserResponse is a response for ListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
type ListInstallationsForAuthenticatedUserResponse struct {
	requests.Response
	request *ListInstallationsForAuthenticatedUserReq
	Data    ListInstallationsForAuthenticatedUserResponseBody
}

/*
ListPlans performs requests for "apps/list-plans"

List plans.

  GET /marketplace_listing/plans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
func ListPlans(ctx context.Context, req *ListPlansReq, opt ...requests.Option) (*ListPlansResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPlansReq)
	}
	resp := &ListPlansResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MarketplaceListingPlan{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPlans performs requests for "apps/list-plans"

List plans.

  GET /marketplace_listing/plans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
func (c Client) ListPlans(ctx context.Context, req *ListPlansReq, opt ...requests.Option) (*ListPlansResponse, error) {
	return ListPlans(ctx, req, append(c, opt...)...)
}

/*
ListPlansReq is request data for Client.ListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type ListPlansReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPlansReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPlansReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-plans",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/marketplace_listing/plans"),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPlansReq) Rel(link string, resp *ListPlansResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPlansResponse is a response for ListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type ListPlansResponse struct {
	requests.Response
	request *ListPlansReq
	Data    []components.MarketplaceListingPlan
}

/*
ListPlansStubbed performs requests for "apps/list-plans-stubbed"

List plans (stubbed).

  GET /marketplace_listing/stubbed/plans

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
func ListPlansStubbed(ctx context.Context, req *ListPlansStubbedReq, opt ...requests.Option) (*ListPlansStubbedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPlansStubbedReq)
	}
	resp := &ListPlansStubbedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MarketplaceListingPlan{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPlansStubbed performs requests for "apps/list-plans-stubbed"

List plans (stubbed).

  GET /marketplace_listing/stubbed/plans

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
func (c Client) ListPlansStubbed(ctx context.Context, req *ListPlansStubbedReq, opt ...requests.Option) (*ListPlansStubbedResponse, error) {
	return ListPlansStubbed(ctx, req, append(c, opt...)...)
}

/*
ListPlansStubbedReq is request data for Client.ListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type ListPlansStubbedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPlansStubbedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPlansStubbedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-plans-stubbed",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/marketplace_listing/stubbed/plans"),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPlansStubbedReq) Rel(link string, resp *ListPlansStubbedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPlansStubbedResponse is a response for ListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type ListPlansStubbedResponse struct {
	requests.Response
	request *ListPlansStubbedReq
	Data    []components.MarketplaceListingPlan
}

/*
ListReposAccessibleToInstallation performs requests for "apps/list-repos-accessible-to-installation"

List repositories accessible to the app installation.

  GET /installation/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
func ListReposAccessibleToInstallation(ctx context.Context, req *ListReposAccessibleToInstallationReq, opt ...requests.Option) (*ListReposAccessibleToInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposAccessibleToInstallationReq)
	}
	resp := &ListReposAccessibleToInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ListReposAccessibleToInstallationResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposAccessibleToInstallation performs requests for "apps/list-repos-accessible-to-installation"

List repositories accessible to the app installation.

  GET /installation/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
func (c Client) ListReposAccessibleToInstallation(ctx context.Context, req *ListReposAccessibleToInstallationReq, opt ...requests.Option) (*ListReposAccessibleToInstallationResponse, error) {
	return ListReposAccessibleToInstallation(ctx, req, append(c, opt...)...)
}

/*
ListReposAccessibleToInstallationReq is request data for Client.ListReposAccessibleToInstallation

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
type ListReposAccessibleToInstallationReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListReposAccessibleToInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposAccessibleToInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man", "mercy"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": internal.String("application/json")},
		Method:       "GET",
		OperationID:  "apps/list-repos-accessible-to-installation",
		Previews: map[string]bool{
			"machine-man": r.MachineManPreview,
			"mercy":       r.MercyPreview,
		},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/installation/repositories"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposAccessibleToInstallationReq) Rel(link string, resp *ListReposAccessibleToInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposAccessibleToInstallationResponseBody is a response body for ListReposAccessibleToInstallation

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
type ListReposAccessibleToInstallationResponseBody struct {
	Repositories        []components.Repository `json:"repositories,omitempty"`
	RepositorySelection string                  `json:"repository_selection,omitempty"`
	TotalCount          int64                   `json:"total_count,omitempty"`
}

/*
ListReposAccessibleToInstallationResponse is a response for ListReposAccessibleToInstallation

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
type ListReposAccessibleToInstallationResponse struct {
	requests.Response
	request *ListReposAccessibleToInstallationReq
	Data    ListReposAccessibleToInstallationResponseBody
}

/*
ListSubscriptionsForAuthenticatedUser performs requests for "apps/list-subscriptions-for-authenticated-user"

List subscriptions for the authenticated user.

  GET /user/marketplace_purchases

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
func ListSubscriptionsForAuthenticatedUser(ctx context.Context, req *ListSubscriptionsForAuthenticatedUserReq, opt ...requests.Option) (*ListSubscriptionsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListSubscriptionsForAuthenticatedUserReq)
	}
	resp := &ListSubscriptionsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.UserMarketplacePurchase{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListSubscriptionsForAuthenticatedUser performs requests for "apps/list-subscriptions-for-authenticated-user"

List subscriptions for the authenticated user.

  GET /user/marketplace_purchases

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
func (c Client) ListSubscriptionsForAuthenticatedUser(ctx context.Context, req *ListSubscriptionsForAuthenticatedUserReq, opt ...requests.Option) (*ListSubscriptionsForAuthenticatedUserResponse, error) {
	return ListSubscriptionsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListSubscriptionsForAuthenticatedUserReq is request data for Client.ListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type ListSubscriptionsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListSubscriptionsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListSubscriptionsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-subscriptions-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/marketplace_purchases"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListSubscriptionsForAuthenticatedUserReq) Rel(link string, resp *ListSubscriptionsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListSubscriptionsForAuthenticatedUserResponse is a response for ListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type ListSubscriptionsForAuthenticatedUserResponse struct {
	requests.Response
	request *ListSubscriptionsForAuthenticatedUserReq
	Data    []components.UserMarketplacePurchase
}

/*
ListSubscriptionsForAuthenticatedUserStubbed performs requests for "apps/list-subscriptions-for-authenticated-user-stubbed"

List subscriptions for the authenticated user (stubbed).

  GET /user/marketplace_purchases/stubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
func ListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, req *ListSubscriptionsForAuthenticatedUserStubbedReq, opt ...requests.Option) (*ListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListSubscriptionsForAuthenticatedUserStubbedReq)
	}
	resp := &ListSubscriptionsForAuthenticatedUserStubbedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.UserMarketplacePurchase{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListSubscriptionsForAuthenticatedUserStubbed performs requests for "apps/list-subscriptions-for-authenticated-user-stubbed"

List subscriptions for the authenticated user (stubbed).

  GET /user/marketplace_purchases/stubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
func (c Client) ListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, req *ListSubscriptionsForAuthenticatedUserStubbedReq, opt ...requests.Option) (*ListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	return ListSubscriptionsForAuthenticatedUserStubbed(ctx, req, append(c, opt...)...)
}

/*
ListSubscriptionsForAuthenticatedUserStubbedReq is request data for Client.ListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type ListSubscriptionsForAuthenticatedUserStubbedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListSubscriptionsForAuthenticatedUserStubbedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListSubscriptionsForAuthenticatedUserStubbedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "apps/list-subscriptions-for-authenticated-user-stubbed",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/marketplace_purchases/stubbed"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListSubscriptionsForAuthenticatedUserStubbedReq) Rel(link string, resp *ListSubscriptionsForAuthenticatedUserStubbedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListSubscriptionsForAuthenticatedUserStubbedResponse is a response for ListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type ListSubscriptionsForAuthenticatedUserStubbedResponse struct {
	requests.Response
	request *ListSubscriptionsForAuthenticatedUserStubbedReq
	Data    []components.UserMarketplacePurchase
}

/*
RemoveRepoFromInstallation performs requests for "apps/remove-repo-from-installation"

Remove a repository from an app installation.

  DELETE /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
func RemoveRepoFromInstallation(ctx context.Context, req *RemoveRepoFromInstallationReq, opt ...requests.Option) (*RemoveRepoFromInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveRepoFromInstallationReq)
	}
	resp := &RemoveRepoFromInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveRepoFromInstallation performs requests for "apps/remove-repo-from-installation"

Remove a repository from an app installation.

  DELETE /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
func (c Client) RemoveRepoFromInstallation(ctx context.Context, req *RemoveRepoFromInstallationReq, opt ...requests.Option) (*RemoveRepoFromInstallationResponse, error) {
	return RemoveRepoFromInstallation(ctx, req, append(c, opt...)...)
}

/*
RemoveRepoFromInstallationReq is request data for Client.RemoveRepoFromInstallation

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
type RemoveRepoFromInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	// repository_id parameter
	RepositoryId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *RemoveRepoFromInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveRepoFromInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "apps/remove-repo-from-installation",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveRepoFromInstallationReq) Rel(link string, resp *RemoveRepoFromInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveRepoFromInstallationResponse is a response for RemoveRepoFromInstallation

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
type RemoveRepoFromInstallationResponse struct {
	requests.Response
	request *RemoveRepoFromInstallationReq
}

/*
ResetAuthorization performs requests for "apps/reset-authorization"

Reset an authorization.

  POST /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
func ResetAuthorization(ctx context.Context, req *ResetAuthorizationReq, opt ...requests.Option) (*ResetAuthorizationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ResetAuthorizationReq)
	}
	resp := &ResetAuthorizationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ResetAuthorization performs requests for "apps/reset-authorization"

Reset an authorization.

  POST /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
func (c Client) ResetAuthorization(ctx context.Context, req *ResetAuthorizationReq, opt ...requests.Option) (*ResetAuthorizationResponse, error) {
	return ResetAuthorization(ctx, req, append(c, opt...)...)
}

/*
ResetAuthorizationReq is request data for Client.ResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type ResetAuthorizationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request
func (r *ResetAuthorizationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ResetAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "POST",
		OperationID:      "apps/reset-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ResetAuthorizationReq) Rel(link string, resp *ResetAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ResetAuthorizationResponse is a response for ResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type ResetAuthorizationResponse struct {
	requests.Response
	request *ResetAuthorizationReq
	Data    components.Authorization
}

/*
ResetToken performs requests for "apps/reset-token"

Reset a token.

  PATCH /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
func ResetToken(ctx context.Context, req *ResetTokenReq, opt ...requests.Option) (*ResetTokenResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ResetTokenReq)
	}
	resp := &ResetTokenResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ResetToken performs requests for "apps/reset-token"

Reset a token.

  PATCH /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
func (c Client) ResetToken(ctx context.Context, req *ResetTokenReq, opt ...requests.Option) (*ResetTokenResponse, error) {
	return ResetToken(ctx, req, append(c, opt...)...)
}

/*
ResetTokenReq is request data for Client.ResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type ResetTokenReq struct {
	_url        string
	ClientId    string
	RequestBody ResetTokenReqBody
}

// HTTPRequest builds an *http.Request
func (r *ResetTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ResetTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "apps/reset-token",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/token", r.ClientId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ResetTokenReq) Rel(link string, resp *ResetTokenResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ResetTokenReqBody is a request body for apps/reset-token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type ResetTokenReqBody struct {

	// The access_token of the OAuth application.
	AccessToken *string `json:"access_token"`
}

/*
ResetTokenResponse is a response for ResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type ResetTokenResponse struct {
	requests.Response
	request *ResetTokenReq
	Data    components.Authorization
}

/*
RevokeAuthorizationForApplication performs requests for "apps/revoke-authorization-for-application"

Revoke an authorization for an application.

  DELETE /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
func RevokeAuthorizationForApplication(ctx context.Context, req *RevokeAuthorizationForApplicationReq, opt ...requests.Option) (*RevokeAuthorizationForApplicationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RevokeAuthorizationForApplicationReq)
	}
	resp := &RevokeAuthorizationForApplicationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RevokeAuthorizationForApplication performs requests for "apps/revoke-authorization-for-application"

Revoke an authorization for an application.

  DELETE /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
func (c Client) RevokeAuthorizationForApplication(ctx context.Context, req *RevokeAuthorizationForApplicationReq, opt ...requests.Option) (*RevokeAuthorizationForApplicationResponse, error) {
	return RevokeAuthorizationForApplication(ctx, req, append(c, opt...)...)
}

/*
RevokeAuthorizationForApplicationReq is request data for Client.RevokeAuthorizationForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
type RevokeAuthorizationForApplicationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request
func (r *RevokeAuthorizationForApplicationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RevokeAuthorizationForApplicationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "apps/revoke-authorization-for-application",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RevokeAuthorizationForApplicationReq) Rel(link string, resp *RevokeAuthorizationForApplicationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RevokeAuthorizationForApplicationResponse is a response for RevokeAuthorizationForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
type RevokeAuthorizationForApplicationResponse struct {
	requests.Response
	request *RevokeAuthorizationForApplicationReq
}

/*
RevokeGrantForApplication performs requests for "apps/revoke-grant-for-application"

Revoke a grant for an application.

  DELETE /applications/{client_id}/grants/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
func RevokeGrantForApplication(ctx context.Context, req *RevokeGrantForApplicationReq, opt ...requests.Option) (*RevokeGrantForApplicationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RevokeGrantForApplicationReq)
	}
	resp := &RevokeGrantForApplicationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RevokeGrantForApplication performs requests for "apps/revoke-grant-for-application"

Revoke a grant for an application.

  DELETE /applications/{client_id}/grants/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
func (c Client) RevokeGrantForApplication(ctx context.Context, req *RevokeGrantForApplicationReq, opt ...requests.Option) (*RevokeGrantForApplicationResponse, error) {
	return RevokeGrantForApplication(ctx, req, append(c, opt...)...)
}

/*
RevokeGrantForApplicationReq is request data for Client.RevokeGrantForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
type RevokeGrantForApplicationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request
func (r *RevokeGrantForApplicationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RevokeGrantForApplicationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "apps/revoke-grant-for-application",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/grants/%v", r.ClientId, r.AccessToken),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RevokeGrantForApplicationReq) Rel(link string, resp *RevokeGrantForApplicationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RevokeGrantForApplicationResponse is a response for RevokeGrantForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
type RevokeGrantForApplicationResponse struct {
	requests.Response
	request *RevokeGrantForApplicationReq
}

/*
RevokeInstallationAccessToken performs requests for "apps/revoke-installation-access-token"

Revoke an installation access token.

  DELETE /installation/token

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
func RevokeInstallationAccessToken(ctx context.Context, req *RevokeInstallationAccessTokenReq, opt ...requests.Option) (*RevokeInstallationAccessTokenResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RevokeInstallationAccessTokenReq)
	}
	resp := &RevokeInstallationAccessTokenResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RevokeInstallationAccessToken performs requests for "apps/revoke-installation-access-token"

Revoke an installation access token.

  DELETE /installation/token

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
func (c Client) RevokeInstallationAccessToken(ctx context.Context, req *RevokeInstallationAccessTokenReq, opt ...requests.Option) (*RevokeInstallationAccessTokenResponse, error) {
	return RevokeInstallationAccessToken(ctx, req, append(c, opt...)...)
}

/*
RevokeInstallationAccessTokenReq is request data for Client.RevokeInstallationAccessToken

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
type RevokeInstallationAccessTokenReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *RevokeInstallationAccessTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RevokeInstallationAccessTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "apps/revoke-installation-access-token",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/installation/token"),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RevokeInstallationAccessTokenReq) Rel(link string, resp *RevokeInstallationAccessTokenResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RevokeInstallationAccessTokenResponse is a response for RevokeInstallationAccessToken

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
type RevokeInstallationAccessTokenResponse struct {
	requests.Response
	request *RevokeInstallationAccessTokenReq
}

/*
SuspendInstallation performs requests for "apps/suspend-installation"

Suspend an app installation.

  PUT /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
func SuspendInstallation(ctx context.Context, req *SuspendInstallationReq, opt ...requests.Option) (*SuspendInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SuspendInstallationReq)
	}
	resp := &SuspendInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SuspendInstallation performs requests for "apps/suspend-installation"

Suspend an app installation.

  PUT /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
func (c Client) SuspendInstallation(ctx context.Context, req *SuspendInstallationReq, opt ...requests.Option) (*SuspendInstallationResponse, error) {
	return SuspendInstallation(ctx, req, append(c, opt...)...)
}

/*
SuspendInstallationReq is request data for Client.SuspendInstallation

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
type SuspendInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64
}

// HTTPRequest builds an *http.Request
func (r *SuspendInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SuspendInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "apps/suspend-installation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SuspendInstallationReq) Rel(link string, resp *SuspendInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SuspendInstallationResponse is a response for SuspendInstallation

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
type SuspendInstallationResponse struct {
	requests.Response
	request *SuspendInstallationReq
	Data    bool
}

/*
UnsuspendInstallation performs requests for "apps/unsuspend-installation"

Unsuspend an app installation.

  DELETE /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
func UnsuspendInstallation(ctx context.Context, req *UnsuspendInstallationReq, opt ...requests.Option) (*UnsuspendInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnsuspendInstallationReq)
	}
	resp := &UnsuspendInstallationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UnsuspendInstallation performs requests for "apps/unsuspend-installation"

Unsuspend an app installation.

  DELETE /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
func (c Client) UnsuspendInstallation(ctx context.Context, req *UnsuspendInstallationReq, opt ...requests.Option) (*UnsuspendInstallationResponse, error) {
	return UnsuspendInstallation(ctx, req, append(c, opt...)...)
}

/*
UnsuspendInstallationReq is request data for Client.UnsuspendInstallation

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
type UnsuspendInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64
}

// HTTPRequest builds an *http.Request
func (r *UnsuspendInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnsuspendInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "apps/unsuspend-installation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnsuspendInstallationReq) Rel(link string, resp *UnsuspendInstallationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnsuspendInstallationResponse is a response for UnsuspendInstallation

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
type UnsuspendInstallationResponse struct {
	requests.Response
	request *UnsuspendInstallationReq
	Data    bool
}
