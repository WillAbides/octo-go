// Code generated by octo-go; DO NOT EDIT.

package apps

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
AddRepoToInstallation performs requests for "apps/add-repo-to-installation"

Add a repository to an app installation.

  PUT /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
func AddRepoToInstallation(ctx context.Context, req *AddRepoToInstallationReq, opt ...requests.Option) (*AddRepoToInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddRepoToInstallationReq)
	}
	resp := &AddRepoToInstallationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewAddRepoToInstallationResponse(r, opts.PreserveResponseBody())
}

// NewAddRepoToInstallationResponse builds a new *AddRepoToInstallationResponse from an *http.Response
func NewAddRepoToInstallationResponse(resp *http.Response, preserveBody bool) (*AddRepoToInstallationResponse, error) {
	var result AddRepoToInstallationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
AddRepoToInstallation performs requests for "apps/add-repo-to-installation"

Add a repository to an app installation.

  PUT /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
func (c Client) AddRepoToInstallation(ctx context.Context, req *AddRepoToInstallationReq, opt ...requests.Option) (*AddRepoToInstallationResponse, error) {
	return AddRepoToInstallation(ctx, req, append(c, opt...)...)
}

/*
AddRepoToInstallationReq is request data for Client.AddRepoToInstallation

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
type AddRepoToInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	// repository_id parameter
	RepositoryId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *AddRepoToInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddRepoToInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "apps/add-repo-to-installation",
		Previews:           map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews:   []string{"machine-man"},
		URLPath:            fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddRepoToInstallationReq) Rel(link string, resp *AddRepoToInstallationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddRepoToInstallationResponse is a response for AddRepoToInstallation

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
type AddRepoToInstallationResponse struct {
	httpResponse *http.Response
}

func (r *AddRepoToInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CheckAuthorization performs requests for "apps/check-authorization"

Check an authorization.

  GET /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
func CheckAuthorization(ctx context.Context, req *CheckAuthorizationReq, opt ...requests.Option) (*CheckAuthorizationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckAuthorizationReq)
	}
	resp := &CheckAuthorizationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckAuthorizationResponse(r, opts.PreserveResponseBody())
}

// NewCheckAuthorizationResponse builds a new *CheckAuthorizationResponse from an *http.Response
func NewCheckAuthorizationResponse(resp *http.Response, preserveBody bool) (*CheckAuthorizationResponse, error) {
	var result CheckAuthorizationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CheckAuthorization performs requests for "apps/check-authorization"

Check an authorization.

  GET /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
func (c Client) CheckAuthorization(ctx context.Context, req *CheckAuthorizationReq, opt ...requests.Option) (*CheckAuthorizationResponse, error) {
	return CheckAuthorization(ctx, req, append(c, opt...)...)
}

/*
CheckAuthorizationReq is request data for Client.CheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type CheckAuthorizationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request
func (r *CheckAuthorizationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/check-authorization",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckAuthorizationReq) Rel(link string, resp *CheckAuthorizationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckAuthorizationResponseBody is a response body for CheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type CheckAuthorizationResponseBody struct {
	App struct {
		ClientId string `json:"client_id"`
		Name     string `json:"name"`
		Url      string `json:"url"`
	} `json:"app,omitempty"`
	CreatedAt    string `json:"created_at,omitempty"`
	Fingerprint  string `json:"fingerprint,omitempty"`
	HashedToken  string `json:"hashed_token,omitempty"`
	Id           int64  `json:"id,omitempty"`
	Installation struct {

		// Simple User
		Account         components.SimpleUser `json:"account,omitempty"`
		Permissions     interface{}           `json:"permissions,omitempty"`
		RepositoriesUrl string                `json:"repositories_url,omitempty"`

		// Describe whether all repositories have been selected or there's a selection involved
		RepositorySelection string `json:"repository_selection,omitempty"`
		SingleFileName      string `json:"single_file_name,omitempty"`
	} `json:"installation,omitempty"`
	Note    string `json:"note,omitempty"`
	NoteUrl string `json:"note_url,omitempty"`

	// A list of scopes that this authorization is in.
	Scopes         []string `json:"scopes,omitempty"`
	Token          string   `json:"token,omitempty"`
	TokenLastEight string   `json:"token_last_eight,omitempty"`
	UpdatedAt      string   `json:"updated_at,omitempty"`
	Url            string   `json:"url,omitempty"`
	User           struct {
		AvatarUrl         string `json:"avatar_url,omitempty"`
		EventsUrl         string `json:"events_url,omitempty"`
		FollowersUrl      string `json:"followers_url,omitempty"`
		FollowingUrl      string `json:"following_url,omitempty"`
		GistsUrl          string `json:"gists_url,omitempty"`
		GravatarId        string `json:"gravatar_id,omitempty"`
		HtmlUrl           string `json:"html_url,omitempty"`
		Id                int64  `json:"id,omitempty"`
		Login             string `json:"login,omitempty"`
		NodeId            string `json:"node_id,omitempty"`
		OrganizationsUrl  string `json:"organizations_url,omitempty"`
		ReceivedEventsUrl string `json:"received_events_url,omitempty"`
		ReposUrl          string `json:"repos_url,omitempty"`
		SiteAdmin         bool   `json:"site_admin,omitempty"`
		StarredAt         string `json:"starred_at,omitempty"`
		StarredUrl        string `json:"starred_url,omitempty"`
		SubscriptionsUrl  string `json:"subscriptions_url,omitempty"`
		Type              string `json:"type,omitempty"`
		Url               string `json:"url,omitempty"`
	} `json:"user,omitempty"`
}

/*
CheckAuthorizationResponse is a response for CheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type CheckAuthorizationResponse struct {
	httpResponse *http.Response
	Data         CheckAuthorizationResponseBody
}

func (r *CheckAuthorizationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CheckToken performs requests for "apps/check-token"

Check a token.

  POST /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
func CheckToken(ctx context.Context, req *CheckTokenReq, opt ...requests.Option) (*CheckTokenResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckTokenReq)
	}
	resp := &CheckTokenResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckTokenResponse(r, opts.PreserveResponseBody())
}

// NewCheckTokenResponse builds a new *CheckTokenResponse from an *http.Response
func NewCheckTokenResponse(resp *http.Response, preserveBody bool) (*CheckTokenResponse, error) {
	var result CheckTokenResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CheckToken performs requests for "apps/check-token"

Check a token.

  POST /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
func (c Client) CheckToken(ctx context.Context, req *CheckTokenReq, opt ...requests.Option) (*CheckTokenResponse, error) {
	return CheckToken(ctx, req, append(c, opt...)...)
}

/*
CheckTokenReq is request data for Client.CheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type CheckTokenReq struct {
	_url        string
	ClientId    string
	RequestBody CheckTokenReqBody
}

// HTTPRequest builds an *http.Request
func (r *CheckTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "apps/check-token",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/token", r.ClientId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckTokenReq) Rel(link string, resp *CheckTokenResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckTokenReqBody is a request body for apps/check-token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type CheckTokenReqBody struct {

	// The access_token of the OAuth application.
	AccessToken *string `json:"access_token"`
}

/*
CheckTokenResponse is a response for CheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type CheckTokenResponse struct {
	httpResponse *http.Response
	Data         components.Authorization
}

func (r *CheckTokenResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateContentAttachment performs requests for "apps/create-content-attachment"

Create a content attachment.

  POST /content_references/{content_reference_id}/attachments

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
func CreateContentAttachment(ctx context.Context, req *CreateContentAttachmentReq, opt ...requests.Option) (*CreateContentAttachmentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateContentAttachmentReq)
	}
	resp := &CreateContentAttachmentResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateContentAttachmentResponse(r, opts.PreserveResponseBody())
}

// NewCreateContentAttachmentResponse builds a new *CreateContentAttachmentResponse from an *http.Response
func NewCreateContentAttachmentResponse(resp *http.Response, preserveBody bool) (*CreateContentAttachmentResponse, error) {
	var result CreateContentAttachmentResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateContentAttachment performs requests for "apps/create-content-attachment"

Create a content attachment.

  POST /content_references/{content_reference_id}/attachments

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
func (c Client) CreateContentAttachment(ctx context.Context, req *CreateContentAttachmentReq, opt ...requests.Option) (*CreateContentAttachmentResponse, error) {
	return CreateContentAttachment(ctx, req, append(c, opt...)...)
}

/*
CreateContentAttachmentReq is request data for Client.CreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type CreateContentAttachmentReq struct {
	_url string

	// content_reference_id parameter
	ContentReferenceId int64
	RequestBody        CreateContentAttachmentReqBody

	/*
	To access the Content Attachments API during the preview period, you must set
	this to true.
	*/
	CorsairPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateContentAttachmentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateContentAttachmentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"corsair"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "apps/create-content-attachment",
		Previews:         map[string]bool{"corsair": r.CorsairPreview},
		RequiredPreviews: []string{"corsair"},
		URLPath:          fmt.Sprintf("/content_references/%v/attachments", r.ContentReferenceId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateContentAttachmentReq) Rel(link string, resp *CreateContentAttachmentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateContentAttachmentReqBody is a request body for apps/create-content-attachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type CreateContentAttachmentReqBody struct {

	// The body of the attachment
	Body *string `json:"body"`

	// The title of the attachment
	Title *string `json:"title"`
}

/*
CreateContentAttachmentResponse is a response for CreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type CreateContentAttachmentResponse struct {
	httpResponse *http.Response
	Data         components.ContentReferenceAttachment
}

func (r *CreateContentAttachmentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateFromManifest performs requests for "apps/create-from-manifest"

Create a GitHub App from a manifest.

  POST /app-manifests/{code}/conversions

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
func CreateFromManifest(ctx context.Context, req *CreateFromManifestReq, opt ...requests.Option) (*CreateFromManifestResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateFromManifestReq)
	}
	resp := &CreateFromManifestResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateFromManifestResponse(r, opts.PreserveResponseBody())
}

// NewCreateFromManifestResponse builds a new *CreateFromManifestResponse from an *http.Response
func NewCreateFromManifestResponse(resp *http.Response, preserveBody bool) (*CreateFromManifestResponse, error) {
	var result CreateFromManifestResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateFromManifest performs requests for "apps/create-from-manifest"

Create a GitHub App from a manifest.

  POST /app-manifests/{code}/conversions

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
func (c Client) CreateFromManifest(ctx context.Context, req *CreateFromManifestReq, opt ...requests.Option) (*CreateFromManifestResponse, error) {
	return CreateFromManifest(ctx, req, append(c, opt...)...)
}

/*
CreateFromManifestReq is request data for Client.CreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type CreateFromManifestReq struct {
	_url string

	// code parameter
	Code string
}

// HTTPRequest builds an *http.Request
func (r *CreateFromManifestReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateFromManifestReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "POST",
		OperationID:        "apps/create-from-manifest",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/app-manifests/%v/conversions", r.Code),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateFromManifestReq) Rel(link string, resp *CreateFromManifestResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateFromManifestResponseBody is a response body for CreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type CreateFromManifestResponseBody struct {
	ClientId     string `json:"client_id,omitempty"`
	ClientSecret string `json:"client_secret,omitempty"`
	CreatedAt    string `json:"created_at,omitempty"`
	Description  string `json:"description,omitempty"`

	// The list of events for the GitHub app
	Events      []string `json:"events,omitempty"`
	ExternalUrl string   `json:"external_url,omitempty"`
	HtmlUrl     string   `json:"html_url,omitempty"`

	// Unique identifier of the GitHub app
	Id int64 `json:"id,omitempty"`

	// The number of installations associated with the GitHub app
	InstallationsCount int64 `json:"installations_count,omitempty"`

	// The name of the GitHub app
	Name   string `json:"name,omitempty"`
	NodeId string `json:"node_id,omitempty"`
	Owner  struct {
		AvatarUrl         string `json:"avatar_url,omitempty"`
		EventsUrl         string `json:"events_url,omitempty"`
		FollowersUrl      string `json:"followers_url,omitempty"`
		FollowingUrl      string `json:"following_url,omitempty"`
		GistsUrl          string `json:"gists_url,omitempty"`
		GravatarId        string `json:"gravatar_id,omitempty"`
		HtmlUrl           string `json:"html_url,omitempty"`
		Id                int64  `json:"id,omitempty"`
		Login             string `json:"login,omitempty"`
		NodeId            string `json:"node_id,omitempty"`
		OrganizationsUrl  string `json:"organizations_url,omitempty"`
		ReceivedEventsUrl string `json:"received_events_url,omitempty"`
		ReposUrl          string `json:"repos_url,omitempty"`
		SiteAdmin         bool   `json:"site_admin,omitempty"`
		StarredAt         string `json:"starred_at,omitempty"`
		StarredUrl        string `json:"starred_url,omitempty"`
		SubscriptionsUrl  string `json:"subscriptions_url,omitempty"`
		Type              string `json:"type,omitempty"`
		Url               string `json:"url,omitempty"`
	} `json:"owner,omitempty"`
	Pem string `json:"pem,omitempty"`

	// The set of permissions for the GitHub app
	Permissions map[string]string `json:"permissions,omitempty"`

	// The slug name of the GitHub app
	Slug          string `json:"slug,omitempty"`
	UpdatedAt     string `json:"updated_at,omitempty"`
	WebhookSecret string `json:"webhook_secret,omitempty"`
}

/*
CreateFromManifestResponse is a response for CreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type CreateFromManifestResponse struct {
	httpResponse *http.Response
	Data         CreateFromManifestResponseBody
}

func (r *CreateFromManifestResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateInstallationAccessToken performs requests for "apps/create-installation-access-token"

Create an installation access token for an app.

  POST /app/installations/{installation_id}/access_tokens

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
func CreateInstallationAccessToken(ctx context.Context, req *CreateInstallationAccessTokenReq, opt ...requests.Option) (*CreateInstallationAccessTokenResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateInstallationAccessTokenReq)
	}
	resp := &CreateInstallationAccessTokenResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateInstallationAccessTokenResponse(r, opts.PreserveResponseBody())
}

// NewCreateInstallationAccessTokenResponse builds a new *CreateInstallationAccessTokenResponse from an *http.Response
func NewCreateInstallationAccessTokenResponse(resp *http.Response, preserveBody bool) (*CreateInstallationAccessTokenResponse, error) {
	var result CreateInstallationAccessTokenResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateInstallationAccessToken performs requests for "apps/create-installation-access-token"

Create an installation access token for an app.

  POST /app/installations/{installation_id}/access_tokens

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
func (c Client) CreateInstallationAccessToken(ctx context.Context, req *CreateInstallationAccessTokenReq, opt ...requests.Option) (*CreateInstallationAccessTokenResponse, error) {
	return CreateInstallationAccessToken(ctx, req, append(c, opt...)...)
}

/*
CreateInstallationAccessTokenReq is request data for Client.CreateInstallationAccessToken

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
type CreateInstallationAccessTokenReq struct {
	_url string

	// installation_id parameter
	InstallationId int64
	RequestBody    CreateInstallationAccessTokenReqBody

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *CreateInstallationAccessTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateInstallationAccessTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "apps/create-installation-access-token",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app/installations/%v/access_tokens", r.InstallationId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateInstallationAccessTokenReq) Rel(link string, resp *CreateInstallationAccessTokenResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateInstallationAccessTokenReqBodyPermissions is a value for CreateInstallationAccessTokenReqBody's Permissions field
type CreateInstallationAccessTokenReqBodyPermissions map[string]string

/*
CreateInstallationAccessTokenReqBody is a request body for apps/create-installation-access-token

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
type CreateInstallationAccessTokenReqBody struct {
	Permissions map[string]string `json:"permissions,omitempty"`

	// List of repository names that the token should have access to
	Repositories []string `json:"repositories,omitempty"`

	// List of repository IDs that the token should have access to
	RepositoryIds []int64 `json:"repository_ids,omitempty"`
}

/*
CreateInstallationAccessTokenResponse is a response for CreateInstallationAccessToken

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
type CreateInstallationAccessTokenResponse struct {
	httpResponse *http.Response
	Data         components.InstallationToken
}

func (r *CreateInstallationAccessTokenResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteAuthorization performs requests for "apps/delete-authorization"

Delete an app authorization.

  DELETE /applications/{client_id}/grant

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
func DeleteAuthorization(ctx context.Context, req *DeleteAuthorizationReq, opt ...requests.Option) (*DeleteAuthorizationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteAuthorizationReq)
	}
	resp := &DeleteAuthorizationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteAuthorizationResponse(r, opts.PreserveResponseBody())
}

// NewDeleteAuthorizationResponse builds a new *DeleteAuthorizationResponse from an *http.Response
func NewDeleteAuthorizationResponse(resp *http.Response, preserveBody bool) (*DeleteAuthorizationResponse, error) {
	var result DeleteAuthorizationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteAuthorization performs requests for "apps/delete-authorization"

Delete an app authorization.

  DELETE /applications/{client_id}/grant

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
func (c Client) DeleteAuthorization(ctx context.Context, req *DeleteAuthorizationReq, opt ...requests.Option) (*DeleteAuthorizationResponse, error) {
	return DeleteAuthorization(ctx, req, append(c, opt...)...)
}

/*
DeleteAuthorizationReq is request data for Client.DeleteAuthorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type DeleteAuthorizationReq struct {
	_url        string
	ClientId    string
	RequestBody DeleteAuthorizationReqBody
}

// HTTPRequest builds an *http.Request
func (r *DeleteAuthorizationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "DELETE",
		OperationID:        "apps/delete-authorization",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/applications/%v/grant", r.ClientId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteAuthorizationReq) Rel(link string, resp *DeleteAuthorizationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteAuthorizationReqBody is a request body for apps/delete-authorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type DeleteAuthorizationReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
DeleteAuthorizationResponse is a response for DeleteAuthorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type DeleteAuthorizationResponse struct {
	httpResponse *http.Response
}

func (r *DeleteAuthorizationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteInstallation performs requests for "apps/delete-installation"

Delete an installation for the authenticated app.

  DELETE /app/installations/{installation_id}

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
func DeleteInstallation(ctx context.Context, req *DeleteInstallationReq, opt ...requests.Option) (*DeleteInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteInstallationReq)
	}
	resp := &DeleteInstallationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteInstallationResponse(r, opts.PreserveResponseBody())
}

// NewDeleteInstallationResponse builds a new *DeleteInstallationResponse from an *http.Response
func NewDeleteInstallationResponse(resp *http.Response, preserveBody bool) (*DeleteInstallationResponse, error) {
	var result DeleteInstallationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteInstallation performs requests for "apps/delete-installation"

Delete an installation for the authenticated app.

  DELETE /app/installations/{installation_id}

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
func (c Client) DeleteInstallation(ctx context.Context, req *DeleteInstallationReq, opt ...requests.Option) (*DeleteInstallationResponse, error) {
	return DeleteInstallation(ctx, req, append(c, opt...)...)
}

/*
DeleteInstallationReq is request data for Client.DeleteInstallation

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
type DeleteInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *DeleteInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "apps/delete-installation",
		Previews:           map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews:   []string{"machine-man"},
		URLPath:            fmt.Sprintf("/app/installations/%v", r.InstallationId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteInstallationReq) Rel(link string, resp *DeleteInstallationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteInstallationResponse is a response for DeleteInstallation

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
type DeleteInstallationResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *DeleteInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteToken performs requests for "apps/delete-token"

Delete an app token.

  DELETE /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
func DeleteToken(ctx context.Context, req *DeleteTokenReq, opt ...requests.Option) (*DeleteTokenResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteTokenReq)
	}
	resp := &DeleteTokenResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteTokenResponse(r, opts.PreserveResponseBody())
}

// NewDeleteTokenResponse builds a new *DeleteTokenResponse from an *http.Response
func NewDeleteTokenResponse(resp *http.Response, preserveBody bool) (*DeleteTokenResponse, error) {
	var result DeleteTokenResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteToken performs requests for "apps/delete-token"

Delete an app token.

  DELETE /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
func (c Client) DeleteToken(ctx context.Context, req *DeleteTokenReq, opt ...requests.Option) (*DeleteTokenResponse, error) {
	return DeleteToken(ctx, req, append(c, opt...)...)
}

/*
DeleteTokenReq is request data for Client.DeleteToken

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type DeleteTokenReq struct {
	_url        string
	ClientId    string
	RequestBody DeleteTokenReqBody
}

// HTTPRequest builds an *http.Request
func (r *DeleteTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "DELETE",
		OperationID:        "apps/delete-token",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/applications/%v/token", r.ClientId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteTokenReq) Rel(link string, resp *DeleteTokenResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteTokenReqBody is a request body for apps/delete-token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type DeleteTokenReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
DeleteTokenResponse is a response for DeleteToken

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type DeleteTokenResponse struct {
	httpResponse *http.Response
}

func (r *DeleteTokenResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetAuthenticated performs requests for "apps/get-authenticated"

Get the authenticated app.

  GET /app

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
func GetAuthenticated(ctx context.Context, req *GetAuthenticatedReq, opt ...requests.Option) (*GetAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetAuthenticatedReq)
	}
	resp := &GetAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewGetAuthenticatedResponse builds a new *GetAuthenticatedResponse from an *http.Response
func NewGetAuthenticatedResponse(resp *http.Response, preserveBody bool) (*GetAuthenticatedResponse, error) {
	var result GetAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetAuthenticated performs requests for "apps/get-authenticated"

Get the authenticated app.

  GET /app

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
func (c Client) GetAuthenticated(ctx context.Context, req *GetAuthenticatedReq, opt ...requests.Option) (*GetAuthenticatedResponse, error) {
	return GetAuthenticated(ctx, req, append(c, opt...)...)
}

/*
GetAuthenticatedReq is request data for Client.GetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
type GetAuthenticatedReq struct {
	_url string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/get-authenticated",
		Previews:           map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews:   []string{"machine-man"},
		URLPath:            fmt.Sprintf("/app"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetAuthenticatedReq) Rel(link string, resp *GetAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetAuthenticatedResponse is a response for GetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
type GetAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         components.Integration
}

func (r *GetAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetBySlug performs requests for "apps/get-by-slug"

Get an app.

  GET /apps/{app_slug}

https://developer.github.com/v3/apps/#get-an-app
*/
func GetBySlug(ctx context.Context, req *GetBySlugReq, opt ...requests.Option) (*GetBySlugResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetBySlugReq)
	}
	resp := &GetBySlugResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetBySlugResponse(r, opts.PreserveResponseBody())
}

// NewGetBySlugResponse builds a new *GetBySlugResponse from an *http.Response
func NewGetBySlugResponse(resp *http.Response, preserveBody bool) (*GetBySlugResponse, error) {
	var result GetBySlugResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetBySlug performs requests for "apps/get-by-slug"

Get an app.

  GET /apps/{app_slug}

https://developer.github.com/v3/apps/#get-an-app
*/
func (c Client) GetBySlug(ctx context.Context, req *GetBySlugReq, opt ...requests.Option) (*GetBySlugResponse, error) {
	return GetBySlug(ctx, req, append(c, opt...)...)
}

/*
GetBySlugReq is request data for Client.GetBySlug

https://developer.github.com/v3/apps/#get-an-app
*/
type GetBySlugReq struct {
	_url string

	// app_slug parameter
	AppSlug string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetBySlugReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetBySlugReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/get-by-slug",
		Previews:           map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews:   []string{"machine-man"},
		URLPath:            fmt.Sprintf("/apps/%v", r.AppSlug),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetBySlugReq) Rel(link string, resp *GetBySlugResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetBySlugResponse is a response for GetBySlug

https://developer.github.com/v3/apps/#get-an-app
*/
type GetBySlugResponse struct {
	httpResponse *http.Response
	Data         components.Integration
}

func (r *GetBySlugResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetInstallation performs requests for "apps/get-installation"

Get an installation for the authenticated app.

  GET /app/installations/{installation_id}

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
func GetInstallation(ctx context.Context, req *GetInstallationReq, opt ...requests.Option) (*GetInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetInstallationReq)
	}
	resp := &GetInstallationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetInstallationResponse(r, opts.PreserveResponseBody())
}

// NewGetInstallationResponse builds a new *GetInstallationResponse from an *http.Response
func NewGetInstallationResponse(resp *http.Response, preserveBody bool) (*GetInstallationResponse, error) {
	var result GetInstallationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetInstallation performs requests for "apps/get-installation"

Get an installation for the authenticated app.

  GET /app/installations/{installation_id}

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
func (c Client) GetInstallation(ctx context.Context, req *GetInstallationReq, opt ...requests.Option) (*GetInstallationResponse, error) {
	return GetInstallation(ctx, req, append(c, opt...)...)
}

/*
GetInstallationReq is request data for Client.GetInstallation

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
type GetInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/get-installation",
		Previews:           map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews:   []string{"machine-man"},
		URLPath:            fmt.Sprintf("/app/installations/%v", r.InstallationId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetInstallationReq) Rel(link string, resp *GetInstallationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetInstallationResponse is a response for GetInstallation

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
type GetInstallationResponse struct {
	httpResponse *http.Response
	Data         components.Installation
}

func (r *GetInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetOrgInstallation performs requests for "apps/get-org-installation"

Get an organization installation for the authenticated app.

  GET /orgs/{org}/installation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
func GetOrgInstallation(ctx context.Context, req *GetOrgInstallationReq, opt ...requests.Option) (*GetOrgInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetOrgInstallationReq)
	}
	resp := &GetOrgInstallationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetOrgInstallationResponse(r, opts.PreserveResponseBody())
}

// NewGetOrgInstallationResponse builds a new *GetOrgInstallationResponse from an *http.Response
func NewGetOrgInstallationResponse(resp *http.Response, preserveBody bool) (*GetOrgInstallationResponse, error) {
	var result GetOrgInstallationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetOrgInstallation performs requests for "apps/get-org-installation"

Get an organization installation for the authenticated app.

  GET /orgs/{org}/installation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
func (c Client) GetOrgInstallation(ctx context.Context, req *GetOrgInstallationReq, opt ...requests.Option) (*GetOrgInstallationResponse, error) {
	return GetOrgInstallation(ctx, req, append(c, opt...)...)
}

/*
GetOrgInstallationReq is request data for Client.GetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
type GetOrgInstallationReq struct {
	_url string
	Org  string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetOrgInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetOrgInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/get-org-installation",
		Previews:           map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews:   []string{"machine-man"},
		URLPath:            fmt.Sprintf("/orgs/%v/installation", r.Org),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetOrgInstallationReq) Rel(link string, resp *GetOrgInstallationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetOrgInstallationResponse is a response for GetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
type GetOrgInstallationResponse struct {
	httpResponse *http.Response
	Data         components.Installation
}

func (r *GetOrgInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetRepoInstallation performs requests for "apps/get-repo-installation"

Get a repository installation for the authenticated app.

  GET /repos/{owner}/{repo}/installation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
func GetRepoInstallation(ctx context.Context, req *GetRepoInstallationReq, opt ...requests.Option) (*GetRepoInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetRepoInstallationReq)
	}
	resp := &GetRepoInstallationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetRepoInstallationResponse(r, opts.PreserveResponseBody())
}

// NewGetRepoInstallationResponse builds a new *GetRepoInstallationResponse from an *http.Response
func NewGetRepoInstallationResponse(resp *http.Response, preserveBody bool) (*GetRepoInstallationResponse, error) {
	var result GetRepoInstallationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 301})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetRepoInstallation performs requests for "apps/get-repo-installation"

Get a repository installation for the authenticated app.

  GET /repos/{owner}/{repo}/installation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
func (c Client) GetRepoInstallation(ctx context.Context, req *GetRepoInstallationReq, opt ...requests.Option) (*GetRepoInstallationResponse, error) {
	return GetRepoInstallation(ctx, req, append(c, opt...)...)
}

/*
GetRepoInstallationReq is request data for Client.GetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
type GetRepoInstallationReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetRepoInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetRepoInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/get-repo-installation",
		Previews:           map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews:   []string{"machine-man"},
		URLPath:            fmt.Sprintf("/repos/%v/%v/installation", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetRepoInstallationReq) Rel(link string, resp *GetRepoInstallationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetRepoInstallationResponse is a response for GetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
type GetRepoInstallationResponse struct {
	httpResponse *http.Response
	Data         components.Installation
}

func (r *GetRepoInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetSubscriptionPlanForAccount performs requests for "apps/get-subscription-plan-for-account"

Get a subscription plan for an account.

  GET /marketplace_listing/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
func GetSubscriptionPlanForAccount(ctx context.Context, req *GetSubscriptionPlanForAccountReq, opt ...requests.Option) (*GetSubscriptionPlanForAccountResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetSubscriptionPlanForAccountReq)
	}
	resp := &GetSubscriptionPlanForAccountResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetSubscriptionPlanForAccountResponse(r, opts.PreserveResponseBody())
}

// NewGetSubscriptionPlanForAccountResponse builds a new *GetSubscriptionPlanForAccountResponse from an *http.Response
func NewGetSubscriptionPlanForAccountResponse(resp *http.Response, preserveBody bool) (*GetSubscriptionPlanForAccountResponse, error) {
	var result GetSubscriptionPlanForAccountResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetSubscriptionPlanForAccount performs requests for "apps/get-subscription-plan-for-account"

Get a subscription plan for an account.

  GET /marketplace_listing/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
func (c Client) GetSubscriptionPlanForAccount(ctx context.Context, req *GetSubscriptionPlanForAccountReq, opt ...requests.Option) (*GetSubscriptionPlanForAccountResponse, error) {
	return GetSubscriptionPlanForAccount(ctx, req, append(c, opt...)...)
}

/*
GetSubscriptionPlanForAccountReq is request data for Client.GetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type GetSubscriptionPlanForAccountReq struct {
	_url string

	// account_id parameter
	AccountId int64
}

// HTTPRequest builds an *http.Request
func (r *GetSubscriptionPlanForAccountReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetSubscriptionPlanForAccountReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/get-subscription-plan-for-account",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/marketplace_listing/accounts/%v", r.AccountId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetSubscriptionPlanForAccountReq) Rel(link string, resp *GetSubscriptionPlanForAccountResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetSubscriptionPlanForAccountResponse is a response for GetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type GetSubscriptionPlanForAccountResponse struct {
	httpResponse *http.Response
	Data         components.MarketplacePurchase
}

func (r *GetSubscriptionPlanForAccountResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetSubscriptionPlanForAccountStubbed performs requests for "apps/get-subscription-plan-for-account-stubbed"

Get a subscription plan for an account (stubbed).

  GET /marketplace_listing/stubbed/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
func GetSubscriptionPlanForAccountStubbed(ctx context.Context, req *GetSubscriptionPlanForAccountStubbedReq, opt ...requests.Option) (*GetSubscriptionPlanForAccountStubbedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetSubscriptionPlanForAccountStubbedReq)
	}
	resp := &GetSubscriptionPlanForAccountStubbedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetSubscriptionPlanForAccountStubbedResponse(r, opts.PreserveResponseBody())
}

// NewGetSubscriptionPlanForAccountStubbedResponse builds a new *GetSubscriptionPlanForAccountStubbedResponse from an *http.Response
func NewGetSubscriptionPlanForAccountStubbedResponse(resp *http.Response, preserveBody bool) (*GetSubscriptionPlanForAccountStubbedResponse, error) {
	var result GetSubscriptionPlanForAccountStubbedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetSubscriptionPlanForAccountStubbed performs requests for "apps/get-subscription-plan-for-account-stubbed"

Get a subscription plan for an account (stubbed).

  GET /marketplace_listing/stubbed/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
func (c Client) GetSubscriptionPlanForAccountStubbed(ctx context.Context, req *GetSubscriptionPlanForAccountStubbedReq, opt ...requests.Option) (*GetSubscriptionPlanForAccountStubbedResponse, error) {
	return GetSubscriptionPlanForAccountStubbed(ctx, req, append(c, opt...)...)
}

/*
GetSubscriptionPlanForAccountStubbedReq is request data for Client.GetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type GetSubscriptionPlanForAccountStubbedReq struct {
	_url string

	// account_id parameter
	AccountId int64
}

// HTTPRequest builds an *http.Request
func (r *GetSubscriptionPlanForAccountStubbedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetSubscriptionPlanForAccountStubbedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/get-subscription-plan-for-account-stubbed",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/marketplace_listing/stubbed/accounts/%v", r.AccountId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetSubscriptionPlanForAccountStubbedReq) Rel(link string, resp *GetSubscriptionPlanForAccountStubbedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetSubscriptionPlanForAccountStubbedResponse is a response for GetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type GetSubscriptionPlanForAccountStubbedResponse struct {
	httpResponse *http.Response
	Data         components.MarketplacePurchase
}

func (r *GetSubscriptionPlanForAccountStubbedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetUserInstallation performs requests for "apps/get-user-installation"

Get a user installation for the authenticated app.

  GET /users/{username}/installation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
func GetUserInstallation(ctx context.Context, req *GetUserInstallationReq, opt ...requests.Option) (*GetUserInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetUserInstallationReq)
	}
	resp := &GetUserInstallationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetUserInstallationResponse(r, opts.PreserveResponseBody())
}

// NewGetUserInstallationResponse builds a new *GetUserInstallationResponse from an *http.Response
func NewGetUserInstallationResponse(resp *http.Response, preserveBody bool) (*GetUserInstallationResponse, error) {
	var result GetUserInstallationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetUserInstallation performs requests for "apps/get-user-installation"

Get a user installation for the authenticated app.

  GET /users/{username}/installation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
func (c Client) GetUserInstallation(ctx context.Context, req *GetUserInstallationReq, opt ...requests.Option) (*GetUserInstallationResponse, error) {
	return GetUserInstallation(ctx, req, append(c, opt...)...)
}

/*
GetUserInstallationReq is request data for Client.GetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
type GetUserInstallationReq struct {
	_url     string
	Username string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetUserInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetUserInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/get-user-installation",
		Previews:           map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews:   []string{"machine-man"},
		URLPath:            fmt.Sprintf("/users/%v/installation", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetUserInstallationReq) Rel(link string, resp *GetUserInstallationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetUserInstallationResponse is a response for GetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
type GetUserInstallationResponse struct {
	httpResponse *http.Response
	Data         components.Installation
}

func (r *GetUserInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListAccountsForPlan performs requests for "apps/list-accounts-for-plan"

List accounts for a plan.

  GET /marketplace_listing/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
func ListAccountsForPlan(ctx context.Context, req *ListAccountsForPlanReq, opt ...requests.Option) (*ListAccountsForPlanResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListAccountsForPlanReq)
	}
	resp := &ListAccountsForPlanResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListAccountsForPlanResponse(r, opts.PreserveResponseBody())
}

// NewListAccountsForPlanResponse builds a new *ListAccountsForPlanResponse from an *http.Response
func NewListAccountsForPlanResponse(resp *http.Response, preserveBody bool) (*ListAccountsForPlanResponse, error) {
	var result ListAccountsForPlanResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListAccountsForPlan performs requests for "apps/list-accounts-for-plan"

List accounts for a plan.

  GET /marketplace_listing/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
func (c Client) ListAccountsForPlan(ctx context.Context, req *ListAccountsForPlanReq, opt ...requests.Option) (*ListAccountsForPlanResponse, error) {
	return ListAccountsForPlan(ctx, req, append(c, opt...)...)
}

/*
ListAccountsForPlanReq is request data for Client.ListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type ListAccountsForPlanReq struct {
	_url string

	// plan_id parameter
	PlanId int64

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListAccountsForPlanReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListAccountsForPlanReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/list-accounts-for-plan",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/marketplace_listing/plans/%v/accounts", r.PlanId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListAccountsForPlanReq) Rel(link string, resp *ListAccountsForPlanResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListAccountsForPlanResponse is a response for ListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type ListAccountsForPlanResponse struct {
	httpResponse *http.Response
	Data         []components.MarketplacePurchase
}

func (r *ListAccountsForPlanResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListAccountsForPlanStubbed performs requests for "apps/list-accounts-for-plan-stubbed"

List accounts for a plan (stubbed).

  GET /marketplace_listing/stubbed/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
func ListAccountsForPlanStubbed(ctx context.Context, req *ListAccountsForPlanStubbedReq, opt ...requests.Option) (*ListAccountsForPlanStubbedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListAccountsForPlanStubbedReq)
	}
	resp := &ListAccountsForPlanStubbedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListAccountsForPlanStubbedResponse(r, opts.PreserveResponseBody())
}

// NewListAccountsForPlanStubbedResponse builds a new *ListAccountsForPlanStubbedResponse from an *http.Response
func NewListAccountsForPlanStubbedResponse(resp *http.Response, preserveBody bool) (*ListAccountsForPlanStubbedResponse, error) {
	var result ListAccountsForPlanStubbedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListAccountsForPlanStubbed performs requests for "apps/list-accounts-for-plan-stubbed"

List accounts for a plan (stubbed).

  GET /marketplace_listing/stubbed/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
func (c Client) ListAccountsForPlanStubbed(ctx context.Context, req *ListAccountsForPlanStubbedReq, opt ...requests.Option) (*ListAccountsForPlanStubbedResponse, error) {
	return ListAccountsForPlanStubbed(ctx, req, append(c, opt...)...)
}

/*
ListAccountsForPlanStubbedReq is request data for Client.ListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type ListAccountsForPlanStubbedReq struct {
	_url string

	// plan_id parameter
	PlanId int64

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListAccountsForPlanStubbedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListAccountsForPlanStubbedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/list-accounts-for-plan-stubbed",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/marketplace_listing/stubbed/plans/%v/accounts", r.PlanId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListAccountsForPlanStubbedReq) Rel(link string, resp *ListAccountsForPlanStubbedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListAccountsForPlanStubbedResponse is a response for ListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type ListAccountsForPlanStubbedResponse struct {
	httpResponse *http.Response
	Data         []components.MarketplacePurchase
}

func (r *ListAccountsForPlanStubbedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListInstallationReposForAuthenticatedUser performs requests for "apps/list-installation-repos-for-authenticated-user"

List repositories accessible to the user access token.

  GET /user/installations/{installation_id}/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
func ListInstallationReposForAuthenticatedUser(ctx context.Context, req *ListInstallationReposForAuthenticatedUserReq, opt ...requests.Option) (*ListInstallationReposForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListInstallationReposForAuthenticatedUserReq)
	}
	resp := &ListInstallationReposForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListInstallationReposForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListInstallationReposForAuthenticatedUserResponse builds a new *ListInstallationReposForAuthenticatedUserResponse from an *http.Response
func NewListInstallationReposForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListInstallationReposForAuthenticatedUserResponse, error) {
	var result ListInstallationReposForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListInstallationReposForAuthenticatedUser performs requests for "apps/list-installation-repos-for-authenticated-user"

List repositories accessible to the user access token.

  GET /user/installations/{installation_id}/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
func (c Client) ListInstallationReposForAuthenticatedUser(ctx context.Context, req *ListInstallationReposForAuthenticatedUserReq, opt ...requests.Option) (*ListInstallationReposForAuthenticatedUserResponse, error) {
	return ListInstallationReposForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListInstallationReposForAuthenticatedUserReq is request data for Client.ListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
type ListInstallationReposForAuthenticatedUserReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListInstallationReposForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListInstallationReposForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man", "mercy"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/list-installation-repos-for-authenticated-user",
		Previews: map[string]bool{
			"machine-man": r.MachineManPreview,
			"mercy":       r.MercyPreview,
		},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/user/installations/%v/repositories", r.InstallationId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInstallationReposForAuthenticatedUserReq) Rel(link string, resp *ListInstallationReposForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInstallationReposForAuthenticatedUserResponseBody is a response body for ListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
type ListInstallationReposForAuthenticatedUserResponseBody struct {
	Repositories        []components.Repository `json:"repositories,omitempty"`
	RepositorySelection string                  `json:"repository_selection,omitempty"`
	TotalCount          int64                   `json:"total_count,omitempty"`
}

/*
ListInstallationReposForAuthenticatedUserResponse is a response for ListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
type ListInstallationReposForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         ListInstallationReposForAuthenticatedUserResponseBody
}

func (r *ListInstallationReposForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListInstallations performs requests for "apps/list-installations"

List installations for the authenticated app.

  GET /app/installations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
func ListInstallations(ctx context.Context, req *ListInstallationsReq, opt ...requests.Option) (*ListInstallationsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListInstallationsReq)
	}
	resp := &ListInstallationsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListInstallationsResponse(r, opts.PreserveResponseBody())
}

// NewListInstallationsResponse builds a new *ListInstallationsResponse from an *http.Response
func NewListInstallationsResponse(resp *http.Response, preserveBody bool) (*ListInstallationsResponse, error) {
	var result ListInstallationsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListInstallations performs requests for "apps/list-installations"

List installations for the authenticated app.

  GET /app/installations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
func (c Client) ListInstallations(ctx context.Context, req *ListInstallationsReq, opt ...requests.Option) (*ListInstallationsResponse, error) {
	return ListInstallations(ctx, req, append(c, opt...)...)
}

/*
ListInstallationsReq is request data for Client.ListInstallations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
type ListInstallationsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since    *string
	Outdated *string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListInstallationsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListInstallationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Outdated != nil {
		query.Set("outdated", *r.Outdated)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/list-installations",
		Previews:           map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews:   []string{"machine-man"},
		URLPath:            fmt.Sprintf("/app/installations"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInstallationsReq) Rel(link string, resp *ListInstallationsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInstallationsResponse is a response for ListInstallations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
type ListInstallationsResponse struct {
	httpResponse *http.Response
	Data         []components.Installation
}

func (r *ListInstallationsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListInstallationsForAuthenticatedUser performs requests for "apps/list-installations-for-authenticated-user"

List app installations accessible to the user access token.

  GET /user/installations

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
func ListInstallationsForAuthenticatedUser(ctx context.Context, req *ListInstallationsForAuthenticatedUserReq, opt ...requests.Option) (*ListInstallationsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListInstallationsForAuthenticatedUserReq)
	}
	resp := &ListInstallationsForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListInstallationsForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListInstallationsForAuthenticatedUserResponse builds a new *ListInstallationsForAuthenticatedUserResponse from an *http.Response
func NewListInstallationsForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListInstallationsForAuthenticatedUserResponse, error) {
	var result ListInstallationsForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListInstallationsForAuthenticatedUser performs requests for "apps/list-installations-for-authenticated-user"

List app installations accessible to the user access token.

  GET /user/installations

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
func (c Client) ListInstallationsForAuthenticatedUser(ctx context.Context, req *ListInstallationsForAuthenticatedUserReq, opt ...requests.Option) (*ListInstallationsForAuthenticatedUserResponse, error) {
	return ListInstallationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListInstallationsForAuthenticatedUserReq is request data for Client.ListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
type ListInstallationsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListInstallationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListInstallationsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/list-installations-for-authenticated-user",
		Previews:           map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews:   []string{"machine-man"},
		URLPath:            fmt.Sprintf("/user/installations"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInstallationsForAuthenticatedUserReq) Rel(link string, resp *ListInstallationsForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInstallationsForAuthenticatedUserResponseBody is a response body for ListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
type ListInstallationsForAuthenticatedUserResponseBody struct {
	Installations []components.Installation `json:"installations,omitempty"`
	TotalCount    int64                     `json:"total_count,omitempty"`
}

/*
ListInstallationsForAuthenticatedUserResponse is a response for ListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
type ListInstallationsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         ListInstallationsForAuthenticatedUserResponseBody
}

func (r *ListInstallationsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPlans performs requests for "apps/list-plans"

List plans.

  GET /marketplace_listing/plans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
func ListPlans(ctx context.Context, req *ListPlansReq, opt ...requests.Option) (*ListPlansResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPlansReq)
	}
	resp := &ListPlansResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPlansResponse(r, opts.PreserveResponseBody())
}

// NewListPlansResponse builds a new *ListPlansResponse from an *http.Response
func NewListPlansResponse(resp *http.Response, preserveBody bool) (*ListPlansResponse, error) {
	var result ListPlansResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPlans performs requests for "apps/list-plans"

List plans.

  GET /marketplace_listing/plans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
func (c Client) ListPlans(ctx context.Context, req *ListPlansReq, opt ...requests.Option) (*ListPlansResponse, error) {
	return ListPlans(ctx, req, append(c, opt...)...)
}

/*
ListPlansReq is request data for Client.ListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type ListPlansReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPlansReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPlansReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/list-plans",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/marketplace_listing/plans"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPlansReq) Rel(link string, resp *ListPlansResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPlansResponse is a response for ListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type ListPlansResponse struct {
	httpResponse *http.Response
	Data         []components.MarketplaceListingPlan
}

func (r *ListPlansResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPlansStubbed performs requests for "apps/list-plans-stubbed"

List plans (stubbed).

  GET /marketplace_listing/stubbed/plans

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
func ListPlansStubbed(ctx context.Context, req *ListPlansStubbedReq, opt ...requests.Option) (*ListPlansStubbedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPlansStubbedReq)
	}
	resp := &ListPlansStubbedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPlansStubbedResponse(r, opts.PreserveResponseBody())
}

// NewListPlansStubbedResponse builds a new *ListPlansStubbedResponse from an *http.Response
func NewListPlansStubbedResponse(resp *http.Response, preserveBody bool) (*ListPlansStubbedResponse, error) {
	var result ListPlansStubbedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPlansStubbed performs requests for "apps/list-plans-stubbed"

List plans (stubbed).

  GET /marketplace_listing/stubbed/plans

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
func (c Client) ListPlansStubbed(ctx context.Context, req *ListPlansStubbedReq, opt ...requests.Option) (*ListPlansStubbedResponse, error) {
	return ListPlansStubbed(ctx, req, append(c, opt...)...)
}

/*
ListPlansStubbedReq is request data for Client.ListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type ListPlansStubbedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPlansStubbedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPlansStubbedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/list-plans-stubbed",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/marketplace_listing/stubbed/plans"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPlansStubbedReq) Rel(link string, resp *ListPlansStubbedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPlansStubbedResponse is a response for ListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type ListPlansStubbedResponse struct {
	httpResponse *http.Response
	Data         []components.MarketplaceListingPlan
}

func (r *ListPlansStubbedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListReposAccessibleToInstallation performs requests for "apps/list-repos-accessible-to-installation"

List repositories accessible to the app installation.

  GET /installation/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
func ListReposAccessibleToInstallation(ctx context.Context, req *ListReposAccessibleToInstallationReq, opt ...requests.Option) (*ListReposAccessibleToInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReposAccessibleToInstallationReq)
	}
	resp := &ListReposAccessibleToInstallationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListReposAccessibleToInstallationResponse(r, opts.PreserveResponseBody())
}

// NewListReposAccessibleToInstallationResponse builds a new *ListReposAccessibleToInstallationResponse from an *http.Response
func NewListReposAccessibleToInstallationResponse(resp *http.Response, preserveBody bool) (*ListReposAccessibleToInstallationResponse, error) {
	var result ListReposAccessibleToInstallationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListReposAccessibleToInstallation performs requests for "apps/list-repos-accessible-to-installation"

List repositories accessible to the app installation.

  GET /installation/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
func (c Client) ListReposAccessibleToInstallation(ctx context.Context, req *ListReposAccessibleToInstallationReq, opt ...requests.Option) (*ListReposAccessibleToInstallationResponse, error) {
	return ListReposAccessibleToInstallation(ctx, req, append(c, opt...)...)
}

/*
ListReposAccessibleToInstallationReq is request data for Client.ListReposAccessibleToInstallation

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
type ListReposAccessibleToInstallationReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListReposAccessibleToInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReposAccessibleToInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man", "mercy"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/list-repos-accessible-to-installation",
		Previews: map[string]bool{
			"machine-man": r.MachineManPreview,
			"mercy":       r.MercyPreview,
		},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/installation/repositories"),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposAccessibleToInstallationReq) Rel(link string, resp *ListReposAccessibleToInstallationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposAccessibleToInstallationResponseBody is a response body for ListReposAccessibleToInstallation

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
type ListReposAccessibleToInstallationResponseBody struct {
	Repositories        []components.Repository `json:"repositories,omitempty"`
	RepositorySelection string                  `json:"repository_selection,omitempty"`
	TotalCount          int64                   `json:"total_count,omitempty"`
}

/*
ListReposAccessibleToInstallationResponse is a response for ListReposAccessibleToInstallation

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
type ListReposAccessibleToInstallationResponse struct {
	httpResponse *http.Response
	Data         ListReposAccessibleToInstallationResponseBody
}

func (r *ListReposAccessibleToInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListSubscriptionsForAuthenticatedUser performs requests for "apps/list-subscriptions-for-authenticated-user"

List subscriptions for the authenticated user.

  GET /user/marketplace_purchases

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
func ListSubscriptionsForAuthenticatedUser(ctx context.Context, req *ListSubscriptionsForAuthenticatedUserReq, opt ...requests.Option) (*ListSubscriptionsForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListSubscriptionsForAuthenticatedUserReq)
	}
	resp := &ListSubscriptionsForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListSubscriptionsForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListSubscriptionsForAuthenticatedUserResponse builds a new *ListSubscriptionsForAuthenticatedUserResponse from an *http.Response
func NewListSubscriptionsForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListSubscriptionsForAuthenticatedUserResponse, error) {
	var result ListSubscriptionsForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListSubscriptionsForAuthenticatedUser performs requests for "apps/list-subscriptions-for-authenticated-user"

List subscriptions for the authenticated user.

  GET /user/marketplace_purchases

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
func (c Client) ListSubscriptionsForAuthenticatedUser(ctx context.Context, req *ListSubscriptionsForAuthenticatedUserReq, opt ...requests.Option) (*ListSubscriptionsForAuthenticatedUserResponse, error) {
	return ListSubscriptionsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListSubscriptionsForAuthenticatedUserReq is request data for Client.ListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type ListSubscriptionsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListSubscriptionsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListSubscriptionsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/list-subscriptions-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/marketplace_purchases"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListSubscriptionsForAuthenticatedUserReq) Rel(link string, resp *ListSubscriptionsForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListSubscriptionsForAuthenticatedUserResponse is a response for ListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type ListSubscriptionsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.UserMarketplacePurchase
}

func (r *ListSubscriptionsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListSubscriptionsForAuthenticatedUserStubbed performs requests for "apps/list-subscriptions-for-authenticated-user-stubbed"

List subscriptions for the authenticated user (stubbed).

  GET /user/marketplace_purchases/stubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
func ListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, req *ListSubscriptionsForAuthenticatedUserStubbedReq, opt ...requests.Option) (*ListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListSubscriptionsForAuthenticatedUserStubbedReq)
	}
	resp := &ListSubscriptionsForAuthenticatedUserStubbedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListSubscriptionsForAuthenticatedUserStubbedResponse(r, opts.PreserveResponseBody())
}

// NewListSubscriptionsForAuthenticatedUserStubbedResponse builds a new *ListSubscriptionsForAuthenticatedUserStubbedResponse from an *http.Response
func NewListSubscriptionsForAuthenticatedUserStubbedResponse(resp *http.Response, preserveBody bool) (*ListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	var result ListSubscriptionsForAuthenticatedUserStubbedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListSubscriptionsForAuthenticatedUserStubbed performs requests for "apps/list-subscriptions-for-authenticated-user-stubbed"

List subscriptions for the authenticated user (stubbed).

  GET /user/marketplace_purchases/stubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
func (c Client) ListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, req *ListSubscriptionsForAuthenticatedUserStubbedReq, opt ...requests.Option) (*ListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	return ListSubscriptionsForAuthenticatedUserStubbed(ctx, req, append(c, opt...)...)
}

/*
ListSubscriptionsForAuthenticatedUserStubbedReq is request data for Client.ListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type ListSubscriptionsForAuthenticatedUserStubbedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListSubscriptionsForAuthenticatedUserStubbedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListSubscriptionsForAuthenticatedUserStubbedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "apps/list-subscriptions-for-authenticated-user-stubbed",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/marketplace_purchases/stubbed"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListSubscriptionsForAuthenticatedUserStubbedReq) Rel(link string, resp *ListSubscriptionsForAuthenticatedUserStubbedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListSubscriptionsForAuthenticatedUserStubbedResponse is a response for ListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type ListSubscriptionsForAuthenticatedUserStubbedResponse struct {
	httpResponse *http.Response
	Data         []components.UserMarketplacePurchase
}

func (r *ListSubscriptionsForAuthenticatedUserStubbedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveRepoFromInstallation performs requests for "apps/remove-repo-from-installation"

Remove a repository from an app installation.

  DELETE /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
func RemoveRepoFromInstallation(ctx context.Context, req *RemoveRepoFromInstallationReq, opt ...requests.Option) (*RemoveRepoFromInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveRepoFromInstallationReq)
	}
	resp := &RemoveRepoFromInstallationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveRepoFromInstallationResponse(r, opts.PreserveResponseBody())
}

// NewRemoveRepoFromInstallationResponse builds a new *RemoveRepoFromInstallationResponse from an *http.Response
func NewRemoveRepoFromInstallationResponse(resp *http.Response, preserveBody bool) (*RemoveRepoFromInstallationResponse, error) {
	var result RemoveRepoFromInstallationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveRepoFromInstallation performs requests for "apps/remove-repo-from-installation"

Remove a repository from an app installation.

  DELETE /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
func (c Client) RemoveRepoFromInstallation(ctx context.Context, req *RemoveRepoFromInstallationReq, opt ...requests.Option) (*RemoveRepoFromInstallationResponse, error) {
	return RemoveRepoFromInstallation(ctx, req, append(c, opt...)...)
}

/*
RemoveRepoFromInstallationReq is request data for Client.RemoveRepoFromInstallation

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
type RemoveRepoFromInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	// repository_id parameter
	RepositoryId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *RemoveRepoFromInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveRepoFromInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "apps/remove-repo-from-installation",
		Previews:           map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews:   []string{"machine-man"},
		URLPath:            fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveRepoFromInstallationReq) Rel(link string, resp *RemoveRepoFromInstallationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveRepoFromInstallationResponse is a response for RemoveRepoFromInstallation

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
type RemoveRepoFromInstallationResponse struct {
	httpResponse *http.Response
}

func (r *RemoveRepoFromInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ResetAuthorization performs requests for "apps/reset-authorization"

Reset an authorization.

  POST /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
func ResetAuthorization(ctx context.Context, req *ResetAuthorizationReq, opt ...requests.Option) (*ResetAuthorizationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ResetAuthorizationReq)
	}
	resp := &ResetAuthorizationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewResetAuthorizationResponse(r, opts.PreserveResponseBody())
}

// NewResetAuthorizationResponse builds a new *ResetAuthorizationResponse from an *http.Response
func NewResetAuthorizationResponse(resp *http.Response, preserveBody bool) (*ResetAuthorizationResponse, error) {
	var result ResetAuthorizationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ResetAuthorization performs requests for "apps/reset-authorization"

Reset an authorization.

  POST /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
func (c Client) ResetAuthorization(ctx context.Context, req *ResetAuthorizationReq, opt ...requests.Option) (*ResetAuthorizationResponse, error) {
	return ResetAuthorization(ctx, req, append(c, opt...)...)
}

/*
ResetAuthorizationReq is request data for Client.ResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type ResetAuthorizationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request
func (r *ResetAuthorizationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ResetAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "POST",
		OperationID:        "apps/reset-authorization",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ResetAuthorizationReq) Rel(link string, resp *ResetAuthorizationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ResetAuthorizationResponse is a response for ResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type ResetAuthorizationResponse struct {
	httpResponse *http.Response
	Data         components.Authorization
}

func (r *ResetAuthorizationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ResetToken performs requests for "apps/reset-token"

Reset a token.

  PATCH /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
func ResetToken(ctx context.Context, req *ResetTokenReq, opt ...requests.Option) (*ResetTokenResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ResetTokenReq)
	}
	resp := &ResetTokenResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewResetTokenResponse(r, opts.PreserveResponseBody())
}

// NewResetTokenResponse builds a new *ResetTokenResponse from an *http.Response
func NewResetTokenResponse(resp *http.Response, preserveBody bool) (*ResetTokenResponse, error) {
	var result ResetTokenResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ResetToken performs requests for "apps/reset-token"

Reset a token.

  PATCH /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
func (c Client) ResetToken(ctx context.Context, req *ResetTokenReq, opt ...requests.Option) (*ResetTokenResponse, error) {
	return ResetToken(ctx, req, append(c, opt...)...)
}

/*
ResetTokenReq is request data for Client.ResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type ResetTokenReq struct {
	_url        string
	ClientId    string
	RequestBody ResetTokenReqBody
}

// HTTPRequest builds an *http.Request
func (r *ResetTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ResetTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "apps/reset-token",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/%v/token", r.ClientId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ResetTokenReq) Rel(link string, resp *ResetTokenResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ResetTokenReqBody is a request body for apps/reset-token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type ResetTokenReqBody struct {

	// The access_token of the OAuth application.
	AccessToken *string `json:"access_token"`
}

/*
ResetTokenResponse is a response for ResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type ResetTokenResponse struct {
	httpResponse *http.Response
	Data         components.Authorization
}

func (r *ResetTokenResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RevokeAuthorizationForApplication performs requests for "apps/revoke-authorization-for-application"

Revoke an authorization for an application.

  DELETE /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
func RevokeAuthorizationForApplication(ctx context.Context, req *RevokeAuthorizationForApplicationReq, opt ...requests.Option) (*RevokeAuthorizationForApplicationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RevokeAuthorizationForApplicationReq)
	}
	resp := &RevokeAuthorizationForApplicationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRevokeAuthorizationForApplicationResponse(r, opts.PreserveResponseBody())
}

// NewRevokeAuthorizationForApplicationResponse builds a new *RevokeAuthorizationForApplicationResponse from an *http.Response
func NewRevokeAuthorizationForApplicationResponse(resp *http.Response, preserveBody bool) (*RevokeAuthorizationForApplicationResponse, error) {
	var result RevokeAuthorizationForApplicationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RevokeAuthorizationForApplication performs requests for "apps/revoke-authorization-for-application"

Revoke an authorization for an application.

  DELETE /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
func (c Client) RevokeAuthorizationForApplication(ctx context.Context, req *RevokeAuthorizationForApplicationReq, opt ...requests.Option) (*RevokeAuthorizationForApplicationResponse, error) {
	return RevokeAuthorizationForApplication(ctx, req, append(c, opt...)...)
}

/*
RevokeAuthorizationForApplicationReq is request data for Client.RevokeAuthorizationForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
type RevokeAuthorizationForApplicationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request
func (r *RevokeAuthorizationForApplicationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RevokeAuthorizationForApplicationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "apps/revoke-authorization-for-application",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RevokeAuthorizationForApplicationReq) Rel(link string, resp *RevokeAuthorizationForApplicationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RevokeAuthorizationForApplicationResponse is a response for RevokeAuthorizationForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
type RevokeAuthorizationForApplicationResponse struct {
	httpResponse *http.Response
}

func (r *RevokeAuthorizationForApplicationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RevokeGrantForApplication performs requests for "apps/revoke-grant-for-application"

Revoke a grant for an application.

  DELETE /applications/{client_id}/grants/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
func RevokeGrantForApplication(ctx context.Context, req *RevokeGrantForApplicationReq, opt ...requests.Option) (*RevokeGrantForApplicationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RevokeGrantForApplicationReq)
	}
	resp := &RevokeGrantForApplicationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRevokeGrantForApplicationResponse(r, opts.PreserveResponseBody())
}

// NewRevokeGrantForApplicationResponse builds a new *RevokeGrantForApplicationResponse from an *http.Response
func NewRevokeGrantForApplicationResponse(resp *http.Response, preserveBody bool) (*RevokeGrantForApplicationResponse, error) {
	var result RevokeGrantForApplicationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RevokeGrantForApplication performs requests for "apps/revoke-grant-for-application"

Revoke a grant for an application.

  DELETE /applications/{client_id}/grants/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
func (c Client) RevokeGrantForApplication(ctx context.Context, req *RevokeGrantForApplicationReq, opt ...requests.Option) (*RevokeGrantForApplicationResponse, error) {
	return RevokeGrantForApplication(ctx, req, append(c, opt...)...)
}

/*
RevokeGrantForApplicationReq is request data for Client.RevokeGrantForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
type RevokeGrantForApplicationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request
func (r *RevokeGrantForApplicationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RevokeGrantForApplicationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "apps/revoke-grant-for-application",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/applications/%v/grants/%v", r.ClientId, r.AccessToken),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RevokeGrantForApplicationReq) Rel(link string, resp *RevokeGrantForApplicationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RevokeGrantForApplicationResponse is a response for RevokeGrantForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
type RevokeGrantForApplicationResponse struct {
	httpResponse *http.Response
}

func (r *RevokeGrantForApplicationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RevokeInstallationAccessToken performs requests for "apps/revoke-installation-access-token"

Revoke an installation access token.

  DELETE /installation/token

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
func RevokeInstallationAccessToken(ctx context.Context, req *RevokeInstallationAccessTokenReq, opt ...requests.Option) (*RevokeInstallationAccessTokenResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RevokeInstallationAccessTokenReq)
	}
	resp := &RevokeInstallationAccessTokenResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRevokeInstallationAccessTokenResponse(r, opts.PreserveResponseBody())
}

// NewRevokeInstallationAccessTokenResponse builds a new *RevokeInstallationAccessTokenResponse from an *http.Response
func NewRevokeInstallationAccessTokenResponse(resp *http.Response, preserveBody bool) (*RevokeInstallationAccessTokenResponse, error) {
	var result RevokeInstallationAccessTokenResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RevokeInstallationAccessToken performs requests for "apps/revoke-installation-access-token"

Revoke an installation access token.

  DELETE /installation/token

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
func (c Client) RevokeInstallationAccessToken(ctx context.Context, req *RevokeInstallationAccessTokenReq, opt ...requests.Option) (*RevokeInstallationAccessTokenResponse, error) {
	return RevokeInstallationAccessToken(ctx, req, append(c, opt...)...)
}

/*
RevokeInstallationAccessTokenReq is request data for Client.RevokeInstallationAccessToken

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
type RevokeInstallationAccessTokenReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *RevokeInstallationAccessTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RevokeInstallationAccessTokenReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "apps/revoke-installation-access-token",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/installation/token"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RevokeInstallationAccessTokenReq) Rel(link string, resp *RevokeInstallationAccessTokenResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RevokeInstallationAccessTokenResponse is a response for RevokeInstallationAccessToken

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
type RevokeInstallationAccessTokenResponse struct {
	httpResponse *http.Response
}

func (r *RevokeInstallationAccessTokenResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
SuspendInstallation performs requests for "apps/suspend-installation"

Suspend an app installation.

  PUT /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
func SuspendInstallation(ctx context.Context, req *SuspendInstallationReq, opt ...requests.Option) (*SuspendInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SuspendInstallationReq)
	}
	resp := &SuspendInstallationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewSuspendInstallationResponse(r, opts.PreserveResponseBody())
}

// NewSuspendInstallationResponse builds a new *SuspendInstallationResponse from an *http.Response
func NewSuspendInstallationResponse(resp *http.Response, preserveBody bool) (*SuspendInstallationResponse, error) {
	var result SuspendInstallationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
SuspendInstallation performs requests for "apps/suspend-installation"

Suspend an app installation.

  PUT /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
func (c Client) SuspendInstallation(ctx context.Context, req *SuspendInstallationReq, opt ...requests.Option) (*SuspendInstallationResponse, error) {
	return SuspendInstallation(ctx, req, append(c, opt...)...)
}

/*
SuspendInstallationReq is request data for Client.SuspendInstallation

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
type SuspendInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64
}

// HTTPRequest builds an *http.Request
func (r *SuspendInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SuspendInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "apps/suspend-installation",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SuspendInstallationReq) Rel(link string, resp *SuspendInstallationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SuspendInstallationResponse is a response for SuspendInstallation

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
type SuspendInstallationResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *SuspendInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UnsuspendInstallation performs requests for "apps/unsuspend-installation"

Unsuspend an app installation.

  DELETE /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
func UnsuspendInstallation(ctx context.Context, req *UnsuspendInstallationReq, opt ...requests.Option) (*UnsuspendInstallationResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnsuspendInstallationReq)
	}
	resp := &UnsuspendInstallationResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUnsuspendInstallationResponse(r, opts.PreserveResponseBody())
}

// NewUnsuspendInstallationResponse builds a new *UnsuspendInstallationResponse from an *http.Response
func NewUnsuspendInstallationResponse(resp *http.Response, preserveBody bool) (*UnsuspendInstallationResponse, error) {
	var result UnsuspendInstallationResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
UnsuspendInstallation performs requests for "apps/unsuspend-installation"

Unsuspend an app installation.

  DELETE /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
func (c Client) UnsuspendInstallation(ctx context.Context, req *UnsuspendInstallationReq, opt ...requests.Option) (*UnsuspendInstallationResponse, error) {
	return UnsuspendInstallation(ctx, req, append(c, opt...)...)
}

/*
UnsuspendInstallationReq is request data for Client.UnsuspendInstallation

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
type UnsuspendInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64
}

// HTTPRequest builds an *http.Request
func (r *UnsuspendInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnsuspendInstallationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "apps/unsuspend-installation",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnsuspendInstallationReq) Rel(link string, resp *UnsuspendInstallationResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnsuspendInstallationResponse is a response for UnsuspendInstallation

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
type UnsuspendInstallationResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *UnsuspendInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}
