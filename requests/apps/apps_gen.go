// Code generated by octo-go; DO NOT EDIT.

package apps

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

/*
AddRepoToInstallation performs requests for "apps/add-repo-to-installation"

Add a repository to an app installation.

  PUT /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
func AddRepoToInstallation(ctx context.Context, req *AddRepoToInstallationReq, opt ...requests.Option) (*AddRepoToInstallationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(AddRepoToInstallationReq)
	}
	resp := &AddRepoToInstallationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddRepoToInstallation performs requests for "apps/add-repo-to-installation"

Add a repository to an app installation.

  PUT /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) AddRepoToInstallation(ctx context.Context, req *AddRepoToInstallationReq, opt ...requests.Option) (*AddRepoToInstallationResponse, error) {
	return AddRepoToInstallation(ctx, req, append(c, opt...)...)
}

/*
AddRepoToInstallationReq is request data for Client.AddRepoToInstallation

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type AddRepoToInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	// repository_id parameter
	RepositoryId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *AddRepoToInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews:      []string{"machine-man"},
		ExplicitURL:      r._url,
		Method:           "PUT",
		Options:          opt,
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddRepoToInstallationReq) Rel(link string, resp *AddRepoToInstallationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddRepoToInstallationResponse is a response for AddRepoToInstallation

https://developer.github.com/v3/apps/installations/#add-a-repository-to-an-app-installation
*/
type AddRepoToInstallationResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *AddRepoToInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *AddRepoToInstallationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{204, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
CheckAuthorization performs requests for "apps/check-authorization"

Check an authorization.

  GET /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
func CheckAuthorization(ctx context.Context, req *CheckAuthorizationReq, opt ...requests.Option) (*CheckAuthorizationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CheckAuthorizationReq)
	}
	resp := &CheckAuthorizationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckAuthorization performs requests for "apps/check-authorization"

Check an authorization.

  GET /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CheckAuthorization(ctx context.Context, req *CheckAuthorizationReq, opt ...requests.Option) (*CheckAuthorizationResponse, error) {
	return CheckAuthorization(ctx, req, append(c, opt...)...)
}

/*
CheckAuthorizationReq is request data for Client.CheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CheckAuthorizationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CheckAuthorizationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": strPtr("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckAuthorizationReq) Rel(link string, resp *CheckAuthorizationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckAuthorizationResponse is a response for CheckAuthorization

https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization
*/
type CheckAuthorizationResponse struct {
	httpResponse *http.Response
	Data         components.Authorization
}

// HTTPResponse returns the *http.Response
func (r *CheckAuthorizationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CheckAuthorizationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
CheckToken performs requests for "apps/check-token"

Check a token.

  POST /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
func CheckToken(ctx context.Context, req *CheckTokenReq, opt ...requests.Option) (*CheckTokenResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CheckTokenReq)
	}
	resp := &CheckTokenResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckToken performs requests for "apps/check-token"

Check a token.

  POST /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CheckToken(ctx context.Context, req *CheckTokenReq, opt ...requests.Option) (*CheckTokenResponse, error) {
	return CheckToken(ctx, req, append(c, opt...)...)
}

/*
CheckTokenReq is request data for Client.CheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CheckTokenReq struct {
	_url        string
	ClientId    string
	RequestBody CheckTokenReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CheckTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       strPtr("application/json"),
			"content-type": strPtr("application/json"),
		},
		Method:  "POST",
		Options: opt,
		URLPath: fmt.Sprintf("/applications/%v/token", r.ClientId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckTokenReq) Rel(link string, resp *CheckTokenResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckTokenReqBody is a request body for apps/check-token

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type CheckTokenReqBody struct {

	// The access_token of the OAuth application.
	AccessToken *string `json:"access_token"`
}

/*
CheckTokenResponse is a response for CheckToken

https://developer.github.com/v3/apps/oauth_applications/#check-a-token
*/
type CheckTokenResponse struct {
	httpResponse *http.Response
	Data         components.Authorization
}

// HTTPResponse returns the *http.Response
func (r *CheckTokenResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CheckTokenResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
CreateContentAttachment performs requests for "apps/create-content-attachment"

Create a content attachment.

  POST /content_references/{content_reference_id}/attachments

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
func CreateContentAttachment(ctx context.Context, req *CreateContentAttachmentReq, opt ...requests.Option) (*CreateContentAttachmentResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CreateContentAttachmentReq)
	}
	resp := &CreateContentAttachmentResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateContentAttachment performs requests for "apps/create-content-attachment"

Create a content attachment.

  POST /content_references/{content_reference_id}/attachments

https://developer.github.com/v3/apps/installations/#create-a-content-attachment

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CreateContentAttachment(ctx context.Context, req *CreateContentAttachmentReq, opt ...requests.Option) (*CreateContentAttachmentResponse, error) {
	return CreateContentAttachment(ctx, req, append(c, opt...)...)
}

/*
CreateContentAttachmentReq is request data for Client.CreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CreateContentAttachmentReq struct {
	_url string

	// content_reference_id parameter
	ContentReferenceId int64
	RequestBody        CreateContentAttachmentReqBody

	/*
	To access the Content Attachments API during the preview period, you must set
	this to true.
	*/
	CorsairPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CreateContentAttachmentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews: []string{"corsair"},
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       strPtr("application/json"),
			"content-type": strPtr("application/json"),
		},
		Method:           "POST",
		Options:          opt,
		Previews:         map[string]bool{"corsair": r.CorsairPreview},
		RequiredPreviews: []string{"corsair"},
		URLPath:          fmt.Sprintf("/content_references/%v/attachments", r.ContentReferenceId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateContentAttachmentReq) Rel(link string, resp *CreateContentAttachmentResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateContentAttachmentReqBody is a request body for apps/create-content-attachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type CreateContentAttachmentReqBody struct {

	// The body of the attachment
	Body *string `json:"body"`

	// The title of the attachment
	Title *string `json:"title"`
}

/*
CreateContentAttachmentResponse is a response for CreateContentAttachment

https://developer.github.com/v3/apps/installations/#create-a-content-attachment
*/
type CreateContentAttachmentResponse struct {
	httpResponse *http.Response
	Data         components.ContentReferenceAttachment
}

// HTTPResponse returns the *http.Response
func (r *CreateContentAttachmentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CreateContentAttachmentResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
CreateFromManifest performs requests for "apps/create-from-manifest"

Create a GitHub App from a manifest.

  POST /app-manifests/{code}/conversions

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
func CreateFromManifest(ctx context.Context, req *CreateFromManifestReq, opt ...requests.Option) (*CreateFromManifestResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CreateFromManifestReq)
	}
	resp := &CreateFromManifestResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateFromManifest performs requests for "apps/create-from-manifest"

Create a GitHub App from a manifest.

  POST /app-manifests/{code}/conversions

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CreateFromManifest(ctx context.Context, req *CreateFromManifestReq, opt ...requests.Option) (*CreateFromManifestResponse, error) {
	return CreateFromManifest(ctx, req, append(c, opt...)...)
}

/*
CreateFromManifestReq is request data for Client.CreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CreateFromManifestReq struct {
	_url string

	// code parameter
	Code string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CreateFromManifestReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": strPtr("application/json")},
		Method:      "POST",
		Options:     opt,
		URLPath:     fmt.Sprintf("/app-manifests/%v/conversions", r.Code),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateFromManifestReq) Rel(link string, resp *CreateFromManifestResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateFromManifestResponseBody is a response body for CreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type CreateFromManifestResponseBody struct {
	ClientId     string `json:"client_id,omitempty"`
	ClientSecret string `json:"client_secret,omitempty"`
	CreatedAt    string `json:"created_at,omitempty"`
	Description  string `json:"description,omitempty"`

	// The list of events for the GitHub app
	Events      []string `json:"events,omitempty"`
	ExternalUrl string   `json:"external_url,omitempty"`
	HtmlUrl     string   `json:"html_url,omitempty"`

	// Unique identifier of the GitHub app
	Id int64 `json:"id,omitempty"`

	// The number of installations associated with the GitHub app
	InstallationsCount int64 `json:"installations_count,omitempty"`

	// The name of the GitHub app
	Name   string                `json:"name,omitempty"`
	NodeId string                `json:"node_id,omitempty"`
	Owner  components.SimpleUser `json:"owner,omitempty"`
	Pem    string                `json:"pem,omitempty"`

	// The set of permissions for the GitHub app
	Permissions map[string]string `json:"permissions,omitempty"`

	// The slug name of the GitHub app
	Slug          string `json:"slug,omitempty"`
	UpdatedAt     string `json:"updated_at,omitempty"`
	WebhookSecret string `json:"webhook_secret,omitempty"`
}

/*
CreateFromManifestResponse is a response for CreateFromManifest

https://developer.github.com/v3/apps/#create-a-github-app-from-a-manifest
*/
type CreateFromManifestResponse struct {
	httpResponse *http.Response
	Data         CreateFromManifestResponseBody
}

// HTTPResponse returns the *http.Response
func (r *CreateFromManifestResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CreateFromManifestResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{201})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{201}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
CreateInstallationAccessToken performs requests for "apps/create-installation-access-token"

Create an installation access token for an app.

  POST /app/installations/{installation_id}/access_tokens

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
func CreateInstallationAccessToken(ctx context.Context, req *CreateInstallationAccessTokenReq, opt ...requests.Option) (*CreateInstallationAccessTokenResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CreateInstallationAccessTokenReq)
	}
	resp := &CreateInstallationAccessTokenResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateInstallationAccessToken performs requests for "apps/create-installation-access-token"

Create an installation access token for an app.

  POST /app/installations/{installation_id}/access_tokens

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CreateInstallationAccessToken(ctx context.Context, req *CreateInstallationAccessTokenReq, opt ...requests.Option) (*CreateInstallationAccessTokenResponse, error) {
	return CreateInstallationAccessToken(ctx, req, append(c, opt...)...)
}

/*
CreateInstallationAccessTokenReq is request data for Client.CreateInstallationAccessToken

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CreateInstallationAccessTokenReq struct {
	_url string

	// installation_id parameter
	InstallationId int64
	RequestBody    CreateInstallationAccessTokenReqBody

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CreateInstallationAccessTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews: []string{"machine-man"},
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       strPtr("application/json"),
			"content-type": strPtr("application/json"),
		},
		Method:           "POST",
		Options:          opt,
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app/installations/%v/access_tokens", r.InstallationId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateInstallationAccessTokenReq) Rel(link string, resp *CreateInstallationAccessTokenResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateInstallationAccessTokenReqBodyPermissions is a value for CreateInstallationAccessTokenReqBody's Permissions field
type CreateInstallationAccessTokenReqBodyPermissions map[string]string

/*
CreateInstallationAccessTokenReqBody is a request body for apps/create-installation-access-token

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
type CreateInstallationAccessTokenReqBody struct {
	Permissions map[string]string `json:"permissions,omitempty"`

	// List of repository names that the token should have access to
	Repositories []string `json:"repositories,omitempty"`

	// List of repository IDs that the token should have access to
	RepositoryIds []int64 `json:"repository_ids,omitempty"`
}

/*
CreateInstallationAccessTokenResponse is a response for CreateInstallationAccessToken

https://developer.github.com/v3/apps/#create-an-installation-access-token-for-an-app
*/
type CreateInstallationAccessTokenResponse struct {
	httpResponse *http.Response
	Data         components.InstallationToken
}

// HTTPResponse returns the *http.Response
func (r *CreateInstallationAccessTokenResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CreateInstallationAccessTokenResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{201})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{201}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
DeleteAuthorization performs requests for "apps/delete-authorization"

Delete an app authorization.

  DELETE /applications/{client_id}/grant

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
func DeleteAuthorization(ctx context.Context, req *DeleteAuthorizationReq, opt ...requests.Option) (*DeleteAuthorizationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DeleteAuthorizationReq)
	}
	resp := &DeleteAuthorizationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteAuthorization performs requests for "apps/delete-authorization"

Delete an app authorization.

  DELETE /applications/{client_id}/grant

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) DeleteAuthorization(ctx context.Context, req *DeleteAuthorizationReq, opt ...requests.Option) (*DeleteAuthorizationResponse, error) {
	return DeleteAuthorization(ctx, req, append(c, opt...)...)
}

/*
DeleteAuthorizationReq is request data for Client.DeleteAuthorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DeleteAuthorizationReq struct {
	_url        string
	ClientId    string
	RequestBody DeleteAuthorizationReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DeleteAuthorizationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"content-type": strPtr("application/json")},
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/applications/%v/grant", r.ClientId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteAuthorizationReq) Rel(link string, resp *DeleteAuthorizationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteAuthorizationReqBody is a request body for apps/delete-authorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type DeleteAuthorizationReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
DeleteAuthorizationResponse is a response for DeleteAuthorization

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization
*/
type DeleteAuthorizationResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *DeleteAuthorizationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DeleteAuthorizationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteInstallation performs requests for "apps/delete-installation"

Delete an installation for the authenticated app.

  DELETE /app/installations/{installation_id}

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
func DeleteInstallation(ctx context.Context, req *DeleteInstallationReq, opt ...requests.Option) (*DeleteInstallationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DeleteInstallationReq)
	}
	resp := &DeleteInstallationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteInstallation performs requests for "apps/delete-installation"

Delete an installation for the authenticated app.

  DELETE /app/installations/{installation_id}

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) DeleteInstallation(ctx context.Context, req *DeleteInstallationReq, opt ...requests.Option) (*DeleteInstallationResponse, error) {
	return DeleteInstallation(ctx, req, append(c, opt...)...)
}

/*
DeleteInstallationReq is request data for Client.DeleteInstallation

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DeleteInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DeleteInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews:      []string{"machine-man"},
		ExplicitURL:      r._url,
		Method:           "DELETE",
		Options:          opt,
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app/installations/%v", r.InstallationId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteInstallationReq) Rel(link string, resp *DeleteInstallationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteInstallationResponse is a response for DeleteInstallation

https://developer.github.com/v3/apps/#delete-an-installation-for-the-authenticated-app
*/
type DeleteInstallationResponse struct {
	httpResponse *http.Response
	Data         bool
}

// HTTPResponse returns the *http.Response
func (r *DeleteInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DeleteInstallationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{204, 404})
	if err != nil {
		return err
	}
	err = setBoolResult(resp, &r.Data)
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteToken performs requests for "apps/delete-token"

Delete an app token.

  DELETE /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
func DeleteToken(ctx context.Context, req *DeleteTokenReq, opt ...requests.Option) (*DeleteTokenResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DeleteTokenReq)
	}
	resp := &DeleteTokenResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteToken performs requests for "apps/delete-token"

Delete an app token.

  DELETE /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) DeleteToken(ctx context.Context, req *DeleteTokenReq, opt ...requests.Option) (*DeleteTokenResponse, error) {
	return DeleteToken(ctx, req, append(c, opt...)...)
}

/*
DeleteTokenReq is request data for Client.DeleteToken

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DeleteTokenReq struct {
	_url        string
	ClientId    string
	RequestBody DeleteTokenReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DeleteTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"content-type": strPtr("application/json")},
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/applications/%v/token", r.ClientId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteTokenReq) Rel(link string, resp *DeleteTokenResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteTokenReqBody is a request body for apps/delete-token

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type DeleteTokenReqBody struct {

	// The OAuth access token used to authenticate to the GitHub API.
	AccessToken *string `json:"access_token,omitempty"`
}

/*
DeleteTokenResponse is a response for DeleteToken

https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token
*/
type DeleteTokenResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *DeleteTokenResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DeleteTokenResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
GetAuthenticated performs requests for "apps/get-authenticated"

Get the authenticated app.

  GET /app

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
func GetAuthenticated(ctx context.Context, req *GetAuthenticatedReq, opt ...requests.Option) (*GetAuthenticatedResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetAuthenticatedReq)
	}
	resp := &GetAuthenticatedResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetAuthenticated performs requests for "apps/get-authenticated"

Get the authenticated app.

  GET /app

https://developer.github.com/v3/apps/#get-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetAuthenticated(ctx context.Context, req *GetAuthenticatedReq, opt ...requests.Option) (*GetAuthenticatedResponse, error) {
	return GetAuthenticated(ctx, req, append(c, opt...)...)
}

/*
GetAuthenticatedReq is request data for Client.GetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetAuthenticatedReq struct {
	_url string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews:      []string{"machine-man"},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": strPtr("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app"),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetAuthenticatedReq) Rel(link string, resp *GetAuthenticatedResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetAuthenticatedResponse is a response for GetAuthenticated

https://developer.github.com/v3/apps/#get-the-authenticated-app
*/
type GetAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         components.Integration
}

// HTTPResponse returns the *http.Response
func (r *GetAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetAuthenticatedResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetBySlug performs requests for "apps/get-by-slug"

Get an app.

  GET /apps/{app_slug}

https://developer.github.com/v3/apps/#get-an-app
*/
func GetBySlug(ctx context.Context, req *GetBySlugReq, opt ...requests.Option) (*GetBySlugResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetBySlugReq)
	}
	resp := &GetBySlugResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetBySlug performs requests for "apps/get-by-slug"

Get an app.

  GET /apps/{app_slug}

https://developer.github.com/v3/apps/#get-an-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetBySlug(ctx context.Context, req *GetBySlugReq, opt ...requests.Option) (*GetBySlugResponse, error) {
	return GetBySlug(ctx, req, append(c, opt...)...)
}

/*
GetBySlugReq is request data for Client.GetBySlug

https://developer.github.com/v3/apps/#get-an-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetBySlugReq struct {
	_url string

	// app_slug parameter
	AppSlug string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetBySlugReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews:      []string{"machine-man"},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": strPtr("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/apps/%v", r.AppSlug),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetBySlugReq) Rel(link string, resp *GetBySlugResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetBySlugResponse is a response for GetBySlug

https://developer.github.com/v3/apps/#get-an-app
*/
type GetBySlugResponse struct {
	httpResponse *http.Response
	Data         components.Integration
}

// HTTPResponse returns the *http.Response
func (r *GetBySlugResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetBySlugResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetInstallation performs requests for "apps/get-installation"

Get an installation for the authenticated app.

  GET /app/installations/{installation_id}

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
func GetInstallation(ctx context.Context, req *GetInstallationReq, opt ...requests.Option) (*GetInstallationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetInstallationReq)
	}
	resp := &GetInstallationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetInstallation performs requests for "apps/get-installation"

Get an installation for the authenticated app.

  GET /app/installations/{installation_id}

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetInstallation(ctx context.Context, req *GetInstallationReq, opt ...requests.Option) (*GetInstallationResponse, error) {
	return GetInstallation(ctx, req, append(c, opt...)...)
}

/*
GetInstallationReq is request data for Client.GetInstallation

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews:      []string{"machine-man"},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": strPtr("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app/installations/%v", r.InstallationId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetInstallationReq) Rel(link string, resp *GetInstallationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetInstallationResponse is a response for GetInstallation

https://developer.github.com/v3/apps/#get-an-installation-for-the-authenticated-app
*/
type GetInstallationResponse struct {
	httpResponse *http.Response
	Data         components.Installation
}

// HTTPResponse returns the *http.Response
func (r *GetInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetInstallationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetOrgInstallation performs requests for "apps/get-org-installation"

Get an organization installation for the authenticated app.

  GET /orgs/{org}/installation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
func GetOrgInstallation(ctx context.Context, req *GetOrgInstallationReq, opt ...requests.Option) (*GetOrgInstallationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetOrgInstallationReq)
	}
	resp := &GetOrgInstallationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetOrgInstallation performs requests for "apps/get-org-installation"

Get an organization installation for the authenticated app.

  GET /orgs/{org}/installation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetOrgInstallation(ctx context.Context, req *GetOrgInstallationReq, opt ...requests.Option) (*GetOrgInstallationResponse, error) {
	return GetOrgInstallation(ctx, req, append(c, opt...)...)
}

/*
GetOrgInstallationReq is request data for Client.GetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetOrgInstallationReq struct {
	_url string
	Org  string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetOrgInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews:      []string{"machine-man"},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": strPtr("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/orgs/%v/installation", r.Org),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetOrgInstallationReq) Rel(link string, resp *GetOrgInstallationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetOrgInstallationResponse is a response for GetOrgInstallation

https://developer.github.com/v3/apps/#get-an-organization-installation-for-the-authenticated-app
*/
type GetOrgInstallationResponse struct {
	httpResponse *http.Response
	Data         components.Installation
}

// HTTPResponse returns the *http.Response
func (r *GetOrgInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetOrgInstallationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetRepoInstallation performs requests for "apps/get-repo-installation"

Get a repository installation for the authenticated app.

  GET /repos/{owner}/{repo}/installation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
func GetRepoInstallation(ctx context.Context, req *GetRepoInstallationReq, opt ...requests.Option) (*GetRepoInstallationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetRepoInstallationReq)
	}
	resp := &GetRepoInstallationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetRepoInstallation performs requests for "apps/get-repo-installation"

Get a repository installation for the authenticated app.

  GET /repos/{owner}/{repo}/installation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetRepoInstallation(ctx context.Context, req *GetRepoInstallationReq, opt ...requests.Option) (*GetRepoInstallationResponse, error) {
	return GetRepoInstallation(ctx, req, append(c, opt...)...)
}

/*
GetRepoInstallationReq is request data for Client.GetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetRepoInstallationReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetRepoInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews:      []string{"machine-man"},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": strPtr("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/installation", r.Owner, r.Repo),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetRepoInstallationReq) Rel(link string, resp *GetRepoInstallationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetRepoInstallationResponse is a response for GetRepoInstallation

https://developer.github.com/v3/apps/#get-a-repository-installation-for-the-authenticated-app
*/
type GetRepoInstallationResponse struct {
	httpResponse *http.Response
	Data         components.Installation
}

// HTTPResponse returns the *http.Response
func (r *GetRepoInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetRepoInstallationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200, 301})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetSubscriptionPlanForAccount performs requests for "apps/get-subscription-plan-for-account"

Get a subscription plan for an account.

  GET /marketplace_listing/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
func GetSubscriptionPlanForAccount(ctx context.Context, req *GetSubscriptionPlanForAccountReq, opt ...requests.Option) (*GetSubscriptionPlanForAccountResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetSubscriptionPlanForAccountReq)
	}
	resp := &GetSubscriptionPlanForAccountResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetSubscriptionPlanForAccount performs requests for "apps/get-subscription-plan-for-account"

Get a subscription plan for an account.

  GET /marketplace_listing/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetSubscriptionPlanForAccount(ctx context.Context, req *GetSubscriptionPlanForAccountReq, opt ...requests.Option) (*GetSubscriptionPlanForAccountResponse, error) {
	return GetSubscriptionPlanForAccount(ctx, req, append(c, opt...)...)
}

/*
GetSubscriptionPlanForAccountReq is request data for Client.GetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetSubscriptionPlanForAccountReq struct {
	_url string

	// account_id parameter
	AccountId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetSubscriptionPlanForAccountReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": strPtr("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/marketplace_listing/accounts/%v", r.AccountId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetSubscriptionPlanForAccountReq) Rel(link string, resp *GetSubscriptionPlanForAccountResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetSubscriptionPlanForAccountResponse is a response for GetSubscriptionPlanForAccount

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account
*/
type GetSubscriptionPlanForAccountResponse struct {
	httpResponse *http.Response
	Data         components.MarketplacePurchase
}

// HTTPResponse returns the *http.Response
func (r *GetSubscriptionPlanForAccountResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetSubscriptionPlanForAccountResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetSubscriptionPlanForAccountStubbed performs requests for "apps/get-subscription-plan-for-account-stubbed"

Get a subscription plan for an account (stubbed).

  GET /marketplace_listing/stubbed/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
func GetSubscriptionPlanForAccountStubbed(ctx context.Context, req *GetSubscriptionPlanForAccountStubbedReq, opt ...requests.Option) (*GetSubscriptionPlanForAccountStubbedResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetSubscriptionPlanForAccountStubbedReq)
	}
	resp := &GetSubscriptionPlanForAccountStubbedResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetSubscriptionPlanForAccountStubbed performs requests for "apps/get-subscription-plan-for-account-stubbed"

Get a subscription plan for an account (stubbed).

  GET /marketplace_listing/stubbed/accounts/{account_id}

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetSubscriptionPlanForAccountStubbed(ctx context.Context, req *GetSubscriptionPlanForAccountStubbedReq, opt ...requests.Option) (*GetSubscriptionPlanForAccountStubbedResponse, error) {
	return GetSubscriptionPlanForAccountStubbed(ctx, req, append(c, opt...)...)
}

/*
GetSubscriptionPlanForAccountStubbedReq is request data for Client.GetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetSubscriptionPlanForAccountStubbedReq struct {
	_url string

	// account_id parameter
	AccountId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetSubscriptionPlanForAccountStubbedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": strPtr("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/marketplace_listing/stubbed/accounts/%v", r.AccountId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetSubscriptionPlanForAccountStubbedReq) Rel(link string, resp *GetSubscriptionPlanForAccountStubbedResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetSubscriptionPlanForAccountStubbedResponse is a response for GetSubscriptionPlanForAccountStubbed

https://developer.github.com/v3/apps/marketplace/#get-a-subscription-plan-for-an-account-stubbed
*/
type GetSubscriptionPlanForAccountStubbedResponse struct {
	httpResponse *http.Response
	Data         components.MarketplacePurchase
}

// HTTPResponse returns the *http.Response
func (r *GetSubscriptionPlanForAccountStubbedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetSubscriptionPlanForAccountStubbedResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetUserInstallation performs requests for "apps/get-user-installation"

Get a user installation for the authenticated app.

  GET /users/{username}/installation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
func GetUserInstallation(ctx context.Context, req *GetUserInstallationReq, opt ...requests.Option) (*GetUserInstallationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetUserInstallationReq)
	}
	resp := &GetUserInstallationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetUserInstallation performs requests for "apps/get-user-installation"

Get a user installation for the authenticated app.

  GET /users/{username}/installation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetUserInstallation(ctx context.Context, req *GetUserInstallationReq, opt ...requests.Option) (*GetUserInstallationResponse, error) {
	return GetUserInstallation(ctx, req, append(c, opt...)...)
}

/*
GetUserInstallationReq is request data for Client.GetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetUserInstallationReq struct {
	_url     string
	Username string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetUserInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews:      []string{"machine-man"},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": strPtr("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/users/%v/installation", r.Username),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetUserInstallationReq) Rel(link string, resp *GetUserInstallationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetUserInstallationResponse is a response for GetUserInstallation

https://developer.github.com/v3/apps/#get-a-user-installation-for-the-authenticated-app
*/
type GetUserInstallationResponse struct {
	httpResponse *http.Response
	Data         components.Installation
}

// HTTPResponse returns the *http.Response
func (r *GetUserInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetUserInstallationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListAccountsForPlan performs requests for "apps/list-accounts-for-plan"

List accounts for a plan.

  GET /marketplace_listing/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
func ListAccountsForPlan(ctx context.Context, req *ListAccountsForPlanReq, opt ...requests.Option) (*ListAccountsForPlanResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListAccountsForPlanReq)
	}
	resp := &ListAccountsForPlanResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListAccountsForPlan performs requests for "apps/list-accounts-for-plan"

List accounts for a plan.

  GET /marketplace_listing/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListAccountsForPlan(ctx context.Context, req *ListAccountsForPlanReq, opt ...requests.Option) (*ListAccountsForPlanResponse, error) {
	return ListAccountsForPlan(ctx, req, append(c, opt...)...)
}

/*
ListAccountsForPlanReq is request data for Client.ListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListAccountsForPlanReq struct {
	_url string

	// plan_id parameter
	PlanId int64

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListAccountsForPlanReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": strPtr("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/marketplace_listing/plans/%v/accounts", r.PlanId),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListAccountsForPlanReq) Rel(link string, resp *ListAccountsForPlanResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListAccountsForPlanResponse is a response for ListAccountsForPlan

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan
*/
type ListAccountsForPlanResponse struct {
	httpResponse *http.Response
	Data         []components.MarketplacePurchase
}

// HTTPResponse returns the *http.Response
func (r *ListAccountsForPlanResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListAccountsForPlanResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListAccountsForPlanStubbed performs requests for "apps/list-accounts-for-plan-stubbed"

List accounts for a plan (stubbed).

  GET /marketplace_listing/stubbed/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
func ListAccountsForPlanStubbed(ctx context.Context, req *ListAccountsForPlanStubbedReq, opt ...requests.Option) (*ListAccountsForPlanStubbedResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListAccountsForPlanStubbedReq)
	}
	resp := &ListAccountsForPlanStubbedResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListAccountsForPlanStubbed performs requests for "apps/list-accounts-for-plan-stubbed"

List accounts for a plan (stubbed).

  GET /marketplace_listing/stubbed/plans/{plan_id}/accounts

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListAccountsForPlanStubbed(ctx context.Context, req *ListAccountsForPlanStubbedReq, opt ...requests.Option) (*ListAccountsForPlanStubbedResponse, error) {
	return ListAccountsForPlanStubbed(ctx, req, append(c, opt...)...)
}

/*
ListAccountsForPlanStubbedReq is request data for Client.ListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListAccountsForPlanStubbedReq struct {
	_url string

	// plan_id parameter
	PlanId int64

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	/*
	To return the oldest accounts first, set to `asc`. Can be one of `asc` or
	`desc`. Ignored without the `sort` parameter.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListAccountsForPlanStubbedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": strPtr("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/marketplace_listing/stubbed/plans/%v/accounts", r.PlanId),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListAccountsForPlanStubbedReq) Rel(link string, resp *ListAccountsForPlanStubbedResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListAccountsForPlanStubbedResponse is a response for ListAccountsForPlanStubbed

https://developer.github.com/v3/apps/marketplace/#list-accounts-for-a-plan-stubbed
*/
type ListAccountsForPlanStubbedResponse struct {
	httpResponse *http.Response
	Data         []components.MarketplacePurchase
}

// HTTPResponse returns the *http.Response
func (r *ListAccountsForPlanStubbedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListAccountsForPlanStubbedResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListInstallationReposForAuthenticatedUser performs requests for "apps/list-installation-repos-for-authenticated-user"

List repositories accessible to the user access token.

  GET /user/installations/{installation_id}/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
func ListInstallationReposForAuthenticatedUser(ctx context.Context, req *ListInstallationReposForAuthenticatedUserReq, opt ...requests.Option) (*ListInstallationReposForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListInstallationReposForAuthenticatedUserReq)
	}
	resp := &ListInstallationReposForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListInstallationReposForAuthenticatedUser performs requests for "apps/list-installation-repos-for-authenticated-user"

List repositories accessible to the user access token.

  GET /user/installations/{installation_id}/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListInstallationReposForAuthenticatedUser(ctx context.Context, req *ListInstallationReposForAuthenticatedUserReq, opt ...requests.Option) (*ListInstallationReposForAuthenticatedUserResponse, error) {
	return ListInstallationReposForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListInstallationReposForAuthenticatedUserReq is request data for Client.ListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListInstallationReposForAuthenticatedUserReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListInstallationReposForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews: []string{"machine-man", "mercy"},
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": strPtr("application/json")},
		Method:      "GET",
		Options:     opt,
		Previews: map[string]bool{
			"machine-man": r.MachineManPreview,
			"mercy":       r.MercyPreview,
		},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/user/installations/%v/repositories", r.InstallationId),
		URLQuery:         query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInstallationReposForAuthenticatedUserReq) Rel(link string, resp *ListInstallationReposForAuthenticatedUserResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInstallationReposForAuthenticatedUserResponseBody is a response body for ListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
type ListInstallationReposForAuthenticatedUserResponseBody struct {
	Repositories        []components.Repository `json:"repositories,omitempty"`
	RepositorySelection string                  `json:"repository_selection,omitempty"`
	TotalCount          int64                   `json:"total_count,omitempty"`
}

/*
ListInstallationReposForAuthenticatedUserResponse is a response for ListInstallationReposForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-user-access-token
*/
type ListInstallationReposForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         ListInstallationReposForAuthenticatedUserResponseBody
}

// HTTPResponse returns the *http.Response
func (r *ListInstallationReposForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListInstallationReposForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListInstallations performs requests for "apps/list-installations"

List installations for the authenticated app.

  GET /app/installations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
func ListInstallations(ctx context.Context, req *ListInstallationsReq, opt ...requests.Option) (*ListInstallationsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListInstallationsReq)
	}
	resp := &ListInstallationsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListInstallations performs requests for "apps/list-installations"

List installations for the authenticated app.

  GET /app/installations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListInstallations(ctx context.Context, req *ListInstallationsReq, opt ...requests.Option) (*ListInstallationsResponse, error) {
	return ListInstallations(ctx, req, append(c, opt...)...)
}

/*
ListInstallationsReq is request data for Client.ListInstallations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListInstallationsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since    *string
	Outdated *string

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListInstallationsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Outdated != nil {
		query.Set("outdated", *r.Outdated)
	}

	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews:      []string{"machine-man"},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": strPtr("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/app/installations"),
		URLQuery:         query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInstallationsReq) Rel(link string, resp *ListInstallationsResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInstallationsResponse is a response for ListInstallations

https://developer.github.com/v3/apps/#list-installations-for-the-authenticated-app
*/
type ListInstallationsResponse struct {
	httpResponse *http.Response
	Data         []components.Installation
}

// HTTPResponse returns the *http.Response
func (r *ListInstallationsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListInstallationsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListInstallationsForAuthenticatedUser performs requests for "apps/list-installations-for-authenticated-user"

List app installations accessible to the user access token.

  GET /user/installations

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
func ListInstallationsForAuthenticatedUser(ctx context.Context, req *ListInstallationsForAuthenticatedUserReq, opt ...requests.Option) (*ListInstallationsForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListInstallationsForAuthenticatedUserReq)
	}
	resp := &ListInstallationsForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListInstallationsForAuthenticatedUser performs requests for "apps/list-installations-for-authenticated-user"

List app installations accessible to the user access token.

  GET /user/installations

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListInstallationsForAuthenticatedUser(ctx context.Context, req *ListInstallationsForAuthenticatedUserReq, opt ...requests.Option) (*ListInstallationsForAuthenticatedUserResponse, error) {
	return ListInstallationsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListInstallationsForAuthenticatedUserReq is request data for Client.ListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListInstallationsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListInstallationsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews:      []string{"machine-man"},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": strPtr("application/json")},
		Method:           "GET",
		Options:          opt,
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/user/installations"),
		URLQuery:         query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListInstallationsForAuthenticatedUserReq) Rel(link string, resp *ListInstallationsForAuthenticatedUserResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListInstallationsForAuthenticatedUserResponseBody is a response body for ListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
type ListInstallationsForAuthenticatedUserResponseBody struct {
	Installations []components.Installation `json:"installations,omitempty"`
	TotalCount    int64                     `json:"total_count,omitempty"`
}

/*
ListInstallationsForAuthenticatedUserResponse is a response for ListInstallationsForAuthenticatedUser

https://developer.github.com/v3/apps/installations/#list-app-installations-accessible-to-the-user-access-token
*/
type ListInstallationsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         ListInstallationsForAuthenticatedUserResponseBody
}

// HTTPResponse returns the *http.Response
func (r *ListInstallationsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListInstallationsForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListPlans performs requests for "apps/list-plans"

List plans.

  GET /marketplace_listing/plans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
func ListPlans(ctx context.Context, req *ListPlansReq, opt ...requests.Option) (*ListPlansResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListPlansReq)
	}
	resp := &ListPlansResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPlans performs requests for "apps/list-plans"

List plans.

  GET /marketplace_listing/plans

https://developer.github.com/v3/apps/marketplace/#list-plans

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListPlans(ctx context.Context, req *ListPlansReq, opt ...requests.Option) (*ListPlansResponse, error) {
	return ListPlans(ctx, req, append(c, opt...)...)
}

/*
ListPlansReq is request data for Client.ListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListPlansReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListPlansReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": strPtr("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/marketplace_listing/plans"),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPlansReq) Rel(link string, resp *ListPlansResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPlansResponse is a response for ListPlans

https://developer.github.com/v3/apps/marketplace/#list-plans
*/
type ListPlansResponse struct {
	httpResponse *http.Response
	Data         []components.MarketplaceListingPlan
}

// HTTPResponse returns the *http.Response
func (r *ListPlansResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListPlansResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListPlansStubbed performs requests for "apps/list-plans-stubbed"

List plans (stubbed).

  GET /marketplace_listing/stubbed/plans

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
func ListPlansStubbed(ctx context.Context, req *ListPlansStubbedReq, opt ...requests.Option) (*ListPlansStubbedResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListPlansStubbedReq)
	}
	resp := &ListPlansStubbedResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPlansStubbed performs requests for "apps/list-plans-stubbed"

List plans (stubbed).

  GET /marketplace_listing/stubbed/plans

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListPlansStubbed(ctx context.Context, req *ListPlansStubbedReq, opt ...requests.Option) (*ListPlansStubbedResponse, error) {
	return ListPlansStubbed(ctx, req, append(c, opt...)...)
}

/*
ListPlansStubbedReq is request data for Client.ListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListPlansStubbedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListPlansStubbedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": strPtr("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/marketplace_listing/stubbed/plans"),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPlansStubbedReq) Rel(link string, resp *ListPlansStubbedResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPlansStubbedResponse is a response for ListPlansStubbed

https://developer.github.com/v3/apps/marketplace/#list-plans-stubbed
*/
type ListPlansStubbedResponse struct {
	httpResponse *http.Response
	Data         []components.MarketplaceListingPlan
}

// HTTPResponse returns the *http.Response
func (r *ListPlansStubbedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListPlansStubbedResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListReposAccessibleToInstallation performs requests for "apps/list-repos-accessible-to-installation"

List repositories accessible to the app installation.

  GET /installation/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
func ListReposAccessibleToInstallation(ctx context.Context, req *ListReposAccessibleToInstallationReq, opt ...requests.Option) (*ListReposAccessibleToInstallationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReposAccessibleToInstallationReq)
	}
	resp := &ListReposAccessibleToInstallationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListReposAccessibleToInstallation performs requests for "apps/list-repos-accessible-to-installation"

List repositories accessible to the app installation.

  GET /installation/repositories

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListReposAccessibleToInstallation(ctx context.Context, req *ListReposAccessibleToInstallationReq, opt ...requests.Option) (*ListReposAccessibleToInstallationResponse, error) {
	return ListReposAccessibleToInstallation(ctx, req, append(c, opt...)...)
}

/*
ListReposAccessibleToInstallationReq is request data for Client.ListReposAccessibleToInstallation

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReposAccessibleToInstallationReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	The `topics` property for repositories on GitHub is currently available for
	developers to preview. To view the `topics` property in calls that return
	repository results, you must set this to true.
	*/
	MercyPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReposAccessibleToInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews: []string{"machine-man", "mercy"},
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": strPtr("application/json")},
		Method:      "GET",
		Options:     opt,
		Previews: map[string]bool{
			"machine-man": r.MachineManPreview,
			"mercy":       r.MercyPreview,
		},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/installation/repositories"),
		URLQuery:         query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReposAccessibleToInstallationReq) Rel(link string, resp *ListReposAccessibleToInstallationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListReposAccessibleToInstallationResponseBody is a response body for ListReposAccessibleToInstallation

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
type ListReposAccessibleToInstallationResponseBody struct {
	Repositories        []components.Repository `json:"repositories,omitempty"`
	RepositorySelection string                  `json:"repository_selection,omitempty"`
	TotalCount          int64                   `json:"total_count,omitempty"`
}

/*
ListReposAccessibleToInstallationResponse is a response for ListReposAccessibleToInstallation

https://developer.github.com/v3/apps/installations/#list-repositories-accessible-to-the-app-installation
*/
type ListReposAccessibleToInstallationResponse struct {
	httpResponse *http.Response
	Data         ListReposAccessibleToInstallationResponseBody
}

// HTTPResponse returns the *http.Response
func (r *ListReposAccessibleToInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListReposAccessibleToInstallationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListSubscriptionsForAuthenticatedUser performs requests for "apps/list-subscriptions-for-authenticated-user"

List subscriptions for the authenticated user.

  GET /user/marketplace_purchases

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
func ListSubscriptionsForAuthenticatedUser(ctx context.Context, req *ListSubscriptionsForAuthenticatedUserReq, opt ...requests.Option) (*ListSubscriptionsForAuthenticatedUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListSubscriptionsForAuthenticatedUserReq)
	}
	resp := &ListSubscriptionsForAuthenticatedUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListSubscriptionsForAuthenticatedUser performs requests for "apps/list-subscriptions-for-authenticated-user"

List subscriptions for the authenticated user.

  GET /user/marketplace_purchases

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListSubscriptionsForAuthenticatedUser(ctx context.Context, req *ListSubscriptionsForAuthenticatedUserReq, opt ...requests.Option) (*ListSubscriptionsForAuthenticatedUserResponse, error) {
	return ListSubscriptionsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListSubscriptionsForAuthenticatedUserReq is request data for Client.ListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListSubscriptionsForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListSubscriptionsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": strPtr("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/user/marketplace_purchases"),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListSubscriptionsForAuthenticatedUserReq) Rel(link string, resp *ListSubscriptionsForAuthenticatedUserResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListSubscriptionsForAuthenticatedUserResponse is a response for ListSubscriptionsForAuthenticatedUser

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user
*/
type ListSubscriptionsForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.UserMarketplacePurchase
}

// HTTPResponse returns the *http.Response
func (r *ListSubscriptionsForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListSubscriptionsForAuthenticatedUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListSubscriptionsForAuthenticatedUserStubbed performs requests for "apps/list-subscriptions-for-authenticated-user-stubbed"

List subscriptions for the authenticated user (stubbed).

  GET /user/marketplace_purchases/stubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
func ListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, req *ListSubscriptionsForAuthenticatedUserStubbedReq, opt ...requests.Option) (*ListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListSubscriptionsForAuthenticatedUserStubbedReq)
	}
	resp := &ListSubscriptionsForAuthenticatedUserStubbedResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListSubscriptionsForAuthenticatedUserStubbed performs requests for "apps/list-subscriptions-for-authenticated-user-stubbed"

List subscriptions for the authenticated user (stubbed).

  GET /user/marketplace_purchases/stubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, req *ListSubscriptionsForAuthenticatedUserStubbedReq, opt ...requests.Option) (*ListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	return ListSubscriptionsForAuthenticatedUserStubbed(ctx, req, append(c, opt...)...)
}

/*
ListSubscriptionsForAuthenticatedUserStubbedReq is request data for Client.ListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListSubscriptionsForAuthenticatedUserStubbedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListSubscriptionsForAuthenticatedUserStubbedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": strPtr("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/user/marketplace_purchases/stubbed"),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListSubscriptionsForAuthenticatedUserStubbedReq) Rel(link string, resp *ListSubscriptionsForAuthenticatedUserStubbedResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListSubscriptionsForAuthenticatedUserStubbedResponse is a response for ListSubscriptionsForAuthenticatedUserStubbed

https://developer.github.com/v3/apps/marketplace/#list-subscriptions-for-the-authenticated-user-stubbed
*/
type ListSubscriptionsForAuthenticatedUserStubbedResponse struct {
	httpResponse *http.Response
	Data         []components.UserMarketplacePurchase
}

// HTTPResponse returns the *http.Response
func (r *ListSubscriptionsForAuthenticatedUserStubbedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListSubscriptionsForAuthenticatedUserStubbedResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
RemoveRepoFromInstallation performs requests for "apps/remove-repo-from-installation"

Remove a repository from an app installation.

  DELETE /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
func RemoveRepoFromInstallation(ctx context.Context, req *RemoveRepoFromInstallationReq, opt ...requests.Option) (*RemoveRepoFromInstallationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(RemoveRepoFromInstallationReq)
	}
	resp := &RemoveRepoFromInstallationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RemoveRepoFromInstallation performs requests for "apps/remove-repo-from-installation"

Remove a repository from an app installation.

  DELETE /user/installations/{installation_id}/repositories/{repository_id}

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) RemoveRepoFromInstallation(ctx context.Context, req *RemoveRepoFromInstallationReq, opt ...requests.Option) (*RemoveRepoFromInstallationResponse, error) {
	return RemoveRepoFromInstallation(ctx, req, append(c, opt...)...)
}

/*
RemoveRepoFromInstallationReq is request data for Client.RemoveRepoFromInstallation

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type RemoveRepoFromInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64

	// repository_id parameter
	RepositoryId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *RemoveRepoFromInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		AllPreviews:      []string{"machine-man"},
		ExplicitURL:      r._url,
		Method:           "DELETE",
		Options:          opt,
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/user/installations/%v/repositories/%v", r.InstallationId, r.RepositoryId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveRepoFromInstallationReq) Rel(link string, resp *RemoveRepoFromInstallationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveRepoFromInstallationResponse is a response for RemoveRepoFromInstallation

https://developer.github.com/v3/apps/installations/#remove-a-repository-from-an-app-installation
*/
type RemoveRepoFromInstallationResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *RemoveRepoFromInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *RemoveRepoFromInstallationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{204, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
ResetAuthorization performs requests for "apps/reset-authorization"

Reset an authorization.

  POST /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
func ResetAuthorization(ctx context.Context, req *ResetAuthorizationReq, opt ...requests.Option) (*ResetAuthorizationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ResetAuthorizationReq)
	}
	resp := &ResetAuthorizationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ResetAuthorization performs requests for "apps/reset-authorization"

Reset an authorization.

  POST /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ResetAuthorization(ctx context.Context, req *ResetAuthorizationReq, opt ...requests.Option) (*ResetAuthorizationResponse, error) {
	return ResetAuthorization(ctx, req, append(c, opt...)...)
}

/*
ResetAuthorizationReq is request data for Client.ResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ResetAuthorizationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ResetAuthorizationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": strPtr("application/json")},
		Method:      "POST",
		Options:     opt,
		URLPath:     fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ResetAuthorizationReq) Rel(link string, resp *ResetAuthorizationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ResetAuthorizationResponse is a response for ResetAuthorization

https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization
*/
type ResetAuthorizationResponse struct {
	httpResponse *http.Response
	Data         components.Authorization
}

// HTTPResponse returns the *http.Response
func (r *ResetAuthorizationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ResetAuthorizationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ResetToken performs requests for "apps/reset-token"

Reset a token.

  PATCH /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
func ResetToken(ctx context.Context, req *ResetTokenReq, opt ...requests.Option) (*ResetTokenResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ResetTokenReq)
	}
	resp := &ResetTokenResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ResetToken performs requests for "apps/reset-token"

Reset a token.

  PATCH /applications/{client_id}/token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ResetToken(ctx context.Context, req *ResetTokenReq, opt ...requests.Option) (*ResetTokenResponse, error) {
	return ResetToken(ctx, req, append(c, opt...)...)
}

/*
ResetTokenReq is request data for Client.ResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ResetTokenReq struct {
	_url        string
	ClientId    string
	RequestBody ResetTokenReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ResetTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       strPtr("application/json"),
			"content-type": strPtr("application/json"),
		},
		Method:  "PATCH",
		Options: opt,
		URLPath: fmt.Sprintf("/applications/%v/token", r.ClientId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ResetTokenReq) Rel(link string, resp *ResetTokenResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ResetTokenReqBody is a request body for apps/reset-token

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type ResetTokenReqBody struct {

	// The access_token of the OAuth application.
	AccessToken *string `json:"access_token"`
}

/*
ResetTokenResponse is a response for ResetToken

https://developer.github.com/v3/apps/oauth_applications/#reset-a-token
*/
type ResetTokenResponse struct {
	httpResponse *http.Response
	Data         components.Authorization
}

// HTTPResponse returns the *http.Response
func (r *ResetTokenResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ResetTokenResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if intInSlice(resp.StatusCode, []int{200}) {
		err = unmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
RevokeAuthorizationForApplication performs requests for "apps/revoke-authorization-for-application"

Revoke an authorization for an application.

  DELETE /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
func RevokeAuthorizationForApplication(ctx context.Context, req *RevokeAuthorizationForApplicationReq, opt ...requests.Option) (*RevokeAuthorizationForApplicationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(RevokeAuthorizationForApplicationReq)
	}
	resp := &RevokeAuthorizationForApplicationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RevokeAuthorizationForApplication performs requests for "apps/revoke-authorization-for-application"

Revoke an authorization for an application.

  DELETE /applications/{client_id}/tokens/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) RevokeAuthorizationForApplication(ctx context.Context, req *RevokeAuthorizationForApplicationReq, opt ...requests.Option) (*RevokeAuthorizationForApplicationResponse, error) {
	return RevokeAuthorizationForApplication(ctx, req, append(c, opt...)...)
}

/*
RevokeAuthorizationForApplicationReq is request data for Client.RevokeAuthorizationForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type RevokeAuthorizationForApplicationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *RevokeAuthorizationForApplicationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/applications/%v/tokens/%v", r.ClientId, r.AccessToken),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RevokeAuthorizationForApplicationReq) Rel(link string, resp *RevokeAuthorizationForApplicationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RevokeAuthorizationForApplicationResponse is a response for RevokeAuthorizationForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application
*/
type RevokeAuthorizationForApplicationResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *RevokeAuthorizationForApplicationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *RevokeAuthorizationForApplicationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
RevokeGrantForApplication performs requests for "apps/revoke-grant-for-application"

Revoke a grant for an application.

  DELETE /applications/{client_id}/grants/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
func RevokeGrantForApplication(ctx context.Context, req *RevokeGrantForApplicationReq, opt ...requests.Option) (*RevokeGrantForApplicationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(RevokeGrantForApplicationReq)
	}
	resp := &RevokeGrantForApplicationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RevokeGrantForApplication performs requests for "apps/revoke-grant-for-application"

Revoke a grant for an application.

  DELETE /applications/{client_id}/grants/{access_token}

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) RevokeGrantForApplication(ctx context.Context, req *RevokeGrantForApplicationReq, opt ...requests.Option) (*RevokeGrantForApplicationResponse, error) {
	return RevokeGrantForApplication(ctx, req, append(c, opt...)...)
}

/*
RevokeGrantForApplicationReq is request data for Client.RevokeGrantForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type RevokeGrantForApplicationReq struct {
	_url        string
	ClientId    string
	AccessToken string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *RevokeGrantForApplicationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/applications/%v/grants/%v", r.ClientId, r.AccessToken),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RevokeGrantForApplicationReq) Rel(link string, resp *RevokeGrantForApplicationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RevokeGrantForApplicationResponse is a response for RevokeGrantForApplication

https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application
*/
type RevokeGrantForApplicationResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *RevokeGrantForApplicationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *RevokeGrantForApplicationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
RevokeInstallationAccessToken performs requests for "apps/revoke-installation-access-token"

Revoke an installation access token.

  DELETE /installation/token

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
func RevokeInstallationAccessToken(ctx context.Context, req *RevokeInstallationAccessTokenReq, opt ...requests.Option) (*RevokeInstallationAccessTokenResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(RevokeInstallationAccessTokenReq)
	}
	resp := &RevokeInstallationAccessTokenResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
RevokeInstallationAccessToken performs requests for "apps/revoke-installation-access-token"

Revoke an installation access token.

  DELETE /installation/token

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) RevokeInstallationAccessToken(ctx context.Context, req *RevokeInstallationAccessTokenReq, opt ...requests.Option) (*RevokeInstallationAccessTokenResponse, error) {
	return RevokeInstallationAccessToken(ctx, req, append(c, opt...)...)
}

/*
RevokeInstallationAccessTokenReq is request data for Client.RevokeInstallationAccessToken

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type RevokeInstallationAccessTokenReq struct {
	_url string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *RevokeInstallationAccessTokenReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/installation/token"),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RevokeInstallationAccessTokenReq) Rel(link string, resp *RevokeInstallationAccessTokenResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RevokeInstallationAccessTokenResponse is a response for RevokeInstallationAccessToken

https://developer.github.com/v3/apps/installations/#revoke-an-installation-access-token
*/
type RevokeInstallationAccessTokenResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *RevokeInstallationAccessTokenResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *RevokeInstallationAccessTokenResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{204})
	if err != nil {
		return err
	}
	return nil
}

/*
SuspendInstallation performs requests for "apps/suspend-installation"

Suspend an app installation.

  PUT /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
func SuspendInstallation(ctx context.Context, req *SuspendInstallationReq, opt ...requests.Option) (*SuspendInstallationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(SuspendInstallationReq)
	}
	resp := &SuspendInstallationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SuspendInstallation performs requests for "apps/suspend-installation"

Suspend an app installation.

  PUT /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#suspend-an-app-installation

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) SuspendInstallation(ctx context.Context, req *SuspendInstallationReq, opt ...requests.Option) (*SuspendInstallationResponse, error) {
	return SuspendInstallation(ctx, req, append(c, opt...)...)
}

/*
SuspendInstallationReq is request data for Client.SuspendInstallation

https://developer.github.com/v3/apps/#suspend-an-app-installation

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type SuspendInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *SuspendInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		Method:      "PUT",
		Options:     opt,
		URLPath:     fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SuspendInstallationReq) Rel(link string, resp *SuspendInstallationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SuspendInstallationResponse is a response for SuspendInstallation

https://developer.github.com/v3/apps/#suspend-an-app-installation
*/
type SuspendInstallationResponse struct {
	httpResponse *http.Response
	Data         bool
}

// HTTPResponse returns the *http.Response
func (r *SuspendInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *SuspendInstallationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{204, 404})
	if err != nil {
		return err
	}
	err = setBoolResult(resp, &r.Data)
	if err != nil {
		return err
	}
	return nil
}

/*
UnsuspendInstallation performs requests for "apps/unsuspend-installation"

Unsuspend an app installation.

  DELETE /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
func UnsuspendInstallation(ctx context.Context, req *UnsuspendInstallationReq, opt ...requests.Option) (*UnsuspendInstallationResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UnsuspendInstallationReq)
	}
	resp := &UnsuspendInstallationResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UnsuspendInstallation performs requests for "apps/unsuspend-installation"

Unsuspend an app installation.

  DELETE /app/installations/{installation_id}/suspended

https://developer.github.com/v3/apps/#unsuspend-an-app-installation

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) UnsuspendInstallation(ctx context.Context, req *UnsuspendInstallationReq, opt ...requests.Option) (*UnsuspendInstallationResponse, error) {
	return UnsuspendInstallation(ctx, req, append(c, opt...)...)
}

/*
UnsuspendInstallationReq is request data for Client.UnsuspendInstallation

https://developer.github.com/v3/apps/#unsuspend-an-app-installation

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UnsuspendInstallationReq struct {
	_url string

	// installation_id parameter
	InstallationId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UnsuspendInstallationReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return buildHTTPRequest(ctx, buildHTTPRequestOptions{
		ExplicitURL: r._url,
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/app/installations/%v/suspended", r.InstallationId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnsuspendInstallationReq) Rel(link string, resp *UnsuspendInstallationResponse) bool {
	u := getRelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnsuspendInstallationResponse is a response for UnsuspendInstallation

https://developer.github.com/v3/apps/#unsuspend-an-app-installation
*/
type UnsuspendInstallationResponse struct {
	httpResponse *http.Response
	Data         bool
}

// HTTPResponse returns the *http.Response
func (r *UnsuspendInstallationResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UnsuspendInstallationResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := responseErrorCheck(resp, []int{204, 404})
	if err != nil {
		return err
	}
	err = setBoolResult(resp, &r.Data)
	if err != nil {
		return err
	}
	return nil
}
