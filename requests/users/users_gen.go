// Code generated by octo-go; DO NOT EDIT.

package users

import (
	"context"
	"encoding/json"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

// Apply implements options.Option
func (c Client) Apply(opts *requests.Options) error {
	for _, o := range c {
		err := o.Apply(opts)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
AddEmailForAuthenticated performs requests for "users/add-email-for-authenticated"

Add an email address for the authenticated user.

  POST /user/emails

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
func AddEmailForAuthenticated(ctx context.Context, req *AddEmailForAuthenticatedReq, opt ...requests.Option) (*AddEmailForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddEmailForAuthenticatedReq)
	}
	resp := &AddEmailForAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Email{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
AddEmailForAuthenticated performs requests for "users/add-email-for-authenticated"

Add an email address for the authenticated user.

  POST /user/emails

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
func (c Client) AddEmailForAuthenticated(ctx context.Context, req *AddEmailForAuthenticatedReq, opt ...requests.Option) (*AddEmailForAuthenticatedResponse, error) {
	return AddEmailForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
AddEmailForAuthenticatedReq is request data for Client.AddEmailForAuthenticated

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
type AddEmailForAuthenticatedReq struct {
	_url        string
	RequestBody AddEmailForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddEmailForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddEmailForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "users/add-email-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/emails"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddEmailForAuthenticatedReq) Rel(link string, resp *AddEmailForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddEmailForAuthenticatedReqBody is a request body for users/add-email-for-authenticated

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
type AddEmailForAuthenticatedReqBody struct {

	/*
	Adds one or more email addresses to your GitHub account. Must contain at least
	one email address. **Note:** Alternatively, you can pass a single email address
	or an `array` of emails addresses directly, but we recommend that you pass an
	object using the `emails` key.
	*/
	Emails []string `json:"emails"`
}

/*
AddEmailForAuthenticatedResponse is a response for AddEmailForAuthenticated

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
type AddEmailForAuthenticatedResponse struct {
	requests.Response
	request *AddEmailForAuthenticatedReq
	Data    []components.Email
}

/*
Block performs requests for "users/block"

Block a user.

  PUT /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#block-a-user
*/
func Block(ctx context.Context, req *BlockReq, opt ...requests.Option) (*BlockResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(BlockReq)
	}
	resp := &BlockResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Block performs requests for "users/block"

Block a user.

  PUT /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#block-a-user
*/
func (c Client) Block(ctx context.Context, req *BlockReq, opt ...requests.Option) (*BlockResponse, error) {
	return Block(ctx, req, append(c, opt...)...)
}

/*
BlockReq is request data for Client.Block

https://developer.github.com/v3/users/blocking/#block-a-user
*/
type BlockReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *BlockReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *BlockReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "users/block",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/blocks/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BlockReq) Rel(link string, resp *BlockResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BlockResponse is a response for Block

https://developer.github.com/v3/users/blocking/#block-a-user
*/
type BlockResponse struct {
	requests.Response
	request *BlockReq
}

/*
CheckBlocked performs requests for "users/check-blocked"

Check if a user is blocked by the authenticated user.

  GET /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
func CheckBlocked(ctx context.Context, req *CheckBlockedReq, opt ...requests.Option) (*CheckBlockedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckBlockedReq)
	}
	resp := &CheckBlockedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckBlocked performs requests for "users/check-blocked"

Check if a user is blocked by the authenticated user.

  GET /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
func (c Client) CheckBlocked(ctx context.Context, req *CheckBlockedReq, opt ...requests.Option) (*CheckBlockedResponse, error) {
	return CheckBlocked(ctx, req, append(c, opt...)...)
}

/*
CheckBlockedReq is request data for Client.CheckBlocked

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
type CheckBlockedReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *CheckBlockedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckBlockedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "users/check-blocked",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/blocks/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckBlockedReq) Rel(link string, resp *CheckBlockedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckBlockedResponse is a response for CheckBlocked

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
type CheckBlockedResponse struct {
	requests.Response
	request *CheckBlockedReq
}

/*
CheckFollowingForUser performs requests for "users/check-following-for-user"

Check if a user follows another user.

  GET /users/{username}/following/{target_user}

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
func CheckFollowingForUser(ctx context.Context, req *CheckFollowingForUserReq, opt ...requests.Option) (*CheckFollowingForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckFollowingForUserReq)
	}
	resp := &CheckFollowingForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckFollowingForUser performs requests for "users/check-following-for-user"

Check if a user follows another user.

  GET /users/{username}/following/{target_user}

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
func (c Client) CheckFollowingForUser(ctx context.Context, req *CheckFollowingForUserReq, opt ...requests.Option) (*CheckFollowingForUserResponse, error) {
	return CheckFollowingForUser(ctx, req, append(c, opt...)...)
}

/*
CheckFollowingForUserReq is request data for Client.CheckFollowingForUser

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
type CheckFollowingForUserReq struct {
	_url     string
	Username string

	// target_user parameter
	TargetUser string
}

// HTTPRequest builds an *http.Request
func (r *CheckFollowingForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckFollowingForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "users/check-following-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/following/%v", r.Username, r.TargetUser),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckFollowingForUserReq) Rel(link string, resp *CheckFollowingForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckFollowingForUserResponse is a response for CheckFollowingForUser

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
type CheckFollowingForUserResponse struct {
	requests.Response
	request *CheckFollowingForUserReq
	Data    bool
}

/*
CheckPersonIsFollowedByAuthenticated performs requests for "users/check-person-is-followed-by-authenticated"

Check if a person is followed by the authenticated user.

  GET /user/following/{username}

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
func CheckPersonIsFollowedByAuthenticated(ctx context.Context, req *CheckPersonIsFollowedByAuthenticatedReq, opt ...requests.Option) (*CheckPersonIsFollowedByAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckPersonIsFollowedByAuthenticatedReq)
	}
	resp := &CheckPersonIsFollowedByAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckPersonIsFollowedByAuthenticated performs requests for "users/check-person-is-followed-by-authenticated"

Check if a person is followed by the authenticated user.

  GET /user/following/{username}

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
func (c Client) CheckPersonIsFollowedByAuthenticated(ctx context.Context, req *CheckPersonIsFollowedByAuthenticatedReq, opt ...requests.Option) (*CheckPersonIsFollowedByAuthenticatedResponse, error) {
	return CheckPersonIsFollowedByAuthenticated(ctx, req, append(c, opt...)...)
}

/*
CheckPersonIsFollowedByAuthenticatedReq is request data for Client.CheckPersonIsFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
type CheckPersonIsFollowedByAuthenticatedReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *CheckPersonIsFollowedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckPersonIsFollowedByAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "users/check-person-is-followed-by-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/following/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckPersonIsFollowedByAuthenticatedReq) Rel(link string, resp *CheckPersonIsFollowedByAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckPersonIsFollowedByAuthenticatedResponse is a response for CheckPersonIsFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
type CheckPersonIsFollowedByAuthenticatedResponse struct {
	requests.Response
	request *CheckPersonIsFollowedByAuthenticatedReq
}

/*
CreateGpgKeyForAuthenticated performs requests for "users/create-gpg-key-for-authenticated"

Create a GPG key for the authenticated user.

  POST /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
func CreateGpgKeyForAuthenticated(ctx context.Context, req *CreateGpgKeyForAuthenticatedReq, opt ...requests.Option) (*CreateGpgKeyForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateGpgKeyForAuthenticatedReq)
	}
	resp := &CreateGpgKeyForAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GpgKey{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateGpgKeyForAuthenticated performs requests for "users/create-gpg-key-for-authenticated"

Create a GPG key for the authenticated user.

  POST /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
func (c Client) CreateGpgKeyForAuthenticated(ctx context.Context, req *CreateGpgKeyForAuthenticatedReq, opt ...requests.Option) (*CreateGpgKeyForAuthenticatedResponse, error) {
	return CreateGpgKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
CreateGpgKeyForAuthenticatedReq is request data for Client.CreateGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
type CreateGpgKeyForAuthenticatedReq struct {
	_url        string
	RequestBody CreateGpgKeyForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateGpgKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateGpgKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "users/create-gpg-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/gpg_keys"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateGpgKeyForAuthenticatedReq) Rel(link string, resp *CreateGpgKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateGpgKeyForAuthenticatedReqBody is a request body for users/create-gpg-key-for-authenticated

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
type CreateGpgKeyForAuthenticatedReqBody struct {

	// A GPG key in ASCII-armored format.
	ArmoredPublicKey *string `json:"armored_public_key"`
}

/*
CreateGpgKeyForAuthenticatedResponse is a response for CreateGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
type CreateGpgKeyForAuthenticatedResponse struct {
	requests.Response
	request *CreateGpgKeyForAuthenticatedReq
	Data    components.GpgKey
}

/*
CreatePublicSshKeyForAuthenticated performs requests for "users/create-public-ssh-key-for-authenticated"

Create a public SSH key for the authenticated user.

  POST /user/keys

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
func CreatePublicSshKeyForAuthenticated(ctx context.Context, req *CreatePublicSshKeyForAuthenticatedReq, opt ...requests.Option) (*CreatePublicSshKeyForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreatePublicSshKeyForAuthenticatedReq)
	}
	resp := &CreatePublicSshKeyForAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Key{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreatePublicSshKeyForAuthenticated performs requests for "users/create-public-ssh-key-for-authenticated"

Create a public SSH key for the authenticated user.

  POST /user/keys

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
func (c Client) CreatePublicSshKeyForAuthenticated(ctx context.Context, req *CreatePublicSshKeyForAuthenticatedReq, opt ...requests.Option) (*CreatePublicSshKeyForAuthenticatedResponse, error) {
	return CreatePublicSshKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
CreatePublicSshKeyForAuthenticatedReq is request data for Client.CreatePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
type CreatePublicSshKeyForAuthenticatedReq struct {
	_url        string
	RequestBody CreatePublicSshKeyForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreatePublicSshKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreatePublicSshKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "users/create-public-ssh-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/keys"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreatePublicSshKeyForAuthenticatedReq) Rel(link string, resp *CreatePublicSshKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreatePublicSshKeyForAuthenticatedReqBody is a request body for users/create-public-ssh-key-for-authenticated

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
type CreatePublicSshKeyForAuthenticatedReqBody struct {

	// The public SSH key to add to your GitHub account.
	Key *string `json:"key"`

	// A descriptive name for the new key.
	Title *string `json:"title,omitempty"`
}

/*
CreatePublicSshKeyForAuthenticatedResponse is a response for CreatePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
type CreatePublicSshKeyForAuthenticatedResponse struct {
	requests.Response
	request *CreatePublicSshKeyForAuthenticatedReq
	Data    components.Key
}

/*
DeleteEmailForAuthenticated performs requests for "users/delete-email-for-authenticated"

Delete an email address for the authenticated user.

  DELETE /user/emails

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
func DeleteEmailForAuthenticated(ctx context.Context, req *DeleteEmailForAuthenticatedReq, opt ...requests.Option) (*DeleteEmailForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteEmailForAuthenticatedReq)
	}
	resp := &DeleteEmailForAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteEmailForAuthenticated performs requests for "users/delete-email-for-authenticated"

Delete an email address for the authenticated user.

  DELETE /user/emails

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
func (c Client) DeleteEmailForAuthenticated(ctx context.Context, req *DeleteEmailForAuthenticatedReq, opt ...requests.Option) (*DeleteEmailForAuthenticatedResponse, error) {
	return DeleteEmailForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
DeleteEmailForAuthenticatedReq is request data for Client.DeleteEmailForAuthenticated

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
type DeleteEmailForAuthenticatedReq struct {
	_url        string
	RequestBody DeleteEmailForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *DeleteEmailForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteEmailForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": internal.String("application/json")},
		Method:           "DELETE",
		OperationID:      "users/delete-email-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/emails"),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteEmailForAuthenticatedReq) Rel(link string, resp *DeleteEmailForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteEmailForAuthenticatedReqBody is a request body for users/delete-email-for-authenticated

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
type DeleteEmailForAuthenticatedReqBody struct {

	// Email addresses associated with the GitHub user account.
	Emails []string `json:"emails"`
}

/*
DeleteEmailForAuthenticatedResponse is a response for DeleteEmailForAuthenticated

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
type DeleteEmailForAuthenticatedResponse struct {
	requests.Response
	request *DeleteEmailForAuthenticatedReq
}

/*
DeleteGpgKeyForAuthenticated performs requests for "users/delete-gpg-key-for-authenticated"

Delete a GPG key for the authenticated user.

  DELETE /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
func DeleteGpgKeyForAuthenticated(ctx context.Context, req *DeleteGpgKeyForAuthenticatedReq, opt ...requests.Option) (*DeleteGpgKeyForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteGpgKeyForAuthenticatedReq)
	}
	resp := &DeleteGpgKeyForAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteGpgKeyForAuthenticated performs requests for "users/delete-gpg-key-for-authenticated"

Delete a GPG key for the authenticated user.

  DELETE /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
func (c Client) DeleteGpgKeyForAuthenticated(ctx context.Context, req *DeleteGpgKeyForAuthenticatedReq, opt ...requests.Option) (*DeleteGpgKeyForAuthenticatedResponse, error) {
	return DeleteGpgKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
DeleteGpgKeyForAuthenticatedReq is request data for Client.DeleteGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
type DeleteGpgKeyForAuthenticatedReq struct {
	_url string

	// gpg_key_id parameter
	GpgKeyId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteGpgKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteGpgKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "users/delete-gpg-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/gpg_keys/%v", r.GpgKeyId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteGpgKeyForAuthenticatedReq) Rel(link string, resp *DeleteGpgKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteGpgKeyForAuthenticatedResponse is a response for DeleteGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
type DeleteGpgKeyForAuthenticatedResponse struct {
	requests.Response
	request *DeleteGpgKeyForAuthenticatedReq
}

/*
DeletePublicSshKeyForAuthenticated performs requests for "users/delete-public-ssh-key-for-authenticated"

Delete a public SSH key for the authenticated user.

  DELETE /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
func DeletePublicSshKeyForAuthenticated(ctx context.Context, req *DeletePublicSshKeyForAuthenticatedReq, opt ...requests.Option) (*DeletePublicSshKeyForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeletePublicSshKeyForAuthenticatedReq)
	}
	resp := &DeletePublicSshKeyForAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeletePublicSshKeyForAuthenticated performs requests for "users/delete-public-ssh-key-for-authenticated"

Delete a public SSH key for the authenticated user.

  DELETE /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
func (c Client) DeletePublicSshKeyForAuthenticated(ctx context.Context, req *DeletePublicSshKeyForAuthenticatedReq, opt ...requests.Option) (*DeletePublicSshKeyForAuthenticatedResponse, error) {
	return DeletePublicSshKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
DeletePublicSshKeyForAuthenticatedReq is request data for Client.DeletePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
type DeletePublicSshKeyForAuthenticatedReq struct {
	_url string

	// key_id parameter
	KeyId int64
}

// HTTPRequest builds an *http.Request
func (r *DeletePublicSshKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeletePublicSshKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "users/delete-public-ssh-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/keys/%v", r.KeyId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeletePublicSshKeyForAuthenticatedReq) Rel(link string, resp *DeletePublicSshKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeletePublicSshKeyForAuthenticatedResponse is a response for DeletePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
type DeletePublicSshKeyForAuthenticatedResponse struct {
	requests.Response
	request *DeletePublicSshKeyForAuthenticatedReq
}

/*
Follow performs requests for "users/follow"

Follow a user.

  PUT /user/following/{username}

https://developer.github.com/v3/users/followers/#follow-a-user
*/
func Follow(ctx context.Context, req *FollowReq, opt ...requests.Option) (*FollowResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(FollowReq)
	}
	resp := &FollowResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Follow performs requests for "users/follow"

Follow a user.

  PUT /user/following/{username}

https://developer.github.com/v3/users/followers/#follow-a-user
*/
func (c Client) Follow(ctx context.Context, req *FollowReq, opt ...requests.Option) (*FollowResponse, error) {
	return Follow(ctx, req, append(c, opt...)...)
}

/*
FollowReq is request data for Client.Follow

https://developer.github.com/v3/users/followers/#follow-a-user
*/
type FollowReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *FollowReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *FollowReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "users/follow",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/following/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *FollowReq) Rel(link string, resp *FollowResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
FollowResponse is a response for Follow

https://developer.github.com/v3/users/followers/#follow-a-user
*/
type FollowResponse struct {
	requests.Response
	request *FollowReq
}

/*
GetAuthenticated performs requests for "users/get-authenticated"

Get the authenticated user.

  GET /user

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
func GetAuthenticated(ctx context.Context, req *GetAuthenticatedReq, opt ...requests.Option) (*GetAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetAuthenticatedReq)
	}
	resp := &GetAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = GetAuthenticatedResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetAuthenticated performs requests for "users/get-authenticated"

Get the authenticated user.

  GET /user

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
func (c Client) GetAuthenticated(ctx context.Context, req *GetAuthenticatedReq, opt ...requests.Option) (*GetAuthenticatedResponse, error) {
	return GetAuthenticated(ctx, req, append(c, opt...)...)
}

/*
GetAuthenticatedReq is request data for Client.GetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type GetAuthenticatedReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *GetAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/get-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetAuthenticatedReq) Rel(link string, resp *GetAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetAuthenticatedResponseBody is a response body for GetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type GetAuthenticatedResponseBody struct {
	oneOfField string

	// Private User
	privateUser components.PrivateUser

	// Public User
	publicUser components.PublicUser
}

// Value returns GetAuthenticatedResponseBody's value. The type will be one of components.PrivateUser or components.PublicUser.
func (c *GetAuthenticatedResponseBody) Value() interface{} {
	switch c.oneOfField {
	case "privateUser":
		return c.privateUser
	case "publicUser":
		return c.publicUser
	}
	return nil
}

// SetValue sets GetAuthenticatedResponseBody's value. The type must be one of components.PrivateUser or components.PublicUser.
func (c *GetAuthenticatedResponseBody) SetValue(value interface{}) {
	switch v := value.(type) {
	case components.PrivateUser:
		c.privateUser = v
	case components.PublicUser:
		c.publicUser = v
	default:
		panic("type not acceptable")
	}
}

func (c *GetAuthenticatedResponseBody) MarshalJSON() ([]byte, error) {
	switch c.oneOfField {
	case "privateUser":
		return json.Marshal(&c.privateUser)
	case "publicUser":
		return json.Marshal(&c.publicUser)
	}
	return json.Marshal(interface{}(nil))
}

func (c *GetAuthenticatedResponseBody) UnmarshalJSON(data []byte) error {
	var err error
	err = json.Unmarshal(data, &c.privateUser)
	if err == nil {
		c.oneOfField = "privateUser"
		return nil
	}
	err = json.Unmarshal(data, &c.publicUser)
	if err == nil {
		c.oneOfField = "publicUser"
		return nil
	}
	return fmt.Errorf("could not unmarshal json")
}

/*
GetAuthenticatedResponse is a response for GetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type GetAuthenticatedResponse struct {
	requests.Response
	request *GetAuthenticatedReq
	Data    GetAuthenticatedResponseBody
}

/*
GetByUsername performs requests for "users/get-by-username"

Get a user.

  GET /users/{username}

https://developer.github.com/v3/users/#get-a-user
*/
func GetByUsername(ctx context.Context, req *GetByUsernameReq, opt ...requests.Option) (*GetByUsernameResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetByUsernameReq)
	}
	resp := &GetByUsernameResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = GetByUsernameResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetByUsername performs requests for "users/get-by-username"

Get a user.

  GET /users/{username}

https://developer.github.com/v3/users/#get-a-user
*/
func (c Client) GetByUsername(ctx context.Context, req *GetByUsernameReq, opt ...requests.Option) (*GetByUsernameResponse, error) {
	return GetByUsername(ctx, req, append(c, opt...)...)
}

/*
GetByUsernameReq is request data for Client.GetByUsername

https://developer.github.com/v3/users/#get-a-user
*/
type GetByUsernameReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetByUsernameReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetByUsernameReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/get-by-username",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetByUsernameReq) Rel(link string, resp *GetByUsernameResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetByUsernameResponseBody is a response body for GetByUsername

https://developer.github.com/v3/users/#get-a-user
*/
type GetByUsernameResponseBody struct {
	oneOfField string

	// Private User
	privateUser components.PrivateUser

	// Public User
	publicUser components.PublicUser
}

// Value returns GetByUsernameResponseBody's value. The type will be one of components.PrivateUser or components.PublicUser.
func (c *GetByUsernameResponseBody) Value() interface{} {
	switch c.oneOfField {
	case "privateUser":
		return c.privateUser
	case "publicUser":
		return c.publicUser
	}
	return nil
}

// SetValue sets GetByUsernameResponseBody's value. The type must be one of components.PrivateUser or components.PublicUser.
func (c *GetByUsernameResponseBody) SetValue(value interface{}) {
	switch v := value.(type) {
	case components.PrivateUser:
		c.privateUser = v
	case components.PublicUser:
		c.publicUser = v
	default:
		panic("type not acceptable")
	}
}

func (c *GetByUsernameResponseBody) MarshalJSON() ([]byte, error) {
	switch c.oneOfField {
	case "privateUser":
		return json.Marshal(&c.privateUser)
	case "publicUser":
		return json.Marshal(&c.publicUser)
	}
	return json.Marshal(interface{}(nil))
}

func (c *GetByUsernameResponseBody) UnmarshalJSON(data []byte) error {
	var err error
	err = json.Unmarshal(data, &c.privateUser)
	if err == nil {
		c.oneOfField = "privateUser"
		return nil
	}
	err = json.Unmarshal(data, &c.publicUser)
	if err == nil {
		c.oneOfField = "publicUser"
		return nil
	}
	return fmt.Errorf("could not unmarshal json")
}

/*
GetByUsernameResponse is a response for GetByUsername

https://developer.github.com/v3/users/#get-a-user
*/
type GetByUsernameResponse struct {
	requests.Response
	request *GetByUsernameReq
	Data    GetByUsernameResponseBody
}

/*
GetContextForUser performs requests for "users/get-context-for-user"

Get contextual information for a user.

  GET /users/{username}/hovercard

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
func GetContextForUser(ctx context.Context, req *GetContextForUserReq, opt ...requests.Option) (*GetContextForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetContextForUserReq)
	}
	resp := &GetContextForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Hovercard{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetContextForUser performs requests for "users/get-context-for-user"

Get contextual information for a user.

  GET /users/{username}/hovercard

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
func (c Client) GetContextForUser(ctx context.Context, req *GetContextForUserReq, opt ...requests.Option) (*GetContextForUserResponse, error) {
	return GetContextForUser(ctx, req, append(c, opt...)...)
}

/*
GetContextForUserReq is request data for Client.GetContextForUser

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
type GetContextForUserReq struct {
	_url     string
	Username string

	/*
	Identifies which additional information you'd like to receive about the person's
	hovercard. Can be `organization`, `repository`, `issue`, `pull_request`.
	**Required** when using `subject_id`.
	*/
	SubjectType *string

	/*
	Uses the ID for the `subject_type` you specified. **Required** when using
	`subject_type`.
	*/
	SubjectId *string
}

// HTTPRequest builds an *http.Request
func (r *GetContextForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetContextForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.SubjectType != nil {
		query.Set("subject_type", *r.SubjectType)
	}
	if r.SubjectId != nil {
		query.Set("subject_id", *r.SubjectId)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/get-context-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/hovercard", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetContextForUserReq) Rel(link string, resp *GetContextForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetContextForUserResponse is a response for GetContextForUser

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
type GetContextForUserResponse struct {
	requests.Response
	request *GetContextForUserReq
	Data    components.Hovercard
}

/*
GetGpgKeyForAuthenticated performs requests for "users/get-gpg-key-for-authenticated"

Get a GPG key for the authenticated user.

  GET /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
func GetGpgKeyForAuthenticated(ctx context.Context, req *GetGpgKeyForAuthenticatedReq, opt ...requests.Option) (*GetGpgKeyForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetGpgKeyForAuthenticatedReq)
	}
	resp := &GetGpgKeyForAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GpgKey{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetGpgKeyForAuthenticated performs requests for "users/get-gpg-key-for-authenticated"

Get a GPG key for the authenticated user.

  GET /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
func (c Client) GetGpgKeyForAuthenticated(ctx context.Context, req *GetGpgKeyForAuthenticatedReq, opt ...requests.Option) (*GetGpgKeyForAuthenticatedResponse, error) {
	return GetGpgKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
GetGpgKeyForAuthenticatedReq is request data for Client.GetGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
type GetGpgKeyForAuthenticatedReq struct {
	_url string

	// gpg_key_id parameter
	GpgKeyId int64
}

// HTTPRequest builds an *http.Request
func (r *GetGpgKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetGpgKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/get-gpg-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/gpg_keys/%v", r.GpgKeyId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetGpgKeyForAuthenticatedReq) Rel(link string, resp *GetGpgKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetGpgKeyForAuthenticatedResponse is a response for GetGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
type GetGpgKeyForAuthenticatedResponse struct {
	requests.Response
	request *GetGpgKeyForAuthenticatedReq
	Data    components.GpgKey
}

/*
GetPublicSshKeyForAuthenticated performs requests for "users/get-public-ssh-key-for-authenticated"

Get a public SSH key for the authenticated user.

  GET /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
func GetPublicSshKeyForAuthenticated(ctx context.Context, req *GetPublicSshKeyForAuthenticatedReq, opt ...requests.Option) (*GetPublicSshKeyForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetPublicSshKeyForAuthenticatedReq)
	}
	resp := &GetPublicSshKeyForAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Key{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetPublicSshKeyForAuthenticated performs requests for "users/get-public-ssh-key-for-authenticated"

Get a public SSH key for the authenticated user.

  GET /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
func (c Client) GetPublicSshKeyForAuthenticated(ctx context.Context, req *GetPublicSshKeyForAuthenticatedReq, opt ...requests.Option) (*GetPublicSshKeyForAuthenticatedResponse, error) {
	return GetPublicSshKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
GetPublicSshKeyForAuthenticatedReq is request data for Client.GetPublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
type GetPublicSshKeyForAuthenticatedReq struct {
	_url string

	// key_id parameter
	KeyId int64
}

// HTTPRequest builds an *http.Request
func (r *GetPublicSshKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetPublicSshKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/get-public-ssh-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/keys/%v", r.KeyId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetPublicSshKeyForAuthenticatedReq) Rel(link string, resp *GetPublicSshKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetPublicSshKeyForAuthenticatedResponse is a response for GetPublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
type GetPublicSshKeyForAuthenticatedResponse struct {
	requests.Response
	request *GetPublicSshKeyForAuthenticatedReq
	Data    components.Key
}

/*
List performs requests for "users/list"

List users.

  GET /users

https://developer.github.com/v3/users/#list-users
*/
func List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReq)
	}
	resp := &ListResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
List performs requests for "users/list"

List users.

  GET /users

https://developer.github.com/v3/users/#list-users
*/
func (c Client) List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	return List(ctx, req, append(c, opt...)...)
}

/*
ListReq is request data for Client.List

https://developer.github.com/v3/users/#list-users
*/
type ListReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/list",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReq) Rel(link string, resp *ListResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListResponse is a response for List

https://developer.github.com/v3/users/#list-users
*/
type ListResponse struct {
	requests.Response
	request *ListReq
	Data    []components.SimpleUser
}

/*
ListBlockedByAuthenticated performs requests for "users/list-blocked-by-authenticated"

List users blocked by the authenticated user.

  GET /user/blocks

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
func ListBlockedByAuthenticated(ctx context.Context, req *ListBlockedByAuthenticatedReq, opt ...requests.Option) (*ListBlockedByAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListBlockedByAuthenticatedReq)
	}
	resp := &ListBlockedByAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListBlockedByAuthenticated performs requests for "users/list-blocked-by-authenticated"

List users blocked by the authenticated user.

  GET /user/blocks

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
func (c Client) ListBlockedByAuthenticated(ctx context.Context, req *ListBlockedByAuthenticatedReq, opt ...requests.Option) (*ListBlockedByAuthenticatedResponse, error) {
	return ListBlockedByAuthenticated(ctx, req, append(c, opt...)...)
}

/*
ListBlockedByAuthenticatedReq is request data for Client.ListBlockedByAuthenticated

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
type ListBlockedByAuthenticatedReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *ListBlockedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListBlockedByAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-blocked-by-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/blocks"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListBlockedByAuthenticatedReq) Rel(link string, resp *ListBlockedByAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListBlockedByAuthenticatedResponse is a response for ListBlockedByAuthenticated

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
type ListBlockedByAuthenticatedResponse struct {
	requests.Response
	request *ListBlockedByAuthenticatedReq
	Data    []components.SimpleUser
}

/*
ListEmailsForAuthenticated performs requests for "users/list-emails-for-authenticated"

List email addresses for the authenticated user.

  GET /user/emails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
func ListEmailsForAuthenticated(ctx context.Context, req *ListEmailsForAuthenticatedReq, opt ...requests.Option) (*ListEmailsForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListEmailsForAuthenticatedReq)
	}
	resp := &ListEmailsForAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Email{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListEmailsForAuthenticated performs requests for "users/list-emails-for-authenticated"

List email addresses for the authenticated user.

  GET /user/emails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
func (c Client) ListEmailsForAuthenticated(ctx context.Context, req *ListEmailsForAuthenticatedReq, opt ...requests.Option) (*ListEmailsForAuthenticatedResponse, error) {
	return ListEmailsForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
ListEmailsForAuthenticatedReq is request data for Client.ListEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
type ListEmailsForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListEmailsForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListEmailsForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-emails-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/emails"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListEmailsForAuthenticatedReq) Rel(link string, resp *ListEmailsForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListEmailsForAuthenticatedResponse is a response for ListEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
type ListEmailsForAuthenticatedResponse struct {
	requests.Response
	request *ListEmailsForAuthenticatedReq
	Data    []components.Email
}

/*
ListFollowedByAuthenticated performs requests for "users/list-followed-by-authenticated"

List the people the authenticated user follows.

  GET /user/following

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
func ListFollowedByAuthenticated(ctx context.Context, req *ListFollowedByAuthenticatedReq, opt ...requests.Option) (*ListFollowedByAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListFollowedByAuthenticatedReq)
	}
	resp := &ListFollowedByAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListFollowedByAuthenticated performs requests for "users/list-followed-by-authenticated"

List the people the authenticated user follows.

  GET /user/following

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
func (c Client) ListFollowedByAuthenticated(ctx context.Context, req *ListFollowedByAuthenticatedReq, opt ...requests.Option) (*ListFollowedByAuthenticatedResponse, error) {
	return ListFollowedByAuthenticated(ctx, req, append(c, opt...)...)
}

/*
ListFollowedByAuthenticatedReq is request data for Client.ListFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
type ListFollowedByAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListFollowedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListFollowedByAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-followed-by-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/following"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListFollowedByAuthenticatedReq) Rel(link string, resp *ListFollowedByAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListFollowedByAuthenticatedResponse is a response for ListFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
type ListFollowedByAuthenticatedResponse struct {
	requests.Response
	request *ListFollowedByAuthenticatedReq
	Data    []components.SimpleUser
}

/*
ListFollowersForAuthenticatedUser performs requests for "users/list-followers-for-authenticated-user"

List followers of the authenticated user.

  GET /user/followers

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
func ListFollowersForAuthenticatedUser(ctx context.Context, req *ListFollowersForAuthenticatedUserReq, opt ...requests.Option) (*ListFollowersForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListFollowersForAuthenticatedUserReq)
	}
	resp := &ListFollowersForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListFollowersForAuthenticatedUser performs requests for "users/list-followers-for-authenticated-user"

List followers of the authenticated user.

  GET /user/followers

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
func (c Client) ListFollowersForAuthenticatedUser(ctx context.Context, req *ListFollowersForAuthenticatedUserReq, opt ...requests.Option) (*ListFollowersForAuthenticatedUserResponse, error) {
	return ListFollowersForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListFollowersForAuthenticatedUserReq is request data for Client.ListFollowersForAuthenticatedUser

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type ListFollowersForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListFollowersForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListFollowersForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-followers-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/followers"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListFollowersForAuthenticatedUserReq) Rel(link string, resp *ListFollowersForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListFollowersForAuthenticatedUserResponse is a response for ListFollowersForAuthenticatedUser

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type ListFollowersForAuthenticatedUserResponse struct {
	requests.Response
	request *ListFollowersForAuthenticatedUserReq
	Data    []components.SimpleUser
}

/*
ListFollowersForUser performs requests for "users/list-followers-for-user"

List followers of a user.

  GET /users/{username}/followers

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
func ListFollowersForUser(ctx context.Context, req *ListFollowersForUserReq, opt ...requests.Option) (*ListFollowersForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListFollowersForUserReq)
	}
	resp := &ListFollowersForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListFollowersForUser performs requests for "users/list-followers-for-user"

List followers of a user.

  GET /users/{username}/followers

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
func (c Client) ListFollowersForUser(ctx context.Context, req *ListFollowersForUserReq, opt ...requests.Option) (*ListFollowersForUserResponse, error) {
	return ListFollowersForUser(ctx, req, append(c, opt...)...)
}

/*
ListFollowersForUserReq is request data for Client.ListFollowersForUser

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type ListFollowersForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListFollowersForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListFollowersForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-followers-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/followers", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListFollowersForUserReq) Rel(link string, resp *ListFollowersForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListFollowersForUserResponse is a response for ListFollowersForUser

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type ListFollowersForUserResponse struct {
	requests.Response
	request *ListFollowersForUserReq
	Data    []components.SimpleUser
}

/*
ListFollowingForUser performs requests for "users/list-following-for-user"

List the people a user follows.

  GET /users/{username}/following

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
func ListFollowingForUser(ctx context.Context, req *ListFollowingForUserReq, opt ...requests.Option) (*ListFollowingForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListFollowingForUserReq)
	}
	resp := &ListFollowingForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListFollowingForUser performs requests for "users/list-following-for-user"

List the people a user follows.

  GET /users/{username}/following

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
func (c Client) ListFollowingForUser(ctx context.Context, req *ListFollowingForUserReq, opt ...requests.Option) (*ListFollowingForUserResponse, error) {
	return ListFollowingForUser(ctx, req, append(c, opt...)...)
}

/*
ListFollowingForUserReq is request data for Client.ListFollowingForUser

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
type ListFollowingForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListFollowingForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListFollowingForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-following-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/following", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListFollowingForUserReq) Rel(link string, resp *ListFollowingForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListFollowingForUserResponse is a response for ListFollowingForUser

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
type ListFollowingForUserResponse struct {
	requests.Response
	request *ListFollowingForUserReq
	Data    []components.SimpleUser
}

/*
ListGpgKeysForAuthenticated performs requests for "users/list-gpg-keys-for-authenticated"

List GPG keys for the authenticated user.

  GET /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
func ListGpgKeysForAuthenticated(ctx context.Context, req *ListGpgKeysForAuthenticatedReq, opt ...requests.Option) (*ListGpgKeysForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListGpgKeysForAuthenticatedReq)
	}
	resp := &ListGpgKeysForAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.GpgKey{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListGpgKeysForAuthenticated performs requests for "users/list-gpg-keys-for-authenticated"

List GPG keys for the authenticated user.

  GET /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
func (c Client) ListGpgKeysForAuthenticated(ctx context.Context, req *ListGpgKeysForAuthenticatedReq, opt ...requests.Option) (*ListGpgKeysForAuthenticatedResponse, error) {
	return ListGpgKeysForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
ListGpgKeysForAuthenticatedReq is request data for Client.ListGpgKeysForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
type ListGpgKeysForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListGpgKeysForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListGpgKeysForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-gpg-keys-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/gpg_keys"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListGpgKeysForAuthenticatedReq) Rel(link string, resp *ListGpgKeysForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListGpgKeysForAuthenticatedResponse is a response for ListGpgKeysForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
type ListGpgKeysForAuthenticatedResponse struct {
	requests.Response
	request *ListGpgKeysForAuthenticatedReq
	Data    []components.GpgKey
}

/*
ListGpgKeysForUser performs requests for "users/list-gpg-keys-for-user"

List GPG keys for a user.

  GET /users/{username}/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
func ListGpgKeysForUser(ctx context.Context, req *ListGpgKeysForUserReq, opt ...requests.Option) (*ListGpgKeysForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListGpgKeysForUserReq)
	}
	resp := &ListGpgKeysForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.GpgKey{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListGpgKeysForUser performs requests for "users/list-gpg-keys-for-user"

List GPG keys for a user.

  GET /users/{username}/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
func (c Client) ListGpgKeysForUser(ctx context.Context, req *ListGpgKeysForUserReq, opt ...requests.Option) (*ListGpgKeysForUserResponse, error) {
	return ListGpgKeysForUser(ctx, req, append(c, opt...)...)
}

/*
ListGpgKeysForUserReq is request data for Client.ListGpgKeysForUser

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type ListGpgKeysForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListGpgKeysForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListGpgKeysForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-gpg-keys-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/gpg_keys", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListGpgKeysForUserReq) Rel(link string, resp *ListGpgKeysForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListGpgKeysForUserResponse is a response for ListGpgKeysForUser

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type ListGpgKeysForUserResponse struct {
	requests.Response
	request *ListGpgKeysForUserReq
	Data    []components.GpgKey
}

/*
ListPublicEmailsForAuthenticated performs requests for "users/list-public-emails-for-authenticated"

List public email addresses for the authenticated user.

  GET /user/public_emails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
func ListPublicEmailsForAuthenticated(ctx context.Context, req *ListPublicEmailsForAuthenticatedReq, opt ...requests.Option) (*ListPublicEmailsForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicEmailsForAuthenticatedReq)
	}
	resp := &ListPublicEmailsForAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Email{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublicEmailsForAuthenticated performs requests for "users/list-public-emails-for-authenticated"

List public email addresses for the authenticated user.

  GET /user/public_emails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
func (c Client) ListPublicEmailsForAuthenticated(ctx context.Context, req *ListPublicEmailsForAuthenticatedReq, opt ...requests.Option) (*ListPublicEmailsForAuthenticatedResponse, error) {
	return ListPublicEmailsForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
ListPublicEmailsForAuthenticatedReq is request data for Client.ListPublicEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
type ListPublicEmailsForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicEmailsForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicEmailsForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-public-emails-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/public_emails"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicEmailsForAuthenticatedReq) Rel(link string, resp *ListPublicEmailsForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicEmailsForAuthenticatedResponse is a response for ListPublicEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
type ListPublicEmailsForAuthenticatedResponse struct {
	requests.Response
	request *ListPublicEmailsForAuthenticatedReq
	Data    []components.Email
}

/*
ListPublicKeysForUser performs requests for "users/list-public-keys-for-user"

List public keys for a user.

  GET /users/{username}/keys

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
func ListPublicKeysForUser(ctx context.Context, req *ListPublicKeysForUserReq, opt ...requests.Option) (*ListPublicKeysForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicKeysForUserReq)
	}
	resp := &ListPublicKeysForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.KeySimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublicKeysForUser performs requests for "users/list-public-keys-for-user"

List public keys for a user.

  GET /users/{username}/keys

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
func (c Client) ListPublicKeysForUser(ctx context.Context, req *ListPublicKeysForUserReq, opt ...requests.Option) (*ListPublicKeysForUserResponse, error) {
	return ListPublicKeysForUser(ctx, req, append(c, opt...)...)
}

/*
ListPublicKeysForUserReq is request data for Client.ListPublicKeysForUser

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type ListPublicKeysForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicKeysForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicKeysForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-public-keys-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/keys", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicKeysForUserReq) Rel(link string, resp *ListPublicKeysForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicKeysForUserResponse is a response for ListPublicKeysForUser

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type ListPublicKeysForUserResponse struct {
	requests.Response
	request *ListPublicKeysForUserReq
	Data    []components.KeySimple
}

/*
ListPublicSshKeysForAuthenticated performs requests for "users/list-public-ssh-keys-for-authenticated"

List public SSH keys for the authenticated user.

  GET /user/keys

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
func ListPublicSshKeysForAuthenticated(ctx context.Context, req *ListPublicSshKeysForAuthenticatedReq, opt ...requests.Option) (*ListPublicSshKeysForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicSshKeysForAuthenticatedReq)
	}
	resp := &ListPublicSshKeysForAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Key{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublicSshKeysForAuthenticated performs requests for "users/list-public-ssh-keys-for-authenticated"

List public SSH keys for the authenticated user.

  GET /user/keys

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
func (c Client) ListPublicSshKeysForAuthenticated(ctx context.Context, req *ListPublicSshKeysForAuthenticatedReq, opt ...requests.Option) (*ListPublicSshKeysForAuthenticatedResponse, error) {
	return ListPublicSshKeysForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
ListPublicSshKeysForAuthenticatedReq is request data for Client.ListPublicSshKeysForAuthenticated

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
type ListPublicSshKeysForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicSshKeysForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicSshKeysForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-public-ssh-keys-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/keys"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicSshKeysForAuthenticatedReq) Rel(link string, resp *ListPublicSshKeysForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicSshKeysForAuthenticatedResponse is a response for ListPublicSshKeysForAuthenticated

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
type ListPublicSshKeysForAuthenticatedResponse struct {
	requests.Response
	request *ListPublicSshKeysForAuthenticatedReq
	Data    []components.Key
}

/*
SetPrimaryEmailVisibilityForAuthenticated performs requests for "users/set-primary-email-visibility-for-authenticated"

Set primary email visibility for the authenticated user.

  PATCH /user/email/visibility

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
func SetPrimaryEmailVisibilityForAuthenticated(ctx context.Context, req *SetPrimaryEmailVisibilityForAuthenticatedReq, opt ...requests.Option) (*SetPrimaryEmailVisibilityForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetPrimaryEmailVisibilityForAuthenticatedReq)
	}
	resp := &SetPrimaryEmailVisibilityForAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Email{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
SetPrimaryEmailVisibilityForAuthenticated performs requests for "users/set-primary-email-visibility-for-authenticated"

Set primary email visibility for the authenticated user.

  PATCH /user/email/visibility

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
func (c Client) SetPrimaryEmailVisibilityForAuthenticated(ctx context.Context, req *SetPrimaryEmailVisibilityForAuthenticatedReq, opt ...requests.Option) (*SetPrimaryEmailVisibilityForAuthenticatedResponse, error) {
	return SetPrimaryEmailVisibilityForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
SetPrimaryEmailVisibilityForAuthenticatedReq is request data for Client.SetPrimaryEmailVisibilityForAuthenticated

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
type SetPrimaryEmailVisibilityForAuthenticatedReq struct {
	_url        string
	RequestBody SetPrimaryEmailVisibilityForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetPrimaryEmailVisibilityForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetPrimaryEmailVisibilityForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "users/set-primary-email-visibility-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/email/visibility"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetPrimaryEmailVisibilityForAuthenticatedReq) Rel(link string, resp *SetPrimaryEmailVisibilityForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetPrimaryEmailVisibilityForAuthenticatedReqBody is a request body for users/set-primary-email-visibility-for-authenticated

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
type SetPrimaryEmailVisibilityForAuthenticatedReqBody struct {

	// An email address associated with the GitHub user account to manage.
	Email *string `json:"email"`

	// Denotes whether an email is publically visible.
	Visibility *string `json:"visibility"`
}

/*
SetPrimaryEmailVisibilityForAuthenticatedResponse is a response for SetPrimaryEmailVisibilityForAuthenticated

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
type SetPrimaryEmailVisibilityForAuthenticatedResponse struct {
	requests.Response
	request *SetPrimaryEmailVisibilityForAuthenticatedReq
	Data    []components.Email
}

/*
Unblock performs requests for "users/unblock"

Unblock a user.

  DELETE /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
func Unblock(ctx context.Context, req *UnblockReq, opt ...requests.Option) (*UnblockResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnblockReq)
	}
	resp := &UnblockResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Unblock performs requests for "users/unblock"

Unblock a user.

  DELETE /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
func (c Client) Unblock(ctx context.Context, req *UnblockReq, opt ...requests.Option) (*UnblockResponse, error) {
	return Unblock(ctx, req, append(c, opt...)...)
}

/*
UnblockReq is request data for Client.Unblock

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
type UnblockReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *UnblockReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnblockReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "users/unblock",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/blocks/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnblockReq) Rel(link string, resp *UnblockResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnblockResponse is a response for Unblock

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
type UnblockResponse struct {
	requests.Response
	request *UnblockReq
}

/*
Unfollow performs requests for "users/unfollow"

Unfollow a user.

  DELETE /user/following/{username}

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
func Unfollow(ctx context.Context, req *UnfollowReq, opt ...requests.Option) (*UnfollowResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnfollowReq)
	}
	resp := &UnfollowResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Unfollow performs requests for "users/unfollow"

Unfollow a user.

  DELETE /user/following/{username}

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
func (c Client) Unfollow(ctx context.Context, req *UnfollowReq, opt ...requests.Option) (*UnfollowResponse, error) {
	return Unfollow(ctx, req, append(c, opt...)...)
}

/*
UnfollowReq is request data for Client.Unfollow

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
type UnfollowReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *UnfollowReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnfollowReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "users/unfollow",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/following/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnfollowReq) Rel(link string, resp *UnfollowResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnfollowResponse is a response for Unfollow

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
type UnfollowResponse struct {
	requests.Response
	request *UnfollowReq
}

/*
UpdateAuthenticated performs requests for "users/update-authenticated"

Update the authenticated user.

  PATCH /user

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
func UpdateAuthenticated(ctx context.Context, req *UpdateAuthenticatedReq, opt ...requests.Option) (*UpdateAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateAuthenticatedReq)
	}
	resp := &UpdateAuthenticatedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PrivateUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateAuthenticated performs requests for "users/update-authenticated"

Update the authenticated user.

  PATCH /user

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
func (c Client) UpdateAuthenticated(ctx context.Context, req *UpdateAuthenticatedReq, opt ...requests.Option) (*UpdateAuthenticatedResponse, error) {
	return UpdateAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UpdateAuthenticatedReq is request data for Client.UpdateAuthenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UpdateAuthenticatedReq struct {
	_url        string
	RequestBody UpdateAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "users/update-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateAuthenticatedReq) Rel(link string, resp *UpdateAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateAuthenticatedReqBody is a request body for users/update-authenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UpdateAuthenticatedReqBody struct {

	// The new short biography of the user.
	Bio *string `json:"bio,omitempty"`

	// The new blog URL of the user.
	Blog *string `json:"blog,omitempty"`

	// The new company of the user.
	Company *string `json:"company,omitempty"`

	// The publicly visible email address of the user.
	Email *string `json:"email,omitempty"`

	// The new hiring availability of the user.
	Hireable *bool `json:"hireable,omitempty"`

	// The new location of the user.
	Location *string `json:"location,omitempty"`

	// The new name of the user.
	Name *string `json:"name,omitempty"`

	// The new Twitter username of the user.
	TwitterUsername *string `json:"twitter_username,omitempty"`
}

/*
UpdateAuthenticatedResponse is a response for UpdateAuthenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UpdateAuthenticatedResponse struct {
	requests.Response
	request *UpdateAuthenticatedReq
	Data    components.PrivateUser
}
