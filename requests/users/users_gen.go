// Code generated by octo-go; DO NOT EDIT.

package users

import (
	"context"
	"encoding/json"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
AddEmailForAuthenticated performs requests for "users/add-email-for-authenticated"

Add an email address for the authenticated user.

  POST /user/emails

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
func AddEmailForAuthenticated(ctx context.Context, req *AddEmailForAuthenticatedReq, opt ...requests.Option) (*AddEmailForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddEmailForAuthenticatedReq)
	}
	resp := &AddEmailForAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewAddEmailForAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewAddEmailForAuthenticatedResponse builds a new *AddEmailForAuthenticatedResponse from an *http.Response
func NewAddEmailForAuthenticatedResponse(resp *http.Response, preserveBody bool) (*AddEmailForAuthenticatedResponse, error) {
	var result AddEmailForAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
AddEmailForAuthenticated performs requests for "users/add-email-for-authenticated"

Add an email address for the authenticated user.

  POST /user/emails

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
func (c Client) AddEmailForAuthenticated(ctx context.Context, req *AddEmailForAuthenticatedReq, opt ...requests.Option) (*AddEmailForAuthenticatedResponse, error) {
	return AddEmailForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
AddEmailForAuthenticatedReq is request data for Client.AddEmailForAuthenticated

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
type AddEmailForAuthenticatedReq struct {
	_url        string
	RequestBody AddEmailForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddEmailForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddEmailForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "users/add-email-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/emails"),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddEmailForAuthenticatedReq) Rel(link string, resp *AddEmailForAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddEmailForAuthenticatedReqBody is a request body for users/add-email-for-authenticated

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
type AddEmailForAuthenticatedReqBody struct {

	/*
	Adds one or more email addresses to your GitHub account. Must contain at least
	one email address. **Note:** Alternatively, you can pass a single email address
	or an `array` of emails addresses directly, but we recommend that you pass an
	object using the `emails` key.
	*/
	Emails []string `json:"emails"`
}

/*
AddEmailForAuthenticatedResponse is a response for AddEmailForAuthenticated

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
type AddEmailForAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         []components.Email
}

func (r *AddEmailForAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Block performs requests for "users/block"

Block a user.

  PUT /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#block-a-user
*/
func Block(ctx context.Context, req *BlockReq, opt ...requests.Option) (*BlockResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(BlockReq)
	}
	resp := &BlockResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewBlockResponse(r, opts.PreserveResponseBody())
}

// NewBlockResponse builds a new *BlockResponse from an *http.Response
func NewBlockResponse(resp *http.Response, preserveBody bool) (*BlockResponse, error) {
	var result BlockResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
Block performs requests for "users/block"

Block a user.

  PUT /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#block-a-user
*/
func (c Client) Block(ctx context.Context, req *BlockReq, opt ...requests.Option) (*BlockResponse, error) {
	return Block(ctx, req, append(c, opt...)...)
}

/*
BlockReq is request data for Client.Block

https://developer.github.com/v3/users/blocking/#block-a-user
*/
type BlockReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *BlockReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *BlockReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "users/block",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/blocks/%v", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BlockReq) Rel(link string, resp *BlockResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BlockResponse is a response for Block

https://developer.github.com/v3/users/blocking/#block-a-user
*/
type BlockResponse struct {
	httpResponse *http.Response
}

func (r *BlockResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CheckBlocked performs requests for "users/check-blocked"

Check if a user is blocked by the authenticated user.

  GET /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
func CheckBlocked(ctx context.Context, req *CheckBlockedReq, opt ...requests.Option) (*CheckBlockedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckBlockedReq)
	}
	resp := &CheckBlockedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckBlockedResponse(r, opts.PreserveResponseBody())
}

// NewCheckBlockedResponse builds a new *CheckBlockedResponse from an *http.Response
func NewCheckBlockedResponse(resp *http.Response, preserveBody bool) (*CheckBlockedResponse, error) {
	var result CheckBlockedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CheckBlocked performs requests for "users/check-blocked"

Check if a user is blocked by the authenticated user.

  GET /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
func (c Client) CheckBlocked(ctx context.Context, req *CheckBlockedReq, opt ...requests.Option) (*CheckBlockedResponse, error) {
	return CheckBlocked(ctx, req, append(c, opt...)...)
}

/*
CheckBlockedReq is request data for Client.CheckBlocked

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
type CheckBlockedReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *CheckBlockedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckBlockedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "users/check-blocked",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/blocks/%v", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckBlockedReq) Rel(link string, resp *CheckBlockedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckBlockedResponse is a response for CheckBlocked

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
type CheckBlockedResponse struct {
	httpResponse *http.Response
}

func (r *CheckBlockedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CheckFollowingForUser performs requests for "users/check-following-for-user"

Check if a user follows another user.

  GET /users/{username}/following/{target_user}

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
func CheckFollowingForUser(ctx context.Context, req *CheckFollowingForUserReq, opt ...requests.Option) (*CheckFollowingForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckFollowingForUserReq)
	}
	resp := &CheckFollowingForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckFollowingForUserResponse(r, opts.PreserveResponseBody())
}

// NewCheckFollowingForUserResponse builds a new *CheckFollowingForUserResponse from an *http.Response
func NewCheckFollowingForUserResponse(resp *http.Response, preserveBody bool) (*CheckFollowingForUserResponse, error) {
	var result CheckFollowingForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CheckFollowingForUser performs requests for "users/check-following-for-user"

Check if a user follows another user.

  GET /users/{username}/following/{target_user}

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
func (c Client) CheckFollowingForUser(ctx context.Context, req *CheckFollowingForUserReq, opt ...requests.Option) (*CheckFollowingForUserResponse, error) {
	return CheckFollowingForUser(ctx, req, append(c, opt...)...)
}

/*
CheckFollowingForUserReq is request data for Client.CheckFollowingForUser

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
type CheckFollowingForUserReq struct {
	_url     string
	Username string

	// target_user parameter
	TargetUser string
}

// HTTPRequest builds an *http.Request
func (r *CheckFollowingForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckFollowingForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "users/check-following-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/following/%v", r.Username, r.TargetUser),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckFollowingForUserReq) Rel(link string, resp *CheckFollowingForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckFollowingForUserResponse is a response for CheckFollowingForUser

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
type CheckFollowingForUserResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *CheckFollowingForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CheckPersonIsFollowedByAuthenticated performs requests for "users/check-person-is-followed-by-authenticated"

Check if a person is followed by the authenticated user.

  GET /user/following/{username}

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
func CheckPersonIsFollowedByAuthenticated(ctx context.Context, req *CheckPersonIsFollowedByAuthenticatedReq, opt ...requests.Option) (*CheckPersonIsFollowedByAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckPersonIsFollowedByAuthenticatedReq)
	}
	resp := &CheckPersonIsFollowedByAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckPersonIsFollowedByAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewCheckPersonIsFollowedByAuthenticatedResponse builds a new *CheckPersonIsFollowedByAuthenticatedResponse from an *http.Response
func NewCheckPersonIsFollowedByAuthenticatedResponse(resp *http.Response, preserveBody bool) (*CheckPersonIsFollowedByAuthenticatedResponse, error) {
	var result CheckPersonIsFollowedByAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CheckPersonIsFollowedByAuthenticated performs requests for "users/check-person-is-followed-by-authenticated"

Check if a person is followed by the authenticated user.

  GET /user/following/{username}

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
func (c Client) CheckPersonIsFollowedByAuthenticated(ctx context.Context, req *CheckPersonIsFollowedByAuthenticatedReq, opt ...requests.Option) (*CheckPersonIsFollowedByAuthenticatedResponse, error) {
	return CheckPersonIsFollowedByAuthenticated(ctx, req, append(c, opt...)...)
}

/*
CheckPersonIsFollowedByAuthenticatedReq is request data for Client.CheckPersonIsFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
type CheckPersonIsFollowedByAuthenticatedReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *CheckPersonIsFollowedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckPersonIsFollowedByAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "users/check-person-is-followed-by-authenticated",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/following/%v", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckPersonIsFollowedByAuthenticatedReq) Rel(link string, resp *CheckPersonIsFollowedByAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckPersonIsFollowedByAuthenticatedResponse is a response for CheckPersonIsFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
type CheckPersonIsFollowedByAuthenticatedResponse struct {
	httpResponse *http.Response
}

func (r *CheckPersonIsFollowedByAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateGpgKeyForAuthenticated performs requests for "users/create-gpg-key-for-authenticated"

Create a GPG key for the authenticated user.

  POST /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
func CreateGpgKeyForAuthenticated(ctx context.Context, req *CreateGpgKeyForAuthenticatedReq, opt ...requests.Option) (*CreateGpgKeyForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateGpgKeyForAuthenticatedReq)
	}
	resp := &CreateGpgKeyForAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateGpgKeyForAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewCreateGpgKeyForAuthenticatedResponse builds a new *CreateGpgKeyForAuthenticatedResponse from an *http.Response
func NewCreateGpgKeyForAuthenticatedResponse(resp *http.Response, preserveBody bool) (*CreateGpgKeyForAuthenticatedResponse, error) {
	var result CreateGpgKeyForAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateGpgKeyForAuthenticated performs requests for "users/create-gpg-key-for-authenticated"

Create a GPG key for the authenticated user.

  POST /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
func (c Client) CreateGpgKeyForAuthenticated(ctx context.Context, req *CreateGpgKeyForAuthenticatedReq, opt ...requests.Option) (*CreateGpgKeyForAuthenticatedResponse, error) {
	return CreateGpgKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
CreateGpgKeyForAuthenticatedReq is request data for Client.CreateGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
type CreateGpgKeyForAuthenticatedReq struct {
	_url        string
	RequestBody CreateGpgKeyForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateGpgKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateGpgKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "users/create-gpg-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/gpg_keys"),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateGpgKeyForAuthenticatedReq) Rel(link string, resp *CreateGpgKeyForAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateGpgKeyForAuthenticatedReqBody is a request body for users/create-gpg-key-for-authenticated

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
type CreateGpgKeyForAuthenticatedReqBody struct {

	// A GPG key in ASCII-armored format.
	ArmoredPublicKey *string `json:"armored_public_key"`
}

/*
CreateGpgKeyForAuthenticatedResponse is a response for CreateGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
type CreateGpgKeyForAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         components.GpgKey
}

func (r *CreateGpgKeyForAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreatePublicSshKeyForAuthenticated performs requests for "users/create-public-ssh-key-for-authenticated"

Create a public SSH key for the authenticated user.

  POST /user/keys

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
func CreatePublicSshKeyForAuthenticated(ctx context.Context, req *CreatePublicSshKeyForAuthenticatedReq, opt ...requests.Option) (*CreatePublicSshKeyForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreatePublicSshKeyForAuthenticatedReq)
	}
	resp := &CreatePublicSshKeyForAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreatePublicSshKeyForAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewCreatePublicSshKeyForAuthenticatedResponse builds a new *CreatePublicSshKeyForAuthenticatedResponse from an *http.Response
func NewCreatePublicSshKeyForAuthenticatedResponse(resp *http.Response, preserveBody bool) (*CreatePublicSshKeyForAuthenticatedResponse, error) {
	var result CreatePublicSshKeyForAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreatePublicSshKeyForAuthenticated performs requests for "users/create-public-ssh-key-for-authenticated"

Create a public SSH key for the authenticated user.

  POST /user/keys

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
func (c Client) CreatePublicSshKeyForAuthenticated(ctx context.Context, req *CreatePublicSshKeyForAuthenticatedReq, opt ...requests.Option) (*CreatePublicSshKeyForAuthenticatedResponse, error) {
	return CreatePublicSshKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
CreatePublicSshKeyForAuthenticatedReq is request data for Client.CreatePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
type CreatePublicSshKeyForAuthenticatedReq struct {
	_url        string
	RequestBody CreatePublicSshKeyForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreatePublicSshKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreatePublicSshKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "users/create-public-ssh-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/keys"),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreatePublicSshKeyForAuthenticatedReq) Rel(link string, resp *CreatePublicSshKeyForAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreatePublicSshKeyForAuthenticatedReqBody is a request body for users/create-public-ssh-key-for-authenticated

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
type CreatePublicSshKeyForAuthenticatedReqBody struct {

	// The public SSH key to add to your GitHub account.
	Key *string `json:"key"`

	// A descriptive name for the new key.
	Title *string `json:"title,omitempty"`
}

/*
CreatePublicSshKeyForAuthenticatedResponse is a response for CreatePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
type CreatePublicSshKeyForAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         components.Key
}

func (r *CreatePublicSshKeyForAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteEmailForAuthenticated performs requests for "users/delete-email-for-authenticated"

Delete an email address for the authenticated user.

  DELETE /user/emails

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
func DeleteEmailForAuthenticated(ctx context.Context, req *DeleteEmailForAuthenticatedReq, opt ...requests.Option) (*DeleteEmailForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteEmailForAuthenticatedReq)
	}
	resp := &DeleteEmailForAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteEmailForAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewDeleteEmailForAuthenticatedResponse builds a new *DeleteEmailForAuthenticatedResponse from an *http.Response
func NewDeleteEmailForAuthenticatedResponse(resp *http.Response, preserveBody bool) (*DeleteEmailForAuthenticatedResponse, error) {
	var result DeleteEmailForAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteEmailForAuthenticated performs requests for "users/delete-email-for-authenticated"

Delete an email address for the authenticated user.

  DELETE /user/emails

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
func (c Client) DeleteEmailForAuthenticated(ctx context.Context, req *DeleteEmailForAuthenticatedReq, opt ...requests.Option) (*DeleteEmailForAuthenticatedResponse, error) {
	return DeleteEmailForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
DeleteEmailForAuthenticatedReq is request data for Client.DeleteEmailForAuthenticated

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
type DeleteEmailForAuthenticatedReq struct {
	_url        string
	RequestBody DeleteEmailForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *DeleteEmailForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteEmailForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "DELETE",
		OperationID:        "users/delete-email-for-authenticated",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/emails"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteEmailForAuthenticatedReq) Rel(link string, resp *DeleteEmailForAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteEmailForAuthenticatedReqBody is a request body for users/delete-email-for-authenticated

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
type DeleteEmailForAuthenticatedReqBody struct {

	// Email addresses associated with the GitHub user account.
	Emails []string `json:"emails"`
}

/*
DeleteEmailForAuthenticatedResponse is a response for DeleteEmailForAuthenticated

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
type DeleteEmailForAuthenticatedResponse struct {
	httpResponse *http.Response
}

func (r *DeleteEmailForAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteGpgKeyForAuthenticated performs requests for "users/delete-gpg-key-for-authenticated"

Delete a GPG key for the authenticated user.

  DELETE /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
func DeleteGpgKeyForAuthenticated(ctx context.Context, req *DeleteGpgKeyForAuthenticatedReq, opt ...requests.Option) (*DeleteGpgKeyForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteGpgKeyForAuthenticatedReq)
	}
	resp := &DeleteGpgKeyForAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteGpgKeyForAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewDeleteGpgKeyForAuthenticatedResponse builds a new *DeleteGpgKeyForAuthenticatedResponse from an *http.Response
func NewDeleteGpgKeyForAuthenticatedResponse(resp *http.Response, preserveBody bool) (*DeleteGpgKeyForAuthenticatedResponse, error) {
	var result DeleteGpgKeyForAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteGpgKeyForAuthenticated performs requests for "users/delete-gpg-key-for-authenticated"

Delete a GPG key for the authenticated user.

  DELETE /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
func (c Client) DeleteGpgKeyForAuthenticated(ctx context.Context, req *DeleteGpgKeyForAuthenticatedReq, opt ...requests.Option) (*DeleteGpgKeyForAuthenticatedResponse, error) {
	return DeleteGpgKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
DeleteGpgKeyForAuthenticatedReq is request data for Client.DeleteGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
type DeleteGpgKeyForAuthenticatedReq struct {
	_url string

	// gpg_key_id parameter
	GpgKeyId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteGpgKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteGpgKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "users/delete-gpg-key-for-authenticated",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/gpg_keys/%v", r.GpgKeyId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteGpgKeyForAuthenticatedReq) Rel(link string, resp *DeleteGpgKeyForAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteGpgKeyForAuthenticatedResponse is a response for DeleteGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
type DeleteGpgKeyForAuthenticatedResponse struct {
	httpResponse *http.Response
}

func (r *DeleteGpgKeyForAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeletePublicSshKeyForAuthenticated performs requests for "users/delete-public-ssh-key-for-authenticated"

Delete a public SSH key for the authenticated user.

  DELETE /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
func DeletePublicSshKeyForAuthenticated(ctx context.Context, req *DeletePublicSshKeyForAuthenticatedReq, opt ...requests.Option) (*DeletePublicSshKeyForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeletePublicSshKeyForAuthenticatedReq)
	}
	resp := &DeletePublicSshKeyForAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeletePublicSshKeyForAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewDeletePublicSshKeyForAuthenticatedResponse builds a new *DeletePublicSshKeyForAuthenticatedResponse from an *http.Response
func NewDeletePublicSshKeyForAuthenticatedResponse(resp *http.Response, preserveBody bool) (*DeletePublicSshKeyForAuthenticatedResponse, error) {
	var result DeletePublicSshKeyForAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeletePublicSshKeyForAuthenticated performs requests for "users/delete-public-ssh-key-for-authenticated"

Delete a public SSH key for the authenticated user.

  DELETE /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
func (c Client) DeletePublicSshKeyForAuthenticated(ctx context.Context, req *DeletePublicSshKeyForAuthenticatedReq, opt ...requests.Option) (*DeletePublicSshKeyForAuthenticatedResponse, error) {
	return DeletePublicSshKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
DeletePublicSshKeyForAuthenticatedReq is request data for Client.DeletePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
type DeletePublicSshKeyForAuthenticatedReq struct {
	_url string

	// key_id parameter
	KeyId int64
}

// HTTPRequest builds an *http.Request
func (r *DeletePublicSshKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeletePublicSshKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "users/delete-public-ssh-key-for-authenticated",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/keys/%v", r.KeyId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeletePublicSshKeyForAuthenticatedReq) Rel(link string, resp *DeletePublicSshKeyForAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeletePublicSshKeyForAuthenticatedResponse is a response for DeletePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
type DeletePublicSshKeyForAuthenticatedResponse struct {
	httpResponse *http.Response
}

func (r *DeletePublicSshKeyForAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Follow performs requests for "users/follow"

Follow a user.

  PUT /user/following/{username}

https://developer.github.com/v3/users/followers/#follow-a-user
*/
func Follow(ctx context.Context, req *FollowReq, opt ...requests.Option) (*FollowResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(FollowReq)
	}
	resp := &FollowResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewFollowResponse(r, opts.PreserveResponseBody())
}

// NewFollowResponse builds a new *FollowResponse from an *http.Response
func NewFollowResponse(resp *http.Response, preserveBody bool) (*FollowResponse, error) {
	var result FollowResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
Follow performs requests for "users/follow"

Follow a user.

  PUT /user/following/{username}

https://developer.github.com/v3/users/followers/#follow-a-user
*/
func (c Client) Follow(ctx context.Context, req *FollowReq, opt ...requests.Option) (*FollowResponse, error) {
	return Follow(ctx, req, append(c, opt...)...)
}

/*
FollowReq is request data for Client.Follow

https://developer.github.com/v3/users/followers/#follow-a-user
*/
type FollowReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *FollowReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *FollowReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "users/follow",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/following/%v", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *FollowReq) Rel(link string, resp *FollowResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
FollowResponse is a response for Follow

https://developer.github.com/v3/users/followers/#follow-a-user
*/
type FollowResponse struct {
	httpResponse *http.Response
}

func (r *FollowResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetAuthenticated performs requests for "users/get-authenticated"

Get the authenticated user.

  GET /user

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
func GetAuthenticated(ctx context.Context, req *GetAuthenticatedReq, opt ...requests.Option) (*GetAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetAuthenticatedReq)
	}
	resp := &GetAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewGetAuthenticatedResponse builds a new *GetAuthenticatedResponse from an *http.Response
func NewGetAuthenticatedResponse(resp *http.Response, preserveBody bool) (*GetAuthenticatedResponse, error) {
	var result GetAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetAuthenticated performs requests for "users/get-authenticated"

Get the authenticated user.

  GET /user

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
func (c Client) GetAuthenticated(ctx context.Context, req *GetAuthenticatedReq, opt ...requests.Option) (*GetAuthenticatedResponse, error) {
	return GetAuthenticated(ctx, req, append(c, opt...)...)
}

/*
GetAuthenticatedReq is request data for Client.GetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type GetAuthenticatedReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *GetAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/get-authenticated",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetAuthenticatedReq) Rel(link string, resp *GetAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetAuthenticatedResponseBody is a response body for GetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type GetAuthenticatedResponseBody struct {
	oneOfField string

	// Private User
	privateUser components.PrivateUser

	// Public User
	publicUser components.PublicUser
}

// Value returns GetAuthenticatedResponseBody's value. The type will be one of components.PrivateUser or components.PublicUser.
func (c *GetAuthenticatedResponseBody) Value() interface{} {
	switch c.oneOfField {
	case "privateUser":
		return c.privateUser
	case "publicUser":
		return c.publicUser
	}
	return nil
}

// SetValue sets GetAuthenticatedResponseBody's value. The type must be one of components.PrivateUser or components.PublicUser.
func (c *GetAuthenticatedResponseBody) SetValue(value interface{}) {
	switch v := value.(type) {
	case components.PrivateUser:
		c.privateUser = v
	case components.PublicUser:
		c.publicUser = v
	default:
		panic("type not acceptable")
	}
}

func (c *GetAuthenticatedResponseBody) MarshalJSON() ([]byte, error) {
	switch c.oneOfField {
	case "privateUser":
		return json.Marshal(&c.privateUser)
	case "publicUser":
		return json.Marshal(&c.publicUser)
	}
	return json.Marshal(interface{}(nil))
}

func (c *GetAuthenticatedResponseBody) UnmarshalJSON(data []byte) error {
	var err error
	err = json.Unmarshal(data, &c.privateUser)
	if err == nil {
		c.oneOfField = "privateUser"
		return nil
	}
	err = json.Unmarshal(data, &c.publicUser)
	if err == nil {
		c.oneOfField = "publicUser"
		return nil
	}
	return fmt.Errorf("could not unmarshal json")
}

/*
GetAuthenticatedResponse is a response for GetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type GetAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         GetAuthenticatedResponseBody
}

func (r *GetAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetByUsername performs requests for "users/get-by-username"

Get a user.

  GET /users/{username}

https://developer.github.com/v3/users/#get-a-user
*/
func GetByUsername(ctx context.Context, req *GetByUsernameReq, opt ...requests.Option) (*GetByUsernameResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetByUsernameReq)
	}
	resp := &GetByUsernameResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetByUsernameResponse(r, opts.PreserveResponseBody())
}

// NewGetByUsernameResponse builds a new *GetByUsernameResponse from an *http.Response
func NewGetByUsernameResponse(resp *http.Response, preserveBody bool) (*GetByUsernameResponse, error) {
	var result GetByUsernameResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetByUsername performs requests for "users/get-by-username"

Get a user.

  GET /users/{username}

https://developer.github.com/v3/users/#get-a-user
*/
func (c Client) GetByUsername(ctx context.Context, req *GetByUsernameReq, opt ...requests.Option) (*GetByUsernameResponse, error) {
	return GetByUsername(ctx, req, append(c, opt...)...)
}

/*
GetByUsernameReq is request data for Client.GetByUsername

https://developer.github.com/v3/users/#get-a-user
*/
type GetByUsernameReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *GetByUsernameReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetByUsernameReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/get-by-username",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetByUsernameReq) Rel(link string, resp *GetByUsernameResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetByUsernameResponseBody is a response body for GetByUsername

https://developer.github.com/v3/users/#get-a-user
*/
type GetByUsernameResponseBody struct {
	oneOfField string

	// Private User
	privateUser components.PrivateUser

	// Public User
	publicUser components.PublicUser
}

// Value returns GetByUsernameResponseBody's value. The type will be one of components.PrivateUser or components.PublicUser.
func (c *GetByUsernameResponseBody) Value() interface{} {
	switch c.oneOfField {
	case "privateUser":
		return c.privateUser
	case "publicUser":
		return c.publicUser
	}
	return nil
}

// SetValue sets GetByUsernameResponseBody's value. The type must be one of components.PrivateUser or components.PublicUser.
func (c *GetByUsernameResponseBody) SetValue(value interface{}) {
	switch v := value.(type) {
	case components.PrivateUser:
		c.privateUser = v
	case components.PublicUser:
		c.publicUser = v
	default:
		panic("type not acceptable")
	}
}

func (c *GetByUsernameResponseBody) MarshalJSON() ([]byte, error) {
	switch c.oneOfField {
	case "privateUser":
		return json.Marshal(&c.privateUser)
	case "publicUser":
		return json.Marshal(&c.publicUser)
	}
	return json.Marshal(interface{}(nil))
}

func (c *GetByUsernameResponseBody) UnmarshalJSON(data []byte) error {
	var err error
	err = json.Unmarshal(data, &c.privateUser)
	if err == nil {
		c.oneOfField = "privateUser"
		return nil
	}
	err = json.Unmarshal(data, &c.publicUser)
	if err == nil {
		c.oneOfField = "publicUser"
		return nil
	}
	return fmt.Errorf("could not unmarshal json")
}

/*
GetByUsernameResponse is a response for GetByUsername

https://developer.github.com/v3/users/#get-a-user
*/
type GetByUsernameResponse struct {
	httpResponse *http.Response
	Data         GetByUsernameResponseBody
}

func (r *GetByUsernameResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetContextForUser performs requests for "users/get-context-for-user"

Get contextual information for a user.

  GET /users/{username}/hovercard

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
func GetContextForUser(ctx context.Context, req *GetContextForUserReq, opt ...requests.Option) (*GetContextForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetContextForUserReq)
	}
	resp := &GetContextForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetContextForUserResponse(r, opts.PreserveResponseBody())
}

// NewGetContextForUserResponse builds a new *GetContextForUserResponse from an *http.Response
func NewGetContextForUserResponse(resp *http.Response, preserveBody bool) (*GetContextForUserResponse, error) {
	var result GetContextForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetContextForUser performs requests for "users/get-context-for-user"

Get contextual information for a user.

  GET /users/{username}/hovercard

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
func (c Client) GetContextForUser(ctx context.Context, req *GetContextForUserReq, opt ...requests.Option) (*GetContextForUserResponse, error) {
	return GetContextForUser(ctx, req, append(c, opt...)...)
}

/*
GetContextForUserReq is request data for Client.GetContextForUser

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
type GetContextForUserReq struct {
	_url     string
	Username string

	/*
	Identifies which additional information you'd like to receive about the person's
	hovercard. Can be `organization`, `repository`, `issue`, `pull_request`.
	**Required** when using `subject_id`.
	*/
	SubjectType *string

	/*
	Uses the ID for the `subject_type` you specified. **Required** when using
	`subject_type`.
	*/
	SubjectId *string
}

// HTTPRequest builds an *http.Request
func (r *GetContextForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetContextForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.SubjectType != nil {
		query.Set("subject_type", *r.SubjectType)
	}
	if r.SubjectId != nil {
		query.Set("subject_id", *r.SubjectId)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/get-context-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/hovercard", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetContextForUserReq) Rel(link string, resp *GetContextForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetContextForUserResponse is a response for GetContextForUser

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
type GetContextForUserResponse struct {
	httpResponse *http.Response
	Data         components.Hovercard
}

func (r *GetContextForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetGpgKeyForAuthenticated performs requests for "users/get-gpg-key-for-authenticated"

Get a GPG key for the authenticated user.

  GET /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
func GetGpgKeyForAuthenticated(ctx context.Context, req *GetGpgKeyForAuthenticatedReq, opt ...requests.Option) (*GetGpgKeyForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetGpgKeyForAuthenticatedReq)
	}
	resp := &GetGpgKeyForAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetGpgKeyForAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewGetGpgKeyForAuthenticatedResponse builds a new *GetGpgKeyForAuthenticatedResponse from an *http.Response
func NewGetGpgKeyForAuthenticatedResponse(resp *http.Response, preserveBody bool) (*GetGpgKeyForAuthenticatedResponse, error) {
	var result GetGpgKeyForAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetGpgKeyForAuthenticated performs requests for "users/get-gpg-key-for-authenticated"

Get a GPG key for the authenticated user.

  GET /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
func (c Client) GetGpgKeyForAuthenticated(ctx context.Context, req *GetGpgKeyForAuthenticatedReq, opt ...requests.Option) (*GetGpgKeyForAuthenticatedResponse, error) {
	return GetGpgKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
GetGpgKeyForAuthenticatedReq is request data for Client.GetGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
type GetGpgKeyForAuthenticatedReq struct {
	_url string

	// gpg_key_id parameter
	GpgKeyId int64
}

// HTTPRequest builds an *http.Request
func (r *GetGpgKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetGpgKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/get-gpg-key-for-authenticated",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/gpg_keys/%v", r.GpgKeyId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetGpgKeyForAuthenticatedReq) Rel(link string, resp *GetGpgKeyForAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetGpgKeyForAuthenticatedResponse is a response for GetGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
type GetGpgKeyForAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         components.GpgKey
}

func (r *GetGpgKeyForAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetPublicSshKeyForAuthenticated performs requests for "users/get-public-ssh-key-for-authenticated"

Get a public SSH key for the authenticated user.

  GET /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
func GetPublicSshKeyForAuthenticated(ctx context.Context, req *GetPublicSshKeyForAuthenticatedReq, opt ...requests.Option) (*GetPublicSshKeyForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetPublicSshKeyForAuthenticatedReq)
	}
	resp := &GetPublicSshKeyForAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetPublicSshKeyForAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewGetPublicSshKeyForAuthenticatedResponse builds a new *GetPublicSshKeyForAuthenticatedResponse from an *http.Response
func NewGetPublicSshKeyForAuthenticatedResponse(resp *http.Response, preserveBody bool) (*GetPublicSshKeyForAuthenticatedResponse, error) {
	var result GetPublicSshKeyForAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetPublicSshKeyForAuthenticated performs requests for "users/get-public-ssh-key-for-authenticated"

Get a public SSH key for the authenticated user.

  GET /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
func (c Client) GetPublicSshKeyForAuthenticated(ctx context.Context, req *GetPublicSshKeyForAuthenticatedReq, opt ...requests.Option) (*GetPublicSshKeyForAuthenticatedResponse, error) {
	return GetPublicSshKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
GetPublicSshKeyForAuthenticatedReq is request data for Client.GetPublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
type GetPublicSshKeyForAuthenticatedReq struct {
	_url string

	// key_id parameter
	KeyId int64
}

// HTTPRequest builds an *http.Request
func (r *GetPublicSshKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetPublicSshKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/get-public-ssh-key-for-authenticated",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/keys/%v", r.KeyId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetPublicSshKeyForAuthenticatedReq) Rel(link string, resp *GetPublicSshKeyForAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetPublicSshKeyForAuthenticatedResponse is a response for GetPublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
type GetPublicSshKeyForAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         components.Key
}

func (r *GetPublicSshKeyForAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
List performs requests for "users/list"

List users.

  GET /users

https://developer.github.com/v3/users/#list-users
*/
func List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReq)
	}
	resp := &ListResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListResponse(r, opts.PreserveResponseBody())
}

// NewListResponse builds a new *ListResponse from an *http.Response
func NewListResponse(resp *http.Response, preserveBody bool) (*ListResponse, error) {
	var result ListResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
List performs requests for "users/list"

List users.

  GET /users

https://developer.github.com/v3/users/#list-users
*/
func (c Client) List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	return List(ctx, req, append(c, opt...)...)
}

/*
ListReq is request data for Client.List

https://developer.github.com/v3/users/#list-users
*/
type ListReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/list",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReq) Rel(link string, resp *ListResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListResponse is a response for List

https://developer.github.com/v3/users/#list-users
*/
type ListResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListBlockedByAuthenticated performs requests for "users/list-blocked-by-authenticated"

List users blocked by the authenticated user.

  GET /user/blocks

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
func ListBlockedByAuthenticated(ctx context.Context, req *ListBlockedByAuthenticatedReq, opt ...requests.Option) (*ListBlockedByAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListBlockedByAuthenticatedReq)
	}
	resp := &ListBlockedByAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListBlockedByAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewListBlockedByAuthenticatedResponse builds a new *ListBlockedByAuthenticatedResponse from an *http.Response
func NewListBlockedByAuthenticatedResponse(resp *http.Response, preserveBody bool) (*ListBlockedByAuthenticatedResponse, error) {
	var result ListBlockedByAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListBlockedByAuthenticated performs requests for "users/list-blocked-by-authenticated"

List users blocked by the authenticated user.

  GET /user/blocks

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
func (c Client) ListBlockedByAuthenticated(ctx context.Context, req *ListBlockedByAuthenticatedReq, opt ...requests.Option) (*ListBlockedByAuthenticatedResponse, error) {
	return ListBlockedByAuthenticated(ctx, req, append(c, opt...)...)
}

/*
ListBlockedByAuthenticatedReq is request data for Client.ListBlockedByAuthenticated

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
type ListBlockedByAuthenticatedReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *ListBlockedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListBlockedByAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/list-blocked-by-authenticated",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/blocks"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListBlockedByAuthenticatedReq) Rel(link string, resp *ListBlockedByAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListBlockedByAuthenticatedResponse is a response for ListBlockedByAuthenticated

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
type ListBlockedByAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListBlockedByAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListEmailsForAuthenticated performs requests for "users/list-emails-for-authenticated"

List email addresses for the authenticated user.

  GET /user/emails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
func ListEmailsForAuthenticated(ctx context.Context, req *ListEmailsForAuthenticatedReq, opt ...requests.Option) (*ListEmailsForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListEmailsForAuthenticatedReq)
	}
	resp := &ListEmailsForAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListEmailsForAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewListEmailsForAuthenticatedResponse builds a new *ListEmailsForAuthenticatedResponse from an *http.Response
func NewListEmailsForAuthenticatedResponse(resp *http.Response, preserveBody bool) (*ListEmailsForAuthenticatedResponse, error) {
	var result ListEmailsForAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListEmailsForAuthenticated performs requests for "users/list-emails-for-authenticated"

List email addresses for the authenticated user.

  GET /user/emails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
func (c Client) ListEmailsForAuthenticated(ctx context.Context, req *ListEmailsForAuthenticatedReq, opt ...requests.Option) (*ListEmailsForAuthenticatedResponse, error) {
	return ListEmailsForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
ListEmailsForAuthenticatedReq is request data for Client.ListEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
type ListEmailsForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListEmailsForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListEmailsForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/list-emails-for-authenticated",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/emails"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListEmailsForAuthenticatedReq) Rel(link string, resp *ListEmailsForAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListEmailsForAuthenticatedResponse is a response for ListEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
type ListEmailsForAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         []components.Email
}

func (r *ListEmailsForAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListFollowedByAuthenticated performs requests for "users/list-followed-by-authenticated"

List the people the authenticated user follows.

  GET /user/following

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
func ListFollowedByAuthenticated(ctx context.Context, req *ListFollowedByAuthenticatedReq, opt ...requests.Option) (*ListFollowedByAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListFollowedByAuthenticatedReq)
	}
	resp := &ListFollowedByAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListFollowedByAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewListFollowedByAuthenticatedResponse builds a new *ListFollowedByAuthenticatedResponse from an *http.Response
func NewListFollowedByAuthenticatedResponse(resp *http.Response, preserveBody bool) (*ListFollowedByAuthenticatedResponse, error) {
	var result ListFollowedByAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListFollowedByAuthenticated performs requests for "users/list-followed-by-authenticated"

List the people the authenticated user follows.

  GET /user/following

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
func (c Client) ListFollowedByAuthenticated(ctx context.Context, req *ListFollowedByAuthenticatedReq, opt ...requests.Option) (*ListFollowedByAuthenticatedResponse, error) {
	return ListFollowedByAuthenticated(ctx, req, append(c, opt...)...)
}

/*
ListFollowedByAuthenticatedReq is request data for Client.ListFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
type ListFollowedByAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListFollowedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListFollowedByAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/list-followed-by-authenticated",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/following"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListFollowedByAuthenticatedReq) Rel(link string, resp *ListFollowedByAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListFollowedByAuthenticatedResponse is a response for ListFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
type ListFollowedByAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListFollowedByAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListFollowersForAuthenticatedUser performs requests for "users/list-followers-for-authenticated-user"

List followers of the authenticated user.

  GET /user/followers

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
func ListFollowersForAuthenticatedUser(ctx context.Context, req *ListFollowersForAuthenticatedUserReq, opt ...requests.Option) (*ListFollowersForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListFollowersForAuthenticatedUserReq)
	}
	resp := &ListFollowersForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListFollowersForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListFollowersForAuthenticatedUserResponse builds a new *ListFollowersForAuthenticatedUserResponse from an *http.Response
func NewListFollowersForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListFollowersForAuthenticatedUserResponse, error) {
	var result ListFollowersForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListFollowersForAuthenticatedUser performs requests for "users/list-followers-for-authenticated-user"

List followers of the authenticated user.

  GET /user/followers

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
func (c Client) ListFollowersForAuthenticatedUser(ctx context.Context, req *ListFollowersForAuthenticatedUserReq, opt ...requests.Option) (*ListFollowersForAuthenticatedUserResponse, error) {
	return ListFollowersForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListFollowersForAuthenticatedUserReq is request data for Client.ListFollowersForAuthenticatedUser

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type ListFollowersForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListFollowersForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListFollowersForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/list-followers-for-authenticated-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/followers"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListFollowersForAuthenticatedUserReq) Rel(link string, resp *ListFollowersForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListFollowersForAuthenticatedUserResponse is a response for ListFollowersForAuthenticatedUser

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type ListFollowersForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListFollowersForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListFollowersForUser performs requests for "users/list-followers-for-user"

List followers of a user.

  GET /users/{username}/followers

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
func ListFollowersForUser(ctx context.Context, req *ListFollowersForUserReq, opt ...requests.Option) (*ListFollowersForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListFollowersForUserReq)
	}
	resp := &ListFollowersForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListFollowersForUserResponse(r, opts.PreserveResponseBody())
}

// NewListFollowersForUserResponse builds a new *ListFollowersForUserResponse from an *http.Response
func NewListFollowersForUserResponse(resp *http.Response, preserveBody bool) (*ListFollowersForUserResponse, error) {
	var result ListFollowersForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListFollowersForUser performs requests for "users/list-followers-for-user"

List followers of a user.

  GET /users/{username}/followers

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
func (c Client) ListFollowersForUser(ctx context.Context, req *ListFollowersForUserReq, opt ...requests.Option) (*ListFollowersForUserResponse, error) {
	return ListFollowersForUser(ctx, req, append(c, opt...)...)
}

/*
ListFollowersForUserReq is request data for Client.ListFollowersForUser

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type ListFollowersForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListFollowersForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListFollowersForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/list-followers-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/followers", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListFollowersForUserReq) Rel(link string, resp *ListFollowersForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListFollowersForUserResponse is a response for ListFollowersForUser

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type ListFollowersForUserResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListFollowersForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListFollowingForUser performs requests for "users/list-following-for-user"

List the people a user follows.

  GET /users/{username}/following

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
func ListFollowingForUser(ctx context.Context, req *ListFollowingForUserReq, opt ...requests.Option) (*ListFollowingForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListFollowingForUserReq)
	}
	resp := &ListFollowingForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListFollowingForUserResponse(r, opts.PreserveResponseBody())
}

// NewListFollowingForUserResponse builds a new *ListFollowingForUserResponse from an *http.Response
func NewListFollowingForUserResponse(resp *http.Response, preserveBody bool) (*ListFollowingForUserResponse, error) {
	var result ListFollowingForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListFollowingForUser performs requests for "users/list-following-for-user"

List the people a user follows.

  GET /users/{username}/following

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
func (c Client) ListFollowingForUser(ctx context.Context, req *ListFollowingForUserReq, opt ...requests.Option) (*ListFollowingForUserResponse, error) {
	return ListFollowingForUser(ctx, req, append(c, opt...)...)
}

/*
ListFollowingForUserReq is request data for Client.ListFollowingForUser

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
type ListFollowingForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListFollowingForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListFollowingForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/list-following-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/following", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListFollowingForUserReq) Rel(link string, resp *ListFollowingForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListFollowingForUserResponse is a response for ListFollowingForUser

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
type ListFollowingForUserResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListFollowingForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListGpgKeysForAuthenticated performs requests for "users/list-gpg-keys-for-authenticated"

List GPG keys for the authenticated user.

  GET /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
func ListGpgKeysForAuthenticated(ctx context.Context, req *ListGpgKeysForAuthenticatedReq, opt ...requests.Option) (*ListGpgKeysForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListGpgKeysForAuthenticatedReq)
	}
	resp := &ListGpgKeysForAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListGpgKeysForAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewListGpgKeysForAuthenticatedResponse builds a new *ListGpgKeysForAuthenticatedResponse from an *http.Response
func NewListGpgKeysForAuthenticatedResponse(resp *http.Response, preserveBody bool) (*ListGpgKeysForAuthenticatedResponse, error) {
	var result ListGpgKeysForAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListGpgKeysForAuthenticated performs requests for "users/list-gpg-keys-for-authenticated"

List GPG keys for the authenticated user.

  GET /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
func (c Client) ListGpgKeysForAuthenticated(ctx context.Context, req *ListGpgKeysForAuthenticatedReq, opt ...requests.Option) (*ListGpgKeysForAuthenticatedResponse, error) {
	return ListGpgKeysForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
ListGpgKeysForAuthenticatedReq is request data for Client.ListGpgKeysForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
type ListGpgKeysForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListGpgKeysForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListGpgKeysForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/list-gpg-keys-for-authenticated",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/gpg_keys"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListGpgKeysForAuthenticatedReq) Rel(link string, resp *ListGpgKeysForAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListGpgKeysForAuthenticatedResponse is a response for ListGpgKeysForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
type ListGpgKeysForAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         []components.GpgKey
}

func (r *ListGpgKeysForAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListGpgKeysForUser performs requests for "users/list-gpg-keys-for-user"

List GPG keys for a user.

  GET /users/{username}/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
func ListGpgKeysForUser(ctx context.Context, req *ListGpgKeysForUserReq, opt ...requests.Option) (*ListGpgKeysForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListGpgKeysForUserReq)
	}
	resp := &ListGpgKeysForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListGpgKeysForUserResponse(r, opts.PreserveResponseBody())
}

// NewListGpgKeysForUserResponse builds a new *ListGpgKeysForUserResponse from an *http.Response
func NewListGpgKeysForUserResponse(resp *http.Response, preserveBody bool) (*ListGpgKeysForUserResponse, error) {
	var result ListGpgKeysForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListGpgKeysForUser performs requests for "users/list-gpg-keys-for-user"

List GPG keys for a user.

  GET /users/{username}/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
func (c Client) ListGpgKeysForUser(ctx context.Context, req *ListGpgKeysForUserReq, opt ...requests.Option) (*ListGpgKeysForUserResponse, error) {
	return ListGpgKeysForUser(ctx, req, append(c, opt...)...)
}

/*
ListGpgKeysForUserReq is request data for Client.ListGpgKeysForUser

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type ListGpgKeysForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListGpgKeysForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListGpgKeysForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/list-gpg-keys-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/gpg_keys", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListGpgKeysForUserReq) Rel(link string, resp *ListGpgKeysForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListGpgKeysForUserResponse is a response for ListGpgKeysForUser

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type ListGpgKeysForUserResponse struct {
	httpResponse *http.Response
	Data         []components.GpgKey
}

func (r *ListGpgKeysForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPublicEmailsForAuthenticated performs requests for "users/list-public-emails-for-authenticated"

List public email addresses for the authenticated user.

  GET /user/public_emails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
func ListPublicEmailsForAuthenticated(ctx context.Context, req *ListPublicEmailsForAuthenticatedReq, opt ...requests.Option) (*ListPublicEmailsForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicEmailsForAuthenticatedReq)
	}
	resp := &ListPublicEmailsForAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPublicEmailsForAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewListPublicEmailsForAuthenticatedResponse builds a new *ListPublicEmailsForAuthenticatedResponse from an *http.Response
func NewListPublicEmailsForAuthenticatedResponse(resp *http.Response, preserveBody bool) (*ListPublicEmailsForAuthenticatedResponse, error) {
	var result ListPublicEmailsForAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPublicEmailsForAuthenticated performs requests for "users/list-public-emails-for-authenticated"

List public email addresses for the authenticated user.

  GET /user/public_emails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
func (c Client) ListPublicEmailsForAuthenticated(ctx context.Context, req *ListPublicEmailsForAuthenticatedReq, opt ...requests.Option) (*ListPublicEmailsForAuthenticatedResponse, error) {
	return ListPublicEmailsForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
ListPublicEmailsForAuthenticatedReq is request data for Client.ListPublicEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
type ListPublicEmailsForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicEmailsForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicEmailsForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/list-public-emails-for-authenticated",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/public_emails"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicEmailsForAuthenticatedReq) Rel(link string, resp *ListPublicEmailsForAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicEmailsForAuthenticatedResponse is a response for ListPublicEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
type ListPublicEmailsForAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         []components.Email
}

func (r *ListPublicEmailsForAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPublicKeysForUser performs requests for "users/list-public-keys-for-user"

List public keys for a user.

  GET /users/{username}/keys

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
func ListPublicKeysForUser(ctx context.Context, req *ListPublicKeysForUserReq, opt ...requests.Option) (*ListPublicKeysForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicKeysForUserReq)
	}
	resp := &ListPublicKeysForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPublicKeysForUserResponse(r, opts.PreserveResponseBody())
}

// NewListPublicKeysForUserResponse builds a new *ListPublicKeysForUserResponse from an *http.Response
func NewListPublicKeysForUserResponse(resp *http.Response, preserveBody bool) (*ListPublicKeysForUserResponse, error) {
	var result ListPublicKeysForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPublicKeysForUser performs requests for "users/list-public-keys-for-user"

List public keys for a user.

  GET /users/{username}/keys

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
func (c Client) ListPublicKeysForUser(ctx context.Context, req *ListPublicKeysForUserReq, opt ...requests.Option) (*ListPublicKeysForUserResponse, error) {
	return ListPublicKeysForUser(ctx, req, append(c, opt...)...)
}

/*
ListPublicKeysForUserReq is request data for Client.ListPublicKeysForUser

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type ListPublicKeysForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicKeysForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicKeysForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/list-public-keys-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/keys", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicKeysForUserReq) Rel(link string, resp *ListPublicKeysForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicKeysForUserResponse is a response for ListPublicKeysForUser

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type ListPublicKeysForUserResponse struct {
	httpResponse *http.Response
	Data         []components.KeySimple
}

func (r *ListPublicKeysForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPublicSshKeysForAuthenticated performs requests for "users/list-public-ssh-keys-for-authenticated"

List public SSH keys for the authenticated user.

  GET /user/keys

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
func ListPublicSshKeysForAuthenticated(ctx context.Context, req *ListPublicSshKeysForAuthenticatedReq, opt ...requests.Option) (*ListPublicSshKeysForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicSshKeysForAuthenticatedReq)
	}
	resp := &ListPublicSshKeysForAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPublicSshKeysForAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewListPublicSshKeysForAuthenticatedResponse builds a new *ListPublicSshKeysForAuthenticatedResponse from an *http.Response
func NewListPublicSshKeysForAuthenticatedResponse(resp *http.Response, preserveBody bool) (*ListPublicSshKeysForAuthenticatedResponse, error) {
	var result ListPublicSshKeysForAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPublicSshKeysForAuthenticated performs requests for "users/list-public-ssh-keys-for-authenticated"

List public SSH keys for the authenticated user.

  GET /user/keys

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
func (c Client) ListPublicSshKeysForAuthenticated(ctx context.Context, req *ListPublicSshKeysForAuthenticatedReq, opt ...requests.Option) (*ListPublicSshKeysForAuthenticatedResponse, error) {
	return ListPublicSshKeysForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
ListPublicSshKeysForAuthenticatedReq is request data for Client.ListPublicSshKeysForAuthenticated

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
type ListPublicSshKeysForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicSshKeysForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicSshKeysForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "users/list-public-ssh-keys-for-authenticated",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/keys"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicSshKeysForAuthenticatedReq) Rel(link string, resp *ListPublicSshKeysForAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicSshKeysForAuthenticatedResponse is a response for ListPublicSshKeysForAuthenticated

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
type ListPublicSshKeysForAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         []components.Key
}

func (r *ListPublicSshKeysForAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
SetPrimaryEmailVisibilityForAuthenticated performs requests for "users/set-primary-email-visibility-for-authenticated"

Set primary email visibility for the authenticated user.

  PATCH /user/email/visibility

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
func SetPrimaryEmailVisibilityForAuthenticated(ctx context.Context, req *SetPrimaryEmailVisibilityForAuthenticatedReq, opt ...requests.Option) (*SetPrimaryEmailVisibilityForAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetPrimaryEmailVisibilityForAuthenticatedReq)
	}
	resp := &SetPrimaryEmailVisibilityForAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewSetPrimaryEmailVisibilityForAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewSetPrimaryEmailVisibilityForAuthenticatedResponse builds a new *SetPrimaryEmailVisibilityForAuthenticatedResponse from an *http.Response
func NewSetPrimaryEmailVisibilityForAuthenticatedResponse(resp *http.Response, preserveBody bool) (*SetPrimaryEmailVisibilityForAuthenticatedResponse, error) {
	var result SetPrimaryEmailVisibilityForAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
SetPrimaryEmailVisibilityForAuthenticated performs requests for "users/set-primary-email-visibility-for-authenticated"

Set primary email visibility for the authenticated user.

  PATCH /user/email/visibility

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
func (c Client) SetPrimaryEmailVisibilityForAuthenticated(ctx context.Context, req *SetPrimaryEmailVisibilityForAuthenticatedReq, opt ...requests.Option) (*SetPrimaryEmailVisibilityForAuthenticatedResponse, error) {
	return SetPrimaryEmailVisibilityForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
SetPrimaryEmailVisibilityForAuthenticatedReq is request data for Client.SetPrimaryEmailVisibilityForAuthenticated

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
type SetPrimaryEmailVisibilityForAuthenticatedReq struct {
	_url        string
	RequestBody SetPrimaryEmailVisibilityForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetPrimaryEmailVisibilityForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetPrimaryEmailVisibilityForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "users/set-primary-email-visibility-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/email/visibility"),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetPrimaryEmailVisibilityForAuthenticatedReq) Rel(link string, resp *SetPrimaryEmailVisibilityForAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetPrimaryEmailVisibilityForAuthenticatedReqBody is a request body for users/set-primary-email-visibility-for-authenticated

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
type SetPrimaryEmailVisibilityForAuthenticatedReqBody struct {

	// An email address associated with the GitHub user account to manage.
	Email *string `json:"email"`

	// Denotes whether an email is publically visible.
	Visibility *string `json:"visibility"`
}

/*
SetPrimaryEmailVisibilityForAuthenticatedResponse is a response for SetPrimaryEmailVisibilityForAuthenticated

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
type SetPrimaryEmailVisibilityForAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         []components.Email
}

func (r *SetPrimaryEmailVisibilityForAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Unblock performs requests for "users/unblock"

Unblock a user.

  DELETE /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
func Unblock(ctx context.Context, req *UnblockReq, opt ...requests.Option) (*UnblockResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnblockReq)
	}
	resp := &UnblockResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUnblockResponse(r, opts.PreserveResponseBody())
}

// NewUnblockResponse builds a new *UnblockResponse from an *http.Response
func NewUnblockResponse(resp *http.Response, preserveBody bool) (*UnblockResponse, error) {
	var result UnblockResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
Unblock performs requests for "users/unblock"

Unblock a user.

  DELETE /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
func (c Client) Unblock(ctx context.Context, req *UnblockReq, opt ...requests.Option) (*UnblockResponse, error) {
	return Unblock(ctx, req, append(c, opt...)...)
}

/*
UnblockReq is request data for Client.Unblock

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
type UnblockReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *UnblockReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnblockReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "users/unblock",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/blocks/%v", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnblockReq) Rel(link string, resp *UnblockResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnblockResponse is a response for Unblock

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
type UnblockResponse struct {
	httpResponse *http.Response
}

func (r *UnblockResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Unfollow performs requests for "users/unfollow"

Unfollow a user.

  DELETE /user/following/{username}

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
func Unfollow(ctx context.Context, req *UnfollowReq, opt ...requests.Option) (*UnfollowResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnfollowReq)
	}
	resp := &UnfollowResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUnfollowResponse(r, opts.PreserveResponseBody())
}

// NewUnfollowResponse builds a new *UnfollowResponse from an *http.Response
func NewUnfollowResponse(resp *http.Response, preserveBody bool) (*UnfollowResponse, error) {
	var result UnfollowResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
Unfollow performs requests for "users/unfollow"

Unfollow a user.

  DELETE /user/following/{username}

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
func (c Client) Unfollow(ctx context.Context, req *UnfollowReq, opt ...requests.Option) (*UnfollowResponse, error) {
	return Unfollow(ctx, req, append(c, opt...)...)
}

/*
UnfollowReq is request data for Client.Unfollow

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
type UnfollowReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *UnfollowReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnfollowReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "users/unfollow",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/user/following/%v", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnfollowReq) Rel(link string, resp *UnfollowResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnfollowResponse is a response for Unfollow

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
type UnfollowResponse struct {
	httpResponse *http.Response
}

func (r *UnfollowResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateAuthenticated performs requests for "users/update-authenticated"

Update the authenticated user.

  PATCH /user

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
func UpdateAuthenticated(ctx context.Context, req *UpdateAuthenticatedReq, opt ...requests.Option) (*UpdateAuthenticatedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateAuthenticatedReq)
	}
	resp := &UpdateAuthenticatedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateAuthenticatedResponse(r, opts.PreserveResponseBody())
}

// NewUpdateAuthenticatedResponse builds a new *UpdateAuthenticatedResponse from an *http.Response
func NewUpdateAuthenticatedResponse(resp *http.Response, preserveBody bool) (*UpdateAuthenticatedResponse, error) {
	var result UpdateAuthenticatedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateAuthenticated performs requests for "users/update-authenticated"

Update the authenticated user.

  PATCH /user

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
func (c Client) UpdateAuthenticated(ctx context.Context, req *UpdateAuthenticatedReq, opt ...requests.Option) (*UpdateAuthenticatedResponse, error) {
	return UpdateAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UpdateAuthenticatedReq is request data for Client.UpdateAuthenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UpdateAuthenticatedReq struct {
	_url        string
	RequestBody UpdateAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "users/update-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user"),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateAuthenticatedReq) Rel(link string, resp *UpdateAuthenticatedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateAuthenticatedReqBody is a request body for users/update-authenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UpdateAuthenticatedReqBody struct {

	// The new short biography of the user.
	Bio *string `json:"bio,omitempty"`

	// The new blog URL of the user.
	Blog *string `json:"blog,omitempty"`

	// The new company of the user.
	Company *string `json:"company,omitempty"`

	// The publicly visible email address of the user.
	Email *string `json:"email,omitempty"`

	// The new hiring availability of the user.
	Hireable *bool `json:"hireable,omitempty"`

	// The new location of the user.
	Location *string `json:"location,omitempty"`

	// The new name of the user.
	Name *string `json:"name,omitempty"`

	// The new Twitter username of the user.
	TwitterUsername *string `json:"twitter_username,omitempty"`
}

/*
UpdateAuthenticatedResponse is a response for UpdateAuthenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UpdateAuthenticatedResponse struct {
	httpResponse *http.Response
	Data         components.PrivateUser
}

func (r *UpdateAuthenticatedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}
