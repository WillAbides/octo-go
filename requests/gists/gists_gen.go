// Code generated by octo-go; DO NOT EDIT.

package gists

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
CheckIsStarred performs requests for "gists/check-is-starred"

Check if a gist is starred.

  GET /gists/{gist_id}/star

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
func CheckIsStarred(ctx context.Context, req *CheckIsStarredReq, opt ...requests.Option) (*CheckIsStarredResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CheckIsStarredReq)
	}
	resp := &CheckIsStarredResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckIsStarred performs requests for "gists/check-is-starred"

Check if a gist is starred.

  GET /gists/{gist_id}/star

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CheckIsStarred(ctx context.Context, req *CheckIsStarredReq, opt ...requests.Option) (*CheckIsStarredResponse, error) {
	return CheckIsStarred(ctx, req, append(c, opt...)...)
}

/*
CheckIsStarredReq is request data for Client.CheckIsStarred

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CheckIsStarredReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CheckIsStarredReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/%v/star", r.GistId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckIsStarredReq) Rel(link string, resp *CheckIsStarredResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckIsStarredResponse is a response for CheckIsStarred

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
type CheckIsStarredResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *CheckIsStarredResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CheckIsStarredResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
Create performs requests for "gists/create"

Create a gist.

  POST /gists

https://developer.github.com/v3/gists/#create-a-gist
*/
func Create(ctx context.Context, req *CreateReq, opt ...requests.Option) (*CreateResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CreateReq)
	}
	resp := &CreateResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Create performs requests for "gists/create"

Create a gist.

  POST /gists

https://developer.github.com/v3/gists/#create-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Create(ctx context.Context, req *CreateReq, opt ...requests.Option) (*CreateResponse, error) {
	return Create(ctx, req, append(c, opt...)...)
}

/*
CreateReq is request data for Client.Create

https://developer.github.com/v3/gists/#create-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CreateReq struct {
	_url        string
	RequestBody CreateReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CreateReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "POST",
		Options: opt,
		URLPath: fmt.Sprintf("/gists"),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateReq) Rel(link string, resp *CreateResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateReqBodyFiles is a value for CreateReqBody's Files field
type CreateReqBodyFiles struct {

	// Content of the file
	Content *string `json:"content"`
}

/*
CreateReqBody is a request body for gists/create

https://developer.github.com/v3/gists/#create-a-gist
*/
type CreateReqBody struct {

	// Description of the gist
	Description *string `json:"description,omitempty"`

	// Names and content for the files that make up the gist
	Files map[string]CreateReqBodyFiles `json:"files"`

	// Flag indicating whether the gist is public
	Public *bool `json:"public,omitempty"`
}

/*
CreateResponse is a response for Create

https://developer.github.com/v3/gists/#create-a-gist
*/
type CreateResponse struct {
	httpResponse *http.Response
	Data         components.GistFull
}

// HTTPResponse returns the *http.Response
func (r *CreateResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CreateResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{201, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
CreateComment performs requests for "gists/create-comment"

Create a gist comment.

  POST /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
func CreateComment(ctx context.Context, req *CreateCommentReq, opt ...requests.Option) (*CreateCommentResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(CreateCommentReq)
	}
	resp := &CreateCommentResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateComment performs requests for "gists/create-comment"

Create a gist comment.

  POST /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#create-a-gist-comment

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) CreateComment(ctx context.Context, req *CreateCommentReq, opt ...requests.Option) (*CreateCommentResponse, error) {
	return CreateComment(ctx, req, append(c, opt...)...)
}

/*
CreateCommentReq is request data for Client.CreateComment

https://developer.github.com/v3/gists/comments/#create-a-gist-comment

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type CreateCommentReq struct {
	_url string

	// gist_id parameter
	GistId      string
	RequestBody CreateCommentReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *CreateCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "POST",
		Options: opt,
		URLPath: fmt.Sprintf("/gists/%v/comments", r.GistId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateCommentReq) Rel(link string, resp *CreateCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateCommentReqBody is a request body for gists/create-comment

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
type CreateCommentReqBody struct {

	// The comment text.
	Body *string `json:"body"`
}

/*
CreateCommentResponse is a response for CreateComment

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
type CreateCommentResponse struct {
	httpResponse *http.Response
	Data         components.GistComment
}

// HTTPResponse returns the *http.Response
func (r *CreateCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *CreateCommentResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{201, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
Delete performs requests for "gists/delete"

Delete a gist.

  DELETE /gists/{gist_id}

https://developer.github.com/v3/gists/#delete-a-gist
*/
func Delete(ctx context.Context, req *DeleteReq, opt ...requests.Option) (*DeleteResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DeleteReq)
	}
	resp := &DeleteResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Delete performs requests for "gists/delete"

Delete a gist.

  DELETE /gists/{gist_id}

https://developer.github.com/v3/gists/#delete-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Delete(ctx context.Context, req *DeleteReq, opt ...requests.Option) (*DeleteResponse, error) {
	return Delete(ctx, req, append(c, opt...)...)
}

/*
DeleteReq is request data for Client.Delete

https://developer.github.com/v3/gists/#delete-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DeleteReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DeleteReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/%v", r.GistId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteReq) Rel(link string, resp *DeleteResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteResponse is a response for Delete

https://developer.github.com/v3/gists/#delete-a-gist
*/
type DeleteResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *DeleteResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DeleteResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteComment performs requests for "gists/delete-comment"

Delete a gist comment.

  DELETE /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
func DeleteComment(ctx context.Context, req *DeleteCommentReq, opt ...requests.Option) (*DeleteCommentResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(DeleteCommentReq)
	}
	resp := &DeleteCommentResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteComment performs requests for "gists/delete-comment"

Delete a gist comment.

  DELETE /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) DeleteComment(ctx context.Context, req *DeleteCommentReq, opt ...requests.Option) (*DeleteCommentResponse, error) {
	return DeleteComment(ctx, req, append(c, opt...)...)
}

/*
DeleteCommentReq is request data for Client.DeleteComment

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type DeleteCommentReq struct {
	_url string

	// gist_id parameter
	GistId string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *DeleteCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteCommentReq) Rel(link string, resp *DeleteCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteCommentResponse is a response for DeleteComment

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
type DeleteCommentResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *DeleteCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *DeleteCommentResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
Fork performs requests for "gists/fork"

Fork a gist.

  POST /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#fork-a-gist
*/
func Fork(ctx context.Context, req *ForkReq, opt ...requests.Option) (*ForkResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ForkReq)
	}
	resp := &ForkResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Fork performs requests for "gists/fork"

Fork a gist.

  POST /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#fork-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Fork(ctx context.Context, req *ForkReq, opt ...requests.Option) (*ForkResponse, error) {
	return Fork(ctx, req, append(c, opt...)...)
}

/*
ForkReq is request data for Client.Fork

https://developer.github.com/v3/gists/#fork-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ForkReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ForkReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "POST",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/%v/forks", r.GistId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ForkReq) Rel(link string, resp *ForkResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ForkResponse is a response for Fork

https://developer.github.com/v3/gists/#fork-a-gist
*/
type ForkResponse struct {
	httpResponse *http.Response
	Data         components.BaseGist
}

// HTTPResponse returns the *http.Response
func (r *ForkResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ForkResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{201, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
Get performs requests for "gists/get"

Get a gist.

  GET /gists/{gist_id}

https://developer.github.com/v3/gists/#get-a-gist
*/
func Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetReq)
	}
	resp := &GetResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Get performs requests for "gists/get"

Get a gist.

  GET /gists/{gist_id}

https://developer.github.com/v3/gists/#get-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	return Get(ctx, req, append(c, opt...)...)
}

/*
GetReq is request data for Client.Get

https://developer.github.com/v3/gists/#get-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/%v", r.GistId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReq) Rel(link string, resp *GetResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetResponse is a response for Get

https://developer.github.com/v3/gists/#get-a-gist
*/
type GetResponse struct {
	httpResponse *http.Response
	Data         components.GistFull
}

// HTTPResponse returns the *http.Response
func (r *GetResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetComment performs requests for "gists/get-comment"

Get a gist comment.

  GET /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
func GetComment(ctx context.Context, req *GetCommentReq, opt ...requests.Option) (*GetCommentResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetCommentReq)
	}
	resp := &GetCommentResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetComment performs requests for "gists/get-comment"

Get a gist comment.

  GET /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#get-a-gist-comment

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetComment(ctx context.Context, req *GetCommentReq, opt ...requests.Option) (*GetCommentResponse, error) {
	return GetComment(ctx, req, append(c, opt...)...)
}

/*
GetCommentReq is request data for Client.GetComment

https://developer.github.com/v3/gists/comments/#get-a-gist-comment

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetCommentReq struct {
	_url string

	// gist_id parameter
	GistId string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCommentReq) Rel(link string, resp *GetCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCommentResponse is a response for GetComment

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
type GetCommentResponse struct {
	httpResponse *http.Response
	Data         components.GistComment
}

// HTTPResponse returns the *http.Response
func (r *GetCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetCommentResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetRevision performs requests for "gists/get-revision"

Get a gist revision.

  GET /gists/{gist_id}/{sha}

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
func GetRevision(ctx context.Context, req *GetRevisionReq, opt ...requests.Option) (*GetRevisionResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(GetRevisionReq)
	}
	resp := &GetRevisionResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetRevision performs requests for "gists/get-revision"

Get a gist revision.

  GET /gists/{gist_id}/{sha}

https://developer.github.com/v3/gists/#get-a-gist-revision

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) GetRevision(ctx context.Context, req *GetRevisionReq, opt ...requests.Option) (*GetRevisionResponse, error) {
	return GetRevision(ctx, req, append(c, opt...)...)
}

/*
GetRevisionReq is request data for Client.GetRevision

https://developer.github.com/v3/gists/#get-a-gist-revision

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type GetRevisionReq struct {
	_url string

	// gist_id parameter
	GistId string

	// sha parameter
	Sha string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *GetRevisionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/%v/%v", r.GistId, r.Sha),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetRevisionReq) Rel(link string, resp *GetRevisionResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetRevisionResponse is a response for GetRevision

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
type GetRevisionResponse struct {
	httpResponse *http.Response
	Data         components.GistFull
}

// HTTPResponse returns the *http.Response
func (r *GetRevisionResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *GetRevisionResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
List performs requests for "gists/list"

List gists for the authenticated user.

  GET /gists

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
func List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListReq)
	}
	resp := &ListResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
List performs requests for "gists/list"

List gists for the authenticated user.

  GET /gists

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	return List(ctx, req, append(c, opt...)...)
}

/*
ListReq is request data for Client.List

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists"),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReq) Rel(link string, resp *ListResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListResponse is a response for List

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
type ListResponse struct {
	httpResponse *http.Response
	Data         []components.BaseGist
}

// HTTPResponse returns the *http.Response
func (r *ListResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListComments performs requests for "gists/list-comments"

List gist comments.

  GET /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
func ListComments(ctx context.Context, req *ListCommentsReq, opt ...requests.Option) (*ListCommentsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListCommentsReq)
	}
	resp := &ListCommentsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListComments performs requests for "gists/list-comments"

List gist comments.

  GET /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#list-gist-comments

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListComments(ctx context.Context, req *ListCommentsReq, opt ...requests.Option) (*ListCommentsResponse, error) {
	return ListComments(ctx, req, append(c, opt...)...)
}

/*
ListCommentsReq is request data for Client.ListComments

https://developer.github.com/v3/gists/comments/#list-gist-comments

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListCommentsReq struct {
	_url string

	// gist_id parameter
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListCommentsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/%v/comments", r.GistId),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommentsReq) Rel(link string, resp *ListCommentsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommentsResponse is a response for ListComments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
type ListCommentsResponse struct {
	httpResponse *http.Response
	Data         []components.GistComment
}

// HTTPResponse returns the *http.Response
func (r *ListCommentsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListCommentsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListCommits performs requests for "gists/list-commits"

List gist commits.

  GET /gists/{gist_id}/commits

https://developer.github.com/v3/gists/#list-gist-commits
*/
func ListCommits(ctx context.Context, req *ListCommitsReq, opt ...requests.Option) (*ListCommitsResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListCommitsReq)
	}
	resp := &ListCommitsResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListCommits performs requests for "gists/list-commits"

List gist commits.

  GET /gists/{gist_id}/commits

https://developer.github.com/v3/gists/#list-gist-commits

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListCommits(ctx context.Context, req *ListCommitsReq, opt ...requests.Option) (*ListCommitsResponse, error) {
	return ListCommits(ctx, req, append(c, opt...)...)
}

/*
ListCommitsReq is request data for Client.ListCommits

https://developer.github.com/v3/gists/#list-gist-commits

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListCommitsReq struct {
	_url string

	// gist_id parameter
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListCommitsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/%v/commits", r.GistId),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommitsReq) Rel(link string, resp *ListCommitsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommitsResponse is a response for ListCommits

https://developer.github.com/v3/gists/#list-gist-commits
*/
type ListCommitsResponse struct {
	httpResponse *http.Response
	Data         []components.GistCommit
}

// HTTPResponse returns the *http.Response
func (r *ListCommitsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListCommitsResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListForUser performs requests for "gists/list-for-user"

List gists for a user.

  GET /users/{username}/gists

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
func ListForUser(ctx context.Context, req *ListForUserReq, opt ...requests.Option) (*ListForUserResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListForUserReq)
	}
	resp := &ListForUserResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForUser performs requests for "gists/list-for-user"

List gists for a user.

  GET /users/{username}/gists

https://developer.github.com/v3/gists/#list-gists-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListForUser(ctx context.Context, req *ListForUserReq, opt ...requests.Option) (*ListForUserResponse, error) {
	return ListForUser(ctx, req, append(c, opt...)...)
}

/*
ListForUserReq is request data for Client.ListForUser

https://developer.github.com/v3/gists/#list-gists-for-a-user

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListForUserReq struct {
	_url     string
	Username string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/users/%v/gists", r.Username),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForUserReq) Rel(link string, resp *ListForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForUserResponse is a response for ListForUser

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
type ListForUserResponse struct {
	httpResponse *http.Response
	Data         []components.BaseGist
}

// HTTPResponse returns the *http.Response
func (r *ListForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListForUserResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListForks performs requests for "gists/list-forks"

List gist forks.

  GET /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#list-gist-forks
*/
func ListForks(ctx context.Context, req *ListForksReq, opt ...requests.Option) (*ListForksResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListForksReq)
	}
	resp := &ListForksResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForks performs requests for "gists/list-forks"

List gist forks.

  GET /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#list-gist-forks

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListForks(ctx context.Context, req *ListForksReq, opt ...requests.Option) (*ListForksResponse, error) {
	return ListForks(ctx, req, append(c, opt...)...)
}

/*
ListForksReq is request data for Client.ListForks

https://developer.github.com/v3/gists/#list-gist-forks

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListForksReq struct {
	_url string

	// gist_id parameter
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListForksReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/%v/forks", r.GistId),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForksReq) Rel(link string, resp *ListForksResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForksResponse is a response for ListForks

https://developer.github.com/v3/gists/#list-gist-forks
*/
type ListForksResponse struct {
	httpResponse *http.Response
	Data         []components.GistFull
}

// HTTPResponse returns the *http.Response
func (r *ListForksResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListForksResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListPublic performs requests for "gists/list-public"

List public gists.

  GET /gists/public

https://developer.github.com/v3/gists/#list-public-gists
*/
func ListPublic(ctx context.Context, req *ListPublicReq, opt ...requests.Option) (*ListPublicResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListPublicReq)
	}
	resp := &ListPublicResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublic performs requests for "gists/list-public"

List public gists.

  GET /gists/public

https://developer.github.com/v3/gists/#list-public-gists

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListPublic(ctx context.Context, req *ListPublicReq, opt ...requests.Option) (*ListPublicResponse, error) {
	return ListPublic(ctx, req, append(c, opt...)...)
}

/*
ListPublicReq is request data for Client.ListPublic

https://developer.github.com/v3/gists/#list-public-gists

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListPublicReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListPublicReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/public"),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicReq) Rel(link string, resp *ListPublicResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicResponse is a response for ListPublic

https://developer.github.com/v3/gists/#list-public-gists
*/
type ListPublicResponse struct {
	httpResponse *http.Response
	Data         []components.BaseGist
}

// HTTPResponse returns the *http.Response
func (r *ListPublicResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListPublicResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
ListStarred performs requests for "gists/list-starred"

List starred gists.

  GET /gists/starred

https://developer.github.com/v3/gists/#list-starred-gists
*/
func ListStarred(ctx context.Context, req *ListStarredReq, opt ...requests.Option) (*ListStarredResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(ListStarredReq)
	}
	resp := &ListStarredResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListStarred performs requests for "gists/list-starred"

List starred gists.

  GET /gists/starred

https://developer.github.com/v3/gists/#list-starred-gists

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) ListStarred(ctx context.Context, req *ListStarredReq, opt ...requests.Option) (*ListStarredResponse, error) {
	return ListStarred(ctx, req, append(c, opt...)...)
}

/*
ListStarredReq is request data for Client.ListStarred

https://developer.github.com/v3/gists/#list-starred-gists

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type ListStarredReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *ListStarredReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		HeaderVals:  map[string]*string{"accept": internal.String("application/json")},
		Method:      "GET",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/starred"),
		URLQuery:    query,
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListStarredReq) Rel(link string, resp *ListStarredResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListStarredResponse is a response for ListStarred

https://developer.github.com/v3/gists/#list-starred-gists
*/
type ListStarredResponse struct {
	httpResponse *http.Response
	Data         []components.BaseGist
}

// HTTPResponse returns the *http.Response
func (r *ListStarredResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *ListStarredResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200, 304})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
Star performs requests for "gists/star"

Star a gist.

  PUT /gists/{gist_id}/star

https://developer.github.com/v3/gists/#star-a-gist
*/
func Star(ctx context.Context, req *StarReq, opt ...requests.Option) (*StarResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(StarReq)
	}
	resp := &StarResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Star performs requests for "gists/star"

Star a gist.

  PUT /gists/{gist_id}/star

https://developer.github.com/v3/gists/#star-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Star(ctx context.Context, req *StarReq, opt ...requests.Option) (*StarResponse, error) {
	return Star(ctx, req, append(c, opt...)...)
}

/*
StarReq is request data for Client.Star

https://developer.github.com/v3/gists/#star-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type StarReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *StarReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		Method:      "PUT",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/%v/star", r.GistId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StarReq) Rel(link string, resp *StarResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StarResponse is a response for Star

https://developer.github.com/v3/gists/#star-a-gist
*/
type StarResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *StarResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *StarResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
Unstar performs requests for "gists/unstar"

Unstar a gist.

  DELETE /gists/{gist_id}/star

https://developer.github.com/v3/gists/#unstar-a-gist
*/
func Unstar(ctx context.Context, req *UnstarReq, opt ...requests.Option) (*UnstarResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UnstarReq)
	}
	resp := &UnstarResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Unstar performs requests for "gists/unstar"

Unstar a gist.

  DELETE /gists/{gist_id}/star

https://developer.github.com/v3/gists/#unstar-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Unstar(ctx context.Context, req *UnstarReq, opt ...requests.Option) (*UnstarResponse, error) {
	return Unstar(ctx, req, append(c, opt...)...)
}

/*
UnstarReq is request data for Client.Unstar

https://developer.github.com/v3/gists/#unstar-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UnstarReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UnstarReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		ExplicitURL: r._url,
		Method:      "DELETE",
		Options:     opt,
		URLPath:     fmt.Sprintf("/gists/%v/star", r.GistId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnstarReq) Rel(link string, resp *UnstarResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnstarResponse is a response for Unstar

https://developer.github.com/v3/gists/#unstar-a-gist
*/
type UnstarResponse struct {
	httpResponse *http.Response
}

// HTTPResponse returns the *http.Response
func (r *UnstarResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UnstarResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{204, 304})
	if err != nil {
		return err
	}
	return nil
}

/*
Update performs requests for "gists/update"

Update a gist.

  PATCH /gists/{gist_id}

https://developer.github.com/v3/gists/#update-a-gist
*/
func Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UpdateReq)
	}
	resp := &UpdateResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Update performs requests for "gists/update"

Update a gist.

  PATCH /gists/{gist_id}

https://developer.github.com/v3/gists/#update-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	return Update(ctx, req, append(c, opt...)...)
}

/*
UpdateReq is request data for Client.Update

https://developer.github.com/v3/gists/#update-a-gist

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UpdateReq struct {
	_url string

	// gist_id parameter
	GistId      string
	RequestBody UpdateReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UpdateReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "PATCH",
		Options: opt,
		URLPath: fmt.Sprintf("/gists/%v", r.GistId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReq) Rel(link string, resp *UpdateResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// UpdateReqBodyFiles is a value for UpdateReqBody's Files field
type UpdateReqBodyFiles struct {

	// The new content of the file
	Content *string `json:"content,omitempty"`

	// The new filename for the file
	Filename *string `json:"filename,omitempty"`
}

/*
UpdateReqBody is a request body for gists/update

https://developer.github.com/v3/gists/#update-a-gist
*/
type UpdateReqBody struct {

	// Description of the gist
	Description *string `json:"description,omitempty"`

	// Names of files to be updated
	Files map[string]UpdateReqBodyFiles `json:"files,omitempty"`
}

/*
UpdateResponse is a response for Update

https://developer.github.com/v3/gists/#update-a-gist
*/
type UpdateResponse struct {
	httpResponse *http.Response
	Data         components.GistFull
}

// HTTPResponse returns the *http.Response
func (r *UpdateResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UpdateResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

/*
UpdateComment performs requests for "gists/update-comment"

Update a gist comment.

  PATCH /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
func UpdateComment(ctx context.Context, req *UpdateCommentReq, opt ...requests.Option) (*UpdateCommentResponse, error) {
	opts := requests.BuildOptions(opt...)
	if req == nil {
		req = new(UpdateCommentReq)
	}
	resp := &UpdateCommentResponse{}

	httpReq, err := req.HTTPRequest(ctx, opt...)
	if err != nil {
		return nil, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}

	err = resp.ReadResponse(r)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateComment performs requests for "gists/update-comment"

Update a gist comment.

  PATCH /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#update-a-gist-comment

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
func (c Client) UpdateComment(ctx context.Context, req *UpdateCommentReq, opt ...requests.Option) (*UpdateCommentResponse, error) {
	return UpdateComment(ctx, req, append(c, opt...)...)
}

/*
UpdateCommentReq is request data for Client.UpdateComment

https://developer.github.com/v3/gists/comments/#update-a-gist-comment

Non-nil errors will have the type *requests.RequestError, octo.ResponseError or url.Error.
*/
type UpdateCommentReq struct {
	_url string

	// gist_id parameter
	GistId string

	// comment_id parameter
	CommentId   int64
	RequestBody UpdateCommentReqBody
}

// HTTPRequest builds an *http.Request. Non-nil errors will have the type *requests.RequestError.
func (r *UpdateCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	return internal.BuildHTTPRequest(ctx, internal.BuildHTTPRequestOptions{
		Body:        r.RequestBody,
		ExplicitURL: r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:  "PATCH",
		Options: opt,
		URLPath: fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId),
	})
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateCommentReq) Rel(link string, resp *UpdateCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateCommentReqBody is a request body for gists/update-comment

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
type UpdateCommentReqBody struct {

	// The comment text.
	Body *string `json:"body"`
}

/*
UpdateCommentResponse is a response for UpdateComment

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
type UpdateCommentResponse struct {
	httpResponse *http.Response
	Data         components.GistComment
}

// HTTPResponse returns the *http.Response
func (r *UpdateCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

// ReadResponse reads an *http.Response. Non-nil errors will have the type octo.ResponseError.
func (r *UpdateCommentResponse) ReadResponse(resp *http.Response) error {
	r.httpResponse = resp
	err := internal.ResponseErrorCheck(resp, []int{200})
	if err != nil {
		return err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.UnmarshalResponseBody(resp, &r.Data)
		if err != nil {
			return err
		}
	}
	return nil
}
