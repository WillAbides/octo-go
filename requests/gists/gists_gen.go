// Code generated by octo-go; DO NOT EDIT.

package gists

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []options.Option

// NewClient returns a new Client
func NewClient(opt ...options.Option) Client {
	return opt
}

/*
CheckIsStarred performs requests for "gists/check-is-starred"

Check if a gist is starred.

  GET /gists/{gist_id}/star

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
func CheckIsStarred(ctx context.Context, req *CheckIsStarredReq, opt ...options.Option) (*CheckIsStarredResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckIsStarredReq)
	}
	resp := &CheckIsStarredResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CheckIsStarred performs requests for "gists/check-is-starred"

Check if a gist is starred.

  GET /gists/{gist_id}/star

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
func (c Client) CheckIsStarred(ctx context.Context, req *CheckIsStarredReq, opt ...options.Option) (*CheckIsStarredResponse, error) {
	return CheckIsStarred(ctx, req, append(c, opt...)...)
}

/*
CheckIsStarredReq is request data for Client.CheckIsStarred

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
type CheckIsStarredReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *CheckIsStarredReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckIsStarredReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "gists/check-is-starred",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/star", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckIsStarredReq) Rel(link string, resp *CheckIsStarredResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckIsStarredResponse is a response for CheckIsStarred

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
type CheckIsStarredResponse struct {
	common.Response
	request *CheckIsStarredReq
}

/*
Create performs requests for "gists/create"

Create a gist.

  POST /gists

https://developer.github.com/v3/gists/#create-a-gist
*/
func Create(ctx context.Context, req *CreateReq, opt ...options.Option) (*CreateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateReq)
	}
	resp := &CreateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Create performs requests for "gists/create"

Create a gist.

  POST /gists

https://developer.github.com/v3/gists/#create-a-gist
*/
func (c Client) Create(ctx context.Context, req *CreateReq, opt ...options.Option) (*CreateResponse, error) {
	return Create(ctx, req, append(c, opt...)...)
}

/*
CreateReq is request data for Client.Create

https://developer.github.com/v3/gists/#create-a-gist
*/
type CreateReq struct {
	_url        string
	RequestBody CreateReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "gists/create",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateReq) Rel(link string, resp *CreateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateReqBodyFiles is a value for CreateReqBody's Files field
type CreateReqBodyFiles struct {

	// Content of the file
	Content *string `json:"content"`
}

/*
CreateReqBody is a request body for gists/create

https://developer.github.com/v3/gists/#create-a-gist
*/
type CreateReqBody struct {

	// Description of the gist
	Description *string `json:"description,omitempty"`

	// Names and content for the files that make up the gist
	Files map[string]CreateReqBodyFiles `json:"files"`

	// Flag indicating whether the gist is public
	Public *bool `json:"public,omitempty"`
}

/*
CreateResponse is a response for Create

https://developer.github.com/v3/gists/#create-a-gist
*/
type CreateResponse struct {
	common.Response
	request *CreateReq
	Data    components.GistFull
}

/*
CreateComment performs requests for "gists/create-comment"

Create a gist comment.

  POST /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
func CreateComment(ctx context.Context, req *CreateCommentReq, opt ...options.Option) (*CreateCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateCommentReq)
	}
	resp := &CreateCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
CreateComment performs requests for "gists/create-comment"

Create a gist comment.

  POST /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
func (c Client) CreateComment(ctx context.Context, req *CreateCommentReq, opt ...options.Option) (*CreateCommentResponse, error) {
	return CreateComment(ctx, req, append(c, opt...)...)
}

/*
CreateCommentReq is request data for Client.CreateComment

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
type CreateCommentReq struct {
	_url string

	// gist_id parameter
	GistId      string
	RequestBody CreateCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "gists/create-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/comments", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateCommentReq) Rel(link string, resp *CreateCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateCommentReqBody is a request body for gists/create-comment

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
type CreateCommentReqBody struct {

	// The comment text.
	Body *string `json:"body"`
}

/*
CreateCommentResponse is a response for CreateComment

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
type CreateCommentResponse struct {
	common.Response
	request *CreateCommentReq
	Data    components.GistComment
}

/*
Delete performs requests for "gists/delete"

Delete a gist.

  DELETE /gists/{gist_id}

https://developer.github.com/v3/gists/#delete-a-gist
*/
func Delete(ctx context.Context, req *DeleteReq, opt ...options.Option) (*DeleteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteReq)
	}
	resp := &DeleteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Delete performs requests for "gists/delete"

Delete a gist.

  DELETE /gists/{gist_id}

https://developer.github.com/v3/gists/#delete-a-gist
*/
func (c Client) Delete(ctx context.Context, req *DeleteReq, opt ...options.Option) (*DeleteResponse, error) {
	return Delete(ctx, req, append(c, opt...)...)
}

/*
DeleteReq is request data for Client.Delete

https://developer.github.com/v3/gists/#delete-a-gist
*/
type DeleteReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *DeleteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "gists/delete",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteReq) Rel(link string, resp *DeleteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteResponse is a response for Delete

https://developer.github.com/v3/gists/#delete-a-gist
*/
type DeleteResponse struct {
	common.Response
	request *DeleteReq
}

/*
DeleteComment performs requests for "gists/delete-comment"

Delete a gist comment.

  DELETE /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
func DeleteComment(ctx context.Context, req *DeleteCommentReq, opt ...options.Option) (*DeleteCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteCommentReq)
	}
	resp := &DeleteCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
DeleteComment performs requests for "gists/delete-comment"

Delete a gist comment.

  DELETE /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
func (c Client) DeleteComment(ctx context.Context, req *DeleteCommentReq, opt ...options.Option) (*DeleteCommentResponse, error) {
	return DeleteComment(ctx, req, append(c, opt...)...)
}

/*
DeleteCommentReq is request data for Client.DeleteComment

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
type DeleteCommentReq struct {
	_url string

	// gist_id parameter
	GistId string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "gists/delete-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteCommentReq) Rel(link string, resp *DeleteCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteCommentResponse is a response for DeleteComment

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
type DeleteCommentResponse struct {
	common.Response
	request *DeleteCommentReq
}

/*
Fork performs requests for "gists/fork"

Fork a gist.

  POST /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#fork-a-gist
*/
func Fork(ctx context.Context, req *ForkReq, opt ...options.Option) (*ForkResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ForkReq)
	}
	resp := &ForkResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.BaseGist{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Fork performs requests for "gists/fork"

Fork a gist.

  POST /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#fork-a-gist
*/
func (c Client) Fork(ctx context.Context, req *ForkReq, opt ...options.Option) (*ForkResponse, error) {
	return Fork(ctx, req, append(c, opt...)...)
}

/*
ForkReq is request data for Client.Fork

https://developer.github.com/v3/gists/#fork-a-gist
*/
type ForkReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *ForkReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ForkReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{201},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "POST",
		OperationID:      "gists/fork",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/forks", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ForkReq) Rel(link string, resp *ForkResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ForkResponse is a response for Fork

https://developer.github.com/v3/gists/#fork-a-gist
*/
type ForkResponse struct {
	common.Response
	request *ForkReq
	Data    components.BaseGist
}

/*
Get performs requests for "gists/get"

Get a gist.

  GET /gists/{gist_id}

https://developer.github.com/v3/gists/#get-a-gist
*/
func Get(ctx context.Context, req *GetReq, opt ...options.Option) (*GetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetReq)
	}
	resp := &GetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Get performs requests for "gists/get"

Get a gist.

  GET /gists/{gist_id}

https://developer.github.com/v3/gists/#get-a-gist
*/
func (c Client) Get(ctx context.Context, req *GetReq, opt ...options.Option) (*GetResponse, error) {
	return Get(ctx, req, append(c, opt...)...)
}

/*
GetReq is request data for Client.Get

https://developer.github.com/v3/gists/#get-a-gist
*/
type GetReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *GetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "gists/get",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReq) Rel(link string, resp *GetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetResponse is a response for Get

https://developer.github.com/v3/gists/#get-a-gist
*/
type GetResponse struct {
	common.Response
	request *GetReq
	Data    components.GistFull
}

/*
GetComment performs requests for "gists/get-comment"

Get a gist comment.

  GET /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
func GetComment(ctx context.Context, req *GetCommentReq, opt ...options.Option) (*GetCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCommentReq)
	}
	resp := &GetCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetComment performs requests for "gists/get-comment"

Get a gist comment.

  GET /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
func (c Client) GetComment(ctx context.Context, req *GetCommentReq, opt ...options.Option) (*GetCommentResponse, error) {
	return GetComment(ctx, req, append(c, opt...)...)
}

/*
GetCommentReq is request data for Client.GetComment

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
type GetCommentReq struct {
	_url string

	// gist_id parameter
	GistId string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request
func (r *GetCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "gists/get-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCommentReq) Rel(link string, resp *GetCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCommentResponse is a response for GetComment

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
type GetCommentResponse struct {
	common.Response
	request *GetCommentReq
	Data    components.GistComment
}

/*
GetRevision performs requests for "gists/get-revision"

Get a gist revision.

  GET /gists/{gist_id}/{sha}

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
func GetRevision(ctx context.Context, req *GetRevisionReq, opt ...options.Option) (*GetRevisionResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetRevisionReq)
	}
	resp := &GetRevisionResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GetRevision performs requests for "gists/get-revision"

Get a gist revision.

  GET /gists/{gist_id}/{sha}

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
func (c Client) GetRevision(ctx context.Context, req *GetRevisionReq, opt ...options.Option) (*GetRevisionResponse, error) {
	return GetRevision(ctx, req, append(c, opt...)...)
}

/*
GetRevisionReq is request data for Client.GetRevision

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
type GetRevisionReq struct {
	_url string

	// gist_id parameter
	GistId string

	// sha parameter
	Sha string
}

// HTTPRequest builds an *http.Request
func (r *GetRevisionReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetRevisionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "gists/get-revision",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/%v", r.GistId, r.Sha),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetRevisionReq) Rel(link string, resp *GetRevisionResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetRevisionResponse is a response for GetRevision

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
type GetRevisionResponse struct {
	common.Response
	request *GetRevisionReq
	Data    components.GistFull
}

/*
List performs requests for "gists/list"

List gists for the authenticated user.

  GET /gists

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
func List(ctx context.Context, req *ListReq, opt ...options.Option) (*ListResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReq)
	}
	resp := &ListResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.BaseGist{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
List performs requests for "gists/list"

List gists for the authenticated user.

  GET /gists

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
func (c Client) List(ctx context.Context, req *ListReq, opt ...options.Option) (*ListResponse, error) {
	return List(ctx, req, append(c, opt...)...)
}

/*
ListReq is request data for Client.List

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
type ListReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReq) Rel(link string, resp *ListResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListResponse is a response for List

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
type ListResponse struct {
	common.Response
	request *ListReq
	Data    []components.BaseGist
}

/*
ListComments performs requests for "gists/list-comments"

List gist comments.

  GET /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
func ListComments(ctx context.Context, req *ListCommentsReq, opt ...options.Option) (*ListCommentsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListCommentsReq)
	}
	resp := &ListCommentsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.GistComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListComments performs requests for "gists/list-comments"

List gist comments.

  GET /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
func (c Client) ListComments(ctx context.Context, req *ListCommentsReq, opt ...options.Option) (*ListCommentsResponse, error) {
	return ListComments(ctx, req, append(c, opt...)...)
}

/*
ListCommentsReq is request data for Client.ListComments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
type ListCommentsReq struct {
	_url string

	// gist_id parameter
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListCommentsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListCommentsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list-comments",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/comments", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommentsReq) Rel(link string, resp *ListCommentsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommentsResponse is a response for ListComments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
type ListCommentsResponse struct {
	common.Response
	request *ListCommentsReq
	Data    []components.GistComment
}

/*
ListCommits performs requests for "gists/list-commits"

List gist commits.

  GET /gists/{gist_id}/commits

https://developer.github.com/v3/gists/#list-gist-commits
*/
func ListCommits(ctx context.Context, req *ListCommitsReq, opt ...options.Option) (*ListCommitsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListCommitsReq)
	}
	resp := &ListCommitsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.GistCommit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListCommits performs requests for "gists/list-commits"

List gist commits.

  GET /gists/{gist_id}/commits

https://developer.github.com/v3/gists/#list-gist-commits
*/
func (c Client) ListCommits(ctx context.Context, req *ListCommitsReq, opt ...options.Option) (*ListCommitsResponse, error) {
	return ListCommits(ctx, req, append(c, opt...)...)
}

/*
ListCommitsReq is request data for Client.ListCommits

https://developer.github.com/v3/gists/#list-gist-commits
*/
type ListCommitsReq struct {
	_url string

	// gist_id parameter
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListCommitsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListCommitsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list-commits",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/commits", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommitsReq) Rel(link string, resp *ListCommitsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommitsResponse is a response for ListCommits

https://developer.github.com/v3/gists/#list-gist-commits
*/
type ListCommitsResponse struct {
	common.Response
	request *ListCommitsReq
	Data    []components.GistCommit
}

/*
ListForUser performs requests for "gists/list-for-user"

List gists for a user.

  GET /users/{username}/gists

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
func ListForUser(ctx context.Context, req *ListForUserReq, opt ...options.Option) (*ListForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForUserReq)
	}
	resp := &ListForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.BaseGist{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForUser performs requests for "gists/list-for-user"

List gists for a user.

  GET /users/{username}/gists

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
func (c Client) ListForUser(ctx context.Context, req *ListForUserReq, opt ...options.Option) (*ListForUserResponse, error) {
	return ListForUser(ctx, req, append(c, opt...)...)
}

/*
ListForUserReq is request data for Client.ListForUser

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
type ListForUserReq struct {
	_url     string
	Username string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/gists", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForUserReq) Rel(link string, resp *ListForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForUserResponse is a response for ListForUser

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
type ListForUserResponse struct {
	common.Response
	request *ListForUserReq
	Data    []components.BaseGist
}

/*
ListForks performs requests for "gists/list-forks"

List gist forks.

  GET /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#list-gist-forks
*/
func ListForks(ctx context.Context, req *ListForksReq, opt ...options.Option) (*ListForksResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForksReq)
	}
	resp := &ListForksResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.GistFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListForks performs requests for "gists/list-forks"

List gist forks.

  GET /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#list-gist-forks
*/
func (c Client) ListForks(ctx context.Context, req *ListForksReq, opt ...options.Option) (*ListForksResponse, error) {
	return ListForks(ctx, req, append(c, opt...)...)
}

/*
ListForksReq is request data for Client.ListForks

https://developer.github.com/v3/gists/#list-gist-forks
*/
type ListForksReq struct {
	_url string

	// gist_id parameter
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListForksReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForksReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list-forks",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/forks", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForksReq) Rel(link string, resp *ListForksResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForksResponse is a response for ListForks

https://developer.github.com/v3/gists/#list-gist-forks
*/
type ListForksResponse struct {
	common.Response
	request *ListForksReq
	Data    []components.GistFull
}

/*
ListPublic performs requests for "gists/list-public"

List public gists.

  GET /gists/public

https://developer.github.com/v3/gists/#list-public-gists
*/
func ListPublic(ctx context.Context, req *ListPublicReq, opt ...options.Option) (*ListPublicResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicReq)
	}
	resp := &ListPublicResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.BaseGist{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListPublic performs requests for "gists/list-public"

List public gists.

  GET /gists/public

https://developer.github.com/v3/gists/#list-public-gists
*/
func (c Client) ListPublic(ctx context.Context, req *ListPublicReq, opt ...options.Option) (*ListPublicResponse, error) {
	return ListPublic(ctx, req, append(c, opt...)...)
}

/*
ListPublicReq is request data for Client.ListPublic

https://developer.github.com/v3/gists/#list-public-gists
*/
type ListPublicReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list-public",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/public"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicReq) Rel(link string, resp *ListPublicResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicResponse is a response for ListPublic

https://developer.github.com/v3/gists/#list-public-gists
*/
type ListPublicResponse struct {
	common.Response
	request *ListPublicReq
	Data    []components.BaseGist
}

/*
ListStarred performs requests for "gists/list-starred"

List starred gists.

  GET /gists/starred

https://developer.github.com/v3/gists/#list-starred-gists
*/
func ListStarred(ctx context.Context, req *ListStarredReq, opt ...options.Option) (*ListStarredResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListStarredReq)
	}
	resp := &ListStarredResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.BaseGist{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ListStarred performs requests for "gists/list-starred"

List starred gists.

  GET /gists/starred

https://developer.github.com/v3/gists/#list-starred-gists
*/
func (c Client) ListStarred(ctx context.Context, req *ListStarredReq, opt ...options.Option) (*ListStarredResponse, error) {
	return ListStarred(ctx, req, append(c, opt...)...)
}

/*
ListStarredReq is request data for Client.ListStarred

https://developer.github.com/v3/gists/#list-starred-gists
*/
type ListStarredReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListStarredReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListStarredReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": internal.String("application/json")},
		Method:           "GET",
		OperationID:      "gists/list-starred",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/starred"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListStarredReq) Rel(link string, resp *ListStarredResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListStarredResponse is a response for ListStarred

https://developer.github.com/v3/gists/#list-starred-gists
*/
type ListStarredResponse struct {
	common.Response
	request *ListStarredReq
	Data    []components.BaseGist
}

/*
Star performs requests for "gists/star"

Star a gist.

  PUT /gists/{gist_id}/star

https://developer.github.com/v3/gists/#star-a-gist
*/
func Star(ctx context.Context, req *StarReq, opt ...options.Option) (*StarResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(StarReq)
	}
	resp := &StarResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Star performs requests for "gists/star"

Star a gist.

  PUT /gists/{gist_id}/star

https://developer.github.com/v3/gists/#star-a-gist
*/
func (c Client) Star(ctx context.Context, req *StarReq, opt ...options.Option) (*StarResponse, error) {
	return Star(ctx, req, append(c, opt...)...)
}

/*
StarReq is request data for Client.Star

https://developer.github.com/v3/gists/#star-a-gist
*/
type StarReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *StarReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *StarReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "gists/star",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/star", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StarReq) Rel(link string, resp *StarResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StarResponse is a response for Star

https://developer.github.com/v3/gists/#star-a-gist
*/
type StarResponse struct {
	common.Response
	request *StarReq
}

/*
Unstar performs requests for "gists/unstar"

Unstar a gist.

  DELETE /gists/{gist_id}/star

https://developer.github.com/v3/gists/#unstar-a-gist
*/
func Unstar(ctx context.Context, req *UnstarReq, opt ...options.Option) (*UnstarResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnstarReq)
	}
	resp := &UnstarResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Unstar performs requests for "gists/unstar"

Unstar a gist.

  DELETE /gists/{gist_id}/star

https://developer.github.com/v3/gists/#unstar-a-gist
*/
func (c Client) Unstar(ctx context.Context, req *UnstarReq, opt ...options.Option) (*UnstarResponse, error) {
	return Unstar(ctx, req, append(c, opt...)...)
}

/*
UnstarReq is request data for Client.Unstar

https://developer.github.com/v3/gists/#unstar-a-gist
*/
type UnstarReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *UnstarReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnstarReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "gists/unstar",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/star", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnstarReq) Rel(link string, resp *UnstarResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnstarResponse is a response for Unstar

https://developer.github.com/v3/gists/#unstar-a-gist
*/
type UnstarResponse struct {
	common.Response
	request *UnstarReq
}

/*
Update performs requests for "gists/update"

Update a gist.

  PATCH /gists/{gist_id}

https://developer.github.com/v3/gists/#update-a-gist
*/
func Update(ctx context.Context, req *UpdateReq, opt ...options.Option) (*UpdateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateReq)
	}
	resp := &UpdateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
Update performs requests for "gists/update"

Update a gist.

  PATCH /gists/{gist_id}

https://developer.github.com/v3/gists/#update-a-gist
*/
func (c Client) Update(ctx context.Context, req *UpdateReq, opt ...options.Option) (*UpdateResponse, error) {
	return Update(ctx, req, append(c, opt...)...)
}

/*
UpdateReq is request data for Client.Update

https://developer.github.com/v3/gists/#update-a-gist
*/
type UpdateReq struct {
	_url string

	// gist_id parameter
	GistId      string
	RequestBody UpdateReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "gists/update",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v", r.GistId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReq) Rel(link string, resp *UpdateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// UpdateReqBodyFiles is a value for UpdateReqBody's Files field
type UpdateReqBodyFiles struct {

	// The new content of the file
	Content *string `json:"content,omitempty"`

	// The new filename for the file
	Filename *string `json:"filename,omitempty"`
}

/*
UpdateReqBody is a request body for gists/update

https://developer.github.com/v3/gists/#update-a-gist
*/
type UpdateReqBody struct {

	// Description of the gist
	Description *string `json:"description,omitempty"`

	// Names of files to be updated
	Files map[string]UpdateReqBodyFiles `json:"files,omitempty"`
}

/*
UpdateResponse is a response for Update

https://developer.github.com/v3/gists/#update-a-gist
*/
type UpdateResponse struct {
	common.Response
	request *UpdateReq
	Data    components.GistFull
}

/*
UpdateComment performs requests for "gists/update-comment"

Update a gist comment.

  PATCH /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
func UpdateComment(ctx context.Context, req *UpdateCommentReq, opt ...options.Option) (*UpdateCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateCommentReq)
	}
	resp := &UpdateCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GistComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UpdateComment performs requests for "gists/update-comment"

Update a gist comment.

  PATCH /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
func (c Client) UpdateComment(ctx context.Context, req *UpdateCommentReq, opt ...options.Option) (*UpdateCommentResponse, error) {
	return UpdateComment(ctx, req, append(c, opt...)...)
}

/*
UpdateCommentReq is request data for Client.UpdateComment

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
type UpdateCommentReq struct {
	_url string

	// gist_id parameter
	GistId string

	// comment_id parameter
	CommentId   int64
	RequestBody UpdateCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "gists/update-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateCommentReq) Rel(link string, resp *UpdateCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateCommentReqBody is a request body for gists/update-comment

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
type UpdateCommentReqBody struct {

	// The comment text.
	Body *string `json:"body"`
}

/*
UpdateCommentResponse is a response for UpdateComment

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
type UpdateCommentResponse struct {
	common.Response
	request *UpdateCommentReq
	Data    components.GistComment
}
