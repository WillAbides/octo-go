// Code generated by octo-go; DO NOT EDIT.

package gists

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
CheckIsStarred performs requests for "gists/check-is-starred"

Check if a gist is starred.

  GET /gists/{gist_id}/star

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
func CheckIsStarred(ctx context.Context, req *CheckIsStarredReq, opt ...requests.Option) (*CheckIsStarredResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckIsStarredReq)
	}
	resp := &CheckIsStarredResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckIsStarredResponse(r, opts.PreserveResponseBody())
}

// NewCheckIsStarredResponse builds a new *CheckIsStarredResponse from an *http.Response
func NewCheckIsStarredResponse(resp *http.Response, preserveBody bool) (*CheckIsStarredResponse, error) {
	var result CheckIsStarredResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CheckIsStarred performs requests for "gists/check-is-starred"

Check if a gist is starred.

  GET /gists/{gist_id}/star

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
func (c Client) CheckIsStarred(ctx context.Context, req *CheckIsStarredReq, opt ...requests.Option) (*CheckIsStarredResponse, error) {
	return CheckIsStarred(ctx, req, append(c, opt...)...)
}

/*
CheckIsStarredReq is request data for Client.CheckIsStarred

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
type CheckIsStarredReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *CheckIsStarredReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckIsStarredReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "gists/check-is-starred",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/%v/star", r.GistId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckIsStarredReq) Rel(link string, resp *CheckIsStarredResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckIsStarredResponse is a response for CheckIsStarred

https://developer.github.com/v3/gists/#check-if-a-gist-is-starred
*/
type CheckIsStarredResponse struct {
	httpResponse *http.Response
}

func (r *CheckIsStarredResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Create performs requests for "gists/create"

Create a gist.

  POST /gists

https://developer.github.com/v3/gists/#create-a-gist
*/
func Create(ctx context.Context, req *CreateReq, opt ...requests.Option) (*CreateResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateReq)
	}
	resp := &CreateResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateResponse(r, opts.PreserveResponseBody())
}

// NewCreateResponse builds a new *CreateResponse from an *http.Response
func NewCreateResponse(resp *http.Response, preserveBody bool) (*CreateResponse, error) {
	var result CreateResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
Create performs requests for "gists/create"

Create a gist.

  POST /gists

https://developer.github.com/v3/gists/#create-a-gist
*/
func (c Client) Create(ctx context.Context, req *CreateReq, opt ...requests.Option) (*CreateResponse, error) {
	return Create(ctx, req, append(c, opt...)...)
}

/*
CreateReq is request data for Client.Create

https://developer.github.com/v3/gists/#create-a-gist
*/
type CreateReq struct {
	_url        string
	RequestBody CreateReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "gists/create",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists"),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateReq) Rel(link string, resp *CreateResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// CreateReqBodyFiles is a value for CreateReqBody's Files field
type CreateReqBodyFiles struct {

	// Content of the file
	Content *string `json:"content"`
}

/*
CreateReqBody is a request body for gists/create

https://developer.github.com/v3/gists/#create-a-gist
*/
type CreateReqBody struct {

	// Description of the gist
	Description *string `json:"description,omitempty"`

	// Names and content for the files that make up the gist
	Files map[string]CreateReqBodyFiles `json:"files"`

	// Flag indicating whether the gist is public
	Public *bool `json:"public,omitempty"`
}

/*
CreateResponse is a response for Create

https://developer.github.com/v3/gists/#create-a-gist
*/
type CreateResponse struct {
	httpResponse *http.Response
	Data         components.GistFull
}

func (r *CreateResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateComment performs requests for "gists/create-comment"

Create a gist comment.

  POST /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
func CreateComment(ctx context.Context, req *CreateCommentReq, opt ...requests.Option) (*CreateCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateCommentReq)
	}
	resp := &CreateCommentResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateCommentResponse(r, opts.PreserveResponseBody())
}

// NewCreateCommentResponse builds a new *CreateCommentResponse from an *http.Response
func NewCreateCommentResponse(resp *http.Response, preserveBody bool) (*CreateCommentResponse, error) {
	var result CreateCommentResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateComment performs requests for "gists/create-comment"

Create a gist comment.

  POST /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
func (c Client) CreateComment(ctx context.Context, req *CreateCommentReq, opt ...requests.Option) (*CreateCommentResponse, error) {
	return CreateComment(ctx, req, append(c, opt...)...)
}

/*
CreateCommentReq is request data for Client.CreateComment

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
type CreateCommentReq struct {
	_url string

	// gist_id parameter
	GistId      string
	RequestBody CreateCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "gists/create-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/comments", r.GistId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateCommentReq) Rel(link string, resp *CreateCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateCommentReqBody is a request body for gists/create-comment

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
type CreateCommentReqBody struct {

	// The comment text.
	Body *string `json:"body"`
}

/*
CreateCommentResponse is a response for CreateComment

https://developer.github.com/v3/gists/comments/#create-a-gist-comment
*/
type CreateCommentResponse struct {
	httpResponse *http.Response
	Data         components.GistComment
}

func (r *CreateCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Delete performs requests for "gists/delete"

Delete a gist.

  DELETE /gists/{gist_id}

https://developer.github.com/v3/gists/#delete-a-gist
*/
func Delete(ctx context.Context, req *DeleteReq, opt ...requests.Option) (*DeleteResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteReq)
	}
	resp := &DeleteResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteResponse(r, opts.PreserveResponseBody())
}

// NewDeleteResponse builds a new *DeleteResponse from an *http.Response
func NewDeleteResponse(resp *http.Response, preserveBody bool) (*DeleteResponse, error) {
	var result DeleteResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
Delete performs requests for "gists/delete"

Delete a gist.

  DELETE /gists/{gist_id}

https://developer.github.com/v3/gists/#delete-a-gist
*/
func (c Client) Delete(ctx context.Context, req *DeleteReq, opt ...requests.Option) (*DeleteResponse, error) {
	return Delete(ctx, req, append(c, opt...)...)
}

/*
DeleteReq is request data for Client.Delete

https://developer.github.com/v3/gists/#delete-a-gist
*/
type DeleteReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *DeleteReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "gists/delete",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/%v", r.GistId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteReq) Rel(link string, resp *DeleteResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteResponse is a response for Delete

https://developer.github.com/v3/gists/#delete-a-gist
*/
type DeleteResponse struct {
	httpResponse *http.Response
}

func (r *DeleteResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteComment performs requests for "gists/delete-comment"

Delete a gist comment.

  DELETE /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
func DeleteComment(ctx context.Context, req *DeleteCommentReq, opt ...requests.Option) (*DeleteCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteCommentReq)
	}
	resp := &DeleteCommentResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteCommentResponse(r, opts.PreserveResponseBody())
}

// NewDeleteCommentResponse builds a new *DeleteCommentResponse from an *http.Response
func NewDeleteCommentResponse(resp *http.Response, preserveBody bool) (*DeleteCommentResponse, error) {
	var result DeleteCommentResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteComment performs requests for "gists/delete-comment"

Delete a gist comment.

  DELETE /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
func (c Client) DeleteComment(ctx context.Context, req *DeleteCommentReq, opt ...requests.Option) (*DeleteCommentResponse, error) {
	return DeleteComment(ctx, req, append(c, opt...)...)
}

/*
DeleteCommentReq is request data for Client.DeleteComment

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
type DeleteCommentReq struct {
	_url string

	// gist_id parameter
	GistId string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "gists/delete-comment",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteCommentReq) Rel(link string, resp *DeleteCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteCommentResponse is a response for DeleteComment

https://developer.github.com/v3/gists/comments/#delete-a-gist-comment
*/
type DeleteCommentResponse struct {
	httpResponse *http.Response
}

func (r *DeleteCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Fork performs requests for "gists/fork"

Fork a gist.

  POST /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#fork-a-gist
*/
func Fork(ctx context.Context, req *ForkReq, opt ...requests.Option) (*ForkResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ForkReq)
	}
	resp := &ForkResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewForkResponse(r, opts.PreserveResponseBody())
}

// NewForkResponse builds a new *ForkResponse from an *http.Response
func NewForkResponse(resp *http.Response, preserveBody bool) (*ForkResponse, error) {
	var result ForkResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
Fork performs requests for "gists/fork"

Fork a gist.

  POST /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#fork-a-gist
*/
func (c Client) Fork(ctx context.Context, req *ForkReq, opt ...requests.Option) (*ForkResponse, error) {
	return Fork(ctx, req, append(c, opt...)...)
}

/*
ForkReq is request data for Client.Fork

https://developer.github.com/v3/gists/#fork-a-gist
*/
type ForkReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *ForkReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ForkReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "POST",
		OperationID:        "gists/fork",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/%v/forks", r.GistId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ForkReq) Rel(link string, resp *ForkResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ForkResponse is a response for Fork

https://developer.github.com/v3/gists/#fork-a-gist
*/
type ForkResponse struct {
	httpResponse *http.Response
	Data         components.BaseGist
}

func (r *ForkResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Get performs requests for "gists/get"

Get a gist.

  GET /gists/{gist_id}

https://developer.github.com/v3/gists/#get-a-gist
*/
func Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetReq)
	}
	resp := &GetResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetResponse(r, opts.PreserveResponseBody())
}

// NewGetResponse builds a new *GetResponse from an *http.Response
func NewGetResponse(resp *http.Response, preserveBody bool) (*GetResponse, error) {
	var result GetResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
Get performs requests for "gists/get"

Get a gist.

  GET /gists/{gist_id}

https://developer.github.com/v3/gists/#get-a-gist
*/
func (c Client) Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	return Get(ctx, req, append(c, opt...)...)
}

/*
GetReq is request data for Client.Get

https://developer.github.com/v3/gists/#get-a-gist
*/
type GetReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *GetReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "gists/get",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/%v", r.GistId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReq) Rel(link string, resp *GetResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetResponse is a response for Get

https://developer.github.com/v3/gists/#get-a-gist
*/
type GetResponse struct {
	httpResponse *http.Response
	Data         components.GistFull
}

func (r *GetResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetComment performs requests for "gists/get-comment"

Get a gist comment.

  GET /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
func GetComment(ctx context.Context, req *GetCommentReq, opt ...requests.Option) (*GetCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCommentReq)
	}
	resp := &GetCommentResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetCommentResponse(r, opts.PreserveResponseBody())
}

// NewGetCommentResponse builds a new *GetCommentResponse from an *http.Response
func NewGetCommentResponse(resp *http.Response, preserveBody bool) (*GetCommentResponse, error) {
	var result GetCommentResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetComment performs requests for "gists/get-comment"

Get a gist comment.

  GET /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
func (c Client) GetComment(ctx context.Context, req *GetCommentReq, opt ...requests.Option) (*GetCommentResponse, error) {
	return GetComment(ctx, req, append(c, opt...)...)
}

/*
GetCommentReq is request data for Client.GetComment

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
type GetCommentReq struct {
	_url string

	// gist_id parameter
	GistId string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request
func (r *GetCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "gists/get-comment",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCommentReq) Rel(link string, resp *GetCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCommentResponse is a response for GetComment

https://developer.github.com/v3/gists/comments/#get-a-gist-comment
*/
type GetCommentResponse struct {
	httpResponse *http.Response
	Data         components.GistComment
}

func (r *GetCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetRevision performs requests for "gists/get-revision"

Get a gist revision.

  GET /gists/{gist_id}/{sha}

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
func GetRevision(ctx context.Context, req *GetRevisionReq, opt ...requests.Option) (*GetRevisionResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetRevisionReq)
	}
	resp := &GetRevisionResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetRevisionResponse(r, opts.PreserveResponseBody())
}

// NewGetRevisionResponse builds a new *GetRevisionResponse from an *http.Response
func NewGetRevisionResponse(resp *http.Response, preserveBody bool) (*GetRevisionResponse, error) {
	var result GetRevisionResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetRevision performs requests for "gists/get-revision"

Get a gist revision.

  GET /gists/{gist_id}/{sha}

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
func (c Client) GetRevision(ctx context.Context, req *GetRevisionReq, opt ...requests.Option) (*GetRevisionResponse, error) {
	return GetRevision(ctx, req, append(c, opt...)...)
}

/*
GetRevisionReq is request data for Client.GetRevision

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
type GetRevisionReq struct {
	_url string

	// gist_id parameter
	GistId string

	// sha parameter
	Sha string
}

// HTTPRequest builds an *http.Request
func (r *GetRevisionReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetRevisionReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "gists/get-revision",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/%v/%v", r.GistId, r.Sha),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetRevisionReq) Rel(link string, resp *GetRevisionResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetRevisionResponse is a response for GetRevision

https://developer.github.com/v3/gists/#get-a-gist-revision
*/
type GetRevisionResponse struct {
	httpResponse *http.Response
	Data         components.GistFull
}

func (r *GetRevisionResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
List performs requests for "gists/list"

List gists for the authenticated user.

  GET /gists

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
func List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReq)
	}
	resp := &ListResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListResponse(r, opts.PreserveResponseBody())
}

// NewListResponse builds a new *ListResponse from an *http.Response
func NewListResponse(resp *http.Response, preserveBody bool) (*ListResponse, error) {
	var result ListResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
List performs requests for "gists/list"

List gists for the authenticated user.

  GET /gists

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
func (c Client) List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	return List(ctx, req, append(c, opt...)...)
}

/*
ListReq is request data for Client.List

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
type ListReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "gists/list",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReq) Rel(link string, resp *ListResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListResponse is a response for List

https://developer.github.com/v3/gists/#list-gists-for-the-authenticated-user
*/
type ListResponse struct {
	httpResponse *http.Response
	Data         []components.BaseGist
}

func (r *ListResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListComments performs requests for "gists/list-comments"

List gist comments.

  GET /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
func ListComments(ctx context.Context, req *ListCommentsReq, opt ...requests.Option) (*ListCommentsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListCommentsReq)
	}
	resp := &ListCommentsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListCommentsResponse(r, opts.PreserveResponseBody())
}

// NewListCommentsResponse builds a new *ListCommentsResponse from an *http.Response
func NewListCommentsResponse(resp *http.Response, preserveBody bool) (*ListCommentsResponse, error) {
	var result ListCommentsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListComments performs requests for "gists/list-comments"

List gist comments.

  GET /gists/{gist_id}/comments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
func (c Client) ListComments(ctx context.Context, req *ListCommentsReq, opt ...requests.Option) (*ListCommentsResponse, error) {
	return ListComments(ctx, req, append(c, opt...)...)
}

/*
ListCommentsReq is request data for Client.ListComments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
type ListCommentsReq struct {
	_url string

	// gist_id parameter
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListCommentsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListCommentsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "gists/list-comments",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/%v/comments", r.GistId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommentsReq) Rel(link string, resp *ListCommentsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommentsResponse is a response for ListComments

https://developer.github.com/v3/gists/comments/#list-gist-comments
*/
type ListCommentsResponse struct {
	httpResponse *http.Response
	Data         []components.GistComment
}

func (r *ListCommentsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListCommits performs requests for "gists/list-commits"

List gist commits.

  GET /gists/{gist_id}/commits

https://developer.github.com/v3/gists/#list-gist-commits
*/
func ListCommits(ctx context.Context, req *ListCommitsReq, opt ...requests.Option) (*ListCommitsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListCommitsReq)
	}
	resp := &ListCommitsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListCommitsResponse(r, opts.PreserveResponseBody())
}

// NewListCommitsResponse builds a new *ListCommitsResponse from an *http.Response
func NewListCommitsResponse(resp *http.Response, preserveBody bool) (*ListCommitsResponse, error) {
	var result ListCommitsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListCommits performs requests for "gists/list-commits"

List gist commits.

  GET /gists/{gist_id}/commits

https://developer.github.com/v3/gists/#list-gist-commits
*/
func (c Client) ListCommits(ctx context.Context, req *ListCommitsReq, opt ...requests.Option) (*ListCommitsResponse, error) {
	return ListCommits(ctx, req, append(c, opt...)...)
}

/*
ListCommitsReq is request data for Client.ListCommits

https://developer.github.com/v3/gists/#list-gist-commits
*/
type ListCommitsReq struct {
	_url string

	// gist_id parameter
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListCommitsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListCommitsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "gists/list-commits",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/%v/commits", r.GistId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommitsReq) Rel(link string, resp *ListCommitsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommitsResponse is a response for ListCommits

https://developer.github.com/v3/gists/#list-gist-commits
*/
type ListCommitsResponse struct {
	httpResponse *http.Response
	Data         []components.GistCommit
}

func (r *ListCommitsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListForUser performs requests for "gists/list-for-user"

List gists for a user.

  GET /users/{username}/gists

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
func ListForUser(ctx context.Context, req *ListForUserReq, opt ...requests.Option) (*ListForUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForUserReq)
	}
	resp := &ListForUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListForUserResponse(r, opts.PreserveResponseBody())
}

// NewListForUserResponse builds a new *ListForUserResponse from an *http.Response
func NewListForUserResponse(resp *http.Response, preserveBody bool) (*ListForUserResponse, error) {
	var result ListForUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListForUser performs requests for "gists/list-for-user"

List gists for a user.

  GET /users/{username}/gists

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
func (c Client) ListForUser(ctx context.Context, req *ListForUserReq, opt ...requests.Option) (*ListForUserResponse, error) {
	return ListForUser(ctx, req, append(c, opt...)...)
}

/*
ListForUserReq is request data for Client.ListForUser

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
type ListForUserReq struct {
	_url     string
	Username string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListForUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "gists/list-for-user",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/users/%v/gists", r.Username),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForUserReq) Rel(link string, resp *ListForUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForUserResponse is a response for ListForUser

https://developer.github.com/v3/gists/#list-gists-for-a-user
*/
type ListForUserResponse struct {
	httpResponse *http.Response
	Data         []components.BaseGist
}

func (r *ListForUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListForks performs requests for "gists/list-forks"

List gist forks.

  GET /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#list-gist-forks
*/
func ListForks(ctx context.Context, req *ListForksReq, opt ...requests.Option) (*ListForksResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForksReq)
	}
	resp := &ListForksResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListForksResponse(r, opts.PreserveResponseBody())
}

// NewListForksResponse builds a new *ListForksResponse from an *http.Response
func NewListForksResponse(resp *http.Response, preserveBody bool) (*ListForksResponse, error) {
	var result ListForksResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListForks performs requests for "gists/list-forks"

List gist forks.

  GET /gists/{gist_id}/forks

https://developer.github.com/v3/gists/#list-gist-forks
*/
func (c Client) ListForks(ctx context.Context, req *ListForksReq, opt ...requests.Option) (*ListForksResponse, error) {
	return ListForks(ctx, req, append(c, opt...)...)
}

/*
ListForksReq is request data for Client.ListForks

https://developer.github.com/v3/gists/#list-gist-forks
*/
type ListForksReq struct {
	_url string

	// gist_id parameter
	GistId string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListForksReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForksReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "gists/list-forks",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/%v/forks", r.GistId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForksReq) Rel(link string, resp *ListForksResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForksResponse is a response for ListForks

https://developer.github.com/v3/gists/#list-gist-forks
*/
type ListForksResponse struct {
	httpResponse *http.Response
	Data         []components.GistFull
}

func (r *ListForksResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListPublic performs requests for "gists/list-public"

List public gists.

  GET /gists/public

https://developer.github.com/v3/gists/#list-public-gists
*/
func ListPublic(ctx context.Context, req *ListPublicReq, opt ...requests.Option) (*ListPublicResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListPublicReq)
	}
	resp := &ListPublicResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListPublicResponse(r, opts.PreserveResponseBody())
}

// NewListPublicResponse builds a new *ListPublicResponse from an *http.Response
func NewListPublicResponse(resp *http.Response, preserveBody bool) (*ListPublicResponse, error) {
	var result ListPublicResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListPublic performs requests for "gists/list-public"

List public gists.

  GET /gists/public

https://developer.github.com/v3/gists/#list-public-gists
*/
func (c Client) ListPublic(ctx context.Context, req *ListPublicReq, opt ...requests.Option) (*ListPublicResponse, error) {
	return ListPublic(ctx, req, append(c, opt...)...)
}

/*
ListPublicReq is request data for Client.ListPublic

https://developer.github.com/v3/gists/#list-public-gists
*/
type ListPublicReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListPublicReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListPublicReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "gists/list-public",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/public"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListPublicReq) Rel(link string, resp *ListPublicResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListPublicResponse is a response for ListPublic

https://developer.github.com/v3/gists/#list-public-gists
*/
type ListPublicResponse struct {
	httpResponse *http.Response
	Data         []components.BaseGist
}

func (r *ListPublicResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListStarred performs requests for "gists/list-starred"

List starred gists.

  GET /gists/starred

https://developer.github.com/v3/gists/#list-starred-gists
*/
func ListStarred(ctx context.Context, req *ListStarredReq, opt ...requests.Option) (*ListStarredResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListStarredReq)
	}
	resp := &ListStarredResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListStarredResponse(r, opts.PreserveResponseBody())
}

// NewListStarredResponse builds a new *ListStarredResponse from an *http.Response
func NewListStarredResponse(resp *http.Response, preserveBody bool) (*ListStarredResponse, error) {
	var result ListStarredResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListStarred performs requests for "gists/list-starred"

List starred gists.

  GET /gists/starred

https://developer.github.com/v3/gists/#list-starred-gists
*/
func (c Client) ListStarred(ctx context.Context, req *ListStarredReq, opt ...requests.Option) (*ListStarredResponse, error) {
	return ListStarred(ctx, req, append(c, opt...)...)
}

/*
ListStarredReq is request data for Client.ListStarred

https://developer.github.com/v3/gists/#list-starred-gists
*/
type ListStarredReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListStarredReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListStarredReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "gists/list-starred",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/starred"),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListStarredReq) Rel(link string, resp *ListStarredResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListStarredResponse is a response for ListStarred

https://developer.github.com/v3/gists/#list-starred-gists
*/
type ListStarredResponse struct {
	httpResponse *http.Response
	Data         []components.BaseGist
}

func (r *ListStarredResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Star performs requests for "gists/star"

Star a gist.

  PUT /gists/{gist_id}/star

https://developer.github.com/v3/gists/#star-a-gist
*/
func Star(ctx context.Context, req *StarReq, opt ...requests.Option) (*StarResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(StarReq)
	}
	resp := &StarResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewStarResponse(r, opts.PreserveResponseBody())
}

// NewStarResponse builds a new *StarResponse from an *http.Response
func NewStarResponse(resp *http.Response, preserveBody bool) (*StarResponse, error) {
	var result StarResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
Star performs requests for "gists/star"

Star a gist.

  PUT /gists/{gist_id}/star

https://developer.github.com/v3/gists/#star-a-gist
*/
func (c Client) Star(ctx context.Context, req *StarReq, opt ...requests.Option) (*StarResponse, error) {
	return Star(ctx, req, append(c, opt...)...)
}

/*
StarReq is request data for Client.Star

https://developer.github.com/v3/gists/#star-a-gist
*/
type StarReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *StarReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *StarReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "PUT",
		OperationID:        "gists/star",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/%v/star", r.GistId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *StarReq) Rel(link string, resp *StarResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
StarResponse is a response for Star

https://developer.github.com/v3/gists/#star-a-gist
*/
type StarResponse struct {
	httpResponse *http.Response
}

func (r *StarResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Unstar performs requests for "gists/unstar"

Unstar a gist.

  DELETE /gists/{gist_id}/star

https://developer.github.com/v3/gists/#unstar-a-gist
*/
func Unstar(ctx context.Context, req *UnstarReq, opt ...requests.Option) (*UnstarResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnstarReq)
	}
	resp := &UnstarResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUnstarResponse(r, opts.PreserveResponseBody())
}

// NewUnstarResponse builds a new *UnstarResponse from an *http.Response
func NewUnstarResponse(resp *http.Response, preserveBody bool) (*UnstarResponse, error) {
	var result UnstarResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 304})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
Unstar performs requests for "gists/unstar"

Unstar a gist.

  DELETE /gists/{gist_id}/star

https://developer.github.com/v3/gists/#unstar-a-gist
*/
func (c Client) Unstar(ctx context.Context, req *UnstarReq, opt ...requests.Option) (*UnstarResponse, error) {
	return Unstar(ctx, req, append(c, opt...)...)
}

/*
UnstarReq is request data for Client.Unstar

https://developer.github.com/v3/gists/#unstar-a-gist
*/
type UnstarReq struct {
	_url string

	// gist_id parameter
	GistId string
}

// HTTPRequest builds an *http.Request
func (r *UnstarReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnstarReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "gists/unstar",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/gists/%v/star", r.GistId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnstarReq) Rel(link string, resp *UnstarResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnstarResponse is a response for Unstar

https://developer.github.com/v3/gists/#unstar-a-gist
*/
type UnstarResponse struct {
	httpResponse *http.Response
}

func (r *UnstarResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Update performs requests for "gists/update"

Update a gist.

  PATCH /gists/{gist_id}

https://developer.github.com/v3/gists/#update-a-gist
*/
func Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateReq)
	}
	resp := &UpdateResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateResponse(r, opts.PreserveResponseBody())
}

// NewUpdateResponse builds a new *UpdateResponse from an *http.Response
func NewUpdateResponse(resp *http.Response, preserveBody bool) (*UpdateResponse, error) {
	var result UpdateResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
Update performs requests for "gists/update"

Update a gist.

  PATCH /gists/{gist_id}

https://developer.github.com/v3/gists/#update-a-gist
*/
func (c Client) Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	return Update(ctx, req, append(c, opt...)...)
}

/*
UpdateReq is request data for Client.Update

https://developer.github.com/v3/gists/#update-a-gist
*/
type UpdateReq struct {
	_url string

	// gist_id parameter
	GistId      string
	RequestBody UpdateReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "gists/update",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v", r.GistId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReq) Rel(link string, resp *UpdateResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// UpdateReqBodyFiles is a value for UpdateReqBody's Files field
type UpdateReqBodyFiles struct {

	// The new content of the file
	Content *string `json:"content,omitempty"`

	// The new filename for the file
	Filename *string `json:"filename,omitempty"`
}

/*
UpdateReqBody is a request body for gists/update

https://developer.github.com/v3/gists/#update-a-gist
*/
type UpdateReqBody struct {

	// Description of the gist
	Description *string `json:"description,omitempty"`

	// Names of files to be updated
	Files map[string]UpdateReqBodyFiles `json:"files,omitempty"`
}

/*
UpdateResponse is a response for Update

https://developer.github.com/v3/gists/#update-a-gist
*/
type UpdateResponse struct {
	httpResponse *http.Response
	Data         components.GistFull
}

func (r *UpdateResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateComment performs requests for "gists/update-comment"

Update a gist comment.

  PATCH /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
func UpdateComment(ctx context.Context, req *UpdateCommentReq, opt ...requests.Option) (*UpdateCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateCommentReq)
	}
	resp := &UpdateCommentResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateCommentResponse(r, opts.PreserveResponseBody())
}

// NewUpdateCommentResponse builds a new *UpdateCommentResponse from an *http.Response
func NewUpdateCommentResponse(resp *http.Response, preserveBody bool) (*UpdateCommentResponse, error) {
	var result UpdateCommentResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateComment performs requests for "gists/update-comment"

Update a gist comment.

  PATCH /gists/{gist_id}/comments/{comment_id}

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
func (c Client) UpdateComment(ctx context.Context, req *UpdateCommentReq, opt ...requests.Option) (*UpdateCommentResponse, error) {
	return UpdateComment(ctx, req, append(c, opt...)...)
}

/*
UpdateCommentReq is request data for Client.UpdateComment

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
type UpdateCommentReq struct {
	_url string

	// gist_id parameter
	GistId string

	// comment_id parameter
	CommentId   int64
	RequestBody UpdateCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "gists/update-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/gists/%v/comments/%v", r.GistId, r.CommentId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateCommentReq) Rel(link string, resp *UpdateCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateCommentReqBody is a request body for gists/update-comment

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
type UpdateCommentReqBody struct {

	// The comment text.
	Body *string `json:"body"`
}

/*
UpdateCommentResponse is a response for UpdateComment

https://developer.github.com/v3/gists/comments/#update-a-gist-comment
*/
type UpdateCommentResponse struct {
	httpResponse *http.Response
	Data         components.GistComment
}

func (r *UpdateCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}
