// Code generated by octo-go; DO NOT EDIT.

package issues

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	requests "github.com/willabides/octo-go/requests"
	"net/http"
	"net/url"
	"strconv"
)

func strPtr(s string) *string { return &s }

// Client is a set of options to apply to requests
type Client []requests.Option

// NewClient returns a new Client
func NewClient(opt ...requests.Option) Client {
	return opt
}

/*
AddAssignees performs requests for "issues/add-assignees"

Add assignees to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
func AddAssignees(ctx context.Context, req *AddAssigneesReq, opt ...requests.Option) (*AddAssigneesResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddAssigneesReq)
	}
	resp := &AddAssigneesResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewAddAssigneesResponse(r, opts.PreserveResponseBody())
}

// NewAddAssigneesResponse builds a new *AddAssigneesResponse from an *http.Response
func NewAddAssigneesResponse(resp *http.Response, preserveBody bool) (*AddAssigneesResponse, error) {
	var result AddAssigneesResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
AddAssignees performs requests for "issues/add-assignees"

Add assignees to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
func (c Client) AddAssignees(ctx context.Context, req *AddAssigneesReq, opt ...requests.Option) (*AddAssigneesResponse, error) {
	return AddAssignees(ctx, req, append(c, opt...)...)
}

/*
AddAssigneesReq is request data for Client.AddAssignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type AddAssigneesReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody AddAssigneesReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddAssigneesReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddAssigneesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "issues/add-assignees",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/assignees", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddAssigneesReq) Rel(link string, resp *AddAssigneesResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddAssigneesReqBody is a request body for issues/add-assignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type AddAssigneesReqBody struct {

	/*
	Usernames of people to assign this issue to. _NOTE: Only users with push access
	can add assignees to an issue. Assignees are silently ignored otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`
}

/*
AddAssigneesResponse is a response for AddAssignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type AddAssigneesResponse struct {
	httpResponse *http.Response
	Data         components.IssueSimple
}

func (r *AddAssigneesResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
AddLabels performs requests for "issues/add-labels"

Add labels to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
func AddLabels(ctx context.Context, req *AddLabelsReq, opt ...requests.Option) (*AddLabelsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(AddLabelsReq)
	}
	resp := &AddLabelsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewAddLabelsResponse(r, opts.PreserveResponseBody())
}

// NewAddLabelsResponse builds a new *AddLabelsResponse from an *http.Response
func NewAddLabelsResponse(resp *http.Response, preserveBody bool) (*AddLabelsResponse, error) {
	var result AddLabelsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
AddLabels performs requests for "issues/add-labels"

Add labels to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
func (c Client) AddLabels(ctx context.Context, req *AddLabelsReq, opt ...requests.Option) (*AddLabelsResponse, error) {
	return AddLabels(ctx, req, append(c, opt...)...)
}

/*
AddLabelsReq is request data for Client.AddLabels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type AddLabelsReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody AddLabelsReqBody
}

// HTTPRequest builds an *http.Request
func (r *AddLabelsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *AddLabelsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "issues/add-labels",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *AddLabelsReq) Rel(link string, resp *AddLabelsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
AddLabelsReqBody is a request body for issues/add-labels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type AddLabelsReqBody struct {

	/*
	The name of the label to add to the issue. Must contain at least one label.
	**Note:** Alternatively, you can pass a single label as a `string` or an `array`
	of labels directly, but GitHub recommends passing an object with the `labels`
	key.
	*/
	Labels []string `json:"labels"`
}

/*
AddLabelsResponse is a response for AddLabels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type AddLabelsResponse struct {
	httpResponse *http.Response
	Data         []components.Label
}

func (r *AddLabelsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CheckUserCanBeAssigned performs requests for "issues/check-user-can-be-assigned"

Check if a user can be assigned.

  GET /repos/{owner}/{repo}/assignees/{assignee}

https://developer.github.com/v3/issues/assignees/#check-if-a-user-can-be-assigned
*/
func CheckUserCanBeAssigned(ctx context.Context, req *CheckUserCanBeAssignedReq, opt ...requests.Option) (*CheckUserCanBeAssignedResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CheckUserCanBeAssignedReq)
	}
	resp := &CheckUserCanBeAssignedResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCheckUserCanBeAssignedResponse(r, opts.PreserveResponseBody())
}

// NewCheckUserCanBeAssignedResponse builds a new *CheckUserCanBeAssignedResponse from an *http.Response
func NewCheckUserCanBeAssignedResponse(resp *http.Response, preserveBody bool) (*CheckUserCanBeAssignedResponse, error) {
	var result CheckUserCanBeAssignedResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
CheckUserCanBeAssigned performs requests for "issues/check-user-can-be-assigned"

Check if a user can be assigned.

  GET /repos/{owner}/{repo}/assignees/{assignee}

https://developer.github.com/v3/issues/assignees/#check-if-a-user-can-be-assigned
*/
func (c Client) CheckUserCanBeAssigned(ctx context.Context, req *CheckUserCanBeAssignedReq, opt ...requests.Option) (*CheckUserCanBeAssignedResponse, error) {
	return CheckUserCanBeAssigned(ctx, req, append(c, opt...)...)
}

/*
CheckUserCanBeAssignedReq is request data for Client.CheckUserCanBeAssigned

https://developer.github.com/v3/issues/assignees/#check-if-a-user-can-be-assigned
*/
type CheckUserCanBeAssignedReq struct {
	_url  string
	Owner string
	Repo  string

	// assignee parameter
	Assignee string
}

// HTTPRequest builds an *http.Request
func (r *CheckUserCanBeAssignedReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CheckUserCanBeAssignedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "GET",
		OperationID:        "issues/check-user-can-be-assigned",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/assignees/%v", r.Owner, r.Repo, r.Assignee),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CheckUserCanBeAssignedReq) Rel(link string, resp *CheckUserCanBeAssignedResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CheckUserCanBeAssignedResponse is a response for CheckUserCanBeAssigned

https://developer.github.com/v3/issues/assignees/#check-if-a-user-can-be-assigned
*/
type CheckUserCanBeAssignedResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *CheckUserCanBeAssignedResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Create performs requests for "issues/create"

Create an issue.

  POST /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#create-an-issue
*/
func Create(ctx context.Context, req *CreateReq, opt ...requests.Option) (*CreateResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateReq)
	}
	resp := &CreateResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateResponse(r, opts.PreserveResponseBody())
}

// NewCreateResponse builds a new *CreateResponse from an *http.Response
func NewCreateResponse(resp *http.Response, preserveBody bool) (*CreateResponse, error) {
	var result CreateResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
Create performs requests for "issues/create"

Create an issue.

  POST /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#create-an-issue
*/
func (c Client) Create(ctx context.Context, req *CreateReq, opt ...requests.Option) (*CreateResponse, error) {
	return Create(ctx, req, append(c, opt...)...)
}

/*
CreateReq is request data for Client.Create

https://developer.github.com/v3/issues/#create-an-issue
*/
type CreateReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "issues/create",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateReq) Rel(link string, resp *CreateResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateReqBody is a request body for issues/create

https://developer.github.com/v3/issues/#create-an-issue
*/
type CreateReqBody struct {

	/*
	Login for the user that this issue should be assigned to. _NOTE: Only users with
	push access can set the assignee for new issues. The assignee is silently
	dropped otherwise. **This field is deprecated.**_
	*/
	Assignee *string `json:"assignee,omitempty"`

	/*
	Logins for Users to assign to this issue. _NOTE: Only users with push access can
	set assignees for new issues. Assignees are silently dropped otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`

	// The contents of the issue.
	Body *string `json:"body,omitempty"`

	/*
	Labels to associate with this issue. _NOTE: Only users with push access can set
	labels for new issues. Labels are silently dropped otherwise._
	*/
	Labels []string `json:"labels,omitempty"`

	/*
	The `number` of the milestone to associate this issue with. _NOTE: Only users
	with push access can set the milestone for new issues. The milestone is silently
	dropped otherwise._
	*/
	Milestone *int64 `json:"milestone,omitempty"`

	// The title of the issue.
	Title *string `json:"title"`
}

/*
CreateResponse is a response for Create

https://developer.github.com/v3/issues/#create-an-issue
*/
type CreateResponse struct {
	httpResponse *http.Response
	Data         components.Issue
}

func (r *CreateResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateComment performs requests for "issues/create-comment"

Create an issue comment.

  POST /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
func CreateComment(ctx context.Context, req *CreateCommentReq, opt ...requests.Option) (*CreateCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateCommentReq)
	}
	resp := &CreateCommentResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateCommentResponse(r, opts.PreserveResponseBody())
}

// NewCreateCommentResponse builds a new *CreateCommentResponse from an *http.Response
func NewCreateCommentResponse(resp *http.Response, preserveBody bool) (*CreateCommentResponse, error) {
	var result CreateCommentResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateComment performs requests for "issues/create-comment"

Create an issue comment.

  POST /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
func (c Client) CreateComment(ctx context.Context, req *CreateCommentReq, opt ...requests.Option) (*CreateCommentResponse, error) {
	return CreateComment(ctx, req, append(c, opt...)...)
}

/*
CreateCommentReq is request data for Client.CreateComment

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
type CreateCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody CreateCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "issues/create-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/comments", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateCommentReq) Rel(link string, resp *CreateCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateCommentReqBody is a request body for issues/create-comment

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
type CreateCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`
}

/*
CreateCommentResponse is a response for CreateComment

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
type CreateCommentResponse struct {
	httpResponse *http.Response
	Data         components.IssueComment
}

func (r *CreateCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateLabel performs requests for "issues/create-label"

Create a label.

  POST /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#create-a-label
*/
func CreateLabel(ctx context.Context, req *CreateLabelReq, opt ...requests.Option) (*CreateLabelResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateLabelReq)
	}
	resp := &CreateLabelResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateLabelResponse(r, opts.PreserveResponseBody())
}

// NewCreateLabelResponse builds a new *CreateLabelResponse from an *http.Response
func NewCreateLabelResponse(resp *http.Response, preserveBody bool) (*CreateLabelResponse, error) {
	var result CreateLabelResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateLabel performs requests for "issues/create-label"

Create a label.

  POST /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#create-a-label
*/
func (c Client) CreateLabel(ctx context.Context, req *CreateLabelReq, opt ...requests.Option) (*CreateLabelResponse, error) {
	return CreateLabel(ctx, req, append(c, opt...)...)
}

/*
CreateLabelReq is request data for Client.CreateLabel

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type CreateLabelReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateLabelReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateLabelReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateLabelReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "issues/create-label",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/labels", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateLabelReq) Rel(link string, resp *CreateLabelResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateLabelReqBody is a request body for issues/create-label

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type CreateLabelReqBody struct {

	// The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.
	Color *string `json:"color,omitempty"`

	// A short description of the label.
	Description *string `json:"description,omitempty"`

	/*
	The name of the label. Emoji can be added to label names, using either native
	emoji or colon-style markup. For example, typing `:strawberry:` will render the
	emoji
	![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png
	":strawberry:"). For a full list of available emoji and codes, see
	[emoji-cheat-sheet.com](http://emoji-cheat-sheet.com/).
	*/
	Name *string `json:"name"`
}

/*
CreateLabelResponse is a response for CreateLabel

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type CreateLabelResponse struct {
	httpResponse *http.Response
	Data         components.Label
}

func (r *CreateLabelResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
CreateMilestone performs requests for "issues/create-milestone"

Create a milestone.

  POST /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
func CreateMilestone(ctx context.Context, req *CreateMilestoneReq, opt ...requests.Option) (*CreateMilestoneResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(CreateMilestoneReq)
	}
	resp := &CreateMilestoneResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewCreateMilestoneResponse(r, opts.PreserveResponseBody())
}

// NewCreateMilestoneResponse builds a new *CreateMilestoneResponse from an *http.Response
func NewCreateMilestoneResponse(resp *http.Response, preserveBody bool) (*CreateMilestoneResponse, error) {
	var result CreateMilestoneResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{201})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{201}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
CreateMilestone performs requests for "issues/create-milestone"

Create a milestone.

  POST /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
func (c Client) CreateMilestone(ctx context.Context, req *CreateMilestoneReq, opt ...requests.Option) (*CreateMilestoneResponse, error) {
	return CreateMilestone(ctx, req, append(c, opt...)...)
}

/*
CreateMilestoneReq is request data for Client.CreateMilestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type CreateMilestoneReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody CreateMilestoneReqBody
}

// HTTPRequest builds an *http.Request
func (r *CreateMilestoneReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *CreateMilestoneReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "POST",
		OperationID:      "issues/create-milestone",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/milestones", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *CreateMilestoneReq) Rel(link string, resp *CreateMilestoneResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
CreateMilestoneReqBody is a request body for issues/create-milestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type CreateMilestoneReqBody struct {

	// A description of the milestone.
	Description *string `json:"description,omitempty"`

	/*
	The milestone due date. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	DueOn *string `json:"due_on,omitempty"`

	// The state of the milestone. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the milestone.
	Title *string `json:"title"`
}

/*
CreateMilestoneResponse is a response for CreateMilestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type CreateMilestoneResponse struct {
	httpResponse *http.Response
	Data         components.Milestone
}

func (r *CreateMilestoneResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteComment performs requests for "issues/delete-comment"

Delete an issue comment.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#delete-an-issue-comment
*/
func DeleteComment(ctx context.Context, req *DeleteCommentReq, opt ...requests.Option) (*DeleteCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteCommentReq)
	}
	resp := &DeleteCommentResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteCommentResponse(r, opts.PreserveResponseBody())
}

// NewDeleteCommentResponse builds a new *DeleteCommentResponse from an *http.Response
func NewDeleteCommentResponse(resp *http.Response, preserveBody bool) (*DeleteCommentResponse, error) {
	var result DeleteCommentResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteComment performs requests for "issues/delete-comment"

Delete an issue comment.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#delete-an-issue-comment
*/
func (c Client) DeleteComment(ctx context.Context, req *DeleteCommentReq, opt ...requests.Option) (*DeleteCommentResponse, error) {
	return DeleteComment(ctx, req, append(c, opt...)...)
}

/*
DeleteCommentReq is request data for Client.DeleteComment

https://developer.github.com/v3/issues/comments/#delete-an-issue-comment
*/
type DeleteCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "issues/delete-comment",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteCommentReq) Rel(link string, resp *DeleteCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteCommentResponse is a response for DeleteComment

https://developer.github.com/v3/issues/comments/#delete-an-issue-comment
*/
type DeleteCommentResponse struct {
	httpResponse *http.Response
}

func (r *DeleteCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteLabel performs requests for "issues/delete-label"

Delete a label.

  DELETE /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
func DeleteLabel(ctx context.Context, req *DeleteLabelReq, opt ...requests.Option) (*DeleteLabelResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteLabelReq)
	}
	resp := &DeleteLabelResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteLabelResponse(r, opts.PreserveResponseBody())
}

// NewDeleteLabelResponse builds a new *DeleteLabelResponse from an *http.Response
func NewDeleteLabelResponse(resp *http.Response, preserveBody bool) (*DeleteLabelResponse, error) {
	var result DeleteLabelResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteLabel performs requests for "issues/delete-label"

Delete a label.

  DELETE /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
func (c Client) DeleteLabel(ctx context.Context, req *DeleteLabelReq, opt ...requests.Option) (*DeleteLabelResponse, error) {
	return DeleteLabel(ctx, req, append(c, opt...)...)
}

/*
DeleteLabelReq is request data for Client.DeleteLabel

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
type DeleteLabelReq struct {
	_url  string
	Owner string
	Repo  string

	// name parameter
	Name string
}

// HTTPRequest builds an *http.Request
func (r *DeleteLabelReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteLabelReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "issues/delete-label",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteLabelReq) Rel(link string, resp *DeleteLabelResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteLabelResponse is a response for DeleteLabel

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
type DeleteLabelResponse struct {
	httpResponse *http.Response
}

func (r *DeleteLabelResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
DeleteMilestone performs requests for "issues/delete-milestone"

Delete a milestone.

  DELETE /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
func DeleteMilestone(ctx context.Context, req *DeleteMilestoneReq, opt ...requests.Option) (*DeleteMilestoneResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(DeleteMilestoneReq)
	}
	resp := &DeleteMilestoneResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewDeleteMilestoneResponse(r, opts.PreserveResponseBody())
}

// NewDeleteMilestoneResponse builds a new *DeleteMilestoneResponse from an *http.Response
func NewDeleteMilestoneResponse(resp *http.Response, preserveBody bool) (*DeleteMilestoneResponse, error) {
	var result DeleteMilestoneResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204, 404})
	if err != nil {
		return &result, err
	}
	err = internal.SetBoolResult(resp, &result.Data)
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
DeleteMilestone performs requests for "issues/delete-milestone"

Delete a milestone.

  DELETE /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
func (c Client) DeleteMilestone(ctx context.Context, req *DeleteMilestoneReq, opt ...requests.Option) (*DeleteMilestoneResponse, error) {
	return DeleteMilestone(ctx, req, append(c, opt...)...)
}

/*
DeleteMilestoneReq is request data for Client.DeleteMilestone

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
type DeleteMilestoneReq struct {
	_url  string
	Owner string
	Repo  string

	// milestone_number parameter
	MilestoneNumber int64
}

// HTTPRequest builds an *http.Request
func (r *DeleteMilestoneReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *DeleteMilestoneReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrBoolean},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "issues/delete-milestone",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *DeleteMilestoneReq) Rel(link string, resp *DeleteMilestoneResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
DeleteMilestoneResponse is a response for DeleteMilestone

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
type DeleteMilestoneResponse struct {
	httpResponse *http.Response
	Data         bool
}

func (r *DeleteMilestoneResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Get performs requests for "issues/get"

Get an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#get-an-issue
*/
func Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetReq)
	}
	resp := &GetResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetResponse(r, opts.PreserveResponseBody())
}

// NewGetResponse builds a new *GetResponse from an *http.Response
func NewGetResponse(resp *http.Response, preserveBody bool) (*GetResponse, error) {
	var result GetResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 301, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
Get performs requests for "issues/get"

Get an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#get-an-issue
*/
func (c Client) Get(ctx context.Context, req *GetReq, opt ...requests.Option) (*GetResponse, error) {
	return Get(ctx, req, append(c, opt...)...)
}

/*
GetReq is request data for Client.Get

https://developer.github.com/v3/issues/#get-an-issue
*/
type GetReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/get",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/issues/%v", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetReq) Rel(link string, resp *GetResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetResponse is a response for Get

https://developer.github.com/v3/issues/#get-an-issue
*/
type GetResponse struct {
	httpResponse *http.Response
	Data         components.Issue
}

func (r *GetResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetComment performs requests for "issues/get-comment"

Get an issue comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#get-an-issue-comment
*/
func GetComment(ctx context.Context, req *GetCommentReq, opt ...requests.Option) (*GetCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetCommentReq)
	}
	resp := &GetCommentResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetCommentResponse(r, opts.PreserveResponseBody())
}

// NewGetCommentResponse builds a new *GetCommentResponse from an *http.Response
func NewGetCommentResponse(resp *http.Response, preserveBody bool) (*GetCommentResponse, error) {
	var result GetCommentResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetComment performs requests for "issues/get-comment"

Get an issue comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#get-an-issue-comment
*/
func (c Client) GetComment(ctx context.Context, req *GetCommentReq, opt ...requests.Option) (*GetCommentResponse, error) {
	return GetComment(ctx, req, append(c, opt...)...)
}

/*
GetCommentReq is request data for Client.GetComment

https://developer.github.com/v3/issues/comments/#get-an-issue-comment
*/
type GetCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man", "squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/get-comment",
		Previews: map[string]bool{
			"machine-man":   r.MachineManPreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetCommentReq) Rel(link string, resp *GetCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetCommentResponse is a response for GetComment

https://developer.github.com/v3/issues/comments/#get-an-issue-comment
*/
type GetCommentResponse struct {
	httpResponse *http.Response
	Data         components.IssueComment
}

func (r *GetCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetEvent performs requests for "issues/get-event"

Get an issue event.

  GET /repos/{owner}/{repo}/issues/events/{event_id}

https://developer.github.com/v3/issues/events/#get-an-issue-event
*/
func GetEvent(ctx context.Context, req *GetEventReq, opt ...requests.Option) (*GetEventResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetEventReq)
	}
	resp := &GetEventResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetEventResponse(r, opts.PreserveResponseBody())
}

// NewGetEventResponse builds a new *GetEventResponse from an *http.Response
func NewGetEventResponse(resp *http.Response, preserveBody bool) (*GetEventResponse, error) {
	var result GetEventResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetEvent performs requests for "issues/get-event"

Get an issue event.

  GET /repos/{owner}/{repo}/issues/events/{event_id}

https://developer.github.com/v3/issues/events/#get-an-issue-event
*/
func (c Client) GetEvent(ctx context.Context, req *GetEventReq, opt ...requests.Option) (*GetEventResponse, error) {
	return GetEvent(ctx, req, append(c, opt...)...)
}

/*
GetEventReq is request data for Client.GetEvent

https://developer.github.com/v3/issues/events/#get-an-issue-event
*/
type GetEventReq struct {
	_url  string
	Owner string
	Repo  string

	// event_id parameter
	EventId int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request
func (r *GetEventReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetEventReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"starfox", "machine-man", "sailor-v"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/get-event",
		Previews: map[string]bool{
			"machine-man": r.MachineManPreview,
			"sailor-v":    r.SailorVPreview,
			"starfox":     r.StarfoxPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/events/%v", r.Owner, r.Repo, r.EventId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetEventReq) Rel(link string, resp *GetEventResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetEventResponse is a response for GetEvent

https://developer.github.com/v3/issues/events/#get-an-issue-event
*/
type GetEventResponse struct {
	httpResponse *http.Response
	Data         components.IssueEvent
}

func (r *GetEventResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetLabel performs requests for "issues/get-label"

Get a label.

  GET /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#get-a-label
*/
func GetLabel(ctx context.Context, req *GetLabelReq, opt ...requests.Option) (*GetLabelResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetLabelReq)
	}
	resp := &GetLabelResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetLabelResponse(r, opts.PreserveResponseBody())
}

// NewGetLabelResponse builds a new *GetLabelResponse from an *http.Response
func NewGetLabelResponse(resp *http.Response, preserveBody bool) (*GetLabelResponse, error) {
	var result GetLabelResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetLabel performs requests for "issues/get-label"

Get a label.

  GET /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#get-a-label
*/
func (c Client) GetLabel(ctx context.Context, req *GetLabelReq, opt ...requests.Option) (*GetLabelResponse, error) {
	return GetLabel(ctx, req, append(c, opt...)...)
}

/*
GetLabelReq is request data for Client.GetLabel

https://developer.github.com/v3/issues/labels/#get-a-label
*/
type GetLabelReq struct {
	_url  string
	Owner string
	Repo  string

	// name parameter
	Name string
}

// HTTPRequest builds an *http.Request
func (r *GetLabelReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetLabelReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/get-label",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetLabelReq) Rel(link string, resp *GetLabelResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetLabelResponse is a response for GetLabel

https://developer.github.com/v3/issues/labels/#get-a-label
*/
type GetLabelResponse struct {
	httpResponse *http.Response
	Data         components.Label
}

func (r *GetLabelResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
GetMilestone performs requests for "issues/get-milestone"

Get a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#get-a-milestone
*/
func GetMilestone(ctx context.Context, req *GetMilestoneReq, opt ...requests.Option) (*GetMilestoneResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GetMilestoneReq)
	}
	resp := &GetMilestoneResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewGetMilestoneResponse(r, opts.PreserveResponseBody())
}

// NewGetMilestoneResponse builds a new *GetMilestoneResponse from an *http.Response
func NewGetMilestoneResponse(resp *http.Response, preserveBody bool) (*GetMilestoneResponse, error) {
	var result GetMilestoneResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
GetMilestone performs requests for "issues/get-milestone"

Get a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#get-a-milestone
*/
func (c Client) GetMilestone(ctx context.Context, req *GetMilestoneReq, opt ...requests.Option) (*GetMilestoneResponse, error) {
	return GetMilestone(ctx, req, append(c, opt...)...)
}

/*
GetMilestoneReq is request data for Client.GetMilestone

https://developer.github.com/v3/issues/milestones/#get-a-milestone
*/
type GetMilestoneReq struct {
	_url  string
	Owner string
	Repo  string

	// milestone_number parameter
	MilestoneNumber int64
}

// HTTPRequest builds an *http.Request
func (r *GetMilestoneReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GetMilestoneReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/get-milestone",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GetMilestoneReq) Rel(link string, resp *GetMilestoneResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GetMilestoneResponse is a response for GetMilestone

https://developer.github.com/v3/issues/milestones/#get-a-milestone
*/
type GetMilestoneResponse struct {
	httpResponse *http.Response
	Data         components.Milestone
}

func (r *GetMilestoneResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
List performs requests for "issues/list"

List issues assigned to the authenticated user.

  GET /issues

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
func List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListReq)
	}
	resp := &ListResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListResponse(r, opts.PreserveResponseBody())
}

// NewListResponse builds a new *ListResponse from an *http.Response
func NewListResponse(resp *http.Response, preserveBody bool) (*ListResponse, error) {
	var result ListResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
List performs requests for "issues/list"

List issues assigned to the authenticated user.

  GET /issues

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
func (c Client) List(ctx context.Context, req *ListReq, opt ...requests.Option) (*ListResponse, error) {
	return List(ctx, req, append(c, opt...)...)
}

/*
ListReq is request data for Client.List

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
type ListReq struct {
	_url string

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since  *string
	Collab *bool
	Orgs   *bool
	Owned  *bool
	Pulls  *bool

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Collab != nil {
		query.Set("collab", strconv.FormatBool(*r.Collab))
	}
	if r.Orgs != nil {
		query.Set("orgs", strconv.FormatBool(*r.Orgs))
	}
	if r.Owned != nil {
		query.Set("owned", strconv.FormatBool(*r.Owned))
	}
	if r.Pulls != nil {
		query.Set("pulls", strconv.FormatBool(*r.Pulls))
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man", "squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list",
		Previews: map[string]bool{
			"machine-man":   r.MachineManPreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/issues"),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListReq) Rel(link string, resp *ListResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListResponse is a response for List

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
type ListResponse struct {
	httpResponse *http.Response
	Data         []components.Issue
}

func (r *ListResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListAssignees performs requests for "issues/list-assignees"

List assignees.

  GET /repos/{owner}/{repo}/assignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
func ListAssignees(ctx context.Context, req *ListAssigneesReq, opt ...requests.Option) (*ListAssigneesResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListAssigneesReq)
	}
	resp := &ListAssigneesResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListAssigneesResponse(r, opts.PreserveResponseBody())
}

// NewListAssigneesResponse builds a new *ListAssigneesResponse from an *http.Response
func NewListAssigneesResponse(resp *http.Response, preserveBody bool) (*ListAssigneesResponse, error) {
	var result ListAssigneesResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListAssignees performs requests for "issues/list-assignees"

List assignees.

  GET /repos/{owner}/{repo}/assignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
func (c Client) ListAssignees(ctx context.Context, req *ListAssigneesReq, opt ...requests.Option) (*ListAssigneesResponse, error) {
	return ListAssignees(ctx, req, append(c, opt...)...)
}

/*
ListAssigneesReq is request data for Client.ListAssignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
type ListAssigneesReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListAssigneesReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListAssigneesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list-assignees",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/assignees", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListAssigneesReq) Rel(link string, resp *ListAssigneesResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListAssigneesResponse is a response for ListAssignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
type ListAssigneesResponse struct {
	httpResponse *http.Response
	Data         []components.SimpleUser
}

func (r *ListAssigneesResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListComments performs requests for "issues/list-comments"

List issue comments.

  GET /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#list-issue-comments
*/
func ListComments(ctx context.Context, req *ListCommentsReq, opt ...requests.Option) (*ListCommentsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListCommentsReq)
	}
	resp := &ListCommentsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListCommentsResponse(r, opts.PreserveResponseBody())
}

// NewListCommentsResponse builds a new *ListCommentsResponse from an *http.Response
func NewListCommentsResponse(resp *http.Response, preserveBody bool) (*ListCommentsResponse, error) {
	var result ListCommentsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListComments performs requests for "issues/list-comments"

List issue comments.

  GET /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#list-issue-comments
*/
func (c Client) ListComments(ctx context.Context, req *ListCommentsReq, opt ...requests.Option) (*ListCommentsResponse, error) {
	return ListComments(ctx, req, append(c, opt...)...)
}

/*
ListCommentsReq is request data for Client.ListComments

https://developer.github.com/v3/issues/comments/#list-issue-comments
*/
type ListCommentsReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListCommentsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListCommentsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list-comments",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/issues/%v/comments", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommentsReq) Rel(link string, resp *ListCommentsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommentsResponse is a response for ListComments

https://developer.github.com/v3/issues/comments/#list-issue-comments
*/
type ListCommentsResponse struct {
	httpResponse *http.Response
	Data         []components.IssueComment
}

func (r *ListCommentsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListCommentsForRepo performs requests for "issues/list-comments-for-repo"

List issue comments for a repository.

  GET /repos/{owner}/{repo}/issues/comments

https://developer.github.com/v3/issues/comments/#list-issue-comments-for-a-repository
*/
func ListCommentsForRepo(ctx context.Context, req *ListCommentsForRepoReq, opt ...requests.Option) (*ListCommentsForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListCommentsForRepoReq)
	}
	resp := &ListCommentsForRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListCommentsForRepoResponse(r, opts.PreserveResponseBody())
}

// NewListCommentsForRepoResponse builds a new *ListCommentsForRepoResponse from an *http.Response
func NewListCommentsForRepoResponse(resp *http.Response, preserveBody bool) (*ListCommentsForRepoResponse, error) {
	var result ListCommentsForRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListCommentsForRepo performs requests for "issues/list-comments-for-repo"

List issue comments for a repository.

  GET /repos/{owner}/{repo}/issues/comments

https://developer.github.com/v3/issues/comments/#list-issue-comments-for-a-repository
*/
func (c Client) ListCommentsForRepo(ctx context.Context, req *ListCommentsForRepoReq, opt ...requests.Option) (*ListCommentsForRepoResponse, error) {
	return ListCommentsForRepo(ctx, req, append(c, opt...)...)
}

/*
ListCommentsForRepoReq is request data for Client.ListCommentsForRepo

https://developer.github.com/v3/issues/comments/#list-issue-comments-for-a-repository
*/
type ListCommentsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// Either `asc` or `desc`. Ignored without the `sort` parameter.
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListCommentsForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListCommentsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list-comments-for-repo",
		Previews:           map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/issues/comments", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListCommentsForRepoReq) Rel(link string, resp *ListCommentsForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListCommentsForRepoResponse is a response for ListCommentsForRepo

https://developer.github.com/v3/issues/comments/#list-issue-comments-for-a-repository
*/
type ListCommentsForRepoResponse struct {
	httpResponse *http.Response
	Data         []components.IssueComment
}

func (r *ListCommentsForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListEvents performs requests for "issues/list-events"

List issue events.

  GET /repos/{owner}/{repo}/issues/{issue_number}/events

https://developer.github.com/v3/issues/events/#list-issue-events
*/
func ListEvents(ctx context.Context, req *ListEventsReq, opt ...requests.Option) (*ListEventsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListEventsReq)
	}
	resp := &ListEventsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListEventsResponse(r, opts.PreserveResponseBody())
}

// NewListEventsResponse builds a new *ListEventsResponse from an *http.Response
func NewListEventsResponse(resp *http.Response, preserveBody bool) (*ListEventsResponse, error) {
	var result ListEventsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListEvents performs requests for "issues/list-events"

List issue events.

  GET /repos/{owner}/{repo}/issues/{issue_number}/events

https://developer.github.com/v3/issues/events/#list-issue-events
*/
func (c Client) ListEvents(ctx context.Context, req *ListEventsReq, opt ...requests.Option) (*ListEventsResponse, error) {
	return ListEvents(ctx, req, append(c, opt...)...)
}

/*
ListEventsReq is request data for Client.ListEvents

https://developer.github.com/v3/issues/events/#list-issue-events
*/
type ListEventsReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListEventsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListEventsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"starfox", "sailor-v"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list-events",
		Previews: map[string]bool{
			"sailor-v": r.SailorVPreview,
			"starfox":  r.StarfoxPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/events", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListEventsReq) Rel(link string, resp *ListEventsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListEventsResponse is a response for ListEvents

https://developer.github.com/v3/issues/events/#list-issue-events
*/
type ListEventsResponse struct {
	httpResponse *http.Response
	Data         []components.IssueEventForIssue
}

func (r *ListEventsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListEventsForRepo performs requests for "issues/list-events-for-repo"

List issue events for a repository.

  GET /repos/{owner}/{repo}/issues/events

https://developer.github.com/v3/issues/events/#list-issue-events-for-a-repository
*/
func ListEventsForRepo(ctx context.Context, req *ListEventsForRepoReq, opt ...requests.Option) (*ListEventsForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListEventsForRepoReq)
	}
	resp := &ListEventsForRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListEventsForRepoResponse(r, opts.PreserveResponseBody())
}

// NewListEventsForRepoResponse builds a new *ListEventsForRepoResponse from an *http.Response
func NewListEventsForRepoResponse(resp *http.Response, preserveBody bool) (*ListEventsForRepoResponse, error) {
	var result ListEventsForRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListEventsForRepo performs requests for "issues/list-events-for-repo"

List issue events for a repository.

  GET /repos/{owner}/{repo}/issues/events

https://developer.github.com/v3/issues/events/#list-issue-events-for-a-repository
*/
func (c Client) ListEventsForRepo(ctx context.Context, req *ListEventsForRepoReq, opt ...requests.Option) (*ListEventsForRepoResponse, error) {
	return ListEventsForRepo(ctx, req, append(c, opt...)...)
}

/*
ListEventsForRepoReq is request data for Client.ListEventsForRepo

https://developer.github.com/v3/issues/events/#list-issue-events-for-a-repository
*/
type ListEventsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListEventsForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListEventsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"starfox", "sailor-v"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list-events-for-repo",
		Previews: map[string]bool{
			"sailor-v": r.SailorVPreview,
			"starfox":  r.StarfoxPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/events", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListEventsForRepoReq) Rel(link string, resp *ListEventsForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListEventsForRepoResponse is a response for ListEventsForRepo

https://developer.github.com/v3/issues/events/#list-issue-events-for-a-repository
*/
type ListEventsForRepoResponse struct {
	httpResponse *http.Response
	Data         []components.IssueEvent
}

func (r *ListEventsForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListEventsForTimeline performs requests for "issues/list-events-for-timeline"

List timeline events for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/timeline

https://developer.github.com/v3/issues/timeline/#list-timeline-events-for-an-issue
*/
func ListEventsForTimeline(ctx context.Context, req *ListEventsForTimelineReq, opt ...requests.Option) (*ListEventsForTimelineResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListEventsForTimelineReq)
	}
	resp := &ListEventsForTimelineResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListEventsForTimelineResponse(r, opts.PreserveResponseBody())
}

// NewListEventsForTimelineResponse builds a new *ListEventsForTimelineResponse from an *http.Response
func NewListEventsForTimelineResponse(resp *http.Response, preserveBody bool) (*ListEventsForTimelineResponse, error) {
	var result ListEventsForTimelineResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListEventsForTimeline performs requests for "issues/list-events-for-timeline"

List timeline events for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/timeline

https://developer.github.com/v3/issues/timeline/#list-timeline-events-for-an-issue
*/
func (c Client) ListEventsForTimeline(ctx context.Context, req *ListEventsForTimelineReq, opt ...requests.Option) (*ListEventsForTimelineResponse, error) {
	return ListEventsForTimeline(ctx, req, append(c, opt...)...)
}

/*
ListEventsForTimelineReq is request data for Client.ListEventsForTimeline

https://developer.github.com/v3/issues/timeline/#list-timeline-events-for-an-issue
*/
type ListEventsForTimelineReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The API to get issue timeline events is currently available for developers to
	preview. During the preview period, the APIs may change without advance notice.
	Please see the [blog
	post](https://developer.github.com/changes/2016-05-23-timeline-preview-api/) for
	full details. To access the API you must set this to true.
	*/
	MockingbirdPreview bool

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListEventsForTimelineReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListEventsForTimelineReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"mockingbird", "starfox"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list-events-for-timeline",
		Previews: map[string]bool{
			"mockingbird": r.MockingbirdPreview,
			"starfox":     r.StarfoxPreview,
		},
		RequiredPreviews: []string{"mockingbird"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/timeline", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListEventsForTimelineReq) Rel(link string, resp *ListEventsForTimelineResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListEventsForTimelineResponse is a response for ListEventsForTimeline

https://developer.github.com/v3/issues/timeline/#list-timeline-events-for-an-issue
*/
type ListEventsForTimelineResponse struct {
	httpResponse *http.Response
	Data         []components.IssueEventForIssue
}

func (r *ListEventsForTimelineResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListForAuthenticatedUser performs requests for "issues/list-for-authenticated-user"

List user account issues assigned to the authenticated user.

  GET /user/issues

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
func ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForAuthenticatedUserReq)
	}
	resp := &ListForAuthenticatedUserResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListForAuthenticatedUserResponse(r, opts.PreserveResponseBody())
}

// NewListForAuthenticatedUserResponse builds a new *ListForAuthenticatedUserResponse from an *http.Response
func NewListForAuthenticatedUserResponse(resp *http.Response, preserveBody bool) (*ListForAuthenticatedUserResponse, error) {
	var result ListForAuthenticatedUserResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 304})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListForAuthenticatedUser performs requests for "issues/list-for-authenticated-user"

List user account issues assigned to the authenticated user.

  GET /user/issues

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
func (c Client) ListForAuthenticatedUser(ctx context.Context, req *ListForAuthenticatedUserReq, opt ...requests.Option) (*ListForAuthenticatedUserResponse, error) {
	return ListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ListForAuthenticatedUserReq is request data for Client.ListForAuthenticatedUser

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
type ListForAuthenticatedUserReq struct {
	_url string

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man", "squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list-for-authenticated-user",
		Previews: map[string]bool{
			"machine-man":   r.MachineManPreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/issues"),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForAuthenticatedUserReq) Rel(link string, resp *ListForAuthenticatedUserResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForAuthenticatedUserResponse is a response for ListForAuthenticatedUser

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
type ListForAuthenticatedUserResponse struct {
	httpResponse *http.Response
	Data         []components.Issue
}

func (r *ListForAuthenticatedUserResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListForOrg performs requests for "issues/list-for-org"

List organization issues assigned to the authenticated user.

  GET /orgs/{org}/issues

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
func ListForOrg(ctx context.Context, req *ListForOrgReq, opt ...requests.Option) (*ListForOrgResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForOrgReq)
	}
	resp := &ListForOrgResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListForOrgResponse(r, opts.PreserveResponseBody())
}

// NewListForOrgResponse builds a new *ListForOrgResponse from an *http.Response
func NewListForOrgResponse(resp *http.Response, preserveBody bool) (*ListForOrgResponse, error) {
	var result ListForOrgResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListForOrg performs requests for "issues/list-for-org"

List organization issues assigned to the authenticated user.

  GET /orgs/{org}/issues

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
func (c Client) ListForOrg(ctx context.Context, req *ListForOrgReq, opt ...requests.Option) (*ListForOrgResponse, error) {
	return ListForOrg(ctx, req, append(c, opt...)...)
}

/*
ListForOrgReq is request data for Client.ListForOrg

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
type ListForOrgReq struct {
	_url string
	Org  string

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForOrgReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man", "squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list-for-org",
		Previews: map[string]bool{
			"machine-man":   r.MachineManPreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/issues", r.Org),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForOrgReq) Rel(link string, resp *ListForOrgResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForOrgResponse is a response for ListForOrg

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
type ListForOrgResponse struct {
	httpResponse *http.Response
	Data         []components.Issue
}

func (r *ListForOrgResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListForRepo performs requests for "issues/list-for-repo"

List repository issues.

  GET /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#list-repository-issues
*/
func ListForRepo(ctx context.Context, req *ListForRepoReq, opt ...requests.Option) (*ListForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListForRepoReq)
	}
	resp := &ListForRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListForRepoResponse(r, opts.PreserveResponseBody())
}

// NewListForRepoResponse builds a new *ListForRepoResponse from an *http.Response
func NewListForRepoResponse(resp *http.Response, preserveBody bool) (*ListForRepoResponse, error) {
	var result ListForRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 301})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListForRepo performs requests for "issues/list-for-repo"

List repository issues.

  GET /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#list-repository-issues
*/
func (c Client) ListForRepo(ctx context.Context, req *ListForRepoReq, opt ...requests.Option) (*ListForRepoResponse, error) {
	return ListForRepo(ctx, req, append(c, opt...)...)
}

/*
ListForRepoReq is request data for Client.ListForRepo

https://developer.github.com/v3/issues/#list-repository-issues
*/
type ListForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	If an `integer` is passed, it should refer to a milestone by its `number` field.
	If the string `*` is passed, issues with any milestone are accepted. If the
	string `none` is passed, issues without milestones are returned.
	*/
	Milestone *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	/*
	Can be the name of a user. Pass in `none` for issues with no assigned user, and
	`*` for issues assigned to any user.
	*/
	Assignee *string

	// The user that created the issue.
	Creator *string

	// A user that's mentioned in the issue.
	Mentioned *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ListForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Milestone != nil {
		query.Set("milestone", *r.Milestone)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Assignee != nil {
		query.Set("assignee", *r.Assignee)
	}
	if r.Creator != nil {
		query.Set("creator", *r.Creator)
	}
	if r.Mentioned != nil {
		query.Set("mentioned", *r.Mentioned)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"machine-man", "squirrel-girl"},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list-for-repo",
		Previews: map[string]bool{
			"machine-man":   r.MachineManPreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues", r.Owner, r.Repo),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListForRepoReq) Rel(link string, resp *ListForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListForRepoResponse is a response for ListForRepo

https://developer.github.com/v3/issues/#list-repository-issues
*/
type ListForRepoResponse struct {
	httpResponse *http.Response
	Data         []components.IssueSimple
}

func (r *ListForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListLabelsForMilestone performs requests for "issues/list-labels-for-milestone"

List labels for issues in a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-issues-in-a-milestone
*/
func ListLabelsForMilestone(ctx context.Context, req *ListLabelsForMilestoneReq, opt ...requests.Option) (*ListLabelsForMilestoneResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListLabelsForMilestoneReq)
	}
	resp := &ListLabelsForMilestoneResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListLabelsForMilestoneResponse(r, opts.PreserveResponseBody())
}

// NewListLabelsForMilestoneResponse builds a new *ListLabelsForMilestoneResponse from an *http.Response
func NewListLabelsForMilestoneResponse(resp *http.Response, preserveBody bool) (*ListLabelsForMilestoneResponse, error) {
	var result ListLabelsForMilestoneResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListLabelsForMilestone performs requests for "issues/list-labels-for-milestone"

List labels for issues in a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-issues-in-a-milestone
*/
func (c Client) ListLabelsForMilestone(ctx context.Context, req *ListLabelsForMilestoneReq, opt ...requests.Option) (*ListLabelsForMilestoneResponse, error) {
	return ListLabelsForMilestone(ctx, req, append(c, opt...)...)
}

/*
ListLabelsForMilestoneReq is request data for Client.ListLabelsForMilestone

https://developer.github.com/v3/issues/labels/#list-labels-for-issues-in-a-milestone
*/
type ListLabelsForMilestoneReq struct {
	_url  string
	Owner string
	Repo  string

	// milestone_number parameter
	MilestoneNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListLabelsForMilestoneReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListLabelsForMilestoneReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list-labels-for-milestone",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/milestones/%v/labels", r.Owner, r.Repo, r.MilestoneNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListLabelsForMilestoneReq) Rel(link string, resp *ListLabelsForMilestoneResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListLabelsForMilestoneResponse is a response for ListLabelsForMilestone

https://developer.github.com/v3/issues/labels/#list-labels-for-issues-in-a-milestone
*/
type ListLabelsForMilestoneResponse struct {
	httpResponse *http.Response
	Data         []components.Label
}

func (r *ListLabelsForMilestoneResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListLabelsForRepo performs requests for "issues/list-labels-for-repo"

List labels for a repository.

  GET /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-a-repository
*/
func ListLabelsForRepo(ctx context.Context, req *ListLabelsForRepoReq, opt ...requests.Option) (*ListLabelsForRepoResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListLabelsForRepoReq)
	}
	resp := &ListLabelsForRepoResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListLabelsForRepoResponse(r, opts.PreserveResponseBody())
}

// NewListLabelsForRepoResponse builds a new *ListLabelsForRepoResponse from an *http.Response
func NewListLabelsForRepoResponse(resp *http.Response, preserveBody bool) (*ListLabelsForRepoResponse, error) {
	var result ListLabelsForRepoResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListLabelsForRepo performs requests for "issues/list-labels-for-repo"

List labels for a repository.

  GET /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-a-repository
*/
func (c Client) ListLabelsForRepo(ctx context.Context, req *ListLabelsForRepoReq, opt ...requests.Option) (*ListLabelsForRepoResponse, error) {
	return ListLabelsForRepo(ctx, req, append(c, opt...)...)
}

/*
ListLabelsForRepoReq is request data for Client.ListLabelsForRepo

https://developer.github.com/v3/issues/labels/#list-labels-for-a-repository
*/
type ListLabelsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListLabelsForRepoReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListLabelsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list-labels-for-repo",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/labels", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListLabelsForRepoReq) Rel(link string, resp *ListLabelsForRepoResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListLabelsForRepoResponse is a response for ListLabelsForRepo

https://developer.github.com/v3/issues/labels/#list-labels-for-a-repository
*/
type ListLabelsForRepoResponse struct {
	httpResponse *http.Response
	Data         []components.Label
}

func (r *ListLabelsForRepoResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListLabelsOnIssue performs requests for "issues/list-labels-on-issue"

List labels for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-an-issue
*/
func ListLabelsOnIssue(ctx context.Context, req *ListLabelsOnIssueReq, opt ...requests.Option) (*ListLabelsOnIssueResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListLabelsOnIssueReq)
	}
	resp := &ListLabelsOnIssueResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListLabelsOnIssueResponse(r, opts.PreserveResponseBody())
}

// NewListLabelsOnIssueResponse builds a new *ListLabelsOnIssueResponse from an *http.Response
func NewListLabelsOnIssueResponse(resp *http.Response, preserveBody bool) (*ListLabelsOnIssueResponse, error) {
	var result ListLabelsOnIssueResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListLabelsOnIssue performs requests for "issues/list-labels-on-issue"

List labels for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-an-issue
*/
func (c Client) ListLabelsOnIssue(ctx context.Context, req *ListLabelsOnIssueReq, opt ...requests.Option) (*ListLabelsOnIssueResponse, error) {
	return ListLabelsOnIssue(ctx, req, append(c, opt...)...)
}

/*
ListLabelsOnIssueReq is request data for Client.ListLabelsOnIssue

https://developer.github.com/v3/issues/labels/#list-labels-for-an-issue
*/
type ListLabelsOnIssueReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListLabelsOnIssueReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListLabelsOnIssueReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list-labels-on-issue",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListLabelsOnIssueReq) Rel(link string, resp *ListLabelsOnIssueResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListLabelsOnIssueResponse is a response for ListLabelsOnIssue

https://developer.github.com/v3/issues/labels/#list-labels-for-an-issue
*/
type ListLabelsOnIssueResponse struct {
	httpResponse *http.Response
	Data         []components.Label
}

func (r *ListLabelsOnIssueResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
ListMilestones performs requests for "issues/list-milestones"

List milestones.

  GET /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#list-milestones
*/
func ListMilestones(ctx context.Context, req *ListMilestonesReq, opt ...requests.Option) (*ListMilestonesResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ListMilestonesReq)
	}
	resp := &ListMilestonesResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewListMilestonesResponse(r, opts.PreserveResponseBody())
}

// NewListMilestonesResponse builds a new *ListMilestonesResponse from an *http.Response
func NewListMilestonesResponse(resp *http.Response, preserveBody bool) (*ListMilestonesResponse, error) {
	var result ListMilestonesResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
ListMilestones performs requests for "issues/list-milestones"

List milestones.

  GET /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#list-milestones
*/
func (c Client) ListMilestones(ctx context.Context, req *ListMilestonesReq, opt ...requests.Option) (*ListMilestonesResponse, error) {
	return ListMilestones(ctx, req, append(c, opt...)...)
}

/*
ListMilestonesReq is request data for Client.ListMilestones

https://developer.github.com/v3/issues/milestones/#list-milestones
*/
type ListMilestonesReq struct {
	_url  string
	Owner string
	Repo  string

	// The state of the milestone. Either `open`, `closed`, or `all`.
	State *string

	// What to sort results by. Either `due_on` or `completeness`.
	Sort *string

	// The direction of the sort. Either `asc` or `desc`.
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ListMilestonesReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ListMilestonesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "GET",
		OperationID:        "issues/list-milestones",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/milestones", r.Owner, r.Repo),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ListMilestonesReq) Rel(link string, resp *ListMilestonesResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ListMilestonesResponse is a response for ListMilestones

https://developer.github.com/v3/issues/milestones/#list-milestones
*/
type ListMilestonesResponse struct {
	httpResponse *http.Response
	Data         []components.Milestone
}

func (r *ListMilestonesResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Lock performs requests for "issues/lock"

Lock an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
func Lock(ctx context.Context, req *LockReq, opt ...requests.Option) (*LockResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(LockReq)
	}
	resp := &LockResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewLockResponse(r, opts.PreserveResponseBody())
}

// NewLockResponse builds a new *LockResponse from an *http.Response
func NewLockResponse(resp *http.Response, preserveBody bool) (*LockResponse, error) {
	var result LockResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
Lock performs requests for "issues/lock"

Lock an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
func (c Client) Lock(ctx context.Context, req *LockReq, opt ...requests.Option) (*LockResponse, error) {
	return Lock(ctx, req, append(c, opt...)...)
}

/*
LockReq is request data for Client.Lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
type LockReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody LockReqBody

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request
func (r *LockReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *LockReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{"sailor-v"},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"content-type": internal.String("application/json")},
		Method:             "PUT",
		OperationID:        "issues/lock",
		Previews:           map[string]bool{"sailor-v": r.SailorVPreview},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/issues/%v/lock", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *LockReq) Rel(link string, resp *LockResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
LockReqBody is a request body for issues/lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
type LockReqBody struct {

	/*
	The reason for locking the issue or pull request conversation. Lock will fail if
	you don't use one of these reasons:
	\* `off-topic`
	\* `too heated`
	\* `resolved`
	\* `spam`
	*/
	LockReason *string `json:"lock_reason,omitempty"`
}

/*
LockResponse is a response for Lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
type LockResponse struct {
	httpResponse *http.Response
}

func (r *LockResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveAllLabels performs requests for "issues/remove-all-labels"

Remove all labels from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
func RemoveAllLabels(ctx context.Context, req *RemoveAllLabelsReq, opt ...requests.Option) (*RemoveAllLabelsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveAllLabelsReq)
	}
	resp := &RemoveAllLabelsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveAllLabelsResponse(r, opts.PreserveResponseBody())
}

// NewRemoveAllLabelsResponse builds a new *RemoveAllLabelsResponse from an *http.Response
func NewRemoveAllLabelsResponse(resp *http.Response, preserveBody bool) (*RemoveAllLabelsResponse, error) {
	var result RemoveAllLabelsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
RemoveAllLabels performs requests for "issues/remove-all-labels"

Remove all labels from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
func (c Client) RemoveAllLabels(ctx context.Context, req *RemoveAllLabelsReq, opt ...requests.Option) (*RemoveAllLabelsResponse, error) {
	return RemoveAllLabels(ctx, req, append(c, opt...)...)
}

/*
RemoveAllLabelsReq is request data for Client.RemoveAllLabels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
type RemoveAllLabelsReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
}

// HTTPRequest builds an *http.Request
func (r *RemoveAllLabelsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveAllLabelsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "issues/remove-all-labels",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveAllLabelsReq) Rel(link string, resp *RemoveAllLabelsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveAllLabelsResponse is a response for RemoveAllLabels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
type RemoveAllLabelsResponse struct {
	httpResponse *http.Response
}

func (r *RemoveAllLabelsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveAssignees performs requests for "issues/remove-assignees"

Remove assignees from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
func RemoveAssignees(ctx context.Context, req *RemoveAssigneesReq, opt ...requests.Option) (*RemoveAssigneesResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveAssigneesReq)
	}
	resp := &RemoveAssigneesResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveAssigneesResponse(r, opts.PreserveResponseBody())
}

// NewRemoveAssigneesResponse builds a new *RemoveAssigneesResponse from an *http.Response
func NewRemoveAssigneesResponse(resp *http.Response, preserveBody bool) (*RemoveAssigneesResponse, error) {
	var result RemoveAssigneesResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
RemoveAssignees performs requests for "issues/remove-assignees"

Remove assignees from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
func (c Client) RemoveAssignees(ctx context.Context, req *RemoveAssigneesReq, opt ...requests.Option) (*RemoveAssigneesResponse, error) {
	return RemoveAssignees(ctx, req, append(c, opt...)...)
}

/*
RemoveAssigneesReq is request data for Client.RemoveAssignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type RemoveAssigneesReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody RemoveAssigneesReqBody
}

// HTTPRequest builds an *http.Request
func (r *RemoveAssigneesReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveAssigneesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "DELETE",
		OperationID:      "issues/remove-assignees",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/assignees", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveAssigneesReq) Rel(link string, resp *RemoveAssigneesResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveAssigneesReqBody is a request body for issues/remove-assignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type RemoveAssigneesReqBody struct {

	/*
	Usernames of assignees to remove from an issue. _NOTE: Only users with push
	access can remove assignees from an issue. Assignees are silently ignored
	otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`
}

/*
RemoveAssigneesResponse is a response for RemoveAssignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type RemoveAssigneesResponse struct {
	httpResponse *http.Response
	Data         components.IssueSimple
}

func (r *RemoveAssigneesResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
RemoveLabel performs requests for "issues/remove-label"

Remove a label from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
func RemoveLabel(ctx context.Context, req *RemoveLabelReq, opt ...requests.Option) (*RemoveLabelResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(RemoveLabelReq)
	}
	resp := &RemoveLabelResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewRemoveLabelResponse(r, opts.PreserveResponseBody())
}

// NewRemoveLabelResponse builds a new *RemoveLabelResponse from an *http.Response
func NewRemoveLabelResponse(resp *http.Response, preserveBody bool) (*RemoveLabelResponse, error) {
	var result RemoveLabelResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
RemoveLabel performs requests for "issues/remove-label"

Remove a label from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
func (c Client) RemoveLabel(ctx context.Context, req *RemoveLabelReq, opt ...requests.Option) (*RemoveLabelResponse, error) {
	return RemoveLabel(ctx, req, append(c, opt...)...)
}

/*
RemoveLabelReq is request data for Client.RemoveLabel

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
type RemoveLabelReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	// name parameter
	Name string
}

// HTTPRequest builds an *http.Request
func (r *RemoveLabelReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *RemoveLabelReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{"accept": internal.String("application/json")},
		Method:             "DELETE",
		OperationID:        "issues/remove-label",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/issues/%v/labels/%v", r.Owner, r.Repo, r.IssueNumber, r.Name),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *RemoveLabelReq) Rel(link string, resp *RemoveLabelResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
RemoveLabelResponse is a response for RemoveLabel

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
type RemoveLabelResponse struct {
	httpResponse *http.Response
	Data         []components.Label
}

func (r *RemoveLabelResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
SetLabels performs requests for "issues/set-labels"

Set labels for an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
func SetLabels(ctx context.Context, req *SetLabelsReq, opt ...requests.Option) (*SetLabelsResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(SetLabelsReq)
	}
	resp := &SetLabelsResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewSetLabelsResponse(r, opts.PreserveResponseBody())
}

// NewSetLabelsResponse builds a new *SetLabelsResponse from an *http.Response
func NewSetLabelsResponse(resp *http.Response, preserveBody bool) (*SetLabelsResponse, error) {
	var result SetLabelsResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
SetLabels performs requests for "issues/set-labels"

Set labels for an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
func (c Client) SetLabels(ctx context.Context, req *SetLabelsReq, opt ...requests.Option) (*SetLabelsResponse, error) {
	return SetLabels(ctx, req, append(c, opt...)...)
}

/*
SetLabelsReq is request data for Client.SetLabels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
type SetLabelsReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody SetLabelsReqBody
}

// HTTPRequest builds an *http.Request
func (r *SetLabelsReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *SetLabelsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "issues/set-labels",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *SetLabelsReq) Rel(link string, resp *SetLabelsResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
SetLabelsReqBody is a request body for issues/set-labels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
type SetLabelsReqBody struct {

	/*
	The names of the labels to add to the issue. You can pass an empty array to
	remove all labels. **Note:** Alternatively, you can pass a single label as a
	`string` or an `array` of labels directly, but GitHub recommends passing an
	object with the `labels` key.
	*/
	Labels []string `json:"labels,omitempty"`
}

/*
SetLabelsResponse is a response for SetLabels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
type SetLabelsResponse struct {
	httpResponse *http.Response
	Data         []components.Label
}

func (r *SetLabelsResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Unlock performs requests for "issues/unlock"

Unlock an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
func Unlock(ctx context.Context, req *UnlockReq, opt ...requests.Option) (*UnlockResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UnlockReq)
	}
	resp := &UnlockResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUnlockResponse(r, opts.PreserveResponseBody())
}

// NewUnlockResponse builds a new *UnlockResponse from an *http.Response
func NewUnlockResponse(resp *http.Response, preserveBody bool) (*UnlockResponse, error) {
	var result UnlockResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{204})
	if err != nil {
		return &result, err
	}
	return &result, nil
}

/*
Unlock performs requests for "issues/unlock"

Unlock an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
func (c Client) Unlock(ctx context.Context, req *UnlockReq, opt ...requests.Option) (*UnlockResponse, error) {
	return Unlock(ctx, req, append(c, opt...)...)
}

/*
UnlockReq is request data for Client.Unlock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
type UnlockReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
}

// HTTPRequest builds an *http.Request
func (r *UnlockReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UnlockReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               nil,
		EndpointAttributes: []internal.EndpointAttribute{},
		ExplicitURL:        r._url,
		HeaderVals:         map[string]*string{},
		Method:             "DELETE",
		OperationID:        "issues/unlock",
		Previews:           map[string]bool{},
		RequiredPreviews:   []string{},
		URLPath:            fmt.Sprintf("/repos/%v/%v/issues/%v/lock", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:           query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UnlockReq) Rel(link string, resp *UnlockResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UnlockResponse is a response for Unlock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
type UnlockResponse struct {
	httpResponse *http.Response
}

func (r *UnlockResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
Update performs requests for "issues/update"

Update an issue.

  PATCH /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#update-an-issue
*/
func Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateReq)
	}
	resp := &UpdateResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateResponse(r, opts.PreserveResponseBody())
}

// NewUpdateResponse builds a new *UpdateResponse from an *http.Response
func NewUpdateResponse(resp *http.Response, preserveBody bool) (*UpdateResponse, error) {
	var result UpdateResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200, 301})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
Update performs requests for "issues/update"

Update an issue.

  PATCH /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#update-an-issue
*/
func (c Client) Update(ctx context.Context, req *UpdateReq, opt ...requests.Option) (*UpdateResponse, error) {
	return Update(ctx, req, append(c, opt...)...)
}

/*
UpdateReq is request data for Client.Update

https://developer.github.com/v3/issues/#update-an-issue
*/
type UpdateReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody UpdateReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "issues/update",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateReq) Rel(link string, resp *UpdateResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateReqBody is a request body for issues/update

https://developer.github.com/v3/issues/#update-an-issue
*/
type UpdateReqBody struct {

	// Login for the user that this issue should be assigned to. **This field is deprecated.**
	Assignee *string `json:"assignee,omitempty"`

	/*
	Logins for Users to assign to this issue. Pass one or more user logins to
	_replace_ the set of assignees on this Issue. Send an empty array (`[]`) to
	clear all assignees from the Issue. _NOTE: Only users with push access can set
	assignees for new issues. Assignees are silently dropped otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`

	// The contents of the issue.
	Body *string `json:"body,omitempty"`

	/*
	Labels to associate with this issue. Pass one or more Labels to _replace_ the
	set of Labels on this Issue. Send an empty array (`[]`) to clear all Labels from
	the Issue. _NOTE: Only users with push access can set labels for issues. Labels
	are silently dropped otherwise._
	*/
	Labels []string `json:"labels,omitempty"`

	/*
	The `number` of the milestone to associate this issue with or `null` to remove
	current. _NOTE: Only users with push access can set the milestone for issues.
	The milestone is silently dropped otherwise._
	*/
	Milestone *int64 `json:"milestone,omitempty"`

	// State of the issue. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the issue.
	Title *string `json:"title,omitempty"`
}

/*
UpdateResponse is a response for Update

https://developer.github.com/v3/issues/#update-an-issue
*/
type UpdateResponse struct {
	httpResponse *http.Response
	Data         components.Issue
}

func (r *UpdateResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateComment performs requests for "issues/update-comment"

Update an issue comment.

  PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
func UpdateComment(ctx context.Context, req *UpdateCommentReq, opt ...requests.Option) (*UpdateCommentResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateCommentReq)
	}
	resp := &UpdateCommentResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateCommentResponse(r, opts.PreserveResponseBody())
}

// NewUpdateCommentResponse builds a new *UpdateCommentResponse from an *http.Response
func NewUpdateCommentResponse(resp *http.Response, preserveBody bool) (*UpdateCommentResponse, error) {
	var result UpdateCommentResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateComment performs requests for "issues/update-comment"

Update an issue comment.

  PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
func (c Client) UpdateComment(ctx context.Context, req *UpdateCommentReq, opt ...requests.Option) (*UpdateCommentResponse, error) {
	return UpdateComment(ctx, req, append(c, opt...)...)
}

/*
UpdateCommentReq is request data for Client.UpdateComment

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
type UpdateCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody UpdateCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateCommentReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "issues/update-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateCommentReq) Rel(link string, resp *UpdateCommentResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateCommentReqBody is a request body for issues/update-comment

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
type UpdateCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`
}

/*
UpdateCommentResponse is a response for UpdateComment

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
type UpdateCommentResponse struct {
	httpResponse *http.Response
	Data         components.IssueComment
}

func (r *UpdateCommentResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateLabel performs requests for "issues/update-label"

Update a label.

  PATCH /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#update-a-label
*/
func UpdateLabel(ctx context.Context, req *UpdateLabelReq, opt ...requests.Option) (*UpdateLabelResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateLabelReq)
	}
	resp := &UpdateLabelResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateLabelResponse(r, opts.PreserveResponseBody())
}

// NewUpdateLabelResponse builds a new *UpdateLabelResponse from an *http.Response
func NewUpdateLabelResponse(resp *http.Response, preserveBody bool) (*UpdateLabelResponse, error) {
	var result UpdateLabelResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateLabel performs requests for "issues/update-label"

Update a label.

  PATCH /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#update-a-label
*/
func (c Client) UpdateLabel(ctx context.Context, req *UpdateLabelReq, opt ...requests.Option) (*UpdateLabelResponse, error) {
	return UpdateLabel(ctx, req, append(c, opt...)...)
}

/*
UpdateLabelReq is request data for Client.UpdateLabel

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type UpdateLabelReq struct {
	_url  string
	Owner string
	Repo  string

	// name parameter
	Name        string
	RequestBody UpdateLabelReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateLabelReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateLabelReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "issues/update-label",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateLabelReq) Rel(link string, resp *UpdateLabelResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateLabelReqBody is a request body for issues/update-label

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type UpdateLabelReqBody struct {

	// The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.
	Color *string `json:"color,omitempty"`

	// A short description of the label.
	Description *string `json:"description,omitempty"`

	/*
	The new name of the label. Emoji can be added to label names, using either
	native emoji or colon-style markup. For example, typing `:strawberry:` will
	render the emoji
	![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png
	":strawberry:"). For a full list of available emoji and codes, see
	[emoji-cheat-sheet.com](http://emoji-cheat-sheet.com/).
	*/
	NewName *string `json:"new_name,omitempty"`
}

/*
UpdateLabelResponse is a response for UpdateLabel

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type UpdateLabelResponse struct {
	httpResponse *http.Response
	Data         components.Label
}

func (r *UpdateLabelResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}

/*
UpdateMilestone performs requests for "issues/update-milestone"

Update a milestone.

  PATCH /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
func UpdateMilestone(ctx context.Context, req *UpdateMilestoneReq, opt ...requests.Option) (*UpdateMilestoneResponse, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UpdateMilestoneReq)
	}
	resp := &UpdateMilestoneResponse{}
	builder := req.requestBuilder()

	httpReq, err := builder.HTTPRequest(ctx, opts)
	if err != nil {
		return resp, err
	}

	r, err := opts.HttpClient().Do(httpReq)
	if err != nil {
		return resp, err
	}
	resp.httpResponse = r

	return NewUpdateMilestoneResponse(r, opts.PreserveResponseBody())
}

// NewUpdateMilestoneResponse builds a new *UpdateMilestoneResponse from an *http.Response
func NewUpdateMilestoneResponse(resp *http.Response, preserveBody bool) (*UpdateMilestoneResponse, error) {
	var result UpdateMilestoneResponse
	result.httpResponse = resp
	err := internal.ErrorCheck(resp, []int{200})
	if err != nil {
		return &result, err
	}
	if internal.IntInSlice(resp.StatusCode, []int{200}) {
		err = internal.DecodeResponseBody(resp, &result.Data, preserveBody)
		if err != nil {
			return &result, err
		}
	}
	return &result, nil
}

/*
UpdateMilestone performs requests for "issues/update-milestone"

Update a milestone.

  PATCH /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
func (c Client) UpdateMilestone(ctx context.Context, req *UpdateMilestoneReq, opt ...requests.Option) (*UpdateMilestoneResponse, error) {
	return UpdateMilestone(ctx, req, append(c, opt...)...)
}

/*
UpdateMilestoneReq is request data for Client.UpdateMilestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type UpdateMilestoneReq struct {
	_url  string
	Owner string
	Repo  string

	// milestone_number parameter
	MilestoneNumber int64
	RequestBody     UpdateMilestoneReqBody
}

// HTTPRequest builds an *http.Request
func (r *UpdateMilestoneReq) HTTPRequest(ctx context.Context, opt ...requests.Option) (*http.Request, error) {
	opts, err := requests.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UpdateMilestoneReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:        []string{},
		Body:               r.RequestBody,
		EndpointAttributes: []internal.EndpointAttribute{internal.AttrJSONRequestBody},
		ExplicitURL:        r._url,
		HeaderVals: map[string]*string{
			"accept":       internal.String("application/json"),
			"content-type": internal.String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "issues/update-milestone",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber),
		URLQuery:         query,
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UpdateMilestoneReq) Rel(link string, resp *UpdateMilestoneResponse) bool {
	u := internal.RelLink(resp.HTTPResponse(), link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UpdateMilestoneReqBody is a request body for issues/update-milestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type UpdateMilestoneReqBody struct {

	// A description of the milestone.
	Description *string `json:"description,omitempty"`

	/*
	The milestone due date. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	DueOn *string `json:"due_on,omitempty"`

	// The state of the milestone. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the milestone.
	Title *string `json:"title,omitempty"`
}

/*
UpdateMilestoneResponse is a response for UpdateMilestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type UpdateMilestoneResponse struct {
	httpResponse *http.Response
	Data         components.Milestone
}

func (r *UpdateMilestoneResponse) HTTPResponse() *http.Response {
	return r.httpResponse
}
