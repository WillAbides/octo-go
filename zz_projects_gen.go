// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
ProjectsAddCollaborator performs requests for "projects/add-collaborator"

Add project collaborator.

  PUT /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
func ProjectsAddCollaborator(ctx context.Context, req *ProjectsAddCollaboratorReq, opt ...options.Option) (*ProjectsAddCollaboratorResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsAddCollaboratorReq)
	}
	resp := &ProjectsAddCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsAddCollaborator performs requests for "projects/add-collaborator"

Add project collaborator.

  PUT /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
func (c Client) ProjectsAddCollaborator(ctx context.Context, req *ProjectsAddCollaboratorReq, opt ...options.Option) (*ProjectsAddCollaboratorResponse, error) {
	return ProjectsAddCollaborator(ctx, req, append(c, opt...)...)
}

/*
ProjectsAddCollaboratorReq is request data for Client.ProjectsAddCollaborator

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
type ProjectsAddCollaboratorReq struct {
	_url        string
	ProjectId   int64
	Username    string
	RequestBody ProjectsAddCollaboratorReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsAddCollaboratorReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsAddCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "PUT",
		OperationID:      "projects/add-collaborator",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v/collaborators/%v", r.ProjectId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsAddCollaboratorReq) Rel(link RelName, resp *ProjectsAddCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsAddCollaboratorReqBody is a request body for projects/add-collaborator

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
type ProjectsAddCollaboratorReqBody struct {

	// The permission to grant the collaborator.
	Permission *string `json:"permission,omitempty"`
}

/*
ProjectsAddCollaboratorResponse is a response for ProjectsAddCollaborator

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
type ProjectsAddCollaboratorResponse struct {
	common.Response
	request *ProjectsAddCollaboratorReq
}

/*
ProjectsCreateCard performs requests for "projects/create-card"

Create a project card.

  POST /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
func ProjectsCreateCard(ctx context.Context, req *ProjectsCreateCardReq, opt ...options.Option) (*ProjectsCreateCardResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsCreateCardReq)
	}
	resp := &ProjectsCreateCardResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProjectCard{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateCard performs requests for "projects/create-card"

Create a project card.

  POST /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
func (c Client) ProjectsCreateCard(ctx context.Context, req *ProjectsCreateCardReq, opt ...options.Option) (*ProjectsCreateCardResponse, error) {
	return ProjectsCreateCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateCardReq is request data for Client.ProjectsCreateCard

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
type ProjectsCreateCardReq struct {
	_url string

	// column_id parameter
	ColumnId    int64
	RequestBody ProjectsCreateCardReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsCreateCardReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsCreateCardReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/create-card",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/%v/cards", r.ColumnId),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateCardReq) Rel(link RelName, resp *ProjectsCreateCardResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateCardReqBody is a request body for projects/create-card

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
type ProjectsCreateCardReqBody struct {

	// The unique identifier of the content associated with the card
	ContentId *int64 `json:"content_id"`

	// The piece of content associated with the card
	ContentType *string `json:"content_type"`
}

/*
ProjectsCreateCardResponse is a response for ProjectsCreateCard

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
type ProjectsCreateCardResponse struct {
	common.Response
	request *ProjectsCreateCardReq
	Data    components.ProjectCard
}

/*
ProjectsCreateColumn performs requests for "projects/create-column"

Create a project column.

  POST /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
func ProjectsCreateColumn(ctx context.Context, req *ProjectsCreateColumnReq, opt ...options.Option) (*ProjectsCreateColumnResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsCreateColumnReq)
	}
	resp := &ProjectsCreateColumnResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProjectColumn{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateColumn performs requests for "projects/create-column"

Create a project column.

  POST /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
func (c Client) ProjectsCreateColumn(ctx context.Context, req *ProjectsCreateColumnReq, opt ...options.Option) (*ProjectsCreateColumnResponse, error) {
	return ProjectsCreateColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateColumnReq is request data for Client.ProjectsCreateColumn

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
type ProjectsCreateColumnReq struct {
	_url        string
	ProjectId   int64
	RequestBody ProjectsCreateColumnReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsCreateColumnReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsCreateColumnReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/create-column",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v/columns", r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateColumnReq) Rel(link RelName, resp *ProjectsCreateColumnResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateColumnReqBody is a request body for projects/create-column

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
type ProjectsCreateColumnReqBody struct {

	// Name of the project column
	Name *string `json:"name"`
}

/*
ProjectsCreateColumnResponse is a response for ProjectsCreateColumn

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
type ProjectsCreateColumnResponse struct {
	common.Response
	request *ProjectsCreateColumnReq
	Data    components.ProjectColumn
}

/*
ProjectsCreateForAuthenticatedUser performs requests for "projects/create-for-authenticated-user"

Create a user project.

  POST /user/projects

https://developer.github.com/v3/projects/#create-a-user-project
*/
func ProjectsCreateForAuthenticatedUser(ctx context.Context, req *ProjectsCreateForAuthenticatedUserReq, opt ...options.Option) (*ProjectsCreateForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsCreateForAuthenticatedUserReq)
	}
	resp := &ProjectsCreateForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateForAuthenticatedUser performs requests for "projects/create-for-authenticated-user"

Create a user project.

  POST /user/projects

https://developer.github.com/v3/projects/#create-a-user-project
*/
func (c Client) ProjectsCreateForAuthenticatedUser(ctx context.Context, req *ProjectsCreateForAuthenticatedUserReq, opt ...options.Option) (*ProjectsCreateForAuthenticatedUserResponse, error) {
	return ProjectsCreateForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateForAuthenticatedUserReq is request data for Client.ProjectsCreateForAuthenticatedUser

https://developer.github.com/v3/projects/#create-a-user-project
*/
type ProjectsCreateForAuthenticatedUserReq struct {
	_url        string
	RequestBody ProjectsCreateForAuthenticatedUserReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsCreateForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsCreateForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/create-for-authenticated-user",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/user/projects"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateForAuthenticatedUserReq) Rel(link RelName, resp *ProjectsCreateForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateForAuthenticatedUserReqBody is a request body for projects/create-for-authenticated-user

https://developer.github.com/v3/projects/#create-a-user-project
*/
type ProjectsCreateForAuthenticatedUserReqBody struct {

	// Body of the project
	Body *string `json:"body,omitempty"`

	// Name of the project
	Name *string `json:"name"`
}

/*
ProjectsCreateForAuthenticatedUserResponse is a response for ProjectsCreateForAuthenticatedUser

https://developer.github.com/v3/projects/#create-a-user-project
*/
type ProjectsCreateForAuthenticatedUserResponse struct {
	common.Response
	request *ProjectsCreateForAuthenticatedUserReq
	Data    components.Project
}

/*
ProjectsCreateForOrg performs requests for "projects/create-for-org"

Create an organization project.

  POST /orgs/{org}/projects

https://developer.github.com/v3/projects/#create-an-organization-project
*/
func ProjectsCreateForOrg(ctx context.Context, req *ProjectsCreateForOrgReq, opt ...options.Option) (*ProjectsCreateForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsCreateForOrgReq)
	}
	resp := &ProjectsCreateForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateForOrg performs requests for "projects/create-for-org"

Create an organization project.

  POST /orgs/{org}/projects

https://developer.github.com/v3/projects/#create-an-organization-project
*/
func (c Client) ProjectsCreateForOrg(ctx context.Context, req *ProjectsCreateForOrgReq, opt ...options.Option) (*ProjectsCreateForOrgResponse, error) {
	return ProjectsCreateForOrg(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateForOrgReq is request data for Client.ProjectsCreateForOrg

https://developer.github.com/v3/projects/#create-an-organization-project
*/
type ProjectsCreateForOrgReq struct {
	_url        string
	Org         string
	RequestBody ProjectsCreateForOrgReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsCreateForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsCreateForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/create-for-org",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/orgs/%v/projects", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateForOrgReq) Rel(link RelName, resp *ProjectsCreateForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateForOrgReqBody is a request body for projects/create-for-org

https://developer.github.com/v3/projects/#create-an-organization-project
*/
type ProjectsCreateForOrgReqBody struct {

	// The description of the project.
	Body *string `json:"body,omitempty"`

	// The name of the project.
	Name *string `json:"name"`
}

/*
ProjectsCreateForOrgResponse is a response for ProjectsCreateForOrg

https://developer.github.com/v3/projects/#create-an-organization-project
*/
type ProjectsCreateForOrgResponse struct {
	common.Response
	request *ProjectsCreateForOrgReq
	Data    components.Project
}

/*
ProjectsCreateForRepo performs requests for "projects/create-for-repo"

Create a repository project.

  POST /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#create-a-repository-project
*/
func ProjectsCreateForRepo(ctx context.Context, req *ProjectsCreateForRepoReq, opt ...options.Option) (*ProjectsCreateForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsCreateForRepoReq)
	}
	resp := &ProjectsCreateForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateForRepo performs requests for "projects/create-for-repo"

Create a repository project.

  POST /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#create-a-repository-project
*/
func (c Client) ProjectsCreateForRepo(ctx context.Context, req *ProjectsCreateForRepoReq, opt ...options.Option) (*ProjectsCreateForRepoResponse, error) {
	return ProjectsCreateForRepo(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateForRepoReq is request data for Client.ProjectsCreateForRepo

https://developer.github.com/v3/projects/#create-a-repository-project
*/
type ProjectsCreateForRepoReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ProjectsCreateForRepoReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsCreateForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsCreateForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/create-for-repo",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/projects", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateForRepoReq) Rel(link RelName, resp *ProjectsCreateForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateForRepoReqBody is a request body for projects/create-for-repo

https://developer.github.com/v3/projects/#create-a-repository-project
*/
type ProjectsCreateForRepoReqBody struct {

	// The description of the project.
	Body *string `json:"body,omitempty"`

	// The name of the project.
	Name *string `json:"name"`
}

/*
ProjectsCreateForRepoResponse is a response for ProjectsCreateForRepo

https://developer.github.com/v3/projects/#create-a-repository-project
*/
type ProjectsCreateForRepoResponse struct {
	common.Response
	request *ProjectsCreateForRepoReq
	Data    components.Project
}

/*
ProjectsDelete performs requests for "projects/delete"

Delete a project.

  DELETE /projects/{project_id}

https://developer.github.com/v3/projects/#delete-a-project
*/
func ProjectsDelete(ctx context.Context, req *ProjectsDeleteReq, opt ...options.Option) (*ProjectsDeleteResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsDeleteReq)
	}
	resp := &ProjectsDeleteResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsDelete performs requests for "projects/delete"

Delete a project.

  DELETE /projects/{project_id}

https://developer.github.com/v3/projects/#delete-a-project
*/
func (c Client) ProjectsDelete(ctx context.Context, req *ProjectsDeleteReq, opt ...options.Option) (*ProjectsDeleteResponse, error) {
	return ProjectsDelete(ctx, req, append(c, opt...)...)
}

/*
ProjectsDeleteReq is request data for Client.ProjectsDelete

https://developer.github.com/v3/projects/#delete-a-project
*/
type ProjectsDeleteReq struct {
	_url      string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsDeleteReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsDeleteReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "projects/delete",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v", r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsDeleteReq) Rel(link RelName, resp *ProjectsDeleteResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsDeleteResponse is a response for ProjectsDelete

https://developer.github.com/v3/projects/#delete-a-project
*/
type ProjectsDeleteResponse struct {
	common.Response
	request *ProjectsDeleteReq
}

/*
ProjectsDeleteCard performs requests for "projects/delete-card"

Delete a project card.

  DELETE /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
func ProjectsDeleteCard(ctx context.Context, req *ProjectsDeleteCardReq, opt ...options.Option) (*ProjectsDeleteCardResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsDeleteCardReq)
	}
	resp := &ProjectsDeleteCardResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsDeleteCard performs requests for "projects/delete-card"

Delete a project card.

  DELETE /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
func (c Client) ProjectsDeleteCard(ctx context.Context, req *ProjectsDeleteCardReq, opt ...options.Option) (*ProjectsDeleteCardResponse, error) {
	return ProjectsDeleteCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsDeleteCardReq is request data for Client.ProjectsDeleteCard

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
type ProjectsDeleteCardReq struct {
	_url string

	// card_id parameter
	CardId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsDeleteCardReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsDeleteCardReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "projects/delete-card",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/cards/%v", r.CardId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsDeleteCardReq) Rel(link RelName, resp *ProjectsDeleteCardResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsDeleteCardResponse is a response for ProjectsDeleteCard

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
type ProjectsDeleteCardResponse struct {
	common.Response
	request *ProjectsDeleteCardReq
}

/*
ProjectsDeleteColumn performs requests for "projects/delete-column"

Delete a project column.

  DELETE /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
func ProjectsDeleteColumn(ctx context.Context, req *ProjectsDeleteColumnReq, opt ...options.Option) (*ProjectsDeleteColumnResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsDeleteColumnReq)
	}
	resp := &ProjectsDeleteColumnResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsDeleteColumn performs requests for "projects/delete-column"

Delete a project column.

  DELETE /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
func (c Client) ProjectsDeleteColumn(ctx context.Context, req *ProjectsDeleteColumnReq, opt ...options.Option) (*ProjectsDeleteColumnResponse, error) {
	return ProjectsDeleteColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsDeleteColumnReq is request data for Client.ProjectsDeleteColumn

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
type ProjectsDeleteColumnReq struct {
	_url string

	// column_id parameter
	ColumnId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsDeleteColumnReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsDeleteColumnReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "projects/delete-column",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/%v", r.ColumnId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsDeleteColumnReq) Rel(link RelName, resp *ProjectsDeleteColumnResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsDeleteColumnResponse is a response for ProjectsDeleteColumn

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
type ProjectsDeleteColumnResponse struct {
	common.Response
	request *ProjectsDeleteColumnReq
}

/*
ProjectsGet performs requests for "projects/get"

Get a project.

  GET /projects/{project_id}

https://developer.github.com/v3/projects/#get-a-project
*/
func ProjectsGet(ctx context.Context, req *ProjectsGetReq, opt ...options.Option) (*ProjectsGetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsGetReq)
	}
	resp := &ProjectsGetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsGet performs requests for "projects/get"

Get a project.

  GET /projects/{project_id}

https://developer.github.com/v3/projects/#get-a-project
*/
func (c Client) ProjectsGet(ctx context.Context, req *ProjectsGetReq, opt ...options.Option) (*ProjectsGetResponse, error) {
	return ProjectsGet(ctx, req, append(c, opt...)...)
}

/*
ProjectsGetReq is request data for Client.ProjectsGet

https://developer.github.com/v3/projects/#get-a-project
*/
type ProjectsGetReq struct {
	_url      string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsGetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsGetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "projects/get",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v", r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsGetReq) Rel(link RelName, resp *ProjectsGetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsGetResponse is a response for ProjectsGet

https://developer.github.com/v3/projects/#get-a-project
*/
type ProjectsGetResponse struct {
	common.Response
	request *ProjectsGetReq
	Data    components.Project
}

/*
ProjectsGetCard performs requests for "projects/get-card"

Get a project card.

  GET /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
func ProjectsGetCard(ctx context.Context, req *ProjectsGetCardReq, opt ...options.Option) (*ProjectsGetCardResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsGetCardReq)
	}
	resp := &ProjectsGetCardResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProjectCard{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsGetCard performs requests for "projects/get-card"

Get a project card.

  GET /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
func (c Client) ProjectsGetCard(ctx context.Context, req *ProjectsGetCardReq, opt ...options.Option) (*ProjectsGetCardResponse, error) {
	return ProjectsGetCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsGetCardReq is request data for Client.ProjectsGetCard

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
type ProjectsGetCardReq struct {
	_url string

	// card_id parameter
	CardId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsGetCardReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsGetCardReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "projects/get-card",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/cards/%v", r.CardId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsGetCardReq) Rel(link RelName, resp *ProjectsGetCardResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsGetCardResponse is a response for ProjectsGetCard

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
type ProjectsGetCardResponse struct {
	common.Response
	request *ProjectsGetCardReq
	Data    components.ProjectCard
}

/*
ProjectsGetColumn performs requests for "projects/get-column"

Get a project column.

  GET /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
func ProjectsGetColumn(ctx context.Context, req *ProjectsGetColumnReq, opt ...options.Option) (*ProjectsGetColumnResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsGetColumnReq)
	}
	resp := &ProjectsGetColumnResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProjectColumn{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsGetColumn performs requests for "projects/get-column"

Get a project column.

  GET /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
func (c Client) ProjectsGetColumn(ctx context.Context, req *ProjectsGetColumnReq, opt ...options.Option) (*ProjectsGetColumnResponse, error) {
	return ProjectsGetColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsGetColumnReq is request data for Client.ProjectsGetColumn

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
type ProjectsGetColumnReq struct {
	_url string

	// column_id parameter
	ColumnId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsGetColumnReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsGetColumnReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "projects/get-column",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/%v", r.ColumnId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsGetColumnReq) Rel(link RelName, resp *ProjectsGetColumnResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsGetColumnResponse is a response for ProjectsGetColumn

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
type ProjectsGetColumnResponse struct {
	common.Response
	request *ProjectsGetColumnReq
	Data    components.ProjectColumn
}

/*
ProjectsGetPermissionForUser performs requests for "projects/get-permission-for-user"

Get project permission for a user.

  GET /projects/{project_id}/collaborators/{username}/permission

https://developer.github.com/v3/projects/collaborators/#get-project-permission-for-a-user
*/
func ProjectsGetPermissionForUser(ctx context.Context, req *ProjectsGetPermissionForUserReq, opt ...options.Option) (*ProjectsGetPermissionForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsGetPermissionForUserReq)
	}
	resp := &ProjectsGetPermissionForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.RepositoryCollaboratorPermission{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsGetPermissionForUser performs requests for "projects/get-permission-for-user"

Get project permission for a user.

  GET /projects/{project_id}/collaborators/{username}/permission

https://developer.github.com/v3/projects/collaborators/#get-project-permission-for-a-user
*/
func (c Client) ProjectsGetPermissionForUser(ctx context.Context, req *ProjectsGetPermissionForUserReq, opt ...options.Option) (*ProjectsGetPermissionForUserResponse, error) {
	return ProjectsGetPermissionForUser(ctx, req, append(c, opt...)...)
}

/*
ProjectsGetPermissionForUserReq is request data for Client.ProjectsGetPermissionForUser

https://developer.github.com/v3/projects/collaborators/#get-project-permission-for-a-user
*/
type ProjectsGetPermissionForUserReq struct {
	_url      string
	ProjectId int64
	Username  string

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsGetPermissionForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsGetPermissionForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "projects/get-permission-for-user",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v/collaborators/%v/permission", r.ProjectId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsGetPermissionForUserReq) Rel(link RelName, resp *ProjectsGetPermissionForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsGetPermissionForUserResponse is a response for ProjectsGetPermissionForUser

https://developer.github.com/v3/projects/collaborators/#get-project-permission-for-a-user
*/
type ProjectsGetPermissionForUserResponse struct {
	common.Response
	request *ProjectsGetPermissionForUserReq
	Data    components.RepositoryCollaboratorPermission
}

/*
ProjectsListCards performs requests for "projects/list-cards"

List project cards.

  GET /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
func ProjectsListCards(ctx context.Context, req *ProjectsListCardsReq, opt ...options.Option) (*ProjectsListCardsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsListCardsReq)
	}
	resp := &ProjectsListCardsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ProjectCard{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListCards performs requests for "projects/list-cards"

List project cards.

  GET /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
func (c Client) ProjectsListCards(ctx context.Context, req *ProjectsListCardsReq, opt ...options.Option) (*ProjectsListCardsResponse, error) {
	return ProjectsListCards(ctx, req, append(c, opt...)...)
}

/*
ProjectsListCardsReq is request data for Client.ProjectsListCards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
type ProjectsListCardsReq struct {
	_url string

	// column_id parameter
	ColumnId int64

	/*
	Filters the project cards that are returned by the card's state. Can be one of
	`all`,`archived`, or `not_archived`.
	*/
	ArchivedState *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsListCardsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsListCardsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.ArchivedState != nil {
		query.Set("archived_state", *r.ArchivedState)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "projects/list-cards",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/%v/cards", r.ColumnId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListCardsReq) Rel(link RelName, resp *ProjectsListCardsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListCardsResponse is a response for ProjectsListCards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
type ProjectsListCardsResponse struct {
	common.Response
	request *ProjectsListCardsReq
	Data    []components.ProjectCard
}

/*
ProjectsListCollaborators performs requests for "projects/list-collaborators"

List project collaborators.

  GET /projects/{project_id}/collaborators

https://developer.github.com/v3/projects/collaborators/#list-project-collaborators
*/
func ProjectsListCollaborators(ctx context.Context, req *ProjectsListCollaboratorsReq, opt ...options.Option) (*ProjectsListCollaboratorsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsListCollaboratorsReq)
	}
	resp := &ProjectsListCollaboratorsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListCollaborators performs requests for "projects/list-collaborators"

List project collaborators.

  GET /projects/{project_id}/collaborators

https://developer.github.com/v3/projects/collaborators/#list-project-collaborators
*/
func (c Client) ProjectsListCollaborators(ctx context.Context, req *ProjectsListCollaboratorsReq, opt ...options.Option) (*ProjectsListCollaboratorsResponse, error) {
	return ProjectsListCollaborators(ctx, req, append(c, opt...)...)
}

/*
ProjectsListCollaboratorsReq is request data for Client.ProjectsListCollaborators

https://developer.github.com/v3/projects/collaborators/#list-project-collaborators
*/
type ProjectsListCollaboratorsReq struct {
	_url      string
	ProjectId int64

	/*
	Filters the collaborators by their affiliation. Can be one of:
	\* `outside`: Outside collaborators of a project that are not a member of the
	project's organization.
	\* `direct`: Collaborators with permissions to a project, regardless of
	organization membership status.
	\* `all`: All collaborators the authenticated user can see.
	*/
	Affiliation *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsListCollaboratorsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsListCollaboratorsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "projects/list-collaborators",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v/collaborators", r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListCollaboratorsReq) Rel(link RelName, resp *ProjectsListCollaboratorsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListCollaboratorsResponse is a response for ProjectsListCollaborators

https://developer.github.com/v3/projects/collaborators/#list-project-collaborators
*/
type ProjectsListCollaboratorsResponse struct {
	common.Response
	request *ProjectsListCollaboratorsReq
	Data    []components.SimpleUser
}

/*
ProjectsListColumns performs requests for "projects/list-columns"

List project columns.

  GET /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
func ProjectsListColumns(ctx context.Context, req *ProjectsListColumnsReq, opt ...options.Option) (*ProjectsListColumnsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsListColumnsReq)
	}
	resp := &ProjectsListColumnsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ProjectColumn{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListColumns performs requests for "projects/list-columns"

List project columns.

  GET /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
func (c Client) ProjectsListColumns(ctx context.Context, req *ProjectsListColumnsReq, opt ...options.Option) (*ProjectsListColumnsResponse, error) {
	return ProjectsListColumns(ctx, req, append(c, opt...)...)
}

/*
ProjectsListColumnsReq is request data for Client.ProjectsListColumns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
type ProjectsListColumnsReq struct {
	_url      string
	ProjectId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsListColumnsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsListColumnsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "projects/list-columns",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v/columns", r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListColumnsReq) Rel(link RelName, resp *ProjectsListColumnsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListColumnsResponse is a response for ProjectsListColumns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
type ProjectsListColumnsResponse struct {
	common.Response
	request *ProjectsListColumnsReq
	Data    []components.ProjectColumn
}

/*
ProjectsListForOrg performs requests for "projects/list-for-org"

List organization projects.

  GET /orgs/{org}/projects

https://developer.github.com/v3/projects/#list-organization-projects
*/
func ProjectsListForOrg(ctx context.Context, req *ProjectsListForOrgReq, opt ...options.Option) (*ProjectsListForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsListForOrgReq)
	}
	resp := &ProjectsListForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListForOrg performs requests for "projects/list-for-org"

List organization projects.

  GET /orgs/{org}/projects

https://developer.github.com/v3/projects/#list-organization-projects
*/
func (c Client) ProjectsListForOrg(ctx context.Context, req *ProjectsListForOrgReq, opt ...options.Option) (*ProjectsListForOrgResponse, error) {
	return ProjectsListForOrg(ctx, req, append(c, opt...)...)
}

/*
ProjectsListForOrgReq is request data for Client.ProjectsListForOrg

https://developer.github.com/v3/projects/#list-organization-projects
*/
type ProjectsListForOrgReq struct {
	_url string
	Org  string

	/*
	Indicates the state of the projects to return. Can be either `open`, `closed`,
	or `all`.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsListForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsListForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "projects/list-for-org",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/orgs/%v/projects", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListForOrgReq) Rel(link RelName, resp *ProjectsListForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListForOrgResponse is a response for ProjectsListForOrg

https://developer.github.com/v3/projects/#list-organization-projects
*/
type ProjectsListForOrgResponse struct {
	common.Response
	request *ProjectsListForOrgReq
	Data    []components.Project
}

/*
ProjectsListForRepo performs requests for "projects/list-for-repo"

List repository projects.

  GET /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#list-repository-projects
*/
func ProjectsListForRepo(ctx context.Context, req *ProjectsListForRepoReq, opt ...options.Option) (*ProjectsListForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsListForRepoReq)
	}
	resp := &ProjectsListForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListForRepo performs requests for "projects/list-for-repo"

List repository projects.

  GET /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#list-repository-projects
*/
func (c Client) ProjectsListForRepo(ctx context.Context, req *ProjectsListForRepoReq, opt ...options.Option) (*ProjectsListForRepoResponse, error) {
	return ProjectsListForRepo(ctx, req, append(c, opt...)...)
}

/*
ProjectsListForRepoReq is request data for Client.ProjectsListForRepo

https://developer.github.com/v3/projects/#list-repository-projects
*/
type ProjectsListForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Indicates the state of the projects to return. Can be either `open`, `closed`,
	or `all`.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsListForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsListForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "projects/list-for-repo",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/projects", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListForRepoReq) Rel(link RelName, resp *ProjectsListForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListForRepoResponse is a response for ProjectsListForRepo

https://developer.github.com/v3/projects/#list-repository-projects
*/
type ProjectsListForRepoResponse struct {
	common.Response
	request *ProjectsListForRepoReq
	Data    []components.Project
}

/*
ProjectsListForUser performs requests for "projects/list-for-user"

List user projects.

  GET /users/{username}/projects

https://developer.github.com/v3/projects/#list-user-projects
*/
func ProjectsListForUser(ctx context.Context, req *ProjectsListForUserReq, opt ...options.Option) (*ProjectsListForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsListForUserReq)
	}
	resp := &ProjectsListForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListForUser performs requests for "projects/list-for-user"

List user projects.

  GET /users/{username}/projects

https://developer.github.com/v3/projects/#list-user-projects
*/
func (c Client) ProjectsListForUser(ctx context.Context, req *ProjectsListForUserReq, opt ...options.Option) (*ProjectsListForUserResponse, error) {
	return ProjectsListForUser(ctx, req, append(c, opt...)...)
}

/*
ProjectsListForUserReq is request data for Client.ProjectsListForUser

https://developer.github.com/v3/projects/#list-user-projects
*/
type ProjectsListForUserReq struct {
	_url     string
	Username string

	/*
	Indicates the state of the projects to return. Can be either `open`, `closed`,
	or `all`.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsListForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsListForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "projects/list-for-user",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/users/%v/projects", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListForUserReq) Rel(link RelName, resp *ProjectsListForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListForUserResponse is a response for ProjectsListForUser

https://developer.github.com/v3/projects/#list-user-projects
*/
type ProjectsListForUserResponse struct {
	common.Response
	request *ProjectsListForUserReq
	Data    []components.Project
}

/*
ProjectsMoveCard performs requests for "projects/move-card"

Move a project card.

  POST /projects/columns/cards/{card_id}/moves

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
func ProjectsMoveCard(ctx context.Context, req *ProjectsMoveCardReq, opt ...options.Option) (*ProjectsMoveCardResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsMoveCardReq)
	}
	resp := &ProjectsMoveCardResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsMoveCard performs requests for "projects/move-card"

Move a project card.

  POST /projects/columns/cards/{card_id}/moves

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
func (c Client) ProjectsMoveCard(ctx context.Context, req *ProjectsMoveCardReq, opt ...options.Option) (*ProjectsMoveCardResponse, error) {
	return ProjectsMoveCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsMoveCardReq is request data for Client.ProjectsMoveCard

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
type ProjectsMoveCardReq struct {
	_url string

	// card_id parameter
	CardId      int64
	RequestBody ProjectsMoveCardReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsMoveCardReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsMoveCardReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/move-card",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/cards/%v/moves", r.CardId),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsMoveCardReq) Rel(link RelName, resp *ProjectsMoveCardResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsMoveCardReqBody is a request body for projects/move-card

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
type ProjectsMoveCardReqBody struct {

	// The unique identifier of the column the card should be moved to
	ColumnId *int64 `json:"column_id,omitempty"`

	// The position of the card in a column
	Position *string `json:"position"`
}

/*
ProjectsMoveCardResponse is a response for ProjectsMoveCard

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
type ProjectsMoveCardResponse struct {
	common.Response
	request *ProjectsMoveCardReq
}

/*
ProjectsMoveColumn performs requests for "projects/move-column"

Move a project column.

  POST /projects/columns/{column_id}/moves

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
func ProjectsMoveColumn(ctx context.Context, req *ProjectsMoveColumnReq, opt ...options.Option) (*ProjectsMoveColumnResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsMoveColumnReq)
	}
	resp := &ProjectsMoveColumnResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsMoveColumn performs requests for "projects/move-column"

Move a project column.

  POST /projects/columns/{column_id}/moves

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
func (c Client) ProjectsMoveColumn(ctx context.Context, req *ProjectsMoveColumnReq, opt ...options.Option) (*ProjectsMoveColumnResponse, error) {
	return ProjectsMoveColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsMoveColumnReq is request data for Client.ProjectsMoveColumn

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
type ProjectsMoveColumnReq struct {
	_url string

	// column_id parameter
	ColumnId    int64
	RequestBody ProjectsMoveColumnReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsMoveColumnReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsMoveColumnReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "projects/move-column",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/%v/moves", r.ColumnId),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsMoveColumnReq) Rel(link RelName, resp *ProjectsMoveColumnResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsMoveColumnReqBody is a request body for projects/move-column

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
type ProjectsMoveColumnReqBody struct {

	// The position of the column in a project
	Position *string `json:"position"`
}

/*
ProjectsMoveColumnResponse is a response for ProjectsMoveColumn

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
type ProjectsMoveColumnResponse struct {
	common.Response
	request *ProjectsMoveColumnReq
}

/*
ProjectsRemoveCollaborator performs requests for "projects/remove-collaborator"

Remove user as a collaborator.

  DELETE /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#remove-project-collaborator
*/
func ProjectsRemoveCollaborator(ctx context.Context, req *ProjectsRemoveCollaboratorReq, opt ...options.Option) (*ProjectsRemoveCollaboratorResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsRemoveCollaboratorReq)
	}
	resp := &ProjectsRemoveCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsRemoveCollaborator performs requests for "projects/remove-collaborator"

Remove user as a collaborator.

  DELETE /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#remove-project-collaborator
*/
func (c Client) ProjectsRemoveCollaborator(ctx context.Context, req *ProjectsRemoveCollaboratorReq, opt ...options.Option) (*ProjectsRemoveCollaboratorResponse, error) {
	return ProjectsRemoveCollaborator(ctx, req, append(c, opt...)...)
}

/*
ProjectsRemoveCollaboratorReq is request data for Client.ProjectsRemoveCollaborator

https://developer.github.com/v3/projects/collaborators/#remove-project-collaborator
*/
type ProjectsRemoveCollaboratorReq struct {
	_url      string
	ProjectId int64
	Username  string

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsRemoveCollaboratorReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsRemoveCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "projects/remove-collaborator",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v/collaborators/%v", r.ProjectId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsRemoveCollaboratorReq) Rel(link RelName, resp *ProjectsRemoveCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsRemoveCollaboratorResponse is a response for ProjectsRemoveCollaborator

https://developer.github.com/v3/projects/collaborators/#remove-project-collaborator
*/
type ProjectsRemoveCollaboratorResponse struct {
	common.Response
	request *ProjectsRemoveCollaboratorReq
}

/*
ProjectsUpdate performs requests for "projects/update"

Update a project.

  PATCH /projects/{project_id}

https://developer.github.com/v3/projects/#update-a-project
*/
func ProjectsUpdate(ctx context.Context, req *ProjectsUpdateReq, opt ...options.Option) (*ProjectsUpdateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsUpdateReq)
	}
	resp := &ProjectsUpdateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Project{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsUpdate performs requests for "projects/update"

Update a project.

  PATCH /projects/{project_id}

https://developer.github.com/v3/projects/#update-a-project
*/
func (c Client) ProjectsUpdate(ctx context.Context, req *ProjectsUpdateReq, opt ...options.Option) (*ProjectsUpdateResponse, error) {
	return ProjectsUpdate(ctx, req, append(c, opt...)...)
}

/*
ProjectsUpdateReq is request data for Client.ProjectsUpdate

https://developer.github.com/v3/projects/#update-a-project
*/
type ProjectsUpdateReq struct {
	_url        string
	ProjectId   int64
	RequestBody ProjectsUpdateReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsUpdateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsUpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "projects/update",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/%v", r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsUpdateReq) Rel(link RelName, resp *ProjectsUpdateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsUpdateReqBody is a request body for projects/update

https://developer.github.com/v3/projects/#update-a-project
*/
type ProjectsUpdateReqBody struct {

	// Body of the project
	Body *string `json:"body,omitempty"`

	// Name of the project
	Name *string `json:"name,omitempty"`

	// The baseline permission that all organization members have on this project
	OrganizationPermission *string `json:"organization_permission,omitempty"`

	// Whether or not this project can be seen by everyone.
	Private *bool `json:"private,omitempty"`

	// State of the project; either 'open' or 'closed'
	State *string `json:"state,omitempty"`
}

/*
ProjectsUpdateResponse is a response for ProjectsUpdate

https://developer.github.com/v3/projects/#update-a-project
*/
type ProjectsUpdateResponse struct {
	common.Response
	request *ProjectsUpdateReq
	Data    components.Project
}

/*
ProjectsUpdateCard performs requests for "projects/update-card"

Update an existing project card.

  PATCH /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
func ProjectsUpdateCard(ctx context.Context, req *ProjectsUpdateCardReq, opt ...options.Option) (*ProjectsUpdateCardResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsUpdateCardReq)
	}
	resp := &ProjectsUpdateCardResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProjectCard{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsUpdateCard performs requests for "projects/update-card"

Update an existing project card.

  PATCH /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
func (c Client) ProjectsUpdateCard(ctx context.Context, req *ProjectsUpdateCardReq, opt ...options.Option) (*ProjectsUpdateCardResponse, error) {
	return ProjectsUpdateCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsUpdateCardReq is request data for Client.ProjectsUpdateCard

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
type ProjectsUpdateCardReq struct {
	_url string

	// card_id parameter
	CardId      int64
	RequestBody ProjectsUpdateCardReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsUpdateCardReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsUpdateCardReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "projects/update-card",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/cards/%v", r.CardId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsUpdateCardReq) Rel(link RelName, resp *ProjectsUpdateCardResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsUpdateCardReqBody is a request body for projects/update-card

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
type ProjectsUpdateCardReqBody struct {

	// Whether or not the card is archived
	Archived *bool `json:"archived,omitempty"`

	// The project card's note
	Note *string `json:"note,omitempty"`
}

/*
ProjectsUpdateCardResponse is a response for ProjectsUpdateCard

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
type ProjectsUpdateCardResponse struct {
	common.Response
	request *ProjectsUpdateCardReq
	Data    components.ProjectCard
}

/*
ProjectsUpdateColumn performs requests for "projects/update-column"

Update an existing project column.

  PATCH /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
func ProjectsUpdateColumn(ctx context.Context, req *ProjectsUpdateColumnReq, opt ...options.Option) (*ProjectsUpdateColumnResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ProjectsUpdateColumnReq)
	}
	resp := &ProjectsUpdateColumnResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ProjectColumn{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsUpdateColumn performs requests for "projects/update-column"

Update an existing project column.

  PATCH /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
func (c Client) ProjectsUpdateColumn(ctx context.Context, req *ProjectsUpdateColumnReq, opt ...options.Option) (*ProjectsUpdateColumnResponse, error) {
	return ProjectsUpdateColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsUpdateColumnReq is request data for Client.ProjectsUpdateColumn

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
type ProjectsUpdateColumnReq struct {
	_url string

	// column_id parameter
	ColumnId    int64
	RequestBody ProjectsUpdateColumnReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *ProjectsUpdateColumnReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ProjectsUpdateColumnReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"inertia"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "projects/update-column",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/projects/columns/%v", r.ColumnId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsUpdateColumnReq) Rel(link RelName, resp *ProjectsUpdateColumnResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsUpdateColumnReqBody is a request body for projects/update-column

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
type ProjectsUpdateColumnReqBody struct {

	// Name of the project column
	Name *string `json:"name"`
}

/*
ProjectsUpdateColumnResponse is a response for ProjectsUpdateColumn

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
type ProjectsUpdateColumnResponse struct {
	common.Response
	request *ProjectsUpdateColumnReq
	Data    components.ProjectColumn
}
