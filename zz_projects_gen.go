// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
ProjectsAddCollaborator performs requests for "projects/add-collaborator"

Add project collaborator.

  PUT /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
func ProjectsAddCollaborator(ctx context.Context, req *ProjectsAddCollaboratorReq, opt ...RequestOption) (*ProjectsAddCollaboratorResponse, error) {
	if req == nil {
		req = new(ProjectsAddCollaboratorReq)
	}
	resp := &ProjectsAddCollaboratorResponse{request: req}
	r, err := doRequest(ctx, req, "projects/add-collaborator", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "projects/add-collaborator")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsAddCollaborator performs requests for "projects/add-collaborator"

Add project collaborator.

  PUT /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
func (c Client) ProjectsAddCollaborator(ctx context.Context, req *ProjectsAddCollaboratorReq, opt ...RequestOption) (*ProjectsAddCollaboratorResponse, error) {
	return ProjectsAddCollaborator(ctx, req, append(c, opt...)...)
}

/*
ProjectsAddCollaboratorReq is request data for Client.ProjectsAddCollaborator

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
type ProjectsAddCollaboratorReq struct {
	_url        string
	ProjectId   int64
	Username    string
	RequestBody ProjectsAddCollaboratorReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsAddCollaboratorReq) url() string {
	return r._url
}

func (r *ProjectsAddCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/projects/%v/collaborators/%v", r.ProjectId, r.Username)
}

func (r *ProjectsAddCollaboratorReq) method() string {
	return "PUT"
}

func (r *ProjectsAddCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsAddCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"content-type": String("application/json")}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsAddCollaboratorReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsAddCollaboratorReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsAddCollaboratorReq) validStatuses() []int {
	return []int{204, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsAddCollaboratorReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/add-collaborator", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsAddCollaboratorReq) Rel(link RelName, resp *ProjectsAddCollaboratorResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsAddCollaboratorReqBody is a request body for projects/add-collaborator

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
type ProjectsAddCollaboratorReqBody struct {

	// The permission to grant the collaborator.
	Permission *string `json:"permission,omitempty"`
}

/*
ProjectsAddCollaboratorResponse is a response for ProjectsAddCollaborator

https://developer.github.com/v3/projects/collaborators/#add-project-collaborator
*/
type ProjectsAddCollaboratorResponse struct {
	response
	request *ProjectsAddCollaboratorReq
}

/*
ProjectsCreateCard performs requests for "projects/create-card"

Create a project card.

  POST /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
func ProjectsCreateCard(ctx context.Context, req *ProjectsCreateCardReq, opt ...RequestOption) (*ProjectsCreateCardResponse, error) {
	if req == nil {
		req = new(ProjectsCreateCardReq)
	}
	resp := &ProjectsCreateCardResponse{request: req}
	r, err := doRequest(ctx, req, "projects/create-card", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.ProjectCard{}
	err = r.decodeBody(&resp.Data, "projects/create-card")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateCard performs requests for "projects/create-card"

Create a project card.

  POST /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
func (c Client) ProjectsCreateCard(ctx context.Context, req *ProjectsCreateCardReq, opt ...RequestOption) (*ProjectsCreateCardResponse, error) {
	return ProjectsCreateCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateCardReq is request data for Client.ProjectsCreateCard

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
type ProjectsCreateCardReq struct {
	_url string

	// column_id parameter
	ColumnId    int64
	RequestBody ProjectsCreateCardReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsCreateCardReq) url() string {
	return r._url
}

func (r *ProjectsCreateCardReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/%v/cards", r.ColumnId)
}

func (r *ProjectsCreateCardReq) method() string {
	return "POST"
}

func (r *ProjectsCreateCardReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsCreateCardReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsCreateCardReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsCreateCardReq) dataStatuses() []int {
	return []int{201}
}

func (r *ProjectsCreateCardReq) validStatuses() []int {
	return []int{201, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsCreateCardReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/create-card", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateCardReq) Rel(link RelName, resp *ProjectsCreateCardResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateCardReqBody is a request body for projects/create-card

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
type ProjectsCreateCardReqBody struct {

	// The unique identifier of the content associated with the card
	ContentId *int64 `json:"content_id"`

	// The piece of content associated with the card
	ContentType *string `json:"content_type"`
}

/*
ProjectsCreateCardResponse is a response for ProjectsCreateCard

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
type ProjectsCreateCardResponse struct {
	response
	request *ProjectsCreateCardReq
	Data    components.ProjectCard
}

/*
ProjectsCreateColumn performs requests for "projects/create-column"

Create a project column.

  POST /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
func ProjectsCreateColumn(ctx context.Context, req *ProjectsCreateColumnReq, opt ...RequestOption) (*ProjectsCreateColumnResponse, error) {
	if req == nil {
		req = new(ProjectsCreateColumnReq)
	}
	resp := &ProjectsCreateColumnResponse{request: req}
	r, err := doRequest(ctx, req, "projects/create-column", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.ProjectColumn{}
	err = r.decodeBody(&resp.Data, "projects/create-column")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateColumn performs requests for "projects/create-column"

Create a project column.

  POST /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
func (c Client) ProjectsCreateColumn(ctx context.Context, req *ProjectsCreateColumnReq, opt ...RequestOption) (*ProjectsCreateColumnResponse, error) {
	return ProjectsCreateColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateColumnReq is request data for Client.ProjectsCreateColumn

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
type ProjectsCreateColumnReq struct {
	_url        string
	ProjectId   int64
	RequestBody ProjectsCreateColumnReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsCreateColumnReq) url() string {
	return r._url
}

func (r *ProjectsCreateColumnReq) urlPath() string {
	return fmt.Sprintf("/projects/%v/columns", r.ProjectId)
}

func (r *ProjectsCreateColumnReq) method() string {
	return "POST"
}

func (r *ProjectsCreateColumnReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsCreateColumnReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsCreateColumnReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsCreateColumnReq) dataStatuses() []int {
	return []int{201}
}

func (r *ProjectsCreateColumnReq) validStatuses() []int {
	return []int{201, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsCreateColumnReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/create-column", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateColumnReq) Rel(link RelName, resp *ProjectsCreateColumnResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateColumnReqBody is a request body for projects/create-column

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
type ProjectsCreateColumnReqBody struct {

	// Name of the project column
	Name *string `json:"name"`
}

/*
ProjectsCreateColumnResponse is a response for ProjectsCreateColumn

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
type ProjectsCreateColumnResponse struct {
	response
	request *ProjectsCreateColumnReq
	Data    components.ProjectColumn
}

/*
ProjectsCreateForAuthenticatedUser performs requests for "projects/create-for-authenticated-user"

Create a user project.

  POST /user/projects

https://developer.github.com/v3/projects/#create-a-user-project
*/
func ProjectsCreateForAuthenticatedUser(ctx context.Context, req *ProjectsCreateForAuthenticatedUserReq, opt ...RequestOption) (*ProjectsCreateForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(ProjectsCreateForAuthenticatedUserReq)
	}
	resp := &ProjectsCreateForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, "projects/create-for-authenticated-user", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Project{}
	err = r.decodeBody(&resp.Data, "projects/create-for-authenticated-user")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateForAuthenticatedUser performs requests for "projects/create-for-authenticated-user"

Create a user project.

  POST /user/projects

https://developer.github.com/v3/projects/#create-a-user-project
*/
func (c Client) ProjectsCreateForAuthenticatedUser(ctx context.Context, req *ProjectsCreateForAuthenticatedUserReq, opt ...RequestOption) (*ProjectsCreateForAuthenticatedUserResponse, error) {
	return ProjectsCreateForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateForAuthenticatedUserReq is request data for Client.ProjectsCreateForAuthenticatedUser

https://developer.github.com/v3/projects/#create-a-user-project
*/
type ProjectsCreateForAuthenticatedUserReq struct {
	_url        string
	RequestBody ProjectsCreateForAuthenticatedUserReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsCreateForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *ProjectsCreateForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/projects")
}

func (r *ProjectsCreateForAuthenticatedUserReq) method() string {
	return "POST"
}

func (r *ProjectsCreateForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsCreateForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsCreateForAuthenticatedUserReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsCreateForAuthenticatedUserReq) dataStatuses() []int {
	return []int{201}
}

func (r *ProjectsCreateForAuthenticatedUserReq) validStatuses() []int {
	return []int{201, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsCreateForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/create-for-authenticated-user", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateForAuthenticatedUserReq) Rel(link RelName, resp *ProjectsCreateForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateForAuthenticatedUserReqBody is a request body for projects/create-for-authenticated-user

https://developer.github.com/v3/projects/#create-a-user-project
*/
type ProjectsCreateForAuthenticatedUserReqBody struct {

	// Body of the project
	Body *string `json:"body,omitempty"`

	// Name of the project
	Name *string `json:"name"`
}

/*
ProjectsCreateForAuthenticatedUserResponse is a response for ProjectsCreateForAuthenticatedUser

https://developer.github.com/v3/projects/#create-a-user-project
*/
type ProjectsCreateForAuthenticatedUserResponse struct {
	response
	request *ProjectsCreateForAuthenticatedUserReq
	Data    components.Project
}

/*
ProjectsCreateForOrg performs requests for "projects/create-for-org"

Create an organization project.

  POST /orgs/{org}/projects

https://developer.github.com/v3/projects/#create-an-organization-project
*/
func ProjectsCreateForOrg(ctx context.Context, req *ProjectsCreateForOrgReq, opt ...RequestOption) (*ProjectsCreateForOrgResponse, error) {
	if req == nil {
		req = new(ProjectsCreateForOrgReq)
	}
	resp := &ProjectsCreateForOrgResponse{request: req}
	r, err := doRequest(ctx, req, "projects/create-for-org", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Project{}
	err = r.decodeBody(&resp.Data, "projects/create-for-org")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateForOrg performs requests for "projects/create-for-org"

Create an organization project.

  POST /orgs/{org}/projects

https://developer.github.com/v3/projects/#create-an-organization-project
*/
func (c Client) ProjectsCreateForOrg(ctx context.Context, req *ProjectsCreateForOrgReq, opt ...RequestOption) (*ProjectsCreateForOrgResponse, error) {
	return ProjectsCreateForOrg(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateForOrgReq is request data for Client.ProjectsCreateForOrg

https://developer.github.com/v3/projects/#create-an-organization-project
*/
type ProjectsCreateForOrgReq struct {
	_url        string
	Org         string
	RequestBody ProjectsCreateForOrgReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsCreateForOrgReq) url() string {
	return r._url
}

func (r *ProjectsCreateForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/projects", r.Org)
}

func (r *ProjectsCreateForOrgReq) method() string {
	return "POST"
}

func (r *ProjectsCreateForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsCreateForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsCreateForOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsCreateForOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *ProjectsCreateForOrgReq) validStatuses() []int {
	return []int{201}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsCreateForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/create-for-org", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateForOrgReq) Rel(link RelName, resp *ProjectsCreateForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateForOrgReqBody is a request body for projects/create-for-org

https://developer.github.com/v3/projects/#create-an-organization-project
*/
type ProjectsCreateForOrgReqBody struct {

	// The description of the project.
	Body *string `json:"body,omitempty"`

	// The name of the project.
	Name *string `json:"name"`
}

/*
ProjectsCreateForOrgResponse is a response for ProjectsCreateForOrg

https://developer.github.com/v3/projects/#create-an-organization-project
*/
type ProjectsCreateForOrgResponse struct {
	response
	request *ProjectsCreateForOrgReq
	Data    components.Project
}

/*
ProjectsCreateForRepo performs requests for "projects/create-for-repo"

Create a repository project.

  POST /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#create-a-repository-project
*/
func ProjectsCreateForRepo(ctx context.Context, req *ProjectsCreateForRepoReq, opt ...RequestOption) (*ProjectsCreateForRepoResponse, error) {
	if req == nil {
		req = new(ProjectsCreateForRepoReq)
	}
	resp := &ProjectsCreateForRepoResponse{request: req}
	r, err := doRequest(ctx, req, "projects/create-for-repo", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Project{}
	err = r.decodeBody(&resp.Data, "projects/create-for-repo")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateForRepo performs requests for "projects/create-for-repo"

Create a repository project.

  POST /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#create-a-repository-project
*/
func (c Client) ProjectsCreateForRepo(ctx context.Context, req *ProjectsCreateForRepoReq, opt ...RequestOption) (*ProjectsCreateForRepoResponse, error) {
	return ProjectsCreateForRepo(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateForRepoReq is request data for Client.ProjectsCreateForRepo

https://developer.github.com/v3/projects/#create-a-repository-project
*/
type ProjectsCreateForRepoReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ProjectsCreateForRepoReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsCreateForRepoReq) url() string {
	return r._url
}

func (r *ProjectsCreateForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/projects", r.Owner, r.Repo)
}

func (r *ProjectsCreateForRepoReq) method() string {
	return "POST"
}

func (r *ProjectsCreateForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsCreateForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsCreateForRepoReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsCreateForRepoReq) dataStatuses() []int {
	return []int{201}
}

func (r *ProjectsCreateForRepoReq) validStatuses() []int {
	return []int{201}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsCreateForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/create-for-repo", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateForRepoReq) Rel(link RelName, resp *ProjectsCreateForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateForRepoReqBody is a request body for projects/create-for-repo

https://developer.github.com/v3/projects/#create-a-repository-project
*/
type ProjectsCreateForRepoReqBody struct {

	// The description of the project.
	Body *string `json:"body,omitempty"`

	// The name of the project.
	Name *string `json:"name"`
}

/*
ProjectsCreateForRepoResponse is a response for ProjectsCreateForRepo

https://developer.github.com/v3/projects/#create-a-repository-project
*/
type ProjectsCreateForRepoResponse struct {
	response
	request *ProjectsCreateForRepoReq
	Data    components.Project
}

/*
ProjectsDelete performs requests for "projects/delete"

Delete a project.

  DELETE /projects/{project_id}

https://developer.github.com/v3/projects/#delete-a-project
*/
func ProjectsDelete(ctx context.Context, req *ProjectsDeleteReq, opt ...RequestOption) (*ProjectsDeleteResponse, error) {
	if req == nil {
		req = new(ProjectsDeleteReq)
	}
	resp := &ProjectsDeleteResponse{request: req}
	r, err := doRequest(ctx, req, "projects/delete", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "projects/delete")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsDelete performs requests for "projects/delete"

Delete a project.

  DELETE /projects/{project_id}

https://developer.github.com/v3/projects/#delete-a-project
*/
func (c Client) ProjectsDelete(ctx context.Context, req *ProjectsDeleteReq, opt ...RequestOption) (*ProjectsDeleteResponse, error) {
	return ProjectsDelete(ctx, req, append(c, opt...)...)
}

/*
ProjectsDeleteReq is request data for Client.ProjectsDelete

https://developer.github.com/v3/projects/#delete-a-project
*/
type ProjectsDeleteReq struct {
	_url      string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsDeleteReq) url() string {
	return r._url
}

func (r *ProjectsDeleteReq) urlPath() string {
	return fmt.Sprintf("/projects/%v", r.ProjectId)
}

func (r *ProjectsDeleteReq) method() string {
	return "DELETE"
}

func (r *ProjectsDeleteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsDeleteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsDeleteReq) body() interface{} {
	return nil
}

func (r *ProjectsDeleteReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsDeleteReq) validStatuses() []int {
	return []int{204, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsDeleteReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/delete", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsDeleteReq) Rel(link RelName, resp *ProjectsDeleteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsDeleteResponse is a response for ProjectsDelete

https://developer.github.com/v3/projects/#delete-a-project
*/
type ProjectsDeleteResponse struct {
	response
	request *ProjectsDeleteReq
}

/*
ProjectsDeleteCard performs requests for "projects/delete-card"

Delete a project card.

  DELETE /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
func ProjectsDeleteCard(ctx context.Context, req *ProjectsDeleteCardReq, opt ...RequestOption) (*ProjectsDeleteCardResponse, error) {
	if req == nil {
		req = new(ProjectsDeleteCardReq)
	}
	resp := &ProjectsDeleteCardResponse{request: req}
	r, err := doRequest(ctx, req, "projects/delete-card", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "projects/delete-card")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsDeleteCard performs requests for "projects/delete-card"

Delete a project card.

  DELETE /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
func (c Client) ProjectsDeleteCard(ctx context.Context, req *ProjectsDeleteCardReq, opt ...RequestOption) (*ProjectsDeleteCardResponse, error) {
	return ProjectsDeleteCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsDeleteCardReq is request data for Client.ProjectsDeleteCard

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
type ProjectsDeleteCardReq struct {
	_url string

	// card_id parameter
	CardId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsDeleteCardReq) url() string {
	return r._url
}

func (r *ProjectsDeleteCardReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/cards/%v", r.CardId)
}

func (r *ProjectsDeleteCardReq) method() string {
	return "DELETE"
}

func (r *ProjectsDeleteCardReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsDeleteCardReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsDeleteCardReq) body() interface{} {
	return nil
}

func (r *ProjectsDeleteCardReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsDeleteCardReq) validStatuses() []int {
	return []int{204, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsDeleteCardReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/delete-card", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsDeleteCardReq) Rel(link RelName, resp *ProjectsDeleteCardResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsDeleteCardResponse is a response for ProjectsDeleteCard

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
type ProjectsDeleteCardResponse struct {
	response
	request *ProjectsDeleteCardReq
}

/*
ProjectsDeleteColumn performs requests for "projects/delete-column"

Delete a project column.

  DELETE /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
func ProjectsDeleteColumn(ctx context.Context, req *ProjectsDeleteColumnReq, opt ...RequestOption) (*ProjectsDeleteColumnResponse, error) {
	if req == nil {
		req = new(ProjectsDeleteColumnReq)
	}
	resp := &ProjectsDeleteColumnResponse{request: req}
	r, err := doRequest(ctx, req, "projects/delete-column", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "projects/delete-column")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsDeleteColumn performs requests for "projects/delete-column"

Delete a project column.

  DELETE /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
func (c Client) ProjectsDeleteColumn(ctx context.Context, req *ProjectsDeleteColumnReq, opt ...RequestOption) (*ProjectsDeleteColumnResponse, error) {
	return ProjectsDeleteColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsDeleteColumnReq is request data for Client.ProjectsDeleteColumn

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
type ProjectsDeleteColumnReq struct {
	_url string

	// column_id parameter
	ColumnId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsDeleteColumnReq) url() string {
	return r._url
}

func (r *ProjectsDeleteColumnReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/%v", r.ColumnId)
}

func (r *ProjectsDeleteColumnReq) method() string {
	return "DELETE"
}

func (r *ProjectsDeleteColumnReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsDeleteColumnReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsDeleteColumnReq) body() interface{} {
	return nil
}

func (r *ProjectsDeleteColumnReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsDeleteColumnReq) validStatuses() []int {
	return []int{204, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsDeleteColumnReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/delete-column", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsDeleteColumnReq) Rel(link RelName, resp *ProjectsDeleteColumnResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsDeleteColumnResponse is a response for ProjectsDeleteColumn

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
type ProjectsDeleteColumnResponse struct {
	response
	request *ProjectsDeleteColumnReq
}

/*
ProjectsGet performs requests for "projects/get"

Get a project.

  GET /projects/{project_id}

https://developer.github.com/v3/projects/#get-a-project
*/
func ProjectsGet(ctx context.Context, req *ProjectsGetReq, opt ...RequestOption) (*ProjectsGetResponse, error) {
	if req == nil {
		req = new(ProjectsGetReq)
	}
	resp := &ProjectsGetResponse{request: req}
	r, err := doRequest(ctx, req, "projects/get", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Project{}
	err = r.decodeBody(&resp.Data, "projects/get")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsGet performs requests for "projects/get"

Get a project.

  GET /projects/{project_id}

https://developer.github.com/v3/projects/#get-a-project
*/
func (c Client) ProjectsGet(ctx context.Context, req *ProjectsGetReq, opt ...RequestOption) (*ProjectsGetResponse, error) {
	return ProjectsGet(ctx, req, append(c, opt...)...)
}

/*
ProjectsGetReq is request data for Client.ProjectsGet

https://developer.github.com/v3/projects/#get-a-project
*/
type ProjectsGetReq struct {
	_url      string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsGetReq) url() string {
	return r._url
}

func (r *ProjectsGetReq) urlPath() string {
	return fmt.Sprintf("/projects/%v", r.ProjectId)
}

func (r *ProjectsGetReq) method() string {
	return "GET"
}

func (r *ProjectsGetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsGetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsGetReq) body() interface{} {
	return nil
}

func (r *ProjectsGetReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsGetReq) validStatuses() []int {
	return []int{200, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsGetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/get", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsGetReq) Rel(link RelName, resp *ProjectsGetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsGetResponse is a response for ProjectsGet

https://developer.github.com/v3/projects/#get-a-project
*/
type ProjectsGetResponse struct {
	response
	request *ProjectsGetReq
	Data    components.Project
}

/*
ProjectsGetCard performs requests for "projects/get-card"

Get a project card.

  GET /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
func ProjectsGetCard(ctx context.Context, req *ProjectsGetCardReq, opt ...RequestOption) (*ProjectsGetCardResponse, error) {
	if req == nil {
		req = new(ProjectsGetCardReq)
	}
	resp := &ProjectsGetCardResponse{request: req}
	r, err := doRequest(ctx, req, "projects/get-card", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.ProjectCard{}
	err = r.decodeBody(&resp.Data, "projects/get-card")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsGetCard performs requests for "projects/get-card"

Get a project card.

  GET /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
func (c Client) ProjectsGetCard(ctx context.Context, req *ProjectsGetCardReq, opt ...RequestOption) (*ProjectsGetCardResponse, error) {
	return ProjectsGetCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsGetCardReq is request data for Client.ProjectsGetCard

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
type ProjectsGetCardReq struct {
	_url string

	// card_id parameter
	CardId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsGetCardReq) url() string {
	return r._url
}

func (r *ProjectsGetCardReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/cards/%v", r.CardId)
}

func (r *ProjectsGetCardReq) method() string {
	return "GET"
}

func (r *ProjectsGetCardReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsGetCardReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsGetCardReq) body() interface{} {
	return nil
}

func (r *ProjectsGetCardReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsGetCardReq) validStatuses() []int {
	return []int{200, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsGetCardReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/get-card", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsGetCardReq) Rel(link RelName, resp *ProjectsGetCardResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsGetCardResponse is a response for ProjectsGetCard

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
type ProjectsGetCardResponse struct {
	response
	request *ProjectsGetCardReq
	Data    components.ProjectCard
}

/*
ProjectsGetColumn performs requests for "projects/get-column"

Get a project column.

  GET /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
func ProjectsGetColumn(ctx context.Context, req *ProjectsGetColumnReq, opt ...RequestOption) (*ProjectsGetColumnResponse, error) {
	if req == nil {
		req = new(ProjectsGetColumnReq)
	}
	resp := &ProjectsGetColumnResponse{request: req}
	r, err := doRequest(ctx, req, "projects/get-column", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.ProjectColumn{}
	err = r.decodeBody(&resp.Data, "projects/get-column")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsGetColumn performs requests for "projects/get-column"

Get a project column.

  GET /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
func (c Client) ProjectsGetColumn(ctx context.Context, req *ProjectsGetColumnReq, opt ...RequestOption) (*ProjectsGetColumnResponse, error) {
	return ProjectsGetColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsGetColumnReq is request data for Client.ProjectsGetColumn

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
type ProjectsGetColumnReq struct {
	_url string

	// column_id parameter
	ColumnId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsGetColumnReq) url() string {
	return r._url
}

func (r *ProjectsGetColumnReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/%v", r.ColumnId)
}

func (r *ProjectsGetColumnReq) method() string {
	return "GET"
}

func (r *ProjectsGetColumnReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsGetColumnReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsGetColumnReq) body() interface{} {
	return nil
}

func (r *ProjectsGetColumnReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsGetColumnReq) validStatuses() []int {
	return []int{200, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsGetColumnReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/get-column", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsGetColumnReq) Rel(link RelName, resp *ProjectsGetColumnResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsGetColumnResponse is a response for ProjectsGetColumn

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
type ProjectsGetColumnResponse struct {
	response
	request *ProjectsGetColumnReq
	Data    components.ProjectColumn
}

/*
ProjectsGetPermissionForUser performs requests for "projects/get-permission-for-user"

Get project permission for a user.

  GET /projects/{project_id}/collaborators/{username}/permission

https://developer.github.com/v3/projects/collaborators/#get-project-permission-for-a-user
*/
func ProjectsGetPermissionForUser(ctx context.Context, req *ProjectsGetPermissionForUserReq, opt ...RequestOption) (*ProjectsGetPermissionForUserResponse, error) {
	if req == nil {
		req = new(ProjectsGetPermissionForUserReq)
	}
	resp := &ProjectsGetPermissionForUserResponse{request: req}
	r, err := doRequest(ctx, req, "projects/get-permission-for-user", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.RepositoryCollaboratorPermission{}
	err = r.decodeBody(&resp.Data, "projects/get-permission-for-user")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsGetPermissionForUser performs requests for "projects/get-permission-for-user"

Get project permission for a user.

  GET /projects/{project_id}/collaborators/{username}/permission

https://developer.github.com/v3/projects/collaborators/#get-project-permission-for-a-user
*/
func (c Client) ProjectsGetPermissionForUser(ctx context.Context, req *ProjectsGetPermissionForUserReq, opt ...RequestOption) (*ProjectsGetPermissionForUserResponse, error) {
	return ProjectsGetPermissionForUser(ctx, req, append(c, opt...)...)
}

/*
ProjectsGetPermissionForUserReq is request data for Client.ProjectsGetPermissionForUser

https://developer.github.com/v3/projects/collaborators/#get-project-permission-for-a-user
*/
type ProjectsGetPermissionForUserReq struct {
	_url      string
	ProjectId int64
	Username  string

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsGetPermissionForUserReq) url() string {
	return r._url
}

func (r *ProjectsGetPermissionForUserReq) urlPath() string {
	return fmt.Sprintf("/projects/%v/collaborators/%v/permission", r.ProjectId, r.Username)
}

func (r *ProjectsGetPermissionForUserReq) method() string {
	return "GET"
}

func (r *ProjectsGetPermissionForUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsGetPermissionForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsGetPermissionForUserReq) body() interface{} {
	return nil
}

func (r *ProjectsGetPermissionForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsGetPermissionForUserReq) validStatuses() []int {
	return []int{200, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsGetPermissionForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/get-permission-for-user", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsGetPermissionForUserReq) Rel(link RelName, resp *ProjectsGetPermissionForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsGetPermissionForUserResponse is a response for ProjectsGetPermissionForUser

https://developer.github.com/v3/projects/collaborators/#get-project-permission-for-a-user
*/
type ProjectsGetPermissionForUserResponse struct {
	response
	request *ProjectsGetPermissionForUserReq
	Data    components.RepositoryCollaboratorPermission
}

/*
ProjectsListCards performs requests for "projects/list-cards"

List project cards.

  GET /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
func ProjectsListCards(ctx context.Context, req *ProjectsListCardsReq, opt ...RequestOption) (*ProjectsListCardsResponse, error) {
	if req == nil {
		req = new(ProjectsListCardsReq)
	}
	resp := &ProjectsListCardsResponse{request: req}
	r, err := doRequest(ctx, req, "projects/list-cards", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.ProjectCard{}
	err = r.decodeBody(&resp.Data, "projects/list-cards")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListCards performs requests for "projects/list-cards"

List project cards.

  GET /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
func (c Client) ProjectsListCards(ctx context.Context, req *ProjectsListCardsReq, opt ...RequestOption) (*ProjectsListCardsResponse, error) {
	return ProjectsListCards(ctx, req, append(c, opt...)...)
}

/*
ProjectsListCardsReq is request data for Client.ProjectsListCards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
type ProjectsListCardsReq struct {
	_url string

	// column_id parameter
	ColumnId int64

	/*
	Filters the project cards that are returned by the card's state. Can be one of
	`all`,`archived`, or `not_archived`.
	*/
	ArchivedState *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsListCardsReq) url() string {
	return r._url
}

func (r *ProjectsListCardsReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/%v/cards", r.ColumnId)
}

func (r *ProjectsListCardsReq) method() string {
	return "GET"
}

func (r *ProjectsListCardsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.ArchivedState != nil {
		query.Set("archived_state", *r.ArchivedState)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ProjectsListCardsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsListCardsReq) body() interface{} {
	return nil
}

func (r *ProjectsListCardsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsListCardsReq) validStatuses() []int {
	return []int{200, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsListCardsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/list-cards", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListCardsReq) Rel(link RelName, resp *ProjectsListCardsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListCardsResponse is a response for ProjectsListCards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
type ProjectsListCardsResponse struct {
	response
	request *ProjectsListCardsReq
	Data    []components.ProjectCard
}

/*
ProjectsListCollaborators performs requests for "projects/list-collaborators"

List project collaborators.

  GET /projects/{project_id}/collaborators

https://developer.github.com/v3/projects/collaborators/#list-project-collaborators
*/
func ProjectsListCollaborators(ctx context.Context, req *ProjectsListCollaboratorsReq, opt ...RequestOption) (*ProjectsListCollaboratorsResponse, error) {
	if req == nil {
		req = new(ProjectsListCollaboratorsReq)
	}
	resp := &ProjectsListCollaboratorsResponse{request: req}
	r, err := doRequest(ctx, req, "projects/list-collaborators", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.SimpleUser{}
	err = r.decodeBody(&resp.Data, "projects/list-collaborators")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListCollaborators performs requests for "projects/list-collaborators"

List project collaborators.

  GET /projects/{project_id}/collaborators

https://developer.github.com/v3/projects/collaborators/#list-project-collaborators
*/
func (c Client) ProjectsListCollaborators(ctx context.Context, req *ProjectsListCollaboratorsReq, opt ...RequestOption) (*ProjectsListCollaboratorsResponse, error) {
	return ProjectsListCollaborators(ctx, req, append(c, opt...)...)
}

/*
ProjectsListCollaboratorsReq is request data for Client.ProjectsListCollaborators

https://developer.github.com/v3/projects/collaborators/#list-project-collaborators
*/
type ProjectsListCollaboratorsReq struct {
	_url      string
	ProjectId int64

	/*
	Filters the collaborators by their affiliation. Can be one of:
	\* `outside`: Outside collaborators of a project that are not a member of the
	project's organization.
	\* `direct`: Collaborators with permissions to a project, regardless of
	organization membership status.
	\* `all`: All collaborators the authenticated user can see.
	*/
	Affiliation *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsListCollaboratorsReq) url() string {
	return r._url
}

func (r *ProjectsListCollaboratorsReq) urlPath() string {
	return fmt.Sprintf("/projects/%v/collaborators", r.ProjectId)
}

func (r *ProjectsListCollaboratorsReq) method() string {
	return "GET"
}

func (r *ProjectsListCollaboratorsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ProjectsListCollaboratorsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsListCollaboratorsReq) body() interface{} {
	return nil
}

func (r *ProjectsListCollaboratorsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsListCollaboratorsReq) validStatuses() []int {
	return []int{200, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsListCollaboratorsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/list-collaborators", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListCollaboratorsReq) Rel(link RelName, resp *ProjectsListCollaboratorsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListCollaboratorsResponse is a response for ProjectsListCollaborators

https://developer.github.com/v3/projects/collaborators/#list-project-collaborators
*/
type ProjectsListCollaboratorsResponse struct {
	response
	request *ProjectsListCollaboratorsReq
	Data    []components.SimpleUser
}

/*
ProjectsListColumns performs requests for "projects/list-columns"

List project columns.

  GET /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
func ProjectsListColumns(ctx context.Context, req *ProjectsListColumnsReq, opt ...RequestOption) (*ProjectsListColumnsResponse, error) {
	if req == nil {
		req = new(ProjectsListColumnsReq)
	}
	resp := &ProjectsListColumnsResponse{request: req}
	r, err := doRequest(ctx, req, "projects/list-columns", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.ProjectColumn{}
	err = r.decodeBody(&resp.Data, "projects/list-columns")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListColumns performs requests for "projects/list-columns"

List project columns.

  GET /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
func (c Client) ProjectsListColumns(ctx context.Context, req *ProjectsListColumnsReq, opt ...RequestOption) (*ProjectsListColumnsResponse, error) {
	return ProjectsListColumns(ctx, req, append(c, opt...)...)
}

/*
ProjectsListColumnsReq is request data for Client.ProjectsListColumns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
type ProjectsListColumnsReq struct {
	_url      string
	ProjectId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsListColumnsReq) url() string {
	return r._url
}

func (r *ProjectsListColumnsReq) urlPath() string {
	return fmt.Sprintf("/projects/%v/columns", r.ProjectId)
}

func (r *ProjectsListColumnsReq) method() string {
	return "GET"
}

func (r *ProjectsListColumnsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ProjectsListColumnsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsListColumnsReq) body() interface{} {
	return nil
}

func (r *ProjectsListColumnsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsListColumnsReq) validStatuses() []int {
	return []int{200, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsListColumnsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/list-columns", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListColumnsReq) Rel(link RelName, resp *ProjectsListColumnsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListColumnsResponse is a response for ProjectsListColumns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
type ProjectsListColumnsResponse struct {
	response
	request *ProjectsListColumnsReq
	Data    []components.ProjectColumn
}

/*
ProjectsListForOrg performs requests for "projects/list-for-org"

List organization projects.

  GET /orgs/{org}/projects

https://developer.github.com/v3/projects/#list-organization-projects
*/
func ProjectsListForOrg(ctx context.Context, req *ProjectsListForOrgReq, opt ...RequestOption) (*ProjectsListForOrgResponse, error) {
	if req == nil {
		req = new(ProjectsListForOrgReq)
	}
	resp := &ProjectsListForOrgResponse{request: req}
	r, err := doRequest(ctx, req, "projects/list-for-org", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.Project{}
	err = r.decodeBody(&resp.Data, "projects/list-for-org")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListForOrg performs requests for "projects/list-for-org"

List organization projects.

  GET /orgs/{org}/projects

https://developer.github.com/v3/projects/#list-organization-projects
*/
func (c Client) ProjectsListForOrg(ctx context.Context, req *ProjectsListForOrgReq, opt ...RequestOption) (*ProjectsListForOrgResponse, error) {
	return ProjectsListForOrg(ctx, req, append(c, opt...)...)
}

/*
ProjectsListForOrgReq is request data for Client.ProjectsListForOrg

https://developer.github.com/v3/projects/#list-organization-projects
*/
type ProjectsListForOrgReq struct {
	_url string
	Org  string

	/*
	Indicates the state of the projects to return. Can be either `open`, `closed`,
	or `all`.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsListForOrgReq) url() string {
	return r._url
}

func (r *ProjectsListForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/projects", r.Org)
}

func (r *ProjectsListForOrgReq) method() string {
	return "GET"
}

func (r *ProjectsListForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ProjectsListForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsListForOrgReq) body() interface{} {
	return nil
}

func (r *ProjectsListForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsListForOrgReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsListForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/list-for-org", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListForOrgReq) Rel(link RelName, resp *ProjectsListForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListForOrgResponse is a response for ProjectsListForOrg

https://developer.github.com/v3/projects/#list-organization-projects
*/
type ProjectsListForOrgResponse struct {
	response
	request *ProjectsListForOrgReq
	Data    []components.Project
}

/*
ProjectsListForRepo performs requests for "projects/list-for-repo"

List repository projects.

  GET /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#list-repository-projects
*/
func ProjectsListForRepo(ctx context.Context, req *ProjectsListForRepoReq, opt ...RequestOption) (*ProjectsListForRepoResponse, error) {
	if req == nil {
		req = new(ProjectsListForRepoReq)
	}
	resp := &ProjectsListForRepoResponse{request: req}
	r, err := doRequest(ctx, req, "projects/list-for-repo", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.Project{}
	err = r.decodeBody(&resp.Data, "projects/list-for-repo")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListForRepo performs requests for "projects/list-for-repo"

List repository projects.

  GET /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#list-repository-projects
*/
func (c Client) ProjectsListForRepo(ctx context.Context, req *ProjectsListForRepoReq, opt ...RequestOption) (*ProjectsListForRepoResponse, error) {
	return ProjectsListForRepo(ctx, req, append(c, opt...)...)
}

/*
ProjectsListForRepoReq is request data for Client.ProjectsListForRepo

https://developer.github.com/v3/projects/#list-repository-projects
*/
type ProjectsListForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Indicates the state of the projects to return. Can be either `open`, `closed`,
	or `all`.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsListForRepoReq) url() string {
	return r._url
}

func (r *ProjectsListForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/projects", r.Owner, r.Repo)
}

func (r *ProjectsListForRepoReq) method() string {
	return "GET"
}

func (r *ProjectsListForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ProjectsListForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsListForRepoReq) body() interface{} {
	return nil
}

func (r *ProjectsListForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsListForRepoReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsListForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/list-for-repo", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListForRepoReq) Rel(link RelName, resp *ProjectsListForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListForRepoResponse is a response for ProjectsListForRepo

https://developer.github.com/v3/projects/#list-repository-projects
*/
type ProjectsListForRepoResponse struct {
	response
	request *ProjectsListForRepoReq
	Data    []components.Project
}

/*
ProjectsListForUser performs requests for "projects/list-for-user"

List user projects.

  GET /users/{username}/projects

https://developer.github.com/v3/projects/#list-user-projects
*/
func ProjectsListForUser(ctx context.Context, req *ProjectsListForUserReq, opt ...RequestOption) (*ProjectsListForUserResponse, error) {
	if req == nil {
		req = new(ProjectsListForUserReq)
	}
	resp := &ProjectsListForUserResponse{request: req}
	r, err := doRequest(ctx, req, "projects/list-for-user", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.Project{}
	err = r.decodeBody(&resp.Data, "projects/list-for-user")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListForUser performs requests for "projects/list-for-user"

List user projects.

  GET /users/{username}/projects

https://developer.github.com/v3/projects/#list-user-projects
*/
func (c Client) ProjectsListForUser(ctx context.Context, req *ProjectsListForUserReq, opt ...RequestOption) (*ProjectsListForUserResponse, error) {
	return ProjectsListForUser(ctx, req, append(c, opt...)...)
}

/*
ProjectsListForUserReq is request data for Client.ProjectsListForUser

https://developer.github.com/v3/projects/#list-user-projects
*/
type ProjectsListForUserReq struct {
	_url     string
	Username string

	/*
	Indicates the state of the projects to return. Can be either `open`, `closed`,
	or `all`.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsListForUserReq) url() string {
	return r._url
}

func (r *ProjectsListForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/projects", r.Username)
}

func (r *ProjectsListForUserReq) method() string {
	return "GET"
}

func (r *ProjectsListForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ProjectsListForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsListForUserReq) body() interface{} {
	return nil
}

func (r *ProjectsListForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsListForUserReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsListForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/list-for-user", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListForUserReq) Rel(link RelName, resp *ProjectsListForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListForUserResponse is a response for ProjectsListForUser

https://developer.github.com/v3/projects/#list-user-projects
*/
type ProjectsListForUserResponse struct {
	response
	request *ProjectsListForUserReq
	Data    []components.Project
}

/*
ProjectsMoveCard performs requests for "projects/move-card"

Move a project card.

  POST /projects/columns/cards/{card_id}/moves

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
func ProjectsMoveCard(ctx context.Context, req *ProjectsMoveCardReq, opt ...RequestOption) (*ProjectsMoveCardResponse, error) {
	if req == nil {
		req = new(ProjectsMoveCardReq)
	}
	resp := &ProjectsMoveCardResponse{request: req}
	r, err := doRequest(ctx, req, "projects/move-card", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "projects/move-card")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsMoveCard performs requests for "projects/move-card"

Move a project card.

  POST /projects/columns/cards/{card_id}/moves

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
func (c Client) ProjectsMoveCard(ctx context.Context, req *ProjectsMoveCardReq, opt ...RequestOption) (*ProjectsMoveCardResponse, error) {
	return ProjectsMoveCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsMoveCardReq is request data for Client.ProjectsMoveCard

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
type ProjectsMoveCardReq struct {
	_url string

	// card_id parameter
	CardId      int64
	RequestBody ProjectsMoveCardReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsMoveCardReq) url() string {
	return r._url
}

func (r *ProjectsMoveCardReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/cards/%v/moves", r.CardId)
}

func (r *ProjectsMoveCardReq) method() string {
	return "POST"
}

func (r *ProjectsMoveCardReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsMoveCardReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsMoveCardReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsMoveCardReq) dataStatuses() []int {
	return []int{201}
}

func (r *ProjectsMoveCardReq) validStatuses() []int {
	return []int{201, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsMoveCardReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/move-card", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsMoveCardReq) Rel(link RelName, resp *ProjectsMoveCardResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsMoveCardReqBody is a request body for projects/move-card

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
type ProjectsMoveCardReqBody struct {

	// The unique identifier of the column the card should be moved to
	ColumnId *int64 `json:"column_id,omitempty"`

	// The position of the card in a column
	Position *string `json:"position"`
}

/*
ProjectsMoveCardResponse is a response for ProjectsMoveCard

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
type ProjectsMoveCardResponse struct {
	response
	request *ProjectsMoveCardReq
}

/*
ProjectsMoveColumn performs requests for "projects/move-column"

Move a project column.

  POST /projects/columns/{column_id}/moves

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
func ProjectsMoveColumn(ctx context.Context, req *ProjectsMoveColumnReq, opt ...RequestOption) (*ProjectsMoveColumnResponse, error) {
	if req == nil {
		req = new(ProjectsMoveColumnReq)
	}
	resp := &ProjectsMoveColumnResponse{request: req}
	r, err := doRequest(ctx, req, "projects/move-column", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "projects/move-column")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsMoveColumn performs requests for "projects/move-column"

Move a project column.

  POST /projects/columns/{column_id}/moves

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
func (c Client) ProjectsMoveColumn(ctx context.Context, req *ProjectsMoveColumnReq, opt ...RequestOption) (*ProjectsMoveColumnResponse, error) {
	return ProjectsMoveColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsMoveColumnReq is request data for Client.ProjectsMoveColumn

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
type ProjectsMoveColumnReq struct {
	_url string

	// column_id parameter
	ColumnId    int64
	RequestBody ProjectsMoveColumnReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsMoveColumnReq) url() string {
	return r._url
}

func (r *ProjectsMoveColumnReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/%v/moves", r.ColumnId)
}

func (r *ProjectsMoveColumnReq) method() string {
	return "POST"
}

func (r *ProjectsMoveColumnReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsMoveColumnReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsMoveColumnReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsMoveColumnReq) dataStatuses() []int {
	return []int{201}
}

func (r *ProjectsMoveColumnReq) validStatuses() []int {
	return []int{201, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsMoveColumnReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/move-column", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsMoveColumnReq) Rel(link RelName, resp *ProjectsMoveColumnResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsMoveColumnReqBody is a request body for projects/move-column

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
type ProjectsMoveColumnReqBody struct {

	// The position of the column in a project
	Position *string `json:"position"`
}

/*
ProjectsMoveColumnResponse is a response for ProjectsMoveColumn

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
type ProjectsMoveColumnResponse struct {
	response
	request *ProjectsMoveColumnReq
}

/*
ProjectsRemoveCollaborator performs requests for "projects/remove-collaborator"

Remove user as a collaborator.

  DELETE /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#remove-project-collaborator
*/
func ProjectsRemoveCollaborator(ctx context.Context, req *ProjectsRemoveCollaboratorReq, opt ...RequestOption) (*ProjectsRemoveCollaboratorResponse, error) {
	if req == nil {
		req = new(ProjectsRemoveCollaboratorReq)
	}
	resp := &ProjectsRemoveCollaboratorResponse{request: req}
	r, err := doRequest(ctx, req, "projects/remove-collaborator", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "projects/remove-collaborator")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsRemoveCollaborator performs requests for "projects/remove-collaborator"

Remove user as a collaborator.

  DELETE /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#remove-project-collaborator
*/
func (c Client) ProjectsRemoveCollaborator(ctx context.Context, req *ProjectsRemoveCollaboratorReq, opt ...RequestOption) (*ProjectsRemoveCollaboratorResponse, error) {
	return ProjectsRemoveCollaborator(ctx, req, append(c, opt...)...)
}

/*
ProjectsRemoveCollaboratorReq is request data for Client.ProjectsRemoveCollaborator

https://developer.github.com/v3/projects/collaborators/#remove-project-collaborator
*/
type ProjectsRemoveCollaboratorReq struct {
	_url      string
	ProjectId int64
	Username  string

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsRemoveCollaboratorReq) url() string {
	return r._url
}

func (r *ProjectsRemoveCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/projects/%v/collaborators/%v", r.ProjectId, r.Username)
}

func (r *ProjectsRemoveCollaboratorReq) method() string {
	return "DELETE"
}

func (r *ProjectsRemoveCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsRemoveCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsRemoveCollaboratorReq) body() interface{} {
	return nil
}

func (r *ProjectsRemoveCollaboratorReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsRemoveCollaboratorReq) validStatuses() []int {
	return []int{204, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsRemoveCollaboratorReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/remove-collaborator", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsRemoveCollaboratorReq) Rel(link RelName, resp *ProjectsRemoveCollaboratorResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsRemoveCollaboratorResponse is a response for ProjectsRemoveCollaborator

https://developer.github.com/v3/projects/collaborators/#remove-project-collaborator
*/
type ProjectsRemoveCollaboratorResponse struct {
	response
	request *ProjectsRemoveCollaboratorReq
}

/*
ProjectsUpdate performs requests for "projects/update"

Update a project.

  PATCH /projects/{project_id}

https://developer.github.com/v3/projects/#update-a-project
*/
func ProjectsUpdate(ctx context.Context, req *ProjectsUpdateReq, opt ...RequestOption) (*ProjectsUpdateResponse, error) {
	if req == nil {
		req = new(ProjectsUpdateReq)
	}
	resp := &ProjectsUpdateResponse{request: req}
	r, err := doRequest(ctx, req, "projects/update", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Project{}
	err = r.decodeBody(&resp.Data, "projects/update")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsUpdate performs requests for "projects/update"

Update a project.

  PATCH /projects/{project_id}

https://developer.github.com/v3/projects/#update-a-project
*/
func (c Client) ProjectsUpdate(ctx context.Context, req *ProjectsUpdateReq, opt ...RequestOption) (*ProjectsUpdateResponse, error) {
	return ProjectsUpdate(ctx, req, append(c, opt...)...)
}

/*
ProjectsUpdateReq is request data for Client.ProjectsUpdate

https://developer.github.com/v3/projects/#update-a-project
*/
type ProjectsUpdateReq struct {
	_url        string
	ProjectId   int64
	RequestBody ProjectsUpdateReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsUpdateReq) url() string {
	return r._url
}

func (r *ProjectsUpdateReq) urlPath() string {
	return fmt.Sprintf("/projects/%v", r.ProjectId)
}

func (r *ProjectsUpdateReq) method() string {
	return "PATCH"
}

func (r *ProjectsUpdateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsUpdateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsUpdateReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsUpdateReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsUpdateReq) validStatuses() []int {
	return []int{200, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsUpdateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/update", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsUpdateReq) Rel(link RelName, resp *ProjectsUpdateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsUpdateReqBody is a request body for projects/update

https://developer.github.com/v3/projects/#update-a-project
*/
type ProjectsUpdateReqBody struct {

	// Body of the project
	Body *string `json:"body,omitempty"`

	// Name of the project
	Name *string `json:"name,omitempty"`

	// The baseline permission that all organization members have on this project
	OrganizationPermission *string `json:"organization_permission,omitempty"`

	// Whether or not this project can be seen by everyone.
	Private *bool `json:"private,omitempty"`

	// State of the project; either 'open' or 'closed'
	State *string `json:"state,omitempty"`
}

/*
ProjectsUpdateResponse is a response for ProjectsUpdate

https://developer.github.com/v3/projects/#update-a-project
*/
type ProjectsUpdateResponse struct {
	response
	request *ProjectsUpdateReq
	Data    components.Project
}

/*
ProjectsUpdateCard performs requests for "projects/update-card"

Update an existing project card.

  PATCH /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
func ProjectsUpdateCard(ctx context.Context, req *ProjectsUpdateCardReq, opt ...RequestOption) (*ProjectsUpdateCardResponse, error) {
	if req == nil {
		req = new(ProjectsUpdateCardReq)
	}
	resp := &ProjectsUpdateCardResponse{request: req}
	r, err := doRequest(ctx, req, "projects/update-card", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.ProjectCard{}
	err = r.decodeBody(&resp.Data, "projects/update-card")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsUpdateCard performs requests for "projects/update-card"

Update an existing project card.

  PATCH /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
func (c Client) ProjectsUpdateCard(ctx context.Context, req *ProjectsUpdateCardReq, opt ...RequestOption) (*ProjectsUpdateCardResponse, error) {
	return ProjectsUpdateCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsUpdateCardReq is request data for Client.ProjectsUpdateCard

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
type ProjectsUpdateCardReq struct {
	_url string

	// card_id parameter
	CardId      int64
	RequestBody ProjectsUpdateCardReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsUpdateCardReq) url() string {
	return r._url
}

func (r *ProjectsUpdateCardReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/cards/%v", r.CardId)
}

func (r *ProjectsUpdateCardReq) method() string {
	return "PATCH"
}

func (r *ProjectsUpdateCardReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsUpdateCardReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsUpdateCardReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsUpdateCardReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsUpdateCardReq) validStatuses() []int {
	return []int{200, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsUpdateCardReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/update-card", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsUpdateCardReq) Rel(link RelName, resp *ProjectsUpdateCardResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsUpdateCardReqBody is a request body for projects/update-card

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
type ProjectsUpdateCardReqBody struct {

	// Whether or not the card is archived
	Archived *bool `json:"archived,omitempty"`

	// The project card's note
	Note *string `json:"note,omitempty"`
}

/*
ProjectsUpdateCardResponse is a response for ProjectsUpdateCard

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
type ProjectsUpdateCardResponse struct {
	response
	request *ProjectsUpdateCardReq
	Data    components.ProjectCard
}

/*
ProjectsUpdateColumn performs requests for "projects/update-column"

Update an existing project column.

  PATCH /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
func ProjectsUpdateColumn(ctx context.Context, req *ProjectsUpdateColumnReq, opt ...RequestOption) (*ProjectsUpdateColumnResponse, error) {
	if req == nil {
		req = new(ProjectsUpdateColumnReq)
	}
	resp := &ProjectsUpdateColumnResponse{request: req}
	r, err := doRequest(ctx, req, "projects/update-column", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.ProjectColumn{}
	err = r.decodeBody(&resp.Data, "projects/update-column")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsUpdateColumn performs requests for "projects/update-column"

Update an existing project column.

  PATCH /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
func (c Client) ProjectsUpdateColumn(ctx context.Context, req *ProjectsUpdateColumnReq, opt ...RequestOption) (*ProjectsUpdateColumnResponse, error) {
	return ProjectsUpdateColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsUpdateColumnReq is request data for Client.ProjectsUpdateColumn

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
type ProjectsUpdateColumnReq struct {
	_url string

	// column_id parameter
	ColumnId    int64
	RequestBody ProjectsUpdateColumnReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsUpdateColumnReq) url() string {
	return r._url
}

func (r *ProjectsUpdateColumnReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/%v", r.ColumnId)
}

func (r *ProjectsUpdateColumnReq) method() string {
	return "PATCH"
}

func (r *ProjectsUpdateColumnReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsUpdateColumnReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsUpdateColumnReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsUpdateColumnReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsUpdateColumnReq) validStatuses() []int {
	return []int{200, 304}
}

// HTTPRequest builds an *http.Request
func (r *ProjectsUpdateColumnReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "projects/update-column", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsUpdateColumnReq) Rel(link RelName, resp *ProjectsUpdateColumnResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsUpdateColumnReqBody is a request body for projects/update-column

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
type ProjectsUpdateColumnReqBody struct {

	// Name of the project column
	Name *string `json:"name"`
}

/*
ProjectsUpdateColumnResponse is a response for ProjectsUpdateColumn

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
type ProjectsUpdateColumnResponse struct {
	response
	request *ProjectsUpdateColumnReq
	Data    components.ProjectColumn
}
