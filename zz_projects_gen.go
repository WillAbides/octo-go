// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
ProjectsAddCollaborator performs requests for "projects/add-collaborator"

Add user as a collaborator.

  PUT /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#add-user-as-a-collaborator
*/
func ProjectsAddCollaborator(ctx context.Context, req *ProjectsAddCollaboratorReq, opt ...RequestOption) (*ProjectsAddCollaboratorResponse, error) {
	if req == nil {
		req = new(ProjectsAddCollaboratorReq)
	}
	resp := &ProjectsAddCollaboratorResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsAddCollaborator performs requests for "projects/add-collaborator"

Add user as a collaborator.

  PUT /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#add-user-as-a-collaborator
*/
func (c Client) ProjectsAddCollaborator(ctx context.Context, req *ProjectsAddCollaboratorReq, opt ...RequestOption) (*ProjectsAddCollaboratorResponse, error) {
	return ProjectsAddCollaborator(ctx, req, append(c, opt...)...)
}

/*
ProjectsAddCollaboratorReq is request data for Client.ProjectsAddCollaborator

https://developer.github.com/v3/projects/collaborators/#add-user-as-a-collaborator
*/
type ProjectsAddCollaboratorReq struct {
	_url        string
	ProjectId   int64
	Username    string
	RequestBody ProjectsAddCollaboratorReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsAddCollaboratorReq) url() string {
	return r._url
}

func (r *ProjectsAddCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/projects/%v/collaborators/%v", r.ProjectId, r.Username)
}

func (r *ProjectsAddCollaboratorReq) method() string {
	return "PUT"
}

func (r *ProjectsAddCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsAddCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsAddCollaboratorReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsAddCollaboratorReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsAddCollaboratorReq) validStatuses() []int {
	return []int{204}
}

func (r *ProjectsAddCollaboratorReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ProjectsAddCollaboratorReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsAddCollaboratorReq) Rel(link RelName, resp *ProjectsAddCollaboratorResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsAddCollaboratorReqBody is a request body for projects/add-collaborator

https://developer.github.com/v3/projects/collaborators/#add-user-as-a-collaborator
*/
type ProjectsAddCollaboratorReqBody struct {

	/*
	   The permission to grant the collaborator. Note that, if you choose not to pass
	   any parameters, you'll need to set `Content-Length` to zero when calling out to
	   this endpoint. For more information, see "[HTTP
	   verbs](https://developer.github.com/v3/#http-verbs)." Can be one of:
	   \* `read` - can read, but not write to or administer this project.
	   \* `write` - can read and write, but not administer this project.
	   \* `admin` - can read, write and administer this project.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
ProjectsAddCollaboratorResponse is a response for ProjectsAddCollaborator

https://developer.github.com/v3/projects/collaborators/#add-user-as-a-collaborator
*/
type ProjectsAddCollaboratorResponse struct {
	response
	request *ProjectsAddCollaboratorReq
}

/*
ProjectsCreateCard performs requests for "projects/create-card"

Create a project card.

  POST /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
func ProjectsCreateCard(ctx context.Context, req *ProjectsCreateCardReq, opt ...RequestOption) (*ProjectsCreateCardResponse, error) {
	if req == nil {
		req = new(ProjectsCreateCardReq)
	}
	resp := &ProjectsCreateCardResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ProjectsCreateCardResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateCard performs requests for "projects/create-card"

Create a project card.

  POST /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
func (c Client) ProjectsCreateCard(ctx context.Context, req *ProjectsCreateCardReq, opt ...RequestOption) (*ProjectsCreateCardResponse, error) {
	return ProjectsCreateCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateCardReq is request data for Client.ProjectsCreateCard

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
type ProjectsCreateCardReq struct {
	_url        string
	ColumnId    int64
	RequestBody ProjectsCreateCardReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsCreateCardReq) url() string {
	return r._url
}

func (r *ProjectsCreateCardReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/%v/cards", r.ColumnId)
}

func (r *ProjectsCreateCardReq) method() string {
	return "POST"
}

func (r *ProjectsCreateCardReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsCreateCardReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsCreateCardReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsCreateCardReq) dataStatuses() []int {
	return []int{201}
}

func (r *ProjectsCreateCardReq) validStatuses() []int {
	return []int{201}
}

func (r *ProjectsCreateCardReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ProjectsCreateCardReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateCardReq) Rel(link RelName, resp *ProjectsCreateCardResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateCardReqBody is a request body for projects/create-card

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
type ProjectsCreateCardReqBody struct {

	/*
	   The issue or pull request id you want to associate with this card. You can use
	   the [List repository
	   issues](https://developer.github.com/v3/issues/#list-repository-issues) and
	   [List pull requests](https://developer.github.com/v3/pulls/#list-pull-requests)
	   endpoints to find this id.
	   **Note:** Depending on whether you use the issue id or pull request id, you will
	   need to specify `Issue` or `PullRequest` as the `content_type`.
	*/
	ContentId *int64 `json:"content_id,omitempty"`

	/*
	   **Required if you provide `content_id`**. The type of content you want to
	   associate with this card. Use `Issue` when `content_id` is an issue id and use
	   `PullRequest` when `content_id` is a pull request id.
	*/
	ContentType *string `json:"content_type,omitempty"`

	/*
	   The card's note content. Only valid for cards without another type of content,
	   so you must omit when specifying `content_id` and `content_type`.
	*/
	Note *string `json:"note,omitempty"`
}

/*
ProjectsCreateCardResponseBody is a response body for ProjectsCreateCard

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
type ProjectsCreateCardResponseBody struct {
	components.ProjectCard
}

/*
ProjectsCreateCardResponse is a response for ProjectsCreateCard

https://developer.github.com/v3/projects/cards/#create-a-project-card
*/
type ProjectsCreateCardResponse struct {
	response
	request *ProjectsCreateCardReq
	Data    *ProjectsCreateCardResponseBody
}

/*
ProjectsCreateColumn performs requests for "projects/create-column"

Create a project column.

  POST /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
func ProjectsCreateColumn(ctx context.Context, req *ProjectsCreateColumnReq, opt ...RequestOption) (*ProjectsCreateColumnResponse, error) {
	if req == nil {
		req = new(ProjectsCreateColumnReq)
	}
	resp := &ProjectsCreateColumnResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateColumn performs requests for "projects/create-column"

Create a project column.

  POST /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
func (c Client) ProjectsCreateColumn(ctx context.Context, req *ProjectsCreateColumnReq, opt ...RequestOption) (*ProjectsCreateColumnResponse, error) {
	return ProjectsCreateColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateColumnReq is request data for Client.ProjectsCreateColumn

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
type ProjectsCreateColumnReq struct {
	_url        string
	ProjectId   int64
	RequestBody ProjectsCreateColumnReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsCreateColumnReq) url() string {
	return r._url
}

func (r *ProjectsCreateColumnReq) urlPath() string {
	return fmt.Sprintf("/projects/%v/columns", r.ProjectId)
}

func (r *ProjectsCreateColumnReq) method() string {
	return "POST"
}

func (r *ProjectsCreateColumnReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsCreateColumnReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsCreateColumnReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsCreateColumnReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsCreateColumnReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsCreateColumnReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ProjectsCreateColumnReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateColumnReq) Rel(link RelName, resp *ProjectsCreateColumnResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateColumnReqBody is a request body for projects/create-column

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
type ProjectsCreateColumnReqBody struct {

	// The name of the column.
	Name *string `json:"name"`
}

/*
ProjectsCreateColumnResponse is a response for ProjectsCreateColumn

https://developer.github.com/v3/projects/columns/#create-a-project-column
*/
type ProjectsCreateColumnResponse struct {
	response
	request *ProjectsCreateColumnReq
}

/*
ProjectsCreateForAuthenticatedUser performs requests for "projects/create-for-authenticated-user"

Create a user project.

  POST /user/projects

https://developer.github.com/v3/projects/#create-a-user-project
*/
func ProjectsCreateForAuthenticatedUser(ctx context.Context, req *ProjectsCreateForAuthenticatedUserReq, opt ...RequestOption) (*ProjectsCreateForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(ProjectsCreateForAuthenticatedUserReq)
	}
	resp := &ProjectsCreateForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ProjectsCreateForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateForAuthenticatedUser performs requests for "projects/create-for-authenticated-user"

Create a user project.

  POST /user/projects

https://developer.github.com/v3/projects/#create-a-user-project
*/
func (c Client) ProjectsCreateForAuthenticatedUser(ctx context.Context, req *ProjectsCreateForAuthenticatedUserReq, opt ...RequestOption) (*ProjectsCreateForAuthenticatedUserResponse, error) {
	return ProjectsCreateForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateForAuthenticatedUserReq is request data for Client.ProjectsCreateForAuthenticatedUser

https://developer.github.com/v3/projects/#create-a-user-project
*/
type ProjectsCreateForAuthenticatedUserReq struct {
	_url        string
	RequestBody ProjectsCreateForAuthenticatedUserReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsCreateForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *ProjectsCreateForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/projects")
}

func (r *ProjectsCreateForAuthenticatedUserReq) method() string {
	return "POST"
}

func (r *ProjectsCreateForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsCreateForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsCreateForAuthenticatedUserReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsCreateForAuthenticatedUserReq) dataStatuses() []int {
	return []int{201}
}

func (r *ProjectsCreateForAuthenticatedUserReq) validStatuses() []int {
	return []int{201}
}

func (r *ProjectsCreateForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ProjectsCreateForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateForAuthenticatedUserReq) Rel(link RelName, resp *ProjectsCreateForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateForAuthenticatedUserReqBody is a request body for projects/create-for-authenticated-user

https://developer.github.com/v3/projects/#create-a-user-project
*/
type ProjectsCreateForAuthenticatedUserReqBody struct {

	// The description of the project.
	Body *string `json:"body,omitempty"`

	// The name of the project.
	Name *string `json:"name"`
}

/*
ProjectsCreateForAuthenticatedUserResponseBody is a response body for ProjectsCreateForAuthenticatedUser

https://developer.github.com/v3/projects/#create-a-user-project
*/
type ProjectsCreateForAuthenticatedUserResponseBody struct {
	components.Project
}

/*
ProjectsCreateForAuthenticatedUserResponse is a response for ProjectsCreateForAuthenticatedUser

https://developer.github.com/v3/projects/#create-a-user-project
*/
type ProjectsCreateForAuthenticatedUserResponse struct {
	response
	request *ProjectsCreateForAuthenticatedUserReq
	Data    *ProjectsCreateForAuthenticatedUserResponseBody
}

/*
ProjectsCreateForOrg performs requests for "projects/create-for-org"

Create an organization project.

  POST /orgs/{org}/projects

https://developer.github.com/v3/projects/#create-an-organization-project
*/
func ProjectsCreateForOrg(ctx context.Context, req *ProjectsCreateForOrgReq, opt ...RequestOption) (*ProjectsCreateForOrgResponse, error) {
	if req == nil {
		req = new(ProjectsCreateForOrgReq)
	}
	resp := &ProjectsCreateForOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ProjectsCreateForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateForOrg performs requests for "projects/create-for-org"

Create an organization project.

  POST /orgs/{org}/projects

https://developer.github.com/v3/projects/#create-an-organization-project
*/
func (c Client) ProjectsCreateForOrg(ctx context.Context, req *ProjectsCreateForOrgReq, opt ...RequestOption) (*ProjectsCreateForOrgResponse, error) {
	return ProjectsCreateForOrg(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateForOrgReq is request data for Client.ProjectsCreateForOrg

https://developer.github.com/v3/projects/#create-an-organization-project
*/
type ProjectsCreateForOrgReq struct {
	_url        string
	Org         string
	RequestBody ProjectsCreateForOrgReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsCreateForOrgReq) url() string {
	return r._url
}

func (r *ProjectsCreateForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/projects", r.Org)
}

func (r *ProjectsCreateForOrgReq) method() string {
	return "POST"
}

func (r *ProjectsCreateForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsCreateForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsCreateForOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsCreateForOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *ProjectsCreateForOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *ProjectsCreateForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ProjectsCreateForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateForOrgReq) Rel(link RelName, resp *ProjectsCreateForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateForOrgReqBody is a request body for projects/create-for-org

https://developer.github.com/v3/projects/#create-an-organization-project
*/
type ProjectsCreateForOrgReqBody struct {

	// The description of the project.
	Body *string `json:"body,omitempty"`

	// The name of the project.
	Name *string `json:"name"`
}

/*
ProjectsCreateForOrgResponseBody is a response body for ProjectsCreateForOrg

https://developer.github.com/v3/projects/#create-an-organization-project
*/
type ProjectsCreateForOrgResponseBody struct {
	components.Project
}

/*
ProjectsCreateForOrgResponse is a response for ProjectsCreateForOrg

https://developer.github.com/v3/projects/#create-an-organization-project
*/
type ProjectsCreateForOrgResponse struct {
	response
	request *ProjectsCreateForOrgReq
	Data    *ProjectsCreateForOrgResponseBody
}

/*
ProjectsCreateForRepo performs requests for "projects/create-for-repo"

Create a repository project.

  POST /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#create-a-repository-project
*/
func ProjectsCreateForRepo(ctx context.Context, req *ProjectsCreateForRepoReq, opt ...RequestOption) (*ProjectsCreateForRepoResponse, error) {
	if req == nil {
		req = new(ProjectsCreateForRepoReq)
	}
	resp := &ProjectsCreateForRepoResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ProjectsCreateForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsCreateForRepo performs requests for "projects/create-for-repo"

Create a repository project.

  POST /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#create-a-repository-project
*/
func (c Client) ProjectsCreateForRepo(ctx context.Context, req *ProjectsCreateForRepoReq, opt ...RequestOption) (*ProjectsCreateForRepoResponse, error) {
	return ProjectsCreateForRepo(ctx, req, append(c, opt...)...)
}

/*
ProjectsCreateForRepoReq is request data for Client.ProjectsCreateForRepo

https://developer.github.com/v3/projects/#create-a-repository-project
*/
type ProjectsCreateForRepoReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody ProjectsCreateForRepoReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsCreateForRepoReq) url() string {
	return r._url
}

func (r *ProjectsCreateForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/projects", r.Owner, r.Repo)
}

func (r *ProjectsCreateForRepoReq) method() string {
	return "POST"
}

func (r *ProjectsCreateForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsCreateForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsCreateForRepoReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsCreateForRepoReq) dataStatuses() []int {
	return []int{201}
}

func (r *ProjectsCreateForRepoReq) validStatuses() []int {
	return []int{201}
}

func (r *ProjectsCreateForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ProjectsCreateForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsCreateForRepoReq) Rel(link RelName, resp *ProjectsCreateForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsCreateForRepoReqBody is a request body for projects/create-for-repo

https://developer.github.com/v3/projects/#create-a-repository-project
*/
type ProjectsCreateForRepoReqBody struct {

	// The description of the project.
	Body *string `json:"body,omitempty"`

	// The name of the project.
	Name *string `json:"name"`
}

/*
ProjectsCreateForRepoResponseBody is a response body for ProjectsCreateForRepo

https://developer.github.com/v3/projects/#create-a-repository-project
*/
type ProjectsCreateForRepoResponseBody struct {
	components.Project
}

/*
ProjectsCreateForRepoResponse is a response for ProjectsCreateForRepo

https://developer.github.com/v3/projects/#create-a-repository-project
*/
type ProjectsCreateForRepoResponse struct {
	response
	request *ProjectsCreateForRepoReq
	Data    *ProjectsCreateForRepoResponseBody
}

/*
ProjectsDelete performs requests for "projects/delete"

Delete a project.

  DELETE /projects/{project_id}

https://developer.github.com/v3/projects/#delete-a-project
*/
func ProjectsDelete(ctx context.Context, req *ProjectsDeleteReq, opt ...RequestOption) (*ProjectsDeleteResponse, error) {
	if req == nil {
		req = new(ProjectsDeleteReq)
	}
	resp := &ProjectsDeleteResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsDelete performs requests for "projects/delete"

Delete a project.

  DELETE /projects/{project_id}

https://developer.github.com/v3/projects/#delete-a-project
*/
func (c Client) ProjectsDelete(ctx context.Context, req *ProjectsDeleteReq, opt ...RequestOption) (*ProjectsDeleteResponse, error) {
	return ProjectsDelete(ctx, req, append(c, opt...)...)
}

/*
ProjectsDeleteReq is request data for Client.ProjectsDelete

https://developer.github.com/v3/projects/#delete-a-project
*/
type ProjectsDeleteReq struct {
	_url      string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsDeleteReq) url() string {
	return r._url
}

func (r *ProjectsDeleteReq) urlPath() string {
	return fmt.Sprintf("/projects/%v", r.ProjectId)
}

func (r *ProjectsDeleteReq) method() string {
	return "DELETE"
}

func (r *ProjectsDeleteReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsDeleteReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsDeleteReq) body() interface{} {
	return nil
}

func (r *ProjectsDeleteReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsDeleteReq) validStatuses() []int {
	return []int{}
}

func (r *ProjectsDeleteReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsDeleteReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsDeleteReq) Rel(link RelName, resp *ProjectsDeleteResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsDeleteResponse is a response for ProjectsDelete

https://developer.github.com/v3/projects/#delete-a-project
*/
type ProjectsDeleteResponse struct {
	response
	request *ProjectsDeleteReq
}

/*
ProjectsDeleteCard performs requests for "projects/delete-card"

Delete a project card.

  DELETE /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
func ProjectsDeleteCard(ctx context.Context, req *ProjectsDeleteCardReq, opt ...RequestOption) (*ProjectsDeleteCardResponse, error) {
	if req == nil {
		req = new(ProjectsDeleteCardReq)
	}
	resp := &ProjectsDeleteCardResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsDeleteCard performs requests for "projects/delete-card"

Delete a project card.

  DELETE /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
func (c Client) ProjectsDeleteCard(ctx context.Context, req *ProjectsDeleteCardReq, opt ...RequestOption) (*ProjectsDeleteCardResponse, error) {
	return ProjectsDeleteCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsDeleteCardReq is request data for Client.ProjectsDeleteCard

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
type ProjectsDeleteCardReq struct {
	_url   string
	CardId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsDeleteCardReq) url() string {
	return r._url
}

func (r *ProjectsDeleteCardReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/cards/%v", r.CardId)
}

func (r *ProjectsDeleteCardReq) method() string {
	return "DELETE"
}

func (r *ProjectsDeleteCardReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsDeleteCardReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsDeleteCardReq) body() interface{} {
	return nil
}

func (r *ProjectsDeleteCardReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsDeleteCardReq) validStatuses() []int {
	return []int{204}
}

func (r *ProjectsDeleteCardReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsDeleteCardReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsDeleteCardReq) Rel(link RelName, resp *ProjectsDeleteCardResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsDeleteCardResponse is a response for ProjectsDeleteCard

https://developer.github.com/v3/projects/cards/#delete-a-project-card
*/
type ProjectsDeleteCardResponse struct {
	response
	request *ProjectsDeleteCardReq
}

/*
ProjectsDeleteColumn performs requests for "projects/delete-column"

Delete a project column.

  DELETE /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
func ProjectsDeleteColumn(ctx context.Context, req *ProjectsDeleteColumnReq, opt ...RequestOption) (*ProjectsDeleteColumnResponse, error) {
	if req == nil {
		req = new(ProjectsDeleteColumnReq)
	}
	resp := &ProjectsDeleteColumnResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsDeleteColumn performs requests for "projects/delete-column"

Delete a project column.

  DELETE /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
func (c Client) ProjectsDeleteColumn(ctx context.Context, req *ProjectsDeleteColumnReq, opt ...RequestOption) (*ProjectsDeleteColumnResponse, error) {
	return ProjectsDeleteColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsDeleteColumnReq is request data for Client.ProjectsDeleteColumn

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
type ProjectsDeleteColumnReq struct {
	_url     string
	ColumnId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsDeleteColumnReq) url() string {
	return r._url
}

func (r *ProjectsDeleteColumnReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/%v", r.ColumnId)
}

func (r *ProjectsDeleteColumnReq) method() string {
	return "DELETE"
}

func (r *ProjectsDeleteColumnReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsDeleteColumnReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsDeleteColumnReq) body() interface{} {
	return nil
}

func (r *ProjectsDeleteColumnReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsDeleteColumnReq) validStatuses() []int {
	return []int{204}
}

func (r *ProjectsDeleteColumnReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsDeleteColumnReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsDeleteColumnReq) Rel(link RelName, resp *ProjectsDeleteColumnResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsDeleteColumnResponse is a response for ProjectsDeleteColumn

https://developer.github.com/v3/projects/columns/#delete-a-project-column
*/
type ProjectsDeleteColumnResponse struct {
	response
	request *ProjectsDeleteColumnReq
}

/*
ProjectsGet performs requests for "projects/get"

Get a project.

  GET /projects/{project_id}

https://developer.github.com/v3/projects/#get-a-project
*/
func ProjectsGet(ctx context.Context, req *ProjectsGetReq, opt ...RequestOption) (*ProjectsGetResponse, error) {
	if req == nil {
		req = new(ProjectsGetReq)
	}
	resp := &ProjectsGetResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ProjectsGetResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsGet performs requests for "projects/get"

Get a project.

  GET /projects/{project_id}

https://developer.github.com/v3/projects/#get-a-project
*/
func (c Client) ProjectsGet(ctx context.Context, req *ProjectsGetReq, opt ...RequestOption) (*ProjectsGetResponse, error) {
	return ProjectsGet(ctx, req, append(c, opt...)...)
}

/*
ProjectsGetReq is request data for Client.ProjectsGet

https://developer.github.com/v3/projects/#get-a-project
*/
type ProjectsGetReq struct {
	_url      string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsGetReq) url() string {
	return r._url
}

func (r *ProjectsGetReq) urlPath() string {
	return fmt.Sprintf("/projects/%v", r.ProjectId)
}

func (r *ProjectsGetReq) method() string {
	return "GET"
}

func (r *ProjectsGetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsGetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsGetReq) body() interface{} {
	return nil
}

func (r *ProjectsGetReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsGetReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsGetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsGetReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsGetReq) Rel(link RelName, resp *ProjectsGetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsGetResponseBody is a response body for ProjectsGet

https://developer.github.com/v3/projects/#get-a-project
*/
type ProjectsGetResponseBody struct {
	components.Project
}

/*
ProjectsGetResponse is a response for ProjectsGet

https://developer.github.com/v3/projects/#get-a-project
*/
type ProjectsGetResponse struct {
	response
	request *ProjectsGetReq
	Data    *ProjectsGetResponseBody
}

/*
ProjectsGetCard performs requests for "projects/get-card"

Get a project card.

  GET /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
func ProjectsGetCard(ctx context.Context, req *ProjectsGetCardReq, opt ...RequestOption) (*ProjectsGetCardResponse, error) {
	if req == nil {
		req = new(ProjectsGetCardReq)
	}
	resp := &ProjectsGetCardResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsGetCard performs requests for "projects/get-card"

Get a project card.

  GET /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
func (c Client) ProjectsGetCard(ctx context.Context, req *ProjectsGetCardReq, opt ...RequestOption) (*ProjectsGetCardResponse, error) {
	return ProjectsGetCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsGetCardReq is request data for Client.ProjectsGetCard

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
type ProjectsGetCardReq struct {
	_url   string
	CardId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsGetCardReq) url() string {
	return r._url
}

func (r *ProjectsGetCardReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/cards/%v", r.CardId)
}

func (r *ProjectsGetCardReq) method() string {
	return "GET"
}

func (r *ProjectsGetCardReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsGetCardReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsGetCardReq) body() interface{} {
	return nil
}

func (r *ProjectsGetCardReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsGetCardReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsGetCardReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsGetCardReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsGetCardReq) Rel(link RelName, resp *ProjectsGetCardResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsGetCardResponse is a response for ProjectsGetCard

https://developer.github.com/v3/projects/cards/#get-a-project-card
*/
type ProjectsGetCardResponse struct {
	response
	request *ProjectsGetCardReq
}

/*
ProjectsGetColumn performs requests for "projects/get-column"

Get a project column.

  GET /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
func ProjectsGetColumn(ctx context.Context, req *ProjectsGetColumnReq, opt ...RequestOption) (*ProjectsGetColumnResponse, error) {
	if req == nil {
		req = new(ProjectsGetColumnReq)
	}
	resp := &ProjectsGetColumnResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsGetColumn performs requests for "projects/get-column"

Get a project column.

  GET /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
func (c Client) ProjectsGetColumn(ctx context.Context, req *ProjectsGetColumnReq, opt ...RequestOption) (*ProjectsGetColumnResponse, error) {
	return ProjectsGetColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsGetColumnReq is request data for Client.ProjectsGetColumn

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
type ProjectsGetColumnReq struct {
	_url     string
	ColumnId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsGetColumnReq) url() string {
	return r._url
}

func (r *ProjectsGetColumnReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/%v", r.ColumnId)
}

func (r *ProjectsGetColumnReq) method() string {
	return "GET"
}

func (r *ProjectsGetColumnReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsGetColumnReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsGetColumnReq) body() interface{} {
	return nil
}

func (r *ProjectsGetColumnReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsGetColumnReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsGetColumnReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsGetColumnReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsGetColumnReq) Rel(link RelName, resp *ProjectsGetColumnResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsGetColumnResponse is a response for ProjectsGetColumn

https://developer.github.com/v3/projects/columns/#get-a-project-column
*/
type ProjectsGetColumnResponse struct {
	response
	request *ProjectsGetColumnReq
}

/*
ProjectsListCards performs requests for "projects/list-cards"

List project cards.

  GET /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
func ProjectsListCards(ctx context.Context, req *ProjectsListCardsReq, opt ...RequestOption) (*ProjectsListCardsResponse, error) {
	if req == nil {
		req = new(ProjectsListCardsReq)
	}
	resp := &ProjectsListCardsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ProjectsListCardsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListCards performs requests for "projects/list-cards"

List project cards.

  GET /projects/columns/{column_id}/cards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
func (c Client) ProjectsListCards(ctx context.Context, req *ProjectsListCardsReq, opt ...RequestOption) (*ProjectsListCardsResponse, error) {
	return ProjectsListCards(ctx, req, append(c, opt...)...)
}

/*
ProjectsListCardsReq is request data for Client.ProjectsListCards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
type ProjectsListCardsReq struct {
	_url     string
	ColumnId int64

	/*
	Filters the project cards that are returned by the card's state. Can be one of
	`all`,`archived`, or `not_archived`.
	*/
	ArchivedState *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsListCardsReq) url() string {
	return r._url
}

func (r *ProjectsListCardsReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/%v/cards", r.ColumnId)
}

func (r *ProjectsListCardsReq) method() string {
	return "GET"
}

func (r *ProjectsListCardsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.ArchivedState != nil {
		query.Set("archived_state", *r.ArchivedState)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ProjectsListCardsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsListCardsReq) body() interface{} {
	return nil
}

func (r *ProjectsListCardsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsListCardsReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsListCardsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsListCardsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListCardsReq) Rel(link RelName, resp *ProjectsListCardsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListCardsResponseBody is a response body for ProjectsListCards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
type ProjectsListCardsResponseBody []struct {
	components.ProjectCard
}

/*
ProjectsListCardsResponse is a response for ProjectsListCards

https://developer.github.com/v3/projects/cards/#list-project-cards
*/
type ProjectsListCardsResponse struct {
	response
	request *ProjectsListCardsReq
	Data    *ProjectsListCardsResponseBody
}

/*
ProjectsListCollaborators performs requests for "projects/list-collaborators"

List collaborators.

  GET /projects/{project_id}/collaborators

https://developer.github.com/v3/projects/collaborators/#list-collaborators
*/
func ProjectsListCollaborators(ctx context.Context, req *ProjectsListCollaboratorsReq, opt ...RequestOption) (*ProjectsListCollaboratorsResponse, error) {
	if req == nil {
		req = new(ProjectsListCollaboratorsReq)
	}
	resp := &ProjectsListCollaboratorsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ProjectsListCollaboratorsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListCollaborators performs requests for "projects/list-collaborators"

List collaborators.

  GET /projects/{project_id}/collaborators

https://developer.github.com/v3/projects/collaborators/#list-collaborators
*/
func (c Client) ProjectsListCollaborators(ctx context.Context, req *ProjectsListCollaboratorsReq, opt ...RequestOption) (*ProjectsListCollaboratorsResponse, error) {
	return ProjectsListCollaborators(ctx, req, append(c, opt...)...)
}

/*
ProjectsListCollaboratorsReq is request data for Client.ProjectsListCollaborators

https://developer.github.com/v3/projects/collaborators/#list-collaborators
*/
type ProjectsListCollaboratorsReq struct {
	_url      string
	ProjectId int64

	/*
	Filters the collaborators by their affiliation. Can be one of:
	\* `outside`: Outside collaborators of a project that are not a member of the
	project's organization.
	\* `direct`: Collaborators with permissions to a project, regardless of
	organization membership status.
	\* `all`: All collaborators the authenticated user can see.
	*/
	Affiliation *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsListCollaboratorsReq) url() string {
	return r._url
}

func (r *ProjectsListCollaboratorsReq) urlPath() string {
	return fmt.Sprintf("/projects/%v/collaborators", r.ProjectId)
}

func (r *ProjectsListCollaboratorsReq) method() string {
	return "GET"
}

func (r *ProjectsListCollaboratorsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Affiliation != nil {
		query.Set("affiliation", *r.Affiliation)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ProjectsListCollaboratorsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsListCollaboratorsReq) body() interface{} {
	return nil
}

func (r *ProjectsListCollaboratorsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsListCollaboratorsReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsListCollaboratorsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsListCollaboratorsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListCollaboratorsReq) Rel(link RelName, resp *ProjectsListCollaboratorsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListCollaboratorsResponseBody is a response body for ProjectsListCollaborators

https://developer.github.com/v3/projects/collaborators/#list-collaborators
*/
type ProjectsListCollaboratorsResponseBody []struct {
	components.SimpleUser
}

/*
ProjectsListCollaboratorsResponse is a response for ProjectsListCollaborators

https://developer.github.com/v3/projects/collaborators/#list-collaborators
*/
type ProjectsListCollaboratorsResponse struct {
	response
	request *ProjectsListCollaboratorsReq
	Data    *ProjectsListCollaboratorsResponseBody
}

/*
ProjectsListColumns performs requests for "projects/list-columns"

List project columns.

  GET /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
func ProjectsListColumns(ctx context.Context, req *ProjectsListColumnsReq, opt ...RequestOption) (*ProjectsListColumnsResponse, error) {
	if req == nil {
		req = new(ProjectsListColumnsReq)
	}
	resp := &ProjectsListColumnsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ProjectsListColumnsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListColumns performs requests for "projects/list-columns"

List project columns.

  GET /projects/{project_id}/columns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
func (c Client) ProjectsListColumns(ctx context.Context, req *ProjectsListColumnsReq, opt ...RequestOption) (*ProjectsListColumnsResponse, error) {
	return ProjectsListColumns(ctx, req, append(c, opt...)...)
}

/*
ProjectsListColumnsReq is request data for Client.ProjectsListColumns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
type ProjectsListColumnsReq struct {
	_url      string
	ProjectId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsListColumnsReq) url() string {
	return r._url
}

func (r *ProjectsListColumnsReq) urlPath() string {
	return fmt.Sprintf("/projects/%v/columns", r.ProjectId)
}

func (r *ProjectsListColumnsReq) method() string {
	return "GET"
}

func (r *ProjectsListColumnsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ProjectsListColumnsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsListColumnsReq) body() interface{} {
	return nil
}

func (r *ProjectsListColumnsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsListColumnsReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsListColumnsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsListColumnsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListColumnsReq) Rel(link RelName, resp *ProjectsListColumnsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListColumnsResponseBody is a response body for ProjectsListColumns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
type ProjectsListColumnsResponseBody []struct {
	components.ProjectColumn
}

/*
ProjectsListColumnsResponse is a response for ProjectsListColumns

https://developer.github.com/v3/projects/columns/#list-project-columns
*/
type ProjectsListColumnsResponse struct {
	response
	request *ProjectsListColumnsReq
	Data    *ProjectsListColumnsResponseBody
}

/*
ProjectsListForOrg performs requests for "projects/list-for-org"

List organization projects.

  GET /orgs/{org}/projects

https://developer.github.com/v3/projects/#list-organization-projects
*/
func ProjectsListForOrg(ctx context.Context, req *ProjectsListForOrgReq, opt ...RequestOption) (*ProjectsListForOrgResponse, error) {
	if req == nil {
		req = new(ProjectsListForOrgReq)
	}
	resp := &ProjectsListForOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ProjectsListForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListForOrg performs requests for "projects/list-for-org"

List organization projects.

  GET /orgs/{org}/projects

https://developer.github.com/v3/projects/#list-organization-projects
*/
func (c Client) ProjectsListForOrg(ctx context.Context, req *ProjectsListForOrgReq, opt ...RequestOption) (*ProjectsListForOrgResponse, error) {
	return ProjectsListForOrg(ctx, req, append(c, opt...)...)
}

/*
ProjectsListForOrgReq is request data for Client.ProjectsListForOrg

https://developer.github.com/v3/projects/#list-organization-projects
*/
type ProjectsListForOrgReq struct {
	_url string
	Org  string

	/*
	Indicates the state of the projects to return. Can be either `open`, `closed`,
	or `all`.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsListForOrgReq) url() string {
	return r._url
}

func (r *ProjectsListForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/projects", r.Org)
}

func (r *ProjectsListForOrgReq) method() string {
	return "GET"
}

func (r *ProjectsListForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ProjectsListForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsListForOrgReq) body() interface{} {
	return nil
}

func (r *ProjectsListForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsListForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsListForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsListForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListForOrgReq) Rel(link RelName, resp *ProjectsListForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListForOrgResponseBody is a response body for ProjectsListForOrg

https://developer.github.com/v3/projects/#list-organization-projects
*/
type ProjectsListForOrgResponseBody []struct {
	components.Project
}

/*
ProjectsListForOrgResponse is a response for ProjectsListForOrg

https://developer.github.com/v3/projects/#list-organization-projects
*/
type ProjectsListForOrgResponse struct {
	response
	request *ProjectsListForOrgReq
	Data    *ProjectsListForOrgResponseBody
}

/*
ProjectsListForRepo performs requests for "projects/list-for-repo"

List repository projects.

  GET /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#list-repository-projects
*/
func ProjectsListForRepo(ctx context.Context, req *ProjectsListForRepoReq, opt ...RequestOption) (*ProjectsListForRepoResponse, error) {
	if req == nil {
		req = new(ProjectsListForRepoReq)
	}
	resp := &ProjectsListForRepoResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ProjectsListForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListForRepo performs requests for "projects/list-for-repo"

List repository projects.

  GET /repos/{owner}/{repo}/projects

https://developer.github.com/v3/projects/#list-repository-projects
*/
func (c Client) ProjectsListForRepo(ctx context.Context, req *ProjectsListForRepoReq, opt ...RequestOption) (*ProjectsListForRepoResponse, error) {
	return ProjectsListForRepo(ctx, req, append(c, opt...)...)
}

/*
ProjectsListForRepoReq is request data for Client.ProjectsListForRepo

https://developer.github.com/v3/projects/#list-repository-projects
*/
type ProjectsListForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Indicates the state of the projects to return. Can be either `open`, `closed`,
	or `all`.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsListForRepoReq) url() string {
	return r._url
}

func (r *ProjectsListForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/projects", r.Owner, r.Repo)
}

func (r *ProjectsListForRepoReq) method() string {
	return "GET"
}

func (r *ProjectsListForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ProjectsListForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsListForRepoReq) body() interface{} {
	return nil
}

func (r *ProjectsListForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsListForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsListForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsListForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListForRepoReq) Rel(link RelName, resp *ProjectsListForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListForRepoResponseBody is a response body for ProjectsListForRepo

https://developer.github.com/v3/projects/#list-repository-projects
*/
type ProjectsListForRepoResponseBody []struct {
	components.Project
}

/*
ProjectsListForRepoResponse is a response for ProjectsListForRepo

https://developer.github.com/v3/projects/#list-repository-projects
*/
type ProjectsListForRepoResponse struct {
	response
	request *ProjectsListForRepoReq
	Data    *ProjectsListForRepoResponseBody
}

/*
ProjectsListForUser performs requests for "projects/list-for-user"

List user projects.

  GET /users/{username}/projects

https://developer.github.com/v3/projects/#list-user-projects
*/
func ProjectsListForUser(ctx context.Context, req *ProjectsListForUserReq, opt ...RequestOption) (*ProjectsListForUserResponse, error) {
	if req == nil {
		req = new(ProjectsListForUserReq)
	}
	resp := &ProjectsListForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ProjectsListForUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsListForUser performs requests for "projects/list-for-user"

List user projects.

  GET /users/{username}/projects

https://developer.github.com/v3/projects/#list-user-projects
*/
func (c Client) ProjectsListForUser(ctx context.Context, req *ProjectsListForUserReq, opt ...RequestOption) (*ProjectsListForUserResponse, error) {
	return ProjectsListForUser(ctx, req, append(c, opt...)...)
}

/*
ProjectsListForUserReq is request data for Client.ProjectsListForUser

https://developer.github.com/v3/projects/#list-user-projects
*/
type ProjectsListForUserReq struct {
	_url     string
	Username string

	/*
	Indicates the state of the projects to return. Can be either `open`, `closed`,
	or `all`.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsListForUserReq) url() string {
	return r._url
}

func (r *ProjectsListForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/projects", r.Username)
}

func (r *ProjectsListForUserReq) method() string {
	return "GET"
}

func (r *ProjectsListForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ProjectsListForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsListForUserReq) body() interface{} {
	return nil
}

func (r *ProjectsListForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsListForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsListForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsListForUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsListForUserReq) Rel(link RelName, resp *ProjectsListForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsListForUserResponseBody is a response body for ProjectsListForUser

https://developer.github.com/v3/projects/#list-user-projects
*/
type ProjectsListForUserResponseBody []struct {
	components.Project
}

/*
ProjectsListForUserResponse is a response for ProjectsListForUser

https://developer.github.com/v3/projects/#list-user-projects
*/
type ProjectsListForUserResponse struct {
	response
	request *ProjectsListForUserReq
	Data    *ProjectsListForUserResponseBody
}

/*
ProjectsMoveCard performs requests for "projects/move-card"

Move a project card.

  POST /projects/columns/cards/{card_id}/moves

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
func ProjectsMoveCard(ctx context.Context, req *ProjectsMoveCardReq, opt ...RequestOption) (*ProjectsMoveCardResponse, error) {
	if req == nil {
		req = new(ProjectsMoveCardReq)
	}
	resp := &ProjectsMoveCardResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsMoveCard performs requests for "projects/move-card"

Move a project card.

  POST /projects/columns/cards/{card_id}/moves

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
func (c Client) ProjectsMoveCard(ctx context.Context, req *ProjectsMoveCardReq, opt ...RequestOption) (*ProjectsMoveCardResponse, error) {
	return ProjectsMoveCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsMoveCardReq is request data for Client.ProjectsMoveCard

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
type ProjectsMoveCardReq struct {
	_url        string
	CardId      int64
	RequestBody ProjectsMoveCardReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsMoveCardReq) url() string {
	return r._url
}

func (r *ProjectsMoveCardReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/cards/%v/moves", r.CardId)
}

func (r *ProjectsMoveCardReq) method() string {
	return "POST"
}

func (r *ProjectsMoveCardReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsMoveCardReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsMoveCardReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsMoveCardReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsMoveCardReq) validStatuses() []int {
	return []int{201}
}

func (r *ProjectsMoveCardReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ProjectsMoveCardReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsMoveCardReq) Rel(link RelName, resp *ProjectsMoveCardResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsMoveCardReqBody is a request body for projects/move-card

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
type ProjectsMoveCardReqBody struct {

	// The `id` value of a column in the same project.
	ColumnId *int64 `json:"column_id,omitempty"`

	/*
	   Can be one of `top`, `bottom`, or `after:<card_id>`, where `<card_id>` is the
	   `id` value of a card in the same column, or in the new column specified by
	   `column_id`.
	*/
	Position *string `json:"position"`
}

/*
ProjectsMoveCardResponse is a response for ProjectsMoveCard

https://developer.github.com/v3/projects/cards/#move-a-project-card
*/
type ProjectsMoveCardResponse struct {
	response
	request *ProjectsMoveCardReq
}

/*
ProjectsMoveColumn performs requests for "projects/move-column"

Move a project column.

  POST /projects/columns/{column_id}/moves

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
func ProjectsMoveColumn(ctx context.Context, req *ProjectsMoveColumnReq, opt ...RequestOption) (*ProjectsMoveColumnResponse, error) {
	if req == nil {
		req = new(ProjectsMoveColumnReq)
	}
	resp := &ProjectsMoveColumnResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsMoveColumn performs requests for "projects/move-column"

Move a project column.

  POST /projects/columns/{column_id}/moves

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
func (c Client) ProjectsMoveColumn(ctx context.Context, req *ProjectsMoveColumnReq, opt ...RequestOption) (*ProjectsMoveColumnResponse, error) {
	return ProjectsMoveColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsMoveColumnReq is request data for Client.ProjectsMoveColumn

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
type ProjectsMoveColumnReq struct {
	_url        string
	ColumnId    int64
	RequestBody ProjectsMoveColumnReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsMoveColumnReq) url() string {
	return r._url
}

func (r *ProjectsMoveColumnReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/%v/moves", r.ColumnId)
}

func (r *ProjectsMoveColumnReq) method() string {
	return "POST"
}

func (r *ProjectsMoveColumnReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsMoveColumnReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsMoveColumnReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsMoveColumnReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsMoveColumnReq) validStatuses() []int {
	return []int{201}
}

func (r *ProjectsMoveColumnReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ProjectsMoveColumnReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsMoveColumnReq) Rel(link RelName, resp *ProjectsMoveColumnResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsMoveColumnReqBody is a request body for projects/move-column

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
type ProjectsMoveColumnReqBody struct {

	/*
	   Can be one of `first`, `last`, or `after:<column_id>`, where `<column_id>` is
	   the `id` value of a column in the same project.
	*/
	Position *string `json:"position"`
}

/*
ProjectsMoveColumnResponse is a response for ProjectsMoveColumn

https://developer.github.com/v3/projects/columns/#move-a-project-column
*/
type ProjectsMoveColumnResponse struct {
	response
	request *ProjectsMoveColumnReq
}

/*
ProjectsRemoveCollaborator performs requests for "projects/remove-collaborator"

Remove user as a collaborator.

  DELETE /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#remove-user-as-a-collaborator
*/
func ProjectsRemoveCollaborator(ctx context.Context, req *ProjectsRemoveCollaboratorReq, opt ...RequestOption) (*ProjectsRemoveCollaboratorResponse, error) {
	if req == nil {
		req = new(ProjectsRemoveCollaboratorReq)
	}
	resp := &ProjectsRemoveCollaboratorResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsRemoveCollaborator performs requests for "projects/remove-collaborator"

Remove user as a collaborator.

  DELETE /projects/{project_id}/collaborators/{username}

https://developer.github.com/v3/projects/collaborators/#remove-user-as-a-collaborator
*/
func (c Client) ProjectsRemoveCollaborator(ctx context.Context, req *ProjectsRemoveCollaboratorReq, opt ...RequestOption) (*ProjectsRemoveCollaboratorResponse, error) {
	return ProjectsRemoveCollaborator(ctx, req, append(c, opt...)...)
}

/*
ProjectsRemoveCollaboratorReq is request data for Client.ProjectsRemoveCollaborator

https://developer.github.com/v3/projects/collaborators/#remove-user-as-a-collaborator
*/
type ProjectsRemoveCollaboratorReq struct {
	_url      string
	ProjectId int64
	Username  string

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsRemoveCollaboratorReq) url() string {
	return r._url
}

func (r *ProjectsRemoveCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/projects/%v/collaborators/%v", r.ProjectId, r.Username)
}

func (r *ProjectsRemoveCollaboratorReq) method() string {
	return "DELETE"
}

func (r *ProjectsRemoveCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsRemoveCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsRemoveCollaboratorReq) body() interface{} {
	return nil
}

func (r *ProjectsRemoveCollaboratorReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsRemoveCollaboratorReq) validStatuses() []int {
	return []int{204}
}

func (r *ProjectsRemoveCollaboratorReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsRemoveCollaboratorReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsRemoveCollaboratorReq) Rel(link RelName, resp *ProjectsRemoveCollaboratorResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsRemoveCollaboratorResponse is a response for ProjectsRemoveCollaborator

https://developer.github.com/v3/projects/collaborators/#remove-user-as-a-collaborator
*/
type ProjectsRemoveCollaboratorResponse struct {
	response
	request *ProjectsRemoveCollaboratorReq
}

/*
ProjectsReviewUserPermissionLevel performs requests for "projects/review-user-permission-level"

Review a user's permission level.

  GET /projects/{project_id}/collaborators/{username}/permission

https://developer.github.com/v3/projects/collaborators/#review-a-users-permission-level
*/
func ProjectsReviewUserPermissionLevel(ctx context.Context, req *ProjectsReviewUserPermissionLevelReq, opt ...RequestOption) (*ProjectsReviewUserPermissionLevelResponse, error) {
	if req == nil {
		req = new(ProjectsReviewUserPermissionLevelReq)
	}
	resp := &ProjectsReviewUserPermissionLevelResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ProjectsReviewUserPermissionLevelResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsReviewUserPermissionLevel performs requests for "projects/review-user-permission-level"

Review a user's permission level.

  GET /projects/{project_id}/collaborators/{username}/permission

https://developer.github.com/v3/projects/collaborators/#review-a-users-permission-level
*/
func (c Client) ProjectsReviewUserPermissionLevel(ctx context.Context, req *ProjectsReviewUserPermissionLevelReq, opt ...RequestOption) (*ProjectsReviewUserPermissionLevelResponse, error) {
	return ProjectsReviewUserPermissionLevel(ctx, req, append(c, opt...)...)
}

/*
ProjectsReviewUserPermissionLevelReq is request data for Client.ProjectsReviewUserPermissionLevel

https://developer.github.com/v3/projects/collaborators/#review-a-users-permission-level
*/
type ProjectsReviewUserPermissionLevelReq struct {
	_url      string
	ProjectId int64
	Username  string

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsReviewUserPermissionLevelReq) url() string {
	return r._url
}

func (r *ProjectsReviewUserPermissionLevelReq) urlPath() string {
	return fmt.Sprintf("/projects/%v/collaborators/%v/permission", r.ProjectId, r.Username)
}

func (r *ProjectsReviewUserPermissionLevelReq) method() string {
	return "GET"
}

func (r *ProjectsReviewUserPermissionLevelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsReviewUserPermissionLevelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsReviewUserPermissionLevelReq) body() interface{} {
	return nil
}

func (r *ProjectsReviewUserPermissionLevelReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsReviewUserPermissionLevelReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsReviewUserPermissionLevelReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ProjectsReviewUserPermissionLevelReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsReviewUserPermissionLevelReq) Rel(link RelName, resp *ProjectsReviewUserPermissionLevelResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsReviewUserPermissionLevelResponseBody is a response body for ProjectsReviewUserPermissionLevel

https://developer.github.com/v3/projects/collaborators/#review-a-users-permission-level
*/
type ProjectsReviewUserPermissionLevelResponseBody struct {
	components.RepositoryCollaboratorPermission
}

/*
ProjectsReviewUserPermissionLevelResponse is a response for ProjectsReviewUserPermissionLevel

https://developer.github.com/v3/projects/collaborators/#review-a-users-permission-level
*/
type ProjectsReviewUserPermissionLevelResponse struct {
	response
	request *ProjectsReviewUserPermissionLevelReq
	Data    *ProjectsReviewUserPermissionLevelResponseBody
}

/*
ProjectsUpdate performs requests for "projects/update"

Update a project.

  PATCH /projects/{project_id}

https://developer.github.com/v3/projects/#update-a-project
*/
func ProjectsUpdate(ctx context.Context, req *ProjectsUpdateReq, opt ...RequestOption) (*ProjectsUpdateResponse, error) {
	if req == nil {
		req = new(ProjectsUpdateReq)
	}
	resp := &ProjectsUpdateResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(ProjectsUpdateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsUpdate performs requests for "projects/update"

Update a project.

  PATCH /projects/{project_id}

https://developer.github.com/v3/projects/#update-a-project
*/
func (c Client) ProjectsUpdate(ctx context.Context, req *ProjectsUpdateReq, opt ...RequestOption) (*ProjectsUpdateResponse, error) {
	return ProjectsUpdate(ctx, req, append(c, opt...)...)
}

/*
ProjectsUpdateReq is request data for Client.ProjectsUpdate

https://developer.github.com/v3/projects/#update-a-project
*/
type ProjectsUpdateReq struct {
	_url        string
	ProjectId   int64
	RequestBody ProjectsUpdateReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsUpdateReq) url() string {
	return r._url
}

func (r *ProjectsUpdateReq) urlPath() string {
	return fmt.Sprintf("/projects/%v", r.ProjectId)
}

func (r *ProjectsUpdateReq) method() string {
	return "PATCH"
}

func (r *ProjectsUpdateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsUpdateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsUpdateReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsUpdateReq) dataStatuses() []int {
	return []int{200}
}

func (r *ProjectsUpdateReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsUpdateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ProjectsUpdateReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsUpdateReq) Rel(link RelName, resp *ProjectsUpdateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsUpdateReqBody is a request body for projects/update

https://developer.github.com/v3/projects/#update-a-project
*/
type ProjectsUpdateReqBody struct {

	// The description of the project.
	Body *string `json:"body,omitempty"`

	// The name of the project.
	Name *string `json:"name,omitempty"`

	/*
	   The permission level that determines whether all members of the project's
	   organization can see and/or make changes to the project. Setting
	   `organization_permission` is only available for organization projects. If an
	   organization member belongs to a team with a higher level of access or is a
	   collaborator with a higher level of access, their permission level is not
	   lowered by `organization_permission`. For information on changing access for a
	   team or collaborator, see [Add or update team
	   project](https://developer.github.com/v3/teams/#add-or-update-team-project) or
	   [Add user as a
	   collaborator](https://developer.github.com/v3/projects/collaborators/#add-user-as-a-collaborator).

	   **Note:** Updating a project's `organization_permission` requires `admin` access
	   to the project.

	   Can be one of:
	   \* `read` - Organization members can read, but not write to or administer this
	   project.
	   \* `write` - Organization members can read and write, but not administer this
	   project.
	   \* `admin` - Organization members can read, write and administer this project.
	   \* `none` - Organization members can only see this project if it is public.
	*/
	OrganizationPermission *string `json:"organization_permission,omitempty"`

	/*
	   Sets the visibility of a project board. Setting `private` is only available for
	   organization and user projects. **Note:** Updating a project's visibility
	   requires `admin` access to the project.

	   Can be one of:
	   \* `false` - Anyone can see the project.
	   \* `true` - Only the user can view a project board created on a user account.
	   Organization members with the appropriate `organization_permission` can see
	   project boards in an organization account.
	*/
	Private *bool `json:"private,omitempty"`

	// State of the project. Either `open` or `closed`.
	State *string `json:"state,omitempty"`
}

/*
ProjectsUpdateResponseBody is a response body for ProjectsUpdate

https://developer.github.com/v3/projects/#update-a-project
*/
type ProjectsUpdateResponseBody struct {
	components.Project
}

/*
ProjectsUpdateResponse is a response for ProjectsUpdate

https://developer.github.com/v3/projects/#update-a-project
*/
type ProjectsUpdateResponse struct {
	response
	request *ProjectsUpdateReq
	Data    *ProjectsUpdateResponseBody
}

/*
ProjectsUpdateCard performs requests for "projects/update-card"

Update a project card.

  PATCH /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
func ProjectsUpdateCard(ctx context.Context, req *ProjectsUpdateCardReq, opt ...RequestOption) (*ProjectsUpdateCardResponse, error) {
	if req == nil {
		req = new(ProjectsUpdateCardReq)
	}
	resp := &ProjectsUpdateCardResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsUpdateCard performs requests for "projects/update-card"

Update a project card.

  PATCH /projects/columns/cards/{card_id}

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
func (c Client) ProjectsUpdateCard(ctx context.Context, req *ProjectsUpdateCardReq, opt ...RequestOption) (*ProjectsUpdateCardResponse, error) {
	return ProjectsUpdateCard(ctx, req, append(c, opt...)...)
}

/*
ProjectsUpdateCardReq is request data for Client.ProjectsUpdateCard

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
type ProjectsUpdateCardReq struct {
	_url        string
	CardId      int64
	RequestBody ProjectsUpdateCardReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsUpdateCardReq) url() string {
	return r._url
}

func (r *ProjectsUpdateCardReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/cards/%v", r.CardId)
}

func (r *ProjectsUpdateCardReq) method() string {
	return "PATCH"
}

func (r *ProjectsUpdateCardReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsUpdateCardReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsUpdateCardReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsUpdateCardReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsUpdateCardReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsUpdateCardReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ProjectsUpdateCardReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsUpdateCardReq) Rel(link RelName, resp *ProjectsUpdateCardResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsUpdateCardReqBody is a request body for projects/update-card

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
type ProjectsUpdateCardReqBody struct {

	/*
	   Use `true` to archive a project card. Specify `false` if you need to restore a
	   previously archived project card.
	*/
	Archived *bool `json:"archived,omitempty"`

	/*
	   The card's note content. Only valid for cards without another type of content,
	   so this cannot be specified if the card already has a `content_id` and
	   `content_type`.
	*/
	Note *string `json:"note,omitempty"`
}

/*
ProjectsUpdateCardResponse is a response for ProjectsUpdateCard

https://developer.github.com/v3/projects/cards/#update-a-project-card
*/
type ProjectsUpdateCardResponse struct {
	response
	request *ProjectsUpdateCardReq
}

/*
ProjectsUpdateColumn performs requests for "projects/update-column"

Update a project column.

  PATCH /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
func ProjectsUpdateColumn(ctx context.Context, req *ProjectsUpdateColumnReq, opt ...RequestOption) (*ProjectsUpdateColumnResponse, error) {
	if req == nil {
		req = new(ProjectsUpdateColumnReq)
	}
	resp := &ProjectsUpdateColumnResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ProjectsUpdateColumn performs requests for "projects/update-column"

Update a project column.

  PATCH /projects/columns/{column_id}

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
func (c Client) ProjectsUpdateColumn(ctx context.Context, req *ProjectsUpdateColumnReq, opt ...RequestOption) (*ProjectsUpdateColumnResponse, error) {
	return ProjectsUpdateColumn(ctx, req, append(c, opt...)...)
}

/*
ProjectsUpdateColumnReq is request data for Client.ProjectsUpdateColumn

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
type ProjectsUpdateColumnReq struct {
	_url        string
	ColumnId    int64
	RequestBody ProjectsUpdateColumnReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *ProjectsUpdateColumnReq) url() string {
	return r._url
}

func (r *ProjectsUpdateColumnReq) urlPath() string {
	return fmt.Sprintf("/projects/columns/%v", r.ColumnId)
}

func (r *ProjectsUpdateColumnReq) method() string {
	return "PATCH"
}

func (r *ProjectsUpdateColumnReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ProjectsUpdateColumnReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *ProjectsUpdateColumnReq) body() interface{} {
	return r.RequestBody
}

func (r *ProjectsUpdateColumnReq) dataStatuses() []int {
	return []int{}
}

func (r *ProjectsUpdateColumnReq) validStatuses() []int {
	return []int{200}
}

func (r *ProjectsUpdateColumnReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *ProjectsUpdateColumnReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ProjectsUpdateColumnReq) Rel(link RelName, resp *ProjectsUpdateColumnResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ProjectsUpdateColumnReqBody is a request body for projects/update-column

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
type ProjectsUpdateColumnReqBody struct {

	// The new name of the column.
	Name *string `json:"name"`
}

/*
ProjectsUpdateColumnResponse is a response for ProjectsUpdateColumn

https://developer.github.com/v3/projects/columns/#update-a-project-column
*/
type ProjectsUpdateColumnResponse struct {
	response
	request *ProjectsUpdateColumnReq
}
