package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/mitchellh/go-wordwrap"
	"github.com/willabides/octo-go/generator/internal/model"
	"github.com/willabides/octo-go/generator/internal/model/openapi"
)

func main() {
	var schemaPath string
	var outputPath string
	var pkgPath string
	var pkgName string
	flag.StringVar(&schemaPath, "schema", "", "path to openapi schema")
	flag.StringVar(&outputPath, "out", "", "directory to write all these files")
	flag.StringVar(&pkgPath, "pkgpath", "", "path for output package")
	flag.StringVar(&pkgName, "pkg", "", "name for output package")
	flag.Parse()
	err := run(schemaPath, outputPath, pkgPath, pkgName)
	if err != nil {
		log.Fatal(err)
	}
}

func run(schemaPath, outputPath, pkgPath, pkgName string) error {
	schemaFile, err := os.Open(schemaPath)
	if err != nil {
		return err
	}
	endpoints, err := openapi.EndpointsFromSchema(schemaFile)
	if err != nil {
		return err
	}

	sort.Slice(endpoints, func(i, j int) bool {
		return endpoints[i].ID < endpoints[j].ID
	})

	concernFiles := map[string]*jen.File{}

	for _, endpoint := range endpoints {
		if concernFiles[endpoint.Concern] == nil {
			cf := jen.NewFilePathName(pkgPath, pkgName)
			cf.HeaderComment("Code generated by octo-go; DO NOT EDIT.")
			concernFiles[endpoint.Concern] = cf
		}
		file := concernFiles[endpoint.Concern]
		addRequestStruct(file, endpoint)
		addRequestBody(file, endpoint)
		addResponseBodies(file, endpoint)
	}

	for concern, concernFile := range concernFiles {
		name := fmt.Sprintf("zz_%s_gen.go", strings.ReplaceAll(concern, "-", "_"))
		f, err := os.Create(filepath.Join(outputPath, name))
		if err != nil {
			return err
		}
		err = concernFile.Render(f)
		if err != nil {
			return err
		}
	}
	return nil
}

func reqBodyStructName(endpointID string) string {
	endpointID = strings.ReplaceAll(endpointID, "/", "-")
	return toArgName(fmt.Sprintf("%s-req-body", endpointID))
}

func reqStructName(endpoint model.Endpoint) string {
	return toArgName(fmt.Sprintf("%s-%s-req", endpoint.Concern, endpoint.Name))
}

func respStructName(endpoint model.Endpoint, code int) string {
	return toArgName(fmt.Sprintf("%s-%s-response-body%d", endpoint.Concern, endpoint.Name, code))
}

func toArgName(in string) string {
	out := in
	for _, separator := range []string{"_", "-", ".", "/"} {
		words := strings.Split(out, separator)
		for i, word := range words {
			words[i] = strings.Title(word)
		}
		out = strings.Join(words, "")
	}
	return out
}

func addRequestStruct(file *jen.File, endpoint model.Endpoint) {
	structName := reqStructName(endpoint)
	file.Commentf("%s builds requests for \"%s\"\n\n%s.\n\n  %s %s\n\n%s",
		structName,
		endpoint.ID,
		endpoint.Summary,
		endpoint.Method,
		endpoint.Path,
		endpoint.DocsURL,
	)
	file.Type().Id(structName).StructFunc(func(group *jen.Group) {
		for _, param := range endpoint.PathParams {
			if param.HelpText != "" {
				group.Line().Comment(wordwrap.WrapString(param.HelpText, 80))
			}
			group.Id(toArgName(param.Name)).Add(paramSchemaFieldType(param.Schema, []string{endpoint.ID, "PATH_PARAMS"}, false, false))
		}
		for _, param := range endpoint.QueryParams {
			if param.HelpText != "" {
				group.Line().Comment(wordwrap.WrapString(param.HelpText, 80))
			}
			group.Id(toArgName(param.Name)).Op("*").Add(paramSchemaFieldType(param.Schema, []string{endpoint.ID, "QUERY_PARAMS"}, true, false))
		}
		if endpoint.JSONBodySchema != nil {
			group.Id("RequestBody").Id(reqBodyStructName(endpoint.ID))
		}
		for _, param := range endpoint.Headers {
			if param.Name == "accept" {
				continue
			}
			if param.HelpText != "" {
				group.Line().Comment(wordwrap.WrapString(param.HelpText, 80))
			}
			group.Id(toArgName(param.Name + "-header")).Op("*").Add(paramSchemaFieldType(param.Schema, []string{endpoint.ID, "QUERY_PARAMS"}, true, false))
		}
		for _, preview := range endpoint.Previews {
			if preview.Note != "" {
				group.Line().Comment(wordwrap.WrapString(fixPreviewNote(preview.Note), 80))
			}
			group.Id(toArgName(preview.Name + "-preview")).Bool()
		}
	})

	file.Add(endpointURLPathFunc(endpoint))
	file.Line()
	file.Func().Params(jen.Id("r").Id(structName)).Id("method").Params().String().Block(
		jen.Return(jen.Lit(endpoint.Method)),
	)
	file.Line()
	queryFunc := endpointURLQueryFunc(endpoint)
	if queryFunc != nil {
		file.Add(queryFunc)
		file.Line()
	}
	headerFunc := endpointHeadersFunc(endpoint)
	if headerFunc != nil {
		file.Add(headerFunc)
		file.Line()
	}
	for _, stmt := range endpointHTTPRequestFunc(endpoint) {
		file.Add(stmt)
	}
}

func endpointHTTPRequestFunc(endpoint model.Endpoint) []*jen.Statement {
	structName := reqStructName(endpoint)
	stmt := jen.Func().Params(jen.Id("r").Id(structName)).Id("HTTPRequest").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("opt ...RequestOption"),
	)
	stmt.Params(jen.Op("*").Qual("net/http", "Request"), jen.Error())
	stmt.BlockFunc(func(funcBlock *jen.Group) {
		if endpoint.JSONBodySchema == nil {
			funcBlock.Return(jen.Id(`httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)`))
		} else {
			funcBlock.Return(jen.Id(`httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), r.RequestBody, opt)`))
		}
	})
	return []*jen.Statement{jen.Comment("HTTPRequest creates an http request"), stmt}
}

func endpointHeadersFunc(endpoint model.Endpoint) *jen.Statement {
	if len(endpoint.Headers)+len(endpoint.Previews) == 0 {
		return nil
	}
	structName := reqStructName(endpoint)
	stmt := jen.Func().Params(jen.Id("r").Id(structName)).Id("header").Params().Qual("net/http", "Header")
	stmt.BlockFunc(func(fnBlock *jen.Group) {
		fnBlock.Id("headerVals").Op(":=").Map(jen.String()).Op("*").String().Values(
			jen.DictFunc(func(dict jen.Dict) {
				for _, header := range endpoint.Headers {
					if header.Name == "accept" {
						continue
					}
					dict[jen.Lit(header.Name)] = jen.Id("r").Dot(toArgName(header.Name + "-header"))
				}
			}),
		)
		fnBlock.Id("previewVals").Op(":=").Map(jen.String()).Bool().Values(
			jen.DictFunc(func(dict jen.Dict) {
				for _, preview := range endpoint.Previews {
					dict[jen.Lit(preview.Name)] = jen.Id("r").Dot(toArgName(preview.Name + "-preview"))
				}
			}),
		)
		fnBlock.Return(jen.Id("requestHeaders")).Params(
			jen.Id("headerVals"),
			jen.Id("previewVals"),
		)
	})
	return stmt
}

func endpointURLPathFunc(endpoint model.Endpoint) *jen.Statement {
	structName := reqStructName(endpoint)
	return jen.Func().Params(jen.Id("r").Id(structName)).Id("urlPath").Params().String().
		BlockFunc(func(group *jen.Group) {
			pth := bracesExp.ReplaceAllString(endpoint.Path, "%v")
			group.Return(jen.Qual("fmt", "Sprintf").ParamsFunc(func(group *jen.Group) {
				group.Lit(pth)
				for _, param := range endpoint.PathParams {
					group.Id("r").Dot(toArgName(param.Name))
				}
			}))
		})
}

func endpointURLQueryFunc(endpoint model.Endpoint) *jen.Statement {
	structName := reqStructName(endpoint)
	stmt := jen.Func().Params(jen.Id("r").Id(structName)).Id("urlQuery").Params()
	stmt.Qual("net/url", "Values")
	stmt.BlockFunc(func(group *jen.Group) {
		group.Id("query").Op(":=").Qual("net/url", "Values").Block()

		for _, param := range endpoint.QueryParams {
			paramArg := jen.Id("r").Dot(toArgName(param.Name))
			group.If(paramArg.Clone().Op("!=").Nil()).BlockFunc(func(ifGroup *jen.Group) {
				var valStmt *jen.Statement
				switch param.Schema.Type {
				case model.ParamTypeString:
					valStmt = jen.Op("*").Add(paramArg)
				case model.ParamTypeInt:
					valStmt = jen.Qual("strconv", "FormatInt").Params(jen.Op("*").Add(paramArg), jen.Lit(10))
				case model.ParamTypeBool:
					valStmt = jen.Qual("strconv", "FormatBool").Params(jen.Op("*").Add(paramArg))
				default:
					fmt.Printf("UNEXPECTED %v\n", param)
				}
				ifGroup.Id("query").Dot("Set").Params(jen.Lit(param.Name), valStmt)
			})
		}
		group.Return(jen.Id("query"))
	})
	return stmt
}

var bracesExp = regexp.MustCompile(`{[^}]+}`)

func addResponseBodies(file *jen.File, endpoint model.Endpoint) {
	if len(endpoint.Responses) == 0 {
		return
	}
	sortedCodes := make([]int, 0, len(endpoint.Responses))
	for code := range endpoint.Responses {
		sortedCodes = append(sortedCodes, code)
	}
	sort.Ints(sortedCodes)
	for _, respCode := range sortedCodes {
		schema := endpoint.Responses[respCode]
		tp := paramSchemaFieldType(schema, []string{endpoint.ID, "responseBody", strconv.Itoa(respCode)}, false, false)
		if tp == nil {
			continue
		}
		structName := respStructName(endpoint, respCode)
		file.Commentf("%s is a response body for %s\n\nAPI documentation: %s",
			structName,
			endpoint.ID,
			endpoint.DocsURL,
		)
		file.Type().Id(respStructName(endpoint, respCode)).Add(tp)
	}
}

func addRequestBodyHelpers(file *jen.File, endpoint model.Endpoint) {
	if endpoint.JSONBodySchema == nil {
		return
	}
	stmts := reqBodyHelperStructs([]string{endpoint.ID, "reqBody"}, endpoint.JSONBodySchema)
	for _, stmt := range stmts {
		file.Add(stmt)
	}
}

func removeValFromStringSlice(sl []string, val string) []string {
	result := make([]string, 0, len(sl))
	for _, s := range sl {
		if s != val {
			result = append(result, s)
		}
	}
	return result
}

func reqBodyHelperStructs(schemaPath []string, schema *model.ParamSchema) []*jen.Statement {
	var result []*jen.Statement
	helperName := reqBodyHelperStructName(schemaPath, schema)
	if helperName != "" {
		tp := paramSchemaFieldType(schema, schemaPath, true, true)
		sp := removeValFromStringSlice(schemaPath, "ITEM_SCHEMA")
		parentStructName := toArgName(strings.Join(sp[:len(sp)-1], "-"))
		parentValueName := toArgName(sp[len(sp)-1])
		comment := fmt.Sprintf("%s is a value for %s's %s field", helperName, parentStructName, parentValueName)
		result = append(result, jen.Comment(comment))
		result = append(result, jen.Type().Id(helperName).Add(tp))
	}
	if schema.ItemSchema != nil {
		result = append(result, reqBodyHelperStructs(append(schemaPath, "ITEM_SCHEMA"), schema.ItemSchema)...)
	}
	for _, param := range schema.ObjectParams {
		nr := reqBodyHelperStructs(append(schemaPath, param.Name), param.Schema)
		result = append(result, nr...)
	}
	return result
}

func reqBodyHelperStructName(schemaPath []string, schema *model.ParamSchema) string {
	//We don't want ITEM_SCHEMA in the name, and removing it doesn't cause duplicate struct names
	sp := removeValFromStringSlice(schemaPath, "ITEM_SCHEMA")

	if len(sp) < 3 {
		return ""
	}
	if schemaPath[1] != "reqBody" {
		return ""
	}
	if len(schema.ObjectParams) == 0 {
		return ""
	}
	suffix := toArgName(strings.Join(sp[2:], "-"))
	return reqBodyStructName(sp[0]) + suffix
}

func addRequestBody(file *jen.File, endpoint model.Endpoint) {
	addRequestBodyHelpers(file, endpoint)
	if endpoint.JSONBodySchema == nil {
		return
	}
	tp := paramSchemaFieldType(endpoint.JSONBodySchema, []string{endpoint.ID, "reqBody"}, true, false)
	if tp == nil {
		return
	}

	structName := reqBodyStructName(endpoint.ID)
	file.Commentf("%s is a request body for %s\n\nAPI documentation: %s",
		structName,
		endpoint.ID,
		endpoint.DocsURL,
	)
	file.Type().Id(structName).Add(tp)
}

func schemaPathString(schemaPath []string) string {
	return strings.Join(schemaPath, "/")
}

var schemaOverrides = []func(schemaPath []string, schema *model.ParamSchema){
	// list-languages returns a map
	func(schemaPath []string, schema *model.ParamSchema) {
		if schemaPathString(schemaPath) != "repos/list-languages/responseBody/200" {
			return
		}
		schema.Type = model.ParamTypeObject
		schema.ObjectParams = nil
		schema.ItemSchema = &model.ParamSchema{
			Type: model.ParamTypeInt,
		}
	},

	// reactions are maps
	func(schemaPath []string, schema *model.ParamSchema) {
		if !strings.HasSuffix(schemaPathString(schemaPath), "/reactions") || schema.Type != model.ParamTypeObject {
			return
		}
		var found bool
		for _, objectParam := range schema.ObjectParams {
			if objectParam.Name == "+1" {
				found = true
				break
			}
		}
		if !found {
			return
		}
		schema.ObjectParams = nil
		schema.ItemSchema = &model.ParamSchema{
			Type: model.ParamTypeInt,
		}
	},
	// a lot of numbers should be integers
	func(schemaPath []string, schema *model.ParamSchema) {
		if schema.Type != model.ParamTypeNumber {
			return
		}
		suffixes := []string{
			"_count",
			"/count",
			"/id",
			"_id",
			"price_in_cents",
			"/comments",
			"/commits",
			"/total_private_repos",
			"/total_commits",
			"/total_ms",
			"/total",
			"/totalResults",
			"/additions",
			"/deletions",
			"_issues",
			"/line",
			"_line",
			"/number",
			"_number",
			"_repos",
			"/startIndex",
			"_position",
			"/position",
			"/jobs",
			"/ahead_by",
			"/behind_by",
			"/changed_files",
			"/changes",
			"/collaborators",
			"/contributions",
			"/duration",
			"/uniques",
			"/week",
			"/limit",
			"/itemsPerPage",
			"_gists",
			"/followers",
			"/remaining",
			"/following",
			"_column",
			"/reset",
			"/size_in_bytes",
			"_comments",
			"/run_duration_ms",
			"weeks/ITEM_SCHEMA/a",
			"weeks/ITEM_SCHEMA/c",
			"weeks/ITEM_SCHEMA/d",
			"repos/get-punch-card-stats/responseBody/200/ITEM_SCHEMA/ITEM_SCHEMA",
			"repos/get-code-frequency-stats/responseBody/200/ITEM_SCHEMA/ITEM_SCHEMA",
			"repos/get-participation-stats/responseBody/200/all/ITEM_SCHEMA",
			"repos/get-participation-stats/responseBody/200/owner/ITEM_SCHEMA",
			"repos/get-commit-activity-stats/responseBody/200/ITEM_SCHEMA/days/ITEM_SCHEMA",
		}
		sPath := schemaPathString(schemaPath)
		for _, suffix := range suffixes {
			if strings.HasSuffix(sPath, suffix) {
				schema.Type = model.ParamTypeInt
				return
			}
		}
	},
}

func overrideParamSchema(schemaPath []string, schema *model.ParamSchema) {
	if schema == nil {
		return
	}
	for _, override := range schemaOverrides {
		override(schemaPath, schema)
	}
}

func paramSchemaFieldType(schema *model.ParamSchema, schemaPath []string, usePointers, noHelper bool) *jen.Statement {
	overrideParamSchema(schemaPath, schema)

	helperStruct := reqBodyHelperStructName(schemaPath, schema)
	if !noHelper && helperStruct != "" {
		return jen.Id(helperStruct)
	}

	if schema == nil {
		return nil
	}
	switch schema.Type {
	case model.ParamTypeString:
		return jen.String()
	case model.ParamTypeInt:
		return jen.Int64()
	case model.ParamTypeBool:
		return jen.Bool()
	case model.ParamTypeNumber:
		return jen.Qual("encoding/json", "Number")
	case model.ParamTypeInterface:
		return jen.Interface()
	case model.ParamTypeArray:
		return jen.Id("[]").Add(paramSchemaFieldType(schema.ItemSchema, append(schemaPath, "ITEM_SCHEMA"), usePointers, false))
	case model.ParamTypeObject:
		return paramSchemaObjectFieldType(schema, schemaPath, usePointers)
	}
	return nil
}

func paramSchemaObjectFieldType(schema *model.ParamSchema, schemaPath []string, usePointers bool) *jen.Statement {
	if len(schema.ObjectParams) > 0 {
		return jen.StructFunc(func(group *jen.Group) {
			for _, param := range schema.ObjectParams {
				if param.HelpText != "" {
					group.Line()
				}
				gStmt := jen.Id(toArgName(param.Name))
				pType := paramSchemaFieldType(param.Schema, append(schemaPath, param.Name), usePointers, false)
				if usePointers && needsPointer(param.Schema) {
					gStmt.Op("*")
				}
				jsonTag := param.Name
				if !param.Required {
					jsonTag += ",omitempty"
				}
				if param.HelpText != "" {
					group.Comment(wordwrap.WrapString(param.HelpText, 80))
				}
				group.Add(gStmt.Add(pType).Tag(map[string]string{
					"json": jsonTag,
				}))
			}
		})
	}
	if schema.ItemSchema != nil {
		stmt := jen.Map(jen.String())
		if usePointers && needsPointer(schema.ItemSchema) {
			stmt.Op("*")
		}
		return stmt.Add(paramSchemaFieldType(schema.ItemSchema, append(schemaPath, "ITEM_SCHEMA"), usePointers, false))
	}
	return jen.Interface()
}

func needsPointer(schema *model.ParamSchema) bool {
	if schema.Type == model.ParamTypeInterface {
		return false
	}
	if schema.Type == model.ParamTypeArray {
		return false
	}
	if schema.Type == model.ParamTypeObject && len(schema.ObjectParams) == 0 {
		return false
	}
	return true
}

func fixPreviewNote(note string) string {
	note = strings.TrimSpace(note)
	note = strings.Split(note, "```")[0]
	note = strings.TrimSpace(note)
	setThisFlagPhrases := []string{
		"provide a custom [media type](https://developer.github.com/v3/media) in the `Accept` header",
		"provide a custom [media type](https://developer.github.com/v3/media) in the `Accept` Header",
		"provide the following custom [media type](https://developer.github.com/v3/media) in the `Accept` header",
	}
	for _, phrase := range setThisFlagPhrases {
		note = strings.ReplaceAll(note, phrase, "set this to true")
	}
	note = strings.TrimSpace(note)
	note = strings.TrimSuffix(note, ":")
	note = strings.TrimSpace(note)
	note = strings.TrimSuffix(note, ".") + "."
	return note
}
