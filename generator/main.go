package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/willabides/octo-go/generator/internal/model"
	"github.com/willabides/octo-go/generator/internal/model/openapi"
)

func main() {
	var schemaPath string
	var outputPath string
	var pkgPath string
	var pkgName string
	flag.StringVar(&schemaPath, "schema", "", "path to openapi schema")
	flag.StringVar(&outputPath, "out", "", "directory to write all these files")
	flag.StringVar(&pkgPath, "pkgpath", "", "path for output package")
	flag.StringVar(&pkgName, "pkg", "", "name for output package")
	flag.Parse()
	err := run(schemaPath, outputPath, pkgPath, pkgName)
	if err != nil {
		log.Fatal(err)
	}
}

func run(schemaPath, outputPath, pkgPath, pkgName string) error {
	err := componentExampleFiles(schemaPath, filepath.Join(outputPath, "components", "examples"))
	if err != nil {
		return err
	}
	schemaFile, err := os.Open(schemaPath)
	if err != nil {
		return err
	}
	mdl, err := openapi.Openapi2Model(schemaFile)
	if err != nil {
		return err
	}
	endpoints := mdl.Endpoints

	sort.Slice(endpoints, func(i, j int) bool {
		return endpoints[i].ID < endpoints[j].ID
	})

	concernFiles := map[string]*jen.File{}

	for _, endpoint := range endpoints {
		err = addEndpointToConcernFiles(endpoint, concernFiles, pkgPath, pkgName)
		if err != nil {
			return err
		}
	}

	for concern, concernFile := range concernFiles {
		// zz_licenses_gen.go causes issues with license file detection on GitHub
		if concern == "licenses" {
			concern = "lic"
		}
		name := fmt.Sprintf("zz_%s_gen.go", strings.ReplaceAll(concern, "-", "_"))
		var f *os.File
		f, err = os.Create(filepath.Join(outputPath, name))
		if err != nil {
			return err
		}
		err = concernFile.Render(f)
		if err != nil {
			return err
		}
	}

	componentSchemas := mdl.ComponentSchemas
	if len(componentSchemas) > 0 {
		filename := "schemas_gen.go"
		var f *os.File
		f, err = os.Create(filepath.Join(outputPath, "components", filename))
		if err != nil {
			return err
		}
		cf := jen.NewFilePath(path.Join(pkgPath, "components"))
		cf.HeaderComment("Code generated by octo-go; DO NOT EDIT.")
		addComponentSchemas(cf, componentSchemas)
		err = cf.Render(f)
		if err != nil {
			return err
		}
	}

	endpointAttrsOut, err := os.Create(filepath.Join(outputPath, "zz_endpoint_attrs_gen.go"))
	if err != nil {
		return err
	}
	endpointAttrsFile := jen.NewFilePathName(pkgPath, pkgName)
	endpointAttrsFile.HeaderComment("Code generated by octo-go; DO NOT EDIT.")
	addEndpointAttributes(endpointAttrsFile)
	err = endpointAttrsFile.Render(endpointAttrsOut)
	if err != nil {
		return err
	}

	err = generateUnmarshalTests(outputPath, endpoints)
	if err != nil {
		return err
	}

	return nil
}

func addEndpointToConcernFiles(endpoint model.Endpoint, concernFiles map[string]*jen.File, pkgPath, pkgName string) error {
	endpoint = endpointWithOverrides(endpoint)
	if endpoint.Legacy {
		return nil
	}
	if len(endpoint.Requests) > 1 {
		// better safe than sorry.  check on what triggers this and make sure it's handled right.
		return fmt.Errorf("we've never had an endpoint with multiple requests before. endpoint: %s", endpoint.ID)
	}
	if concernFiles[endpoint.Concern] == nil {
		cf := jen.NewFilePathName(pkgPath, pkgName)
		cf.HeaderComment("Code generated by octo-go; DO NOT EDIT.")
		concernFiles[endpoint.Concern] = cf
	}
	file := concernFiles[endpoint.Concern]
	addRequestFunc(file, endpoint)
	addClientMethod(file, endpoint)
	addRequestStruct(file, endpoint)
	addRequestBody(file, endpoint)
	addResponseBody(file, endpoint)
	addResponse(file, endpoint)
	return nil
}
