// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
OauthAuthorizationsCreateAuthorization performs requests for "oauth-authorizations/create-authorization"

Create a new authorization.

  POST /authorizations

https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization
*/
func OauthAuthorizationsCreateAuthorization(ctx context.Context, req *OauthAuthorizationsCreateAuthorizationReq, opt ...options.Option) (*OauthAuthorizationsCreateAuthorizationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OauthAuthorizationsCreateAuthorizationReq)
	}
	resp := &OauthAuthorizationsCreateAuthorizationResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OauthAuthorizationsCreateAuthorization performs requests for "oauth-authorizations/create-authorization"

Create a new authorization.

  POST /authorizations

https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization
*/
func (c Client) OauthAuthorizationsCreateAuthorization(ctx context.Context, req *OauthAuthorizationsCreateAuthorizationReq, opt ...options.Option) (*OauthAuthorizationsCreateAuthorizationResponse, error) {
	return OauthAuthorizationsCreateAuthorization(ctx, req, append(c, opt...)...)
}

/*
OauthAuthorizationsCreateAuthorizationReq is request data for Client.OauthAuthorizationsCreateAuthorization

https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization
*/
type OauthAuthorizationsCreateAuthorizationReq struct {
	_url        string
	RequestBody OauthAuthorizationsCreateAuthorizationReqBody
}

// HTTPRequest builds an *http.Request
func (r *OauthAuthorizationsCreateAuthorizationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OauthAuthorizationsCreateAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "oauth-authorizations/create-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OauthAuthorizationsCreateAuthorizationReq) Rel(link RelName, resp *OauthAuthorizationsCreateAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OauthAuthorizationsCreateAuthorizationReqBody is a request body for oauth-authorizations/create-authorization

https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization
*/
type OauthAuthorizationsCreateAuthorizationReqBody struct {

	// The OAuth app client key for which to create the token.
	ClientId *string `json:"client_id,omitempty"`

	// The OAuth app client secret for which to create the token.
	ClientSecret *string `json:"client_secret,omitempty"`

	// A unique string to distinguish an authorization from others created for the same client ID and user.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// A note to remind you what the OAuth token is for.
	Note *string `json:"note,omitempty"`

	// A URL to remind you what app the OAuth token is for.
	NoteUrl *string `json:"note_url,omitempty"`

	// A list of scopes that this authorization is in.
	Scopes []string `json:"scopes,omitempty"`
}

/*
OauthAuthorizationsCreateAuthorizationResponse is a response for OauthAuthorizationsCreateAuthorization

https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization
*/
type OauthAuthorizationsCreateAuthorizationResponse struct {
	internal.Response
	request *OauthAuthorizationsCreateAuthorizationReq
	Data    components.Authorization
}

/*
OauthAuthorizationsDeleteAuthorization performs requests for "oauth-authorizations/delete-authorization"

Delete an authorization.

  DELETE /authorizations/{authorization_id}

https://developer.github.com/v3/oauth_authorizations/#delete-an-authorization
*/
func OauthAuthorizationsDeleteAuthorization(ctx context.Context, req *OauthAuthorizationsDeleteAuthorizationReq, opt ...options.Option) (*OauthAuthorizationsDeleteAuthorizationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OauthAuthorizationsDeleteAuthorizationReq)
	}
	resp := &OauthAuthorizationsDeleteAuthorizationResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OauthAuthorizationsDeleteAuthorization performs requests for "oauth-authorizations/delete-authorization"

Delete an authorization.

  DELETE /authorizations/{authorization_id}

https://developer.github.com/v3/oauth_authorizations/#delete-an-authorization
*/
func (c Client) OauthAuthorizationsDeleteAuthorization(ctx context.Context, req *OauthAuthorizationsDeleteAuthorizationReq, opt ...options.Option) (*OauthAuthorizationsDeleteAuthorizationResponse, error) {
	return OauthAuthorizationsDeleteAuthorization(ctx, req, append(c, opt...)...)
}

/*
OauthAuthorizationsDeleteAuthorizationReq is request data for Client.OauthAuthorizationsDeleteAuthorization

https://developer.github.com/v3/oauth_authorizations/#delete-an-authorization
*/
type OauthAuthorizationsDeleteAuthorizationReq struct {
	_url string

	// authorization_id parameter
	AuthorizationId int64
}

// HTTPRequest builds an *http.Request
func (r *OauthAuthorizationsDeleteAuthorizationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OauthAuthorizationsDeleteAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "oauth-authorizations/delete-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations/%v", r.AuthorizationId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OauthAuthorizationsDeleteAuthorizationReq) Rel(link RelName, resp *OauthAuthorizationsDeleteAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OauthAuthorizationsDeleteAuthorizationResponse is a response for OauthAuthorizationsDeleteAuthorization

https://developer.github.com/v3/oauth_authorizations/#delete-an-authorization
*/
type OauthAuthorizationsDeleteAuthorizationResponse struct {
	internal.Response
	request *OauthAuthorizationsDeleteAuthorizationReq
}

/*
OauthAuthorizationsDeleteGrant performs requests for "oauth-authorizations/delete-grant"

Delete a grant.

  DELETE /applications/grants/{grant_id}

https://developer.github.com/v3/oauth_authorizations/#delete-a-grant
*/
func OauthAuthorizationsDeleteGrant(ctx context.Context, req *OauthAuthorizationsDeleteGrantReq, opt ...options.Option) (*OauthAuthorizationsDeleteGrantResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OauthAuthorizationsDeleteGrantReq)
	}
	resp := &OauthAuthorizationsDeleteGrantResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OauthAuthorizationsDeleteGrant performs requests for "oauth-authorizations/delete-grant"

Delete a grant.

  DELETE /applications/grants/{grant_id}

https://developer.github.com/v3/oauth_authorizations/#delete-a-grant
*/
func (c Client) OauthAuthorizationsDeleteGrant(ctx context.Context, req *OauthAuthorizationsDeleteGrantReq, opt ...options.Option) (*OauthAuthorizationsDeleteGrantResponse, error) {
	return OauthAuthorizationsDeleteGrant(ctx, req, append(c, opt...)...)
}

/*
OauthAuthorizationsDeleteGrantReq is request data for Client.OauthAuthorizationsDeleteGrant

https://developer.github.com/v3/oauth_authorizations/#delete-a-grant
*/
type OauthAuthorizationsDeleteGrantReq struct {
	_url string

	// grant_id parameter
	GrantId int64
}

// HTTPRequest builds an *http.Request
func (r *OauthAuthorizationsDeleteGrantReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OauthAuthorizationsDeleteGrantReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "oauth-authorizations/delete-grant",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/grants/%v", r.GrantId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OauthAuthorizationsDeleteGrantReq) Rel(link RelName, resp *OauthAuthorizationsDeleteGrantResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OauthAuthorizationsDeleteGrantResponse is a response for OauthAuthorizationsDeleteGrant

https://developer.github.com/v3/oauth_authorizations/#delete-a-grant
*/
type OauthAuthorizationsDeleteGrantResponse struct {
	internal.Response
	request *OauthAuthorizationsDeleteGrantReq
}

/*
OauthAuthorizationsGetAuthorization performs requests for "oauth-authorizations/get-authorization"

Get a single authorization.

  GET /authorizations/{authorization_id}

https://developer.github.com/v3/oauth_authorizations/#get-a-single-authorization
*/
func OauthAuthorizationsGetAuthorization(ctx context.Context, req *OauthAuthorizationsGetAuthorizationReq, opt ...options.Option) (*OauthAuthorizationsGetAuthorizationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OauthAuthorizationsGetAuthorizationReq)
	}
	resp := &OauthAuthorizationsGetAuthorizationResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OauthAuthorizationsGetAuthorization performs requests for "oauth-authorizations/get-authorization"

Get a single authorization.

  GET /authorizations/{authorization_id}

https://developer.github.com/v3/oauth_authorizations/#get-a-single-authorization
*/
func (c Client) OauthAuthorizationsGetAuthorization(ctx context.Context, req *OauthAuthorizationsGetAuthorizationReq, opt ...options.Option) (*OauthAuthorizationsGetAuthorizationResponse, error) {
	return OauthAuthorizationsGetAuthorization(ctx, req, append(c, opt...)...)
}

/*
OauthAuthorizationsGetAuthorizationReq is request data for Client.OauthAuthorizationsGetAuthorization

https://developer.github.com/v3/oauth_authorizations/#get-a-single-authorization
*/
type OauthAuthorizationsGetAuthorizationReq struct {
	_url string

	// authorization_id parameter
	AuthorizationId int64
}

// HTTPRequest builds an *http.Request
func (r *OauthAuthorizationsGetAuthorizationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OauthAuthorizationsGetAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "oauth-authorizations/get-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations/%v", r.AuthorizationId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OauthAuthorizationsGetAuthorizationReq) Rel(link RelName, resp *OauthAuthorizationsGetAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OauthAuthorizationsGetAuthorizationResponse is a response for OauthAuthorizationsGetAuthorization

https://developer.github.com/v3/oauth_authorizations/#get-a-single-authorization
*/
type OauthAuthorizationsGetAuthorizationResponse struct {
	internal.Response
	request *OauthAuthorizationsGetAuthorizationReq
	Data    components.Authorization
}

/*
OauthAuthorizationsGetGrant performs requests for "oauth-authorizations/get-grant"

Get a single grant.

  GET /applications/grants/{grant_id}

https://developer.github.com/v3/oauth_authorizations/#get-a-single-grant
*/
func OauthAuthorizationsGetGrant(ctx context.Context, req *OauthAuthorizationsGetGrantReq, opt ...options.Option) (*OauthAuthorizationsGetGrantResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OauthAuthorizationsGetGrantReq)
	}
	resp := &OauthAuthorizationsGetGrantResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ApplicationGrant{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OauthAuthorizationsGetGrant performs requests for "oauth-authorizations/get-grant"

Get a single grant.

  GET /applications/grants/{grant_id}

https://developer.github.com/v3/oauth_authorizations/#get-a-single-grant
*/
func (c Client) OauthAuthorizationsGetGrant(ctx context.Context, req *OauthAuthorizationsGetGrantReq, opt ...options.Option) (*OauthAuthorizationsGetGrantResponse, error) {
	return OauthAuthorizationsGetGrant(ctx, req, append(c, opt...)...)
}

/*
OauthAuthorizationsGetGrantReq is request data for Client.OauthAuthorizationsGetGrant

https://developer.github.com/v3/oauth_authorizations/#get-a-single-grant
*/
type OauthAuthorizationsGetGrantReq struct {
	_url string

	// grant_id parameter
	GrantId int64
}

// HTTPRequest builds an *http.Request
func (r *OauthAuthorizationsGetGrantReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OauthAuthorizationsGetGrantReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "oauth-authorizations/get-grant",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/grants/%v", r.GrantId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OauthAuthorizationsGetGrantReq) Rel(link RelName, resp *OauthAuthorizationsGetGrantResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OauthAuthorizationsGetGrantResponse is a response for OauthAuthorizationsGetGrant

https://developer.github.com/v3/oauth_authorizations/#get-a-single-grant
*/
type OauthAuthorizationsGetGrantResponse struct {
	internal.Response
	request *OauthAuthorizationsGetGrantReq
	Data    components.ApplicationGrant
}

/*
OauthAuthorizationsGetOrCreateAuthorizationForApp performs requests for "oauth-authorizations/get-or-create-authorization-for-app"

Get-or-create an authorization for a specific app.

  PUT /authorizations/clients/{client_id}

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app
*/
func OauthAuthorizationsGetOrCreateAuthorizationForApp(ctx context.Context, req *OauthAuthorizationsGetOrCreateAuthorizationForAppReq, opt ...options.Option) (*OauthAuthorizationsGetOrCreateAuthorizationForAppResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OauthAuthorizationsGetOrCreateAuthorizationForAppReq)
	}
	resp := &OauthAuthorizationsGetOrCreateAuthorizationForAppResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OauthAuthorizationsGetOrCreateAuthorizationForApp performs requests for "oauth-authorizations/get-or-create-authorization-for-app"

Get-or-create an authorization for a specific app.

  PUT /authorizations/clients/{client_id}

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app
*/
func (c Client) OauthAuthorizationsGetOrCreateAuthorizationForApp(ctx context.Context, req *OauthAuthorizationsGetOrCreateAuthorizationForAppReq, opt ...options.Option) (*OauthAuthorizationsGetOrCreateAuthorizationForAppResponse, error) {
	return OauthAuthorizationsGetOrCreateAuthorizationForApp(ctx, req, append(c, opt...)...)
}

/*
OauthAuthorizationsGetOrCreateAuthorizationForAppReq is request data for Client.OauthAuthorizationsGetOrCreateAuthorizationForApp

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app
*/
type OauthAuthorizationsGetOrCreateAuthorizationForAppReq struct {
	_url        string
	ClientId    string
	RequestBody OauthAuthorizationsGetOrCreateAuthorizationForAppReqBody
}

// HTTPRequest builds an *http.Request
func (r *OauthAuthorizationsGetOrCreateAuthorizationForAppReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OauthAuthorizationsGetOrCreateAuthorizationForAppReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200, 201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "oauth-authorizations/get-or-create-authorization-for-app",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations/clients/%v", r.ClientId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OauthAuthorizationsGetOrCreateAuthorizationForAppReq) Rel(link RelName, resp *OauthAuthorizationsGetOrCreateAuthorizationForAppResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OauthAuthorizationsGetOrCreateAuthorizationForAppReqBody is a request body for oauth-authorizations/get-or-create-authorization-for-app

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app
*/
type OauthAuthorizationsGetOrCreateAuthorizationForAppReqBody struct {

	// The OAuth app client secret for which to create the token.
	ClientSecret *string `json:"client_secret"`

	// A unique string to distinguish an authorization from others created for the same client ID and user.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// A note to remind you what the OAuth token is for.
	Note *string `json:"note,omitempty"`

	// A URL to remind you what app the OAuth token is for.
	NoteUrl *string `json:"note_url,omitempty"`

	// A list of scopes that this authorization is in.
	Scopes []string `json:"scopes,omitempty"`
}

/*
OauthAuthorizationsGetOrCreateAuthorizationForAppResponse is a response for OauthAuthorizationsGetOrCreateAuthorizationForApp

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app
*/
type OauthAuthorizationsGetOrCreateAuthorizationForAppResponse struct {
	internal.Response
	request *OauthAuthorizationsGetOrCreateAuthorizationForAppReq
	Data    components.Authorization
}

/*
OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint performs requests for "oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint"

Get-or-create an authorization for a specific app and fingerprint.

  PUT /authorizations/clients/{client_id}/{fingerprint}

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app-and-fingerprint
*/
func OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx context.Context, req *OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq, opt ...options.Option) (*OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq)
	}
	resp := &OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint performs requests for "oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint"

Get-or-create an authorization for a specific app and fingerprint.

  PUT /authorizations/clients/{client_id}/{fingerprint}

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app-and-fingerprint
*/
func (c Client) OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx context.Context, req *OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq, opt ...options.Option) (*OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse, error) {
	return OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx, req, append(c, opt...)...)
}

/*
OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq is request data for Client.OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app-and-fingerprint
*/
type OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq struct {
	_url     string
	ClientId string

	// fingerprint parameter
	Fingerprint string
	RequestBody OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReqBody
}

// HTTPRequest builds an *http.Request
func (r *OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200, 201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations/clients/%v/%v", r.ClientId, r.Fingerprint),
		URLQuery:         query,
		ValidStatuses:    []int{200, 201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) Rel(link RelName, resp *OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReqBody is a request body for oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app-and-fingerprint
*/
type OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReqBody struct {

	// The OAuth app client secret for which to create the token.
	ClientSecret *string `json:"client_secret"`

	// A note to remind you what the OAuth token is for.
	Note *string `json:"note,omitempty"`

	// A URL to remind you what app the OAuth token is for.
	NoteUrl *string `json:"note_url,omitempty"`

	// A list of scopes that this authorization is in.
	Scopes []string `json:"scopes,omitempty"`
}

/*
OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse is a response for OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint

https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app-and-fingerprint
*/
type OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse struct {
	internal.Response
	request *OauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq
	Data    components.Authorization
}

/*
OauthAuthorizationsListAuthorizations performs requests for "oauth-authorizations/list-authorizations"

List your authorizations.

  GET /authorizations

https://developer.github.com/v3/oauth_authorizations/#list-your-authorizations
*/
func OauthAuthorizationsListAuthorizations(ctx context.Context, req *OauthAuthorizationsListAuthorizationsReq, opt ...options.Option) (*OauthAuthorizationsListAuthorizationsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OauthAuthorizationsListAuthorizationsReq)
	}
	resp := &OauthAuthorizationsListAuthorizationsResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Authorization{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OauthAuthorizationsListAuthorizations performs requests for "oauth-authorizations/list-authorizations"

List your authorizations.

  GET /authorizations

https://developer.github.com/v3/oauth_authorizations/#list-your-authorizations
*/
func (c Client) OauthAuthorizationsListAuthorizations(ctx context.Context, req *OauthAuthorizationsListAuthorizationsReq, opt ...options.Option) (*OauthAuthorizationsListAuthorizationsResponse, error) {
	return OauthAuthorizationsListAuthorizations(ctx, req, append(c, opt...)...)
}

/*
OauthAuthorizationsListAuthorizationsReq is request data for Client.OauthAuthorizationsListAuthorizations

https://developer.github.com/v3/oauth_authorizations/#list-your-authorizations
*/
type OauthAuthorizationsListAuthorizationsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *OauthAuthorizationsListAuthorizationsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OauthAuthorizationsListAuthorizationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "oauth-authorizations/list-authorizations",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OauthAuthorizationsListAuthorizationsReq) Rel(link RelName, resp *OauthAuthorizationsListAuthorizationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OauthAuthorizationsListAuthorizationsResponse is a response for OauthAuthorizationsListAuthorizations

https://developer.github.com/v3/oauth_authorizations/#list-your-authorizations
*/
type OauthAuthorizationsListAuthorizationsResponse struct {
	internal.Response
	request *OauthAuthorizationsListAuthorizationsReq
	Data    []components.Authorization
}

/*
OauthAuthorizationsListGrants performs requests for "oauth-authorizations/list-grants"

List your grants.

  GET /applications/grants

https://developer.github.com/v3/oauth_authorizations/#list-your-grants
*/
func OauthAuthorizationsListGrants(ctx context.Context, req *OauthAuthorizationsListGrantsReq, opt ...options.Option) (*OauthAuthorizationsListGrantsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OauthAuthorizationsListGrantsReq)
	}
	resp := &OauthAuthorizationsListGrantsResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ApplicationGrant{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OauthAuthorizationsListGrants performs requests for "oauth-authorizations/list-grants"

List your grants.

  GET /applications/grants

https://developer.github.com/v3/oauth_authorizations/#list-your-grants
*/
func (c Client) OauthAuthorizationsListGrants(ctx context.Context, req *OauthAuthorizationsListGrantsReq, opt ...options.Option) (*OauthAuthorizationsListGrantsResponse, error) {
	return OauthAuthorizationsListGrants(ctx, req, append(c, opt...)...)
}

/*
OauthAuthorizationsListGrantsReq is request data for Client.OauthAuthorizationsListGrants

https://developer.github.com/v3/oauth_authorizations/#list-your-grants
*/
type OauthAuthorizationsListGrantsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *OauthAuthorizationsListGrantsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OauthAuthorizationsListGrantsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "oauth-authorizations/list-grants",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/applications/grants"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OauthAuthorizationsListGrantsReq) Rel(link RelName, resp *OauthAuthorizationsListGrantsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OauthAuthorizationsListGrantsResponse is a response for OauthAuthorizationsListGrants

https://developer.github.com/v3/oauth_authorizations/#list-your-grants
*/
type OauthAuthorizationsListGrantsResponse struct {
	internal.Response
	request *OauthAuthorizationsListGrantsReq
	Data    []components.ApplicationGrant
}

/*
OauthAuthorizationsUpdateAuthorization performs requests for "oauth-authorizations/update-authorization"

Update an existing authorization.

  PATCH /authorizations/{authorization_id}

https://developer.github.com/v3/oauth_authorizations/#update-an-existing-authorization
*/
func OauthAuthorizationsUpdateAuthorization(ctx context.Context, req *OauthAuthorizationsUpdateAuthorizationReq, opt ...options.Option) (*OauthAuthorizationsUpdateAuthorizationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OauthAuthorizationsUpdateAuthorizationReq)
	}
	resp := &OauthAuthorizationsUpdateAuthorizationResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Authorization{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OauthAuthorizationsUpdateAuthorization performs requests for "oauth-authorizations/update-authorization"

Update an existing authorization.

  PATCH /authorizations/{authorization_id}

https://developer.github.com/v3/oauth_authorizations/#update-an-existing-authorization
*/
func (c Client) OauthAuthorizationsUpdateAuthorization(ctx context.Context, req *OauthAuthorizationsUpdateAuthorizationReq, opt ...options.Option) (*OauthAuthorizationsUpdateAuthorizationResponse, error) {
	return OauthAuthorizationsUpdateAuthorization(ctx, req, append(c, opt...)...)
}

/*
OauthAuthorizationsUpdateAuthorizationReq is request data for Client.OauthAuthorizationsUpdateAuthorization

https://developer.github.com/v3/oauth_authorizations/#update-an-existing-authorization
*/
type OauthAuthorizationsUpdateAuthorizationReq struct {
	_url string

	// authorization_id parameter
	AuthorizationId int64
	RequestBody     OauthAuthorizationsUpdateAuthorizationReqBody
}

// HTTPRequest builds an *http.Request
func (r *OauthAuthorizationsUpdateAuthorizationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OauthAuthorizationsUpdateAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "oauth-authorizations/update-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/authorizations/%v", r.AuthorizationId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OauthAuthorizationsUpdateAuthorizationReq) Rel(link RelName, resp *OauthAuthorizationsUpdateAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OauthAuthorizationsUpdateAuthorizationReqBody is a request body for oauth-authorizations/update-authorization

https://developer.github.com/v3/oauth_authorizations/#update-an-existing-authorization
*/
type OauthAuthorizationsUpdateAuthorizationReqBody struct {

	// A list of scopes to add to this authorization.
	AddScopes []string `json:"add_scopes,omitempty"`

	// A unique string to distinguish an authorization from others created for the same client ID and user.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// A note to remind you what the OAuth token is for.
	Note *string `json:"note,omitempty"`

	// A URL to remind you what app the OAuth token is for.
	NoteUrl *string `json:"note_url,omitempty"`

	// A list of scopes to remove from this authorization.
	RemoveScopes []string `json:"remove_scopes,omitempty"`

	// A list of scopes that this authorization is in.
	Scopes []string `json:"scopes,omitempty"`
}

/*
OauthAuthorizationsUpdateAuthorizationResponse is a response for OauthAuthorizationsUpdateAuthorization

https://developer.github.com/v3/oauth_authorizations/#update-an-existing-authorization
*/
type OauthAuthorizationsUpdateAuthorizationResponse struct {
	internal.Response
	request *OauthAuthorizationsUpdateAuthorizationReq
	Data    components.Authorization
}
