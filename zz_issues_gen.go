// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
IssuesAddAssignees performs requests for "issues/add-assignees"

Add assignees to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
func (c *Client) IssuesAddAssignees(ctx context.Context, req *IssuesAddAssigneesReq, opt ...RequestOption) (*IssuesAddAssigneesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesAddAssigneesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesAddAssigneesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesAddAssigneesReq is request data for Client.IssuesAddAssignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesAddAssigneesReqBody
}

func (r *IssuesAddAssigneesReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesAddAssigneesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/assignees", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesAddAssigneesReq) method() string {
	return "POST"
}

func (r *IssuesAddAssigneesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesAddAssigneesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesAddAssigneesReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesAddAssigneesReq) dataStatuses() []int {
	return []int{201}
}

func (r *IssuesAddAssigneesReq) validStatuses() []int {
	return []int{201}
}

func (r *IssuesAddAssigneesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesAddAssigneesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesAddAssigneesReq) Rel(link RelName, resp *IssuesAddAssigneesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesAddAssigneesReqBody is a request body for issues/add-assignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesReqBody struct {

	/*
	   Usernames of people to assign this issue to. _NOTE: Only users with push access
	   can add assignees to an issue. Assignees are silently ignored otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`
}

/*
IssuesAddAssigneesResponseBody is a response body for IssuesAddAssignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesResponseBody struct {
	components.IssueSimple
}

/*
IssuesAddAssigneesResponse is a response for IssuesAddAssignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesResponse struct {
	response
	request *IssuesAddAssigneesReq
	Data    *IssuesAddAssigneesResponseBody
}

/*
IssuesAddLabels performs requests for "issues/add-labels"

Add labels to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
func (c *Client) IssuesAddLabels(ctx context.Context, req *IssuesAddLabelsReq, opt ...RequestOption) (*IssuesAddLabelsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesAddLabelsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesAddLabelsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesAddLabelsReq is request data for Client.IssuesAddLabels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesAddLabelsReqBody
}

func (r *IssuesAddLabelsReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesAddLabelsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesAddLabelsReq) method() string {
	return "POST"
}

func (r *IssuesAddLabelsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesAddLabelsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesAddLabelsReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesAddLabelsReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesAddLabelsReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesAddLabelsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesAddLabelsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesAddLabelsReq) Rel(link RelName, resp *IssuesAddLabelsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesAddLabelsReqBody is a request body for issues/add-labels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsReqBody struct {

	/*
	   The name of the label to add to the issue. Must contain at least one label.
	   **Note:** Alternatively, you can pass a single label as a `string` or an `array`
	   of labels directly, but GitHub recommends passing an object with the `labels`
	   key.
	*/
	Labels []string `json:"labels"`
}

/*
IssuesAddLabelsResponseBody is a response body for IssuesAddLabels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsResponseBody []struct {
	components.Label
}

/*
IssuesAddLabelsResponse is a response for IssuesAddLabels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsResponse struct {
	response
	request *IssuesAddLabelsReq
	Data    *IssuesAddLabelsResponseBody
}

/*
IssuesCheckAssignee performs requests for "issues/check-assignee"

Check assignee.

  GET /repos/{owner}/{repo}/assignees/{assignee}

https://developer.github.com/v3/issues/assignees/#check-assignee
*/
func (c *Client) IssuesCheckAssignee(ctx context.Context, req *IssuesCheckAssigneeReq, opt ...RequestOption) (*IssuesCheckAssigneeResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesCheckAssigneeResponse{
		request:  req,
		response: *r,
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCheckAssigneeReq is request data for Client.IssuesCheckAssignee

https://developer.github.com/v3/issues/assignees/#check-assignee
*/
type IssuesCheckAssigneeReq struct {
	pgURL    string
	Owner    string
	Repo     string
	Assignee string
}

func (r *IssuesCheckAssigneeReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesCheckAssigneeReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/assignees/%v", r.Owner, r.Repo, r.Assignee)
}

func (r *IssuesCheckAssigneeReq) method() string {
	return "GET"
}

func (r *IssuesCheckAssigneeReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCheckAssigneeReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCheckAssigneeReq) body() interface{} {
	return nil
}

func (r *IssuesCheckAssigneeReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesCheckAssigneeReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesCheckAssigneeReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// httpRequest creates an http request
func (r *IssuesCheckAssigneeReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCheckAssigneeReq) Rel(link RelName, resp *IssuesCheckAssigneeResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesCheckAssigneeResponse is a response for IssuesCheckAssignee

https://developer.github.com/v3/issues/assignees/#check-assignee
*/
type IssuesCheckAssigneeResponse struct {
	response
	request *IssuesCheckAssigneeReq
	Data    bool
}

/*
IssuesCreate performs requests for "issues/create"

Create an issue.

  POST /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#create-an-issue
*/
func (c *Client) IssuesCreate(ctx context.Context, req *IssuesCreateReq, opt ...RequestOption) (*IssuesCreateResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesCreateResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesCreateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCreateReq is request data for Client.IssuesCreate

https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateReq struct {
	pgURL       string
	Owner       string
	Repo        string
	RequestBody IssuesCreateReqBody
}

func (r *IssuesCreateReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesCreateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues", r.Owner, r.Repo)
}

func (r *IssuesCreateReq) method() string {
	return "POST"
}

func (r *IssuesCreateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCreateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCreateReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesCreateReq) dataStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateReq) validStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesCreateReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCreateReq) Rel(link RelName, resp *IssuesCreateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesCreateReqBody is a request body for issues/create

https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateReqBody struct {

	/*
	   Login for the user that this issue should be assigned to. _NOTE: Only users with
	   push access can set the assignee for new issues. The assignee is silently
	   dropped otherwise. **This field is deprecated.**_
	*/
	Assignee *string `json:"assignee,omitempty"`

	/*
	   Logins for Users to assign to this issue. _NOTE: Only users with push access can
	   set assignees for new issues. Assignees are silently dropped otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`

	// The contents of the issue.
	Body *string `json:"body,omitempty"`

	/*
	   Labels to associate with this issue. _NOTE: Only users with push access can set
	   labels for new issues. Labels are silently dropped otherwise._
	*/
	Labels []string `json:"labels,omitempty"`

	/*
	   The `number` of the milestone to associate this issue with. _NOTE: Only users
	   with push access can set the milestone for new issues. The milestone is silently
	   dropped otherwise._
	*/
	Milestone *int64 `json:"milestone,omitempty"`

	// The title of the issue.
	Title *string `json:"title"`
}

/*
IssuesCreateResponseBody is a response body for IssuesCreate

https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateResponseBody struct {
	components.Issue
}

/*
IssuesCreateResponse is a response for IssuesCreate

https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateResponse struct {
	response
	request *IssuesCreateReq
	Data    *IssuesCreateResponseBody
}

/*
IssuesCreateComment performs requests for "issues/create-comment"

Create a comment.

  POST /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#create-a-comment
*/
func (c *Client) IssuesCreateComment(ctx context.Context, req *IssuesCreateCommentReq, opt ...RequestOption) (*IssuesCreateCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesCreateCommentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesCreateCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCreateCommentReq is request data for Client.IssuesCreateComment

https://developer.github.com/v3/issues/comments/#create-a-comment
*/
type IssuesCreateCommentReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesCreateCommentReqBody
}

func (r *IssuesCreateCommentReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesCreateCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/comments", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesCreateCommentReq) method() string {
	return "POST"
}

func (r *IssuesCreateCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCreateCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCreateCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesCreateCommentReq) dataStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateCommentReq) validStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesCreateCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCreateCommentReq) Rel(link RelName, resp *IssuesCreateCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesCreateCommentReqBody is a request body for issues/create-comment

https://developer.github.com/v3/issues/comments/#create-a-comment
*/
type IssuesCreateCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`
}

/*
IssuesCreateCommentResponseBody is a response body for IssuesCreateComment

https://developer.github.com/v3/issues/comments/#create-a-comment
*/
type IssuesCreateCommentResponseBody struct {
	components.IssueComment
}

/*
IssuesCreateCommentResponse is a response for IssuesCreateComment

https://developer.github.com/v3/issues/comments/#create-a-comment
*/
type IssuesCreateCommentResponse struct {
	response
	request *IssuesCreateCommentReq
	Data    *IssuesCreateCommentResponseBody
}

/*
IssuesCreateLabel performs requests for "issues/create-label"

Create a label.

  POST /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#create-a-label
*/
func (c *Client) IssuesCreateLabel(ctx context.Context, req *IssuesCreateLabelReq, opt ...RequestOption) (*IssuesCreateLabelResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesCreateLabelResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesCreateLabelResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCreateLabelReq is request data for Client.IssuesCreateLabel

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelReq struct {
	pgURL       string
	Owner       string
	Repo        string
	RequestBody IssuesCreateLabelReqBody
}

func (r *IssuesCreateLabelReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesCreateLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels", r.Owner, r.Repo)
}

func (r *IssuesCreateLabelReq) method() string {
	return "POST"
}

func (r *IssuesCreateLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCreateLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCreateLabelReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesCreateLabelReq) dataStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateLabelReq) validStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateLabelReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesCreateLabelReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCreateLabelReq) Rel(link RelName, resp *IssuesCreateLabelResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesCreateLabelReqBody is a request body for issues/create-label

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelReqBody struct {

	/*
	   The [hexadecimal color code](http://www.color-hex.com/) for the label, without
	   the leading `#`.
	*/
	Color *string `json:"color"`

	// A short description of the label.
	Description *string `json:"description,omitempty"`

	/*
	   The name of the label. Emoji can be added to label names, using either native
	   emoji or colon-style markup. For example, typing `:strawberry:` will render the
	   emoji
	   ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png
	   ":strawberry:"). For a full list of available emoji and codes, see
	   [emoji-cheat-sheet.com](http://emoji-cheat-sheet.com/).
	*/
	Name *string `json:"name"`
}

/*
IssuesCreateLabelResponseBody is a response body for IssuesCreateLabel

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelResponseBody struct {
	components.Label
}

/*
IssuesCreateLabelResponse is a response for IssuesCreateLabel

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelResponse struct {
	response
	request *IssuesCreateLabelReq
	Data    *IssuesCreateLabelResponseBody
}

/*
IssuesCreateMilestone performs requests for "issues/create-milestone"

Create a milestone.

  POST /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
func (c *Client) IssuesCreateMilestone(ctx context.Context, req *IssuesCreateMilestoneReq, opt ...RequestOption) (*IssuesCreateMilestoneResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesCreateMilestoneResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesCreateMilestoneResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCreateMilestoneReq is request data for Client.IssuesCreateMilestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneReq struct {
	pgURL       string
	Owner       string
	Repo        string
	RequestBody IssuesCreateMilestoneReqBody
}

func (r *IssuesCreateMilestoneReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesCreateMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones", r.Owner, r.Repo)
}

func (r *IssuesCreateMilestoneReq) method() string {
	return "POST"
}

func (r *IssuesCreateMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCreateMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCreateMilestoneReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesCreateMilestoneReq) dataStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateMilestoneReq) validStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateMilestoneReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesCreateMilestoneReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCreateMilestoneReq) Rel(link RelName, resp *IssuesCreateMilestoneResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesCreateMilestoneReqBody is a request body for issues/create-milestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneReqBody struct {

	// A description of the milestone.
	Description *string `json:"description,omitempty"`

	/*
	   The milestone due date. This is a timestamp in [ISO
	   8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	DueOn *string `json:"due_on,omitempty"`

	// The state of the milestone. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the milestone.
	Title *string `json:"title"`
}

/*
IssuesCreateMilestoneResponseBody is a response body for IssuesCreateMilestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneResponseBody struct {
	components.Milestone
}

/*
IssuesCreateMilestoneResponse is a response for IssuesCreateMilestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneResponse struct {
	response
	request *IssuesCreateMilestoneReq
	Data    *IssuesCreateMilestoneResponseBody
}

/*
IssuesDeleteComment performs requests for "issues/delete-comment"

Delete a comment.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#delete-a-comment
*/
func (c *Client) IssuesDeleteComment(ctx context.Context, req *IssuesDeleteCommentReq, opt ...RequestOption) (*IssuesDeleteCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesDeleteCommentResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesDeleteCommentReq is request data for Client.IssuesDeleteComment

https://developer.github.com/v3/issues/comments/#delete-a-comment
*/
type IssuesDeleteCommentReq struct {
	pgURL     string
	Owner     string
	Repo      string
	CommentId int64
}

func (r *IssuesDeleteCommentReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesDeleteCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *IssuesDeleteCommentReq) method() string {
	return "DELETE"
}

func (r *IssuesDeleteCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesDeleteCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesDeleteCommentReq) body() interface{} {
	return nil
}

func (r *IssuesDeleteCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesDeleteCommentReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesDeleteCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesDeleteCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesDeleteCommentReq) Rel(link RelName, resp *IssuesDeleteCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesDeleteCommentResponse is a response for IssuesDeleteComment

https://developer.github.com/v3/issues/comments/#delete-a-comment
*/
type IssuesDeleteCommentResponse struct {
	response
	request *IssuesDeleteCommentReq
}

/*
IssuesDeleteLabel performs requests for "issues/delete-label"

Delete a label.

  DELETE /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
func (c *Client) IssuesDeleteLabel(ctx context.Context, req *IssuesDeleteLabelReq, opt ...RequestOption) (*IssuesDeleteLabelResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesDeleteLabelResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesDeleteLabelReq is request data for Client.IssuesDeleteLabel

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
type IssuesDeleteLabelReq struct {
	pgURL string
	Owner string
	Repo  string
	Name  string
}

func (r *IssuesDeleteLabelReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesDeleteLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name)
}

func (r *IssuesDeleteLabelReq) method() string {
	return "DELETE"
}

func (r *IssuesDeleteLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesDeleteLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesDeleteLabelReq) body() interface{} {
	return nil
}

func (r *IssuesDeleteLabelReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesDeleteLabelReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesDeleteLabelReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesDeleteLabelReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesDeleteLabelReq) Rel(link RelName, resp *IssuesDeleteLabelResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesDeleteLabelResponse is a response for IssuesDeleteLabel

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
type IssuesDeleteLabelResponse struct {
	response
	request *IssuesDeleteLabelReq
}

/*
IssuesDeleteMilestone performs requests for "issues/delete-milestone"

Delete a milestone.

  DELETE /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
func (c *Client) IssuesDeleteMilestone(ctx context.Context, req *IssuesDeleteMilestoneReq, opt ...RequestOption) (*IssuesDeleteMilestoneResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesDeleteMilestoneResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesDeleteMilestoneReq is request data for Client.IssuesDeleteMilestone

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
type IssuesDeleteMilestoneReq struct {
	pgURL           string
	Owner           string
	Repo            string
	MilestoneNumber int64
}

func (r *IssuesDeleteMilestoneReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesDeleteMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber)
}

func (r *IssuesDeleteMilestoneReq) method() string {
	return "DELETE"
}

func (r *IssuesDeleteMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesDeleteMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesDeleteMilestoneReq) body() interface{} {
	return nil
}

func (r *IssuesDeleteMilestoneReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesDeleteMilestoneReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesDeleteMilestoneReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesDeleteMilestoneReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesDeleteMilestoneReq) Rel(link RelName, resp *IssuesDeleteMilestoneResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesDeleteMilestoneResponse is a response for IssuesDeleteMilestone

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
type IssuesDeleteMilestoneResponse struct {
	response
	request *IssuesDeleteMilestoneReq
}

/*
IssuesGet performs requests for "issues/get"

Get an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#get-an-issue
*/
func (c *Client) IssuesGet(ctx context.Context, req *IssuesGetReq, opt ...RequestOption) (*IssuesGetResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesGetResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesGetResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGetReq is request data for Client.IssuesGet

https://developer.github.com/v3/issues/#get-an-issue
*/
type IssuesGetReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64

	/*
	An additional `reactions` object in the issue payload is currently available for
	developers to preview. During the preview period, the APIs may change without
	advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesGetReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesGetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesGetReq) method() string {
	return "GET"
}

func (r *IssuesGetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetReq) body() interface{} {
	return nil
}

func (r *IssuesGetReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesGetReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesGetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesGetReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetReq) Rel(link RelName, resp *IssuesGetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesGetResponseBody is a response body for IssuesGet

https://developer.github.com/v3/issues/#get-an-issue
*/
type IssuesGetResponseBody struct {
	components.Issue
}

/*
IssuesGetResponse is a response for IssuesGet

https://developer.github.com/v3/issues/#get-an-issue
*/
type IssuesGetResponse struct {
	response
	request *IssuesGetReq
	Data    *IssuesGetResponseBody
}

/*
IssuesGetComment performs requests for "issues/get-comment"

Get a single comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#get-a-single-comment
*/
func (c *Client) IssuesGetComment(ctx context.Context, req *IssuesGetCommentReq, opt ...RequestOption) (*IssuesGetCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesGetCommentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesGetCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGetCommentReq is request data for Client.IssuesGetComment

https://developer.github.com/v3/issues/comments/#get-a-single-comment
*/
type IssuesGetCommentReq struct {
	pgURL     string
	Owner     string
	Repo      string
	CommentId int64

	/*
	If an issue comment is created via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesGetCommentReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesGetCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *IssuesGetCommentReq) method() string {
	return "GET"
}

func (r *IssuesGetCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetCommentReq) body() interface{} {
	return nil
}

func (r *IssuesGetCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesGetCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesGetCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesGetCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetCommentReq) Rel(link RelName, resp *IssuesGetCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesGetCommentResponseBody is a response body for IssuesGetComment

https://developer.github.com/v3/issues/comments/#get-a-single-comment
*/
type IssuesGetCommentResponseBody struct {
	components.IssueComment
}

/*
IssuesGetCommentResponse is a response for IssuesGetComment

https://developer.github.com/v3/issues/comments/#get-a-single-comment
*/
type IssuesGetCommentResponse struct {
	response
	request *IssuesGetCommentReq
	Data    *IssuesGetCommentResponseBody
}

/*
IssuesGetEvent performs requests for "issues/get-event"

Get a single event.

  GET /repos/{owner}/{repo}/issues/events/{event_id}

https://developer.github.com/v3/issues/events/#get-a-single-event
*/
func (c *Client) IssuesGetEvent(ctx context.Context, req *IssuesGetEventReq, opt ...RequestOption) (*IssuesGetEventResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesGetEventResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesGetEventResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGetEventReq is request data for Client.IssuesGetEvent

https://developer.github.com/v3/issues/events/#get-a-single-event
*/
type IssuesGetEventReq struct {
	pgURL   string
	Owner   string
	Repo    string
	EventId int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	If an issue event is created via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *IssuesGetEventReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesGetEventReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/events/%v", r.Owner, r.Repo, r.EventId)
}

func (r *IssuesGetEventReq) method() string {
	return "GET"
}

func (r *IssuesGetEventReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetEventReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man": r.MachineManPreview,
		"sailor-v":    r.SailorVPreview,
		"starfox":     r.StarfoxPreview,
	}
	if allPreviews {
		previewVals["starfox"] = true
		previewVals["machine-man"] = true
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetEventReq) body() interface{} {
	return nil
}

func (r *IssuesGetEventReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesGetEventReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesGetEventReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesGetEventReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetEventReq) Rel(link RelName, resp *IssuesGetEventResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesGetEventResponseBody is a response body for IssuesGetEvent

https://developer.github.com/v3/issues/events/#get-a-single-event
*/
type IssuesGetEventResponseBody struct {
	components.IssueEvent
}

/*
IssuesGetEventResponse is a response for IssuesGetEvent

https://developer.github.com/v3/issues/events/#get-a-single-event
*/
type IssuesGetEventResponse struct {
	response
	request *IssuesGetEventReq
	Data    *IssuesGetEventResponseBody
}

/*
IssuesGetLabel performs requests for "issues/get-label"

Get a single label.

  GET /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#get-a-single-label
*/
func (c *Client) IssuesGetLabel(ctx context.Context, req *IssuesGetLabelReq, opt ...RequestOption) (*IssuesGetLabelResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesGetLabelResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesGetLabelResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGetLabelReq is request data for Client.IssuesGetLabel

https://developer.github.com/v3/issues/labels/#get-a-single-label
*/
type IssuesGetLabelReq struct {
	pgURL string
	Owner string
	Repo  string
	Name  string
}

func (r *IssuesGetLabelReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesGetLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name)
}

func (r *IssuesGetLabelReq) method() string {
	return "GET"
}

func (r *IssuesGetLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetLabelReq) body() interface{} {
	return nil
}

func (r *IssuesGetLabelReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesGetLabelReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesGetLabelReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesGetLabelReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetLabelReq) Rel(link RelName, resp *IssuesGetLabelResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesGetLabelResponseBody is a response body for IssuesGetLabel

https://developer.github.com/v3/issues/labels/#get-a-single-label
*/
type IssuesGetLabelResponseBody struct {
	components.Label
}

/*
IssuesGetLabelResponse is a response for IssuesGetLabel

https://developer.github.com/v3/issues/labels/#get-a-single-label
*/
type IssuesGetLabelResponse struct {
	response
	request *IssuesGetLabelReq
	Data    *IssuesGetLabelResponseBody
}

/*
IssuesGetMilestone performs requests for "issues/get-milestone"

Get a single milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#get-a-single-milestone
*/
func (c *Client) IssuesGetMilestone(ctx context.Context, req *IssuesGetMilestoneReq, opt ...RequestOption) (*IssuesGetMilestoneResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesGetMilestoneResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesGetMilestoneResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGetMilestoneReq is request data for Client.IssuesGetMilestone

https://developer.github.com/v3/issues/milestones/#get-a-single-milestone
*/
type IssuesGetMilestoneReq struct {
	pgURL           string
	Owner           string
	Repo            string
	MilestoneNumber int64
}

func (r *IssuesGetMilestoneReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesGetMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber)
}

func (r *IssuesGetMilestoneReq) method() string {
	return "GET"
}

func (r *IssuesGetMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetMilestoneReq) body() interface{} {
	return nil
}

func (r *IssuesGetMilestoneReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesGetMilestoneReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesGetMilestoneReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesGetMilestoneReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetMilestoneReq) Rel(link RelName, resp *IssuesGetMilestoneResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesGetMilestoneResponseBody is a response body for IssuesGetMilestone

https://developer.github.com/v3/issues/milestones/#get-a-single-milestone
*/
type IssuesGetMilestoneResponseBody struct {
	components.Milestone
}

/*
IssuesGetMilestoneResponse is a response for IssuesGetMilestone

https://developer.github.com/v3/issues/milestones/#get-a-single-milestone
*/
type IssuesGetMilestoneResponse struct {
	response
	request *IssuesGetMilestoneReq
	Data    *IssuesGetMilestoneResponseBody
}

/*
IssuesList performs requests for "issues/list"

List issues assigned to the authenticated user.

  GET /issues

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
func (c *Client) IssuesList(ctx context.Context, req *IssuesListReq, opt ...RequestOption) (*IssuesListResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListReq is request data for Client.IssuesList

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
type IssuesListReq struct {
	pgURL string

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// The direction of the sort. Can be either `asc` or `desc`.
	Direction *string

	/*
	Only issues updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	If an issue is opened via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue payload is currently available for
	developers to preview. During the preview period, the APIs may change without
	advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListReq) urlPath() string {
	return fmt.Sprintf("/issues")
}

func (r *IssuesListReq) method() string {
	return "GET"
}

func (r *IssuesListReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListReq) body() interface{} {
	return nil
}

func (r *IssuesListReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListReq) Rel(link RelName, resp *IssuesListResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListResponseBody is a response body for IssuesList

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
type IssuesListResponseBody []struct {
	components.IssueWithRepo
}

/*
IssuesListResponse is a response for IssuesList

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
type IssuesListResponse struct {
	response
	request *IssuesListReq
	Data    *IssuesListResponseBody
}

/*
IssuesListAssignees performs requests for "issues/list-assignees"

List assignees.

  GET /repos/{owner}/{repo}/assignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
func (c *Client) IssuesListAssignees(ctx context.Context, req *IssuesListAssigneesReq, opt ...RequestOption) (*IssuesListAssigneesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListAssigneesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListAssigneesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListAssigneesReq is request data for Client.IssuesListAssignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
type IssuesListAssigneesReq struct {
	pgURL string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListAssigneesReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListAssigneesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/assignees", r.Owner, r.Repo)
}

func (r *IssuesListAssigneesReq) method() string {
	return "GET"
}

func (r *IssuesListAssigneesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListAssigneesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListAssigneesReq) body() interface{} {
	return nil
}

func (r *IssuesListAssigneesReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListAssigneesReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListAssigneesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListAssigneesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListAssigneesReq) Rel(link RelName, resp *IssuesListAssigneesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListAssigneesResponseBody is a response body for IssuesListAssignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
type IssuesListAssigneesResponseBody []struct {
	components.SimpleUser
}

/*
IssuesListAssigneesResponse is a response for IssuesListAssignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
type IssuesListAssigneesResponse struct {
	response
	request *IssuesListAssigneesReq
	Data    *IssuesListAssigneesResponseBody
}

/*
IssuesListComments performs requests for "issues/list-comments"

List comments on an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#list-comments-on-an-issue
*/
func (c *Client) IssuesListComments(ctx context.Context, req *IssuesListCommentsReq, opt ...RequestOption) (*IssuesListCommentsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListCommentsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListCommentsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListCommentsReq is request data for Client.IssuesListComments

https://developer.github.com/v3/issues/comments/#list-comments-on-an-issue
*/
type IssuesListCommentsReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64

	/*
	Only comments updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListCommentsReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListCommentsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/comments", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesListCommentsReq) method() string {
	return "GET"
}

func (r *IssuesListCommentsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListCommentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListCommentsReq) body() interface{} {
	return nil
}

func (r *IssuesListCommentsReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListCommentsReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListCommentsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListCommentsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListCommentsReq) Rel(link RelName, resp *IssuesListCommentsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListCommentsResponseBody is a response body for IssuesListComments

https://developer.github.com/v3/issues/comments/#list-comments-on-an-issue
*/
type IssuesListCommentsResponseBody []struct {
	components.IssueComment
}

/*
IssuesListCommentsResponse is a response for IssuesListComments

https://developer.github.com/v3/issues/comments/#list-comments-on-an-issue
*/
type IssuesListCommentsResponse struct {
	response
	request *IssuesListCommentsReq
	Data    *IssuesListCommentsResponseBody
}

/*
IssuesListCommentsForRepo performs requests for "issues/list-comments-for-repo"

List comments in a repository.

  GET /repos/{owner}/{repo}/issues/comments

https://developer.github.com/v3/issues/comments/#list-comments-in-a-repository
*/
func (c *Client) IssuesListCommentsForRepo(ctx context.Context, req *IssuesListCommentsForRepoReq, opt ...RequestOption) (*IssuesListCommentsForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListCommentsForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListCommentsForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListCommentsForRepoReq is request data for Client.IssuesListCommentsForRepo

https://developer.github.com/v3/issues/comments/#list-comments-in-a-repository
*/
type IssuesListCommentsForRepoReq struct {
	pgURL string
	Owner string
	Repo  string

	// Either `created` or `updated`.
	Sort *string

	// Either `asc` or `desc`. Ignored without the `sort` parameter.
	Direction *string

	/*
	Only comments updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListCommentsForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListCommentsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments", r.Owner, r.Repo)
}

func (r *IssuesListCommentsForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListCommentsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListCommentsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListCommentsForRepoReq) body() interface{} {
	return nil
}

func (r *IssuesListCommentsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListCommentsForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListCommentsForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListCommentsForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListCommentsForRepoReq) Rel(link RelName, resp *IssuesListCommentsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListCommentsForRepoResponseBody is a response body for IssuesListCommentsForRepo

https://developer.github.com/v3/issues/comments/#list-comments-in-a-repository
*/
type IssuesListCommentsForRepoResponseBody []struct {
	components.IssueComment
}

/*
IssuesListCommentsForRepoResponse is a response for IssuesListCommentsForRepo

https://developer.github.com/v3/issues/comments/#list-comments-in-a-repository
*/
type IssuesListCommentsForRepoResponse struct {
	response
	request *IssuesListCommentsForRepoReq
	Data    *IssuesListCommentsForRepoResponseBody
}

/*
IssuesListEvents performs requests for "issues/list-events"

List events for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/events

https://developer.github.com/v3/issues/events/#list-events-for-an-issue
*/
func (c *Client) IssuesListEvents(ctx context.Context, req *IssuesListEventsReq, opt ...RequestOption) (*IssuesListEventsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListEventsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListEventsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListEventsReq is request data for Client.IssuesListEvents

https://developer.github.com/v3/issues/events/#list-events-for-an-issue
*/
type IssuesListEventsReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *IssuesListEventsReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListEventsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/events", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesListEventsReq) method() string {
	return "GET"
}

func (r *IssuesListEventsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListEventsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"sailor-v": r.SailorVPreview,
		"starfox":  r.StarfoxPreview,
	}
	if allPreviews {
		previewVals["starfox"] = true
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListEventsReq) body() interface{} {
	return nil
}

func (r *IssuesListEventsReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListEventsReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListEventsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListEventsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListEventsReq) Rel(link RelName, resp *IssuesListEventsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListEventsResponseBody is a response body for IssuesListEvents

https://developer.github.com/v3/issues/events/#list-events-for-an-issue
*/
type IssuesListEventsResponseBody []struct {
	components.IssueEventForIssue
}

/*
IssuesListEventsResponse is a response for IssuesListEvents

https://developer.github.com/v3/issues/events/#list-events-for-an-issue
*/
type IssuesListEventsResponse struct {
	response
	request *IssuesListEventsReq
	Data    *IssuesListEventsResponseBody
}

/*
IssuesListEventsForRepo performs requests for "issues/list-events-for-repo"

List events for a repository.

  GET /repos/{owner}/{repo}/issues/events

https://developer.github.com/v3/issues/events/#list-events-for-a-repository
*/
func (c *Client) IssuesListEventsForRepo(ctx context.Context, req *IssuesListEventsForRepoReq, opt ...RequestOption) (*IssuesListEventsForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListEventsForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListEventsForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListEventsForRepoReq is request data for Client.IssuesListEventsForRepo

https://developer.github.com/v3/issues/events/#list-events-for-a-repository
*/
type IssuesListEventsForRepoReq struct {
	pgURL string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *IssuesListEventsForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListEventsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/events", r.Owner, r.Repo)
}

func (r *IssuesListEventsForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListEventsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListEventsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"sailor-v": r.SailorVPreview,
		"starfox":  r.StarfoxPreview,
	}
	if allPreviews {
		previewVals["starfox"] = true
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListEventsForRepoReq) body() interface{} {
	return nil
}

func (r *IssuesListEventsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListEventsForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListEventsForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListEventsForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListEventsForRepoReq) Rel(link RelName, resp *IssuesListEventsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListEventsForRepoResponseBody is a response body for IssuesListEventsForRepo

https://developer.github.com/v3/issues/events/#list-events-for-a-repository
*/
type IssuesListEventsForRepoResponseBody []struct {
	components.IssueEvent
}

/*
IssuesListEventsForRepoResponse is a response for IssuesListEventsForRepo

https://developer.github.com/v3/issues/events/#list-events-for-a-repository
*/
type IssuesListEventsForRepoResponse struct {
	response
	request *IssuesListEventsForRepoReq
	Data    *IssuesListEventsForRepoResponseBody
}

/*
IssuesListEventsForTimeline performs requests for "issues/list-events-for-timeline"

List events for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/timeline

https://developer.github.com/v3/issues/timeline/#list-events-for-an-issue
*/
func (c *Client) IssuesListEventsForTimeline(ctx context.Context, req *IssuesListEventsForTimelineReq, opt ...RequestOption) (*IssuesListEventsForTimelineResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListEventsForTimelineResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListEventsForTimelineResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListEventsForTimelineReq is request data for Client.IssuesListEventsForTimeline

https://developer.github.com/v3/issues/timeline/#list-events-for-an-issue
*/
type IssuesListEventsForTimelineReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The API to get issue timeline events is currently available for developers to
	preview. During the preview period, the APIs may change without advance notice.
	Please see the [blog
	post](https://developer.github.com/changes/2016-05-23-timeline-preview-api/) for
	full details. To access the API you must set this to true.
	*/
	MockingbirdPreview bool

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool
}

func (r *IssuesListEventsForTimelineReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListEventsForTimelineReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/timeline", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesListEventsForTimelineReq) method() string {
	return "GET"
}

func (r *IssuesListEventsForTimelineReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListEventsForTimelineReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"mockingbird": r.MockingbirdPreview,
		"starfox":     r.StarfoxPreview,
	}
	if requiredPreviews {
		previewVals["mockingbird"] = true
	}
	if allPreviews {
		previewVals["mockingbird"] = true
		previewVals["starfox"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListEventsForTimelineReq) body() interface{} {
	return nil
}

func (r *IssuesListEventsForTimelineReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListEventsForTimelineReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListEventsForTimelineReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListEventsForTimelineReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListEventsForTimelineReq) Rel(link RelName, resp *IssuesListEventsForTimelineResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListEventsForTimelineResponseBody is a response body for IssuesListEventsForTimeline

https://developer.github.com/v3/issues/timeline/#list-events-for-an-issue
*/
type IssuesListEventsForTimelineResponseBody []struct {
	components.IssueEventForIssue
}

/*
IssuesListEventsForTimelineResponse is a response for IssuesListEventsForTimeline

https://developer.github.com/v3/issues/timeline/#list-events-for-an-issue
*/
type IssuesListEventsForTimelineResponse struct {
	response
	request *IssuesListEventsForTimelineReq
	Data    *IssuesListEventsForTimelineResponseBody
}

/*
IssuesListForAuthenticatedUser performs requests for "issues/list-for-authenticated-user"

List user account issues assigned to the authenticated user.

  GET /user/issues

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
func (c *Client) IssuesListForAuthenticatedUser(ctx context.Context, req *IssuesListForAuthenticatedUserReq, opt ...RequestOption) (*IssuesListForAuthenticatedUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListForAuthenticatedUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListForAuthenticatedUserReq is request data for Client.IssuesListForAuthenticatedUser

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
type IssuesListForAuthenticatedUserReq struct {
	pgURL string

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// The direction of the sort. Can be either `asc` or `desc`.
	Direction *string

	/*
	Only issues updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	If an issue is opened via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue payload is currently available for
	developers to preview. During the preview period, the APIs may change without
	advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListForAuthenticatedUserReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/issues")
}

func (r *IssuesListForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *IssuesListForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *IssuesListForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListForAuthenticatedUserReq) Rel(link RelName, resp *IssuesListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListForAuthenticatedUserResponseBody is a response body for IssuesListForAuthenticatedUser

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
type IssuesListForAuthenticatedUserResponseBody []struct {
	components.IssueWithRepo
}

/*
IssuesListForAuthenticatedUserResponse is a response for IssuesListForAuthenticatedUser

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
type IssuesListForAuthenticatedUserResponse struct {
	response
	request *IssuesListForAuthenticatedUserReq
	Data    *IssuesListForAuthenticatedUserResponseBody
}

/*
IssuesListForOrg performs requests for "issues/list-for-org"

List organization issues assigned to the authenticated user.

  GET /orgs/{org}/issues

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
func (c *Client) IssuesListForOrg(ctx context.Context, req *IssuesListForOrgReq, opt ...RequestOption) (*IssuesListForOrgResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListForOrgResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListForOrgReq is request data for Client.IssuesListForOrg

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
type IssuesListForOrgReq struct {
	pgURL string
	Org   string

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// The direction of the sort. Can be either `asc` or `desc`.
	Direction *string

	/*
	Only issues updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	If an issue is opened via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue payload is currently available for
	developers to preview. During the preview period, the APIs may change without
	advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListForOrgReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/issues", r.Org)
}

func (r *IssuesListForOrgReq) method() string {
	return "GET"
}

func (r *IssuesListForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListForOrgReq) body() interface{} {
	return nil
}

func (r *IssuesListForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListForOrgReq) Rel(link RelName, resp *IssuesListForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListForOrgResponseBody is a response body for IssuesListForOrg

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
type IssuesListForOrgResponseBody []struct {
	components.IssueWithRepo
}

/*
IssuesListForOrgResponse is a response for IssuesListForOrg

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
type IssuesListForOrgResponse struct {
	response
	request *IssuesListForOrgReq
	Data    *IssuesListForOrgResponseBody
}

/*
IssuesListForRepo performs requests for "issues/list-for-repo"

List repository issues.

  GET /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#list-repository-issues
*/
func (c *Client) IssuesListForRepo(ctx context.Context, req *IssuesListForRepoReq, opt ...RequestOption) (*IssuesListForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListForRepoReq is request data for Client.IssuesListForRepo

https://developer.github.com/v3/issues/#list-repository-issues
*/
type IssuesListForRepoReq struct {
	pgURL string
	Owner string
	Repo  string

	/*
	If an `integer` is passed, it should refer to a milestone by its `number` field.
	If the string `*` is passed, issues with any milestone are accepted. If the
	string `none` is passed, issues without milestones are returned.
	*/
	Milestone *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	/*
	Can be the name of a user. Pass in `none` for issues with no assigned user, and
	`*` for issues assigned to any user.
	*/
	Assignee *string

	// The user that created the issue.
	Creator *string

	// A user that's mentioned in the issue.
	Mentioned *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// The direction of the sort. Can be either `asc` or `desc`.
	Direction *string

	/*
	Only issues updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	If an issue is opened via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue payload is currently available for
	developers to preview. During the preview period, the APIs may change without
	advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues", r.Owner, r.Repo)
}

func (r *IssuesListForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Milestone != nil {
		query.Set("milestone", *r.Milestone)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Assignee != nil {
		query.Set("assignee", *r.Assignee)
	}
	if r.Creator != nil {
		query.Set("creator", *r.Creator)
	}
	if r.Mentioned != nil {
		query.Set("mentioned", *r.Mentioned)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListForRepoReq) body() interface{} {
	return nil
}

func (r *IssuesListForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListForRepoReq) Rel(link RelName, resp *IssuesListForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListForRepoResponseBody is a response body for IssuesListForRepo

https://developer.github.com/v3/issues/#list-repository-issues
*/
type IssuesListForRepoResponseBody []struct {
	components.IssueSimple2
}

/*
IssuesListForRepoResponse is a response for IssuesListForRepo

https://developer.github.com/v3/issues/#list-repository-issues
*/
type IssuesListForRepoResponse struct {
	response
	request *IssuesListForRepoReq
	Data    *IssuesListForRepoResponseBody
}

/*
IssuesListLabelsForMilestone performs requests for "issues/list-labels-for-milestone"

Get labels for every issue in a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels

https://developer.github.com/v3/issues/labels/#get-labels-for-every-issue-in-a-milestone
*/
func (c *Client) IssuesListLabelsForMilestone(ctx context.Context, req *IssuesListLabelsForMilestoneReq, opt ...RequestOption) (*IssuesListLabelsForMilestoneResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListLabelsForMilestoneResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListLabelsForMilestoneResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListLabelsForMilestoneReq is request data for Client.IssuesListLabelsForMilestone

https://developer.github.com/v3/issues/labels/#get-labels-for-every-issue-in-a-milestone
*/
type IssuesListLabelsForMilestoneReq struct {
	pgURL           string
	Owner           string
	Repo            string
	MilestoneNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListLabelsForMilestoneReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListLabelsForMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones/%v/labels", r.Owner, r.Repo, r.MilestoneNumber)
}

func (r *IssuesListLabelsForMilestoneReq) method() string {
	return "GET"
}

func (r *IssuesListLabelsForMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListLabelsForMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListLabelsForMilestoneReq) body() interface{} {
	return nil
}

func (r *IssuesListLabelsForMilestoneReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListLabelsForMilestoneReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListLabelsForMilestoneReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListLabelsForMilestoneReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListLabelsForMilestoneReq) Rel(link RelName, resp *IssuesListLabelsForMilestoneResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListLabelsForMilestoneResponseBody is a response body for IssuesListLabelsForMilestone

https://developer.github.com/v3/issues/labels/#get-labels-for-every-issue-in-a-milestone
*/
type IssuesListLabelsForMilestoneResponseBody []struct {
	components.Label
}

/*
IssuesListLabelsForMilestoneResponse is a response for IssuesListLabelsForMilestone

https://developer.github.com/v3/issues/labels/#get-labels-for-every-issue-in-a-milestone
*/
type IssuesListLabelsForMilestoneResponse struct {
	response
	request *IssuesListLabelsForMilestoneReq
	Data    *IssuesListLabelsForMilestoneResponseBody
}

/*
IssuesListLabelsForRepo performs requests for "issues/list-labels-for-repo"

List all labels for this repository.

  GET /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository
*/
func (c *Client) IssuesListLabelsForRepo(ctx context.Context, req *IssuesListLabelsForRepoReq, opt ...RequestOption) (*IssuesListLabelsForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListLabelsForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListLabelsForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListLabelsForRepoReq is request data for Client.IssuesListLabelsForRepo

https://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository
*/
type IssuesListLabelsForRepoReq struct {
	pgURL string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListLabelsForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListLabelsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels", r.Owner, r.Repo)
}

func (r *IssuesListLabelsForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListLabelsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListLabelsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListLabelsForRepoReq) body() interface{} {
	return nil
}

func (r *IssuesListLabelsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListLabelsForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListLabelsForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListLabelsForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListLabelsForRepoReq) Rel(link RelName, resp *IssuesListLabelsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListLabelsForRepoResponseBody is a response body for IssuesListLabelsForRepo

https://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository
*/
type IssuesListLabelsForRepoResponseBody []struct {
	components.Label
}

/*
IssuesListLabelsForRepoResponse is a response for IssuesListLabelsForRepo

https://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository
*/
type IssuesListLabelsForRepoResponse struct {
	response
	request *IssuesListLabelsForRepoReq
	Data    *IssuesListLabelsForRepoResponseBody
}

/*
IssuesListLabelsOnIssue performs requests for "issues/list-labels-on-issue"

List labels on an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-on-an-issue
*/
func (c *Client) IssuesListLabelsOnIssue(ctx context.Context, req *IssuesListLabelsOnIssueReq, opt ...RequestOption) (*IssuesListLabelsOnIssueResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListLabelsOnIssueResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListLabelsOnIssueResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListLabelsOnIssueReq is request data for Client.IssuesListLabelsOnIssue

https://developer.github.com/v3/issues/labels/#list-labels-on-an-issue
*/
type IssuesListLabelsOnIssueReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListLabelsOnIssueReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListLabelsOnIssueReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesListLabelsOnIssueReq) method() string {
	return "GET"
}

func (r *IssuesListLabelsOnIssueReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListLabelsOnIssueReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListLabelsOnIssueReq) body() interface{} {
	return nil
}

func (r *IssuesListLabelsOnIssueReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListLabelsOnIssueReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListLabelsOnIssueReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListLabelsOnIssueReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListLabelsOnIssueReq) Rel(link RelName, resp *IssuesListLabelsOnIssueResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListLabelsOnIssueResponseBody is a response body for IssuesListLabelsOnIssue

https://developer.github.com/v3/issues/labels/#list-labels-on-an-issue
*/
type IssuesListLabelsOnIssueResponseBody []struct {
	components.Label
}

/*
IssuesListLabelsOnIssueResponse is a response for IssuesListLabelsOnIssue

https://developer.github.com/v3/issues/labels/#list-labels-on-an-issue
*/
type IssuesListLabelsOnIssueResponse struct {
	response
	request *IssuesListLabelsOnIssueReq
	Data    *IssuesListLabelsOnIssueResponseBody
}

/*
IssuesListMilestonesForRepo performs requests for "issues/list-milestones-for-repo"

List milestones for a repository.

  GET /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#list-milestones-for-a-repository
*/
func (c *Client) IssuesListMilestonesForRepo(ctx context.Context, req *IssuesListMilestonesForRepoReq, opt ...RequestOption) (*IssuesListMilestonesForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesListMilestonesForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesListMilestonesForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListMilestonesForRepoReq is request data for Client.IssuesListMilestonesForRepo

https://developer.github.com/v3/issues/milestones/#list-milestones-for-a-repository
*/
type IssuesListMilestonesForRepoReq struct {
	pgURL string
	Owner string
	Repo  string

	// The state of the milestone. Either `open`, `closed`, or `all`.
	State *string

	// What to sort results by. Either `due_on` or `completeness`.
	Sort *string

	// The direction of the sort. Either `asc` or `desc`.
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListMilestonesForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesListMilestonesForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones", r.Owner, r.Repo)
}

func (r *IssuesListMilestonesForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListMilestonesForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListMilestonesForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListMilestonesForRepoReq) body() interface{} {
	return nil
}

func (r *IssuesListMilestonesForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListMilestonesForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListMilestonesForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesListMilestonesForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListMilestonesForRepoReq) Rel(link RelName, resp *IssuesListMilestonesForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesListMilestonesForRepoResponseBody is a response body for IssuesListMilestonesForRepo

https://developer.github.com/v3/issues/milestones/#list-milestones-for-a-repository
*/
type IssuesListMilestonesForRepoResponseBody []struct {
	components.Milestone
}

/*
IssuesListMilestonesForRepoResponse is a response for IssuesListMilestonesForRepo

https://developer.github.com/v3/issues/milestones/#list-milestones-for-a-repository
*/
type IssuesListMilestonesForRepoResponse struct {
	response
	request *IssuesListMilestonesForRepoReq
	Data    *IssuesListMilestonesForRepoResponseBody
}

/*
IssuesLock performs requests for "issues/lock"

Lock an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
func (c *Client) IssuesLock(ctx context.Context, req *IssuesLockReq, opt ...RequestOption) (*IssuesLockResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesLockResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesLockReq is request data for Client.IssuesLock

https://developer.github.com/v3/issues/#lock-an-issue
*/
type IssuesLockReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesLockReqBody

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *IssuesLockReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesLockReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/lock", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesLockReq) method() string {
	return "PUT"
}

func (r *IssuesLockReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesLockReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"sailor-v": r.SailorVPreview}
	if allPreviews {
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesLockReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesLockReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesLockReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesLockReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesLockReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesLockReq) Rel(link RelName, resp *IssuesLockResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesLockReqBody is a request body for issues/lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
type IssuesLockReqBody struct {

	/*
	   The reason for locking the issue or pull request conversation. Lock will fail if
	   you don't use one of these reasons:
	   \* `off-topic`
	   \* `too heated`
	   \* `resolved`
	   \* `spam`
	*/
	LockReason *string `json:"lock_reason,omitempty"`
}

/*
IssuesLockResponse is a response for IssuesLock

https://developer.github.com/v3/issues/#lock-an-issue
*/
type IssuesLockResponse struct {
	response
	request *IssuesLockReq
}

/*
IssuesRemoveAllLabels performs requests for "issues/remove-all-labels"

Remove all labels from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
func (c *Client) IssuesRemoveAllLabels(ctx context.Context, req *IssuesRemoveAllLabelsReq, opt ...RequestOption) (*IssuesRemoveAllLabelsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesRemoveAllLabelsResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesRemoveAllLabelsReq is request data for Client.IssuesRemoveAllLabels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
type IssuesRemoveAllLabelsReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64
}

func (r *IssuesRemoveAllLabelsReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesRemoveAllLabelsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesRemoveAllLabelsReq) method() string {
	return "DELETE"
}

func (r *IssuesRemoveAllLabelsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesRemoveAllLabelsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesRemoveAllLabelsReq) body() interface{} {
	return nil
}

func (r *IssuesRemoveAllLabelsReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesRemoveAllLabelsReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesRemoveAllLabelsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesRemoveAllLabelsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesRemoveAllLabelsReq) Rel(link RelName, resp *IssuesRemoveAllLabelsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesRemoveAllLabelsResponse is a response for IssuesRemoveAllLabels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
type IssuesRemoveAllLabelsResponse struct {
	response
	request *IssuesRemoveAllLabelsReq
}

/*
IssuesRemoveAssignees performs requests for "issues/remove-assignees"

Remove assignees from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
func (c *Client) IssuesRemoveAssignees(ctx context.Context, req *IssuesRemoveAssigneesReq, opt ...RequestOption) (*IssuesRemoveAssigneesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesRemoveAssigneesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesRemoveAssigneesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesRemoveAssigneesReq is request data for Client.IssuesRemoveAssignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesRemoveAssigneesReqBody
}

func (r *IssuesRemoveAssigneesReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesRemoveAssigneesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/assignees", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesRemoveAssigneesReq) method() string {
	return "DELETE"
}

func (r *IssuesRemoveAssigneesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesRemoveAssigneesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesRemoveAssigneesReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesRemoveAssigneesReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesRemoveAssigneesReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesRemoveAssigneesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesRemoveAssigneesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesRemoveAssigneesReq) Rel(link RelName, resp *IssuesRemoveAssigneesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesRemoveAssigneesReqBody is a request body for issues/remove-assignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesReqBody struct {

	/*
	   Usernames of assignees to remove from an issue. _NOTE: Only users with push
	   access can remove assignees from an issue. Assignees are silently ignored
	   otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`
}

/*
IssuesRemoveAssigneesResponseBody is a response body for IssuesRemoveAssignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesResponseBody struct {
	components.IssueSimple2
}

/*
IssuesRemoveAssigneesResponse is a response for IssuesRemoveAssignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesResponse struct {
	response
	request *IssuesRemoveAssigneesReq
	Data    *IssuesRemoveAssigneesResponseBody
}

/*
IssuesRemoveLabel performs requests for "issues/remove-label"

Remove a label from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
func (c *Client) IssuesRemoveLabel(ctx context.Context, req *IssuesRemoveLabelReq, opt ...RequestOption) (*IssuesRemoveLabelResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesRemoveLabelResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesRemoveLabelResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesRemoveLabelReq is request data for Client.IssuesRemoveLabel

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
type IssuesRemoveLabelReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64
	Name        string
}

func (r *IssuesRemoveLabelReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesRemoveLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels/%v", r.Owner, r.Repo, r.IssueNumber, r.Name)
}

func (r *IssuesRemoveLabelReq) method() string {
	return "DELETE"
}

func (r *IssuesRemoveLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesRemoveLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesRemoveLabelReq) body() interface{} {
	return nil
}

func (r *IssuesRemoveLabelReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesRemoveLabelReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesRemoveLabelReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesRemoveLabelReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesRemoveLabelReq) Rel(link RelName, resp *IssuesRemoveLabelResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesRemoveLabelResponseBody is a response body for IssuesRemoveLabel

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
type IssuesRemoveLabelResponseBody []struct {
	components.Label
}

/*
IssuesRemoveLabelResponse is a response for IssuesRemoveLabel

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
type IssuesRemoveLabelResponse struct {
	response
	request *IssuesRemoveLabelReq
	Data    *IssuesRemoveLabelResponseBody
}

/*
IssuesReplaceAllLabels performs requests for "issues/replace-all-labels"

Replace all labels for an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#replace-all-labels-for-an-issue
*/
func (c *Client) IssuesReplaceAllLabels(ctx context.Context, req *IssuesReplaceAllLabelsReq, opt ...RequestOption) (*IssuesReplaceAllLabelsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesReplaceAllLabelsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesReplaceAllLabelsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesReplaceAllLabelsReq is request data for Client.IssuesReplaceAllLabels

https://developer.github.com/v3/issues/labels/#replace-all-labels-for-an-issue
*/
type IssuesReplaceAllLabelsReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesReplaceAllLabelsReqBody
}

func (r *IssuesReplaceAllLabelsReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesReplaceAllLabelsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesReplaceAllLabelsReq) method() string {
	return "PUT"
}

func (r *IssuesReplaceAllLabelsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesReplaceAllLabelsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesReplaceAllLabelsReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesReplaceAllLabelsReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesReplaceAllLabelsReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesReplaceAllLabelsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesReplaceAllLabelsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesReplaceAllLabelsReq) Rel(link RelName, resp *IssuesReplaceAllLabelsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesReplaceAllLabelsReqBody is a request body for issues/replace-all-labels

https://developer.github.com/v3/issues/labels/#replace-all-labels-for-an-issue
*/
type IssuesReplaceAllLabelsReqBody struct {

	/*
	   The names of the labels to add to the issue. You can pass an empty array to
	   remove all labels. **Note:** Alternatively, you can pass a single label as a
	   `string` or an `array` of labels directly, but GitHub recommends passing an
	   object with the `labels` key.
	*/
	Labels []string `json:"labels,omitempty"`
}

/*
IssuesReplaceAllLabelsResponseBody is a response body for IssuesReplaceAllLabels

https://developer.github.com/v3/issues/labels/#replace-all-labels-for-an-issue
*/
type IssuesReplaceAllLabelsResponseBody []struct {
	components.Label
}

/*
IssuesReplaceAllLabelsResponse is a response for IssuesReplaceAllLabels

https://developer.github.com/v3/issues/labels/#replace-all-labels-for-an-issue
*/
type IssuesReplaceAllLabelsResponse struct {
	response
	request *IssuesReplaceAllLabelsReq
	Data    *IssuesReplaceAllLabelsResponseBody
}

/*
IssuesUnlock performs requests for "issues/unlock"

Unlock an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
func (c *Client) IssuesUnlock(ctx context.Context, req *IssuesUnlockReq, opt ...RequestOption) (*IssuesUnlockResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesUnlockResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUnlockReq is request data for Client.IssuesUnlock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
type IssuesUnlockReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64
}

func (r *IssuesUnlockReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesUnlockReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/lock", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesUnlockReq) method() string {
	return "DELETE"
}

func (r *IssuesUnlockReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUnlockReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUnlockReq) body() interface{} {
	return nil
}

func (r *IssuesUnlockReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesUnlockReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesUnlockReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesUnlockReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUnlockReq) Rel(link RelName, resp *IssuesUnlockResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesUnlockResponse is a response for IssuesUnlock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
type IssuesUnlockResponse struct {
	response
	request *IssuesUnlockReq
}

/*
IssuesUpdate performs requests for "issues/update"

Update an issue.

  PATCH /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#update-an-issue
*/
func (c *Client) IssuesUpdate(ctx context.Context, req *IssuesUpdateReq, opt ...RequestOption) (*IssuesUpdateResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesUpdateResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesUpdateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUpdateReq is request data for Client.IssuesUpdate

https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateReq struct {
	pgURL       string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesUpdateReqBody
}

func (r *IssuesUpdateReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesUpdateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesUpdateReq) method() string {
	return "PATCH"
}

func (r *IssuesUpdateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUpdateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUpdateReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesUpdateReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesUpdateReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUpdateReq) Rel(link RelName, resp *IssuesUpdateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesUpdateReqBody is a request body for issues/update

https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateReqBody struct {

	/*
	   Login for the user that this issue should be assigned to. **This field is
	   deprecated.**
	*/
	Assignee *string `json:"assignee,omitempty"`

	/*
	   Logins for Users to assign to this issue. Pass one or more user logins to
	   _replace_ the set of assignees on this Issue. Send an empty array (`[]`) to
	   clear all assignees from the Issue. _NOTE: Only users with push access can set
	   assignees for new issues. Assignees are silently dropped otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`

	// The contents of the issue.
	Body *string `json:"body,omitempty"`

	/*
	   Labels to associate with this issue. Pass one or more Labels to _replace_ the
	   set of Labels on this Issue. Send an empty array (`[]`) to clear all Labels from
	   the Issue. _NOTE: Only users with push access can set labels for issues. Labels
	   are silently dropped otherwise._
	*/
	Labels []string `json:"labels,omitempty"`

	/*
	   The `number` of the milestone to associate this issue with or `null` to remove
	   current. _NOTE: Only users with push access can set the milestone for issues.
	   The milestone is silently dropped otherwise._
	*/
	Milestone *int64 `json:"milestone,omitempty"`

	// State of the issue. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the issue.
	Title *string `json:"title,omitempty"`
}

/*
IssuesUpdateResponseBody is a response body for IssuesUpdate

https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateResponseBody struct {
	components.Issue
}

/*
IssuesUpdateResponse is a response for IssuesUpdate

https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateResponse struct {
	response
	request *IssuesUpdateReq
	Data    *IssuesUpdateResponseBody
}

/*
IssuesUpdateComment performs requests for "issues/update-comment"

Edit a comment.

  PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#edit-a-comment
*/
func (c *Client) IssuesUpdateComment(ctx context.Context, req *IssuesUpdateCommentReq, opt ...RequestOption) (*IssuesUpdateCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesUpdateCommentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesUpdateCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUpdateCommentReq is request data for Client.IssuesUpdateComment

https://developer.github.com/v3/issues/comments/#edit-a-comment
*/
type IssuesUpdateCommentReq struct {
	pgURL       string
	Owner       string
	Repo        string
	CommentId   int64
	RequestBody IssuesUpdateCommentReqBody
}

func (r *IssuesUpdateCommentReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesUpdateCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *IssuesUpdateCommentReq) method() string {
	return "PATCH"
}

func (r *IssuesUpdateCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUpdateCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUpdateCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesUpdateCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesUpdateCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUpdateCommentReq) Rel(link RelName, resp *IssuesUpdateCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesUpdateCommentReqBody is a request body for issues/update-comment

https://developer.github.com/v3/issues/comments/#edit-a-comment
*/
type IssuesUpdateCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`
}

/*
IssuesUpdateCommentResponseBody is a response body for IssuesUpdateComment

https://developer.github.com/v3/issues/comments/#edit-a-comment
*/
type IssuesUpdateCommentResponseBody struct {
	components.IssueComment
}

/*
IssuesUpdateCommentResponse is a response for IssuesUpdateComment

https://developer.github.com/v3/issues/comments/#edit-a-comment
*/
type IssuesUpdateCommentResponse struct {
	response
	request *IssuesUpdateCommentReq
	Data    *IssuesUpdateCommentResponseBody
}

/*
IssuesUpdateLabel performs requests for "issues/update-label"

Update a label.

  PATCH /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#update-a-label
*/
func (c *Client) IssuesUpdateLabel(ctx context.Context, req *IssuesUpdateLabelReq, opt ...RequestOption) (*IssuesUpdateLabelResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesUpdateLabelResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesUpdateLabelResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUpdateLabelReq is request data for Client.IssuesUpdateLabel

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelReq struct {
	pgURL       string
	Owner       string
	Repo        string
	Name        string
	RequestBody IssuesUpdateLabelReqBody
}

func (r *IssuesUpdateLabelReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesUpdateLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name)
}

func (r *IssuesUpdateLabelReq) method() string {
	return "PATCH"
}

func (r *IssuesUpdateLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUpdateLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUpdateLabelReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesUpdateLabelReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateLabelReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateLabelReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesUpdateLabelReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUpdateLabelReq) Rel(link RelName, resp *IssuesUpdateLabelResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesUpdateLabelReqBody is a request body for issues/update-label

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelReqBody struct {

	/*
	   The [hexadecimal color code](http://www.color-hex.com/) for the label, without
	   the leading `#`.
	*/
	Color *string `json:"color,omitempty"`

	// A short description of the label.
	Description *string `json:"description,omitempty"`

	/*
	   The new name of the label. Emoji can be added to label names, using either
	   native emoji or colon-style markup. For example, typing `:strawberry:` will
	   render the emoji
	   ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png
	   ":strawberry:"). For a full list of available emoji and codes, see
	   [emoji-cheat-sheet.com](http://emoji-cheat-sheet.com/).
	*/
	NewName *string `json:"new_name,omitempty"`
}

/*
IssuesUpdateLabelResponseBody is a response body for IssuesUpdateLabel

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelResponseBody struct {
	components.Label
}

/*
IssuesUpdateLabelResponse is a response for IssuesUpdateLabel

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelResponse struct {
	response
	request *IssuesUpdateLabelReq
	Data    *IssuesUpdateLabelResponseBody
}

/*
IssuesUpdateMilestone performs requests for "issues/update-milestone"

Update a milestone.

  PATCH /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
func (c *Client) IssuesUpdateMilestone(ctx context.Context, req *IssuesUpdateMilestoneReq, opt ...RequestOption) (*IssuesUpdateMilestoneResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &IssuesUpdateMilestoneResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(IssuesUpdateMilestoneResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUpdateMilestoneReq is request data for Client.IssuesUpdateMilestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneReq struct {
	pgURL           string
	Owner           string
	Repo            string
	MilestoneNumber int64
	RequestBody     IssuesUpdateMilestoneReqBody
}

func (r *IssuesUpdateMilestoneReq) pagingURL() string {
	return r.pgURL
}

func (r *IssuesUpdateMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber)
}

func (r *IssuesUpdateMilestoneReq) method() string {
	return "PATCH"
}

func (r *IssuesUpdateMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUpdateMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUpdateMilestoneReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesUpdateMilestoneReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateMilestoneReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateMilestoneReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *IssuesUpdateMilestoneReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUpdateMilestoneReq) Rel(link RelName, resp *IssuesUpdateMilestoneResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
IssuesUpdateMilestoneReqBody is a request body for issues/update-milestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneReqBody struct {

	// A description of the milestone.
	Description *string `json:"description,omitempty"`

	/*
	   The milestone due date. This is a timestamp in [ISO
	   8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	DueOn *string `json:"due_on,omitempty"`

	// The state of the milestone. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the milestone.
	Title *string `json:"title,omitempty"`
}

/*
IssuesUpdateMilestoneResponseBody is a response body for IssuesUpdateMilestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneResponseBody struct {
	components.Milestone
}

/*
IssuesUpdateMilestoneResponse is a response for IssuesUpdateMilestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneResponse struct {
	response
	request *IssuesUpdateMilestoneReq
	Data    *IssuesUpdateMilestoneResponseBody
}
