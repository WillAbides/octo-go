// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
IssuesAddAssignees performs requests for "issues/add-assignees"

Add assignees to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
func IssuesAddAssignees(ctx context.Context, req *IssuesAddAssigneesReq, opt ...options.Option) (*IssuesAddAssigneesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesAddAssigneesReq)
	}
	resp := &IssuesAddAssigneesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.IssueSimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesAddAssignees performs requests for "issues/add-assignees"

Add assignees to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
func (c Client) IssuesAddAssignees(ctx context.Context, req *IssuesAddAssigneesReq, opt ...options.Option) (*IssuesAddAssigneesResponse, error) {
	return IssuesAddAssignees(ctx, req, append(c, opt...)...)
}

/*
IssuesAddAssigneesReq is request data for Client.IssuesAddAssignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody IssuesAddAssigneesReqBody
}

// HTTPRequest builds an *http.Request
func (r *IssuesAddAssigneesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesAddAssigneesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "issues/add-assignees",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/assignees", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesAddAssigneesReq) Rel(link string, resp *IssuesAddAssigneesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesAddAssigneesReqBody is a request body for issues/add-assignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesReqBody struct {

	/*
	Usernames of people to assign this issue to. _NOTE: Only users with push access
	can add assignees to an issue. Assignees are silently ignored otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`
}

/*
IssuesAddAssigneesResponse is a response for IssuesAddAssignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesResponse struct {
	common.Response
	request *IssuesAddAssigneesReq
	Data    components.IssueSimple
}

/*
IssuesAddLabels performs requests for "issues/add-labels"

Add labels to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
func IssuesAddLabels(ctx context.Context, req *IssuesAddLabelsReq, opt ...options.Option) (*IssuesAddLabelsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesAddLabelsReq)
	}
	resp := &IssuesAddLabelsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Label{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesAddLabels performs requests for "issues/add-labels"

Add labels to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
func (c Client) IssuesAddLabels(ctx context.Context, req *IssuesAddLabelsReq, opt ...options.Option) (*IssuesAddLabelsResponse, error) {
	return IssuesAddLabels(ctx, req, append(c, opt...)...)
}

/*
IssuesAddLabelsReq is request data for Client.IssuesAddLabels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody IssuesAddLabelsReqBody
}

// HTTPRequest builds an *http.Request
func (r *IssuesAddLabelsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesAddLabelsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "issues/add-labels",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesAddLabelsReq) Rel(link string, resp *IssuesAddLabelsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesAddLabelsReqBody is a request body for issues/add-labels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsReqBody struct {

	/*
	The name of the label to add to the issue. Must contain at least one label.
	**Note:** Alternatively, you can pass a single label as a `string` or an `array`
	of labels directly, but GitHub recommends passing an object with the `labels`
	key.
	*/
	Labels []string `json:"labels"`
}

/*
IssuesAddLabelsResponse is a response for IssuesAddLabels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsResponse struct {
	common.Response
	request *IssuesAddLabelsReq
	Data    []components.Label
}

/*
IssuesCheckUserCanBeAssigned performs requests for "issues/check-user-can-be-assigned"

Check if a user can be assigned.

  GET /repos/{owner}/{repo}/assignees/{assignee}

https://developer.github.com/v3/issues/assignees/#check-if-a-user-can-be-assigned
*/
func IssuesCheckUserCanBeAssigned(ctx context.Context, req *IssuesCheckUserCanBeAssignedReq, opt ...options.Option) (*IssuesCheckUserCanBeAssignedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesCheckUserCanBeAssignedReq)
	}
	resp := &IssuesCheckUserCanBeAssignedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCheckUserCanBeAssigned performs requests for "issues/check-user-can-be-assigned"

Check if a user can be assigned.

  GET /repos/{owner}/{repo}/assignees/{assignee}

https://developer.github.com/v3/issues/assignees/#check-if-a-user-can-be-assigned
*/
func (c Client) IssuesCheckUserCanBeAssigned(ctx context.Context, req *IssuesCheckUserCanBeAssignedReq, opt ...options.Option) (*IssuesCheckUserCanBeAssignedResponse, error) {
	return IssuesCheckUserCanBeAssigned(ctx, req, append(c, opt...)...)
}

/*
IssuesCheckUserCanBeAssignedReq is request data for Client.IssuesCheckUserCanBeAssigned

https://developer.github.com/v3/issues/assignees/#check-if-a-user-can-be-assigned
*/
type IssuesCheckUserCanBeAssignedReq struct {
	_url  string
	Owner string
	Repo  string

	// assignee parameter
	Assignee string
}

// HTTPRequest builds an *http.Request
func (r *IssuesCheckUserCanBeAssignedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesCheckUserCanBeAssignedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "issues/check-user-can-be-assigned",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/assignees/%v", r.Owner, r.Repo, r.Assignee),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCheckUserCanBeAssignedReq) Rel(link string, resp *IssuesCheckUserCanBeAssignedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesCheckUserCanBeAssignedResponse is a response for IssuesCheckUserCanBeAssigned

https://developer.github.com/v3/issues/assignees/#check-if-a-user-can-be-assigned
*/
type IssuesCheckUserCanBeAssignedResponse struct {
	common.Response
	request *IssuesCheckUserCanBeAssignedReq
	Data    bool
}

/*
IssuesCreate performs requests for "issues/create"

Create an issue.

  POST /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#create-an-issue
*/
func IssuesCreate(ctx context.Context, req *IssuesCreateReq, opt ...options.Option) (*IssuesCreateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesCreateReq)
	}
	resp := &IssuesCreateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Issue{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCreate performs requests for "issues/create"

Create an issue.

  POST /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#create-an-issue
*/
func (c Client) IssuesCreate(ctx context.Context, req *IssuesCreateReq, opt ...options.Option) (*IssuesCreateResponse, error) {
	return IssuesCreate(ctx, req, append(c, opt...)...)
}

/*
IssuesCreateReq is request data for Client.IssuesCreate

https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody IssuesCreateReqBody
}

// HTTPRequest builds an *http.Request
func (r *IssuesCreateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesCreateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "issues/create",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCreateReq) Rel(link string, resp *IssuesCreateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesCreateReqBody is a request body for issues/create

https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateReqBody struct {

	/*
	Login for the user that this issue should be assigned to. _NOTE: Only users with
	push access can set the assignee for new issues. The assignee is silently
	dropped otherwise. **This field is deprecated.**_
	*/
	Assignee *string `json:"assignee,omitempty"`

	/*
	Logins for Users to assign to this issue. _NOTE: Only users with push access can
	set assignees for new issues. Assignees are silently dropped otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`

	// The contents of the issue.
	Body *string `json:"body,omitempty"`

	/*
	Labels to associate with this issue. _NOTE: Only users with push access can set
	labels for new issues. Labels are silently dropped otherwise._
	*/
	Labels []string `json:"labels,omitempty"`

	/*
	The `number` of the milestone to associate this issue with. _NOTE: Only users
	with push access can set the milestone for new issues. The milestone is silently
	dropped otherwise._
	*/
	Milestone *int64 `json:"milestone,omitempty"`

	// The title of the issue.
	Title *string `json:"title"`
}

/*
IssuesCreateResponse is a response for IssuesCreate

https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateResponse struct {
	common.Response
	request *IssuesCreateReq
	Data    components.Issue
}

/*
IssuesCreateComment performs requests for "issues/create-comment"

Create an issue comment.

  POST /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
func IssuesCreateComment(ctx context.Context, req *IssuesCreateCommentReq, opt ...options.Option) (*IssuesCreateCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesCreateCommentReq)
	}
	resp := &IssuesCreateCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.IssueComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCreateComment performs requests for "issues/create-comment"

Create an issue comment.

  POST /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
func (c Client) IssuesCreateComment(ctx context.Context, req *IssuesCreateCommentReq, opt ...options.Option) (*IssuesCreateCommentResponse, error) {
	return IssuesCreateComment(ctx, req, append(c, opt...)...)
}

/*
IssuesCreateCommentReq is request data for Client.IssuesCreateComment

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
type IssuesCreateCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody IssuesCreateCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *IssuesCreateCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesCreateCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "issues/create-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/comments", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCreateCommentReq) Rel(link string, resp *IssuesCreateCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesCreateCommentReqBody is a request body for issues/create-comment

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
type IssuesCreateCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`
}

/*
IssuesCreateCommentResponse is a response for IssuesCreateComment

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
type IssuesCreateCommentResponse struct {
	common.Response
	request *IssuesCreateCommentReq
	Data    components.IssueComment
}

/*
IssuesCreateLabel performs requests for "issues/create-label"

Create a label.

  POST /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#create-a-label
*/
func IssuesCreateLabel(ctx context.Context, req *IssuesCreateLabelReq, opt ...options.Option) (*IssuesCreateLabelResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesCreateLabelReq)
	}
	resp := &IssuesCreateLabelResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Label{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCreateLabel performs requests for "issues/create-label"

Create a label.

  POST /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#create-a-label
*/
func (c Client) IssuesCreateLabel(ctx context.Context, req *IssuesCreateLabelReq, opt ...options.Option) (*IssuesCreateLabelResponse, error) {
	return IssuesCreateLabel(ctx, req, append(c, opt...)...)
}

/*
IssuesCreateLabelReq is request data for Client.IssuesCreateLabel

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody IssuesCreateLabelReqBody
}

// HTTPRequest builds an *http.Request
func (r *IssuesCreateLabelReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesCreateLabelReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "issues/create-label",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/labels", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCreateLabelReq) Rel(link string, resp *IssuesCreateLabelResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesCreateLabelReqBody is a request body for issues/create-label

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelReqBody struct {

	// The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.
	Color *string `json:"color,omitempty"`

	// A short description of the label.
	Description *string `json:"description,omitempty"`

	/*
	The name of the label. Emoji can be added to label names, using either native
	emoji or colon-style markup. For example, typing `:strawberry:` will render the
	emoji
	![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png
	":strawberry:"). For a full list of available emoji and codes, see
	[emoji-cheat-sheet.com](http://emoji-cheat-sheet.com/).
	*/
	Name *string `json:"name"`
}

/*
IssuesCreateLabelResponse is a response for IssuesCreateLabel

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelResponse struct {
	common.Response
	request *IssuesCreateLabelReq
	Data    components.Label
}

/*
IssuesCreateMilestone performs requests for "issues/create-milestone"

Create a milestone.

  POST /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
func IssuesCreateMilestone(ctx context.Context, req *IssuesCreateMilestoneReq, opt ...options.Option) (*IssuesCreateMilestoneResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesCreateMilestoneReq)
	}
	resp := &IssuesCreateMilestoneResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Milestone{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCreateMilestone performs requests for "issues/create-milestone"

Create a milestone.

  POST /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
func (c Client) IssuesCreateMilestone(ctx context.Context, req *IssuesCreateMilestoneReq, opt ...options.Option) (*IssuesCreateMilestoneResponse, error) {
	return IssuesCreateMilestone(ctx, req, append(c, opt...)...)
}

/*
IssuesCreateMilestoneReq is request data for Client.IssuesCreateMilestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody IssuesCreateMilestoneReqBody
}

// HTTPRequest builds an *http.Request
func (r *IssuesCreateMilestoneReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesCreateMilestoneReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "issues/create-milestone",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/milestones", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCreateMilestoneReq) Rel(link string, resp *IssuesCreateMilestoneResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesCreateMilestoneReqBody is a request body for issues/create-milestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneReqBody struct {

	// A description of the milestone.
	Description *string `json:"description,omitempty"`

	/*
	The milestone due date. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	DueOn *string `json:"due_on,omitempty"`

	// The state of the milestone. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the milestone.
	Title *string `json:"title"`
}

/*
IssuesCreateMilestoneResponse is a response for IssuesCreateMilestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneResponse struct {
	common.Response
	request *IssuesCreateMilestoneReq
	Data    components.Milestone
}

/*
IssuesDeleteComment performs requests for "issues/delete-comment"

Delete an issue comment.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#delete-an-issue-comment
*/
func IssuesDeleteComment(ctx context.Context, req *IssuesDeleteCommentReq, opt ...options.Option) (*IssuesDeleteCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesDeleteCommentReq)
	}
	resp := &IssuesDeleteCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesDeleteComment performs requests for "issues/delete-comment"

Delete an issue comment.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#delete-an-issue-comment
*/
func (c Client) IssuesDeleteComment(ctx context.Context, req *IssuesDeleteCommentReq, opt ...options.Option) (*IssuesDeleteCommentResponse, error) {
	return IssuesDeleteComment(ctx, req, append(c, opt...)...)
}

/*
IssuesDeleteCommentReq is request data for Client.IssuesDeleteComment

https://developer.github.com/v3/issues/comments/#delete-an-issue-comment
*/
type IssuesDeleteCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request
func (r *IssuesDeleteCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesDeleteCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "issues/delete-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesDeleteCommentReq) Rel(link string, resp *IssuesDeleteCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesDeleteCommentResponse is a response for IssuesDeleteComment

https://developer.github.com/v3/issues/comments/#delete-an-issue-comment
*/
type IssuesDeleteCommentResponse struct {
	common.Response
	request *IssuesDeleteCommentReq
}

/*
IssuesDeleteLabel performs requests for "issues/delete-label"

Delete a label.

  DELETE /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
func IssuesDeleteLabel(ctx context.Context, req *IssuesDeleteLabelReq, opt ...options.Option) (*IssuesDeleteLabelResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesDeleteLabelReq)
	}
	resp := &IssuesDeleteLabelResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesDeleteLabel performs requests for "issues/delete-label"

Delete a label.

  DELETE /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
func (c Client) IssuesDeleteLabel(ctx context.Context, req *IssuesDeleteLabelReq, opt ...options.Option) (*IssuesDeleteLabelResponse, error) {
	return IssuesDeleteLabel(ctx, req, append(c, opt...)...)
}

/*
IssuesDeleteLabelReq is request data for Client.IssuesDeleteLabel

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
type IssuesDeleteLabelReq struct {
	_url  string
	Owner string
	Repo  string

	// name parameter
	Name string
}

// HTTPRequest builds an *http.Request
func (r *IssuesDeleteLabelReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesDeleteLabelReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "issues/delete-label",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesDeleteLabelReq) Rel(link string, resp *IssuesDeleteLabelResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesDeleteLabelResponse is a response for IssuesDeleteLabel

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
type IssuesDeleteLabelResponse struct {
	common.Response
	request *IssuesDeleteLabelReq
}

/*
IssuesDeleteMilestone performs requests for "issues/delete-milestone"

Delete a milestone.

  DELETE /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
func IssuesDeleteMilestone(ctx context.Context, req *IssuesDeleteMilestoneReq, opt ...options.Option) (*IssuesDeleteMilestoneResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesDeleteMilestoneReq)
	}
	resp := &IssuesDeleteMilestoneResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesDeleteMilestone performs requests for "issues/delete-milestone"

Delete a milestone.

  DELETE /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
func (c Client) IssuesDeleteMilestone(ctx context.Context, req *IssuesDeleteMilestoneReq, opt ...options.Option) (*IssuesDeleteMilestoneResponse, error) {
	return IssuesDeleteMilestone(ctx, req, append(c, opt...)...)
}

/*
IssuesDeleteMilestoneReq is request data for Client.IssuesDeleteMilestone

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
type IssuesDeleteMilestoneReq struct {
	_url  string
	Owner string
	Repo  string

	// milestone_number parameter
	MilestoneNumber int64
}

// HTTPRequest builds an *http.Request
func (r *IssuesDeleteMilestoneReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesDeleteMilestoneReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "issues/delete-milestone",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesDeleteMilestoneReq) Rel(link string, resp *IssuesDeleteMilestoneResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesDeleteMilestoneResponse is a response for IssuesDeleteMilestone

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
type IssuesDeleteMilestoneResponse struct {
	common.Response
	request *IssuesDeleteMilestoneReq
	Data    bool
}

/*
IssuesGet performs requests for "issues/get"

Get an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#get-an-issue
*/
func IssuesGet(ctx context.Context, req *IssuesGetReq, opt ...options.Option) (*IssuesGetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesGetReq)
	}
	resp := &IssuesGetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Issue{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGet performs requests for "issues/get"

Get an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#get-an-issue
*/
func (c Client) IssuesGet(ctx context.Context, req *IssuesGetReq, opt ...options.Option) (*IssuesGetResponse, error) {
	return IssuesGet(ctx, req, append(c, opt...)...)
}

/*
IssuesGetReq is request data for Client.IssuesGet

https://developer.github.com/v3/issues/#get-an-issue
*/
type IssuesGetReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *IssuesGetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesGetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "issues/get",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200, 301, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetReq) Rel(link string, resp *IssuesGetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesGetResponse is a response for IssuesGet

https://developer.github.com/v3/issues/#get-an-issue
*/
type IssuesGetResponse struct {
	common.Response
	request *IssuesGetReq
	Data    components.Issue
}

/*
IssuesGetComment performs requests for "issues/get-comment"

Get an issue comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#get-an-issue-comment
*/
func IssuesGetComment(ctx context.Context, req *IssuesGetCommentReq, opt ...options.Option) (*IssuesGetCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesGetCommentReq)
	}
	resp := &IssuesGetCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.IssueComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGetComment performs requests for "issues/get-comment"

Get an issue comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#get-an-issue-comment
*/
func (c Client) IssuesGetComment(ctx context.Context, req *IssuesGetCommentReq, opt ...options.Option) (*IssuesGetCommentResponse, error) {
	return IssuesGetComment(ctx, req, append(c, opt...)...)
}

/*
IssuesGetCommentReq is request data for Client.IssuesGetComment

https://developer.github.com/v3/issues/comments/#get-an-issue-comment
*/
type IssuesGetCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *IssuesGetCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesGetCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man", "squirrel-girl"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "issues/get-comment",
		Previews: map[string]bool{
			"machine-man":   r.MachineManPreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetCommentReq) Rel(link string, resp *IssuesGetCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesGetCommentResponse is a response for IssuesGetComment

https://developer.github.com/v3/issues/comments/#get-an-issue-comment
*/
type IssuesGetCommentResponse struct {
	common.Response
	request *IssuesGetCommentReq
	Data    components.IssueComment
}

/*
IssuesGetEvent performs requests for "issues/get-event"

Get an issue event.

  GET /repos/{owner}/{repo}/issues/events/{event_id}

https://developer.github.com/v3/issues/events/#get-an-issue-event
*/
func IssuesGetEvent(ctx context.Context, req *IssuesGetEventReq, opt ...options.Option) (*IssuesGetEventResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesGetEventReq)
	}
	resp := &IssuesGetEventResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.IssueEvent{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGetEvent performs requests for "issues/get-event"

Get an issue event.

  GET /repos/{owner}/{repo}/issues/events/{event_id}

https://developer.github.com/v3/issues/events/#get-an-issue-event
*/
func (c Client) IssuesGetEvent(ctx context.Context, req *IssuesGetEventReq, opt ...options.Option) (*IssuesGetEventResponse, error) {
	return IssuesGetEvent(ctx, req, append(c, opt...)...)
}

/*
IssuesGetEventReq is request data for Client.IssuesGetEvent

https://developer.github.com/v3/issues/events/#get-an-issue-event
*/
type IssuesGetEventReq struct {
	_url  string
	Owner string
	Repo  string

	// event_id parameter
	EventId int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request
func (r *IssuesGetEventReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesGetEventReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"starfox", "machine-man", "sailor-v"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "issues/get-event",
		Previews: map[string]bool{
			"machine-man": r.MachineManPreview,
			"sailor-v":    r.SailorVPreview,
			"starfox":     r.StarfoxPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/events/%v", r.Owner, r.Repo, r.EventId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetEventReq) Rel(link string, resp *IssuesGetEventResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesGetEventResponse is a response for IssuesGetEvent

https://developer.github.com/v3/issues/events/#get-an-issue-event
*/
type IssuesGetEventResponse struct {
	common.Response
	request *IssuesGetEventReq
	Data    components.IssueEvent
}

/*
IssuesGetLabel performs requests for "issues/get-label"

Get a label.

  GET /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#get-a-label
*/
func IssuesGetLabel(ctx context.Context, req *IssuesGetLabelReq, opt ...options.Option) (*IssuesGetLabelResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesGetLabelReq)
	}
	resp := &IssuesGetLabelResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Label{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGetLabel performs requests for "issues/get-label"

Get a label.

  GET /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#get-a-label
*/
func (c Client) IssuesGetLabel(ctx context.Context, req *IssuesGetLabelReq, opt ...options.Option) (*IssuesGetLabelResponse, error) {
	return IssuesGetLabel(ctx, req, append(c, opt...)...)
}

/*
IssuesGetLabelReq is request data for Client.IssuesGetLabel

https://developer.github.com/v3/issues/labels/#get-a-label
*/
type IssuesGetLabelReq struct {
	_url  string
	Owner string
	Repo  string

	// name parameter
	Name string
}

// HTTPRequest builds an *http.Request
func (r *IssuesGetLabelReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesGetLabelReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "issues/get-label",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetLabelReq) Rel(link string, resp *IssuesGetLabelResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesGetLabelResponse is a response for IssuesGetLabel

https://developer.github.com/v3/issues/labels/#get-a-label
*/
type IssuesGetLabelResponse struct {
	common.Response
	request *IssuesGetLabelReq
	Data    components.Label
}

/*
IssuesGetMilestone performs requests for "issues/get-milestone"

Get a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#get-a-milestone
*/
func IssuesGetMilestone(ctx context.Context, req *IssuesGetMilestoneReq, opt ...options.Option) (*IssuesGetMilestoneResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesGetMilestoneReq)
	}
	resp := &IssuesGetMilestoneResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Milestone{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGetMilestone performs requests for "issues/get-milestone"

Get a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#get-a-milestone
*/
func (c Client) IssuesGetMilestone(ctx context.Context, req *IssuesGetMilestoneReq, opt ...options.Option) (*IssuesGetMilestoneResponse, error) {
	return IssuesGetMilestone(ctx, req, append(c, opt...)...)
}

/*
IssuesGetMilestoneReq is request data for Client.IssuesGetMilestone

https://developer.github.com/v3/issues/milestones/#get-a-milestone
*/
type IssuesGetMilestoneReq struct {
	_url  string
	Owner string
	Repo  string

	// milestone_number parameter
	MilestoneNumber int64
}

// HTTPRequest builds an *http.Request
func (r *IssuesGetMilestoneReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesGetMilestoneReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "issues/get-milestone",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetMilestoneReq) Rel(link string, resp *IssuesGetMilestoneResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesGetMilestoneResponse is a response for IssuesGetMilestone

https://developer.github.com/v3/issues/milestones/#get-a-milestone
*/
type IssuesGetMilestoneResponse struct {
	common.Response
	request *IssuesGetMilestoneReq
	Data    components.Milestone
}

/*
IssuesList performs requests for "issues/list"

List issues assigned to the authenticated user.

  GET /issues

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
func IssuesList(ctx context.Context, req *IssuesListReq, opt ...options.Option) (*IssuesListResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListReq)
	}
	resp := &IssuesListResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Issue{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesList performs requests for "issues/list"

List issues assigned to the authenticated user.

  GET /issues

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
func (c Client) IssuesList(ctx context.Context, req *IssuesListReq, opt ...options.Option) (*IssuesListResponse, error) {
	return IssuesList(ctx, req, append(c, opt...)...)
}

/*
IssuesListReq is request data for Client.IssuesList

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
type IssuesListReq struct {
	_url string

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since  *string
	Collab *bool
	Orgs   *bool
	Owned  *bool
	Pulls  *bool

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *IssuesListReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.Collab != nil {
		query.Set("collab", strconv.FormatBool(*r.Collab))
	}
	if r.Orgs != nil {
		query.Set("orgs", strconv.FormatBool(*r.Orgs))
	}
	if r.Owned != nil {
		query.Set("owned", strconv.FormatBool(*r.Owned))
	}
	if r.Pulls != nil {
		query.Set("pulls", strconv.FormatBool(*r.Pulls))
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man", "squirrel-girl"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "issues/list",
		Previews: map[string]bool{
			"machine-man":   r.MachineManPreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/issues"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListReq) Rel(link string, resp *IssuesListResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListResponse is a response for IssuesList

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
type IssuesListResponse struct {
	common.Response
	request *IssuesListReq
	Data    []components.Issue
}

/*
IssuesListAssignees performs requests for "issues/list-assignees"

List assignees.

  GET /repos/{owner}/{repo}/assignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
func IssuesListAssignees(ctx context.Context, req *IssuesListAssigneesReq, opt ...options.Option) (*IssuesListAssigneesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListAssigneesReq)
	}
	resp := &IssuesListAssigneesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListAssignees performs requests for "issues/list-assignees"

List assignees.

  GET /repos/{owner}/{repo}/assignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
func (c Client) IssuesListAssignees(ctx context.Context, req *IssuesListAssigneesReq, opt ...options.Option) (*IssuesListAssigneesResponse, error) {
	return IssuesListAssignees(ctx, req, append(c, opt...)...)
}

/*
IssuesListAssigneesReq is request data for Client.IssuesListAssignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
type IssuesListAssigneesReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *IssuesListAssigneesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListAssigneesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "issues/list-assignees",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/assignees", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListAssigneesReq) Rel(link string, resp *IssuesListAssigneesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListAssigneesResponse is a response for IssuesListAssignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
type IssuesListAssigneesResponse struct {
	common.Response
	request *IssuesListAssigneesReq
	Data    []components.SimpleUser
}

/*
IssuesListComments performs requests for "issues/list-comments"

List issue comments.

  GET /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#list-issue-comments
*/
func IssuesListComments(ctx context.Context, req *IssuesListCommentsReq, opt ...options.Option) (*IssuesListCommentsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListCommentsReq)
	}
	resp := &IssuesListCommentsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.IssueComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListComments performs requests for "issues/list-comments"

List issue comments.

  GET /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#list-issue-comments
*/
func (c Client) IssuesListComments(ctx context.Context, req *IssuesListCommentsReq, opt ...options.Option) (*IssuesListCommentsResponse, error) {
	return IssuesListComments(ctx, req, append(c, opt...)...)
}

/*
IssuesListCommentsReq is request data for Client.IssuesListComments

https://developer.github.com/v3/issues/comments/#list-issue-comments
*/
type IssuesListCommentsReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *IssuesListCommentsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListCommentsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "issues/list-comments",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/comments", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListCommentsReq) Rel(link string, resp *IssuesListCommentsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListCommentsResponse is a response for IssuesListComments

https://developer.github.com/v3/issues/comments/#list-issue-comments
*/
type IssuesListCommentsResponse struct {
	common.Response
	request *IssuesListCommentsReq
	Data    []components.IssueComment
}

/*
IssuesListCommentsForRepo performs requests for "issues/list-comments-for-repo"

List issue comments for a repository.

  GET /repos/{owner}/{repo}/issues/comments

https://developer.github.com/v3/issues/comments/#list-issue-comments-for-a-repository
*/
func IssuesListCommentsForRepo(ctx context.Context, req *IssuesListCommentsForRepoReq, opt ...options.Option) (*IssuesListCommentsForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListCommentsForRepoReq)
	}
	resp := &IssuesListCommentsForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.IssueComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListCommentsForRepo performs requests for "issues/list-comments-for-repo"

List issue comments for a repository.

  GET /repos/{owner}/{repo}/issues/comments

https://developer.github.com/v3/issues/comments/#list-issue-comments-for-a-repository
*/
func (c Client) IssuesListCommentsForRepo(ctx context.Context, req *IssuesListCommentsForRepoReq, opt ...options.Option) (*IssuesListCommentsForRepoResponse, error) {
	return IssuesListCommentsForRepo(ctx, req, append(c, opt...)...)
}

/*
IssuesListCommentsForRepoReq is request data for Client.IssuesListCommentsForRepo

https://developer.github.com/v3/issues/comments/#list-issue-comments-for-a-repository
*/
type IssuesListCommentsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// Either `asc` or `desc`. Ignored without the `sort` parameter.
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *IssuesListCommentsForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListCommentsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "issues/list-comments-for-repo",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/comments", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListCommentsForRepoReq) Rel(link string, resp *IssuesListCommentsForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListCommentsForRepoResponse is a response for IssuesListCommentsForRepo

https://developer.github.com/v3/issues/comments/#list-issue-comments-for-a-repository
*/
type IssuesListCommentsForRepoResponse struct {
	common.Response
	request *IssuesListCommentsForRepoReq
	Data    []components.IssueComment
}

/*
IssuesListEvents performs requests for "issues/list-events"

List issue events.

  GET /repos/{owner}/{repo}/issues/{issue_number}/events

https://developer.github.com/v3/issues/events/#list-issue-events
*/
func IssuesListEvents(ctx context.Context, req *IssuesListEventsReq, opt ...options.Option) (*IssuesListEventsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListEventsReq)
	}
	resp := &IssuesListEventsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.IssueEventForIssue{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListEvents performs requests for "issues/list-events"

List issue events.

  GET /repos/{owner}/{repo}/issues/{issue_number}/events

https://developer.github.com/v3/issues/events/#list-issue-events
*/
func (c Client) IssuesListEvents(ctx context.Context, req *IssuesListEventsReq, opt ...options.Option) (*IssuesListEventsResponse, error) {
	return IssuesListEvents(ctx, req, append(c, opt...)...)
}

/*
IssuesListEventsReq is request data for Client.IssuesListEvents

https://developer.github.com/v3/issues/events/#list-issue-events
*/
type IssuesListEventsReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request
func (r *IssuesListEventsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListEventsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"starfox", "sailor-v"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "issues/list-events",
		Previews: map[string]bool{
			"sailor-v": r.SailorVPreview,
			"starfox":  r.StarfoxPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/events", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListEventsReq) Rel(link string, resp *IssuesListEventsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListEventsResponse is a response for IssuesListEvents

https://developer.github.com/v3/issues/events/#list-issue-events
*/
type IssuesListEventsResponse struct {
	common.Response
	request *IssuesListEventsReq
	Data    []components.IssueEventForIssue
}

/*
IssuesListEventsForRepo performs requests for "issues/list-events-for-repo"

List issue events for a repository.

  GET /repos/{owner}/{repo}/issues/events

https://developer.github.com/v3/issues/events/#list-issue-events-for-a-repository
*/
func IssuesListEventsForRepo(ctx context.Context, req *IssuesListEventsForRepoReq, opt ...options.Option) (*IssuesListEventsForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListEventsForRepoReq)
	}
	resp := &IssuesListEventsForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.IssueEvent{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListEventsForRepo performs requests for "issues/list-events-for-repo"

List issue events for a repository.

  GET /repos/{owner}/{repo}/issues/events

https://developer.github.com/v3/issues/events/#list-issue-events-for-a-repository
*/
func (c Client) IssuesListEventsForRepo(ctx context.Context, req *IssuesListEventsForRepoReq, opt ...options.Option) (*IssuesListEventsForRepoResponse, error) {
	return IssuesListEventsForRepo(ctx, req, append(c, opt...)...)
}

/*
IssuesListEventsForRepoReq is request data for Client.IssuesListEventsForRepo

https://developer.github.com/v3/issues/events/#list-issue-events-for-a-repository
*/
type IssuesListEventsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request
func (r *IssuesListEventsForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListEventsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"starfox", "sailor-v"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "issues/list-events-for-repo",
		Previews: map[string]bool{
			"sailor-v": r.SailorVPreview,
			"starfox":  r.StarfoxPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/events", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListEventsForRepoReq) Rel(link string, resp *IssuesListEventsForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListEventsForRepoResponse is a response for IssuesListEventsForRepo

https://developer.github.com/v3/issues/events/#list-issue-events-for-a-repository
*/
type IssuesListEventsForRepoResponse struct {
	common.Response
	request *IssuesListEventsForRepoReq
	Data    []components.IssueEvent
}

/*
IssuesListEventsForTimeline performs requests for "issues/list-events-for-timeline"

List timeline events for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/timeline

https://developer.github.com/v3/issues/timeline/#list-timeline-events-for-an-issue
*/
func IssuesListEventsForTimeline(ctx context.Context, req *IssuesListEventsForTimelineReq, opt ...options.Option) (*IssuesListEventsForTimelineResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListEventsForTimelineReq)
	}
	resp := &IssuesListEventsForTimelineResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.IssueEventForIssue{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListEventsForTimeline performs requests for "issues/list-events-for-timeline"

List timeline events for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/timeline

https://developer.github.com/v3/issues/timeline/#list-timeline-events-for-an-issue
*/
func (c Client) IssuesListEventsForTimeline(ctx context.Context, req *IssuesListEventsForTimelineReq, opt ...options.Option) (*IssuesListEventsForTimelineResponse, error) {
	return IssuesListEventsForTimeline(ctx, req, append(c, opt...)...)
}

/*
IssuesListEventsForTimelineReq is request data for Client.IssuesListEventsForTimeline

https://developer.github.com/v3/issues/timeline/#list-timeline-events-for-an-issue
*/
type IssuesListEventsForTimelineReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The API to get issue timeline events is currently available for developers to
	preview. During the preview period, the APIs may change without advance notice.
	Please see the [blog
	post](https://developer.github.com/changes/2016-05-23-timeline-preview-api/) for
	full details. To access the API you must set this to true.
	*/
	MockingbirdPreview bool

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool
}

// HTTPRequest builds an *http.Request
func (r *IssuesListEventsForTimelineReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListEventsForTimelineReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"mockingbird", "starfox"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "issues/list-events-for-timeline",
		Previews: map[string]bool{
			"mockingbird": r.MockingbirdPreview,
			"starfox":     r.StarfoxPreview,
		},
		RequiredPreviews: []string{"mockingbird"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/timeline", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListEventsForTimelineReq) Rel(link string, resp *IssuesListEventsForTimelineResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListEventsForTimelineResponse is a response for IssuesListEventsForTimeline

https://developer.github.com/v3/issues/timeline/#list-timeline-events-for-an-issue
*/
type IssuesListEventsForTimelineResponse struct {
	common.Response
	request *IssuesListEventsForTimelineReq
	Data    []components.IssueEventForIssue
}

/*
IssuesListForAuthenticatedUser performs requests for "issues/list-for-authenticated-user"

List user account issues assigned to the authenticated user.

  GET /user/issues

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
func IssuesListForAuthenticatedUser(ctx context.Context, req *IssuesListForAuthenticatedUserReq, opt ...options.Option) (*IssuesListForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListForAuthenticatedUserReq)
	}
	resp := &IssuesListForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Issue{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListForAuthenticatedUser performs requests for "issues/list-for-authenticated-user"

List user account issues assigned to the authenticated user.

  GET /user/issues

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
func (c Client) IssuesListForAuthenticatedUser(ctx context.Context, req *IssuesListForAuthenticatedUserReq, opt ...options.Option) (*IssuesListForAuthenticatedUserResponse, error) {
	return IssuesListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
IssuesListForAuthenticatedUserReq is request data for Client.IssuesListForAuthenticatedUser

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
type IssuesListForAuthenticatedUserReq struct {
	_url string

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *IssuesListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man", "squirrel-girl"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "issues/list-for-authenticated-user",
		Previews: map[string]bool{
			"machine-man":   r.MachineManPreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/issues"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListForAuthenticatedUserReq) Rel(link string, resp *IssuesListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListForAuthenticatedUserResponse is a response for IssuesListForAuthenticatedUser

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
type IssuesListForAuthenticatedUserResponse struct {
	common.Response
	request *IssuesListForAuthenticatedUserReq
	Data    []components.Issue
}

/*
IssuesListForOrg performs requests for "issues/list-for-org"

List organization issues assigned to the authenticated user.

  GET /orgs/{org}/issues

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
func IssuesListForOrg(ctx context.Context, req *IssuesListForOrgReq, opt ...options.Option) (*IssuesListForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListForOrgReq)
	}
	resp := &IssuesListForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Issue{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListForOrg performs requests for "issues/list-for-org"

List organization issues assigned to the authenticated user.

  GET /orgs/{org}/issues

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
func (c Client) IssuesListForOrg(ctx context.Context, req *IssuesListForOrgReq, opt ...options.Option) (*IssuesListForOrgResponse, error) {
	return IssuesListForOrg(ctx, req, append(c, opt...)...)
}

/*
IssuesListForOrgReq is request data for Client.IssuesListForOrg

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
type IssuesListForOrgReq struct {
	_url string
	Org  string

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *IssuesListForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man", "squirrel-girl"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "issues/list-for-org",
		Previews: map[string]bool{
			"machine-man":   r.MachineManPreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/issues", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListForOrgReq) Rel(link string, resp *IssuesListForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListForOrgResponse is a response for IssuesListForOrg

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
type IssuesListForOrgResponse struct {
	common.Response
	request *IssuesListForOrgReq
	Data    []components.Issue
}

/*
IssuesListForRepo performs requests for "issues/list-for-repo"

List repository issues.

  GET /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#list-repository-issues
*/
func IssuesListForRepo(ctx context.Context, req *IssuesListForRepoReq, opt ...options.Option) (*IssuesListForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListForRepoReq)
	}
	resp := &IssuesListForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.IssueSimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListForRepo performs requests for "issues/list-for-repo"

List repository issues.

  GET /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#list-repository-issues
*/
func (c Client) IssuesListForRepo(ctx context.Context, req *IssuesListForRepoReq, opt ...options.Option) (*IssuesListForRepoResponse, error) {
	return IssuesListForRepo(ctx, req, append(c, opt...)...)
}

/*
IssuesListForRepoReq is request data for Client.IssuesListForRepo

https://developer.github.com/v3/issues/#list-repository-issues
*/
type IssuesListForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	If an `integer` is passed, it should refer to a milestone by its `number` field.
	If the string `*` is passed, issues with any milestone are accepted. If the
	string `none` is passed, issues without milestones are returned.
	*/
	Milestone *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	/*
	Can be the name of a user. Pass in `none` for issues with no assigned user, and
	`*` for issues assigned to any user.
	*/
	Assignee *string

	// The user that created the issue.
	Creator *string

	// A user that's mentioned in the issue.
	Mentioned *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *IssuesListForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Milestone != nil {
		query.Set("milestone", *r.Milestone)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Assignee != nil {
		query.Set("assignee", *r.Assignee)
	}
	if r.Creator != nil {
		query.Set("creator", *r.Creator)
	}
	if r.Mentioned != nil {
		query.Set("mentioned", *r.Mentioned)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"machine-man", "squirrel-girl"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "issues/list-for-repo",
		Previews: map[string]bool{
			"machine-man":   r.MachineManPreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 301},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListForRepoReq) Rel(link string, resp *IssuesListForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListForRepoResponse is a response for IssuesListForRepo

https://developer.github.com/v3/issues/#list-repository-issues
*/
type IssuesListForRepoResponse struct {
	common.Response
	request *IssuesListForRepoReq
	Data    []components.IssueSimple
}

/*
IssuesListLabelsForMilestone performs requests for "issues/list-labels-for-milestone"

List labels for issues in a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-issues-in-a-milestone
*/
func IssuesListLabelsForMilestone(ctx context.Context, req *IssuesListLabelsForMilestoneReq, opt ...options.Option) (*IssuesListLabelsForMilestoneResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListLabelsForMilestoneReq)
	}
	resp := &IssuesListLabelsForMilestoneResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Label{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListLabelsForMilestone performs requests for "issues/list-labels-for-milestone"

List labels for issues in a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-issues-in-a-milestone
*/
func (c Client) IssuesListLabelsForMilestone(ctx context.Context, req *IssuesListLabelsForMilestoneReq, opt ...options.Option) (*IssuesListLabelsForMilestoneResponse, error) {
	return IssuesListLabelsForMilestone(ctx, req, append(c, opt...)...)
}

/*
IssuesListLabelsForMilestoneReq is request data for Client.IssuesListLabelsForMilestone

https://developer.github.com/v3/issues/labels/#list-labels-for-issues-in-a-milestone
*/
type IssuesListLabelsForMilestoneReq struct {
	_url  string
	Owner string
	Repo  string

	// milestone_number parameter
	MilestoneNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *IssuesListLabelsForMilestoneReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListLabelsForMilestoneReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "issues/list-labels-for-milestone",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/milestones/%v/labels", r.Owner, r.Repo, r.MilestoneNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListLabelsForMilestoneReq) Rel(link string, resp *IssuesListLabelsForMilestoneResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListLabelsForMilestoneResponse is a response for IssuesListLabelsForMilestone

https://developer.github.com/v3/issues/labels/#list-labels-for-issues-in-a-milestone
*/
type IssuesListLabelsForMilestoneResponse struct {
	common.Response
	request *IssuesListLabelsForMilestoneReq
	Data    []components.Label
}

/*
IssuesListLabelsForRepo performs requests for "issues/list-labels-for-repo"

List labels for a repository.

  GET /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-a-repository
*/
func IssuesListLabelsForRepo(ctx context.Context, req *IssuesListLabelsForRepoReq, opt ...options.Option) (*IssuesListLabelsForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListLabelsForRepoReq)
	}
	resp := &IssuesListLabelsForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Label{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListLabelsForRepo performs requests for "issues/list-labels-for-repo"

List labels for a repository.

  GET /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-a-repository
*/
func (c Client) IssuesListLabelsForRepo(ctx context.Context, req *IssuesListLabelsForRepoReq, opt ...options.Option) (*IssuesListLabelsForRepoResponse, error) {
	return IssuesListLabelsForRepo(ctx, req, append(c, opt...)...)
}

/*
IssuesListLabelsForRepoReq is request data for Client.IssuesListLabelsForRepo

https://developer.github.com/v3/issues/labels/#list-labels-for-a-repository
*/
type IssuesListLabelsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *IssuesListLabelsForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListLabelsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "issues/list-labels-for-repo",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/labels", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListLabelsForRepoReq) Rel(link string, resp *IssuesListLabelsForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListLabelsForRepoResponse is a response for IssuesListLabelsForRepo

https://developer.github.com/v3/issues/labels/#list-labels-for-a-repository
*/
type IssuesListLabelsForRepoResponse struct {
	common.Response
	request *IssuesListLabelsForRepoReq
	Data    []components.Label
}

/*
IssuesListLabelsOnIssue performs requests for "issues/list-labels-on-issue"

List labels for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-an-issue
*/
func IssuesListLabelsOnIssue(ctx context.Context, req *IssuesListLabelsOnIssueReq, opt ...options.Option) (*IssuesListLabelsOnIssueResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListLabelsOnIssueReq)
	}
	resp := &IssuesListLabelsOnIssueResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Label{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListLabelsOnIssue performs requests for "issues/list-labels-on-issue"

List labels for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-an-issue
*/
func (c Client) IssuesListLabelsOnIssue(ctx context.Context, req *IssuesListLabelsOnIssueReq, opt ...options.Option) (*IssuesListLabelsOnIssueResponse, error) {
	return IssuesListLabelsOnIssue(ctx, req, append(c, opt...)...)
}

/*
IssuesListLabelsOnIssueReq is request data for Client.IssuesListLabelsOnIssue

https://developer.github.com/v3/issues/labels/#list-labels-for-an-issue
*/
type IssuesListLabelsOnIssueReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *IssuesListLabelsOnIssueReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListLabelsOnIssueReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "issues/list-labels-on-issue",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListLabelsOnIssueReq) Rel(link string, resp *IssuesListLabelsOnIssueResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListLabelsOnIssueResponse is a response for IssuesListLabelsOnIssue

https://developer.github.com/v3/issues/labels/#list-labels-for-an-issue
*/
type IssuesListLabelsOnIssueResponse struct {
	common.Response
	request *IssuesListLabelsOnIssueReq
	Data    []components.Label
}

/*
IssuesListMilestones performs requests for "issues/list-milestones"

List milestones.

  GET /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#list-milestones
*/
func IssuesListMilestones(ctx context.Context, req *IssuesListMilestonesReq, opt ...options.Option) (*IssuesListMilestonesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesListMilestonesReq)
	}
	resp := &IssuesListMilestonesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Milestone{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListMilestones performs requests for "issues/list-milestones"

List milestones.

  GET /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#list-milestones
*/
func (c Client) IssuesListMilestones(ctx context.Context, req *IssuesListMilestonesReq, opt ...options.Option) (*IssuesListMilestonesResponse, error) {
	return IssuesListMilestones(ctx, req, append(c, opt...)...)
}

/*
IssuesListMilestonesReq is request data for Client.IssuesListMilestones

https://developer.github.com/v3/issues/milestones/#list-milestones
*/
type IssuesListMilestonesReq struct {
	_url  string
	Owner string
	Repo  string

	// The state of the milestone. Either `open`, `closed`, or `all`.
	State *string

	// What to sort results by. Either `due_on` or `completeness`.
	Sort *string

	// The direction of the sort. Either `asc` or `desc`.
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *IssuesListMilestonesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesListMilestonesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "issues/list-milestones",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/milestones", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListMilestonesReq) Rel(link string, resp *IssuesListMilestonesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListMilestonesResponse is a response for IssuesListMilestones

https://developer.github.com/v3/issues/milestones/#list-milestones
*/
type IssuesListMilestonesResponse struct {
	common.Response
	request *IssuesListMilestonesReq
	Data    []components.Milestone
}

/*
IssuesLock performs requests for "issues/lock"

Lock an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
func IssuesLock(ctx context.Context, req *IssuesLockReq, opt ...options.Option) (*IssuesLockResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesLockReq)
	}
	resp := &IssuesLockResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesLock performs requests for "issues/lock"

Lock an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
func (c Client) IssuesLock(ctx context.Context, req *IssuesLockReq, opt ...options.Option) (*IssuesLockResponse, error) {
	return IssuesLock(ctx, req, append(c, opt...)...)
}

/*
IssuesLockReq is request data for Client.IssuesLock

https://developer.github.com/v3/issues/#lock-an-issue
*/
type IssuesLockReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody IssuesLockReqBody

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request
func (r *IssuesLockReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesLockReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"sailor-v"},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "PUT",
		OperationID:      "issues/lock",
		Previews:         map[string]bool{"sailor-v": r.SailorVPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/lock", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesLockReq) Rel(link string, resp *IssuesLockResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesLockReqBody is a request body for issues/lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
type IssuesLockReqBody struct {

	/*
	The reason for locking the issue or pull request conversation. Lock will fail if
	you don't use one of these reasons:
	\* `off-topic`
	\* `too heated`
	\* `resolved`
	\* `spam`
	*/
	LockReason *string `json:"lock_reason,omitempty"`
}

/*
IssuesLockResponse is a response for IssuesLock

https://developer.github.com/v3/issues/#lock-an-issue
*/
type IssuesLockResponse struct {
	common.Response
	request *IssuesLockReq
}

/*
IssuesRemoveAllLabels performs requests for "issues/remove-all-labels"

Remove all labels from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
func IssuesRemoveAllLabels(ctx context.Context, req *IssuesRemoveAllLabelsReq, opt ...options.Option) (*IssuesRemoveAllLabelsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesRemoveAllLabelsReq)
	}
	resp := &IssuesRemoveAllLabelsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesRemoveAllLabels performs requests for "issues/remove-all-labels"

Remove all labels from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
func (c Client) IssuesRemoveAllLabels(ctx context.Context, req *IssuesRemoveAllLabelsReq, opt ...options.Option) (*IssuesRemoveAllLabelsResponse, error) {
	return IssuesRemoveAllLabels(ctx, req, append(c, opt...)...)
}

/*
IssuesRemoveAllLabelsReq is request data for Client.IssuesRemoveAllLabels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
type IssuesRemoveAllLabelsReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
}

// HTTPRequest builds an *http.Request
func (r *IssuesRemoveAllLabelsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesRemoveAllLabelsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "issues/remove-all-labels",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesRemoveAllLabelsReq) Rel(link string, resp *IssuesRemoveAllLabelsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesRemoveAllLabelsResponse is a response for IssuesRemoveAllLabels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
type IssuesRemoveAllLabelsResponse struct {
	common.Response
	request *IssuesRemoveAllLabelsReq
}

/*
IssuesRemoveAssignees performs requests for "issues/remove-assignees"

Remove assignees from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
func IssuesRemoveAssignees(ctx context.Context, req *IssuesRemoveAssigneesReq, opt ...options.Option) (*IssuesRemoveAssigneesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesRemoveAssigneesReq)
	}
	resp := &IssuesRemoveAssigneesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.IssueSimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesRemoveAssignees performs requests for "issues/remove-assignees"

Remove assignees from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
func (c Client) IssuesRemoveAssignees(ctx context.Context, req *IssuesRemoveAssigneesReq, opt ...options.Option) (*IssuesRemoveAssigneesResponse, error) {
	return IssuesRemoveAssignees(ctx, req, append(c, opt...)...)
}

/*
IssuesRemoveAssigneesReq is request data for Client.IssuesRemoveAssignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody IssuesRemoveAssigneesReqBody
}

// HTTPRequest builds an *http.Request
func (r *IssuesRemoveAssigneesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesRemoveAssigneesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "DELETE",
		OperationID:      "issues/remove-assignees",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/assignees", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesRemoveAssigneesReq) Rel(link string, resp *IssuesRemoveAssigneesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesRemoveAssigneesReqBody is a request body for issues/remove-assignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesReqBody struct {

	/*
	Usernames of assignees to remove from an issue. _NOTE: Only users with push
	access can remove assignees from an issue. Assignees are silently ignored
	otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`
}

/*
IssuesRemoveAssigneesResponse is a response for IssuesRemoveAssignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesResponse struct {
	common.Response
	request *IssuesRemoveAssigneesReq
	Data    components.IssueSimple
}

/*
IssuesRemoveLabel performs requests for "issues/remove-label"

Remove a label from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
func IssuesRemoveLabel(ctx context.Context, req *IssuesRemoveLabelReq, opt ...options.Option) (*IssuesRemoveLabelResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesRemoveLabelReq)
	}
	resp := &IssuesRemoveLabelResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Label{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesRemoveLabel performs requests for "issues/remove-label"

Remove a label from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
func (c Client) IssuesRemoveLabel(ctx context.Context, req *IssuesRemoveLabelReq, opt ...options.Option) (*IssuesRemoveLabelResponse, error) {
	return IssuesRemoveLabel(ctx, req, append(c, opt...)...)
}

/*
IssuesRemoveLabelReq is request data for Client.IssuesRemoveLabel

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
type IssuesRemoveLabelReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64

	// name parameter
	Name string
}

// HTTPRequest builds an *http.Request
func (r *IssuesRemoveLabelReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesRemoveLabelReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "DELETE",
		OperationID:      "issues/remove-label",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/labels/%v", r.Owner, r.Repo, r.IssueNumber, r.Name),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesRemoveLabelReq) Rel(link string, resp *IssuesRemoveLabelResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesRemoveLabelResponse is a response for IssuesRemoveLabel

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
type IssuesRemoveLabelResponse struct {
	common.Response
	request *IssuesRemoveLabelReq
	Data    []components.Label
}

/*
IssuesSetLabels performs requests for "issues/set-labels"

Set labels for an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
func IssuesSetLabels(ctx context.Context, req *IssuesSetLabelsReq, opt ...options.Option) (*IssuesSetLabelsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesSetLabelsReq)
	}
	resp := &IssuesSetLabelsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Label{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesSetLabels performs requests for "issues/set-labels"

Set labels for an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
func (c Client) IssuesSetLabels(ctx context.Context, req *IssuesSetLabelsReq, opt ...options.Option) (*IssuesSetLabelsResponse, error) {
	return IssuesSetLabels(ctx, req, append(c, opt...)...)
}

/*
IssuesSetLabelsReq is request data for Client.IssuesSetLabels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
type IssuesSetLabelsReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody IssuesSetLabelsReqBody
}

// HTTPRequest builds an *http.Request
func (r *IssuesSetLabelsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesSetLabelsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "issues/set-labels",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesSetLabelsReq) Rel(link string, resp *IssuesSetLabelsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesSetLabelsReqBody is a request body for issues/set-labels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
type IssuesSetLabelsReqBody struct {

	/*
	The names of the labels to add to the issue. You can pass an empty array to
	remove all labels. **Note:** Alternatively, you can pass a single label as a
	`string` or an `array` of labels directly, but GitHub recommends passing an
	object with the `labels` key.
	*/
	Labels []string `json:"labels,omitempty"`
}

/*
IssuesSetLabelsResponse is a response for IssuesSetLabels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
type IssuesSetLabelsResponse struct {
	common.Response
	request *IssuesSetLabelsReq
	Data    []components.Label
}

/*
IssuesUnlock performs requests for "issues/unlock"

Unlock an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
func IssuesUnlock(ctx context.Context, req *IssuesUnlockReq, opt ...options.Option) (*IssuesUnlockResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesUnlockReq)
	}
	resp := &IssuesUnlockResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUnlock performs requests for "issues/unlock"

Unlock an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
func (c Client) IssuesUnlock(ctx context.Context, req *IssuesUnlockReq, opt ...options.Option) (*IssuesUnlockResponse, error) {
	return IssuesUnlock(ctx, req, append(c, opt...)...)
}

/*
IssuesUnlockReq is request data for Client.IssuesUnlock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
type IssuesUnlockReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
}

// HTTPRequest builds an *http.Request
func (r *IssuesUnlockReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesUnlockReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "issues/unlock",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v/lock", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUnlockReq) Rel(link string, resp *IssuesUnlockResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesUnlockResponse is a response for IssuesUnlock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
type IssuesUnlockResponse struct {
	common.Response
	request *IssuesUnlockReq
}

/*
IssuesUpdate performs requests for "issues/update"

Update an issue.

  PATCH /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#update-an-issue
*/
func IssuesUpdate(ctx context.Context, req *IssuesUpdateReq, opt ...options.Option) (*IssuesUpdateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesUpdateReq)
	}
	resp := &IssuesUpdateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Issue{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUpdate performs requests for "issues/update"

Update an issue.

  PATCH /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#update-an-issue
*/
func (c Client) IssuesUpdate(ctx context.Context, req *IssuesUpdateReq, opt ...options.Option) (*IssuesUpdateResponse, error) {
	return IssuesUpdate(ctx, req, append(c, opt...)...)
}

/*
IssuesUpdateReq is request data for Client.IssuesUpdate

https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateReq struct {
	_url  string
	Owner string
	Repo  string

	// issue_number parameter
	IssueNumber int64
	RequestBody IssuesUpdateReqBody
}

// HTTPRequest builds an *http.Request
func (r *IssuesUpdateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesUpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "issues/update",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/%v", r.Owner, r.Repo, r.IssueNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200, 301},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUpdateReq) Rel(link string, resp *IssuesUpdateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesUpdateReqBody is a request body for issues/update

https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateReqBody struct {

	// Login for the user that this issue should be assigned to. **This field is deprecated.**
	Assignee *string `json:"assignee,omitempty"`

	/*
	Logins for Users to assign to this issue. Pass one or more user logins to
	_replace_ the set of assignees on this Issue. Send an empty array (`[]`) to
	clear all assignees from the Issue. _NOTE: Only users with push access can set
	assignees for new issues. Assignees are silently dropped otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`

	// The contents of the issue.
	Body *string `json:"body,omitempty"`

	/*
	Labels to associate with this issue. Pass one or more Labels to _replace_ the
	set of Labels on this Issue. Send an empty array (`[]`) to clear all Labels from
	the Issue. _NOTE: Only users with push access can set labels for issues. Labels
	are silently dropped otherwise._
	*/
	Labels []string `json:"labels,omitempty"`

	/*
	The `number` of the milestone to associate this issue with or `null` to remove
	current. _NOTE: Only users with push access can set the milestone for issues.
	The milestone is silently dropped otherwise._
	*/
	Milestone *int64 `json:"milestone,omitempty"`

	// State of the issue. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the issue.
	Title *string `json:"title,omitempty"`
}

/*
IssuesUpdateResponse is a response for IssuesUpdate

https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateResponse struct {
	common.Response
	request *IssuesUpdateReq
	Data    components.Issue
}

/*
IssuesUpdateComment performs requests for "issues/update-comment"

Update an issue comment.

  PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
func IssuesUpdateComment(ctx context.Context, req *IssuesUpdateCommentReq, opt ...options.Option) (*IssuesUpdateCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesUpdateCommentReq)
	}
	resp := &IssuesUpdateCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.IssueComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUpdateComment performs requests for "issues/update-comment"

Update an issue comment.

  PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
func (c Client) IssuesUpdateComment(ctx context.Context, req *IssuesUpdateCommentReq, opt ...options.Option) (*IssuesUpdateCommentResponse, error) {
	return IssuesUpdateComment(ctx, req, append(c, opt...)...)
}

/*
IssuesUpdateCommentReq is request data for Client.IssuesUpdateComment

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
type IssuesUpdateCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody IssuesUpdateCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *IssuesUpdateCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesUpdateCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "issues/update-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUpdateCommentReq) Rel(link string, resp *IssuesUpdateCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesUpdateCommentReqBody is a request body for issues/update-comment

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
type IssuesUpdateCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`
}

/*
IssuesUpdateCommentResponse is a response for IssuesUpdateComment

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
type IssuesUpdateCommentResponse struct {
	common.Response
	request *IssuesUpdateCommentReq
	Data    components.IssueComment
}

/*
IssuesUpdateLabel performs requests for "issues/update-label"

Update a label.

  PATCH /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#update-a-label
*/
func IssuesUpdateLabel(ctx context.Context, req *IssuesUpdateLabelReq, opt ...options.Option) (*IssuesUpdateLabelResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesUpdateLabelReq)
	}
	resp := &IssuesUpdateLabelResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Label{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUpdateLabel performs requests for "issues/update-label"

Update a label.

  PATCH /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#update-a-label
*/
func (c Client) IssuesUpdateLabel(ctx context.Context, req *IssuesUpdateLabelReq, opt ...options.Option) (*IssuesUpdateLabelResponse, error) {
	return IssuesUpdateLabel(ctx, req, append(c, opt...)...)
}

/*
IssuesUpdateLabelReq is request data for Client.IssuesUpdateLabel

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelReq struct {
	_url  string
	Owner string
	Repo  string

	// name parameter
	Name        string
	RequestBody IssuesUpdateLabelReqBody
}

// HTTPRequest builds an *http.Request
func (r *IssuesUpdateLabelReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesUpdateLabelReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "issues/update-label",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUpdateLabelReq) Rel(link string, resp *IssuesUpdateLabelResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesUpdateLabelReqBody is a request body for issues/update-label

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelReqBody struct {

	// The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.
	Color *string `json:"color,omitempty"`

	// A short description of the label.
	Description *string `json:"description,omitempty"`

	/*
	The new name of the label. Emoji can be added to label names, using either
	native emoji or colon-style markup. For example, typing `:strawberry:` will
	render the emoji
	![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png
	":strawberry:"). For a full list of available emoji and codes, see
	[emoji-cheat-sheet.com](http://emoji-cheat-sheet.com/).
	*/
	NewName *string `json:"new_name,omitempty"`
}

/*
IssuesUpdateLabelResponse is a response for IssuesUpdateLabel

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelResponse struct {
	common.Response
	request *IssuesUpdateLabelReq
	Data    components.Label
}

/*
IssuesUpdateMilestone performs requests for "issues/update-milestone"

Update a milestone.

  PATCH /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
func IssuesUpdateMilestone(ctx context.Context, req *IssuesUpdateMilestoneReq, opt ...options.Option) (*IssuesUpdateMilestoneResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(IssuesUpdateMilestoneReq)
	}
	resp := &IssuesUpdateMilestoneResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Milestone{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUpdateMilestone performs requests for "issues/update-milestone"

Update a milestone.

  PATCH /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
func (c Client) IssuesUpdateMilestone(ctx context.Context, req *IssuesUpdateMilestoneReq, opt ...options.Option) (*IssuesUpdateMilestoneResponse, error) {
	return IssuesUpdateMilestone(ctx, req, append(c, opt...)...)
}

/*
IssuesUpdateMilestoneReq is request data for Client.IssuesUpdateMilestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneReq struct {
	_url  string
	Owner string
	Repo  string

	// milestone_number parameter
	MilestoneNumber int64
	RequestBody     IssuesUpdateMilestoneReqBody
}

// HTTPRequest builds an *http.Request
func (r *IssuesUpdateMilestoneReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *IssuesUpdateMilestoneReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "issues/update-milestone",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUpdateMilestoneReq) Rel(link string, resp *IssuesUpdateMilestoneResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesUpdateMilestoneReqBody is a request body for issues/update-milestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneReqBody struct {

	// A description of the milestone.
	Description *string `json:"description,omitempty"`

	/*
	The milestone due date. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	DueOn *string `json:"due_on,omitempty"`

	// The state of the milestone. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the milestone.
	Title *string `json:"title,omitempty"`
}

/*
IssuesUpdateMilestoneResponse is a response for IssuesUpdateMilestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneResponse struct {
	common.Response
	request *IssuesUpdateMilestoneReq
	Data    components.Milestone
}
