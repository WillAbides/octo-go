// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
IssuesAddAssigneesReq builds requests for "issues/add-assignees"

Add assignees to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesReq struct {
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesAddAssigneesReqBody
}

func (r *IssuesAddAssigneesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/assignees", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesAddAssigneesReq) method() string {
	return "POST"
}

func (r *IssuesAddAssigneesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesAddAssigneesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesAddAssigneesReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *IssuesAddAssigneesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesAddAssigneesReqBody is a request body for issues/add-assignees

API documentation: https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesReqBody struct {

	/*
	   Usernames of people to assign this issue to. _NOTE: Only users with push access
	   can add assignees to an issue. Assignees are silently ignored otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`
}

/*
IssuesAddAssigneesResponseBody201 is a response body for issues/add-assignees

API documentation: https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesResponseBody201 struct {
	components.IssueSimple
}

/*
IssuesAddLabelsReq builds requests for "issues/add-labels"

Add labels to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsReq struct {
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesAddLabelsReqBody
}

func (r *IssuesAddLabelsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesAddLabelsReq) method() string {
	return "POST"
}

func (r *IssuesAddLabelsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesAddLabelsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesAddLabelsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *IssuesAddLabelsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesAddLabelsReqBody is a request body for issues/add-labels

API documentation: https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsReqBody struct {

	/*
	   The name of the label to add to the issue. Must contain at least one label.
	   **Note:** Alternatively, you can pass a single label as a `string` or an `array`
	   of labels directly, but GitHub recommends passing an object with the `labels`
	   key.
	*/
	Labels []string `json:"labels"`
}

/*
IssuesAddLabelsResponseBody200 is a response body for issues/add-labels

API documentation: https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsResponseBody200 []struct {
	components.Label
}

/*
IssuesCheckAssigneeReq builds requests for "issues/check-assignee"

Check assignee.

  GET /repos/{owner}/{repo}/assignees/{assignee}

https://developer.github.com/v3/issues/assignees/#check-assignee
*/
type IssuesCheckAssigneeReq struct {
	Owner    string
	Repo     string
	Assignee string
}

func (r *IssuesCheckAssigneeReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/assignees/%v", r.Owner, r.Repo, r.Assignee)
}

func (r *IssuesCheckAssigneeReq) method() string {
	return "GET"
}

func (r *IssuesCheckAssigneeReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCheckAssigneeReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCheckAssigneeReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesCheckAssigneeReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesCreateReq builds requests for "issues/create"

Create an issue.

  POST /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateReq struct {
	Owner       string
	Repo        string
	RequestBody IssuesCreateReqBody
}

func (r *IssuesCreateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues", r.Owner, r.Repo)
}

func (r *IssuesCreateReq) method() string {
	return "POST"
}

func (r *IssuesCreateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCreateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCreateReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *IssuesCreateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesCreateReqBody is a request body for issues/create

API documentation: https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateReqBody struct {

	/*
	   Login for the user that this issue should be assigned to. _NOTE: Only users with
	   push access can set the assignee for new issues. The assignee is silently
	   dropped otherwise. **This field is deprecated.**_
	*/
	Assignee *string `json:"assignee,omitempty"`

	/*
	   Logins for Users to assign to this issue. _NOTE: Only users with push access can
	   set assignees for new issues. Assignees are silently dropped otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`

	// The contents of the issue.
	Body *string `json:"body,omitempty"`

	/*
	   Labels to associate with this issue. _NOTE: Only users with push access can set
	   labels for new issues. Labels are silently dropped otherwise._
	*/
	Labels []string `json:"labels,omitempty"`

	/*
	   The `number` of the milestone to associate this issue with. _NOTE: Only users
	   with push access can set the milestone for new issues. The milestone is silently
	   dropped otherwise._
	*/
	Milestone *int64 `json:"milestone,omitempty"`

	// The title of the issue.
	Title *string `json:"title"`
}

/*
IssuesCreateResponseBody201 is a response body for issues/create

API documentation: https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateResponseBody201 struct {
	components.Issue
}

/*
IssuesCreateCommentReq builds requests for "issues/create-comment"

Create a comment.

  POST /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#create-a-comment
*/
type IssuesCreateCommentReq struct {
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesCreateCommentReqBody
}

func (r *IssuesCreateCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/comments", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesCreateCommentReq) method() string {
	return "POST"
}

func (r *IssuesCreateCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCreateCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCreateCommentReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *IssuesCreateCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesCreateCommentReqBody is a request body for issues/create-comment

API documentation: https://developer.github.com/v3/issues/comments/#create-a-comment
*/
type IssuesCreateCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`
}

/*
IssuesCreateCommentResponseBody201 is a response body for issues/create-comment

API documentation: https://developer.github.com/v3/issues/comments/#create-a-comment
*/
type IssuesCreateCommentResponseBody201 struct {
	components.IssueComment
}

/*
IssuesCreateLabelReq builds requests for "issues/create-label"

Create a label.

  POST /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelReq struct {
	Owner       string
	Repo        string
	RequestBody IssuesCreateLabelReqBody
}

func (r *IssuesCreateLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels", r.Owner, r.Repo)
}

func (r *IssuesCreateLabelReq) method() string {
	return "POST"
}

func (r *IssuesCreateLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCreateLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCreateLabelReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *IssuesCreateLabelReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesCreateLabelReqBody is a request body for issues/create-label

API documentation: https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelReqBody struct {

	/*
	   The [hexadecimal color code](http://www.color-hex.com/) for the label, without
	   the leading `#`.
	*/
	Color *string `json:"color"`

	// A short description of the label.
	Description *string `json:"description,omitempty"`

	/*
	   The name of the label. Emoji can be added to label names, using either native
	   emoji or colon-style markup. For example, typing `:strawberry:` will render the
	   emoji
	   ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png
	   ":strawberry:"). For a full list of available emoji and codes, see
	   [emoji-cheat-sheet.com](http://emoji-cheat-sheet.com/).
	*/
	Name *string `json:"name"`
}

/*
IssuesCreateLabelResponseBody201 is a response body for issues/create-label

API documentation: https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelResponseBody201 struct {
	components.Label
}

/*
IssuesCreateMilestoneReq builds requests for "issues/create-milestone"

Create a milestone.

  POST /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneReq struct {
	Owner       string
	Repo        string
	RequestBody IssuesCreateMilestoneReqBody
}

func (r *IssuesCreateMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones", r.Owner, r.Repo)
}

func (r *IssuesCreateMilestoneReq) method() string {
	return "POST"
}

func (r *IssuesCreateMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCreateMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCreateMilestoneReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *IssuesCreateMilestoneReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesCreateMilestoneReqBody is a request body for issues/create-milestone

API documentation: https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneReqBody struct {

	// A description of the milestone.
	Description *string `json:"description,omitempty"`

	/*
	   The milestone due date. This is a timestamp in [ISO
	   8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	DueOn *string `json:"due_on,omitempty"`

	// The state of the milestone. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the milestone.
	Title *string `json:"title"`
}

/*
IssuesCreateMilestoneResponseBody201 is a response body for issues/create-milestone

API documentation: https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneResponseBody201 struct {
	components.Milestone
}

/*
IssuesDeleteCommentReq builds requests for "issues/delete-comment"

Delete a comment.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#delete-a-comment
*/
type IssuesDeleteCommentReq struct {
	Owner     string
	Repo      string
	CommentId int64
}

func (r *IssuesDeleteCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *IssuesDeleteCommentReq) method() string {
	return "DELETE"
}

func (r *IssuesDeleteCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesDeleteCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesDeleteCommentReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesDeleteCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesDeleteLabelReq builds requests for "issues/delete-label"

Delete a label.

  DELETE /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
type IssuesDeleteLabelReq struct {
	Owner string
	Repo  string
	Name  string
}

func (r *IssuesDeleteLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name)
}

func (r *IssuesDeleteLabelReq) method() string {
	return "DELETE"
}

func (r *IssuesDeleteLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesDeleteLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesDeleteLabelReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesDeleteLabelReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesDeleteMilestoneReq builds requests for "issues/delete-milestone"

Delete a milestone.

  DELETE /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
type IssuesDeleteMilestoneReq struct {
	Owner           string
	Repo            string
	MilestoneNumber int64
}

func (r *IssuesDeleteMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber)
}

func (r *IssuesDeleteMilestoneReq) method() string {
	return "DELETE"
}

func (r *IssuesDeleteMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesDeleteMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesDeleteMilestoneReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesDeleteMilestoneReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesGetReq builds requests for "issues/get"

Get an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#get-an-issue
*/
type IssuesGetReq struct {
	Owner       string
	Repo        string
	IssueNumber int64

	/*
	An additional `reactions` object in the issue payload is currently available for
	developers to preview. During the preview period, the APIs may change without
	advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesGetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesGetReq) method() string {
	return "GET"
}

func (r *IssuesGetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesGetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesGetResponseBody200 is a response body for issues/get

API documentation: https://developer.github.com/v3/issues/#get-an-issue
*/
type IssuesGetResponseBody200 struct {
	components.Issue
}

/*
IssuesGetCommentReq builds requests for "issues/get-comment"

Get a single comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#get-a-single-comment
*/
type IssuesGetCommentReq struct {
	Owner     string
	Repo      string
	CommentId int64

	/*
	If an issue comment is created via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesGetCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *IssuesGetCommentReq) method() string {
	return "GET"
}

func (r *IssuesGetCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetCommentReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesGetCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesGetCommentResponseBody200 is a response body for issues/get-comment

API documentation: https://developer.github.com/v3/issues/comments/#get-a-single-comment
*/
type IssuesGetCommentResponseBody200 struct {
	components.IssueComment
}

/*
IssuesGetEventReq builds requests for "issues/get-event"

Get a single event.

  GET /repos/{owner}/{repo}/issues/events/{event_id}

https://developer.github.com/v3/issues/events/#get-a-single-event
*/
type IssuesGetEventReq struct {
	Owner   string
	Repo    string
	EventId int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	If an issue event is created via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *IssuesGetEventReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/events/%v", r.Owner, r.Repo, r.EventId)
}

func (r *IssuesGetEventReq) method() string {
	return "GET"
}

func (r *IssuesGetEventReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetEventReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man": r.MachineManPreview,
		"sailor-v":    r.SailorVPreview,
		"starfox":     r.StarfoxPreview,
	}
	if allPreviews {
		previewVals["starfox"] = true
		previewVals["machine-man"] = true
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetEventReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesGetEventReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesGetEventResponseBody200 is a response body for issues/get-event

API documentation: https://developer.github.com/v3/issues/events/#get-a-single-event
*/
type IssuesGetEventResponseBody200 struct {
	components.IssueEvent
}

/*
IssuesGetLabelReq builds requests for "issues/get-label"

Get a single label.

  GET /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#get-a-single-label
*/
type IssuesGetLabelReq struct {
	Owner string
	Repo  string
	Name  string
}

func (r *IssuesGetLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name)
}

func (r *IssuesGetLabelReq) method() string {
	return "GET"
}

func (r *IssuesGetLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetLabelReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesGetLabelReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesGetLabelResponseBody200 is a response body for issues/get-label

API documentation: https://developer.github.com/v3/issues/labels/#get-a-single-label
*/
type IssuesGetLabelResponseBody200 struct {
	components.Label
}

/*
IssuesGetMilestoneReq builds requests for "issues/get-milestone"

Get a single milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#get-a-single-milestone
*/
type IssuesGetMilestoneReq struct {
	Owner           string
	Repo            string
	MilestoneNumber int64
}

func (r *IssuesGetMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber)
}

func (r *IssuesGetMilestoneReq) method() string {
	return "GET"
}

func (r *IssuesGetMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetMilestoneReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesGetMilestoneReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesGetMilestoneResponseBody200 is a response body for issues/get-milestone

API documentation: https://developer.github.com/v3/issues/milestones/#get-a-single-milestone
*/
type IssuesGetMilestoneResponseBody200 struct {
	components.Milestone
}

/*
IssuesListReq builds requests for "issues/list"

List issues assigned to the authenticated user.

  GET /issues

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
type IssuesListReq struct {

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// The direction of the sort. Can be either `asc` or `desc`.
	Direction *string

	/*
	Only issues updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	If an issue is opened via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue payload is currently available for
	developers to preview. During the preview period, the APIs may change without
	advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListReq) urlPath() string {
	return fmt.Sprintf("/issues")
}

func (r *IssuesListReq) method() string {
	return "GET"
}

func (r *IssuesListReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListResponseBody200 is a response body for issues/list

API documentation: https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
type IssuesListResponseBody200 []struct {
	components.IssueWithRepo
}

/*
IssuesListAssigneesReq builds requests for "issues/list-assignees"

List assignees.

  GET /repos/{owner}/{repo}/assignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
type IssuesListAssigneesReq struct {
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListAssigneesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/assignees", r.Owner, r.Repo)
}

func (r *IssuesListAssigneesReq) method() string {
	return "GET"
}

func (r *IssuesListAssigneesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListAssigneesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListAssigneesReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListAssigneesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListAssigneesResponseBody200 is a response body for issues/list-assignees

API documentation: https://developer.github.com/v3/issues/assignees/#list-assignees
*/
type IssuesListAssigneesResponseBody200 []struct {
	components.SimpleUser
}

/*
IssuesListCommentsReq builds requests for "issues/list-comments"

List comments on an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#list-comments-on-an-issue
*/
type IssuesListCommentsReq struct {
	Owner       string
	Repo        string
	IssueNumber int64

	/*
	Only comments updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListCommentsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/comments", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesListCommentsReq) method() string {
	return "GET"
}

func (r *IssuesListCommentsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListCommentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListCommentsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListCommentsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListCommentsResponseBody200 is a response body for issues/list-comments

API documentation: https://developer.github.com/v3/issues/comments/#list-comments-on-an-issue
*/
type IssuesListCommentsResponseBody200 []struct {
	components.IssueComment
}

/*
IssuesListCommentsForRepoReq builds requests for "issues/list-comments-for-repo"

List comments in a repository.

  GET /repos/{owner}/{repo}/issues/comments

https://developer.github.com/v3/issues/comments/#list-comments-in-a-repository
*/
type IssuesListCommentsForRepoReq struct {
	Owner string
	Repo  string

	// Either `created` or `updated`.
	Sort *string

	// Either `asc` or `desc`. Ignored without the `sort` parameter.
	Direction *string

	/*
	Only comments updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListCommentsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments", r.Owner, r.Repo)
}

func (r *IssuesListCommentsForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListCommentsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListCommentsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListCommentsForRepoReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListCommentsForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListCommentsForRepoResponseBody200 is a response body for issues/list-comments-for-repo

API documentation: https://developer.github.com/v3/issues/comments/#list-comments-in-a-repository
*/
type IssuesListCommentsForRepoResponseBody200 []struct {
	components.IssueComment
}

/*
IssuesListEventsReq builds requests for "issues/list-events"

List events for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/events

https://developer.github.com/v3/issues/events/#list-events-for-an-issue
*/
type IssuesListEventsReq struct {
	Owner       string
	Repo        string
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *IssuesListEventsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/events", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesListEventsReq) method() string {
	return "GET"
}

func (r *IssuesListEventsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListEventsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"sailor-v": r.SailorVPreview,
		"starfox":  r.StarfoxPreview,
	}
	if allPreviews {
		previewVals["starfox"] = true
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListEventsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListEventsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListEventsResponseBody200 is a response body for issues/list-events

API documentation: https://developer.github.com/v3/issues/events/#list-events-for-an-issue
*/
type IssuesListEventsResponseBody200 []struct {
	components.IssueEventForIssue
}

/*
IssuesListEventsForRepoReq builds requests for "issues/list-events-for-repo"

List events for a repository.

  GET /repos/{owner}/{repo}/issues/events

https://developer.github.com/v3/issues/events/#list-events-for-a-repository
*/
type IssuesListEventsForRepoReq struct {
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *IssuesListEventsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/events", r.Owner, r.Repo)
}

func (r *IssuesListEventsForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListEventsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListEventsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"sailor-v": r.SailorVPreview,
		"starfox":  r.StarfoxPreview,
	}
	if allPreviews {
		previewVals["starfox"] = true
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListEventsForRepoReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListEventsForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListEventsForRepoResponseBody200 is a response body for issues/list-events-for-repo

API documentation: https://developer.github.com/v3/issues/events/#list-events-for-a-repository
*/
type IssuesListEventsForRepoResponseBody200 []struct {
	components.IssueEvent
}

/*
IssuesListEventsForTimelineReq builds requests for "issues/list-events-for-timeline"

List events for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/timeline

https://developer.github.com/v3/issues/timeline/#list-events-for-an-issue
*/
type IssuesListEventsForTimelineReq struct {
	Owner       string
	Repo        string
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The API to get issue timeline events is currently available for developers to
	preview. During the preview period, the APIs may change without advance notice.
	Please see the [blog
	post](https://developer.github.com/changes/2016-05-23-timeline-preview-api/) for
	full details. To access the API you must set this to true.
	*/
	MockingbirdPreview bool

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool
}

func (r *IssuesListEventsForTimelineReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/timeline", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesListEventsForTimelineReq) method() string {
	return "GET"
}

func (r *IssuesListEventsForTimelineReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListEventsForTimelineReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"mockingbird": r.MockingbirdPreview,
		"starfox":     r.StarfoxPreview,
	}
	if requiredPreviews {
		previewVals["mockingbird"] = true
	}
	if allPreviews {
		previewVals["mockingbird"] = true
		previewVals["starfox"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListEventsForTimelineReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListEventsForTimelineReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListEventsForTimelineResponseBody200 is a response body for issues/list-events-for-timeline

API documentation: https://developer.github.com/v3/issues/timeline/#list-events-for-an-issue
*/
type IssuesListEventsForTimelineResponseBody200 []struct {
	components.IssueEventForIssue
}

/*
IssuesListForAuthenticatedUserReq builds requests for "issues/list-for-authenticated-user"

List user account issues assigned to the authenticated user.

  GET /user/issues

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
type IssuesListForAuthenticatedUserReq struct {

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// The direction of the sort. Can be either `asc` or `desc`.
	Direction *string

	/*
	Only issues updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	If an issue is opened via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue payload is currently available for
	developers to preview. During the preview period, the APIs may change without
	advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/issues")
}

func (r *IssuesListForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *IssuesListForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListForAuthenticatedUserReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListForAuthenticatedUserResponseBody200 is a response body for issues/list-for-authenticated-user

API documentation: https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
type IssuesListForAuthenticatedUserResponseBody200 []struct {
	components.IssueWithRepo
}

/*
IssuesListForOrgReq builds requests for "issues/list-for-org"

List organization issues assigned to the authenticated user.

  GET /orgs/{org}/issues

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
type IssuesListForOrgReq struct {
	Org string

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// The direction of the sort. Can be either `asc` or `desc`.
	Direction *string

	/*
	Only issues updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	If an issue is opened via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue payload is currently available for
	developers to preview. During the preview period, the APIs may change without
	advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/issues", r.Org)
}

func (r *IssuesListForOrgReq) method() string {
	return "GET"
}

func (r *IssuesListForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListForOrgReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListForOrgResponseBody200 is a response body for issues/list-for-org

API documentation: https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
type IssuesListForOrgResponseBody200 []struct {
	components.IssueWithRepo
}

/*
IssuesListForRepoReq builds requests for "issues/list-for-repo"

List repository issues.

  GET /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#list-repository-issues
*/
type IssuesListForRepoReq struct {
	Owner string
	Repo  string

	/*
	If an `integer` is passed, it should refer to a milestone by its `number` field.
	If the string `*` is passed, issues with any milestone are accepted. If the
	string `none` is passed, issues without milestones are returned.
	*/
	Milestone *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	/*
	Can be the name of a user. Pass in `none` for issues with no assigned user, and
	`*` for issues assigned to any user.
	*/
	Assignee *string

	// The user that created the issue.
	Creator *string

	// A user that's mentioned in the issue.
	Mentioned *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// The direction of the sort. Can be either `asc` or `desc`.
	Direction *string

	/*
	Only issues updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	If an issue is opened via a GitHub App, the response will include the
	`performed_via_github_app` object with information about the GitHub App. For
	more information, see the [related blog
	post](https://developer.github.com/changes/2016-09-14-Integrations-Early-Access).

	To receive the `performed_via_github_app` object in the response, you must set
	this to true.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue payload is currently available for
	developers to preview. During the preview period, the APIs may change without
	advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues", r.Owner, r.Repo)
}

func (r *IssuesListForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Milestone != nil {
		query.Set("milestone", *r.Milestone)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Assignee != nil {
		query.Set("assignee", *r.Assignee)
	}
	if r.Creator != nil {
		query.Set("creator", *r.Creator)
	}
	if r.Mentioned != nil {
		query.Set("mentioned", *r.Mentioned)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListForRepoReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListForRepoResponseBody200 is a response body for issues/list-for-repo

API documentation: https://developer.github.com/v3/issues/#list-repository-issues
*/
type IssuesListForRepoResponseBody200 []struct {
	components.IssueSimple2
}

/*
IssuesListLabelsForMilestoneReq builds requests for "issues/list-labels-for-milestone"

Get labels for every issue in a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels

https://developer.github.com/v3/issues/labels/#get-labels-for-every-issue-in-a-milestone
*/
type IssuesListLabelsForMilestoneReq struct {
	Owner           string
	Repo            string
	MilestoneNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListLabelsForMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones/%v/labels", r.Owner, r.Repo, r.MilestoneNumber)
}

func (r *IssuesListLabelsForMilestoneReq) method() string {
	return "GET"
}

func (r *IssuesListLabelsForMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListLabelsForMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListLabelsForMilestoneReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListLabelsForMilestoneReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListLabelsForMilestoneResponseBody200 is a response body for issues/list-labels-for-milestone

API documentation: https://developer.github.com/v3/issues/labels/#get-labels-for-every-issue-in-a-milestone
*/
type IssuesListLabelsForMilestoneResponseBody200 []struct {
	components.Label
}

/*
IssuesListLabelsForRepoReq builds requests for "issues/list-labels-for-repo"

List all labels for this repository.

  GET /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository
*/
type IssuesListLabelsForRepoReq struct {
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListLabelsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels", r.Owner, r.Repo)
}

func (r *IssuesListLabelsForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListLabelsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListLabelsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListLabelsForRepoReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListLabelsForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListLabelsForRepoResponseBody200 is a response body for issues/list-labels-for-repo

API documentation: https://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository
*/
type IssuesListLabelsForRepoResponseBody200 []struct {
	components.Label
}

/*
IssuesListLabelsOnIssueReq builds requests for "issues/list-labels-on-issue"

List labels on an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-on-an-issue
*/
type IssuesListLabelsOnIssueReq struct {
	Owner       string
	Repo        string
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListLabelsOnIssueReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesListLabelsOnIssueReq) method() string {
	return "GET"
}

func (r *IssuesListLabelsOnIssueReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListLabelsOnIssueReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListLabelsOnIssueReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListLabelsOnIssueReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListLabelsOnIssueResponseBody200 is a response body for issues/list-labels-on-issue

API documentation: https://developer.github.com/v3/issues/labels/#list-labels-on-an-issue
*/
type IssuesListLabelsOnIssueResponseBody200 []struct {
	components.Label
}

/*
IssuesListMilestonesForRepoReq builds requests for "issues/list-milestones-for-repo"

List milestones for a repository.

  GET /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#list-milestones-for-a-repository
*/
type IssuesListMilestonesForRepoReq struct {
	Owner string
	Repo  string

	// The state of the milestone. Either `open`, `closed`, or `all`.
	State *string

	// What to sort results by. Either `due_on` or `completeness`.
	Sort *string

	// The direction of the sort. Either `asc` or `desc`.
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListMilestonesForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones", r.Owner, r.Repo)
}

func (r *IssuesListMilestonesForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListMilestonesForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListMilestonesForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListMilestonesForRepoReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesListMilestonesForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesListMilestonesForRepoResponseBody200 is a response body for issues/list-milestones-for-repo

API documentation: https://developer.github.com/v3/issues/milestones/#list-milestones-for-a-repository
*/
type IssuesListMilestonesForRepoResponseBody200 []struct {
	components.Milestone
}

/*
IssuesLockReq builds requests for "issues/lock"

Lock an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
type IssuesLockReq struct {
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesLockReqBody

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *IssuesLockReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/lock", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesLockReq) method() string {
	return "PUT"
}

func (r *IssuesLockReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesLockReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"sailor-v": r.SailorVPreview}
	if allPreviews {
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesLockReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *IssuesLockReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesLockReqBody is a request body for issues/lock

API documentation: https://developer.github.com/v3/issues/#lock-an-issue
*/
type IssuesLockReqBody struct {

	/*
	   The reason for locking the issue or pull request conversation. Lock will fail if
	   you don't use one of these reasons:
	   \* `off-topic`
	   \* `too heated`
	   \* `resolved`
	   \* `spam`
	*/
	LockReason *string `json:"lock_reason,omitempty"`
}

/*
IssuesRemoveAllLabelsReq builds requests for "issues/remove-all-labels"

Remove all labels from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
type IssuesRemoveAllLabelsReq struct {
	Owner       string
	Repo        string
	IssueNumber int64
}

func (r *IssuesRemoveAllLabelsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesRemoveAllLabelsReq) method() string {
	return "DELETE"
}

func (r *IssuesRemoveAllLabelsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesRemoveAllLabelsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesRemoveAllLabelsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesRemoveAllLabelsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesRemoveAssigneesReq builds requests for "issues/remove-assignees"

Remove assignees from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesReq struct {
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesRemoveAssigneesReqBody
}

func (r *IssuesRemoveAssigneesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/assignees", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesRemoveAssigneesReq) method() string {
	return "DELETE"
}

func (r *IssuesRemoveAssigneesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesRemoveAssigneesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesRemoveAssigneesReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *IssuesRemoveAssigneesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesRemoveAssigneesReqBody is a request body for issues/remove-assignees

API documentation: https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesReqBody struct {

	/*
	   Usernames of assignees to remove from an issue. _NOTE: Only users with push
	   access can remove assignees from an issue. Assignees are silently ignored
	   otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`
}

/*
IssuesRemoveAssigneesResponseBody200 is a response body for issues/remove-assignees

API documentation: https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesResponseBody200 struct {
	components.IssueSimple2
}

/*
IssuesRemoveLabelReq builds requests for "issues/remove-label"

Remove a label from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
type IssuesRemoveLabelReq struct {
	Owner       string
	Repo        string
	IssueNumber int64
	Name        string
}

func (r *IssuesRemoveLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels/%v", r.Owner, r.Repo, r.IssueNumber, r.Name)
}

func (r *IssuesRemoveLabelReq) method() string {
	return "DELETE"
}

func (r *IssuesRemoveLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesRemoveLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesRemoveLabelReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesRemoveLabelReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesRemoveLabelResponseBody200 is a response body for issues/remove-label

API documentation: https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
type IssuesRemoveLabelResponseBody200 []struct {
	components.Label
}

/*
IssuesReplaceAllLabelsReq builds requests for "issues/replace-all-labels"

Replace all labels for an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#replace-all-labels-for-an-issue
*/
type IssuesReplaceAllLabelsReq struct {
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesReplaceAllLabelsReqBody
}

func (r *IssuesReplaceAllLabelsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesReplaceAllLabelsReq) method() string {
	return "PUT"
}

func (r *IssuesReplaceAllLabelsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesReplaceAllLabelsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesReplaceAllLabelsReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *IssuesReplaceAllLabelsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesReplaceAllLabelsReqBody is a request body for issues/replace-all-labels

API documentation: https://developer.github.com/v3/issues/labels/#replace-all-labels-for-an-issue
*/
type IssuesReplaceAllLabelsReqBody struct {

	/*
	   The names of the labels to add to the issue. You can pass an empty array to
	   remove all labels. **Note:** Alternatively, you can pass a single label as a
	   `string` or an `array` of labels directly, but GitHub recommends passing an
	   object with the `labels` key.
	*/
	Labels []string `json:"labels,omitempty"`
}

/*
IssuesReplaceAllLabelsResponseBody200 is a response body for issues/replace-all-labels

API documentation: https://developer.github.com/v3/issues/labels/#replace-all-labels-for-an-issue
*/
type IssuesReplaceAllLabelsResponseBody200 []struct {
	components.Label
}

/*
IssuesUnlockReq builds requests for "issues/unlock"

Unlock an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
type IssuesUnlockReq struct {
	Owner       string
	Repo        string
	IssueNumber int64
}

func (r *IssuesUnlockReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/lock", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesUnlockReq) method() string {
	return "DELETE"
}

func (r *IssuesUnlockReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUnlockReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUnlockReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *IssuesUnlockReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesUpdateReq builds requests for "issues/update"

Update an issue.

  PATCH /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateReq struct {
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesUpdateReqBody
}

func (r *IssuesUpdateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesUpdateReq) method() string {
	return "PATCH"
}

func (r *IssuesUpdateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUpdateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUpdateReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *IssuesUpdateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesUpdateReqBody is a request body for issues/update

API documentation: https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateReqBody struct {

	/*
	   Login for the user that this issue should be assigned to. **This field is
	   deprecated.**
	*/
	Assignee *string `json:"assignee,omitempty"`

	/*
	   Logins for Users to assign to this issue. Pass one or more user logins to
	   _replace_ the set of assignees on this Issue. Send an empty array (`[]`) to
	   clear all assignees from the Issue. _NOTE: Only users with push access can set
	   assignees for new issues. Assignees are silently dropped otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`

	// The contents of the issue.
	Body *string `json:"body,omitempty"`

	/*
	   Labels to associate with this issue. Pass one or more Labels to _replace_ the
	   set of Labels on this Issue. Send an empty array (`[]`) to clear all Labels from
	   the Issue. _NOTE: Only users with push access can set labels for issues. Labels
	   are silently dropped otherwise._
	*/
	Labels []string `json:"labels,omitempty"`

	/*
	   The `number` of the milestone to associate this issue with or `null` to remove
	   current. _NOTE: Only users with push access can set the milestone for issues.
	   The milestone is silently dropped otherwise._
	*/
	Milestone *int64 `json:"milestone,omitempty"`

	// State of the issue. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the issue.
	Title *string `json:"title,omitempty"`
}

/*
IssuesUpdateResponseBody200 is a response body for issues/update

API documentation: https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateResponseBody200 struct {
	components.Issue
}

/*
IssuesUpdateCommentReq builds requests for "issues/update-comment"

Edit a comment.

  PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#edit-a-comment
*/
type IssuesUpdateCommentReq struct {
	Owner       string
	Repo        string
	CommentId   int64
	RequestBody IssuesUpdateCommentReqBody
}

func (r *IssuesUpdateCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *IssuesUpdateCommentReq) method() string {
	return "PATCH"
}

func (r *IssuesUpdateCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUpdateCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUpdateCommentReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *IssuesUpdateCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesUpdateCommentReqBody is a request body for issues/update-comment

API documentation: https://developer.github.com/v3/issues/comments/#edit-a-comment
*/
type IssuesUpdateCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`
}

/*
IssuesUpdateCommentResponseBody200 is a response body for issues/update-comment

API documentation: https://developer.github.com/v3/issues/comments/#edit-a-comment
*/
type IssuesUpdateCommentResponseBody200 struct {
	components.IssueComment
}

/*
IssuesUpdateLabelReq builds requests for "issues/update-label"

Update a label.

  PATCH /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelReq struct {
	Owner       string
	Repo        string
	Name        string
	RequestBody IssuesUpdateLabelReqBody
}

func (r *IssuesUpdateLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name)
}

func (r *IssuesUpdateLabelReq) method() string {
	return "PATCH"
}

func (r *IssuesUpdateLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUpdateLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUpdateLabelReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *IssuesUpdateLabelReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesUpdateLabelReqBody is a request body for issues/update-label

API documentation: https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelReqBody struct {

	/*
	   The [hexadecimal color code](http://www.color-hex.com/) for the label, without
	   the leading `#`.
	*/
	Color *string `json:"color,omitempty"`

	// A short description of the label.
	Description *string `json:"description,omitempty"`

	/*
	   The new name of the label. Emoji can be added to label names, using either
	   native emoji or colon-style markup. For example, typing `:strawberry:` will
	   render the emoji
	   ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png
	   ":strawberry:"). For a full list of available emoji and codes, see
	   [emoji-cheat-sheet.com](http://emoji-cheat-sheet.com/).
	*/
	NewName *string `json:"new_name,omitempty"`
}

/*
IssuesUpdateLabelResponseBody200 is a response body for issues/update-label

API documentation: https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelResponseBody200 struct {
	components.Label
}

/*
IssuesUpdateMilestoneReq builds requests for "issues/update-milestone"

Update a milestone.

  PATCH /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneReq struct {
	Owner           string
	Repo            string
	MilestoneNumber int64
	RequestBody     IssuesUpdateMilestoneReqBody
}

func (r *IssuesUpdateMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber)
}

func (r *IssuesUpdateMilestoneReq) method() string {
	return "PATCH"
}

func (r *IssuesUpdateMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUpdateMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUpdateMilestoneReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *IssuesUpdateMilestoneReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
IssuesUpdateMilestoneReqBody is a request body for issues/update-milestone

API documentation: https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneReqBody struct {

	// A description of the milestone.
	Description *string `json:"description,omitempty"`

	/*
	   The milestone due date. This is a timestamp in [ISO
	   8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	DueOn *string `json:"due_on,omitempty"`

	// The state of the milestone. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the milestone.
	Title *string `json:"title,omitempty"`
}

/*
IssuesUpdateMilestoneResponseBody200 is a response body for issues/update-milestone

API documentation: https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneResponseBody200 struct {
	components.Milestone
}
