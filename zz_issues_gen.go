// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
IssuesAddAssignees performs requests for "issues/add-assignees"

Add assignees to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
func IssuesAddAssignees(ctx context.Context, req *IssuesAddAssigneesReq, opt ...RequestOption) (*IssuesAddAssigneesResponse, error) {
	if req == nil {
		req = new(IssuesAddAssigneesReq)
	}
	resp := &IssuesAddAssigneesResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesAddAssigneesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesAddAssignees performs requests for "issues/add-assignees"

Add assignees to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
func (c Client) IssuesAddAssignees(ctx context.Context, req *IssuesAddAssigneesReq, opt ...RequestOption) (*IssuesAddAssigneesResponse, error) {
	return IssuesAddAssignees(ctx, req, append(c, opt...)...)
}

/*
IssuesAddAssigneesReq is request data for Client.IssuesAddAssignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesAddAssigneesReqBody
}

func (r *IssuesAddAssigneesReq) url() string {
	return r._url
}

func (r *IssuesAddAssigneesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/assignees", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesAddAssigneesReq) method() string {
	return "POST"
}

func (r *IssuesAddAssigneesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesAddAssigneesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesAddAssigneesReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesAddAssigneesReq) dataStatuses() []int {
	return []int{201}
}

func (r *IssuesAddAssigneesReq) validStatuses() []int {
	return []int{201}
}

func (r *IssuesAddAssigneesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *IssuesAddAssigneesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesAddAssigneesReq) Rel(link RelName, resp *IssuesAddAssigneesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesAddAssigneesReqBody is a request body for issues/add-assignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesReqBody struct {

	/*
	   Usernames of people to assign this issue to. _NOTE: Only users with push access
	   can add assignees to an issue. Assignees are silently ignored otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`
}

/*
IssuesAddAssigneesResponseBody is a response body for IssuesAddAssignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesResponseBody struct {
	components.IssueSimple
}

/*
IssuesAddAssigneesResponse is a response for IssuesAddAssignees

https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue
*/
type IssuesAddAssigneesResponse struct {
	response
	request *IssuesAddAssigneesReq
	Data    *IssuesAddAssigneesResponseBody
}

/*
IssuesAddLabels performs requests for "issues/add-labels"

Add labels to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
func IssuesAddLabels(ctx context.Context, req *IssuesAddLabelsReq, opt ...RequestOption) (*IssuesAddLabelsResponse, error) {
	if req == nil {
		req = new(IssuesAddLabelsReq)
	}
	resp := &IssuesAddLabelsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesAddLabelsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesAddLabels performs requests for "issues/add-labels"

Add labels to an issue.

  POST /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
func (c Client) IssuesAddLabels(ctx context.Context, req *IssuesAddLabelsReq, opt ...RequestOption) (*IssuesAddLabelsResponse, error) {
	return IssuesAddLabels(ctx, req, append(c, opt...)...)
}

/*
IssuesAddLabelsReq is request data for Client.IssuesAddLabels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesAddLabelsReqBody
}

func (r *IssuesAddLabelsReq) url() string {
	return r._url
}

func (r *IssuesAddLabelsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesAddLabelsReq) method() string {
	return "POST"
}

func (r *IssuesAddLabelsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesAddLabelsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesAddLabelsReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesAddLabelsReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesAddLabelsReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesAddLabelsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *IssuesAddLabelsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesAddLabelsReq) Rel(link RelName, resp *IssuesAddLabelsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesAddLabelsReqBody is a request body for issues/add-labels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsReqBody struct {

	/*
	   The name of the label to add to the issue. Must contain at least one label.
	   **Note:** Alternatively, you can pass a single label as a `string` or an `array`
	   of labels directly, but GitHub recommends passing an object with the `labels`
	   key.
	*/
	Labels []string `json:"labels"`
}

/*
IssuesAddLabelsResponseBody is a response body for IssuesAddLabels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsResponseBody []struct {
	components.Label
}

/*
IssuesAddLabelsResponse is a response for IssuesAddLabels

https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue
*/
type IssuesAddLabelsResponse struct {
	response
	request *IssuesAddLabelsReq
	Data    *IssuesAddLabelsResponseBody
}

/*
IssuesCheckUserCanBeAssigned performs requests for "issues/check-user-can-be-assigned"

Check if a user can be assigned.

  GET /repos/{owner}/{repo}/assignees/{assignee}

https://developer.github.com/v3/issues/assignees/#check-if-a-user-can-be-assigned
*/
func IssuesCheckUserCanBeAssigned(ctx context.Context, req *IssuesCheckUserCanBeAssignedReq, opt ...RequestOption) (*IssuesCheckUserCanBeAssignedResponse, error) {
	if req == nil {
		req = new(IssuesCheckUserCanBeAssignedReq)
	}
	resp := &IssuesCheckUserCanBeAssignedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCheckUserCanBeAssigned performs requests for "issues/check-user-can-be-assigned"

Check if a user can be assigned.

  GET /repos/{owner}/{repo}/assignees/{assignee}

https://developer.github.com/v3/issues/assignees/#check-if-a-user-can-be-assigned
*/
func (c Client) IssuesCheckUserCanBeAssigned(ctx context.Context, req *IssuesCheckUserCanBeAssignedReq, opt ...RequestOption) (*IssuesCheckUserCanBeAssignedResponse, error) {
	return IssuesCheckUserCanBeAssigned(ctx, req, append(c, opt...)...)
}

/*
IssuesCheckUserCanBeAssignedReq is request data for Client.IssuesCheckUserCanBeAssigned

https://developer.github.com/v3/issues/assignees/#check-if-a-user-can-be-assigned
*/
type IssuesCheckUserCanBeAssignedReq struct {
	_url     string
	Owner    string
	Repo     string
	Assignee string
}

func (r *IssuesCheckUserCanBeAssignedReq) url() string {
	return r._url
}

func (r *IssuesCheckUserCanBeAssignedReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/assignees/%v", r.Owner, r.Repo, r.Assignee)
}

func (r *IssuesCheckUserCanBeAssignedReq) method() string {
	return "GET"
}

func (r *IssuesCheckUserCanBeAssignedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCheckUserCanBeAssignedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCheckUserCanBeAssignedReq) body() interface{} {
	return nil
}

func (r *IssuesCheckUserCanBeAssignedReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesCheckUserCanBeAssignedReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesCheckUserCanBeAssignedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// HTTPRequest builds an *http.Request
func (r *IssuesCheckUserCanBeAssignedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCheckUserCanBeAssignedReq) Rel(link RelName, resp *IssuesCheckUserCanBeAssignedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesCheckUserCanBeAssignedResponse is a response for IssuesCheckUserCanBeAssigned

https://developer.github.com/v3/issues/assignees/#check-if-a-user-can-be-assigned
*/
type IssuesCheckUserCanBeAssignedResponse struct {
	response
	request *IssuesCheckUserCanBeAssignedReq
	Data    bool
}

/*
IssuesCreate performs requests for "issues/create"

Create an issue.

  POST /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#create-an-issue
*/
func IssuesCreate(ctx context.Context, req *IssuesCreateReq, opt ...RequestOption) (*IssuesCreateResponse, error) {
	if req == nil {
		req = new(IssuesCreateReq)
	}
	resp := &IssuesCreateResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesCreateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCreate performs requests for "issues/create"

Create an issue.

  POST /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#create-an-issue
*/
func (c Client) IssuesCreate(ctx context.Context, req *IssuesCreateReq, opt ...RequestOption) (*IssuesCreateResponse, error) {
	return IssuesCreate(ctx, req, append(c, opt...)...)
}

/*
IssuesCreateReq is request data for Client.IssuesCreate

https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody IssuesCreateReqBody
}

func (r *IssuesCreateReq) url() string {
	return r._url
}

func (r *IssuesCreateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues", r.Owner, r.Repo)
}

func (r *IssuesCreateReq) method() string {
	return "POST"
}

func (r *IssuesCreateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCreateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCreateReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesCreateReq) dataStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateReq) validStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *IssuesCreateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCreateReq) Rel(link RelName, resp *IssuesCreateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesCreateReqBody is a request body for issues/create

https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateReqBody struct {

	/*
	   Login for the user that this issue should be assigned to. _NOTE: Only users with
	   push access can set the assignee for new issues. The assignee is silently
	   dropped otherwise. **This field is deprecated.**_
	*/
	Assignee *string `json:"assignee,omitempty"`

	/*
	   Logins for Users to assign to this issue. _NOTE: Only users with push access can
	   set assignees for new issues. Assignees are silently dropped otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`

	// The contents of the issue.
	Body *string `json:"body,omitempty"`

	/*
	   Labels to associate with this issue. _NOTE: Only users with push access can set
	   labels for new issues. Labels are silently dropped otherwise._
	*/
	Labels []string `json:"labels,omitempty"`

	/*
	   The `number` of the milestone to associate this issue with. _NOTE: Only users
	   with push access can set the milestone for new issues. The milestone is silently
	   dropped otherwise._
	*/
	Milestone *int64 `json:"milestone,omitempty"`

	// The title of the issue.
	Title *string `json:"title"`
}

/*
IssuesCreateResponseBody is a response body for IssuesCreate

https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateResponseBody struct {
	components.Issue
}

/*
IssuesCreateResponse is a response for IssuesCreate

https://developer.github.com/v3/issues/#create-an-issue
*/
type IssuesCreateResponse struct {
	response
	request *IssuesCreateReq
	Data    *IssuesCreateResponseBody
}

/*
IssuesCreateComment performs requests for "issues/create-comment"

Create an issue comment.

  POST /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
func IssuesCreateComment(ctx context.Context, req *IssuesCreateCommentReq, opt ...RequestOption) (*IssuesCreateCommentResponse, error) {
	if req == nil {
		req = new(IssuesCreateCommentReq)
	}
	resp := &IssuesCreateCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesCreateCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCreateComment performs requests for "issues/create-comment"

Create an issue comment.

  POST /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
func (c Client) IssuesCreateComment(ctx context.Context, req *IssuesCreateCommentReq, opt ...RequestOption) (*IssuesCreateCommentResponse, error) {
	return IssuesCreateComment(ctx, req, append(c, opt...)...)
}

/*
IssuesCreateCommentReq is request data for Client.IssuesCreateComment

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
type IssuesCreateCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesCreateCommentReqBody
}

func (r *IssuesCreateCommentReq) url() string {
	return r._url
}

func (r *IssuesCreateCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/comments", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesCreateCommentReq) method() string {
	return "POST"
}

func (r *IssuesCreateCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCreateCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCreateCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesCreateCommentReq) dataStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateCommentReq) validStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *IssuesCreateCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCreateCommentReq) Rel(link RelName, resp *IssuesCreateCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesCreateCommentReqBody is a request body for issues/create-comment

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
type IssuesCreateCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`
}

/*
IssuesCreateCommentResponseBody is a response body for IssuesCreateComment

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
type IssuesCreateCommentResponseBody struct {
	components.IssueComment
}

/*
IssuesCreateCommentResponse is a response for IssuesCreateComment

https://developer.github.com/v3/issues/comments/#create-an-issue-comment
*/
type IssuesCreateCommentResponse struct {
	response
	request *IssuesCreateCommentReq
	Data    *IssuesCreateCommentResponseBody
}

/*
IssuesCreateLabel performs requests for "issues/create-label"

Create a label.

  POST /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#create-a-label
*/
func IssuesCreateLabel(ctx context.Context, req *IssuesCreateLabelReq, opt ...RequestOption) (*IssuesCreateLabelResponse, error) {
	if req == nil {
		req = new(IssuesCreateLabelReq)
	}
	resp := &IssuesCreateLabelResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesCreateLabelResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCreateLabel performs requests for "issues/create-label"

Create a label.

  POST /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#create-a-label
*/
func (c Client) IssuesCreateLabel(ctx context.Context, req *IssuesCreateLabelReq, opt ...RequestOption) (*IssuesCreateLabelResponse, error) {
	return IssuesCreateLabel(ctx, req, append(c, opt...)...)
}

/*
IssuesCreateLabelReq is request data for Client.IssuesCreateLabel

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody IssuesCreateLabelReqBody
}

func (r *IssuesCreateLabelReq) url() string {
	return r._url
}

func (r *IssuesCreateLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels", r.Owner, r.Repo)
}

func (r *IssuesCreateLabelReq) method() string {
	return "POST"
}

func (r *IssuesCreateLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCreateLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCreateLabelReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesCreateLabelReq) dataStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateLabelReq) validStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateLabelReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *IssuesCreateLabelReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCreateLabelReq) Rel(link RelName, resp *IssuesCreateLabelResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesCreateLabelReqBody is a request body for issues/create-label

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelReqBody struct {

	/*
	   The [hexadecimal color code](http://www.color-hex.com/) for the label, without
	   the leading `#`.
	*/
	Color *string `json:"color"`

	// A short description of the label.
	Description *string `json:"description,omitempty"`

	/*
	   The name of the label. Emoji can be added to label names, using either native
	   emoji or colon-style markup. For example, typing `:strawberry:` will render the
	   emoji
	   ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png
	   ":strawberry:"). For a full list of available emoji and codes, see
	   [emoji-cheat-sheet.com](http://emoji-cheat-sheet.com/).
	*/
	Name *string `json:"name"`
}

/*
IssuesCreateLabelResponseBody is a response body for IssuesCreateLabel

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelResponseBody struct {
	components.Label
}

/*
IssuesCreateLabelResponse is a response for IssuesCreateLabel

https://developer.github.com/v3/issues/labels/#create-a-label
*/
type IssuesCreateLabelResponse struct {
	response
	request *IssuesCreateLabelReq
	Data    *IssuesCreateLabelResponseBody
}

/*
IssuesCreateMilestone performs requests for "issues/create-milestone"

Create a milestone.

  POST /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
func IssuesCreateMilestone(ctx context.Context, req *IssuesCreateMilestoneReq, opt ...RequestOption) (*IssuesCreateMilestoneResponse, error) {
	if req == nil {
		req = new(IssuesCreateMilestoneReq)
	}
	resp := &IssuesCreateMilestoneResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesCreateMilestoneResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesCreateMilestone performs requests for "issues/create-milestone"

Create a milestone.

  POST /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
func (c Client) IssuesCreateMilestone(ctx context.Context, req *IssuesCreateMilestoneReq, opt ...RequestOption) (*IssuesCreateMilestoneResponse, error) {
	return IssuesCreateMilestone(ctx, req, append(c, opt...)...)
}

/*
IssuesCreateMilestoneReq is request data for Client.IssuesCreateMilestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody IssuesCreateMilestoneReqBody
}

func (r *IssuesCreateMilestoneReq) url() string {
	return r._url
}

func (r *IssuesCreateMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones", r.Owner, r.Repo)
}

func (r *IssuesCreateMilestoneReq) method() string {
	return "POST"
}

func (r *IssuesCreateMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesCreateMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesCreateMilestoneReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesCreateMilestoneReq) dataStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateMilestoneReq) validStatuses() []int {
	return []int{201}
}

func (r *IssuesCreateMilestoneReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *IssuesCreateMilestoneReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesCreateMilestoneReq) Rel(link RelName, resp *IssuesCreateMilestoneResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesCreateMilestoneReqBody is a request body for issues/create-milestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneReqBody struct {

	// A description of the milestone.
	Description *string `json:"description,omitempty"`

	/*
	   The milestone due date. This is a timestamp in [ISO
	   8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	DueOn *string `json:"due_on,omitempty"`

	// The state of the milestone. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the milestone.
	Title *string `json:"title"`
}

/*
IssuesCreateMilestoneResponseBody is a response body for IssuesCreateMilestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneResponseBody struct {
	components.Milestone
}

/*
IssuesCreateMilestoneResponse is a response for IssuesCreateMilestone

https://developer.github.com/v3/issues/milestones/#create-a-milestone
*/
type IssuesCreateMilestoneResponse struct {
	response
	request *IssuesCreateMilestoneReq
	Data    *IssuesCreateMilestoneResponseBody
}

/*
IssuesDeleteComment performs requests for "issues/delete-comment"

Delete an issue comment.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#delete-an-issue-comment
*/
func IssuesDeleteComment(ctx context.Context, req *IssuesDeleteCommentReq, opt ...RequestOption) (*IssuesDeleteCommentResponse, error) {
	if req == nil {
		req = new(IssuesDeleteCommentReq)
	}
	resp := &IssuesDeleteCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesDeleteComment performs requests for "issues/delete-comment"

Delete an issue comment.

  DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#delete-an-issue-comment
*/
func (c Client) IssuesDeleteComment(ctx context.Context, req *IssuesDeleteCommentReq, opt ...RequestOption) (*IssuesDeleteCommentResponse, error) {
	return IssuesDeleteComment(ctx, req, append(c, opt...)...)
}

/*
IssuesDeleteCommentReq is request data for Client.IssuesDeleteComment

https://developer.github.com/v3/issues/comments/#delete-an-issue-comment
*/
type IssuesDeleteCommentReq struct {
	_url      string
	Owner     string
	Repo      string
	CommentId int64
}

func (r *IssuesDeleteCommentReq) url() string {
	return r._url
}

func (r *IssuesDeleteCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *IssuesDeleteCommentReq) method() string {
	return "DELETE"
}

func (r *IssuesDeleteCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesDeleteCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesDeleteCommentReq) body() interface{} {
	return nil
}

func (r *IssuesDeleteCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesDeleteCommentReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesDeleteCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesDeleteCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesDeleteCommentReq) Rel(link RelName, resp *IssuesDeleteCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesDeleteCommentResponse is a response for IssuesDeleteComment

https://developer.github.com/v3/issues/comments/#delete-an-issue-comment
*/
type IssuesDeleteCommentResponse struct {
	response
	request *IssuesDeleteCommentReq
}

/*
IssuesDeleteLabel performs requests for "issues/delete-label"

Delete a label.

  DELETE /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
func IssuesDeleteLabel(ctx context.Context, req *IssuesDeleteLabelReq, opt ...RequestOption) (*IssuesDeleteLabelResponse, error) {
	if req == nil {
		req = new(IssuesDeleteLabelReq)
	}
	resp := &IssuesDeleteLabelResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesDeleteLabel performs requests for "issues/delete-label"

Delete a label.

  DELETE /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
func (c Client) IssuesDeleteLabel(ctx context.Context, req *IssuesDeleteLabelReq, opt ...RequestOption) (*IssuesDeleteLabelResponse, error) {
	return IssuesDeleteLabel(ctx, req, append(c, opt...)...)
}

/*
IssuesDeleteLabelReq is request data for Client.IssuesDeleteLabel

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
type IssuesDeleteLabelReq struct {
	_url  string
	Owner string
	Repo  string
	Name  string
}

func (r *IssuesDeleteLabelReq) url() string {
	return r._url
}

func (r *IssuesDeleteLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name)
}

func (r *IssuesDeleteLabelReq) method() string {
	return "DELETE"
}

func (r *IssuesDeleteLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesDeleteLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesDeleteLabelReq) body() interface{} {
	return nil
}

func (r *IssuesDeleteLabelReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesDeleteLabelReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesDeleteLabelReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesDeleteLabelReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesDeleteLabelReq) Rel(link RelName, resp *IssuesDeleteLabelResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesDeleteLabelResponse is a response for IssuesDeleteLabel

https://developer.github.com/v3/issues/labels/#delete-a-label
*/
type IssuesDeleteLabelResponse struct {
	response
	request *IssuesDeleteLabelReq
}

/*
IssuesDeleteMilestone performs requests for "issues/delete-milestone"

Delete a milestone.

  DELETE /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
func IssuesDeleteMilestone(ctx context.Context, req *IssuesDeleteMilestoneReq, opt ...RequestOption) (*IssuesDeleteMilestoneResponse, error) {
	if req == nil {
		req = new(IssuesDeleteMilestoneReq)
	}
	resp := &IssuesDeleteMilestoneResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesDeleteMilestone performs requests for "issues/delete-milestone"

Delete a milestone.

  DELETE /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
func (c Client) IssuesDeleteMilestone(ctx context.Context, req *IssuesDeleteMilestoneReq, opt ...RequestOption) (*IssuesDeleteMilestoneResponse, error) {
	return IssuesDeleteMilestone(ctx, req, append(c, opt...)...)
}

/*
IssuesDeleteMilestoneReq is request data for Client.IssuesDeleteMilestone

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
type IssuesDeleteMilestoneReq struct {
	_url            string
	Owner           string
	Repo            string
	MilestoneNumber int64
}

func (r *IssuesDeleteMilestoneReq) url() string {
	return r._url
}

func (r *IssuesDeleteMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber)
}

func (r *IssuesDeleteMilestoneReq) method() string {
	return "DELETE"
}

func (r *IssuesDeleteMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesDeleteMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesDeleteMilestoneReq) body() interface{} {
	return nil
}

func (r *IssuesDeleteMilestoneReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesDeleteMilestoneReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesDeleteMilestoneReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesDeleteMilestoneReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesDeleteMilestoneReq) Rel(link RelName, resp *IssuesDeleteMilestoneResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesDeleteMilestoneResponse is a response for IssuesDeleteMilestone

https://developer.github.com/v3/issues/milestones/#delete-a-milestone
*/
type IssuesDeleteMilestoneResponse struct {
	response
	request *IssuesDeleteMilestoneReq
}

/*
IssuesGet performs requests for "issues/get"

Get an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#get-an-issue
*/
func IssuesGet(ctx context.Context, req *IssuesGetReq, opt ...RequestOption) (*IssuesGetResponse, error) {
	if req == nil {
		req = new(IssuesGetReq)
	}
	resp := &IssuesGetResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesGetResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGet performs requests for "issues/get"

Get an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#get-an-issue
*/
func (c Client) IssuesGet(ctx context.Context, req *IssuesGetReq, opt ...RequestOption) (*IssuesGetResponse, error) {
	return IssuesGet(ctx, req, append(c, opt...)...)
}

/*
IssuesGetReq is request data for Client.IssuesGet

https://developer.github.com/v3/issues/#get-an-issue
*/
type IssuesGetReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesGetReq) url() string {
	return r._url
}

func (r *IssuesGetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesGetReq) method() string {
	return "GET"
}

func (r *IssuesGetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetReq) body() interface{} {
	return nil
}

func (r *IssuesGetReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesGetReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesGetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesGetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetReq) Rel(link RelName, resp *IssuesGetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesGetResponseBody is a response body for IssuesGet

https://developer.github.com/v3/issues/#get-an-issue
*/
type IssuesGetResponseBody struct {
	components.Issue
}

/*
IssuesGetResponse is a response for IssuesGet

https://developer.github.com/v3/issues/#get-an-issue
*/
type IssuesGetResponse struct {
	response
	request *IssuesGetReq
	Data    *IssuesGetResponseBody
}

/*
IssuesGetComment performs requests for "issues/get-comment"

Get an issue comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#get-an-issue-comment
*/
func IssuesGetComment(ctx context.Context, req *IssuesGetCommentReq, opt ...RequestOption) (*IssuesGetCommentResponse, error) {
	if req == nil {
		req = new(IssuesGetCommentReq)
	}
	resp := &IssuesGetCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesGetCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGetComment performs requests for "issues/get-comment"

Get an issue comment.

  GET /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#get-an-issue-comment
*/
func (c Client) IssuesGetComment(ctx context.Context, req *IssuesGetCommentReq, opt ...RequestOption) (*IssuesGetCommentResponse, error) {
	return IssuesGetComment(ctx, req, append(c, opt...)...)
}

/*
IssuesGetCommentReq is request data for Client.IssuesGetComment

https://developer.github.com/v3/issues/comments/#get-an-issue-comment
*/
type IssuesGetCommentReq struct {
	_url      string
	Owner     string
	Repo      string
	CommentId int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesGetCommentReq) url() string {
	return r._url
}

func (r *IssuesGetCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *IssuesGetCommentReq) method() string {
	return "GET"
}

func (r *IssuesGetCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetCommentReq) body() interface{} {
	return nil
}

func (r *IssuesGetCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesGetCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesGetCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesGetCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetCommentReq) Rel(link RelName, resp *IssuesGetCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesGetCommentResponseBody is a response body for IssuesGetComment

https://developer.github.com/v3/issues/comments/#get-an-issue-comment
*/
type IssuesGetCommentResponseBody struct {
	components.IssueComment
}

/*
IssuesGetCommentResponse is a response for IssuesGetComment

https://developer.github.com/v3/issues/comments/#get-an-issue-comment
*/
type IssuesGetCommentResponse struct {
	response
	request *IssuesGetCommentReq
	Data    *IssuesGetCommentResponseBody
}

/*
IssuesGetEvent performs requests for "issues/get-event"

Get an issue event.

  GET /repos/{owner}/{repo}/issues/events/{event_id}

https://developer.github.com/v3/issues/events/#get-an-issue-event
*/
func IssuesGetEvent(ctx context.Context, req *IssuesGetEventReq, opt ...RequestOption) (*IssuesGetEventResponse, error) {
	if req == nil {
		req = new(IssuesGetEventReq)
	}
	resp := &IssuesGetEventResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesGetEventResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGetEvent performs requests for "issues/get-event"

Get an issue event.

  GET /repos/{owner}/{repo}/issues/events/{event_id}

https://developer.github.com/v3/issues/events/#get-an-issue-event
*/
func (c Client) IssuesGetEvent(ctx context.Context, req *IssuesGetEventReq, opt ...RequestOption) (*IssuesGetEventResponse, error) {
	return IssuesGetEvent(ctx, req, append(c, opt...)...)
}

/*
IssuesGetEventReq is request data for Client.IssuesGetEvent

https://developer.github.com/v3/issues/events/#get-an-issue-event
*/
type IssuesGetEventReq struct {
	_url    string
	Owner   string
	Repo    string
	EventId int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *IssuesGetEventReq) url() string {
	return r._url
}

func (r *IssuesGetEventReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/events/%v", r.Owner, r.Repo, r.EventId)
}

func (r *IssuesGetEventReq) method() string {
	return "GET"
}

func (r *IssuesGetEventReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetEventReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man": r.MachineManPreview,
		"sailor-v":    r.SailorVPreview,
		"starfox":     r.StarfoxPreview,
	}
	if allPreviews {
		previewVals["starfox"] = true
		previewVals["machine-man"] = true
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetEventReq) body() interface{} {
	return nil
}

func (r *IssuesGetEventReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesGetEventReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesGetEventReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesGetEventReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetEventReq) Rel(link RelName, resp *IssuesGetEventResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesGetEventResponseBody is a response body for IssuesGetEvent

https://developer.github.com/v3/issues/events/#get-an-issue-event
*/
type IssuesGetEventResponseBody struct {
	components.IssueEvent
}

/*
IssuesGetEventResponse is a response for IssuesGetEvent

https://developer.github.com/v3/issues/events/#get-an-issue-event
*/
type IssuesGetEventResponse struct {
	response
	request *IssuesGetEventReq
	Data    *IssuesGetEventResponseBody
}

/*
IssuesGetLabel performs requests for "issues/get-label"

Get a label.

  GET /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#get-a-label
*/
func IssuesGetLabel(ctx context.Context, req *IssuesGetLabelReq, opt ...RequestOption) (*IssuesGetLabelResponse, error) {
	if req == nil {
		req = new(IssuesGetLabelReq)
	}
	resp := &IssuesGetLabelResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesGetLabelResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGetLabel performs requests for "issues/get-label"

Get a label.

  GET /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#get-a-label
*/
func (c Client) IssuesGetLabel(ctx context.Context, req *IssuesGetLabelReq, opt ...RequestOption) (*IssuesGetLabelResponse, error) {
	return IssuesGetLabel(ctx, req, append(c, opt...)...)
}

/*
IssuesGetLabelReq is request data for Client.IssuesGetLabel

https://developer.github.com/v3/issues/labels/#get-a-label
*/
type IssuesGetLabelReq struct {
	_url  string
	Owner string
	Repo  string
	Name  string
}

func (r *IssuesGetLabelReq) url() string {
	return r._url
}

func (r *IssuesGetLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name)
}

func (r *IssuesGetLabelReq) method() string {
	return "GET"
}

func (r *IssuesGetLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetLabelReq) body() interface{} {
	return nil
}

func (r *IssuesGetLabelReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesGetLabelReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesGetLabelReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesGetLabelReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetLabelReq) Rel(link RelName, resp *IssuesGetLabelResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesGetLabelResponseBody is a response body for IssuesGetLabel

https://developer.github.com/v3/issues/labels/#get-a-label
*/
type IssuesGetLabelResponseBody struct {
	components.Label
}

/*
IssuesGetLabelResponse is a response for IssuesGetLabel

https://developer.github.com/v3/issues/labels/#get-a-label
*/
type IssuesGetLabelResponse struct {
	response
	request *IssuesGetLabelReq
	Data    *IssuesGetLabelResponseBody
}

/*
IssuesGetMilestone performs requests for "issues/get-milestone"

Get a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#get-a-milestone
*/
func IssuesGetMilestone(ctx context.Context, req *IssuesGetMilestoneReq, opt ...RequestOption) (*IssuesGetMilestoneResponse, error) {
	if req == nil {
		req = new(IssuesGetMilestoneReq)
	}
	resp := &IssuesGetMilestoneResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesGetMilestoneResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesGetMilestone performs requests for "issues/get-milestone"

Get a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#get-a-milestone
*/
func (c Client) IssuesGetMilestone(ctx context.Context, req *IssuesGetMilestoneReq, opt ...RequestOption) (*IssuesGetMilestoneResponse, error) {
	return IssuesGetMilestone(ctx, req, append(c, opt...)...)
}

/*
IssuesGetMilestoneReq is request data for Client.IssuesGetMilestone

https://developer.github.com/v3/issues/milestones/#get-a-milestone
*/
type IssuesGetMilestoneReq struct {
	_url            string
	Owner           string
	Repo            string
	MilestoneNumber int64
}

func (r *IssuesGetMilestoneReq) url() string {
	return r._url
}

func (r *IssuesGetMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber)
}

func (r *IssuesGetMilestoneReq) method() string {
	return "GET"
}

func (r *IssuesGetMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesGetMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesGetMilestoneReq) body() interface{} {
	return nil
}

func (r *IssuesGetMilestoneReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesGetMilestoneReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesGetMilestoneReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesGetMilestoneReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesGetMilestoneReq) Rel(link RelName, resp *IssuesGetMilestoneResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesGetMilestoneResponseBody is a response body for IssuesGetMilestone

https://developer.github.com/v3/issues/milestones/#get-a-milestone
*/
type IssuesGetMilestoneResponseBody struct {
	components.Milestone
}

/*
IssuesGetMilestoneResponse is a response for IssuesGetMilestone

https://developer.github.com/v3/issues/milestones/#get-a-milestone
*/
type IssuesGetMilestoneResponse struct {
	response
	request *IssuesGetMilestoneReq
	Data    *IssuesGetMilestoneResponseBody
}

/*
IssuesList performs requests for "issues/list"

List issues assigned to the authenticated user.

  GET /issues

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
func IssuesList(ctx context.Context, req *IssuesListReq, opt ...RequestOption) (*IssuesListResponse, error) {
	if req == nil {
		req = new(IssuesListReq)
	}
	resp := &IssuesListResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesList performs requests for "issues/list"

List issues assigned to the authenticated user.

  GET /issues

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
func (c Client) IssuesList(ctx context.Context, req *IssuesListReq, opt ...RequestOption) (*IssuesListResponse, error) {
	return IssuesList(ctx, req, append(c, opt...)...)
}

/*
IssuesListReq is request data for Client.IssuesList

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
type IssuesListReq struct {
	_url string

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// The direction of the sort. Can be either `asc` or `desc`.
	Direction *string

	/*
	Only issues updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListReq) url() string {
	return r._url
}

func (r *IssuesListReq) urlPath() string {
	return fmt.Sprintf("/issues")
}

func (r *IssuesListReq) method() string {
	return "GET"
}

func (r *IssuesListReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListReq) body() interface{} {
	return nil
}

func (r *IssuesListReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListReq) Rel(link RelName, resp *IssuesListResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListResponseBody is a response body for IssuesList

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
type IssuesListResponseBody []struct {
	components.IssueWithRepo
}

/*
IssuesListResponse is a response for IssuesList

https://developer.github.com/v3/issues/#list-issues-assigned-to-the-authenticated-user
*/
type IssuesListResponse struct {
	response
	request *IssuesListReq
	Data    *IssuesListResponseBody
}

/*
IssuesListAssignees performs requests for "issues/list-assignees"

List assignees.

  GET /repos/{owner}/{repo}/assignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
func IssuesListAssignees(ctx context.Context, req *IssuesListAssigneesReq, opt ...RequestOption) (*IssuesListAssigneesResponse, error) {
	if req == nil {
		req = new(IssuesListAssigneesReq)
	}
	resp := &IssuesListAssigneesResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListAssigneesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListAssignees performs requests for "issues/list-assignees"

List assignees.

  GET /repos/{owner}/{repo}/assignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
func (c Client) IssuesListAssignees(ctx context.Context, req *IssuesListAssigneesReq, opt ...RequestOption) (*IssuesListAssigneesResponse, error) {
	return IssuesListAssignees(ctx, req, append(c, opt...)...)
}

/*
IssuesListAssigneesReq is request data for Client.IssuesListAssignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
type IssuesListAssigneesReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListAssigneesReq) url() string {
	return r._url
}

func (r *IssuesListAssigneesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/assignees", r.Owner, r.Repo)
}

func (r *IssuesListAssigneesReq) method() string {
	return "GET"
}

func (r *IssuesListAssigneesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListAssigneesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListAssigneesReq) body() interface{} {
	return nil
}

func (r *IssuesListAssigneesReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListAssigneesReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListAssigneesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListAssigneesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListAssigneesReq) Rel(link RelName, resp *IssuesListAssigneesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListAssigneesResponseBody is a response body for IssuesListAssignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
type IssuesListAssigneesResponseBody []struct {
	components.SimpleUser
}

/*
IssuesListAssigneesResponse is a response for IssuesListAssignees

https://developer.github.com/v3/issues/assignees/#list-assignees
*/
type IssuesListAssigneesResponse struct {
	response
	request *IssuesListAssigneesReq
	Data    *IssuesListAssigneesResponseBody
}

/*
IssuesListComments performs requests for "issues/list-comments"

List issue comments.

  GET /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#list-issue-comments
*/
func IssuesListComments(ctx context.Context, req *IssuesListCommentsReq, opt ...RequestOption) (*IssuesListCommentsResponse, error) {
	if req == nil {
		req = new(IssuesListCommentsReq)
	}
	resp := &IssuesListCommentsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListCommentsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListComments performs requests for "issues/list-comments"

List issue comments.

  GET /repos/{owner}/{repo}/issues/{issue_number}/comments

https://developer.github.com/v3/issues/comments/#list-issue-comments
*/
func (c Client) IssuesListComments(ctx context.Context, req *IssuesListCommentsReq, opt ...RequestOption) (*IssuesListCommentsResponse, error) {
	return IssuesListComments(ctx, req, append(c, opt...)...)
}

/*
IssuesListCommentsReq is request data for Client.IssuesListComments

https://developer.github.com/v3/issues/comments/#list-issue-comments
*/
type IssuesListCommentsReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64

	/*
	Only comments updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListCommentsReq) url() string {
	return r._url
}

func (r *IssuesListCommentsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/comments", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesListCommentsReq) method() string {
	return "GET"
}

func (r *IssuesListCommentsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListCommentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListCommentsReq) body() interface{} {
	return nil
}

func (r *IssuesListCommentsReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListCommentsReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListCommentsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListCommentsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListCommentsReq) Rel(link RelName, resp *IssuesListCommentsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListCommentsResponseBody is a response body for IssuesListComments

https://developer.github.com/v3/issues/comments/#list-issue-comments
*/
type IssuesListCommentsResponseBody []struct {
	components.IssueComment
}

/*
IssuesListCommentsResponse is a response for IssuesListComments

https://developer.github.com/v3/issues/comments/#list-issue-comments
*/
type IssuesListCommentsResponse struct {
	response
	request *IssuesListCommentsReq
	Data    *IssuesListCommentsResponseBody
}

/*
IssuesListCommentsForRepo performs requests for "issues/list-comments-for-repo"

List issue comments for a repository.

  GET /repos/{owner}/{repo}/issues/comments

https://developer.github.com/v3/issues/comments/#list-issue-comments-for-a-repository
*/
func IssuesListCommentsForRepo(ctx context.Context, req *IssuesListCommentsForRepoReq, opt ...RequestOption) (*IssuesListCommentsForRepoResponse, error) {
	if req == nil {
		req = new(IssuesListCommentsForRepoReq)
	}
	resp := &IssuesListCommentsForRepoResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListCommentsForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListCommentsForRepo performs requests for "issues/list-comments-for-repo"

List issue comments for a repository.

  GET /repos/{owner}/{repo}/issues/comments

https://developer.github.com/v3/issues/comments/#list-issue-comments-for-a-repository
*/
func (c Client) IssuesListCommentsForRepo(ctx context.Context, req *IssuesListCommentsForRepoReq, opt ...RequestOption) (*IssuesListCommentsForRepoResponse, error) {
	return IssuesListCommentsForRepo(ctx, req, append(c, opt...)...)
}

/*
IssuesListCommentsForRepoReq is request data for Client.IssuesListCommentsForRepo

https://developer.github.com/v3/issues/comments/#list-issue-comments-for-a-repository
*/
type IssuesListCommentsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Either `created` or `updated`.
	Sort *string

	// Either `asc` or `desc`. Ignored without the `sort` parameter.
	Direction *string

	/*
	Only comments updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListCommentsForRepoReq) url() string {
	return r._url
}

func (r *IssuesListCommentsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments", r.Owner, r.Repo)
}

func (r *IssuesListCommentsForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListCommentsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListCommentsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListCommentsForRepoReq) body() interface{} {
	return nil
}

func (r *IssuesListCommentsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListCommentsForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListCommentsForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListCommentsForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListCommentsForRepoReq) Rel(link RelName, resp *IssuesListCommentsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListCommentsForRepoResponseBody is a response body for IssuesListCommentsForRepo

https://developer.github.com/v3/issues/comments/#list-issue-comments-for-a-repository
*/
type IssuesListCommentsForRepoResponseBody []struct {
	components.IssueComment
}

/*
IssuesListCommentsForRepoResponse is a response for IssuesListCommentsForRepo

https://developer.github.com/v3/issues/comments/#list-issue-comments-for-a-repository
*/
type IssuesListCommentsForRepoResponse struct {
	response
	request *IssuesListCommentsForRepoReq
	Data    *IssuesListCommentsForRepoResponseBody
}

/*
IssuesListEvents performs requests for "issues/list-events"

List issue events.

  GET /repos/{owner}/{repo}/issues/{issue_number}/events

https://developer.github.com/v3/issues/events/#list-issue-events
*/
func IssuesListEvents(ctx context.Context, req *IssuesListEventsReq, opt ...RequestOption) (*IssuesListEventsResponse, error) {
	if req == nil {
		req = new(IssuesListEventsReq)
	}
	resp := &IssuesListEventsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListEventsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListEvents performs requests for "issues/list-events"

List issue events.

  GET /repos/{owner}/{repo}/issues/{issue_number}/events

https://developer.github.com/v3/issues/events/#list-issue-events
*/
func (c Client) IssuesListEvents(ctx context.Context, req *IssuesListEventsReq, opt ...RequestOption) (*IssuesListEventsResponse, error) {
	return IssuesListEvents(ctx, req, append(c, opt...)...)
}

/*
IssuesListEventsReq is request data for Client.IssuesListEvents

https://developer.github.com/v3/issues/events/#list-issue-events
*/
type IssuesListEventsReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *IssuesListEventsReq) url() string {
	return r._url
}

func (r *IssuesListEventsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/events", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesListEventsReq) method() string {
	return "GET"
}

func (r *IssuesListEventsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListEventsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"sailor-v": r.SailorVPreview,
		"starfox":  r.StarfoxPreview,
	}
	if allPreviews {
		previewVals["starfox"] = true
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListEventsReq) body() interface{} {
	return nil
}

func (r *IssuesListEventsReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListEventsReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListEventsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListEventsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListEventsReq) Rel(link RelName, resp *IssuesListEventsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListEventsResponseBody is a response body for IssuesListEvents

https://developer.github.com/v3/issues/events/#list-issue-events
*/
type IssuesListEventsResponseBody []struct {
	components.IssueEventForIssue
}

/*
IssuesListEventsResponse is a response for IssuesListEvents

https://developer.github.com/v3/issues/events/#list-issue-events
*/
type IssuesListEventsResponse struct {
	response
	request *IssuesListEventsReq
	Data    *IssuesListEventsResponseBody
}

/*
IssuesListEventsForRepo performs requests for "issues/list-events-for-repo"

List issue events for a repository.

  GET /repos/{owner}/{repo}/issues/events

https://developer.github.com/v3/issues/events/#list-issue-events-for-a-repository
*/
func IssuesListEventsForRepo(ctx context.Context, req *IssuesListEventsForRepoReq, opt ...RequestOption) (*IssuesListEventsForRepoResponse, error) {
	if req == nil {
		req = new(IssuesListEventsForRepoReq)
	}
	resp := &IssuesListEventsForRepoResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListEventsForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListEventsForRepo performs requests for "issues/list-events-for-repo"

List issue events for a repository.

  GET /repos/{owner}/{repo}/issues/events

https://developer.github.com/v3/issues/events/#list-issue-events-for-a-repository
*/
func (c Client) IssuesListEventsForRepo(ctx context.Context, req *IssuesListEventsForRepoReq, opt ...RequestOption) (*IssuesListEventsForRepoResponse, error) {
	return IssuesListEventsForRepo(ctx, req, append(c, opt...)...)
}

/*
IssuesListEventsForRepoReq is request data for Client.IssuesListEventsForRepo

https://developer.github.com/v3/issues/events/#list-issue-events-for-a-repository
*/
type IssuesListEventsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *IssuesListEventsForRepoReq) url() string {
	return r._url
}

func (r *IssuesListEventsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/events", r.Owner, r.Repo)
}

func (r *IssuesListEventsForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListEventsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListEventsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"sailor-v": r.SailorVPreview,
		"starfox":  r.StarfoxPreview,
	}
	if allPreviews {
		previewVals["starfox"] = true
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListEventsForRepoReq) body() interface{} {
	return nil
}

func (r *IssuesListEventsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListEventsForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListEventsForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListEventsForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListEventsForRepoReq) Rel(link RelName, resp *IssuesListEventsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListEventsForRepoResponseBody is a response body for IssuesListEventsForRepo

https://developer.github.com/v3/issues/events/#list-issue-events-for-a-repository
*/
type IssuesListEventsForRepoResponseBody []struct {
	components.IssueEvent
}

/*
IssuesListEventsForRepoResponse is a response for IssuesListEventsForRepo

https://developer.github.com/v3/issues/events/#list-issue-events-for-a-repository
*/
type IssuesListEventsForRepoResponse struct {
	response
	request *IssuesListEventsForRepoReq
	Data    *IssuesListEventsForRepoResponseBody
}

/*
IssuesListEventsForTimeline performs requests for "issues/list-events-for-timeline"

List timeline events for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/timeline

https://developer.github.com/v3/issues/timeline/#list-timeline-events-for-an-issue
*/
func IssuesListEventsForTimeline(ctx context.Context, req *IssuesListEventsForTimelineReq, opt ...RequestOption) (*IssuesListEventsForTimelineResponse, error) {
	if req == nil {
		req = new(IssuesListEventsForTimelineReq)
	}
	resp := &IssuesListEventsForTimelineResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListEventsForTimelineResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListEventsForTimeline performs requests for "issues/list-events-for-timeline"

List timeline events for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/timeline

https://developer.github.com/v3/issues/timeline/#list-timeline-events-for-an-issue
*/
func (c Client) IssuesListEventsForTimeline(ctx context.Context, req *IssuesListEventsForTimelineReq, opt ...RequestOption) (*IssuesListEventsForTimelineResponse, error) {
	return IssuesListEventsForTimeline(ctx, req, append(c, opt...)...)
}

/*
IssuesListEventsForTimelineReq is request data for Client.IssuesListEventsForTimeline

https://developer.github.com/v3/issues/timeline/#list-timeline-events-for-an-issue
*/
type IssuesListEventsForTimelineReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The API to get issue timeline events is currently available for developers to
	preview. During the preview period, the APIs may change without advance notice.
	Please see the [blog
	post](https://developer.github.com/changes/2016-05-23-timeline-preview-api/) for
	full details. To access the API you must set this to true.
	*/
	MockingbirdPreview bool

	/*
	Project card details are now shown in REST API v3 responses for project-related
	issue and timeline events. This feature is now available for developers to
	preview. For details, see the [blog
	post](https://developer.github.com/changes/2018-09-05-project-card-events).

	To receive the `project_card` attribute, project boards must be
	[enabled](https://help.github.com/articles/disabling-project-boards-in-a-repository)
	for a repository, and you must set this to true.
	*/
	StarfoxPreview bool
}

func (r *IssuesListEventsForTimelineReq) url() string {
	return r._url
}

func (r *IssuesListEventsForTimelineReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/timeline", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesListEventsForTimelineReq) method() string {
	return "GET"
}

func (r *IssuesListEventsForTimelineReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListEventsForTimelineReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"mockingbird": r.MockingbirdPreview,
		"starfox":     r.StarfoxPreview,
	}
	if requiredPreviews {
		previewVals["mockingbird"] = true
	}
	if allPreviews {
		previewVals["mockingbird"] = true
		previewVals["starfox"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListEventsForTimelineReq) body() interface{} {
	return nil
}

func (r *IssuesListEventsForTimelineReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListEventsForTimelineReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListEventsForTimelineReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListEventsForTimelineReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListEventsForTimelineReq) Rel(link RelName, resp *IssuesListEventsForTimelineResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListEventsForTimelineResponseBody is a response body for IssuesListEventsForTimeline

https://developer.github.com/v3/issues/timeline/#list-timeline-events-for-an-issue
*/
type IssuesListEventsForTimelineResponseBody []struct {
	components.IssueEventForIssue
}

/*
IssuesListEventsForTimelineResponse is a response for IssuesListEventsForTimeline

https://developer.github.com/v3/issues/timeline/#list-timeline-events-for-an-issue
*/
type IssuesListEventsForTimelineResponse struct {
	response
	request *IssuesListEventsForTimelineReq
	Data    *IssuesListEventsForTimelineResponseBody
}

/*
IssuesListForAuthenticatedUser performs requests for "issues/list-for-authenticated-user"

List user account issues assigned to the authenticated user.

  GET /user/issues

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
func IssuesListForAuthenticatedUser(ctx context.Context, req *IssuesListForAuthenticatedUserReq, opt ...RequestOption) (*IssuesListForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(IssuesListForAuthenticatedUserReq)
	}
	resp := &IssuesListForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListForAuthenticatedUser performs requests for "issues/list-for-authenticated-user"

List user account issues assigned to the authenticated user.

  GET /user/issues

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
func (c Client) IssuesListForAuthenticatedUser(ctx context.Context, req *IssuesListForAuthenticatedUserReq, opt ...RequestOption) (*IssuesListForAuthenticatedUserResponse, error) {
	return IssuesListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
IssuesListForAuthenticatedUserReq is request data for Client.IssuesListForAuthenticatedUser

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
type IssuesListForAuthenticatedUserReq struct {
	_url string

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// The direction of the sort. Can be either `asc` or `desc`.
	Direction *string

	/*
	Only issues updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *IssuesListForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/issues")
}

func (r *IssuesListForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *IssuesListForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *IssuesListForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListForAuthenticatedUserReq) Rel(link RelName, resp *IssuesListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListForAuthenticatedUserResponseBody is a response body for IssuesListForAuthenticatedUser

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
type IssuesListForAuthenticatedUserResponseBody []struct {
	components.IssueWithRepo
}

/*
IssuesListForAuthenticatedUserResponse is a response for IssuesListForAuthenticatedUser

https://developer.github.com/v3/issues/#list-user-account-issues-assigned-to-the-authenticated-user
*/
type IssuesListForAuthenticatedUserResponse struct {
	response
	request *IssuesListForAuthenticatedUserReq
	Data    *IssuesListForAuthenticatedUserResponseBody
}

/*
IssuesListForOrg performs requests for "issues/list-for-org"

List organization issues assigned to the authenticated user.

  GET /orgs/{org}/issues

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
func IssuesListForOrg(ctx context.Context, req *IssuesListForOrgReq, opt ...RequestOption) (*IssuesListForOrgResponse, error) {
	if req == nil {
		req = new(IssuesListForOrgReq)
	}
	resp := &IssuesListForOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListForOrg performs requests for "issues/list-for-org"

List organization issues assigned to the authenticated user.

  GET /orgs/{org}/issues

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
func (c Client) IssuesListForOrg(ctx context.Context, req *IssuesListForOrgReq, opt ...RequestOption) (*IssuesListForOrgResponse, error) {
	return IssuesListForOrg(ctx, req, append(c, opt...)...)
}

/*
IssuesListForOrgReq is request data for Client.IssuesListForOrg

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
type IssuesListForOrgReq struct {
	_url string
	Org  string

	/*
	Indicates which sorts of issues to return. Can be one of:
	\* `assigned`: Issues assigned to you
	\* `created`: Issues created by you
	\* `mentioned`: Issues mentioning you
	\* `subscribed`: Issues you're subscribed to updates for
	\* `all`: All issues the authenticated user can see, regardless of participation
	or creation
	*/
	Filter *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// The direction of the sort. Can be either `asc` or `desc`.
	Direction *string

	/*
	Only issues updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListForOrgReq) url() string {
	return r._url
}

func (r *IssuesListForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/issues", r.Org)
}

func (r *IssuesListForOrgReq) method() string {
	return "GET"
}

func (r *IssuesListForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListForOrgReq) body() interface{} {
	return nil
}

func (r *IssuesListForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListForOrgReq) Rel(link RelName, resp *IssuesListForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListForOrgResponseBody is a response body for IssuesListForOrg

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
type IssuesListForOrgResponseBody []struct {
	components.IssueWithRepo
}

/*
IssuesListForOrgResponse is a response for IssuesListForOrg

https://developer.github.com/v3/issues/#list-organization-issues-assigned-to-the-authenticated-user
*/
type IssuesListForOrgResponse struct {
	response
	request *IssuesListForOrgReq
	Data    *IssuesListForOrgResponseBody
}

/*
IssuesListForRepo performs requests for "issues/list-for-repo"

List repository issues.

  GET /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#list-repository-issues
*/
func IssuesListForRepo(ctx context.Context, req *IssuesListForRepoReq, opt ...RequestOption) (*IssuesListForRepoResponse, error) {
	if req == nil {
		req = new(IssuesListForRepoReq)
	}
	resp := &IssuesListForRepoResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListForRepo performs requests for "issues/list-for-repo"

List repository issues.

  GET /repos/{owner}/{repo}/issues

https://developer.github.com/v3/issues/#list-repository-issues
*/
func (c Client) IssuesListForRepo(ctx context.Context, req *IssuesListForRepoReq, opt ...RequestOption) (*IssuesListForRepoResponse, error) {
	return IssuesListForRepo(ctx, req, append(c, opt...)...)
}

/*
IssuesListForRepoReq is request data for Client.IssuesListForRepo

https://developer.github.com/v3/issues/#list-repository-issues
*/
type IssuesListForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	If an `integer` is passed, it should refer to a milestone by its `number` field.
	If the string `*` is passed, issues with any milestone are accepted. If the
	string `none` is passed, issues without milestones are returned.
	*/
	Milestone *string

	/*
	Indicates the state of the issues to return. Can be either `open`, `closed`, or
	`all`.
	*/
	State *string

	/*
	Can be the name of a user. Pass in `none` for issues with no assigned user, and
	`*` for issues assigned to any user.
	*/
	Assignee *string

	// The user that created the issue.
	Creator *string

	// A user that's mentioned in the issue.
	Mentioned *string

	// A list of comma separated label names. Example: `bug,ui,@high`
	Labels *string

	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort *string

	// The direction of the sort. Can be either `asc` or `desc`.
	Direction *string

	/*
	Only issues updated at or after this time are returned. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *IssuesListForRepoReq) url() string {
	return r._url
}

func (r *IssuesListForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues", r.Owner, r.Repo)
}

func (r *IssuesListForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Milestone != nil {
		query.Set("milestone", *r.Milestone)
	}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Assignee != nil {
		query.Set("assignee", *r.Assignee)
	}
	if r.Creator != nil {
		query.Set("creator", *r.Creator)
	}
	if r.Mentioned != nil {
		query.Set("mentioned", *r.Mentioned)
	}
	if r.Labels != nil {
		query.Set("labels", *r.Labels)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"machine-man":   r.MachineManPreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["machine-man"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListForRepoReq) body() interface{} {
	return nil
}

func (r *IssuesListForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListForRepoReq) Rel(link RelName, resp *IssuesListForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListForRepoResponseBody is a response body for IssuesListForRepo

https://developer.github.com/v3/issues/#list-repository-issues
*/
type IssuesListForRepoResponseBody []struct {
	components.IssueSimple2
}

/*
IssuesListForRepoResponse is a response for IssuesListForRepo

https://developer.github.com/v3/issues/#list-repository-issues
*/
type IssuesListForRepoResponse struct {
	response
	request *IssuesListForRepoReq
	Data    *IssuesListForRepoResponseBody
}

/*
IssuesListLabelsForMilestone performs requests for "issues/list-labels-for-milestone"

List labels for issues in a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-issues-in-a-milestone
*/
func IssuesListLabelsForMilestone(ctx context.Context, req *IssuesListLabelsForMilestoneReq, opt ...RequestOption) (*IssuesListLabelsForMilestoneResponse, error) {
	if req == nil {
		req = new(IssuesListLabelsForMilestoneReq)
	}
	resp := &IssuesListLabelsForMilestoneResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListLabelsForMilestoneResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListLabelsForMilestone performs requests for "issues/list-labels-for-milestone"

List labels for issues in a milestone.

  GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-issues-in-a-milestone
*/
func (c Client) IssuesListLabelsForMilestone(ctx context.Context, req *IssuesListLabelsForMilestoneReq, opt ...RequestOption) (*IssuesListLabelsForMilestoneResponse, error) {
	return IssuesListLabelsForMilestone(ctx, req, append(c, opt...)...)
}

/*
IssuesListLabelsForMilestoneReq is request data for Client.IssuesListLabelsForMilestone

https://developer.github.com/v3/issues/labels/#list-labels-for-issues-in-a-milestone
*/
type IssuesListLabelsForMilestoneReq struct {
	_url            string
	Owner           string
	Repo            string
	MilestoneNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListLabelsForMilestoneReq) url() string {
	return r._url
}

func (r *IssuesListLabelsForMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones/%v/labels", r.Owner, r.Repo, r.MilestoneNumber)
}

func (r *IssuesListLabelsForMilestoneReq) method() string {
	return "GET"
}

func (r *IssuesListLabelsForMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListLabelsForMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListLabelsForMilestoneReq) body() interface{} {
	return nil
}

func (r *IssuesListLabelsForMilestoneReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListLabelsForMilestoneReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListLabelsForMilestoneReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListLabelsForMilestoneReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListLabelsForMilestoneReq) Rel(link RelName, resp *IssuesListLabelsForMilestoneResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListLabelsForMilestoneResponseBody is a response body for IssuesListLabelsForMilestone

https://developer.github.com/v3/issues/labels/#list-labels-for-issues-in-a-milestone
*/
type IssuesListLabelsForMilestoneResponseBody []struct {
	components.Label
}

/*
IssuesListLabelsForMilestoneResponse is a response for IssuesListLabelsForMilestone

https://developer.github.com/v3/issues/labels/#list-labels-for-issues-in-a-milestone
*/
type IssuesListLabelsForMilestoneResponse struct {
	response
	request *IssuesListLabelsForMilestoneReq
	Data    *IssuesListLabelsForMilestoneResponseBody
}

/*
IssuesListLabelsForRepo performs requests for "issues/list-labels-for-repo"

List labels for a repository.

  GET /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-a-repository
*/
func IssuesListLabelsForRepo(ctx context.Context, req *IssuesListLabelsForRepoReq, opt ...RequestOption) (*IssuesListLabelsForRepoResponse, error) {
	if req == nil {
		req = new(IssuesListLabelsForRepoReq)
	}
	resp := &IssuesListLabelsForRepoResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListLabelsForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListLabelsForRepo performs requests for "issues/list-labels-for-repo"

List labels for a repository.

  GET /repos/{owner}/{repo}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-a-repository
*/
func (c Client) IssuesListLabelsForRepo(ctx context.Context, req *IssuesListLabelsForRepoReq, opt ...RequestOption) (*IssuesListLabelsForRepoResponse, error) {
	return IssuesListLabelsForRepo(ctx, req, append(c, opt...)...)
}

/*
IssuesListLabelsForRepoReq is request data for Client.IssuesListLabelsForRepo

https://developer.github.com/v3/issues/labels/#list-labels-for-a-repository
*/
type IssuesListLabelsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListLabelsForRepoReq) url() string {
	return r._url
}

func (r *IssuesListLabelsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels", r.Owner, r.Repo)
}

func (r *IssuesListLabelsForRepoReq) method() string {
	return "GET"
}

func (r *IssuesListLabelsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListLabelsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListLabelsForRepoReq) body() interface{} {
	return nil
}

func (r *IssuesListLabelsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListLabelsForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListLabelsForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListLabelsForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListLabelsForRepoReq) Rel(link RelName, resp *IssuesListLabelsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListLabelsForRepoResponseBody is a response body for IssuesListLabelsForRepo

https://developer.github.com/v3/issues/labels/#list-labels-for-a-repository
*/
type IssuesListLabelsForRepoResponseBody []struct {
	components.Label
}

/*
IssuesListLabelsForRepoResponse is a response for IssuesListLabelsForRepo

https://developer.github.com/v3/issues/labels/#list-labels-for-a-repository
*/
type IssuesListLabelsForRepoResponse struct {
	response
	request *IssuesListLabelsForRepoReq
	Data    *IssuesListLabelsForRepoResponseBody
}

/*
IssuesListLabelsOnIssue performs requests for "issues/list-labels-on-issue"

List labels for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-an-issue
*/
func IssuesListLabelsOnIssue(ctx context.Context, req *IssuesListLabelsOnIssueReq, opt ...RequestOption) (*IssuesListLabelsOnIssueResponse, error) {
	if req == nil {
		req = new(IssuesListLabelsOnIssueReq)
	}
	resp := &IssuesListLabelsOnIssueResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListLabelsOnIssueResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListLabelsOnIssue performs requests for "issues/list-labels-on-issue"

List labels for an issue.

  GET /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#list-labels-for-an-issue
*/
func (c Client) IssuesListLabelsOnIssue(ctx context.Context, req *IssuesListLabelsOnIssueReq, opt ...RequestOption) (*IssuesListLabelsOnIssueResponse, error) {
	return IssuesListLabelsOnIssue(ctx, req, append(c, opt...)...)
}

/*
IssuesListLabelsOnIssueReq is request data for Client.IssuesListLabelsOnIssue

https://developer.github.com/v3/issues/labels/#list-labels-for-an-issue
*/
type IssuesListLabelsOnIssueReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListLabelsOnIssueReq) url() string {
	return r._url
}

func (r *IssuesListLabelsOnIssueReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesListLabelsOnIssueReq) method() string {
	return "GET"
}

func (r *IssuesListLabelsOnIssueReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListLabelsOnIssueReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListLabelsOnIssueReq) body() interface{} {
	return nil
}

func (r *IssuesListLabelsOnIssueReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListLabelsOnIssueReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListLabelsOnIssueReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListLabelsOnIssueReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListLabelsOnIssueReq) Rel(link RelName, resp *IssuesListLabelsOnIssueResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListLabelsOnIssueResponseBody is a response body for IssuesListLabelsOnIssue

https://developer.github.com/v3/issues/labels/#list-labels-for-an-issue
*/
type IssuesListLabelsOnIssueResponseBody []struct {
	components.Label
}

/*
IssuesListLabelsOnIssueResponse is a response for IssuesListLabelsOnIssue

https://developer.github.com/v3/issues/labels/#list-labels-for-an-issue
*/
type IssuesListLabelsOnIssueResponse struct {
	response
	request *IssuesListLabelsOnIssueReq
	Data    *IssuesListLabelsOnIssueResponseBody
}

/*
IssuesListMilestones performs requests for "issues/list-milestones"

List milestones.

  GET /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#list-milestones
*/
func IssuesListMilestones(ctx context.Context, req *IssuesListMilestonesReq, opt ...RequestOption) (*IssuesListMilestonesResponse, error) {
	if req == nil {
		req = new(IssuesListMilestonesReq)
	}
	resp := &IssuesListMilestonesResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesListMilestonesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesListMilestones performs requests for "issues/list-milestones"

List milestones.

  GET /repos/{owner}/{repo}/milestones

https://developer.github.com/v3/issues/milestones/#list-milestones
*/
func (c Client) IssuesListMilestones(ctx context.Context, req *IssuesListMilestonesReq, opt ...RequestOption) (*IssuesListMilestonesResponse, error) {
	return IssuesListMilestones(ctx, req, append(c, opt...)...)
}

/*
IssuesListMilestonesReq is request data for Client.IssuesListMilestones

https://developer.github.com/v3/issues/milestones/#list-milestones
*/
type IssuesListMilestonesReq struct {
	_url  string
	Owner string
	Repo  string

	// The state of the milestone. Either `open`, `closed`, or `all`.
	State *string

	// What to sort results by. Either `due_on` or `completeness`.
	Sort *string

	// The direction of the sort. Either `asc` or `desc`.
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *IssuesListMilestonesReq) url() string {
	return r._url
}

func (r *IssuesListMilestonesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones", r.Owner, r.Repo)
}

func (r *IssuesListMilestonesReq) method() string {
	return "GET"
}

func (r *IssuesListMilestonesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *IssuesListMilestonesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesListMilestonesReq) body() interface{} {
	return nil
}

func (r *IssuesListMilestonesReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesListMilestonesReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesListMilestonesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesListMilestonesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesListMilestonesReq) Rel(link RelName, resp *IssuesListMilestonesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesListMilestonesResponseBody is a response body for IssuesListMilestones

https://developer.github.com/v3/issues/milestones/#list-milestones
*/
type IssuesListMilestonesResponseBody []struct {
	components.Milestone
}

/*
IssuesListMilestonesResponse is a response for IssuesListMilestones

https://developer.github.com/v3/issues/milestones/#list-milestones
*/
type IssuesListMilestonesResponse struct {
	response
	request *IssuesListMilestonesReq
	Data    *IssuesListMilestonesResponseBody
}

/*
IssuesLock performs requests for "issues/lock"

Lock an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
func IssuesLock(ctx context.Context, req *IssuesLockReq, opt ...RequestOption) (*IssuesLockResponse, error) {
	if req == nil {
		req = new(IssuesLockReq)
	}
	resp := &IssuesLockResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesLock performs requests for "issues/lock"

Lock an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
func (c Client) IssuesLock(ctx context.Context, req *IssuesLockReq, opt ...RequestOption) (*IssuesLockResponse, error) {
	return IssuesLock(ctx, req, append(c, opt...)...)
}

/*
IssuesLockReq is request data for Client.IssuesLock

https://developer.github.com/v3/issues/#lock-an-issue
*/
type IssuesLockReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesLockReqBody

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *IssuesLockReq) url() string {
	return r._url
}

func (r *IssuesLockReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/lock", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesLockReq) method() string {
	return "PUT"
}

func (r *IssuesLockReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesLockReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"sailor-v": r.SailorVPreview}
	if allPreviews {
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesLockReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesLockReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesLockReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesLockReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *IssuesLockReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesLockReq) Rel(link RelName, resp *IssuesLockResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesLockReqBody is a request body for issues/lock

https://developer.github.com/v3/issues/#lock-an-issue
*/
type IssuesLockReqBody struct {

	/*
	   The reason for locking the issue or pull request conversation. Lock will fail if
	   you don't use one of these reasons:
	   \* `off-topic`
	   \* `too heated`
	   \* `resolved`
	   \* `spam`
	*/
	LockReason *string `json:"lock_reason,omitempty"`
}

/*
IssuesLockResponse is a response for IssuesLock

https://developer.github.com/v3/issues/#lock-an-issue
*/
type IssuesLockResponse struct {
	response
	request *IssuesLockReq
}

/*
IssuesRemoveAllLabels performs requests for "issues/remove-all-labels"

Remove all labels from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
func IssuesRemoveAllLabels(ctx context.Context, req *IssuesRemoveAllLabelsReq, opt ...RequestOption) (*IssuesRemoveAllLabelsResponse, error) {
	if req == nil {
		req = new(IssuesRemoveAllLabelsReq)
	}
	resp := &IssuesRemoveAllLabelsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesRemoveAllLabels performs requests for "issues/remove-all-labels"

Remove all labels from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
func (c Client) IssuesRemoveAllLabels(ctx context.Context, req *IssuesRemoveAllLabelsReq, opt ...RequestOption) (*IssuesRemoveAllLabelsResponse, error) {
	return IssuesRemoveAllLabels(ctx, req, append(c, opt...)...)
}

/*
IssuesRemoveAllLabelsReq is request data for Client.IssuesRemoveAllLabels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
type IssuesRemoveAllLabelsReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64
}

func (r *IssuesRemoveAllLabelsReq) url() string {
	return r._url
}

func (r *IssuesRemoveAllLabelsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesRemoveAllLabelsReq) method() string {
	return "DELETE"
}

func (r *IssuesRemoveAllLabelsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesRemoveAllLabelsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesRemoveAllLabelsReq) body() interface{} {
	return nil
}

func (r *IssuesRemoveAllLabelsReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesRemoveAllLabelsReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesRemoveAllLabelsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesRemoveAllLabelsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesRemoveAllLabelsReq) Rel(link RelName, resp *IssuesRemoveAllLabelsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesRemoveAllLabelsResponse is a response for IssuesRemoveAllLabels

https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
*/
type IssuesRemoveAllLabelsResponse struct {
	response
	request *IssuesRemoveAllLabelsReq
}

/*
IssuesRemoveAssignees performs requests for "issues/remove-assignees"

Remove assignees from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
func IssuesRemoveAssignees(ctx context.Context, req *IssuesRemoveAssigneesReq, opt ...RequestOption) (*IssuesRemoveAssigneesResponse, error) {
	if req == nil {
		req = new(IssuesRemoveAssigneesReq)
	}
	resp := &IssuesRemoveAssigneesResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesRemoveAssigneesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesRemoveAssignees performs requests for "issues/remove-assignees"

Remove assignees from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
func (c Client) IssuesRemoveAssignees(ctx context.Context, req *IssuesRemoveAssigneesReq, opt ...RequestOption) (*IssuesRemoveAssigneesResponse, error) {
	return IssuesRemoveAssignees(ctx, req, append(c, opt...)...)
}

/*
IssuesRemoveAssigneesReq is request data for Client.IssuesRemoveAssignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesRemoveAssigneesReqBody
}

func (r *IssuesRemoveAssigneesReq) url() string {
	return r._url
}

func (r *IssuesRemoveAssigneesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/assignees", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesRemoveAssigneesReq) method() string {
	return "DELETE"
}

func (r *IssuesRemoveAssigneesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesRemoveAssigneesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesRemoveAssigneesReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesRemoveAssigneesReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesRemoveAssigneesReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesRemoveAssigneesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *IssuesRemoveAssigneesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesRemoveAssigneesReq) Rel(link RelName, resp *IssuesRemoveAssigneesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesRemoveAssigneesReqBody is a request body for issues/remove-assignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesReqBody struct {

	/*
	   Usernames of assignees to remove from an issue. _NOTE: Only users with push
	   access can remove assignees from an issue. Assignees are silently ignored
	   otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`
}

/*
IssuesRemoveAssigneesResponseBody is a response body for IssuesRemoveAssignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesResponseBody struct {
	components.IssueSimple2
}

/*
IssuesRemoveAssigneesResponse is a response for IssuesRemoveAssignees

https://developer.github.com/v3/issues/assignees/#remove-assignees-from-an-issue
*/
type IssuesRemoveAssigneesResponse struct {
	response
	request *IssuesRemoveAssigneesReq
	Data    *IssuesRemoveAssigneesResponseBody
}

/*
IssuesRemoveLabel performs requests for "issues/remove-label"

Remove a label from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
func IssuesRemoveLabel(ctx context.Context, req *IssuesRemoveLabelReq, opt ...RequestOption) (*IssuesRemoveLabelResponse, error) {
	if req == nil {
		req = new(IssuesRemoveLabelReq)
	}
	resp := &IssuesRemoveLabelResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesRemoveLabelResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesRemoveLabel performs requests for "issues/remove-label"

Remove a label from an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
func (c Client) IssuesRemoveLabel(ctx context.Context, req *IssuesRemoveLabelReq, opt ...RequestOption) (*IssuesRemoveLabelResponse, error) {
	return IssuesRemoveLabel(ctx, req, append(c, opt...)...)
}

/*
IssuesRemoveLabelReq is request data for Client.IssuesRemoveLabel

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
type IssuesRemoveLabelReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64
	Name        string
}

func (r *IssuesRemoveLabelReq) url() string {
	return r._url
}

func (r *IssuesRemoveLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels/%v", r.Owner, r.Repo, r.IssueNumber, r.Name)
}

func (r *IssuesRemoveLabelReq) method() string {
	return "DELETE"
}

func (r *IssuesRemoveLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesRemoveLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesRemoveLabelReq) body() interface{} {
	return nil
}

func (r *IssuesRemoveLabelReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesRemoveLabelReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesRemoveLabelReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesRemoveLabelReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesRemoveLabelReq) Rel(link RelName, resp *IssuesRemoveLabelResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesRemoveLabelResponseBody is a response body for IssuesRemoveLabel

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
type IssuesRemoveLabelResponseBody []struct {
	components.Label
}

/*
IssuesRemoveLabelResponse is a response for IssuesRemoveLabel

https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
*/
type IssuesRemoveLabelResponse struct {
	response
	request *IssuesRemoveLabelReq
	Data    *IssuesRemoveLabelResponseBody
}

/*
IssuesSetLabels performs requests for "issues/set-labels"

Set labels for an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
func IssuesSetLabels(ctx context.Context, req *IssuesSetLabelsReq, opt ...RequestOption) (*IssuesSetLabelsResponse, error) {
	if req == nil {
		req = new(IssuesSetLabelsReq)
	}
	resp := &IssuesSetLabelsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesSetLabelsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesSetLabels performs requests for "issues/set-labels"

Set labels for an issue.

  PUT /repos/{owner}/{repo}/issues/{issue_number}/labels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
func (c Client) IssuesSetLabels(ctx context.Context, req *IssuesSetLabelsReq, opt ...RequestOption) (*IssuesSetLabelsResponse, error) {
	return IssuesSetLabels(ctx, req, append(c, opt...)...)
}

/*
IssuesSetLabelsReq is request data for Client.IssuesSetLabels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
type IssuesSetLabelsReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesSetLabelsReqBody
}

func (r *IssuesSetLabelsReq) url() string {
	return r._url
}

func (r *IssuesSetLabelsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/labels", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesSetLabelsReq) method() string {
	return "PUT"
}

func (r *IssuesSetLabelsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesSetLabelsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesSetLabelsReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesSetLabelsReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesSetLabelsReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesSetLabelsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *IssuesSetLabelsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesSetLabelsReq) Rel(link RelName, resp *IssuesSetLabelsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesSetLabelsReqBody is a request body for issues/set-labels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
type IssuesSetLabelsReqBody struct {

	/*
	   The names of the labels to add to the issue. You can pass an empty array to
	   remove all labels. **Note:** Alternatively, you can pass a single label as a
	   `string` or an `array` of labels directly, but GitHub recommends passing an
	   object with the `labels` key.
	*/
	Labels []string `json:"labels,omitempty"`
}

/*
IssuesSetLabelsResponseBody is a response body for IssuesSetLabels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
type IssuesSetLabelsResponseBody []struct {
	components.Label
}

/*
IssuesSetLabelsResponse is a response for IssuesSetLabels

https://developer.github.com/v3/issues/labels/#set-labels-for-an-issue
*/
type IssuesSetLabelsResponse struct {
	response
	request *IssuesSetLabelsReq
	Data    *IssuesSetLabelsResponseBody
}

/*
IssuesUnlock performs requests for "issues/unlock"

Unlock an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
func IssuesUnlock(ctx context.Context, req *IssuesUnlockReq, opt ...RequestOption) (*IssuesUnlockResponse, error) {
	if req == nil {
		req = new(IssuesUnlockReq)
	}
	resp := &IssuesUnlockResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUnlock performs requests for "issues/unlock"

Unlock an issue.

  DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
func (c Client) IssuesUnlock(ctx context.Context, req *IssuesUnlockReq, opt ...RequestOption) (*IssuesUnlockResponse, error) {
	return IssuesUnlock(ctx, req, append(c, opt...)...)
}

/*
IssuesUnlockReq is request data for Client.IssuesUnlock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
type IssuesUnlockReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64
}

func (r *IssuesUnlockReq) url() string {
	return r._url
}

func (r *IssuesUnlockReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v/lock", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesUnlockReq) method() string {
	return "DELETE"
}

func (r *IssuesUnlockReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUnlockReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUnlockReq) body() interface{} {
	return nil
}

func (r *IssuesUnlockReq) dataStatuses() []int {
	return []int{}
}

func (r *IssuesUnlockReq) validStatuses() []int {
	return []int{204}
}

func (r *IssuesUnlockReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *IssuesUnlockReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUnlockReq) Rel(link RelName, resp *IssuesUnlockResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesUnlockResponse is a response for IssuesUnlock

https://developer.github.com/v3/issues/#unlock-an-issue
*/
type IssuesUnlockResponse struct {
	response
	request *IssuesUnlockReq
}

/*
IssuesUpdate performs requests for "issues/update"

Update an issue.

  PATCH /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#update-an-issue
*/
func IssuesUpdate(ctx context.Context, req *IssuesUpdateReq, opt ...RequestOption) (*IssuesUpdateResponse, error) {
	if req == nil {
		req = new(IssuesUpdateReq)
	}
	resp := &IssuesUpdateResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesUpdateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUpdate performs requests for "issues/update"

Update an issue.

  PATCH /repos/{owner}/{repo}/issues/{issue_number}

https://developer.github.com/v3/issues/#update-an-issue
*/
func (c Client) IssuesUpdate(ctx context.Context, req *IssuesUpdateReq, opt ...RequestOption) (*IssuesUpdateResponse, error) {
	return IssuesUpdate(ctx, req, append(c, opt...)...)
}

/*
IssuesUpdateReq is request data for Client.IssuesUpdate

https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateReq struct {
	_url        string
	Owner       string
	Repo        string
	IssueNumber int64
	RequestBody IssuesUpdateReqBody
}

func (r *IssuesUpdateReq) url() string {
	return r._url
}

func (r *IssuesUpdateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/%v", r.Owner, r.Repo, r.IssueNumber)
}

func (r *IssuesUpdateReq) method() string {
	return "PATCH"
}

func (r *IssuesUpdateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUpdateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUpdateReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesUpdateReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *IssuesUpdateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUpdateReq) Rel(link RelName, resp *IssuesUpdateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesUpdateReqBody is a request body for issues/update

https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateReqBody struct {

	/*
	   Login for the user that this issue should be assigned to. **This field is
	   deprecated.**
	*/
	Assignee *string `json:"assignee,omitempty"`

	/*
	   Logins for Users to assign to this issue. Pass one or more user logins to
	   _replace_ the set of assignees on this Issue. Send an empty array (`[]`) to
	   clear all assignees from the Issue. _NOTE: Only users with push access can set
	   assignees for new issues. Assignees are silently dropped otherwise._
	*/
	Assignees []string `json:"assignees,omitempty"`

	// The contents of the issue.
	Body *string `json:"body,omitempty"`

	/*
	   Labels to associate with this issue. Pass one or more Labels to _replace_ the
	   set of Labels on this Issue. Send an empty array (`[]`) to clear all Labels from
	   the Issue. _NOTE: Only users with push access can set labels for issues. Labels
	   are silently dropped otherwise._
	*/
	Labels []string `json:"labels,omitempty"`

	/*
	   The `number` of the milestone to associate this issue with or `null` to remove
	   current. _NOTE: Only users with push access can set the milestone for issues.
	   The milestone is silently dropped otherwise._
	*/
	Milestone *int64 `json:"milestone,omitempty"`

	// State of the issue. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the issue.
	Title *string `json:"title,omitempty"`
}

/*
IssuesUpdateResponseBody is a response body for IssuesUpdate

https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateResponseBody struct {
	components.Issue
}

/*
IssuesUpdateResponse is a response for IssuesUpdate

https://developer.github.com/v3/issues/#update-an-issue
*/
type IssuesUpdateResponse struct {
	response
	request *IssuesUpdateReq
	Data    *IssuesUpdateResponseBody
}

/*
IssuesUpdateComment performs requests for "issues/update-comment"

Update an issue comment.

  PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
func IssuesUpdateComment(ctx context.Context, req *IssuesUpdateCommentReq, opt ...RequestOption) (*IssuesUpdateCommentResponse, error) {
	if req == nil {
		req = new(IssuesUpdateCommentReq)
	}
	resp := &IssuesUpdateCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesUpdateCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUpdateComment performs requests for "issues/update-comment"

Update an issue comment.

  PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
func (c Client) IssuesUpdateComment(ctx context.Context, req *IssuesUpdateCommentReq, opt ...RequestOption) (*IssuesUpdateCommentResponse, error) {
	return IssuesUpdateComment(ctx, req, append(c, opt...)...)
}

/*
IssuesUpdateCommentReq is request data for Client.IssuesUpdateComment

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
type IssuesUpdateCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	CommentId   int64
	RequestBody IssuesUpdateCommentReqBody
}

func (r *IssuesUpdateCommentReq) url() string {
	return r._url
}

func (r *IssuesUpdateCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/issues/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *IssuesUpdateCommentReq) method() string {
	return "PATCH"
}

func (r *IssuesUpdateCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUpdateCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUpdateCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesUpdateCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *IssuesUpdateCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUpdateCommentReq) Rel(link RelName, resp *IssuesUpdateCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesUpdateCommentReqBody is a request body for issues/update-comment

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
type IssuesUpdateCommentReqBody struct {

	// The contents of the comment.
	Body *string `json:"body"`
}

/*
IssuesUpdateCommentResponseBody is a response body for IssuesUpdateComment

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
type IssuesUpdateCommentResponseBody struct {
	components.IssueComment
}

/*
IssuesUpdateCommentResponse is a response for IssuesUpdateComment

https://developer.github.com/v3/issues/comments/#update-an-issue-comment
*/
type IssuesUpdateCommentResponse struct {
	response
	request *IssuesUpdateCommentReq
	Data    *IssuesUpdateCommentResponseBody
}

/*
IssuesUpdateLabel performs requests for "issues/update-label"

Update a label.

  PATCH /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#update-a-label
*/
func IssuesUpdateLabel(ctx context.Context, req *IssuesUpdateLabelReq, opt ...RequestOption) (*IssuesUpdateLabelResponse, error) {
	if req == nil {
		req = new(IssuesUpdateLabelReq)
	}
	resp := &IssuesUpdateLabelResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesUpdateLabelResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUpdateLabel performs requests for "issues/update-label"

Update a label.

  PATCH /repos/{owner}/{repo}/labels/{name}

https://developer.github.com/v3/issues/labels/#update-a-label
*/
func (c Client) IssuesUpdateLabel(ctx context.Context, req *IssuesUpdateLabelReq, opt ...RequestOption) (*IssuesUpdateLabelResponse, error) {
	return IssuesUpdateLabel(ctx, req, append(c, opt...)...)
}

/*
IssuesUpdateLabelReq is request data for Client.IssuesUpdateLabel

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelReq struct {
	_url        string
	Owner       string
	Repo        string
	Name        string
	RequestBody IssuesUpdateLabelReqBody
}

func (r *IssuesUpdateLabelReq) url() string {
	return r._url
}

func (r *IssuesUpdateLabelReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/labels/%v", r.Owner, r.Repo, r.Name)
}

func (r *IssuesUpdateLabelReq) method() string {
	return "PATCH"
}

func (r *IssuesUpdateLabelReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUpdateLabelReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUpdateLabelReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesUpdateLabelReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateLabelReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateLabelReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *IssuesUpdateLabelReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUpdateLabelReq) Rel(link RelName, resp *IssuesUpdateLabelResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesUpdateLabelReqBody is a request body for issues/update-label

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelReqBody struct {

	/*
	   The [hexadecimal color code](http://www.color-hex.com/) for the label, without
	   the leading `#`.
	*/
	Color *string `json:"color,omitempty"`

	// A short description of the label.
	Description *string `json:"description,omitempty"`

	/*
	   The new name of the label. Emoji can be added to label names, using either
	   native emoji or colon-style markup. For example, typing `:strawberry:` will
	   render the emoji
	   ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png
	   ":strawberry:"). For a full list of available emoji and codes, see
	   [emoji-cheat-sheet.com](http://emoji-cheat-sheet.com/).
	*/
	NewName *string `json:"new_name,omitempty"`
}

/*
IssuesUpdateLabelResponseBody is a response body for IssuesUpdateLabel

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelResponseBody struct {
	components.Label
}

/*
IssuesUpdateLabelResponse is a response for IssuesUpdateLabel

https://developer.github.com/v3/issues/labels/#update-a-label
*/
type IssuesUpdateLabelResponse struct {
	response
	request *IssuesUpdateLabelReq
	Data    *IssuesUpdateLabelResponseBody
}

/*
IssuesUpdateMilestone performs requests for "issues/update-milestone"

Update a milestone.

  PATCH /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
func IssuesUpdateMilestone(ctx context.Context, req *IssuesUpdateMilestoneReq, opt ...RequestOption) (*IssuesUpdateMilestoneResponse, error) {
	if req == nil {
		req = new(IssuesUpdateMilestoneReq)
	}
	resp := &IssuesUpdateMilestoneResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(IssuesUpdateMilestoneResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
IssuesUpdateMilestone performs requests for "issues/update-milestone"

Update a milestone.

  PATCH /repos/{owner}/{repo}/milestones/{milestone_number}

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
func (c Client) IssuesUpdateMilestone(ctx context.Context, req *IssuesUpdateMilestoneReq, opt ...RequestOption) (*IssuesUpdateMilestoneResponse, error) {
	return IssuesUpdateMilestone(ctx, req, append(c, opt...)...)
}

/*
IssuesUpdateMilestoneReq is request data for Client.IssuesUpdateMilestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneReq struct {
	_url            string
	Owner           string
	Repo            string
	MilestoneNumber int64
	RequestBody     IssuesUpdateMilestoneReqBody
}

func (r *IssuesUpdateMilestoneReq) url() string {
	return r._url
}

func (r *IssuesUpdateMilestoneReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/milestones/%v", r.Owner, r.Repo, r.MilestoneNumber)
}

func (r *IssuesUpdateMilestoneReq) method() string {
	return "PATCH"
}

func (r *IssuesUpdateMilestoneReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *IssuesUpdateMilestoneReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *IssuesUpdateMilestoneReq) body() interface{} {
	return r.RequestBody
}

func (r *IssuesUpdateMilestoneReq) dataStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateMilestoneReq) validStatuses() []int {
	return []int{200}
}

func (r *IssuesUpdateMilestoneReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *IssuesUpdateMilestoneReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *IssuesUpdateMilestoneReq) Rel(link RelName, resp *IssuesUpdateMilestoneResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
IssuesUpdateMilestoneReqBody is a request body for issues/update-milestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneReqBody struct {

	// A description of the milestone.
	Description *string `json:"description,omitempty"`

	/*
	   The milestone due date. This is a timestamp in [ISO
	   8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	DueOn *string `json:"due_on,omitempty"`

	// The state of the milestone. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the milestone.
	Title *string `json:"title,omitempty"`
}

/*
IssuesUpdateMilestoneResponseBody is a response body for IssuesUpdateMilestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneResponseBody struct {
	components.Milestone
}

/*
IssuesUpdateMilestoneResponse is a response for IssuesUpdateMilestone

https://developer.github.com/v3/issues/milestones/#update-a-milestone
*/
type IssuesUpdateMilestoneResponse struct {
	response
	request *IssuesUpdateMilestoneReq
	Data    *IssuesUpdateMilestoneResponseBody
}
