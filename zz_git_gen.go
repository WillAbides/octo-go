// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
GitCreateBlob performs requests for "git/create-blob"

Create a blob.

  POST /repos/{owner}/{repo}/git/blobs

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
func GitCreateBlob(ctx context.Context, req *GitCreateBlobReq, opt ...options.Option) (*GitCreateBlobResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GitCreateBlobReq)
	}
	resp := &GitCreateBlobResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ShortBlob{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitCreateBlob performs requests for "git/create-blob"

Create a blob.

  POST /repos/{owner}/{repo}/git/blobs

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
func (c Client) GitCreateBlob(ctx context.Context, req *GitCreateBlobReq, opt ...options.Option) (*GitCreateBlobResponse, error) {
	return GitCreateBlob(ctx, req, append(c, opt...)...)
}

/*
GitCreateBlobReq is request data for Client.GitCreateBlob

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
type GitCreateBlobReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody GitCreateBlobReqBody
}

// HTTPRequest builds an *http.Request
func (r *GitCreateBlobReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GitCreateBlobReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "git/create-blob",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/blobs", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitCreateBlobReq) Rel(link RelName, resp *GitCreateBlobResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitCreateBlobReqBody is a request body for git/create-blob

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
type GitCreateBlobReqBody struct {

	// The new blob's content.
	Content *string `json:"content"`

	// The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.
	Encoding *string `json:"encoding,omitempty"`
}

/*
GitCreateBlobResponse is a response for GitCreateBlob

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
type GitCreateBlobResponse struct {
	common.Response
	request *GitCreateBlobReq
	Data    components.ShortBlob
}

/*
GitCreateCommit performs requests for "git/create-commit"

Create a commit.

  POST /repos/{owner}/{repo}/git/commits

https://developer.github.com/v3/git/commits/#create-a-commit
*/
func GitCreateCommit(ctx context.Context, req *GitCreateCommitReq, opt ...options.Option) (*GitCreateCommitResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GitCreateCommitReq)
	}
	resp := &GitCreateCommitResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GitCommit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitCreateCommit performs requests for "git/create-commit"

Create a commit.

  POST /repos/{owner}/{repo}/git/commits

https://developer.github.com/v3/git/commits/#create-a-commit
*/
func (c Client) GitCreateCommit(ctx context.Context, req *GitCreateCommitReq, opt ...options.Option) (*GitCreateCommitResponse, error) {
	return GitCreateCommit(ctx, req, append(c, opt...)...)
}

/*
GitCreateCommitReq is request data for Client.GitCreateCommit

https://developer.github.com/v3/git/commits/#create-a-commit
*/
type GitCreateCommitReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody GitCreateCommitReqBody
}

// HTTPRequest builds an *http.Request
func (r *GitCreateCommitReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GitCreateCommitReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "git/create-commit",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/commits", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitCreateCommitReq) Rel(link RelName, resp *GitCreateCommitResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// GitCreateCommitReqBodyAuthor is a value for GitCreateCommitReqBody's Author field
type GitCreateCommitReqBodyAuthor struct {

	/*
	Indicates when this commit was authored (or committed). This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Date *string `json:"date,omitempty"`

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

// GitCreateCommitReqBodyCommitter is a value for GitCreateCommitReqBody's Committer field
type GitCreateCommitReqBodyCommitter struct {

	/*
	Indicates when this commit was authored (or committed). This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Date *string `json:"date,omitempty"`

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

/*
GitCreateCommitReqBody is a request body for git/create-commit

https://developer.github.com/v3/git/commits/#create-a-commit
*/
type GitCreateCommitReqBody struct {

	/*
	Information about the author of the commit. By default, the `author` will be the
	authenticated user and the current date. See the `author` and `committer` object
	below for details.
	*/
	Author *GitCreateCommitReqBodyAuthor `json:"author,omitempty"`

	/*
	Information about the person who is making the commit. By default, `committer`
	will use the information set in `author`. See the `author` and `committer`
	object below for details.
	*/
	Committer *GitCreateCommitReqBodyCommitter `json:"committer,omitempty"`

	// The commit message
	Message *string `json:"message"`

	/*
	The SHAs of the commits that were the parents of this commit. If omitted or
	empty, the commit will be written as a root commit. For a single parent, an
	array of one SHA should be provided; for a merge commit, an array of more than
	one should be provided.
	*/
	Parents []string `json:"parents,omitempty"`

	/*
	The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the
	commit. GitHub adds the signature to the `gpgsig` header of the created commit.
	For a commit signature to be verifiable by Git or GitHub, it must be an
	ASCII-armored detached PGP signature over the string commit as it would be
	written to the object database. To pass a `signature` parameter, you need to
	first manually create a valid PGP signature, which can be complicated. You may
	find it easier to [use the command
	line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create
	signed commits.
	*/
	Signature *string `json:"signature,omitempty"`

	// The SHA of the tree object this commit points to
	Tree *string `json:"tree"`
}

/*
GitCreateCommitResponse is a response for GitCreateCommit

https://developer.github.com/v3/git/commits/#create-a-commit
*/
type GitCreateCommitResponse struct {
	common.Response
	request *GitCreateCommitReq
	Data    components.GitCommit
}

/*
GitCreateRef performs requests for "git/create-ref"

Create a reference.

  POST /repos/{owner}/{repo}/git/refs

https://developer.github.com/v3/git/refs/#create-a-reference
*/
func GitCreateRef(ctx context.Context, req *GitCreateRefReq, opt ...options.Option) (*GitCreateRefResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GitCreateRefReq)
	}
	resp := &GitCreateRefResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GitRef{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitCreateRef performs requests for "git/create-ref"

Create a reference.

  POST /repos/{owner}/{repo}/git/refs

https://developer.github.com/v3/git/refs/#create-a-reference
*/
func (c Client) GitCreateRef(ctx context.Context, req *GitCreateRefReq, opt ...options.Option) (*GitCreateRefResponse, error) {
	return GitCreateRef(ctx, req, append(c, opt...)...)
}

/*
GitCreateRefReq is request data for Client.GitCreateRef

https://developer.github.com/v3/git/refs/#create-a-reference
*/
type GitCreateRefReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody GitCreateRefReqBody
}

// HTTPRequest builds an *http.Request
func (r *GitCreateRefReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GitCreateRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "git/create-ref",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/refs", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitCreateRefReq) Rel(link RelName, resp *GitCreateRefResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitCreateRefReqBody is a request body for git/create-ref

https://developer.github.com/v3/git/refs/#create-a-reference
*/
type GitCreateRefReqBody struct {
	Key *string `json:"key,omitempty"`

	/*
	The name of the fully qualified reference (ie: `refs/heads/master`). If it
	doesn't start with 'refs' and have at least two slashes, it will be rejected.
	*/
	Ref *string `json:"ref"`

	// The SHA1 value for this reference.
	Sha *string `json:"sha"`
}

/*
GitCreateRefResponse is a response for GitCreateRef

https://developer.github.com/v3/git/refs/#create-a-reference
*/
type GitCreateRefResponse struct {
	common.Response
	request *GitCreateRefReq
	Data    components.GitRef
}

/*
GitCreateTag performs requests for "git/create-tag"

Create a tag object.

  POST /repos/{owner}/{repo}/git/tags

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
func GitCreateTag(ctx context.Context, req *GitCreateTagReq, opt ...options.Option) (*GitCreateTagResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GitCreateTagReq)
	}
	resp := &GitCreateTagResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GitTag{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitCreateTag performs requests for "git/create-tag"

Create a tag object.

  POST /repos/{owner}/{repo}/git/tags

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
func (c Client) GitCreateTag(ctx context.Context, req *GitCreateTagReq, opt ...options.Option) (*GitCreateTagResponse, error) {
	return GitCreateTag(ctx, req, append(c, opt...)...)
}

/*
GitCreateTagReq is request data for Client.GitCreateTag

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
type GitCreateTagReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody GitCreateTagReqBody
}

// HTTPRequest builds an *http.Request
func (r *GitCreateTagReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GitCreateTagReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "git/create-tag",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/tags", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitCreateTagReq) Rel(link RelName, resp *GitCreateTagResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// GitCreateTagReqBodyTagger is a value for GitCreateTagReqBody's Tagger field
type GitCreateTagReqBodyTagger struct {

	/*
	When this object was tagged. This is a timestamp in [ISO
	8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Date *string `json:"date,omitempty"`

	// The email of the author of the tag
	Email *string `json:"email,omitempty"`

	// The name of the author of the tag
	Name *string `json:"name,omitempty"`
}

/*
GitCreateTagReqBody is a request body for git/create-tag

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
type GitCreateTagReqBody struct {

	// The tag message.
	Message *string `json:"message"`

	// The SHA of the git object this is tagging.
	Object *string `json:"object"`

	// The tag's name. This is typically a version (e.g., "v0.0.1").
	Tag *string `json:"tag"`

	// An object with information about the individual creating the tag.
	Tagger *GitCreateTagReqBodyTagger `json:"tagger,omitempty"`

	// The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`.
	Type *string `json:"type"`
}

/*
GitCreateTagResponse is a response for GitCreateTag

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
type GitCreateTagResponse struct {
	common.Response
	request *GitCreateTagReq
	Data    components.GitTag
}

/*
GitCreateTree performs requests for "git/create-tree"

Create a tree.

  POST /repos/{owner}/{repo}/git/trees

https://developer.github.com/v3/git/trees/#create-a-tree
*/
func GitCreateTree(ctx context.Context, req *GitCreateTreeReq, opt ...options.Option) (*GitCreateTreeResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GitCreateTreeReq)
	}
	resp := &GitCreateTreeResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GitTree{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitCreateTree performs requests for "git/create-tree"

Create a tree.

  POST /repos/{owner}/{repo}/git/trees

https://developer.github.com/v3/git/trees/#create-a-tree
*/
func (c Client) GitCreateTree(ctx context.Context, req *GitCreateTreeReq, opt ...options.Option) (*GitCreateTreeResponse, error) {
	return GitCreateTree(ctx, req, append(c, opt...)...)
}

/*
GitCreateTreeReq is request data for Client.GitCreateTree

https://developer.github.com/v3/git/trees/#create-a-tree
*/
type GitCreateTreeReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody GitCreateTreeReqBody
}

// HTTPRequest builds an *http.Request
func (r *GitCreateTreeReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GitCreateTreeReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "git/create-tree",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/trees", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitCreateTreeReq) Rel(link RelName, resp *GitCreateTreeResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// GitCreateTreeReqBodyTree is a value for GitCreateTreeReqBody's Tree field
type GitCreateTreeReqBodyTree struct {

	/*
	The content you want this file to have. GitHub will write this blob out and use
	that SHA for this entry. Use either this, or `tree.sha`.

	**Note:** Use either `tree.sha` or `content` to specify the contents of the
	entry. Using both `tree.sha` and `content` will return an error.
	*/
	Content *string `json:"content,omitempty"`

	/*
	The file mode; one of `100644` for file (blob), `100755` for executable (blob),
	`040000` for subdirectory (tree), `160000` for submodule (commit), or `120000`
	for a blob that specifies the path of a symlink.
	*/
	Mode *string `json:"mode,omitempty"`

	// The file referenced in the tree.
	Path *string `json:"path,omitempty"`

	/*
	The SHA1 checksum ID of the object in the tree. Also called `tree.sha`. If the
	value is `null` then the file will be deleted.

	**Note:** Use either `tree.sha` or `content` to specify the contents of the
	entry. Using both `tree.sha` and `content` will return an error.
	*/
	Sha *string `json:"sha,omitempty"`

	// Either `blob`, `tree`, or `commit`.
	Type *string `json:"type,omitempty"`
}

/*
GitCreateTreeReqBody is a request body for git/create-tree

https://developer.github.com/v3/git/trees/#create-a-tree
*/
type GitCreateTreeReqBody struct {

	/*
	The SHA1 of the tree you want to update with new data. If you don't set this,
	the commit will be created on top of everything; however, it will only contain
	your change, the rest of your files will show up as deleted.
	*/
	BaseTree *string `json:"base_tree,omitempty"`

	// Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure.
	Tree []GitCreateTreeReqBodyTree `json:"tree"`
}

/*
GitCreateTreeResponse is a response for GitCreateTree

https://developer.github.com/v3/git/trees/#create-a-tree
*/
type GitCreateTreeResponse struct {
	common.Response
	request *GitCreateTreeReq
	Data    components.GitTree
}

/*
GitDeleteRef performs requests for "git/delete-ref"

Delete a reference.

  DELETE /repos/{owner}/{repo}/git/refs/{ref}

https://developer.github.com/v3/git/refs/#delete-a-reference
*/
func GitDeleteRef(ctx context.Context, req *GitDeleteRefReq, opt ...options.Option) (*GitDeleteRefResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GitDeleteRefReq)
	}
	resp := &GitDeleteRefResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitDeleteRef performs requests for "git/delete-ref"

Delete a reference.

  DELETE /repos/{owner}/{repo}/git/refs/{ref}

https://developer.github.com/v3/git/refs/#delete-a-reference
*/
func (c Client) GitDeleteRef(ctx context.Context, req *GitDeleteRefReq, opt ...options.Option) (*GitDeleteRefResponse, error) {
	return GitDeleteRef(ctx, req, append(c, opt...)...)
}

/*
GitDeleteRefReq is request data for Client.GitDeleteRef

https://developer.github.com/v3/git/refs/#delete-a-reference
*/
type GitDeleteRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string
}

// HTTPRequest builds an *http.Request
func (r *GitDeleteRefReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GitDeleteRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "git/delete-ref",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/refs/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitDeleteRefReq) Rel(link RelName, resp *GitDeleteRefResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitDeleteRefResponse is a response for GitDeleteRef

https://developer.github.com/v3/git/refs/#delete-a-reference
*/
type GitDeleteRefResponse struct {
	common.Response
	request *GitDeleteRefReq
}

/*
GitGetBlob performs requests for "git/get-blob"

Get a blob.

  GET /repos/{owner}/{repo}/git/blobs/{file_sha}

https://developer.github.com/v3/git/blobs/#get-a-blob
*/
func GitGetBlob(ctx context.Context, req *GitGetBlobReq, opt ...options.Option) (*GitGetBlobResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GitGetBlobReq)
	}
	resp := &GitGetBlobResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Blob{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitGetBlob performs requests for "git/get-blob"

Get a blob.

  GET /repos/{owner}/{repo}/git/blobs/{file_sha}

https://developer.github.com/v3/git/blobs/#get-a-blob
*/
func (c Client) GitGetBlob(ctx context.Context, req *GitGetBlobReq, opt ...options.Option) (*GitGetBlobResponse, error) {
	return GitGetBlob(ctx, req, append(c, opt...)...)
}

/*
GitGetBlobReq is request data for Client.GitGetBlob

https://developer.github.com/v3/git/blobs/#get-a-blob
*/
type GitGetBlobReq struct {
	_url  string
	Owner string
	Repo  string

	// file_sha parameter
	FileSha string
}

// HTTPRequest builds an *http.Request
func (r *GitGetBlobReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GitGetBlobReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "git/get-blob",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/blobs/%v", r.Owner, r.Repo, r.FileSha),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitGetBlobReq) Rel(link RelName, resp *GitGetBlobResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitGetBlobResponse is a response for GitGetBlob

https://developer.github.com/v3/git/blobs/#get-a-blob
*/
type GitGetBlobResponse struct {
	common.Response
	request *GitGetBlobReq
	Data    components.Blob
}

/*
GitGetCommit performs requests for "git/get-commit"

Get a commit.

  GET /repos/{owner}/{repo}/git/commits/{commit_sha}

https://developer.github.com/v3/git/commits/#get-a-commit
*/
func GitGetCommit(ctx context.Context, req *GitGetCommitReq, opt ...options.Option) (*GitGetCommitResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GitGetCommitReq)
	}
	resp := &GitGetCommitResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GitCommit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitGetCommit performs requests for "git/get-commit"

Get a commit.

  GET /repos/{owner}/{repo}/git/commits/{commit_sha}

https://developer.github.com/v3/git/commits/#get-a-commit
*/
func (c Client) GitGetCommit(ctx context.Context, req *GitGetCommitReq, opt ...options.Option) (*GitGetCommitResponse, error) {
	return GitGetCommit(ctx, req, append(c, opt...)...)
}

/*
GitGetCommitReq is request data for Client.GitGetCommit

https://developer.github.com/v3/git/commits/#get-a-commit
*/
type GitGetCommitReq struct {
	_url  string
	Owner string
	Repo  string

	// commit_sha+ parameter
	CommitSha string
}

// HTTPRequest builds an *http.Request
func (r *GitGetCommitReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GitGetCommitReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "git/get-commit",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/commits/%v", r.Owner, r.Repo, r.CommitSha),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitGetCommitReq) Rel(link RelName, resp *GitGetCommitResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitGetCommitResponse is a response for GitGetCommit

https://developer.github.com/v3/git/commits/#get-a-commit
*/
type GitGetCommitResponse struct {
	common.Response
	request *GitGetCommitReq
	Data    components.GitCommit
}

/*
GitGetRef performs requests for "git/get-ref"

Get a reference.

  GET /repos/{owner}/{repo}/git/ref/{ref}

https://developer.github.com/v3/git/refs/#get-a-reference
*/
func GitGetRef(ctx context.Context, req *GitGetRefReq, opt ...options.Option) (*GitGetRefResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GitGetRefReq)
	}
	resp := &GitGetRefResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GitRef{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitGetRef performs requests for "git/get-ref"

Get a reference.

  GET /repos/{owner}/{repo}/git/ref/{ref}

https://developer.github.com/v3/git/refs/#get-a-reference
*/
func (c Client) GitGetRef(ctx context.Context, req *GitGetRefReq, opt ...options.Option) (*GitGetRefResponse, error) {
	return GitGetRef(ctx, req, append(c, opt...)...)
}

/*
GitGetRefReq is request data for Client.GitGetRef

https://developer.github.com/v3/git/refs/#get-a-reference
*/
type GitGetRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string
}

// HTTPRequest builds an *http.Request
func (r *GitGetRefReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GitGetRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "git/get-ref",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/ref/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitGetRefReq) Rel(link RelName, resp *GitGetRefResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitGetRefResponse is a response for GitGetRef

https://developer.github.com/v3/git/refs/#get-a-reference
*/
type GitGetRefResponse struct {
	common.Response
	request *GitGetRefReq
	Data    components.GitRef
}

/*
GitGetTag performs requests for "git/get-tag"

Get a tag.

  GET /repos/{owner}/{repo}/git/tags/{tag_sha}

https://developer.github.com/v3/git/tags/#get-a-tag
*/
func GitGetTag(ctx context.Context, req *GitGetTagReq, opt ...options.Option) (*GitGetTagResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GitGetTagReq)
	}
	resp := &GitGetTagResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GitTag{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitGetTag performs requests for "git/get-tag"

Get a tag.

  GET /repos/{owner}/{repo}/git/tags/{tag_sha}

https://developer.github.com/v3/git/tags/#get-a-tag
*/
func (c Client) GitGetTag(ctx context.Context, req *GitGetTagReq, opt ...options.Option) (*GitGetTagResponse, error) {
	return GitGetTag(ctx, req, append(c, opt...)...)
}

/*
GitGetTagReq is request data for Client.GitGetTag

https://developer.github.com/v3/git/tags/#get-a-tag
*/
type GitGetTagReq struct {
	_url  string
	Owner string
	Repo  string

	// tag_sha parameter
	TagSha string
}

// HTTPRequest builds an *http.Request
func (r *GitGetTagReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GitGetTagReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "git/get-tag",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/tags/%v", r.Owner, r.Repo, r.TagSha),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitGetTagReq) Rel(link RelName, resp *GitGetTagResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitGetTagResponse is a response for GitGetTag

https://developer.github.com/v3/git/tags/#get-a-tag
*/
type GitGetTagResponse struct {
	common.Response
	request *GitGetTagReq
	Data    components.GitTag
}

/*
GitGetTree performs requests for "git/get-tree"

Get a tree.

  GET /repos/{owner}/{repo}/git/trees/{tree_sha}

https://developer.github.com/v3/git/trees/#get-a-tree
*/
func GitGetTree(ctx context.Context, req *GitGetTreeReq, opt ...options.Option) (*GitGetTreeResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GitGetTreeReq)
	}
	resp := &GitGetTreeResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GitTree{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitGetTree performs requests for "git/get-tree"

Get a tree.

  GET /repos/{owner}/{repo}/git/trees/{tree_sha}

https://developer.github.com/v3/git/trees/#get-a-tree
*/
func (c Client) GitGetTree(ctx context.Context, req *GitGetTreeReq, opt ...options.Option) (*GitGetTreeResponse, error) {
	return GitGetTree(ctx, req, append(c, opt...)...)
}

/*
GitGetTreeReq is request data for Client.GitGetTree

https://developer.github.com/v3/git/trees/#get-a-tree
*/
type GitGetTreeReq struct {
	_url  string
	Owner string
	Repo  string

	// tree_sha parameter
	TreeSha string

	/*
	Setting this parameter to any value returns the objects or subtrees referenced
	by the tree specified in `:tree_sha`. For example, setting `recursive` to any of
	the following will enable returning objects or subtrees: `0`, `1`, `"true"`, and
	`"false"`. Omit this parameter to prevent recursively returning objects or
	subtrees.
	*/
	Recursive *string
}

// HTTPRequest builds an *http.Request
func (r *GitGetTreeReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GitGetTreeReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Recursive != nil {
		query.Set("recursive", *r.Recursive)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "git/get-tree",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/trees/%v", r.Owner, r.Repo, r.TreeSha),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitGetTreeReq) Rel(link RelName, resp *GitGetTreeResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitGetTreeResponse is a response for GitGetTree

https://developer.github.com/v3/git/trees/#get-a-tree
*/
type GitGetTreeResponse struct {
	common.Response
	request *GitGetTreeReq
	Data    components.GitTree
}

/*
GitListMatchingRefs performs requests for "git/list-matching-refs"

List matching references.

  GET /repos/{owner}/{repo}/git/matching-refs/{ref}

https://developer.github.com/v3/git/refs/#list-matching-references
*/
func GitListMatchingRefs(ctx context.Context, req *GitListMatchingRefsReq, opt ...options.Option) (*GitListMatchingRefsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GitListMatchingRefsReq)
	}
	resp := &GitListMatchingRefsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.GitRef{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitListMatchingRefs performs requests for "git/list-matching-refs"

List matching references.

  GET /repos/{owner}/{repo}/git/matching-refs/{ref}

https://developer.github.com/v3/git/refs/#list-matching-references
*/
func (c Client) GitListMatchingRefs(ctx context.Context, req *GitListMatchingRefsReq, opt ...options.Option) (*GitListMatchingRefsResponse, error) {
	return GitListMatchingRefs(ctx, req, append(c, opt...)...)
}

/*
GitListMatchingRefsReq is request data for Client.GitListMatchingRefs

https://developer.github.com/v3/git/refs/#list-matching-references
*/
type GitListMatchingRefsReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *GitListMatchingRefsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GitListMatchingRefsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "git/list-matching-refs",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/matching-refs/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitListMatchingRefsReq) Rel(link RelName, resp *GitListMatchingRefsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitListMatchingRefsResponse is a response for GitListMatchingRefs

https://developer.github.com/v3/git/refs/#list-matching-references
*/
type GitListMatchingRefsResponse struct {
	common.Response
	request *GitListMatchingRefsReq
	Data    []components.GitRef
}

/*
GitUpdateRef performs requests for "git/update-ref"

Update a reference.

  PATCH /repos/{owner}/{repo}/git/refs/{ref}

https://developer.github.com/v3/git/refs/#update-a-reference
*/
func GitUpdateRef(ctx context.Context, req *GitUpdateRefReq, opt ...options.Option) (*GitUpdateRefResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(GitUpdateRefReq)
	}
	resp := &GitUpdateRefResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GitRef{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitUpdateRef performs requests for "git/update-ref"

Update a reference.

  PATCH /repos/{owner}/{repo}/git/refs/{ref}

https://developer.github.com/v3/git/refs/#update-a-reference
*/
func (c Client) GitUpdateRef(ctx context.Context, req *GitUpdateRefReq, opt ...options.Option) (*GitUpdateRefResponse, error) {
	return GitUpdateRef(ctx, req, append(c, opt...)...)
}

/*
GitUpdateRefReq is request data for Client.GitUpdateRef

https://developer.github.com/v3/git/refs/#update-a-reference
*/
type GitUpdateRefReq struct {
	_url  string
	Owner string
	Repo  string

	// ref+ parameter
	Ref         string
	RequestBody GitUpdateRefReqBody
}

// HTTPRequest builds an *http.Request
func (r *GitUpdateRefReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *GitUpdateRefReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "git/update-ref",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/git/refs/%v", r.Owner, r.Repo, r.Ref),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitUpdateRefReq) Rel(link RelName, resp *GitUpdateRefResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitUpdateRefReqBody is a request body for git/update-ref

https://developer.github.com/v3/git/refs/#update-a-reference
*/
type GitUpdateRefReqBody struct {

	/*
	Indicates whether to force the update or to make sure the update is a
	fast-forward update. Leaving this out or setting it to `false` will make sure
	you're not overwriting work.
	*/
	Force *bool `json:"force,omitempty"`

	// The SHA1 value to set this reference to
	Sha *string `json:"sha"`
}

/*
GitUpdateRefResponse is a response for GitUpdateRef

https://developer.github.com/v3/git/refs/#update-a-reference
*/
type GitUpdateRefResponse struct {
	common.Response
	request *GitUpdateRefReq
	Data    components.GitRef
}
