// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
GitCreateBlob performs requests for "git/create-blob"

Create a blob.

  POST /repos/{owner}/{repo}/git/blobs

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
func (c *Client) GitCreateBlob(ctx context.Context, req *GitCreateBlobReq, opt ...RequestOption) (*GitCreateBlobResponse, error) {
	if req == nil {
		req = new(GitCreateBlobReq)
	}
	resp := &GitCreateBlobResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(GitCreateBlobResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitCreateBlobReq is request data for Client.GitCreateBlob

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
type GitCreateBlobReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody GitCreateBlobReqBody
}

func (r *GitCreateBlobReq) url() string {
	return r._url
}

func (r *GitCreateBlobReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/git/blobs", r.Owner, r.Repo)
}

func (r *GitCreateBlobReq) method() string {
	return "POST"
}

func (r *GitCreateBlobReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GitCreateBlobReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GitCreateBlobReq) body() interface{} {
	return r.RequestBody
}

func (r *GitCreateBlobReq) dataStatuses() []int {
	return []int{201}
}

func (r *GitCreateBlobReq) validStatuses() []int {
	return []int{201}
}

func (r *GitCreateBlobReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *GitCreateBlobReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitCreateBlobReq) Rel(link RelName, resp *GitCreateBlobResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitCreateBlobReqBody is a request body for git/create-blob

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
type GitCreateBlobReqBody struct {

	// The new blob's content.
	Content *string `json:"content"`

	/*
	   The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are
	   supported.
	*/
	Encoding *string `json:"encoding,omitempty"`
}

/*
GitCreateBlobResponseBody is a response body for GitCreateBlob

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
type GitCreateBlobResponseBody struct {
	components.ShortBlob
}

/*
GitCreateBlobResponse is a response for GitCreateBlob

https://developer.github.com/v3/git/blobs/#create-a-blob
*/
type GitCreateBlobResponse struct {
	response
	request *GitCreateBlobReq
	Data    *GitCreateBlobResponseBody
}

/*
GitCreateCommit performs requests for "git/create-commit"

Create a commit.

  POST /repos/{owner}/{repo}/git/commits

https://developer.github.com/v3/git/commits/#create-a-commit
*/
func (c *Client) GitCreateCommit(ctx context.Context, req *GitCreateCommitReq, opt ...RequestOption) (*GitCreateCommitResponse, error) {
	if req == nil {
		req = new(GitCreateCommitReq)
	}
	resp := &GitCreateCommitResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(GitCreateCommitResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitCreateCommitReq is request data for Client.GitCreateCommit

https://developer.github.com/v3/git/commits/#create-a-commit
*/
type GitCreateCommitReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody GitCreateCommitReqBody
}

func (r *GitCreateCommitReq) url() string {
	return r._url
}

func (r *GitCreateCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/git/commits", r.Owner, r.Repo)
}

func (r *GitCreateCommitReq) method() string {
	return "POST"
}

func (r *GitCreateCommitReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GitCreateCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GitCreateCommitReq) body() interface{} {
	return r.RequestBody
}

func (r *GitCreateCommitReq) dataStatuses() []int {
	return []int{201}
}

func (r *GitCreateCommitReq) validStatuses() []int {
	return []int{201}
}

func (r *GitCreateCommitReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *GitCreateCommitReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitCreateCommitReq) Rel(link RelName, resp *GitCreateCommitResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// GitCreateCommitReqBodyAuthor is a value for GitCreateCommitReqBody's Author field
type GitCreateCommitReqBodyAuthor struct {

	/*
	   Indicates when this commit was authored (or committed). This is a timestamp in
	   [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	   `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Date *string `json:"date,omitempty"`

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

// GitCreateCommitReqBodyCommitter is a value for GitCreateCommitReqBody's Committer field
type GitCreateCommitReqBodyCommitter struct {

	/*
	   Indicates when this commit was authored (or committed). This is a timestamp in
	   [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	   `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Date *string `json:"date,omitempty"`

	// The email of the author (or committer) of the commit
	Email *string `json:"email,omitempty"`

	// The name of the author (or committer) of the commit
	Name *string `json:"name,omitempty"`
}

/*
GitCreateCommitReqBody is a request body for git/create-commit

https://developer.github.com/v3/git/commits/#create-a-commit
*/
type GitCreateCommitReqBody struct {

	/*
	   Information about the author of the commit. By default, the `author` will be the
	   authenticated user and the current date. See the `author` and `committer` object
	   below for details.
	*/
	Author *GitCreateCommitReqBodyAuthor `json:"author,omitempty"`

	/*
	   Information about the person who is making the commit. By default, `committer`
	   will use the information set in `author`. See the `author` and `committer`
	   object below for details.
	*/
	Committer *GitCreateCommitReqBodyCommitter `json:"committer,omitempty"`

	// The commit message
	Message *string `json:"message"`

	/*
	   The SHAs of the commits that were the parents of this commit. If omitted or
	   empty, the commit will be written as a root commit. For a single parent, an
	   array of one SHA should be provided; for a merge commit, an array of more than
	   one should be provided.
	*/
	Parents []string `json:"parents"`

	/*
	   The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the
	   commit. GitHub adds the signature to the `gpgsig` header of the created commit.
	   For a commit signature to be verifiable by Git or GitHub, it must be an
	   ASCII-armored detached PGP signature over the string commit as it would be
	   written to the object database. To pass a `signature` parameter, you need to
	   first manually create a valid PGP signature, which can be complicated. You may
	   find it easier to [use the command
	   line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create
	   signed commits.
	*/
	Signature *string `json:"signature,omitempty"`

	// The SHA of the tree object this commit points to
	Tree *string `json:"tree"`
}

/*
GitCreateCommitResponseBody is a response body for GitCreateCommit

https://developer.github.com/v3/git/commits/#create-a-commit
*/
type GitCreateCommitResponseBody struct {
	components.GitCommit
}

/*
GitCreateCommitResponse is a response for GitCreateCommit

https://developer.github.com/v3/git/commits/#create-a-commit
*/
type GitCreateCommitResponse struct {
	response
	request *GitCreateCommitReq
	Data    *GitCreateCommitResponseBody
}

/*
GitCreateRef performs requests for "git/create-ref"

Create a reference.

  POST /repos/{owner}/{repo}/git/refs

https://developer.github.com/v3/git/refs/#create-a-reference
*/
func (c *Client) GitCreateRef(ctx context.Context, req *GitCreateRefReq, opt ...RequestOption) (*GitCreateRefResponse, error) {
	if req == nil {
		req = new(GitCreateRefReq)
	}
	resp := &GitCreateRefResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(GitCreateRefResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitCreateRefReq is request data for Client.GitCreateRef

https://developer.github.com/v3/git/refs/#create-a-reference
*/
type GitCreateRefReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody GitCreateRefReqBody
}

func (r *GitCreateRefReq) url() string {
	return r._url
}

func (r *GitCreateRefReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/git/refs", r.Owner, r.Repo)
}

func (r *GitCreateRefReq) method() string {
	return "POST"
}

func (r *GitCreateRefReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GitCreateRefReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GitCreateRefReq) body() interface{} {
	return r.RequestBody
}

func (r *GitCreateRefReq) dataStatuses() []int {
	return []int{201}
}

func (r *GitCreateRefReq) validStatuses() []int {
	return []int{201}
}

func (r *GitCreateRefReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *GitCreateRefReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitCreateRefReq) Rel(link RelName, resp *GitCreateRefResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitCreateRefReqBody is a request body for git/create-ref

https://developer.github.com/v3/git/refs/#create-a-reference
*/
type GitCreateRefReqBody struct {

	/*
	   The name of the fully qualified reference (ie: `refs/heads/master`). If it
	   doesn't start with 'refs' and have at least two slashes, it will be rejected.
	*/
	Ref *string `json:"ref"`

	// The SHA1 value for this reference.
	Sha *string `json:"sha"`
}

/*
GitCreateRefResponseBody is a response body for GitCreateRef

https://developer.github.com/v3/git/refs/#create-a-reference
*/
type GitCreateRefResponseBody struct {
	components.GitRef
}

/*
GitCreateRefResponse is a response for GitCreateRef

https://developer.github.com/v3/git/refs/#create-a-reference
*/
type GitCreateRefResponse struct {
	response
	request *GitCreateRefReq
	Data    *GitCreateRefResponseBody
}

/*
GitCreateTag performs requests for "git/create-tag"

Create a tag object.

  POST /repos/{owner}/{repo}/git/tags

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
func (c *Client) GitCreateTag(ctx context.Context, req *GitCreateTagReq, opt ...RequestOption) (*GitCreateTagResponse, error) {
	if req == nil {
		req = new(GitCreateTagReq)
	}
	resp := &GitCreateTagResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(GitCreateTagResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitCreateTagReq is request data for Client.GitCreateTag

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
type GitCreateTagReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody GitCreateTagReqBody
}

func (r *GitCreateTagReq) url() string {
	return r._url
}

func (r *GitCreateTagReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/git/tags", r.Owner, r.Repo)
}

func (r *GitCreateTagReq) method() string {
	return "POST"
}

func (r *GitCreateTagReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GitCreateTagReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GitCreateTagReq) body() interface{} {
	return r.RequestBody
}

func (r *GitCreateTagReq) dataStatuses() []int {
	return []int{201}
}

func (r *GitCreateTagReq) validStatuses() []int {
	return []int{201}
}

func (r *GitCreateTagReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *GitCreateTagReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitCreateTagReq) Rel(link RelName, resp *GitCreateTagResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// GitCreateTagReqBodyTagger is a value for GitCreateTagReqBody's Tagger field
type GitCreateTagReqBodyTagger struct {

	/*
	   When this object was tagged. This is a timestamp in [ISO
	   8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Date *string `json:"date,omitempty"`

	// The email of the author of the tag
	Email *string `json:"email,omitempty"`

	// The name of the author of the tag
	Name *string `json:"name,omitempty"`
}

/*
GitCreateTagReqBody is a request body for git/create-tag

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
type GitCreateTagReqBody struct {

	// The tag message.
	Message *string `json:"message"`

	// The SHA of the git object this is tagging.
	Object *string `json:"object"`

	// The tag's name. This is typically a version (e.g., "v0.0.1").
	Tag *string `json:"tag"`

	// An object with information about the individual creating the tag.
	Tagger *GitCreateTagReqBodyTagger `json:"tagger,omitempty"`

	/*
	   The type of the object we're tagging. Normally this is a `commit` but it can
	   also be a `tree` or a `blob`.
	*/
	Type *string `json:"type"`
}

/*
GitCreateTagResponseBody is a response body for GitCreateTag

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
type GitCreateTagResponseBody struct {
	components.GitTag
}

/*
GitCreateTagResponse is a response for GitCreateTag

https://developer.github.com/v3/git/tags/#create-a-tag-object
*/
type GitCreateTagResponse struct {
	response
	request *GitCreateTagReq
	Data    *GitCreateTagResponseBody
}

/*
GitCreateTree performs requests for "git/create-tree"

Create a tree.

  POST /repos/{owner}/{repo}/git/trees

https://developer.github.com/v3/git/trees/#create-a-tree
*/
func (c *Client) GitCreateTree(ctx context.Context, req *GitCreateTreeReq, opt ...RequestOption) (*GitCreateTreeResponse, error) {
	if req == nil {
		req = new(GitCreateTreeReq)
	}
	resp := &GitCreateTreeResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(GitCreateTreeResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitCreateTreeReq is request data for Client.GitCreateTree

https://developer.github.com/v3/git/trees/#create-a-tree
*/
type GitCreateTreeReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody GitCreateTreeReqBody
}

func (r *GitCreateTreeReq) url() string {
	return r._url
}

func (r *GitCreateTreeReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/git/trees", r.Owner, r.Repo)
}

func (r *GitCreateTreeReq) method() string {
	return "POST"
}

func (r *GitCreateTreeReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GitCreateTreeReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GitCreateTreeReq) body() interface{} {
	return r.RequestBody
}

func (r *GitCreateTreeReq) dataStatuses() []int {
	return []int{201}
}

func (r *GitCreateTreeReq) validStatuses() []int {
	return []int{201}
}

func (r *GitCreateTreeReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *GitCreateTreeReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitCreateTreeReq) Rel(link RelName, resp *GitCreateTreeResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// GitCreateTreeReqBodyTree is a value for GitCreateTreeReqBody's Tree field
type GitCreateTreeReqBodyTree struct {

	/*
	   The content you want this file to have. GitHub will write this blob out and use
	   that SHA for this entry. Use either this, or `tree.sha`.

	   **Note:** Use either `tree.sha` or `content` to specify the contents of the
	   entry. Using both `tree.sha` and `content` will return an error.
	*/
	Content *string `json:"content,omitempty"`

	/*
	   The file mode; one of `100644` for file (blob), `100755` for executable (blob),
	   `040000` for subdirectory (tree), `160000` for submodule (commit), or `120000`
	   for a blob that specifies the path of a symlink.
	*/
	Mode *string `json:"mode,omitempty"`

	// The file referenced in the tree.
	Path *string `json:"path,omitempty"`

	/*
	   The SHA1 checksum ID of the object in the tree. Also called `tree.sha`. If the
	   value is `null` then the file will be deleted.

	   **Note:** Use either `tree.sha` or `content` to specify the contents of the
	   entry. Using both `tree.sha` and `content` will return an error.
	*/
	Sha *string `json:"sha,omitempty"`

	// Either `blob`, `tree`, or `commit`.
	Type *string `json:"type,omitempty"`
}

/*
GitCreateTreeReqBody is a request body for git/create-tree

https://developer.github.com/v3/git/trees/#create-a-tree
*/
type GitCreateTreeReqBody struct {

	/*
	   The SHA1 of the tree you want to update with new data. If you don't set this,
	   the commit will be created on top of everything; however, it will only contain
	   your change, the rest of your files will show up as deleted.
	*/
	BaseTree *string `json:"base_tree,omitempty"`

	// Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure.
	Tree []GitCreateTreeReqBodyTree `json:"tree"`
}

/*
GitCreateTreeResponseBody is a response body for GitCreateTree

https://developer.github.com/v3/git/trees/#create-a-tree
*/
type GitCreateTreeResponseBody struct {
	components.GitTree
}

/*
GitCreateTreeResponse is a response for GitCreateTree

https://developer.github.com/v3/git/trees/#create-a-tree
*/
type GitCreateTreeResponse struct {
	response
	request *GitCreateTreeReq
	Data    *GitCreateTreeResponseBody
}

/*
GitDeleteRef performs requests for "git/delete-ref"

Delete a reference.

  DELETE /repos/{owner}/{repo}/git/refs/{ref}

https://developer.github.com/v3/git/refs/#delete-a-reference
*/
func (c *Client) GitDeleteRef(ctx context.Context, req *GitDeleteRefReq, opt ...RequestOption) (*GitDeleteRefResponse, error) {
	if req == nil {
		req = new(GitDeleteRefReq)
	}
	resp := &GitDeleteRefResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitDeleteRefReq is request data for Client.GitDeleteRef

https://developer.github.com/v3/git/refs/#delete-a-reference
*/
type GitDeleteRefReq struct {
	_url  string
	Owner string
	Repo  string
	Ref   string
}

func (r *GitDeleteRefReq) url() string {
	return r._url
}

func (r *GitDeleteRefReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/git/refs/%v", r.Owner, r.Repo, r.Ref)
}

func (r *GitDeleteRefReq) method() string {
	return "DELETE"
}

func (r *GitDeleteRefReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GitDeleteRefReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GitDeleteRefReq) body() interface{} {
	return nil
}

func (r *GitDeleteRefReq) dataStatuses() []int {
	return []int{}
}

func (r *GitDeleteRefReq) validStatuses() []int {
	return []int{204}
}

func (r *GitDeleteRefReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *GitDeleteRefReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitDeleteRefReq) Rel(link RelName, resp *GitDeleteRefResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitDeleteRefResponse is a response for GitDeleteRef

https://developer.github.com/v3/git/refs/#delete-a-reference
*/
type GitDeleteRefResponse struct {
	response
	request *GitDeleteRefReq
}

/*
GitGetBlob performs requests for "git/get-blob"

Get a blob.

  GET /repos/{owner}/{repo}/git/blobs/{file_sha}

https://developer.github.com/v3/git/blobs/#get-a-blob
*/
func (c *Client) GitGetBlob(ctx context.Context, req *GitGetBlobReq, opt ...RequestOption) (*GitGetBlobResponse, error) {
	if req == nil {
		req = new(GitGetBlobReq)
	}
	resp := &GitGetBlobResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(GitGetBlobResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitGetBlobReq is request data for Client.GitGetBlob

https://developer.github.com/v3/git/blobs/#get-a-blob
*/
type GitGetBlobReq struct {
	_url    string
	Owner   string
	Repo    string
	FileSha string
}

func (r *GitGetBlobReq) url() string {
	return r._url
}

func (r *GitGetBlobReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/git/blobs/%v", r.Owner, r.Repo, r.FileSha)
}

func (r *GitGetBlobReq) method() string {
	return "GET"
}

func (r *GitGetBlobReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GitGetBlobReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GitGetBlobReq) body() interface{} {
	return nil
}

func (r *GitGetBlobReq) dataStatuses() []int {
	return []int{200}
}

func (r *GitGetBlobReq) validStatuses() []int {
	return []int{200}
}

func (r *GitGetBlobReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *GitGetBlobReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitGetBlobReq) Rel(link RelName, resp *GitGetBlobResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitGetBlobResponseBody is a response body for GitGetBlob

https://developer.github.com/v3/git/blobs/#get-a-blob
*/
type GitGetBlobResponseBody struct {
	components.Blob
}

/*
GitGetBlobResponse is a response for GitGetBlob

https://developer.github.com/v3/git/blobs/#get-a-blob
*/
type GitGetBlobResponse struct {
	response
	request *GitGetBlobReq
	Data    *GitGetBlobResponseBody
}

/*
GitGetCommit performs requests for "git/get-commit"

Get a commit.

  GET /repos/{owner}/{repo}/git/commits/{commit_sha}

https://developer.github.com/v3/git/commits/#get-a-commit
*/
func (c *Client) GitGetCommit(ctx context.Context, req *GitGetCommitReq, opt ...RequestOption) (*GitGetCommitResponse, error) {
	if req == nil {
		req = new(GitGetCommitReq)
	}
	resp := &GitGetCommitResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(GitGetCommitResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitGetCommitReq is request data for Client.GitGetCommit

https://developer.github.com/v3/git/commits/#get-a-commit
*/
type GitGetCommitReq struct {
	_url      string
	Owner     string
	Repo      string
	CommitSha string
}

func (r *GitGetCommitReq) url() string {
	return r._url
}

func (r *GitGetCommitReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/git/commits/%v", r.Owner, r.Repo, r.CommitSha)
}

func (r *GitGetCommitReq) method() string {
	return "GET"
}

func (r *GitGetCommitReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GitGetCommitReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GitGetCommitReq) body() interface{} {
	return nil
}

func (r *GitGetCommitReq) dataStatuses() []int {
	return []int{200}
}

func (r *GitGetCommitReq) validStatuses() []int {
	return []int{200}
}

func (r *GitGetCommitReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *GitGetCommitReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitGetCommitReq) Rel(link RelName, resp *GitGetCommitResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitGetCommitResponseBody is a response body for GitGetCommit

https://developer.github.com/v3/git/commits/#get-a-commit
*/
type GitGetCommitResponseBody struct {
	components.GitCommit2
}

/*
GitGetCommitResponse is a response for GitGetCommit

https://developer.github.com/v3/git/commits/#get-a-commit
*/
type GitGetCommitResponse struct {
	response
	request *GitGetCommitReq
	Data    *GitGetCommitResponseBody
}

/*
GitGetRef performs requests for "git/get-ref"

Get a single reference.

  GET /repos/{owner}/{repo}/git/ref/{ref}

https://developer.github.com/v3/git/refs/#get-a-single-reference
*/
func (c *Client) GitGetRef(ctx context.Context, req *GitGetRefReq, opt ...RequestOption) (*GitGetRefResponse, error) {
	if req == nil {
		req = new(GitGetRefReq)
	}
	resp := &GitGetRefResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(GitGetRefResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitGetRefReq is request data for Client.GitGetRef

https://developer.github.com/v3/git/refs/#get-a-single-reference
*/
type GitGetRefReq struct {
	_url  string
	Owner string
	Repo  string
	Ref   string
}

func (r *GitGetRefReq) url() string {
	return r._url
}

func (r *GitGetRefReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/git/ref/%v", r.Owner, r.Repo, r.Ref)
}

func (r *GitGetRefReq) method() string {
	return "GET"
}

func (r *GitGetRefReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GitGetRefReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GitGetRefReq) body() interface{} {
	return nil
}

func (r *GitGetRefReq) dataStatuses() []int {
	return []int{200}
}

func (r *GitGetRefReq) validStatuses() []int {
	return []int{200}
}

func (r *GitGetRefReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *GitGetRefReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitGetRefReq) Rel(link RelName, resp *GitGetRefResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitGetRefResponseBody is a response body for GitGetRef

https://developer.github.com/v3/git/refs/#get-a-single-reference
*/
type GitGetRefResponseBody struct {
	components.GitRef
}

/*
GitGetRefResponse is a response for GitGetRef

https://developer.github.com/v3/git/refs/#get-a-single-reference
*/
type GitGetRefResponse struct {
	response
	request *GitGetRefReq
	Data    *GitGetRefResponseBody
}

/*
GitGetTag performs requests for "git/get-tag"

Get a tag.

  GET /repos/{owner}/{repo}/git/tags/{tag_sha}

https://developer.github.com/v3/git/tags/#get-a-tag
*/
func (c *Client) GitGetTag(ctx context.Context, req *GitGetTagReq, opt ...RequestOption) (*GitGetTagResponse, error) {
	if req == nil {
		req = new(GitGetTagReq)
	}
	resp := &GitGetTagResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(GitGetTagResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitGetTagReq is request data for Client.GitGetTag

https://developer.github.com/v3/git/tags/#get-a-tag
*/
type GitGetTagReq struct {
	_url   string
	Owner  string
	Repo   string
	TagSha string
}

func (r *GitGetTagReq) url() string {
	return r._url
}

func (r *GitGetTagReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/git/tags/%v", r.Owner, r.Repo, r.TagSha)
}

func (r *GitGetTagReq) method() string {
	return "GET"
}

func (r *GitGetTagReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GitGetTagReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GitGetTagReq) body() interface{} {
	return nil
}

func (r *GitGetTagReq) dataStatuses() []int {
	return []int{200}
}

func (r *GitGetTagReq) validStatuses() []int {
	return []int{200}
}

func (r *GitGetTagReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *GitGetTagReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitGetTagReq) Rel(link RelName, resp *GitGetTagResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitGetTagResponseBody is a response body for GitGetTag

https://developer.github.com/v3/git/tags/#get-a-tag
*/
type GitGetTagResponseBody struct {
	components.GitTag
}

/*
GitGetTagResponse is a response for GitGetTag

https://developer.github.com/v3/git/tags/#get-a-tag
*/
type GitGetTagResponse struct {
	response
	request *GitGetTagReq
	Data    *GitGetTagResponseBody
}

/*
GitGetTree performs requests for "git/get-tree"

Get a tree.

  GET /repos/{owner}/{repo}/git/trees/{tree_sha}

https://developer.github.com/v3/git/trees/#get-a-tree
*/
func (c *Client) GitGetTree(ctx context.Context, req *GitGetTreeReq, opt ...RequestOption) (*GitGetTreeResponse, error) {
	if req == nil {
		req = new(GitGetTreeReq)
	}
	resp := &GitGetTreeResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(GitGetTreeResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitGetTreeReq is request data for Client.GitGetTree

https://developer.github.com/v3/git/trees/#get-a-tree
*/
type GitGetTreeReq struct {
	_url string

	// owner parameter
	Owner string

	// repo parameter
	Repo string

	// tree_sha parameter
	TreeSha string

	// recursive parameter
	Recursive *int64
}

func (r *GitGetTreeReq) url() string {
	return r._url
}

func (r *GitGetTreeReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/git/trees/%v", r.Owner, r.Repo, r.TreeSha)
}

func (r *GitGetTreeReq) method() string {
	return "GET"
}

func (r *GitGetTreeReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Recursive != nil {
		query.Set("recursive", strconv.FormatInt(*r.Recursive, 10))
	}
	return query
}

func (r *GitGetTreeReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GitGetTreeReq) body() interface{} {
	return nil
}

func (r *GitGetTreeReq) dataStatuses() []int {
	return []int{200}
}

func (r *GitGetTreeReq) validStatuses() []int {
	return []int{200}
}

func (r *GitGetTreeReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *GitGetTreeReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitGetTreeReq) Rel(link RelName, resp *GitGetTreeResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitGetTreeResponseBody is a response body for GitGetTree

https://developer.github.com/v3/git/trees/#get-a-tree
*/
type GitGetTreeResponseBody struct {
	components.GitTree2
}

/*
GitGetTreeResponse is a response for GitGetTree

https://developer.github.com/v3/git/trees/#get-a-tree
*/
type GitGetTreeResponse struct {
	response
	request *GitGetTreeReq
	Data    *GitGetTreeResponseBody
}

/*
GitListMatchingRefs performs requests for "git/list-matching-refs"

List matching references.

  GET /repos/{owner}/{repo}/git/matching-refs/{ref}

https://developer.github.com/v3/git/refs/#list-matching-references
*/
func (c *Client) GitListMatchingRefs(ctx context.Context, req *GitListMatchingRefsReq, opt ...RequestOption) (*GitListMatchingRefsResponse, error) {
	if req == nil {
		req = new(GitListMatchingRefsReq)
	}
	resp := &GitListMatchingRefsResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(GitListMatchingRefsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitListMatchingRefsReq is request data for Client.GitListMatchingRefs

https://developer.github.com/v3/git/refs/#list-matching-references
*/
type GitListMatchingRefsReq struct {
	_url  string
	Owner string
	Repo  string
	Ref   string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *GitListMatchingRefsReq) url() string {
	return r._url
}

func (r *GitListMatchingRefsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/git/matching-refs/%v", r.Owner, r.Repo, r.Ref)
}

func (r *GitListMatchingRefsReq) method() string {
	return "GET"
}

func (r *GitListMatchingRefsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *GitListMatchingRefsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GitListMatchingRefsReq) body() interface{} {
	return nil
}

func (r *GitListMatchingRefsReq) dataStatuses() []int {
	return []int{200}
}

func (r *GitListMatchingRefsReq) validStatuses() []int {
	return []int{200}
}

func (r *GitListMatchingRefsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *GitListMatchingRefsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitListMatchingRefsReq) Rel(link RelName, resp *GitListMatchingRefsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitListMatchingRefsResponseBody is a response body for GitListMatchingRefs

https://developer.github.com/v3/git/refs/#list-matching-references
*/
type GitListMatchingRefsResponseBody []struct {
	components.GitRef
}

/*
GitListMatchingRefsResponse is a response for GitListMatchingRefs

https://developer.github.com/v3/git/refs/#list-matching-references
*/
type GitListMatchingRefsResponse struct {
	response
	request *GitListMatchingRefsReq
	Data    *GitListMatchingRefsResponseBody
}

/*
GitUpdateRef performs requests for "git/update-ref"

Update a reference.

  PATCH /repos/{owner}/{repo}/git/refs/{ref}

https://developer.github.com/v3/git/refs/#update-a-reference
*/
func (c *Client) GitUpdateRef(ctx context.Context, req *GitUpdateRefReq, opt ...RequestOption) (*GitUpdateRefResponse, error) {
	if req == nil {
		req = new(GitUpdateRefReq)
	}
	resp := &GitUpdateRefResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(GitUpdateRefResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
GitUpdateRefReq is request data for Client.GitUpdateRef

https://developer.github.com/v3/git/refs/#update-a-reference
*/
type GitUpdateRefReq struct {
	_url        string
	Owner       string
	Repo        string
	Ref         string
	RequestBody GitUpdateRefReqBody
}

func (r *GitUpdateRefReq) url() string {
	return r._url
}

func (r *GitUpdateRefReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/git/refs/%v", r.Owner, r.Repo, r.Ref)
}

func (r *GitUpdateRefReq) method() string {
	return "PATCH"
}

func (r *GitUpdateRefReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *GitUpdateRefReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *GitUpdateRefReq) body() interface{} {
	return r.RequestBody
}

func (r *GitUpdateRefReq) dataStatuses() []int {
	return []int{200}
}

func (r *GitUpdateRefReq) validStatuses() []int {
	return []int{200}
}

func (r *GitUpdateRefReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *GitUpdateRefReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *GitUpdateRefReq) Rel(link RelName, resp *GitUpdateRefResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
GitUpdateRefReqBody is a request body for git/update-ref

https://developer.github.com/v3/git/refs/#update-a-reference
*/
type GitUpdateRefReqBody struct {

	/*
	   Indicates whether to force the update or to make sure the update is a
	   fast-forward update. Leaving this out or setting it to `false` will make sure
	   you're not overwriting work.
	*/
	Force *bool `json:"force,omitempty"`

	// The SHA1 value to set this reference to
	Sha *string `json:"sha"`
}

/*
GitUpdateRefResponseBody is a response body for GitUpdateRef

https://developer.github.com/v3/git/refs/#update-a-reference
*/
type GitUpdateRefResponseBody struct {
	components.GitRef
}

/*
GitUpdateRefResponse is a response for GitUpdateRef

https://developer.github.com/v3/git/refs/#update-a-reference
*/
type GitUpdateRefResponse struct {
	response
	request *GitUpdateRefReq
	Data    *GitUpdateRefResponseBody
}
