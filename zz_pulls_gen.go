// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
PullsCheckIfMerged performs requests for "pulls/check-if-merged"

Check if a pull request has been merged.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#check-if-a-pull-request-has-been-merged
*/
func PullsCheckIfMerged(ctx context.Context, req *PullsCheckIfMergedReq, opt ...options.Option) (*PullsCheckIfMergedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsCheckIfMergedReq)
	}
	resp := &PullsCheckIfMergedResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCheckIfMerged performs requests for "pulls/check-if-merged"

Check if a pull request has been merged.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#check-if-a-pull-request-has-been-merged
*/
func (c Client) PullsCheckIfMerged(ctx context.Context, req *PullsCheckIfMergedReq, opt ...options.Option) (*PullsCheckIfMergedResponse, error) {
	return PullsCheckIfMerged(ctx, req, append(c, opt...)...)
}

/*
PullsCheckIfMergedReq is request data for Client.PullsCheckIfMerged

https://developer.github.com/v3/pulls/#check-if-a-pull-request-has-been-merged
*/
type PullsCheckIfMergedReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64
}

// HTTPRequest builds an *http.Request
func (r *PullsCheckIfMergedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsCheckIfMergedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "pulls/check-if-merged",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/merge", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCheckIfMergedReq) Rel(link string, resp *PullsCheckIfMergedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsCheckIfMergedResponse is a response for PullsCheckIfMerged

https://developer.github.com/v3/pulls/#check-if-a-pull-request-has-been-merged
*/
type PullsCheckIfMergedResponse struct {
	common.Response
	request *PullsCheckIfMergedReq
	Data    bool
}

/*
PullsCreate performs requests for "pulls/create"

Create a pull request.

  POST /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
func PullsCreate(ctx context.Context, req *PullsCreateReq, opt ...options.Option) (*PullsCreateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsCreateReq)
	}
	resp := &PullsCreateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequest{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCreate performs requests for "pulls/create"

Create a pull request.

  POST /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
func (c Client) PullsCreate(ctx context.Context, req *PullsCreateReq, opt ...options.Option) (*PullsCreateResponse, error) {
	return PullsCreate(ctx, req, append(c, opt...)...)
}

/*
PullsCreateReq is request data for Client.PullsCreate

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
type PullsCreateReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody PullsCreateReqBody

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request
func (r *PullsCreateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsCreateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"sailor-v"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "pulls/create",
		Previews:         map[string]bool{"sailor-v": r.SailorVPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCreateReq) Rel(link string, resp *PullsCreateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsCreateReqBody is a request body for pulls/create

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
type PullsCreateReqBody struct {

	/*
	The name of the branch you want the changes pulled into. This should be an
	existing branch on the current repository. You cannot submit a pull request to
	one repository that requests a merge to a base of another repository.
	*/
	Base *string `json:"base"`

	// The contents of the pull request.
	Body *string `json:"body,omitempty"`

	/*
	Indicates whether the pull request is a draft. See "[Draft Pull
	Requests](https://help.github.com/en/articles/about-pull-requests#draft-pull-requests)"
	in the GitHub Help documentation to learn more.
	*/
	Draft *bool `json:"draft,omitempty"`

	/*
	The name of the branch where your changes are implemented. For cross-repository
	pull requests in the same network, namespace `head` with a user like this:
	`username:branch`.
	*/
	Head  *string `json:"head"`
	Issue *int64  `json:"issue,omitempty"`

	/*
	Indicates whether [maintainers can
	modify](https://help.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/)
	the pull request.
	*/
	MaintainerCanModify *bool `json:"maintainer_can_modify,omitempty"`

	// The title of the new pull request.
	Title *string `json:"title,omitempty"`
}

/*
PullsCreateResponse is a response for PullsCreate

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
type PullsCreateResponse struct {
	common.Response
	request *PullsCreateReq
	Data    components.PullRequest
}

/*
PullsCreateReplyForReviewComment performs requests for "pulls/create-reply-for-review-comment"

Create a reply for a review comment.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
func PullsCreateReplyForReviewComment(ctx context.Context, req *PullsCreateReplyForReviewCommentReq, opt ...options.Option) (*PullsCreateReplyForReviewCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsCreateReplyForReviewCommentReq)
	}
	resp := &PullsCreateReplyForReviewCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequestReviewComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCreateReplyForReviewComment performs requests for "pulls/create-reply-for-review-comment"

Create a reply for a review comment.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
func (c Client) PullsCreateReplyForReviewComment(ctx context.Context, req *PullsCreateReplyForReviewCommentReq, opt ...options.Option) (*PullsCreateReplyForReviewCommentResponse, error) {
	return PullsCreateReplyForReviewComment(ctx, req, append(c, opt...)...)
}

/*
PullsCreateReplyForReviewCommentReq is request data for Client.PullsCreateReplyForReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
type PullsCreateReplyForReviewCommentReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// comment_id parameter
	CommentId   int64
	RequestBody PullsCreateReplyForReviewCommentReqBody
}

// HTTPRequest builds an *http.Request
func (r *PullsCreateReplyForReviewCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsCreateReplyForReviewCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "pulls/create-reply-for-review-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/comments/%v/replies", r.Owner, r.Repo, r.PullNumber, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCreateReplyForReviewCommentReq) Rel(link string, resp *PullsCreateReplyForReviewCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsCreateReplyForReviewCommentReqBody is a request body for pulls/create-reply-for-review-comment

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
type PullsCreateReplyForReviewCommentReqBody struct {

	// The text of the review comment.
	Body *string `json:"body"`
}

/*
PullsCreateReplyForReviewCommentResponse is a response for PullsCreateReplyForReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
type PullsCreateReplyForReviewCommentResponse struct {
	common.Response
	request *PullsCreateReplyForReviewCommentReq
	Data    components.PullRequestReviewComment
}

/*
PullsCreateReview performs requests for "pulls/create-review"

Create a review for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
func PullsCreateReview(ctx context.Context, req *PullsCreateReviewReq, opt ...options.Option) (*PullsCreateReviewResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsCreateReviewReq)
	}
	resp := &PullsCreateReviewResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequestReview{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCreateReview performs requests for "pulls/create-review"

Create a review for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
func (c Client) PullsCreateReview(ctx context.Context, req *PullsCreateReviewReq, opt ...options.Option) (*PullsCreateReviewResponse, error) {
	return PullsCreateReview(ctx, req, append(c, opt...)...)
}

/*
PullsCreateReviewReq is request data for Client.PullsCreateReview

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
type PullsCreateReviewReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsCreateReviewReqBody
}

// HTTPRequest builds an *http.Request
func (r *PullsCreateReviewReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsCreateReviewReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "pulls/create-review",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCreateReviewReq) Rel(link string, resp *PullsCreateReviewResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// PullsCreateReviewReqBodyComments is a value for PullsCreateReviewReqBody's Comments field
type PullsCreateReviewReqBodyComments struct {

	// Text of the review comment.
	Body *string `json:"body"`
	Line *int64  `json:"line,omitempty"`

	// The relative path to the file that necessitates a review comment.
	Path *string `json:"path"`

	/*
	The position in the diff where you want to add a review comment. Note this value
	is not the same as the line number in the file. For help finding the position
	value, read the note below.
	*/
	Position  *int64  `json:"position,omitempty"`
	Side      *string `json:"side,omitempty"`
	StartLine *int64  `json:"start_line,omitempty"`
	StartSide *string `json:"start_side,omitempty"`
}

/*
PullsCreateReviewReqBody is a request body for pulls/create-review

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
type PullsCreateReviewReqBody struct {

	/*
	**Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event`
	parameter. The body text of the pull request review.
	*/
	Body *string `json:"body,omitempty"`

	// Use the following table to specify the location, destination, and contents of the draft review comment.
	Comments []PullsCreateReviewReqBodyComments `json:"comments,omitempty"`

	/*
	The SHA of the commit that needs a review. Not using the latest commit SHA may
	render your review comment outdated if a subsequent commit modifies the line you
	specify as the `position`. Defaults to the most recent commit in the pull
	request when you do not specify a value.
	*/
	CommitId *string `json:"commit_id,omitempty"`

	/*
	The review action you want to perform. The review actions include: `APPROVE`,
	`REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review
	action state to `PENDING`, which means you will need to [submit the pull request
	review](https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request)
	when you are ready.
	*/
	Event *string `json:"event,omitempty"`
}

/*
PullsCreateReviewResponse is a response for PullsCreateReview

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
type PullsCreateReviewResponse struct {
	common.Response
	request *PullsCreateReviewReq
	Data    components.PullRequestReview
}

/*
PullsCreateReviewComment performs requests for "pulls/create-review-comment"

Create a review comment for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
func PullsCreateReviewComment(ctx context.Context, req *PullsCreateReviewCommentReq, opt ...options.Option) (*PullsCreateReviewCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsCreateReviewCommentReq)
	}
	resp := &PullsCreateReviewCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequestReviewComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCreateReviewComment performs requests for "pulls/create-review-comment"

Create a review comment for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
func (c Client) PullsCreateReviewComment(ctx context.Context, req *PullsCreateReviewCommentReq, opt ...options.Option) (*PullsCreateReviewCommentResponse, error) {
	return PullsCreateReviewComment(ctx, req, append(c, opt...)...)
}

/*
PullsCreateReviewCommentReq is request data for Client.PullsCreateReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
type PullsCreateReviewCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsCreateReviewCommentReqBody

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool
}

// HTTPRequest builds an *http.Request
func (r *PullsCreateReviewCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsCreateReviewCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"comfort-fade"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "pulls/create-review-comment",
		Previews:         map[string]bool{"comfort-fade": r.ComfortFadePreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/comments", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCreateReviewCommentReq) Rel(link string, resp *PullsCreateReviewCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsCreateReviewCommentReqBody is a request body for pulls/create-review-comment

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
type PullsCreateReviewCommentReqBody struct {

	// The text of the review comment.
	Body *string `json:"body"`

	/*
	The SHA of the commit needing a comment. Not using the latest commit SHA may
	render your comment outdated if a subsequent commit modifies the line you
	specify as the `position`.
	*/
	CommitId  *string `json:"commit_id,omitempty"`
	InReplyTo *int64  `json:"in_reply_to,omitempty"`

	/*
	**Required with `comfort-fade` preview**. The line of the blob in the pull
	request diff that the comment applies to. For a multi-line comment, the last
	line of the range that your comment applies to.
	*/
	Line *int64 `json:"line,omitempty"`

	// The relative path to the file that necessitates a comment.
	Path *string `json:"path"`

	/*
	**Required without `comfort-fade` preview**. The position in the diff where you
	want to add a review comment. Note this value is not the same as the line number
	in the file. For help finding the position value, read the note above.
	*/
	Position *int64 `json:"position,omitempty"`

	/*
	**Required with `comfort-fade` preview**. In a split diff view, the side of the
	diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use
	`LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear
	in green or unchanged lines that appear in white and are shown for context. For
	a multi-line comment, side represents whether the last line of the comment range
	is a deletion or addition. For more information, see "[Diff view
	options](https://help.github.com/en/articles/about-comparing-branches-in-pull-requests#diff-view-options)"
	in the GitHub Help documentation.
	*/
	Side *string `json:"side,omitempty"`

	/*
	**Required when using multi-line comments**. To create multi-line comments, you
	must use the `comfort-fade` preview header. The `start_line` is the first line
	in the pull request diff that your multi-line comment applies to. To learn more
	about multi-line comments, see "[Commenting on a pull
	request](https://help.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)"
	in the GitHub Help documentation.
	*/
	StartLine *int64 `json:"start_line,omitempty"`

	/*
	**Required when using multi-line comments**. To create multi-line comments, you
	must use the `comfort-fade` preview header. The `start_side` is the starting
	side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn
	more about multi-line comments, see "[Commenting on a pull
	request](https://help.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)"
	in the GitHub Help documentation. See `side` in this table for additional
	context.
	*/
	StartSide *string `json:"start_side,omitempty"`
}

/*
PullsCreateReviewCommentResponse is a response for PullsCreateReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
type PullsCreateReviewCommentResponse struct {
	common.Response
	request *PullsCreateReviewCommentReq
	Data    components.PullRequestReviewComment
}

/*
PullsDeletePendingReview performs requests for "pulls/delete-pending-review"

Delete a pending review for a pull request.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review-for-a-pull-request
*/
func PullsDeletePendingReview(ctx context.Context, req *PullsDeletePendingReviewReq, opt ...options.Option) (*PullsDeletePendingReviewResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsDeletePendingReviewReq)
	}
	resp := &PullsDeletePendingReviewResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequestReview{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsDeletePendingReview performs requests for "pulls/delete-pending-review"

Delete a pending review for a pull request.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review-for-a-pull-request
*/
func (c Client) PullsDeletePendingReview(ctx context.Context, req *PullsDeletePendingReviewReq, opt ...options.Option) (*PullsDeletePendingReviewResponse, error) {
	return PullsDeletePendingReview(ctx, req, append(c, opt...)...)
}

/*
PullsDeletePendingReviewReq is request data for Client.PullsDeletePendingReview

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review-for-a-pull-request
*/
type PullsDeletePendingReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// review_id parameter
	ReviewId int64
}

// HTTPRequest builds an *http.Request
func (r *PullsDeletePendingReviewReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsDeletePendingReviewReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "DELETE",
		OperationID:      "pulls/delete-pending-review",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v", r.Owner, r.Repo, r.PullNumber, r.ReviewId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsDeletePendingReviewReq) Rel(link string, resp *PullsDeletePendingReviewResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsDeletePendingReviewResponse is a response for PullsDeletePendingReview

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review-for-a-pull-request
*/
type PullsDeletePendingReviewResponse struct {
	common.Response
	request *PullsDeletePendingReviewReq
	Data    components.PullRequestReview
}

/*
PullsDeleteReviewComment performs requests for "pulls/delete-review-comment"

Delete a review comment for a pull request.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#delete-a-review-comment-for-a-pull-request
*/
func PullsDeleteReviewComment(ctx context.Context, req *PullsDeleteReviewCommentReq, opt ...options.Option) (*PullsDeleteReviewCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsDeleteReviewCommentReq)
	}
	resp := &PullsDeleteReviewCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsDeleteReviewComment performs requests for "pulls/delete-review-comment"

Delete a review comment for a pull request.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#delete-a-review-comment-for-a-pull-request
*/
func (c Client) PullsDeleteReviewComment(ctx context.Context, req *PullsDeleteReviewCommentReq, opt ...options.Option) (*PullsDeleteReviewCommentResponse, error) {
	return PullsDeleteReviewComment(ctx, req, append(c, opt...)...)
}

/*
PullsDeleteReviewCommentReq is request data for Client.PullsDeleteReviewComment

https://developer.github.com/v3/pulls/comments/#delete-a-review-comment-for-a-pull-request
*/
type PullsDeleteReviewCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64
}

// HTTPRequest builds an *http.Request
func (r *PullsDeleteReviewCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsDeleteReviewCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "pulls/delete-review-comment",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsDeleteReviewCommentReq) Rel(link string, resp *PullsDeleteReviewCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsDeleteReviewCommentResponse is a response for PullsDeleteReviewComment

https://developer.github.com/v3/pulls/comments/#delete-a-review-comment-for-a-pull-request
*/
type PullsDeleteReviewCommentResponse struct {
	common.Response
	request *PullsDeleteReviewCommentReq
	Data    bool
}

/*
PullsDismissReview performs requests for "pulls/dismiss-review"

Dismiss a review for a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
func PullsDismissReview(ctx context.Context, req *PullsDismissReviewReq, opt ...options.Option) (*PullsDismissReviewResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsDismissReviewReq)
	}
	resp := &PullsDismissReviewResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequestReview{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsDismissReview performs requests for "pulls/dismiss-review"

Dismiss a review for a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
func (c Client) PullsDismissReview(ctx context.Context, req *PullsDismissReviewReq, opt ...options.Option) (*PullsDismissReviewResponse, error) {
	return PullsDismissReview(ctx, req, append(c, opt...)...)
}

/*
PullsDismissReviewReq is request data for Client.PullsDismissReview

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
type PullsDismissReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// review_id parameter
	ReviewId    int64
	RequestBody PullsDismissReviewReqBody
}

// HTTPRequest builds an *http.Request
func (r *PullsDismissReviewReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsDismissReviewReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "pulls/dismiss-review",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v/dismissals", r.Owner, r.Repo, r.PullNumber, r.ReviewId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsDismissReviewReq) Rel(link string, resp *PullsDismissReviewResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsDismissReviewReqBody is a request body for pulls/dismiss-review

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
type PullsDismissReviewReqBody struct {
	Event *string `json:"event,omitempty"`

	// The message for the pull request review dismissal
	Message *string `json:"message"`
}

/*
PullsDismissReviewResponse is a response for PullsDismissReview

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
type PullsDismissReviewResponse struct {
	common.Response
	request *PullsDismissReviewReq
	Data    components.PullRequestReview
}

/*
PullsGet performs requests for "pulls/get"

Get a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#get-a-pull-request
*/
func PullsGet(ctx context.Context, req *PullsGetReq, opt ...options.Option) (*PullsGetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsGetReq)
	}
	resp := &PullsGetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequest{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsGet performs requests for "pulls/get"

Get a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#get-a-pull-request
*/
func (c Client) PullsGet(ctx context.Context, req *PullsGetReq, opt ...options.Option) (*PullsGetResponse, error) {
	return PullsGet(ctx, req, append(c, opt...)...)
}

/*
PullsGetReq is request data for Client.PullsGet

https://developer.github.com/v3/pulls/#get-a-pull-request
*/
type PullsGetReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request
func (r *PullsGetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsGetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"sailor-v"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "pulls/get",
		Previews:         map[string]bool{"sailor-v": r.SailorVPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsGetReq) Rel(link string, resp *PullsGetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsGetResponse is a response for PullsGet

https://developer.github.com/v3/pulls/#get-a-pull-request
*/
type PullsGetResponse struct {
	common.Response
	request *PullsGetReq
	Data    components.PullRequest
}

/*
PullsGetReview performs requests for "pulls/get-review"

Get a review for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#get-a-review-for-a-pull-request
*/
func PullsGetReview(ctx context.Context, req *PullsGetReviewReq, opt ...options.Option) (*PullsGetReviewResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsGetReviewReq)
	}
	resp := &PullsGetReviewResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequestReview{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsGetReview performs requests for "pulls/get-review"

Get a review for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#get-a-review-for-a-pull-request
*/
func (c Client) PullsGetReview(ctx context.Context, req *PullsGetReviewReq, opt ...options.Option) (*PullsGetReviewResponse, error) {
	return PullsGetReview(ctx, req, append(c, opt...)...)
}

/*
PullsGetReviewReq is request data for Client.PullsGetReview

https://developer.github.com/v3/pulls/reviews/#get-a-review-for-a-pull-request
*/
type PullsGetReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// review_id parameter
	ReviewId int64
}

// HTTPRequest builds an *http.Request
func (r *PullsGetReviewReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsGetReviewReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "pulls/get-review",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v", r.Owner, r.Repo, r.PullNumber, r.ReviewId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsGetReviewReq) Rel(link string, resp *PullsGetReviewResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsGetReviewResponse is a response for PullsGetReview

https://developer.github.com/v3/pulls/reviews/#get-a-review-for-a-pull-request
*/
type PullsGetReviewResponse struct {
	common.Response
	request *PullsGetReviewReq
	Data    components.PullRequestReview
}

/*
PullsGetReviewComment performs requests for "pulls/get-review-comment"

Get a review comment for a pull request.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#get-a-review-comment-for-a-pull-request
*/
func PullsGetReviewComment(ctx context.Context, req *PullsGetReviewCommentReq, opt ...options.Option) (*PullsGetReviewCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsGetReviewCommentReq)
	}
	resp := &PullsGetReviewCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequestReviewComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsGetReviewComment performs requests for "pulls/get-review-comment"

Get a review comment for a pull request.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#get-a-review-comment-for-a-pull-request
*/
func (c Client) PullsGetReviewComment(ctx context.Context, req *PullsGetReviewCommentReq, opt ...options.Option) (*PullsGetReviewCommentResponse, error) {
	return PullsGetReviewComment(ctx, req, append(c, opt...)...)
}

/*
PullsGetReviewCommentReq is request data for Client.PullsGetReviewComment

https://developer.github.com/v3/pulls/comments/#get-a-review-comment-for-a-pull-request
*/
type PullsGetReviewCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId int64

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *PullsGetReviewCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsGetReviewCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"comfort-fade", "squirrel-girl"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "pulls/get-review-comment",
		Previews: map[string]bool{
			"comfort-fade":  r.ComfortFadePreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsGetReviewCommentReq) Rel(link string, resp *PullsGetReviewCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsGetReviewCommentResponse is a response for PullsGetReviewComment

https://developer.github.com/v3/pulls/comments/#get-a-review-comment-for-a-pull-request
*/
type PullsGetReviewCommentResponse struct {
	common.Response
	request *PullsGetReviewCommentReq
	Data    components.PullRequestReviewComment
}

/*
PullsList performs requests for "pulls/list"

List pull requests.

  GET /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#list-pull-requests
*/
func PullsList(ctx context.Context, req *PullsListReq, opt ...options.Option) (*PullsListResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsListReq)
	}
	resp := &PullsListResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.PullRequestSimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsList performs requests for "pulls/list"

List pull requests.

  GET /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#list-pull-requests
*/
func (c Client) PullsList(ctx context.Context, req *PullsListReq, opt ...options.Option) (*PullsListResponse, error) {
	return PullsList(ctx, req, append(c, opt...)...)
}

/*
PullsListReq is request data for Client.PullsList

https://developer.github.com/v3/pulls/#list-pull-requests
*/
type PullsListReq struct {
	_url  string
	Owner string
	Repo  string

	// Either `open`, `closed`, or `all` to filter by state.
	State *string

	/*
	Filter pulls by head user or head organization and branch name in the format of
	`user:ref-name` or `organization:ref-name`. For example:
	`github:new-script-format` or `octocat:test-branch`.
	*/
	Head *string

	// Filter pulls by base branch name. Example: `gh-pages`.
	Base *string

	/*
	What to sort results by. Can be either `created`, `updated`, `popularity`
	(comment count) or `long-running` (age, filtering by pulls updated in the last
	month).
	*/
	Sort *string

	/*
	The direction of the sort. Can be either `asc` or `desc`. Default: `desc` when
	sort is `created` or sort is not specified, otherwise `asc`.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request
func (r *PullsListReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Head != nil {
		query.Set("head", *r.Head)
	}
	if r.Base != nil {
		query.Set("base", *r.Base)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"sailor-v"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "pulls/list",
		Previews:         map[string]bool{"sailor-v": r.SailorVPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListReq) Rel(link string, resp *PullsListResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListResponse is a response for PullsList

https://developer.github.com/v3/pulls/#list-pull-requests
*/
type PullsListResponse struct {
	common.Response
	request *PullsListReq
	Data    []components.PullRequestSimple
}

/*
PullsListCommentsForReview performs requests for "pulls/list-comments-for-review"

List comments for a pull request review.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments

https://developer.github.com/v3/pulls/reviews/#list-comments-for-a-pull-request-review
*/
func PullsListCommentsForReview(ctx context.Context, req *PullsListCommentsForReviewReq, opt ...options.Option) (*PullsListCommentsForReviewResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsListCommentsForReviewReq)
	}
	resp := &PullsListCommentsForReviewResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.ReviewComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListCommentsForReview performs requests for "pulls/list-comments-for-review"

List comments for a pull request review.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments

https://developer.github.com/v3/pulls/reviews/#list-comments-for-a-pull-request-review
*/
func (c Client) PullsListCommentsForReview(ctx context.Context, req *PullsListCommentsForReviewReq, opt ...options.Option) (*PullsListCommentsForReviewResponse, error) {
	return PullsListCommentsForReview(ctx, req, append(c, opt...)...)
}

/*
PullsListCommentsForReviewReq is request data for Client.PullsListCommentsForReview

https://developer.github.com/v3/pulls/reviews/#list-comments-for-a-pull-request-review
*/
type PullsListCommentsForReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// review_id parameter
	ReviewId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *PullsListCommentsForReviewReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsListCommentsForReviewReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "pulls/list-comments-for-review",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v/comments", r.Owner, r.Repo, r.PullNumber, r.ReviewId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListCommentsForReviewReq) Rel(link string, resp *PullsListCommentsForReviewResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListCommentsForReviewResponse is a response for PullsListCommentsForReview

https://developer.github.com/v3/pulls/reviews/#list-comments-for-a-pull-request-review
*/
type PullsListCommentsForReviewResponse struct {
	common.Response
	request *PullsListCommentsForReviewReq
	Data    []components.ReviewComment
}

/*
PullsListCommits performs requests for "pulls/list-commits"

List commits on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/commits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
func PullsListCommits(ctx context.Context, req *PullsListCommitsReq, opt ...options.Option) (*PullsListCommitsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsListCommitsReq)
	}
	resp := &PullsListCommitsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleCommit{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListCommits performs requests for "pulls/list-commits"

List commits on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/commits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
func (c Client) PullsListCommits(ctx context.Context, req *PullsListCommitsReq, opt ...options.Option) (*PullsListCommitsResponse, error) {
	return PullsListCommits(ctx, req, append(c, opt...)...)
}

/*
PullsListCommitsReq is request data for Client.PullsListCommits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
type PullsListCommitsReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *PullsListCommitsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsListCommitsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "pulls/list-commits",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/commits", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListCommitsReq) Rel(link string, resp *PullsListCommitsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListCommitsResponse is a response for PullsListCommits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
type PullsListCommitsResponse struct {
	common.Response
	request *PullsListCommitsReq
	Data    []components.SimpleCommit
}

/*
PullsListFiles performs requests for "pulls/list-files"

List pull requests files.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/files

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
func PullsListFiles(ctx context.Context, req *PullsListFilesReq, opt ...options.Option) (*PullsListFilesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsListFilesReq)
	}
	resp := &PullsListFilesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.DiffEntry{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListFiles performs requests for "pulls/list-files"

List pull requests files.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/files

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
func (c Client) PullsListFiles(ctx context.Context, req *PullsListFilesReq, opt ...options.Option) (*PullsListFilesResponse, error) {
	return PullsListFiles(ctx, req, append(c, opt...)...)
}

/*
PullsListFilesReq is request data for Client.PullsListFiles

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
type PullsListFilesReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *PullsListFilesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsListFilesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "pulls/list-files",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/files", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListFilesReq) Rel(link string, resp *PullsListFilesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListFilesResponse is a response for PullsListFiles

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
type PullsListFilesResponse struct {
	common.Response
	request *PullsListFilesReq
	Data    []components.DiffEntry
}

/*
PullsListRequestedReviewers performs requests for "pulls/list-requested-reviewers"

List requested reviewers for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#list-requested-reviewers-for-a-pull-request
*/
func PullsListRequestedReviewers(ctx context.Context, req *PullsListRequestedReviewersReq, opt ...options.Option) (*PullsListRequestedReviewersResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsListRequestedReviewersReq)
	}
	resp := &PullsListRequestedReviewersResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequestReviewRequest{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListRequestedReviewers performs requests for "pulls/list-requested-reviewers"

List requested reviewers for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#list-requested-reviewers-for-a-pull-request
*/
func (c Client) PullsListRequestedReviewers(ctx context.Context, req *PullsListRequestedReviewersReq, opt ...options.Option) (*PullsListRequestedReviewersResponse, error) {
	return PullsListRequestedReviewers(ctx, req, append(c, opt...)...)
}

/*
PullsListRequestedReviewersReq is request data for Client.PullsListRequestedReviewers

https://developer.github.com/v3/pulls/review_requests/#list-requested-reviewers-for-a-pull-request
*/
type PullsListRequestedReviewersReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *PullsListRequestedReviewersReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsListRequestedReviewersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "pulls/list-requested-reviewers",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/requested_reviewers", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListRequestedReviewersReq) Rel(link string, resp *PullsListRequestedReviewersResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListRequestedReviewersResponse is a response for PullsListRequestedReviewers

https://developer.github.com/v3/pulls/review_requests/#list-requested-reviewers-for-a-pull-request
*/
type PullsListRequestedReviewersResponse struct {
	common.Response
	request *PullsListRequestedReviewersReq
	Data    components.PullRequestReviewRequest
}

/*
PullsListReviewComments performs requests for "pulls/list-review-comments"

List review comments on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#list-review-comments-on-a-pull-request
*/
func PullsListReviewComments(ctx context.Context, req *PullsListReviewCommentsReq, opt ...options.Option) (*PullsListReviewCommentsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsListReviewCommentsReq)
	}
	resp := &PullsListReviewCommentsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.PullRequestReviewComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListReviewComments performs requests for "pulls/list-review-comments"

List review comments on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#list-review-comments-on-a-pull-request
*/
func (c Client) PullsListReviewComments(ctx context.Context, req *PullsListReviewCommentsReq, opt ...options.Option) (*PullsListReviewCommentsResponse, error) {
	return PullsListReviewComments(ctx, req, append(c, opt...)...)
}

/*
PullsListReviewCommentsReq is request data for Client.PullsListReviewComments

https://developer.github.com/v3/pulls/comments/#list-review-comments-on-a-pull-request
*/
type PullsListReviewCommentsReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// Can be either `asc` or `desc`. Ignored without `sort` parameter.
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *PullsListReviewCommentsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsListReviewCommentsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"comfort-fade", "squirrel-girl"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "pulls/list-review-comments",
		Previews: map[string]bool{
			"comfort-fade":  r.ComfortFadePreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/comments", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListReviewCommentsReq) Rel(link string, resp *PullsListReviewCommentsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListReviewCommentsResponse is a response for PullsListReviewComments

https://developer.github.com/v3/pulls/comments/#list-review-comments-on-a-pull-request
*/
type PullsListReviewCommentsResponse struct {
	common.Response
	request *PullsListReviewCommentsReq
	Data    []components.PullRequestReviewComment
}

/*
PullsListReviewCommentsForRepo performs requests for "pulls/list-review-comments-for-repo"

List review comments in a repository.

  GET /repos/{owner}/{repo}/pulls/comments

https://developer.github.com/v3/pulls/comments/#list-review-comments-in-a-repository
*/
func PullsListReviewCommentsForRepo(ctx context.Context, req *PullsListReviewCommentsForRepoReq, opt ...options.Option) (*PullsListReviewCommentsForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsListReviewCommentsForRepoReq)
	}
	resp := &PullsListReviewCommentsForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.PullRequestReviewComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListReviewCommentsForRepo performs requests for "pulls/list-review-comments-for-repo"

List review comments in a repository.

  GET /repos/{owner}/{repo}/pulls/comments

https://developer.github.com/v3/pulls/comments/#list-review-comments-in-a-repository
*/
func (c Client) PullsListReviewCommentsForRepo(ctx context.Context, req *PullsListReviewCommentsForRepoReq, opt ...options.Option) (*PullsListReviewCommentsForRepoResponse, error) {
	return PullsListReviewCommentsForRepo(ctx, req, append(c, opt...)...)
}

/*
PullsListReviewCommentsForRepoReq is request data for Client.PullsListReviewCommentsForRepo

https://developer.github.com/v3/pulls/comments/#list-review-comments-in-a-repository
*/
type PullsListReviewCommentsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	One of `created` (when the repository was starred) or `updated` (when it was
	last pushed to).
	*/
	Sort *string

	// Can be either `asc` or `desc`. Ignored without `sort` parameter.
	Direction *string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *PullsListReviewCommentsForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsListReviewCommentsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"comfort-fade", "squirrel-girl"},
		Body:         nil,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals:   map[string]*string{"accept": String("application/json")},
		Method:       "GET",
		OperationID:  "pulls/list-review-comments-for-repo",
		Previews: map[string]bool{
			"comfort-fade":  r.ComfortFadePreview,
			"squirrel-girl": r.SquirrelGirlPreview,
		},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/comments", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListReviewCommentsForRepoReq) Rel(link string, resp *PullsListReviewCommentsForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListReviewCommentsForRepoResponse is a response for PullsListReviewCommentsForRepo

https://developer.github.com/v3/pulls/comments/#list-review-comments-in-a-repository
*/
type PullsListReviewCommentsForRepoResponse struct {
	common.Response
	request *PullsListReviewCommentsForRepoReq
	Data    []components.PullRequestReviewComment
}

/*
PullsListReviews performs requests for "pulls/list-reviews"

List reviews for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-for-a-pull-request
*/
func PullsListReviews(ctx context.Context, req *PullsListReviewsReq, opt ...options.Option) (*PullsListReviewsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsListReviewsReq)
	}
	resp := &PullsListReviewsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.PullRequestReview{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListReviews performs requests for "pulls/list-reviews"

List reviews for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-for-a-pull-request
*/
func (c Client) PullsListReviews(ctx context.Context, req *PullsListReviewsReq, opt ...options.Option) (*PullsListReviewsResponse, error) {
	return PullsListReviews(ctx, req, append(c, opt...)...)
}

/*
PullsListReviewsReq is request data for Client.PullsListReviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-for-a-pull-request
*/
type PullsListReviewsReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *PullsListReviewsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsListReviewsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "pulls/list-reviews",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListReviewsReq) Rel(link string, resp *PullsListReviewsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListReviewsResponse is a response for PullsListReviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-for-a-pull-request
*/
type PullsListReviewsResponse struct {
	common.Response
	request *PullsListReviewsReq
	Data    []components.PullRequestReview
}

/*
PullsMerge performs requests for "pulls/merge"

Merge a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
func PullsMerge(ctx context.Context, req *PullsMergeReq, opt ...options.Option) (*PullsMergeResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsMergeReq)
	}
	resp := &PullsMergeResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequestMergeResult{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsMerge performs requests for "pulls/merge"

Merge a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
func (c Client) PullsMerge(ctx context.Context, req *PullsMergeReq, opt ...options.Option) (*PullsMergeResponse, error) {
	return PullsMerge(ctx, req, append(c, opt...)...)
}

/*
PullsMergeReq is request data for Client.PullsMerge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
type PullsMergeReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsMergeReqBody
}

// HTTPRequest builds an *http.Request
func (r *PullsMergeReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsMergeReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "pulls/merge",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/merge", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsMergeReq) Rel(link string, resp *PullsMergeResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsMergeReqBody is a request body for pulls/merge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
type PullsMergeReqBody struct {

	// Extra detail to append to automatic commit message.
	CommitMessage *string `json:"commit_message,omitempty"`

	// Title for the automatic commit message.
	CommitTitle *string `json:"commit_title,omitempty"`

	// Merge method to use. Possible values are `merge`, `squash` or `rebase`. Default is `merge`.
	MergeMethod *string `json:"merge_method,omitempty"`

	// SHA that pull request head must match to allow merge.
	Sha *string `json:"sha,omitempty"`
}

/*
PullsMergeResponse is a response for PullsMerge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
type PullsMergeResponse struct {
	common.Response
	request *PullsMergeReq
	Data    components.PullRequestMergeResult
}

/*
PullsRemoveRequestedReviewers performs requests for "pulls/remove-requested-reviewers"

Remove requested reviewers from a pull request.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request
*/
func PullsRemoveRequestedReviewers(ctx context.Context, req *PullsRemoveRequestedReviewersReq, opt ...options.Option) (*PullsRemoveRequestedReviewersResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsRemoveRequestedReviewersReq)
	}
	resp := &PullsRemoveRequestedReviewersResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsRemoveRequestedReviewers performs requests for "pulls/remove-requested-reviewers"

Remove requested reviewers from a pull request.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request
*/
func (c Client) PullsRemoveRequestedReviewers(ctx context.Context, req *PullsRemoveRequestedReviewersReq, opt ...options.Option) (*PullsRemoveRequestedReviewersResponse, error) {
	return PullsRemoveRequestedReviewers(ctx, req, append(c, opt...)...)
}

/*
PullsRemoveRequestedReviewersReq is request data for Client.PullsRemoveRequestedReviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request
*/
type PullsRemoveRequestedReviewersReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsRemoveRequestedReviewersReqBody
}

// HTTPRequest builds an *http.Request
func (r *PullsRemoveRequestedReviewersReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsRemoveRequestedReviewersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "DELETE",
		OperationID:      "pulls/remove-requested-reviewers",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/requested_reviewers", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsRemoveRequestedReviewersReq) Rel(link string, resp *PullsRemoveRequestedReviewersResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsRemoveRequestedReviewersReqBody is a request body for pulls/remove-requested-reviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request
*/
type PullsRemoveRequestedReviewersReqBody struct {

	// An array of user `login`s that will be removed.
	Reviewers []string `json:"reviewers,omitempty"`

	// An array of team `slug`s that will be removed.
	TeamReviewers []string `json:"team_reviewers,omitempty"`
}

/*
PullsRemoveRequestedReviewersResponse is a response for PullsRemoveRequestedReviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request
*/
type PullsRemoveRequestedReviewersResponse struct {
	common.Response
	request *PullsRemoveRequestedReviewersReq
}

/*
PullsRequestReviewers performs requests for "pulls/request-reviewers"

Request reviewers for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
func PullsRequestReviewers(ctx context.Context, req *PullsRequestReviewersReq, opt ...options.Option) (*PullsRequestReviewersResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsRequestReviewersReq)
	}
	resp := &PullsRequestReviewersResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequestSimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsRequestReviewers performs requests for "pulls/request-reviewers"

Request reviewers for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
func (c Client) PullsRequestReviewers(ctx context.Context, req *PullsRequestReviewersReq, opt ...options.Option) (*PullsRequestReviewersResponse, error) {
	return PullsRequestReviewers(ctx, req, append(c, opt...)...)
}

/*
PullsRequestReviewersReq is request data for Client.PullsRequestReviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
type PullsRequestReviewersReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsRequestReviewersReqBody
}

// HTTPRequest builds an *http.Request
func (r *PullsRequestReviewersReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsRequestReviewersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "pulls/request-reviewers",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/requested_reviewers", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsRequestReviewersReq) Rel(link string, resp *PullsRequestReviewersResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsRequestReviewersReqBody is a request body for pulls/request-reviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
type PullsRequestReviewersReqBody struct {

	// An array of user `login`s that will be requested.
	Reviewers []string `json:"reviewers,omitempty"`

	// An array of team `slug`s that will be requested.
	TeamReviewers []string `json:"team_reviewers,omitempty"`
}

/*
PullsRequestReviewersResponse is a response for PullsRequestReviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
type PullsRequestReviewersResponse struct {
	common.Response
	request *PullsRequestReviewersReq
	Data    components.PullRequestSimple
}

/*
PullsSubmitReview performs requests for "pulls/submit-review"

Submit a review for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
func PullsSubmitReview(ctx context.Context, req *PullsSubmitReviewReq, opt ...options.Option) (*PullsSubmitReviewResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsSubmitReviewReq)
	}
	resp := &PullsSubmitReviewResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequestReview{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsSubmitReview performs requests for "pulls/submit-review"

Submit a review for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
func (c Client) PullsSubmitReview(ctx context.Context, req *PullsSubmitReviewReq, opt ...options.Option) (*PullsSubmitReviewResponse, error) {
	return PullsSubmitReview(ctx, req, append(c, opt...)...)
}

/*
PullsSubmitReviewReq is request data for Client.PullsSubmitReview

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
type PullsSubmitReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// review_id parameter
	ReviewId    int64
	RequestBody PullsSubmitReviewReqBody
}

// HTTPRequest builds an *http.Request
func (r *PullsSubmitReviewReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsSubmitReviewReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "pulls/submit-review",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v/events", r.Owner, r.Repo, r.PullNumber, r.ReviewId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsSubmitReviewReq) Rel(link string, resp *PullsSubmitReviewResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsSubmitReviewReqBody is a request body for pulls/submit-review

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
type PullsSubmitReviewReqBody struct {

	// The body text of the pull request review
	Body *string `json:"body,omitempty"`

	/*
	The review action you want to perform. The review actions include: `APPROVE`,
	`REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns
	_HTTP 422 (Unrecognizable entity)_ and sets the review action state to
	`PENDING`, which means you will need to re-submit the pull request review using
	a review action.
	*/
	Event *string `json:"event"`
}

/*
PullsSubmitReviewResponse is a response for PullsSubmitReview

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
type PullsSubmitReviewResponse struct {
	common.Response
	request *PullsSubmitReviewReq
	Data    components.PullRequestReview
}

/*
PullsUpdate performs requests for "pulls/update"

Update a pull request.

  PATCH /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
func PullsUpdate(ctx context.Context, req *PullsUpdateReq, opt ...options.Option) (*PullsUpdateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsUpdateReq)
	}
	resp := &PullsUpdateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequest{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsUpdate performs requests for "pulls/update"

Update a pull request.

  PATCH /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
func (c Client) PullsUpdate(ctx context.Context, req *PullsUpdateReq, opt ...options.Option) (*PullsUpdateResponse, error) {
	return PullsUpdate(ctx, req, append(c, opt...)...)
}

/*
PullsUpdateReq is request data for Client.PullsUpdate

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
type PullsUpdateReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsUpdateReqBody

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

// HTTPRequest builds an *http.Request
func (r *PullsUpdateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsUpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"sailor-v"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "pulls/update",
		Previews:         map[string]bool{"sailor-v": r.SailorVPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsUpdateReq) Rel(link string, resp *PullsUpdateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsUpdateReqBody is a request body for pulls/update

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
type PullsUpdateReqBody struct {

	/*
	The name of the branch you want your changes pulled into. This should be an
	existing branch on the current repository. You cannot update the base branch on
	a pull request to point to another repository.
	*/
	Base *string `json:"base,omitempty"`

	// The contents of the pull request.
	Body *string `json:"body,omitempty"`

	/*
	Indicates whether [maintainers can
	modify](https://help.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/)
	the pull request.
	*/
	MaintainerCanModify *bool `json:"maintainer_can_modify,omitempty"`

	// State of this Pull Request. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the pull request.
	Title *string `json:"title,omitempty"`
}

/*
PullsUpdateResponse is a response for PullsUpdate

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
type PullsUpdateResponse struct {
	common.Response
	request *PullsUpdateReq
	Data    components.PullRequest
}

/*
PullsUpdateBranch performs requests for "pulls/update-branch"

Update a pull request branch.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
func PullsUpdateBranch(ctx context.Context, req *PullsUpdateBranchReq, opt ...options.Option) (*PullsUpdateBranchResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsUpdateBranchReq)
	}
	resp := &PullsUpdateBranchResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = PullsUpdateBranchResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsUpdateBranch performs requests for "pulls/update-branch"

Update a pull request branch.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
func (c Client) PullsUpdateBranch(ctx context.Context, req *PullsUpdateBranchReq, opt ...options.Option) (*PullsUpdateBranchResponse, error) {
	return PullsUpdateBranch(ctx, req, append(c, opt...)...)
}

/*
PullsUpdateBranchReq is request data for Client.PullsUpdateBranch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type PullsUpdateBranchReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsUpdateBranchReqBody

	/*
	Updating the pull request branch with latest upstream changes is currently
	available for developers to preview. To access this new endpoint during the
	preview period, you must set this to true.
	*/
	LydianPreview bool
}

// HTTPRequest builds an *http.Request
func (r *PullsUpdateBranchReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsUpdateBranchReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"lydian"},
		Body:         r.RequestBody,
		DataStatuses: []int{202},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "pulls/update-branch",
		Previews:         map[string]bool{"lydian": r.LydianPreview},
		RequiredPreviews: []string{"lydian"},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/update-branch", r.Owner, r.Repo, r.PullNumber),
		URLQuery:         query,
		ValidStatuses:    []int{202},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsUpdateBranchReq) Rel(link string, resp *PullsUpdateBranchResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsUpdateBranchReqBody is a request body for pulls/update-branch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type PullsUpdateBranchReqBody struct {

	/*
	The expected SHA of the pull request's HEAD ref. This is the most recent commit
	on the pull request's branch. If the expected SHA does not match the pull
	request's HEAD, you will receive a `422 Unprocessable Entity` status. You can
	use the "[List
	commits](https://developer.github.com/v3/repos/commits/#list-commits)" endpoint
	to find the most recent commit SHA. Default: SHA of the pull request's current
	HEAD ref.
	*/
	ExpectedHeadSha *string `json:"expected_head_sha,omitempty"`
}

/*
PullsUpdateBranchResponseBody is a response body for PullsUpdateBranch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type PullsUpdateBranchResponseBody struct {
	Message string `json:"message,omitempty"`
	Url     string `json:"url,omitempty"`
}

/*
PullsUpdateBranchResponse is a response for PullsUpdateBranch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type PullsUpdateBranchResponse struct {
	common.Response
	request *PullsUpdateBranchReq
	Data    PullsUpdateBranchResponseBody
}

/*
PullsUpdateReview performs requests for "pulls/update-review"

Update a review for a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
func PullsUpdateReview(ctx context.Context, req *PullsUpdateReviewReq, opt ...options.Option) (*PullsUpdateReviewResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsUpdateReviewReq)
	}
	resp := &PullsUpdateReviewResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequestReview{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsUpdateReview performs requests for "pulls/update-review"

Update a review for a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
func (c Client) PullsUpdateReview(ctx context.Context, req *PullsUpdateReviewReq, opt ...options.Option) (*PullsUpdateReviewResponse, error) {
	return PullsUpdateReview(ctx, req, append(c, opt...)...)
}

/*
PullsUpdateReviewReq is request data for Client.PullsUpdateReview

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
type PullsUpdateReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// review_id parameter
	ReviewId    int64
	RequestBody PullsUpdateReviewReqBody
}

// HTTPRequest builds an *http.Request
func (r *PullsUpdateReviewReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsUpdateReviewReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "pulls/update-review",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v", r.Owner, r.Repo, r.PullNumber, r.ReviewId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsUpdateReviewReq) Rel(link string, resp *PullsUpdateReviewResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsUpdateReviewReqBody is a request body for pulls/update-review

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
type PullsUpdateReviewReqBody struct {

	// The body text of the pull request review.
	Body *string `json:"body"`
}

/*
PullsUpdateReviewResponse is a response for PullsUpdateReview

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
type PullsUpdateReviewResponse struct {
	common.Response
	request *PullsUpdateReviewReq
	Data    components.PullRequestReview
}

/*
PullsUpdateReviewComment performs requests for "pulls/update-review-comment"

Update a review comment for a pull request.

  PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
func PullsUpdateReviewComment(ctx context.Context, req *PullsUpdateReviewCommentReq, opt ...options.Option) (*PullsUpdateReviewCommentResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(PullsUpdateReviewCommentReq)
	}
	resp := &PullsUpdateReviewCommentResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PullRequestReviewComment{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsUpdateReviewComment performs requests for "pulls/update-review-comment"

Update a review comment for a pull request.

  PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
func (c Client) PullsUpdateReviewComment(ctx context.Context, req *PullsUpdateReviewCommentReq, opt ...options.Option) (*PullsUpdateReviewCommentResponse, error) {
	return PullsUpdateReviewComment(ctx, req, append(c, opt...)...)
}

/*
PullsUpdateReviewCommentReq is request data for Client.PullsUpdateReviewComment

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
type PullsUpdateReviewCommentReq struct {
	_url  string
	Owner string
	Repo  string

	// comment_id parameter
	CommentId   int64
	RequestBody PullsUpdateReviewCommentReqBody

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool
}

// HTTPRequest builds an *http.Request
func (r *PullsUpdateReviewCommentReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *PullsUpdateReviewCommentReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"comfort-fade"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "pulls/update-review-comment",
		Previews:         map[string]bool{"comfort-fade": r.ComfortFadePreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/pulls/comments/%v", r.Owner, r.Repo, r.CommentId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsUpdateReviewCommentReq) Rel(link string, resp *PullsUpdateReviewCommentResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsUpdateReviewCommentReqBody is a request body for pulls/update-review-comment

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
type PullsUpdateReviewCommentReqBody struct {

	// The text of the reply to the review comment.
	Body *string `json:"body"`
}

/*
PullsUpdateReviewCommentResponse is a response for PullsUpdateReviewComment

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
type PullsUpdateReviewCommentResponse struct {
	common.Response
	request *PullsUpdateReviewCommentReq
	Data    components.PullRequestReviewComment
}
