// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
PullsCheckIfMerged performs requests for "pulls/check-if-merged"

Get if a pull request has been merged.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#get-if-a-pull-request-has-been-merged
*/
func (c *Client) PullsCheckIfMerged(ctx context.Context, req *PullsCheckIfMergedReq, opt ...RequestOption) (*PullsCheckIfMergedResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsCheckIfMergedResponse{
		request:  req,
		response: *r,
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCheckIfMergedReq is request data for Client.PullsCheckIfMerged

https://developer.github.com/v3/pulls/#get-if-a-pull-request-has-been-merged
*/
type PullsCheckIfMergedReq struct {
	pgURL      string
	Owner      string
	Repo       string
	PullNumber int64
}

func (r *PullsCheckIfMergedReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsCheckIfMergedReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/merge", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsCheckIfMergedReq) method() string {
	return "GET"
}

func (r *PullsCheckIfMergedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsCheckIfMergedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsCheckIfMergedReq) body() interface{} {
	return nil
}

func (r *PullsCheckIfMergedReq) dataStatuses() []int {
	return []int{}
}

func (r *PullsCheckIfMergedReq) validStatuses() []int {
	return []int{204}
}

func (r *PullsCheckIfMergedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// httpRequest creates an http request
func (r *PullsCheckIfMergedReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCheckIfMergedReq) Rel(link RelName, resp *PullsCheckIfMergedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsCheckIfMergedResponse is a response for PullsCheckIfMerged

https://developer.github.com/v3/pulls/#get-if-a-pull-request-has-been-merged
*/
type PullsCheckIfMergedResponse struct {
	response
	request *PullsCheckIfMergedReq
	Data    bool
}

/*
PullsCreate performs requests for "pulls/create"

Create a pull request.

  POST /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
func (c *Client) PullsCreate(ctx context.Context, req *PullsCreateReq, opt ...RequestOption) (*PullsCreateResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsCreateResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsCreateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCreateReq is request data for Client.PullsCreate

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
type PullsCreateReq struct {
	pgURL       string
	Owner       string
	Repo        string
	RequestBody PullsCreateReqBody

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *PullsCreateReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsCreateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls", r.Owner, r.Repo)
}

func (r *PullsCreateReq) method() string {
	return "POST"
}

func (r *PullsCreateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsCreateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"sailor-v": r.SailorVPreview}
	if allPreviews {
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsCreateReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsCreateReq) dataStatuses() []int {
	return []int{201}
}

func (r *PullsCreateReq) validStatuses() []int {
	return []int{201}
}

func (r *PullsCreateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *PullsCreateReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCreateReq) Rel(link RelName, resp *PullsCreateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsCreateReqBody is a request body for pulls/create

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
type PullsCreateReqBody struct {

	/*
	   The name of the branch you want the changes pulled into. This should be an
	   existing branch on the current repository. You cannot submit a pull request to
	   one repository that requests a merge to a base of another repository.
	*/
	Base *string `json:"base"`

	// The contents of the pull request.
	Body *string `json:"body,omitempty"`

	/*
	   Indicates whether the pull request is a draft. See "[Draft Pull
	   Requests](https://help.github.com/en/articles/about-pull-requests#draft-pull-requests)"
	   in the GitHub Help documentation to learn more.
	*/
	Draft *bool `json:"draft,omitempty"`

	/*
	   The name of the branch where your changes are implemented. For cross-repository
	   pull requests in the same network, namespace `head` with a user like this:
	   `username:branch`.
	*/
	Head *string `json:"head"`

	/*
	   Indicates whether [maintainers can
	   modify](https://help.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/)
	   the pull request.
	*/
	MaintainerCanModify *bool `json:"maintainer_can_modify,omitempty"`

	// The title of the new pull request.
	Title *string `json:"title"`
}

/*
PullsCreateResponseBody is a response body for PullsCreate

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
type PullsCreateResponseBody struct {
	components.PullRequest
}

/*
PullsCreateResponse is a response for PullsCreate

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
type PullsCreateResponse struct {
	response
	request *PullsCreateReq
	Data    *PullsCreateResponseBody
}

/*
PullsCreateComment performs requests for "pulls/create-comment"

Create a comment.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#create-a-comment
*/
func (c *Client) PullsCreateComment(ctx context.Context, req *PullsCreateCommentReq, opt ...RequestOption) (*PullsCreateCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsCreateCommentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsCreateCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCreateCommentReq is request data for Client.PullsCreateComment

https://developer.github.com/v3/pulls/comments/#create-a-comment
*/
type PullsCreateCommentReq struct {
	pgURL       string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsCreateCommentReqBody

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool
}

func (r *PullsCreateCommentReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsCreateCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/comments", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsCreateCommentReq) method() string {
	return "POST"
}

func (r *PullsCreateCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsCreateCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"comfort-fade": r.ComfortFadePreview}
	if allPreviews {
		previewVals["comfort-fade"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsCreateCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsCreateCommentReq) dataStatuses() []int {
	return []int{201}
}

func (r *PullsCreateCommentReq) validStatuses() []int {
	return []int{201}
}

func (r *PullsCreateCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *PullsCreateCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCreateCommentReq) Rel(link RelName, resp *PullsCreateCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsCreateCommentReqBody is a request body for pulls/create-comment

https://developer.github.com/v3/pulls/comments/#create-a-comment
*/
type PullsCreateCommentReqBody struct {

	// The text of the review comment.
	Body *string `json:"body"`

	/*
	   The SHA of the commit needing a comment. Not using the latest commit SHA may
	   render your comment outdated if a subsequent commit modifies the line you
	   specify as the `position`.
	*/
	CommitId *string `json:"commit_id"`

	/*
	   **Required with `comfort-fade` preview**. The line of the blob in the pull
	   request diff that the comment applies to. For a multi-line comment, the last
	   line of the range that your comment applies to.
	*/
	Line *int64 `json:"line,omitempty"`

	// The relative path to the file that necessitates a comment.
	Path *string `json:"path"`

	/*
	   **Required without `comfort-fade` preview**. The position in the diff where you
	   want to add a review comment. Note this value is not the same as the line number
	   in the file. For help finding the position value, read the note above.
	*/
	Position *int64 `json:"position,omitempty"`

	/*
	   **Required with `comfort-fade` preview**. In a split diff view, the side of the
	   diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use
	   `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear
	   in green or unchanged lines that appear in white and are shown for context. For
	   a multi-line comment, side represents whether the last line of the comment range
	   is a deletion or addition. For more information, see "[Diff view
	   options](https://help.github.com/en/articles/about-comparing-branches-in-pull-requests#diff-view-options)"
	   in the GitHub Help documentation.
	*/
	Side *string `json:"side,omitempty"`

	/*
	   **Required when using multi-line comments**. To create multi-line comments, you
	   must use the `comfort-fade` preview header. The `start_line` is the first line
	   in the pull request diff that your multi-line comment applies to. To learn more
	   about multi-line comments, see "[Commenting on a pull
	   request](https://help.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)"
	   in the GitHub Help documentation.
	*/
	StartLine *int64 `json:"start_line,omitempty"`

	/*
	   **Required when using multi-line comments**. To create multi-line comments, you
	   must use the `comfort-fade` preview header. The `start_side` is the starting
	   side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn
	   more about multi-line comments, see "[Commenting on a pull
	   request](https://help.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)"
	   in the GitHub Help documentation. See `side` in this table for additional
	   context.
	*/
	StartSide *string `json:"start_side,omitempty"`
}

/*
PullsCreateCommentResponseBody is a response body for PullsCreateComment

https://developer.github.com/v3/pulls/comments/#create-a-comment
*/
type PullsCreateCommentResponseBody struct {
	components.PullRequestReviewComment
}

/*
PullsCreateCommentResponse is a response for PullsCreateComment

https://developer.github.com/v3/pulls/comments/#create-a-comment
*/
type PullsCreateCommentResponse struct {
	response
	request *PullsCreateCommentReq
	Data    *PullsCreateCommentResponseBody
}

/*
PullsCreateReview performs requests for "pulls/create-review"

Create a pull request review.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#create-a-pull-request-review
*/
func (c *Client) PullsCreateReview(ctx context.Context, req *PullsCreateReviewReq, opt ...RequestOption) (*PullsCreateReviewResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsCreateReviewResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsCreateReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCreateReviewReq is request data for Client.PullsCreateReview

https://developer.github.com/v3/pulls/reviews/#create-a-pull-request-review
*/
type PullsCreateReviewReq struct {
	pgURL       string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsCreateReviewReqBody
}

func (r *PullsCreateReviewReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsCreateReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsCreateReviewReq) method() string {
	return "POST"
}

func (r *PullsCreateReviewReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsCreateReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsCreateReviewReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsCreateReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsCreateReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsCreateReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *PullsCreateReviewReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCreateReviewReq) Rel(link RelName, resp *PullsCreateReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

// PullsCreateReviewReqBodyComments is a value for PullsCreateReviewReqBody's Comments field
type PullsCreateReviewReqBodyComments struct {

	// Text of the review comment.
	Body *string `json:"body"`

	// The relative path to the file that necessitates a review comment.
	Path *string `json:"path"`

	/*
	   The position in the diff where you want to add a review comment. Note this value
	   is not the same as the line number in the file. For help finding the position
	   value, read the note below.
	*/
	Position *int64 `json:"position"`
}

/*
PullsCreateReviewReqBody is a request body for pulls/create-review

https://developer.github.com/v3/pulls/reviews/#create-a-pull-request-review
*/
type PullsCreateReviewReqBody struct {

	/*
	   **Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event`
	   parameter. The body text of the pull request review.
	*/
	Body *string `json:"body,omitempty"`

	/*
	   Use the following table to specify the location, destination, and contents of
	   the draft review comment.
	*/
	Comments []PullsCreateReviewReqBodyComments `json:"comments,omitempty"`

	/*
	   The SHA of the commit that needs a review. Not using the latest commit SHA may
	   render your review comment outdated if a subsequent commit modifies the line you
	   specify as the `position`. Defaults to the most recent commit in the pull
	   request when you do not specify a value.
	*/
	CommitId *string `json:"commit_id,omitempty"`

	/*
	   The review action you want to perform. The review actions include: `APPROVE`,
	   `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review
	   action state to `PENDING`, which means you will need to [submit the pull request
	   review](https://developer.github.com/v3/pulls/reviews/#submit-a-pull-request-review)
	   when you are ready.
	*/
	Event *string `json:"event,omitempty"`
}

/*
PullsCreateReviewResponseBody is a response body for PullsCreateReview

https://developer.github.com/v3/pulls/reviews/#create-a-pull-request-review
*/
type PullsCreateReviewResponseBody struct {
	components.PullRequestReview
}

/*
PullsCreateReviewResponse is a response for PullsCreateReview

https://developer.github.com/v3/pulls/reviews/#create-a-pull-request-review
*/
type PullsCreateReviewResponse struct {
	response
	request *PullsCreateReviewReq
	Data    *PullsCreateReviewResponseBody
}

/*
PullsCreateReviewCommentReply performs requests for "pulls/create-review-comment-reply"

Create a review comment reply.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-reply
*/
func (c *Client) PullsCreateReviewCommentReply(ctx context.Context, req *PullsCreateReviewCommentReplyReq, opt ...RequestOption) (*PullsCreateReviewCommentReplyResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsCreateReviewCommentReplyResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsCreateReviewCommentReplyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCreateReviewCommentReplyReq is request data for Client.PullsCreateReviewCommentReply

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-reply
*/
type PullsCreateReviewCommentReplyReq struct {
	pgURL       string
	Owner       string
	Repo        string
	PullNumber  int64
	CommentId   int64
	RequestBody PullsCreateReviewCommentReplyReqBody
}

func (r *PullsCreateReviewCommentReplyReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsCreateReviewCommentReplyReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/comments/%v/replies", r.Owner, r.Repo, r.PullNumber, r.CommentId)
}

func (r *PullsCreateReviewCommentReplyReq) method() string {
	return "POST"
}

func (r *PullsCreateReviewCommentReplyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsCreateReviewCommentReplyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsCreateReviewCommentReplyReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsCreateReviewCommentReplyReq) dataStatuses() []int {
	return []int{201}
}

func (r *PullsCreateReviewCommentReplyReq) validStatuses() []int {
	return []int{201}
}

func (r *PullsCreateReviewCommentReplyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *PullsCreateReviewCommentReplyReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCreateReviewCommentReplyReq) Rel(link RelName, resp *PullsCreateReviewCommentReplyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsCreateReviewCommentReplyReqBody is a request body for pulls/create-review-comment-reply

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-reply
*/
type PullsCreateReviewCommentReplyReqBody struct {

	// The text of the review comment.
	Body *string `json:"body"`
}

/*
PullsCreateReviewCommentReplyResponseBody is a response body for PullsCreateReviewCommentReply

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-reply
*/
type PullsCreateReviewCommentReplyResponseBody struct {
	components.PullRequestReviewComment2
}

/*
PullsCreateReviewCommentReplyResponse is a response for PullsCreateReviewCommentReply

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-reply
*/
type PullsCreateReviewCommentReplyResponse struct {
	response
	request *PullsCreateReviewCommentReplyReq
	Data    *PullsCreateReviewCommentReplyResponseBody
}

/*
PullsCreateReviewRequest performs requests for "pulls/create-review-request"

Create a review request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#create-a-review-request
*/
func (c *Client) PullsCreateReviewRequest(ctx context.Context, req *PullsCreateReviewRequestReq, opt ...RequestOption) (*PullsCreateReviewRequestResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsCreateReviewRequestResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsCreateReviewRequestResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCreateReviewRequestReq is request data for Client.PullsCreateReviewRequest

https://developer.github.com/v3/pulls/review_requests/#create-a-review-request
*/
type PullsCreateReviewRequestReq struct {
	pgURL       string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsCreateReviewRequestReqBody
}

func (r *PullsCreateReviewRequestReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsCreateReviewRequestReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/requested_reviewers", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsCreateReviewRequestReq) method() string {
	return "POST"
}

func (r *PullsCreateReviewRequestReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsCreateReviewRequestReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsCreateReviewRequestReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsCreateReviewRequestReq) dataStatuses() []int {
	return []int{201}
}

func (r *PullsCreateReviewRequestReq) validStatuses() []int {
	return []int{201}
}

func (r *PullsCreateReviewRequestReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *PullsCreateReviewRequestReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCreateReviewRequestReq) Rel(link RelName, resp *PullsCreateReviewRequestResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsCreateReviewRequestReqBody is a request body for pulls/create-review-request

https://developer.github.com/v3/pulls/review_requests/#create-a-review-request
*/
type PullsCreateReviewRequestReqBody struct {

	// An array of user `login`s that will be requested.
	Reviewers []string `json:"reviewers,omitempty"`

	// An array of team `slug`s that will be requested.
	TeamReviewers []string `json:"team_reviewers,omitempty"`
}

/*
PullsCreateReviewRequestResponseBody is a response body for PullsCreateReviewRequest

https://developer.github.com/v3/pulls/review_requests/#create-a-review-request
*/
type PullsCreateReviewRequestResponseBody struct {
	components.PullRequestReviewRequest
}

/*
PullsCreateReviewRequestResponse is a response for PullsCreateReviewRequest

https://developer.github.com/v3/pulls/review_requests/#create-a-review-request
*/
type PullsCreateReviewRequestResponse struct {
	response
	request *PullsCreateReviewRequestReq
	Data    *PullsCreateReviewRequestResponseBody
}

/*
PullsDeleteComment performs requests for "pulls/delete-comment"

Delete a comment.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#delete-a-comment
*/
func (c *Client) PullsDeleteComment(ctx context.Context, req *PullsDeleteCommentReq, opt ...RequestOption) (*PullsDeleteCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsDeleteCommentResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsDeleteCommentReq is request data for Client.PullsDeleteComment

https://developer.github.com/v3/pulls/comments/#delete-a-comment
*/
type PullsDeleteCommentReq struct {
	pgURL     string
	Owner     string
	Repo      string
	CommentId int64
}

func (r *PullsDeleteCommentReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsDeleteCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *PullsDeleteCommentReq) method() string {
	return "DELETE"
}

func (r *PullsDeleteCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsDeleteCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsDeleteCommentReq) body() interface{} {
	return nil
}

func (r *PullsDeleteCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *PullsDeleteCommentReq) validStatuses() []int {
	return []int{204}
}

func (r *PullsDeleteCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *PullsDeleteCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsDeleteCommentReq) Rel(link RelName, resp *PullsDeleteCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsDeleteCommentResponse is a response for PullsDeleteComment

https://developer.github.com/v3/pulls/comments/#delete-a-comment
*/
type PullsDeleteCommentResponse struct {
	response
	request *PullsDeleteCommentReq
}

/*
PullsDeletePendingReview performs requests for "pulls/delete-pending-review"

Delete a pending review.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review
*/
func (c *Client) PullsDeletePendingReview(ctx context.Context, req *PullsDeletePendingReviewReq, opt ...RequestOption) (*PullsDeletePendingReviewResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsDeletePendingReviewResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsDeletePendingReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsDeletePendingReviewReq is request data for Client.PullsDeletePendingReview

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review
*/
type PullsDeletePendingReviewReq struct {
	pgURL      string
	Owner      string
	Repo       string
	PullNumber int64
	ReviewId   int64
}

func (r *PullsDeletePendingReviewReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsDeletePendingReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v", r.Owner, r.Repo, r.PullNumber, r.ReviewId)
}

func (r *PullsDeletePendingReviewReq) method() string {
	return "DELETE"
}

func (r *PullsDeletePendingReviewReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsDeletePendingReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsDeletePendingReviewReq) body() interface{} {
	return nil
}

func (r *PullsDeletePendingReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsDeletePendingReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsDeletePendingReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *PullsDeletePendingReviewReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsDeletePendingReviewReq) Rel(link RelName, resp *PullsDeletePendingReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsDeletePendingReviewResponseBody is a response body for PullsDeletePendingReview

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review
*/
type PullsDeletePendingReviewResponseBody struct {
	components.PullRequestReview
}

/*
PullsDeletePendingReviewResponse is a response for PullsDeletePendingReview

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review
*/
type PullsDeletePendingReviewResponse struct {
	response
	request *PullsDeletePendingReviewReq
	Data    *PullsDeletePendingReviewResponseBody
}

/*
PullsDeleteReviewRequest performs requests for "pulls/delete-review-request"

Delete a review request.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#delete-a-review-request
*/
func (c *Client) PullsDeleteReviewRequest(ctx context.Context, req *PullsDeleteReviewRequestReq, opt ...RequestOption) (*PullsDeleteReviewRequestResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsDeleteReviewRequestResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsDeleteReviewRequestReq is request data for Client.PullsDeleteReviewRequest

https://developer.github.com/v3/pulls/review_requests/#delete-a-review-request
*/
type PullsDeleteReviewRequestReq struct {
	pgURL       string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsDeleteReviewRequestReqBody
}

func (r *PullsDeleteReviewRequestReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsDeleteReviewRequestReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/requested_reviewers", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsDeleteReviewRequestReq) method() string {
	return "DELETE"
}

func (r *PullsDeleteReviewRequestReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsDeleteReviewRequestReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsDeleteReviewRequestReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsDeleteReviewRequestReq) dataStatuses() []int {
	return []int{}
}

func (r *PullsDeleteReviewRequestReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsDeleteReviewRequestReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *PullsDeleteReviewRequestReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsDeleteReviewRequestReq) Rel(link RelName, resp *PullsDeleteReviewRequestResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsDeleteReviewRequestReqBody is a request body for pulls/delete-review-request

https://developer.github.com/v3/pulls/review_requests/#delete-a-review-request
*/
type PullsDeleteReviewRequestReqBody struct {

	// An array of user `login`s that will be removed.
	Reviewers []string `json:"reviewers,omitempty"`

	// An array of team `slug`s that will be removed.
	TeamReviewers []string `json:"team_reviewers,omitempty"`
}

/*
PullsDeleteReviewRequestResponse is a response for PullsDeleteReviewRequest

https://developer.github.com/v3/pulls/review_requests/#delete-a-review-request
*/
type PullsDeleteReviewRequestResponse struct {
	response
	request *PullsDeleteReviewRequestReq
}

/*
PullsDismissReview performs requests for "pulls/dismiss-review"

Dismiss a pull request review.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals

https://developer.github.com/v3/pulls/reviews/#dismiss-a-pull-request-review
*/
func (c *Client) PullsDismissReview(ctx context.Context, req *PullsDismissReviewReq, opt ...RequestOption) (*PullsDismissReviewResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsDismissReviewResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsDismissReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsDismissReviewReq is request data for Client.PullsDismissReview

https://developer.github.com/v3/pulls/reviews/#dismiss-a-pull-request-review
*/
type PullsDismissReviewReq struct {
	pgURL       string
	Owner       string
	Repo        string
	PullNumber  int64
	ReviewId    int64
	RequestBody PullsDismissReviewReqBody
}

func (r *PullsDismissReviewReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsDismissReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v/dismissals", r.Owner, r.Repo, r.PullNumber, r.ReviewId)
}

func (r *PullsDismissReviewReq) method() string {
	return "PUT"
}

func (r *PullsDismissReviewReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsDismissReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsDismissReviewReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsDismissReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsDismissReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsDismissReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *PullsDismissReviewReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsDismissReviewReq) Rel(link RelName, resp *PullsDismissReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsDismissReviewReqBody is a request body for pulls/dismiss-review

https://developer.github.com/v3/pulls/reviews/#dismiss-a-pull-request-review
*/
type PullsDismissReviewReqBody struct {

	// The message for the pull request review dismissal
	Message *string `json:"message"`
}

/*
PullsDismissReviewResponseBody is a response body for PullsDismissReview

https://developer.github.com/v3/pulls/reviews/#dismiss-a-pull-request-review
*/
type PullsDismissReviewResponseBody struct {
	components.PullRequestReview
}

/*
PullsDismissReviewResponse is a response for PullsDismissReview

https://developer.github.com/v3/pulls/reviews/#dismiss-a-pull-request-review
*/
type PullsDismissReviewResponse struct {
	response
	request *PullsDismissReviewReq
	Data    *PullsDismissReviewResponseBody
}

/*
PullsGet performs requests for "pulls/get"

Get a single pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#get-a-single-pull-request
*/
func (c *Client) PullsGet(ctx context.Context, req *PullsGetReq, opt ...RequestOption) (*PullsGetResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsGetResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsGetResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsGetReq is request data for Client.PullsGet

https://developer.github.com/v3/pulls/#get-a-single-pull-request
*/
type PullsGetReq struct {
	pgURL      string
	Owner      string
	Repo       string
	PullNumber int64

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *PullsGetReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsGetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsGetReq) method() string {
	return "GET"
}

func (r *PullsGetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsGetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"sailor-v": r.SailorVPreview}
	if allPreviews {
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsGetReq) body() interface{} {
	return nil
}

func (r *PullsGetReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsGetReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsGetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *PullsGetReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsGetReq) Rel(link RelName, resp *PullsGetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsGetResponseBody is a response body for PullsGet

https://developer.github.com/v3/pulls/#get-a-single-pull-request
*/
type PullsGetResponseBody struct {
	components.PullRequest
}

/*
PullsGetResponse is a response for PullsGet

https://developer.github.com/v3/pulls/#get-a-single-pull-request
*/
type PullsGetResponse struct {
	response
	request *PullsGetReq
	Data    *PullsGetResponseBody
}

/*
PullsGetComment performs requests for "pulls/get-comment"

Get a single comment.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#get-a-single-comment
*/
func (c *Client) PullsGetComment(ctx context.Context, req *PullsGetCommentReq, opt ...RequestOption) (*PullsGetCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsGetCommentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsGetCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsGetCommentReq is request data for Client.PullsGetComment

https://developer.github.com/v3/pulls/comments/#get-a-single-comment
*/
type PullsGetCommentReq struct {
	pgURL     string
	Owner     string
	Repo      string
	CommentId int64

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool

	/*
	An additional `reactions` object in the review comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *PullsGetCommentReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsGetCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *PullsGetCommentReq) method() string {
	return "GET"
}

func (r *PullsGetCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsGetCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"comfort-fade":  r.ComfortFadePreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["comfort-fade"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsGetCommentReq) body() interface{} {
	return nil
}

func (r *PullsGetCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsGetCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsGetCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *PullsGetCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsGetCommentReq) Rel(link RelName, resp *PullsGetCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsGetCommentResponseBody is a response body for PullsGetComment

https://developer.github.com/v3/pulls/comments/#get-a-single-comment
*/
type PullsGetCommentResponseBody struct {
	components.PullRequestReviewComment
}

/*
PullsGetCommentResponse is a response for PullsGetComment

https://developer.github.com/v3/pulls/comments/#get-a-single-comment
*/
type PullsGetCommentResponse struct {
	response
	request *PullsGetCommentReq
	Data    *PullsGetCommentResponseBody
}

/*
PullsGetCommentsForReview performs requests for "pulls/get-comments-for-review"

Get comments for a single review.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments

https://developer.github.com/v3/pulls/reviews/#get-comments-for-a-single-review
*/
func (c *Client) PullsGetCommentsForReview(ctx context.Context, req *PullsGetCommentsForReviewReq, opt ...RequestOption) (*PullsGetCommentsForReviewResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsGetCommentsForReviewResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsGetCommentsForReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsGetCommentsForReviewReq is request data for Client.PullsGetCommentsForReview

https://developer.github.com/v3/pulls/reviews/#get-comments-for-a-single-review
*/
type PullsGetCommentsForReviewReq struct {
	pgURL      string
	Owner      string
	Repo       string
	PullNumber int64
	ReviewId   int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *PullsGetCommentsForReviewReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsGetCommentsForReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v/comments", r.Owner, r.Repo, r.PullNumber, r.ReviewId)
}

func (r *PullsGetCommentsForReviewReq) method() string {
	return "GET"
}

func (r *PullsGetCommentsForReviewReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsGetCommentsForReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsGetCommentsForReviewReq) body() interface{} {
	return nil
}

func (r *PullsGetCommentsForReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsGetCommentsForReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsGetCommentsForReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *PullsGetCommentsForReviewReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsGetCommentsForReviewReq) Rel(link RelName, resp *PullsGetCommentsForReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsGetCommentsForReviewResponseBody is a response body for PullsGetCommentsForReview

https://developer.github.com/v3/pulls/reviews/#get-comments-for-a-single-review
*/
type PullsGetCommentsForReviewResponseBody []struct {
	components.LegacyReviewComment
}

/*
PullsGetCommentsForReviewResponse is a response for PullsGetCommentsForReview

https://developer.github.com/v3/pulls/reviews/#get-comments-for-a-single-review
*/
type PullsGetCommentsForReviewResponse struct {
	response
	request *PullsGetCommentsForReviewReq
	Data    *PullsGetCommentsForReviewResponseBody
}

/*
PullsGetReview performs requests for "pulls/get-review"

Get a single review.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#get-a-single-review
*/
func (c *Client) PullsGetReview(ctx context.Context, req *PullsGetReviewReq, opt ...RequestOption) (*PullsGetReviewResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsGetReviewResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsGetReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsGetReviewReq is request data for Client.PullsGetReview

https://developer.github.com/v3/pulls/reviews/#get-a-single-review
*/
type PullsGetReviewReq struct {
	pgURL      string
	Owner      string
	Repo       string
	PullNumber int64
	ReviewId   int64
}

func (r *PullsGetReviewReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsGetReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v", r.Owner, r.Repo, r.PullNumber, r.ReviewId)
}

func (r *PullsGetReviewReq) method() string {
	return "GET"
}

func (r *PullsGetReviewReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsGetReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsGetReviewReq) body() interface{} {
	return nil
}

func (r *PullsGetReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsGetReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsGetReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *PullsGetReviewReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsGetReviewReq) Rel(link RelName, resp *PullsGetReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsGetReviewResponseBody is a response body for PullsGetReview

https://developer.github.com/v3/pulls/reviews/#get-a-single-review
*/
type PullsGetReviewResponseBody struct {
	components.PullRequestReview2
}

/*
PullsGetReviewResponse is a response for PullsGetReview

https://developer.github.com/v3/pulls/reviews/#get-a-single-review
*/
type PullsGetReviewResponse struct {
	response
	request *PullsGetReviewReq
	Data    *PullsGetReviewResponseBody
}

/*
PullsList performs requests for "pulls/list"

List pull requests.

  GET /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#list-pull-requests
*/
func (c *Client) PullsList(ctx context.Context, req *PullsListReq, opt ...RequestOption) (*PullsListResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsListResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsListResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListReq is request data for Client.PullsList

https://developer.github.com/v3/pulls/#list-pull-requests
*/
type PullsListReq struct {
	pgURL string
	Owner string
	Repo  string

	// Either `open`, `closed`, or `all` to filter by state.
	State *string

	/*
	Filter pulls by head user or head organization and branch name in the format of
	`user:ref-name` or `organization:ref-name`. For example:
	`github:new-script-format` or `octocat:test-branch`.
	*/
	Head *string

	// Filter pulls by base branch name. Example: `gh-pages`.
	Base *string

	/*
	What to sort results by. Can be either `created`, `updated`, `popularity`
	(comment count) or `long-running` (age, filtering by pulls updated in the last
	month).
	*/
	Sort *string

	/*
	The direction of the sort. Can be either `asc` or `desc`. Default: `desc` when
	sort is `created` or sort is not specified, otherwise `asc`.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *PullsListReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsListReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls", r.Owner, r.Repo)
}

func (r *PullsListReq) method() string {
	return "GET"
}

func (r *PullsListReq) urlQuery() url.Values {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Head != nil {
		query.Set("head", *r.Head)
	}
	if r.Base != nil {
		query.Set("base", *r.Base)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"sailor-v": r.SailorVPreview}
	if allPreviews {
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListReq) body() interface{} {
	return nil
}

func (r *PullsListReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *PullsListReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListReq) Rel(link RelName, resp *PullsListResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsListResponseBody is a response body for PullsList

https://developer.github.com/v3/pulls/#list-pull-requests
*/
type PullsListResponseBody []struct {
	components.PullRequestSimple
}

/*
PullsListResponse is a response for PullsList

https://developer.github.com/v3/pulls/#list-pull-requests
*/
type PullsListResponse struct {
	response
	request *PullsListReq
	Data    *PullsListResponseBody
}

/*
PullsListComments performs requests for "pulls/list-comments"

List comments on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#list-comments-on-a-pull-request
*/
func (c *Client) PullsListComments(ctx context.Context, req *PullsListCommentsReq, opt ...RequestOption) (*PullsListCommentsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsListCommentsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsListCommentsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListCommentsReq is request data for Client.PullsListComments

https://developer.github.com/v3/pulls/comments/#list-comments-on-a-pull-request
*/
type PullsListCommentsReq struct {
	pgURL      string
	Owner      string
	Repo       string
	PullNumber int64

	// Can be either `created` or `updated` comments.
	Sort *string

	// Can be either `asc` or `desc`. Ignored without `sort` parameter.
	Direction *string

	/*
	This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
	format: `YYYY-MM-DDTHH:MM:SSZ`. Only returns comments `updated` at or after this
	time.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool

	/*
	An additional `reactions` object in the review comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *PullsListCommentsReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsListCommentsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/comments", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsListCommentsReq) method() string {
	return "GET"
}

func (r *PullsListCommentsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListCommentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"comfort-fade":  r.ComfortFadePreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["comfort-fade"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListCommentsReq) body() interface{} {
	return nil
}

func (r *PullsListCommentsReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListCommentsReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListCommentsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *PullsListCommentsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListCommentsReq) Rel(link RelName, resp *PullsListCommentsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsListCommentsResponseBody is a response body for PullsListComments

https://developer.github.com/v3/pulls/comments/#list-comments-on-a-pull-request
*/
type PullsListCommentsResponseBody []struct {
	components.PullRequestReviewComment
}

/*
PullsListCommentsResponse is a response for PullsListComments

https://developer.github.com/v3/pulls/comments/#list-comments-on-a-pull-request
*/
type PullsListCommentsResponse struct {
	response
	request *PullsListCommentsReq
	Data    *PullsListCommentsResponseBody
}

/*
PullsListCommentsForRepo performs requests for "pulls/list-comments-for-repo"

List comments in a repository.

  GET /repos/{owner}/{repo}/pulls/comments

https://developer.github.com/v3/pulls/comments/#list-comments-in-a-repository
*/
func (c *Client) PullsListCommentsForRepo(ctx context.Context, req *PullsListCommentsForRepoReq, opt ...RequestOption) (*PullsListCommentsForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsListCommentsForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsListCommentsForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListCommentsForRepoReq is request data for Client.PullsListCommentsForRepo

https://developer.github.com/v3/pulls/comments/#list-comments-in-a-repository
*/
type PullsListCommentsForRepoReq struct {
	pgURL string
	Owner string
	Repo  string

	// Can be either `created` or `updated` comments.
	Sort *string

	// Can be either `asc` or `desc`. Ignored without `sort` parameter.
	Direction *string

	/*
	This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
	format: `YYYY-MM-DDTHH:MM:SSZ`. Only returns comments `updated` at or after this
	time.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool

	/*
	An additional `reactions` object in the review comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *PullsListCommentsForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsListCommentsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments", r.Owner, r.Repo)
}

func (r *PullsListCommentsForRepoReq) method() string {
	return "GET"
}

func (r *PullsListCommentsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListCommentsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"comfort-fade":  r.ComfortFadePreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["comfort-fade"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListCommentsForRepoReq) body() interface{} {
	return nil
}

func (r *PullsListCommentsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListCommentsForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListCommentsForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *PullsListCommentsForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListCommentsForRepoReq) Rel(link RelName, resp *PullsListCommentsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsListCommentsForRepoResponseBody is a response body for PullsListCommentsForRepo

https://developer.github.com/v3/pulls/comments/#list-comments-in-a-repository
*/
type PullsListCommentsForRepoResponseBody []struct {
	components.PullRequestReviewComment
}

/*
PullsListCommentsForRepoResponse is a response for PullsListCommentsForRepo

https://developer.github.com/v3/pulls/comments/#list-comments-in-a-repository
*/
type PullsListCommentsForRepoResponse struct {
	response
	request *PullsListCommentsForRepoReq
	Data    *PullsListCommentsForRepoResponseBody
}

/*
PullsListCommits performs requests for "pulls/list-commits"

List commits on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/commits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
func (c *Client) PullsListCommits(ctx context.Context, req *PullsListCommitsReq, opt ...RequestOption) (*PullsListCommitsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsListCommitsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsListCommitsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListCommitsReq is request data for Client.PullsListCommits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
type PullsListCommitsReq struct {
	pgURL      string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *PullsListCommitsReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsListCommitsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/commits", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsListCommitsReq) method() string {
	return "GET"
}

func (r *PullsListCommitsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListCommitsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListCommitsReq) body() interface{} {
	return nil
}

func (r *PullsListCommitsReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListCommitsReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListCommitsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *PullsListCommitsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListCommitsReq) Rel(link RelName, resp *PullsListCommitsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsListCommitsResponseBody is a response body for PullsListCommits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
type PullsListCommitsResponseBody []struct {
	components.SimpleCommit
}

/*
PullsListCommitsResponse is a response for PullsListCommits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
type PullsListCommitsResponse struct {
	response
	request *PullsListCommitsReq
	Data    *PullsListCommitsResponseBody
}

/*
PullsListFiles performs requests for "pulls/list-files"

List pull requests files.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/files

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
func (c *Client) PullsListFiles(ctx context.Context, req *PullsListFilesReq, opt ...RequestOption) (*PullsListFilesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsListFilesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsListFilesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListFilesReq is request data for Client.PullsListFiles

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
type PullsListFilesReq struct {
	pgURL      string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *PullsListFilesReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsListFilesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/files", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsListFilesReq) method() string {
	return "GET"
}

func (r *PullsListFilesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListFilesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListFilesReq) body() interface{} {
	return nil
}

func (r *PullsListFilesReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListFilesReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListFilesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *PullsListFilesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListFilesReq) Rel(link RelName, resp *PullsListFilesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsListFilesResponseBody is a response body for PullsListFiles

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
type PullsListFilesResponseBody []struct {
	components.DiffEntry
}

/*
PullsListFilesResponse is a response for PullsListFiles

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
type PullsListFilesResponse struct {
	response
	request *PullsListFilesReq
	Data    *PullsListFilesResponseBody
}

/*
PullsListReviewRequests performs requests for "pulls/list-review-requests"

List review requests.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#list-review-requests
*/
func (c *Client) PullsListReviewRequests(ctx context.Context, req *PullsListReviewRequestsReq, opt ...RequestOption) (*PullsListReviewRequestsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsListReviewRequestsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsListReviewRequestsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListReviewRequestsReq is request data for Client.PullsListReviewRequests

https://developer.github.com/v3/pulls/review_requests/#list-review-requests
*/
type PullsListReviewRequestsReq struct {
	pgURL      string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *PullsListReviewRequestsReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsListReviewRequestsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/requested_reviewers", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsListReviewRequestsReq) method() string {
	return "GET"
}

func (r *PullsListReviewRequestsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListReviewRequestsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListReviewRequestsReq) body() interface{} {
	return nil
}

func (r *PullsListReviewRequestsReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListReviewRequestsReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListReviewRequestsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *PullsListReviewRequestsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListReviewRequestsReq) Rel(link RelName, resp *PullsListReviewRequestsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsListReviewRequestsResponseBody is a response body for PullsListReviewRequests

https://developer.github.com/v3/pulls/review_requests/#list-review-requests
*/
type PullsListReviewRequestsResponseBody struct {
	components.SimplePullRequestReviewRequest
}

/*
PullsListReviewRequestsResponse is a response for PullsListReviewRequests

https://developer.github.com/v3/pulls/review_requests/#list-review-requests
*/
type PullsListReviewRequestsResponse struct {
	response
	request *PullsListReviewRequestsReq
	Data    *PullsListReviewRequestsResponseBody
}

/*
PullsListReviews performs requests for "pulls/list-reviews"

List reviews on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-on-a-pull-request
*/
func (c *Client) PullsListReviews(ctx context.Context, req *PullsListReviewsReq, opt ...RequestOption) (*PullsListReviewsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsListReviewsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsListReviewsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListReviewsReq is request data for Client.PullsListReviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-on-a-pull-request
*/
type PullsListReviewsReq struct {
	pgURL      string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *PullsListReviewsReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsListReviewsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsListReviewsReq) method() string {
	return "GET"
}

func (r *PullsListReviewsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListReviewsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListReviewsReq) body() interface{} {
	return nil
}

func (r *PullsListReviewsReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListReviewsReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListReviewsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *PullsListReviewsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListReviewsReq) Rel(link RelName, resp *PullsListReviewsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsListReviewsResponseBody is a response body for PullsListReviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-on-a-pull-request
*/
type PullsListReviewsResponseBody []struct {
	components.PullRequestReview2
}

/*
PullsListReviewsResponse is a response for PullsListReviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-on-a-pull-request
*/
type PullsListReviewsResponse struct {
	response
	request *PullsListReviewsReq
	Data    *PullsListReviewsResponseBody
}

/*
PullsMerge performs requests for "pulls/merge"

Merge a pull request (Merge Button).

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#merge-a-pull-request-merge-button
*/
func (c *Client) PullsMerge(ctx context.Context, req *PullsMergeReq, opt ...RequestOption) (*PullsMergeResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsMergeResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsMergeResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsMergeReq is request data for Client.PullsMerge

https://developer.github.com/v3/pulls/#merge-a-pull-request-merge-button
*/
type PullsMergeReq struct {
	pgURL       string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsMergeReqBody
}

func (r *PullsMergeReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsMergeReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/merge", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsMergeReq) method() string {
	return "PUT"
}

func (r *PullsMergeReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsMergeReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsMergeReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsMergeReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsMergeReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsMergeReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *PullsMergeReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsMergeReq) Rel(link RelName, resp *PullsMergeResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsMergeReqBody is a request body for pulls/merge

https://developer.github.com/v3/pulls/#merge-a-pull-request-merge-button
*/
type PullsMergeReqBody struct {

	// Extra detail to append to automatic commit message.
	CommitMessage *string `json:"commit_message,omitempty"`

	// Title for the automatic commit message.
	CommitTitle *string `json:"commit_title,omitempty"`

	/*
	   Merge method to use. Possible values are `merge`, `squash` or `rebase`. Default
	   is `merge`.
	*/
	MergeMethod *string `json:"merge_method,omitempty"`

	// SHA that pull request head must match to allow merge.
	Sha *string `json:"sha,omitempty"`
}

/*
PullsMergeResponseBody is a response body for PullsMerge

https://developer.github.com/v3/pulls/#merge-a-pull-request-merge-button
*/
type PullsMergeResponseBody struct {
	components.PullRequestMergeResult
}

/*
PullsMergeResponse is a response for PullsMerge

https://developer.github.com/v3/pulls/#merge-a-pull-request-merge-button
*/
type PullsMergeResponse struct {
	response
	request *PullsMergeReq
	Data    *PullsMergeResponseBody
}

/*
PullsSubmitReview performs requests for "pulls/submit-review"

Submit a pull request review.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events

https://developer.github.com/v3/pulls/reviews/#submit-a-pull-request-review
*/
func (c *Client) PullsSubmitReview(ctx context.Context, req *PullsSubmitReviewReq, opt ...RequestOption) (*PullsSubmitReviewResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsSubmitReviewResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsSubmitReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsSubmitReviewReq is request data for Client.PullsSubmitReview

https://developer.github.com/v3/pulls/reviews/#submit-a-pull-request-review
*/
type PullsSubmitReviewReq struct {
	pgURL       string
	Owner       string
	Repo        string
	PullNumber  int64
	ReviewId    int64
	RequestBody PullsSubmitReviewReqBody
}

func (r *PullsSubmitReviewReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsSubmitReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v/events", r.Owner, r.Repo, r.PullNumber, r.ReviewId)
}

func (r *PullsSubmitReviewReq) method() string {
	return "POST"
}

func (r *PullsSubmitReviewReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsSubmitReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsSubmitReviewReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsSubmitReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsSubmitReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsSubmitReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *PullsSubmitReviewReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsSubmitReviewReq) Rel(link RelName, resp *PullsSubmitReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsSubmitReviewReqBody is a request body for pulls/submit-review

https://developer.github.com/v3/pulls/reviews/#submit-a-pull-request-review
*/
type PullsSubmitReviewReqBody struct {

	// The body text of the pull request review
	Body *string `json:"body,omitempty"`

	/*
	   The review action you want to perform. The review actions include: `APPROVE`,
	   `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns
	   _HTTP 422 (Unrecognizable entity)_ and sets the review action state to
	   `PENDING`, which means you will need to re-submit the pull request review using
	   a review action.
	*/
	Event *string `json:"event"`
}

/*
PullsSubmitReviewResponseBody is a response body for PullsSubmitReview

https://developer.github.com/v3/pulls/reviews/#submit-a-pull-request-review
*/
type PullsSubmitReviewResponseBody struct {
	components.PullRequestReview2
}

/*
PullsSubmitReviewResponse is a response for PullsSubmitReview

https://developer.github.com/v3/pulls/reviews/#submit-a-pull-request-review
*/
type PullsSubmitReviewResponse struct {
	response
	request *PullsSubmitReviewReq
	Data    *PullsSubmitReviewResponseBody
}

/*
PullsUpdate performs requests for "pulls/update"

Update a pull request.

  PATCH /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
func (c *Client) PullsUpdate(ctx context.Context, req *PullsUpdateReq, opt ...RequestOption) (*PullsUpdateResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsUpdateResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsUpdateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsUpdateReq is request data for Client.PullsUpdate

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
type PullsUpdateReq struct {
	pgURL       string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsUpdateReqBody

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *PullsUpdateReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsUpdateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsUpdateReq) method() string {
	return "PATCH"
}

func (r *PullsUpdateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsUpdateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"sailor-v": r.SailorVPreview}
	if allPreviews {
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsUpdateReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsUpdateReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsUpdateReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsUpdateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *PullsUpdateReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsUpdateReq) Rel(link RelName, resp *PullsUpdateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsUpdateReqBody is a request body for pulls/update

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
type PullsUpdateReqBody struct {

	/*
	   The name of the branch you want your changes pulled into. This should be an
	   existing branch on the current repository. You cannot update the base branch on
	   a pull request to point to another repository.
	*/
	Base *string `json:"base,omitempty"`

	// The contents of the pull request.
	Body *string `json:"body,omitempty"`

	/*
	   Indicates whether [maintainers can
	   modify](https://help.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/)
	   the pull request.
	*/
	MaintainerCanModify *bool `json:"maintainer_can_modify,omitempty"`

	// State of this Pull Request. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the pull request.
	Title *string `json:"title,omitempty"`
}

/*
PullsUpdateResponseBody is a response body for PullsUpdate

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
type PullsUpdateResponseBody struct {
	components.PullRequest
}

/*
PullsUpdateResponse is a response for PullsUpdate

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
type PullsUpdateResponse struct {
	response
	request *PullsUpdateReq
	Data    *PullsUpdateResponseBody
}

/*
PullsUpdateBranch performs requests for "pulls/update-branch"

Update a pull request branch.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
func (c *Client) PullsUpdateBranch(ctx context.Context, req *PullsUpdateBranchReq, opt ...RequestOption) (*PullsUpdateBranchResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsUpdateBranchResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsUpdateBranchResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsUpdateBranchReq is request data for Client.PullsUpdateBranch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type PullsUpdateBranchReq struct {
	pgURL       string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsUpdateBranchReqBody

	/*
	Updating the pull request branch with latest upstream changes is currently
	available for developers to preview. To access this new endpoint during the
	preview period, you must set this to true.
	*/
	LydianPreview bool
}

func (r *PullsUpdateBranchReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsUpdateBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/update-branch", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsUpdateBranchReq) method() string {
	return "PUT"
}

func (r *PullsUpdateBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsUpdateBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"lydian": r.LydianPreview}
	if requiredPreviews {
		previewVals["lydian"] = true
	}
	if allPreviews {
		previewVals["lydian"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsUpdateBranchReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsUpdateBranchReq) dataStatuses() []int {
	return []int{202}
}

func (r *PullsUpdateBranchReq) validStatuses() []int {
	return []int{202}
}

func (r *PullsUpdateBranchReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *PullsUpdateBranchReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsUpdateBranchReq) Rel(link RelName, resp *PullsUpdateBranchResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsUpdateBranchReqBody is a request body for pulls/update-branch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type PullsUpdateBranchReqBody struct {

	/*
	   The expected SHA of the pull request's HEAD ref. This is the most recent commit
	   on the pull request's branch. If the expected SHA does not match the pull
	   request's HEAD, you will receive a `422 Unprocessable Entity` status. You can
	   use the "[List commits on a
	   repository](https://developer.github.com/v3/repos/commits/#list-commits-on-a-repository)"
	   endpoint to find the most recent commit SHA. Default: SHA of the pull request's
	   current HEAD ref.
	*/
	ExpectedHeadSha *string `json:"expected_head_sha,omitempty"`
}

/*
PullsUpdateBranchResponseBody is a response body for PullsUpdateBranch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type PullsUpdateBranchResponseBody struct {
	Message string `json:"message,omitempty"`
	Url     string `json:"url,omitempty"`
}

/*
PullsUpdateBranchResponse is a response for PullsUpdateBranch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type PullsUpdateBranchResponse struct {
	response
	request *PullsUpdateBranchReq
	Data    *PullsUpdateBranchResponseBody
}

/*
PullsUpdateComment performs requests for "pulls/update-comment"

Edit a comment.

  PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#edit-a-comment
*/
func (c *Client) PullsUpdateComment(ctx context.Context, req *PullsUpdateCommentReq, opt ...RequestOption) (*PullsUpdateCommentResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsUpdateCommentResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsUpdateCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsUpdateCommentReq is request data for Client.PullsUpdateComment

https://developer.github.com/v3/pulls/comments/#edit-a-comment
*/
type PullsUpdateCommentReq struct {
	pgURL       string
	Owner       string
	Repo        string
	CommentId   int64
	RequestBody PullsUpdateCommentReqBody

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool
}

func (r *PullsUpdateCommentReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsUpdateCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *PullsUpdateCommentReq) method() string {
	return "PATCH"
}

func (r *PullsUpdateCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsUpdateCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"comfort-fade": r.ComfortFadePreview}
	if allPreviews {
		previewVals["comfort-fade"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsUpdateCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsUpdateCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsUpdateCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsUpdateCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *PullsUpdateCommentReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsUpdateCommentReq) Rel(link RelName, resp *PullsUpdateCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsUpdateCommentReqBody is a request body for pulls/update-comment

https://developer.github.com/v3/pulls/comments/#edit-a-comment
*/
type PullsUpdateCommentReqBody struct {

	// The text of the reply to the review comment.
	Body *string `json:"body"`
}

/*
PullsUpdateCommentResponseBody is a response body for PullsUpdateComment

https://developer.github.com/v3/pulls/comments/#edit-a-comment
*/
type PullsUpdateCommentResponseBody struct {
	components.PullRequestReviewComment
}

/*
PullsUpdateCommentResponse is a response for PullsUpdateComment

https://developer.github.com/v3/pulls/comments/#edit-a-comment
*/
type PullsUpdateCommentResponse struct {
	response
	request *PullsUpdateCommentReq
	Data    *PullsUpdateCommentResponseBody
}

/*
PullsUpdateReview performs requests for "pulls/update-review"

Update a pull request review.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#update-a-pull-request-review
*/
func (c *Client) PullsUpdateReview(ctx context.Context, req *PullsUpdateReviewReq, opt ...RequestOption) (*PullsUpdateReviewResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &PullsUpdateReviewResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(PullsUpdateReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsUpdateReviewReq is request data for Client.PullsUpdateReview

https://developer.github.com/v3/pulls/reviews/#update-a-pull-request-review
*/
type PullsUpdateReviewReq struct {
	pgURL       string
	Owner       string
	Repo        string
	PullNumber  int64
	ReviewId    int64
	RequestBody PullsUpdateReviewReqBody
}

func (r *PullsUpdateReviewReq) pagingURL() string {
	return r.pgURL
}

func (r *PullsUpdateReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v", r.Owner, r.Repo, r.PullNumber, r.ReviewId)
}

func (r *PullsUpdateReviewReq) method() string {
	return "PUT"
}

func (r *PullsUpdateReviewReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsUpdateReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsUpdateReviewReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsUpdateReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsUpdateReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsUpdateReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *PullsUpdateReviewReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsUpdateReviewReq) Rel(link RelName, resp *PullsUpdateReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
PullsUpdateReviewReqBody is a request body for pulls/update-review

https://developer.github.com/v3/pulls/reviews/#update-a-pull-request-review
*/
type PullsUpdateReviewReqBody struct {

	// The body text of the pull request review.
	Body *string `json:"body"`
}

/*
PullsUpdateReviewResponseBody is a response body for PullsUpdateReview

https://developer.github.com/v3/pulls/reviews/#update-a-pull-request-review
*/
type PullsUpdateReviewResponseBody struct {
	components.PullRequestReview
}

/*
PullsUpdateReviewResponse is a response for PullsUpdateReview

https://developer.github.com/v3/pulls/reviews/#update-a-pull-request-review
*/
type PullsUpdateReviewResponse struct {
	response
	request *PullsUpdateReviewReq
	Data    *PullsUpdateReviewResponseBody
}
