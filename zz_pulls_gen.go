// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
PullsCheckIfMerged performs requests for "pulls/check-if-merged"

Check if a pull request has been merged.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#check-if-a-pull-request-has-been-merged
*/
func PullsCheckIfMerged(ctx context.Context, req *PullsCheckIfMergedReq, opt ...RequestOption) (*PullsCheckIfMergedResponse, error) {
	if req == nil {
		req = new(PullsCheckIfMergedReq)
	}
	resp := &PullsCheckIfMergedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCheckIfMerged performs requests for "pulls/check-if-merged"

Check if a pull request has been merged.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#check-if-a-pull-request-has-been-merged
*/
func (c Client) PullsCheckIfMerged(ctx context.Context, req *PullsCheckIfMergedReq, opt ...RequestOption) (*PullsCheckIfMergedResponse, error) {
	return PullsCheckIfMerged(ctx, req, append(c, opt...)...)
}

/*
PullsCheckIfMergedReq is request data for Client.PullsCheckIfMerged

https://developer.github.com/v3/pulls/#check-if-a-pull-request-has-been-merged
*/
type PullsCheckIfMergedReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64
}

func (r *PullsCheckIfMergedReq) url() string {
	return r._url
}

func (r *PullsCheckIfMergedReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/merge", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsCheckIfMergedReq) method() string {
	return "GET"
}

func (r *PullsCheckIfMergedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsCheckIfMergedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsCheckIfMergedReq) body() interface{} {
	return nil
}

func (r *PullsCheckIfMergedReq) dataStatuses() []int {
	return []int{}
}

func (r *PullsCheckIfMergedReq) validStatuses() []int {
	return []int{204}
}

func (r *PullsCheckIfMergedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// HTTPRequest builds an *http.Request
func (r *PullsCheckIfMergedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCheckIfMergedReq) Rel(link RelName, resp *PullsCheckIfMergedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsCheckIfMergedResponse is a response for PullsCheckIfMerged

https://developer.github.com/v3/pulls/#check-if-a-pull-request-has-been-merged
*/
type PullsCheckIfMergedResponse struct {
	response
	request *PullsCheckIfMergedReq
	Data    bool
}

/*
PullsCreate performs requests for "pulls/create"

Create a pull request.

  POST /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
func PullsCreate(ctx context.Context, req *PullsCreateReq, opt ...RequestOption) (*PullsCreateResponse, error) {
	if req == nil {
		req = new(PullsCreateReq)
	}
	resp := &PullsCreateResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsCreateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCreate performs requests for "pulls/create"

Create a pull request.

  POST /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
func (c Client) PullsCreate(ctx context.Context, req *PullsCreateReq, opt ...RequestOption) (*PullsCreateResponse, error) {
	return PullsCreate(ctx, req, append(c, opt...)...)
}

/*
PullsCreateReq is request data for Client.PullsCreate

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
type PullsCreateReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody PullsCreateReqBody

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *PullsCreateReq) url() string {
	return r._url
}

func (r *PullsCreateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls", r.Owner, r.Repo)
}

func (r *PullsCreateReq) method() string {
	return "POST"
}

func (r *PullsCreateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsCreateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"sailor-v": r.SailorVPreview}
	if allPreviews {
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsCreateReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsCreateReq) dataStatuses() []int {
	return []int{201}
}

func (r *PullsCreateReq) validStatuses() []int {
	return []int{201}
}

func (r *PullsCreateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *PullsCreateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCreateReq) Rel(link RelName, resp *PullsCreateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsCreateReqBody is a request body for pulls/create

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
type PullsCreateReqBody struct {

	/*
	   The name of the branch you want the changes pulled into. This should be an
	   existing branch on the current repository. You cannot submit a pull request to
	   one repository that requests a merge to a base of another repository.
	*/
	Base *string `json:"base"`

	// The contents of the pull request.
	Body *string `json:"body,omitempty"`

	/*
	   Indicates whether the pull request is a draft. See "[Draft Pull
	   Requests](https://help.github.com/en/articles/about-pull-requests#draft-pull-requests)"
	   in the GitHub Help documentation to learn more.
	*/
	Draft *bool `json:"draft,omitempty"`

	/*
	   The name of the branch where your changes are implemented. For cross-repository
	   pull requests in the same network, namespace `head` with a user like this:
	   `username:branch`.
	*/
	Head *string `json:"head"`

	/*
	   Indicates whether [maintainers can
	   modify](https://help.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/)
	   the pull request.
	*/
	MaintainerCanModify *bool `json:"maintainer_can_modify,omitempty"`

	// The title of the new pull request.
	Title *string `json:"title"`
}

/*
PullsCreateResponseBody is a response body for PullsCreate

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
type PullsCreateResponseBody components.PullRequest

/*
PullsCreateResponse is a response for PullsCreate

https://developer.github.com/v3/pulls/#create-a-pull-request
*/
type PullsCreateResponse struct {
	response
	request *PullsCreateReq
	Data    *PullsCreateResponseBody
}

/*
PullsCreateReplyForReviewComment performs requests for "pulls/create-reply-for-review-comment"

Create a reply for a review comment.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
func PullsCreateReplyForReviewComment(ctx context.Context, req *PullsCreateReplyForReviewCommentReq, opt ...RequestOption) (*PullsCreateReplyForReviewCommentResponse, error) {
	if req == nil {
		req = new(PullsCreateReplyForReviewCommentReq)
	}
	resp := &PullsCreateReplyForReviewCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsCreateReplyForReviewCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCreateReplyForReviewComment performs requests for "pulls/create-reply-for-review-comment"

Create a reply for a review comment.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
func (c Client) PullsCreateReplyForReviewComment(ctx context.Context, req *PullsCreateReplyForReviewCommentReq, opt ...RequestOption) (*PullsCreateReplyForReviewCommentResponse, error) {
	return PullsCreateReplyForReviewComment(ctx, req, append(c, opt...)...)
}

/*
PullsCreateReplyForReviewCommentReq is request data for Client.PullsCreateReplyForReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
type PullsCreateReplyForReviewCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	CommentId   int64
	RequestBody PullsCreateReplyForReviewCommentReqBody
}

func (r *PullsCreateReplyForReviewCommentReq) url() string {
	return r._url
}

func (r *PullsCreateReplyForReviewCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/comments/%v/replies", r.Owner, r.Repo, r.PullNumber, r.CommentId)
}

func (r *PullsCreateReplyForReviewCommentReq) method() string {
	return "POST"
}

func (r *PullsCreateReplyForReviewCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsCreateReplyForReviewCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsCreateReplyForReviewCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsCreateReplyForReviewCommentReq) dataStatuses() []int {
	return []int{201}
}

func (r *PullsCreateReplyForReviewCommentReq) validStatuses() []int {
	return []int{201}
}

func (r *PullsCreateReplyForReviewCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *PullsCreateReplyForReviewCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCreateReplyForReviewCommentReq) Rel(link RelName, resp *PullsCreateReplyForReviewCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsCreateReplyForReviewCommentReqBody is a request body for pulls/create-reply-for-review-comment

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
type PullsCreateReplyForReviewCommentReqBody struct {

	// The text of the review comment.
	Body *string `json:"body"`
}

/*
PullsCreateReplyForReviewCommentResponseBody is a response body for PullsCreateReplyForReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
type PullsCreateReplyForReviewCommentResponseBody components.PullRequestReviewComment

/*
PullsCreateReplyForReviewCommentResponse is a response for PullsCreateReplyForReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-reply-for-a-review-comment
*/
type PullsCreateReplyForReviewCommentResponse struct {
	response
	request *PullsCreateReplyForReviewCommentReq
	Data    *PullsCreateReplyForReviewCommentResponseBody
}

/*
PullsCreateReview performs requests for "pulls/create-review"

Create a review for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
func PullsCreateReview(ctx context.Context, req *PullsCreateReviewReq, opt ...RequestOption) (*PullsCreateReviewResponse, error) {
	if req == nil {
		req = new(PullsCreateReviewReq)
	}
	resp := &PullsCreateReviewResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsCreateReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCreateReview performs requests for "pulls/create-review"

Create a review for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
func (c Client) PullsCreateReview(ctx context.Context, req *PullsCreateReviewReq, opt ...RequestOption) (*PullsCreateReviewResponse, error) {
	return PullsCreateReview(ctx, req, append(c, opt...)...)
}

/*
PullsCreateReviewReq is request data for Client.PullsCreateReview

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
type PullsCreateReviewReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsCreateReviewReqBody
}

func (r *PullsCreateReviewReq) url() string {
	return r._url
}

func (r *PullsCreateReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsCreateReviewReq) method() string {
	return "POST"
}

func (r *PullsCreateReviewReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsCreateReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsCreateReviewReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsCreateReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsCreateReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsCreateReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *PullsCreateReviewReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCreateReviewReq) Rel(link RelName, resp *PullsCreateReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// PullsCreateReviewReqBodyComments is a value for PullsCreateReviewReqBody's Comments field
type PullsCreateReviewReqBodyComments struct {

	// Text of the review comment.
	Body *string `json:"body"`

	// The relative path to the file that necessitates a review comment.
	Path *string `json:"path"`

	/*
	   The position in the diff where you want to add a review comment. Note this value
	   is not the same as the line number in the file. For help finding the position
	   value, read the note below.
	*/
	Position *int64 `json:"position"`
}

/*
PullsCreateReviewReqBody is a request body for pulls/create-review

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
type PullsCreateReviewReqBody struct {

	/*
	   **Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event`
	   parameter. The body text of the pull request review.
	*/
	Body *string `json:"body,omitempty"`

	/*
	   Use the following table to specify the location, destination, and contents of
	   the draft review comment.
	*/
	Comments []PullsCreateReviewReqBodyComments `json:"comments,omitempty"`

	/*
	   The SHA of the commit that needs a review. Not using the latest commit SHA may
	   render your review comment outdated if a subsequent commit modifies the line you
	   specify as the `position`. Defaults to the most recent commit in the pull
	   request when you do not specify a value.
	*/
	CommitId *string `json:"commit_id,omitempty"`

	/*
	   The review action you want to perform. The review actions include: `APPROVE`,
	   `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review
	   action state to `PENDING`, which means you will need to [submit the pull request
	   review](https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request)
	   when you are ready.
	*/
	Event *string `json:"event,omitempty"`
}

/*
PullsCreateReviewResponseBody is a response body for PullsCreateReview

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
type PullsCreateReviewResponseBody components.PullRequestReview

/*
PullsCreateReviewResponse is a response for PullsCreateReview

https://developer.github.com/v3/pulls/reviews/#create-a-review-for-a-pull-request
*/
type PullsCreateReviewResponse struct {
	response
	request *PullsCreateReviewReq
	Data    *PullsCreateReviewResponseBody
}

/*
PullsCreateReviewComment performs requests for "pulls/create-review-comment"

Create a review comment for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
func PullsCreateReviewComment(ctx context.Context, req *PullsCreateReviewCommentReq, opt ...RequestOption) (*PullsCreateReviewCommentResponse, error) {
	if req == nil {
		req = new(PullsCreateReviewCommentReq)
	}
	resp := &PullsCreateReviewCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsCreateReviewCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsCreateReviewComment performs requests for "pulls/create-review-comment"

Create a review comment for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
func (c Client) PullsCreateReviewComment(ctx context.Context, req *PullsCreateReviewCommentReq, opt ...RequestOption) (*PullsCreateReviewCommentResponse, error) {
	return PullsCreateReviewComment(ctx, req, append(c, opt...)...)
}

/*
PullsCreateReviewCommentReq is request data for Client.PullsCreateReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
type PullsCreateReviewCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsCreateReviewCommentReqBody

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool
}

func (r *PullsCreateReviewCommentReq) url() string {
	return r._url
}

func (r *PullsCreateReviewCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/comments", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsCreateReviewCommentReq) method() string {
	return "POST"
}

func (r *PullsCreateReviewCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsCreateReviewCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"comfort-fade": r.ComfortFadePreview}
	if allPreviews {
		previewVals["comfort-fade"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsCreateReviewCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsCreateReviewCommentReq) dataStatuses() []int {
	return []int{201}
}

func (r *PullsCreateReviewCommentReq) validStatuses() []int {
	return []int{201}
}

func (r *PullsCreateReviewCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *PullsCreateReviewCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsCreateReviewCommentReq) Rel(link RelName, resp *PullsCreateReviewCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsCreateReviewCommentReqBody is a request body for pulls/create-review-comment

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
type PullsCreateReviewCommentReqBody struct {

	// The text of the review comment.
	Body *string `json:"body"`

	/*
	   The SHA of the commit needing a comment. Not using the latest commit SHA may
	   render your comment outdated if a subsequent commit modifies the line you
	   specify as the `position`.
	*/
	CommitId *string `json:"commit_id"`

	/*
	   **Required with `comfort-fade` preview**. The line of the blob in the pull
	   request diff that the comment applies to. For a multi-line comment, the last
	   line of the range that your comment applies to.
	*/
	Line *int64 `json:"line,omitempty"`

	// The relative path to the file that necessitates a comment.
	Path *string `json:"path"`

	/*
	   **Required without `comfort-fade` preview**. The position in the diff where you
	   want to add a review comment. Note this value is not the same as the line number
	   in the file. For help finding the position value, read the note above.
	*/
	Position *int64 `json:"position,omitempty"`

	/*
	   **Required with `comfort-fade` preview**. In a split diff view, the side of the
	   diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use
	   `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear
	   in green or unchanged lines that appear in white and are shown for context. For
	   a multi-line comment, side represents whether the last line of the comment range
	   is a deletion or addition. For more information, see "[Diff view
	   options](https://help.github.com/en/articles/about-comparing-branches-in-pull-requests#diff-view-options)".
	*/
	Side *string `json:"side,omitempty"`

	/*
	   **Required when using multi-line comments**. To create multi-line comments, you
	   must use the `comfort-fade` preview header. The `start_line` is the first line
	   in the pull request diff that your multi-line comment applies to. To learn more
	   about multi-line comments, see "[Commenting on a pull
	   request](https://help.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)".
	*/
	StartLine *int64 `json:"start_line,omitempty"`

	/*
	   **Required when using multi-line comments**. To create multi-line comments, you
	   must use the `comfort-fade` preview header. The `start_side` is the starting
	   side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn
	   more about multi-line comments, see "[Commenting on a pull
	   request](https://help.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)".
	   See `side` in this table for additional context.
	*/
	StartSide *string `json:"start_side,omitempty"`
}

/*
PullsCreateReviewCommentResponseBody is a response body for PullsCreateReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
type PullsCreateReviewCommentResponseBody components.PullRequestReviewComment

/*
PullsCreateReviewCommentResponse is a response for PullsCreateReviewComment

https://developer.github.com/v3/pulls/comments/#create-a-review-comment-for-a-pull-request
*/
type PullsCreateReviewCommentResponse struct {
	response
	request *PullsCreateReviewCommentReq
	Data    *PullsCreateReviewCommentResponseBody
}

/*
PullsDeletePendingReview performs requests for "pulls/delete-pending-review"

Delete a pending review for a pull request.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review-for-a-pull-request
*/
func PullsDeletePendingReview(ctx context.Context, req *PullsDeletePendingReviewReq, opt ...RequestOption) (*PullsDeletePendingReviewResponse, error) {
	if req == nil {
		req = new(PullsDeletePendingReviewReq)
	}
	resp := &PullsDeletePendingReviewResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsDeletePendingReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsDeletePendingReview performs requests for "pulls/delete-pending-review"

Delete a pending review for a pull request.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review-for-a-pull-request
*/
func (c Client) PullsDeletePendingReview(ctx context.Context, req *PullsDeletePendingReviewReq, opt ...RequestOption) (*PullsDeletePendingReviewResponse, error) {
	return PullsDeletePendingReview(ctx, req, append(c, opt...)...)
}

/*
PullsDeletePendingReviewReq is request data for Client.PullsDeletePendingReview

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review-for-a-pull-request
*/
type PullsDeletePendingReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64
	ReviewId   int64
}

func (r *PullsDeletePendingReviewReq) url() string {
	return r._url
}

func (r *PullsDeletePendingReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v", r.Owner, r.Repo, r.PullNumber, r.ReviewId)
}

func (r *PullsDeletePendingReviewReq) method() string {
	return "DELETE"
}

func (r *PullsDeletePendingReviewReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsDeletePendingReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsDeletePendingReviewReq) body() interface{} {
	return nil
}

func (r *PullsDeletePendingReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsDeletePendingReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsDeletePendingReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *PullsDeletePendingReviewReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsDeletePendingReviewReq) Rel(link RelName, resp *PullsDeletePendingReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsDeletePendingReviewResponseBody is a response body for PullsDeletePendingReview

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review-for-a-pull-request
*/
type PullsDeletePendingReviewResponseBody components.PullRequestReview2

/*
PullsDeletePendingReviewResponse is a response for PullsDeletePendingReview

https://developer.github.com/v3/pulls/reviews/#delete-a-pending-review-for-a-pull-request
*/
type PullsDeletePendingReviewResponse struct {
	response
	request *PullsDeletePendingReviewReq
	Data    *PullsDeletePendingReviewResponseBody
}

/*
PullsDeleteReviewComment performs requests for "pulls/delete-review-comment"

Delete a review comment for a pull request.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#delete-a-review-comment-for-a-pull-request
*/
func PullsDeleteReviewComment(ctx context.Context, req *PullsDeleteReviewCommentReq, opt ...RequestOption) (*PullsDeleteReviewCommentResponse, error) {
	if req == nil {
		req = new(PullsDeleteReviewCommentReq)
	}
	resp := &PullsDeleteReviewCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsDeleteReviewComment performs requests for "pulls/delete-review-comment"

Delete a review comment for a pull request.

  DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#delete-a-review-comment-for-a-pull-request
*/
func (c Client) PullsDeleteReviewComment(ctx context.Context, req *PullsDeleteReviewCommentReq, opt ...RequestOption) (*PullsDeleteReviewCommentResponse, error) {
	return PullsDeleteReviewComment(ctx, req, append(c, opt...)...)
}

/*
PullsDeleteReviewCommentReq is request data for Client.PullsDeleteReviewComment

https://developer.github.com/v3/pulls/comments/#delete-a-review-comment-for-a-pull-request
*/
type PullsDeleteReviewCommentReq struct {
	_url      string
	Owner     string
	Repo      string
	CommentId int64
}

func (r *PullsDeleteReviewCommentReq) url() string {
	return r._url
}

func (r *PullsDeleteReviewCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *PullsDeleteReviewCommentReq) method() string {
	return "DELETE"
}

func (r *PullsDeleteReviewCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsDeleteReviewCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsDeleteReviewCommentReq) body() interface{} {
	return nil
}

func (r *PullsDeleteReviewCommentReq) dataStatuses() []int {
	return []int{}
}

func (r *PullsDeleteReviewCommentReq) validStatuses() []int {
	return []int{204}
}

func (r *PullsDeleteReviewCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *PullsDeleteReviewCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsDeleteReviewCommentReq) Rel(link RelName, resp *PullsDeleteReviewCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsDeleteReviewCommentResponse is a response for PullsDeleteReviewComment

https://developer.github.com/v3/pulls/comments/#delete-a-review-comment-for-a-pull-request
*/
type PullsDeleteReviewCommentResponse struct {
	response
	request *PullsDeleteReviewCommentReq
}

/*
PullsDismissReview performs requests for "pulls/dismiss-review"

Dismiss a review for a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
func PullsDismissReview(ctx context.Context, req *PullsDismissReviewReq, opt ...RequestOption) (*PullsDismissReviewResponse, error) {
	if req == nil {
		req = new(PullsDismissReviewReq)
	}
	resp := &PullsDismissReviewResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsDismissReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsDismissReview performs requests for "pulls/dismiss-review"

Dismiss a review for a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
func (c Client) PullsDismissReview(ctx context.Context, req *PullsDismissReviewReq, opt ...RequestOption) (*PullsDismissReviewResponse, error) {
	return PullsDismissReview(ctx, req, append(c, opt...)...)
}

/*
PullsDismissReviewReq is request data for Client.PullsDismissReview

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
type PullsDismissReviewReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	ReviewId    int64
	RequestBody PullsDismissReviewReqBody
}

func (r *PullsDismissReviewReq) url() string {
	return r._url
}

func (r *PullsDismissReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v/dismissals", r.Owner, r.Repo, r.PullNumber, r.ReviewId)
}

func (r *PullsDismissReviewReq) method() string {
	return "PUT"
}

func (r *PullsDismissReviewReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsDismissReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsDismissReviewReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsDismissReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsDismissReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsDismissReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *PullsDismissReviewReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsDismissReviewReq) Rel(link RelName, resp *PullsDismissReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsDismissReviewReqBody is a request body for pulls/dismiss-review

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
type PullsDismissReviewReqBody struct {

	// The message for the pull request review dismissal
	Message *string `json:"message"`
}

/*
PullsDismissReviewResponseBody is a response body for PullsDismissReview

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
type PullsDismissReviewResponseBody components.PullRequestReview

/*
PullsDismissReviewResponse is a response for PullsDismissReview

https://developer.github.com/v3/pulls/reviews/#dismiss-a-review-for-a-pull-request
*/
type PullsDismissReviewResponse struct {
	response
	request *PullsDismissReviewReq
	Data    *PullsDismissReviewResponseBody
}

/*
PullsGet performs requests for "pulls/get"

Get a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#get-a-pull-request
*/
func PullsGet(ctx context.Context, req *PullsGetReq, opt ...RequestOption) (*PullsGetResponse, error) {
	if req == nil {
		req = new(PullsGetReq)
	}
	resp := &PullsGetResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsGetResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsGet performs requests for "pulls/get"

Get a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#get-a-pull-request
*/
func (c Client) PullsGet(ctx context.Context, req *PullsGetReq, opt ...RequestOption) (*PullsGetResponse, error) {
	return PullsGet(ctx, req, append(c, opt...)...)
}

/*
PullsGetReq is request data for Client.PullsGet

https://developer.github.com/v3/pulls/#get-a-pull-request
*/
type PullsGetReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *PullsGetReq) url() string {
	return r._url
}

func (r *PullsGetReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsGetReq) method() string {
	return "GET"
}

func (r *PullsGetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsGetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"sailor-v": r.SailorVPreview}
	if allPreviews {
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsGetReq) body() interface{} {
	return nil
}

func (r *PullsGetReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsGetReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsGetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *PullsGetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsGetReq) Rel(link RelName, resp *PullsGetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsGetResponseBody is a response body for PullsGet

https://developer.github.com/v3/pulls/#get-a-pull-request
*/
type PullsGetResponseBody components.PullRequest

/*
PullsGetResponse is a response for PullsGet

https://developer.github.com/v3/pulls/#get-a-pull-request
*/
type PullsGetResponse struct {
	response
	request *PullsGetReq
	Data    *PullsGetResponseBody
}

/*
PullsGetReview performs requests for "pulls/get-review"

Get a review for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#get-a-review-for-a-pull-request
*/
func PullsGetReview(ctx context.Context, req *PullsGetReviewReq, opt ...RequestOption) (*PullsGetReviewResponse, error) {
	if req == nil {
		req = new(PullsGetReviewReq)
	}
	resp := &PullsGetReviewResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsGetReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsGetReview performs requests for "pulls/get-review"

Get a review for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#get-a-review-for-a-pull-request
*/
func (c Client) PullsGetReview(ctx context.Context, req *PullsGetReviewReq, opt ...RequestOption) (*PullsGetReviewResponse, error) {
	return PullsGetReview(ctx, req, append(c, opt...)...)
}

/*
PullsGetReviewReq is request data for Client.PullsGetReview

https://developer.github.com/v3/pulls/reviews/#get-a-review-for-a-pull-request
*/
type PullsGetReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64
	ReviewId   int64
}

func (r *PullsGetReviewReq) url() string {
	return r._url
}

func (r *PullsGetReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v", r.Owner, r.Repo, r.PullNumber, r.ReviewId)
}

func (r *PullsGetReviewReq) method() string {
	return "GET"
}

func (r *PullsGetReviewReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsGetReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsGetReviewReq) body() interface{} {
	return nil
}

func (r *PullsGetReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsGetReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsGetReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *PullsGetReviewReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsGetReviewReq) Rel(link RelName, resp *PullsGetReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsGetReviewResponseBody is a response body for PullsGetReview

https://developer.github.com/v3/pulls/reviews/#get-a-review-for-a-pull-request
*/
type PullsGetReviewResponseBody components.PullRequestReview

/*
PullsGetReviewResponse is a response for PullsGetReview

https://developer.github.com/v3/pulls/reviews/#get-a-review-for-a-pull-request
*/
type PullsGetReviewResponse struct {
	response
	request *PullsGetReviewReq
	Data    *PullsGetReviewResponseBody
}

/*
PullsGetReviewComment performs requests for "pulls/get-review-comment"

Get a review comment for a pull request.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#get-a-review-comment-for-a-pull-request
*/
func PullsGetReviewComment(ctx context.Context, req *PullsGetReviewCommentReq, opt ...RequestOption) (*PullsGetReviewCommentResponse, error) {
	if req == nil {
		req = new(PullsGetReviewCommentReq)
	}
	resp := &PullsGetReviewCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsGetReviewCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsGetReviewComment performs requests for "pulls/get-review-comment"

Get a review comment for a pull request.

  GET /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#get-a-review-comment-for-a-pull-request
*/
func (c Client) PullsGetReviewComment(ctx context.Context, req *PullsGetReviewCommentReq, opt ...RequestOption) (*PullsGetReviewCommentResponse, error) {
	return PullsGetReviewComment(ctx, req, append(c, opt...)...)
}

/*
PullsGetReviewCommentReq is request data for Client.PullsGetReviewComment

https://developer.github.com/v3/pulls/comments/#get-a-review-comment-for-a-pull-request
*/
type PullsGetReviewCommentReq struct {
	_url      string
	Owner     string
	Repo      string
	CommentId int64

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *PullsGetReviewCommentReq) url() string {
	return r._url
}

func (r *PullsGetReviewCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *PullsGetReviewCommentReq) method() string {
	return "GET"
}

func (r *PullsGetReviewCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsGetReviewCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"comfort-fade":  r.ComfortFadePreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["comfort-fade"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsGetReviewCommentReq) body() interface{} {
	return nil
}

func (r *PullsGetReviewCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsGetReviewCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsGetReviewCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *PullsGetReviewCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsGetReviewCommentReq) Rel(link RelName, resp *PullsGetReviewCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsGetReviewCommentResponseBody is a response body for PullsGetReviewComment

https://developer.github.com/v3/pulls/comments/#get-a-review-comment-for-a-pull-request
*/
type PullsGetReviewCommentResponseBody components.PullRequestReviewComment

/*
PullsGetReviewCommentResponse is a response for PullsGetReviewComment

https://developer.github.com/v3/pulls/comments/#get-a-review-comment-for-a-pull-request
*/
type PullsGetReviewCommentResponse struct {
	response
	request *PullsGetReviewCommentReq
	Data    *PullsGetReviewCommentResponseBody
}

/*
PullsList performs requests for "pulls/list"

List pull requests.

  GET /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#list-pull-requests
*/
func PullsList(ctx context.Context, req *PullsListReq, opt ...RequestOption) (*PullsListResponse, error) {
	if req == nil {
		req = new(PullsListReq)
	}
	resp := &PullsListResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsListResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsList performs requests for "pulls/list"

List pull requests.

  GET /repos/{owner}/{repo}/pulls

https://developer.github.com/v3/pulls/#list-pull-requests
*/
func (c Client) PullsList(ctx context.Context, req *PullsListReq, opt ...RequestOption) (*PullsListResponse, error) {
	return PullsList(ctx, req, append(c, opt...)...)
}

/*
PullsListReq is request data for Client.PullsList

https://developer.github.com/v3/pulls/#list-pull-requests
*/
type PullsListReq struct {
	_url  string
	Owner string
	Repo  string

	// Either `open`, `closed`, or `all` to filter by state.
	State *string

	/*
	Filter pulls by head user or head organization and branch name in the format of
	`user:ref-name` or `organization:ref-name`. For example:
	`github:new-script-format` or `octocat:test-branch`.
	*/
	Head *string

	// Filter pulls by base branch name. Example: `gh-pages`.
	Base *string

	/*
	What to sort results by. Can be either `created`, `updated`, `popularity`
	(comment count) or `long-running` (age, filtering by pulls updated in the last
	month).
	*/
	Sort *string

	/*
	The direction of the sort. Can be either `asc` or `desc`. Default: `desc` when
	sort is `created` or sort is not specified, otherwise `asc`.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *PullsListReq) url() string {
	return r._url
}

func (r *PullsListReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls", r.Owner, r.Repo)
}

func (r *PullsListReq) method() string {
	return "GET"
}

func (r *PullsListReq) urlQuery() url.Values {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.Head != nil {
		query.Set("head", *r.Head)
	}
	if r.Base != nil {
		query.Set("base", *r.Base)
	}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"sailor-v": r.SailorVPreview}
	if allPreviews {
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListReq) body() interface{} {
	return nil
}

func (r *PullsListReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *PullsListReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListReq) Rel(link RelName, resp *PullsListResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListResponseBody is a response body for PullsList

https://developer.github.com/v3/pulls/#list-pull-requests
*/
type PullsListResponseBody []components.PullRequestSimple

/*
PullsListResponse is a response for PullsList

https://developer.github.com/v3/pulls/#list-pull-requests
*/
type PullsListResponse struct {
	response
	request *PullsListReq
	Data    *PullsListResponseBody
}

/*
PullsListCommentsForReview performs requests for "pulls/list-comments-for-review"

List comments for a pull request review.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments

https://developer.github.com/v3/pulls/reviews/#list-comments-for-a-pull-request-review
*/
func PullsListCommentsForReview(ctx context.Context, req *PullsListCommentsForReviewReq, opt ...RequestOption) (*PullsListCommentsForReviewResponse, error) {
	if req == nil {
		req = new(PullsListCommentsForReviewReq)
	}
	resp := &PullsListCommentsForReviewResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsListCommentsForReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListCommentsForReview performs requests for "pulls/list-comments-for-review"

List comments for a pull request review.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments

https://developer.github.com/v3/pulls/reviews/#list-comments-for-a-pull-request-review
*/
func (c Client) PullsListCommentsForReview(ctx context.Context, req *PullsListCommentsForReviewReq, opt ...RequestOption) (*PullsListCommentsForReviewResponse, error) {
	return PullsListCommentsForReview(ctx, req, append(c, opt...)...)
}

/*
PullsListCommentsForReviewReq is request data for Client.PullsListCommentsForReview

https://developer.github.com/v3/pulls/reviews/#list-comments-for-a-pull-request-review
*/
type PullsListCommentsForReviewReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64
	ReviewId   int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *PullsListCommentsForReviewReq) url() string {
	return r._url
}

func (r *PullsListCommentsForReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v/comments", r.Owner, r.Repo, r.PullNumber, r.ReviewId)
}

func (r *PullsListCommentsForReviewReq) method() string {
	return "GET"
}

func (r *PullsListCommentsForReviewReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListCommentsForReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListCommentsForReviewReq) body() interface{} {
	return nil
}

func (r *PullsListCommentsForReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListCommentsForReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListCommentsForReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *PullsListCommentsForReviewReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListCommentsForReviewReq) Rel(link RelName, resp *PullsListCommentsForReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListCommentsForReviewResponseBody is a response body for PullsListCommentsForReview

https://developer.github.com/v3/pulls/reviews/#list-comments-for-a-pull-request-review
*/
type PullsListCommentsForReviewResponseBody []components.LegacyReviewComment

/*
PullsListCommentsForReviewResponse is a response for PullsListCommentsForReview

https://developer.github.com/v3/pulls/reviews/#list-comments-for-a-pull-request-review
*/
type PullsListCommentsForReviewResponse struct {
	response
	request *PullsListCommentsForReviewReq
	Data    *PullsListCommentsForReviewResponseBody
}

/*
PullsListCommits performs requests for "pulls/list-commits"

List commits on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/commits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
func PullsListCommits(ctx context.Context, req *PullsListCommitsReq, opt ...RequestOption) (*PullsListCommitsResponse, error) {
	if req == nil {
		req = new(PullsListCommitsReq)
	}
	resp := &PullsListCommitsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsListCommitsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListCommits performs requests for "pulls/list-commits"

List commits on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/commits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
func (c Client) PullsListCommits(ctx context.Context, req *PullsListCommitsReq, opt ...RequestOption) (*PullsListCommitsResponse, error) {
	return PullsListCommits(ctx, req, append(c, opt...)...)
}

/*
PullsListCommitsReq is request data for Client.PullsListCommits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
type PullsListCommitsReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *PullsListCommitsReq) url() string {
	return r._url
}

func (r *PullsListCommitsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/commits", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsListCommitsReq) method() string {
	return "GET"
}

func (r *PullsListCommitsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListCommitsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListCommitsReq) body() interface{} {
	return nil
}

func (r *PullsListCommitsReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListCommitsReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListCommitsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *PullsListCommitsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListCommitsReq) Rel(link RelName, resp *PullsListCommitsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListCommitsResponseBody is a response body for PullsListCommits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
type PullsListCommitsResponseBody []components.SimpleCommit

/*
PullsListCommitsResponse is a response for PullsListCommits

https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
*/
type PullsListCommitsResponse struct {
	response
	request *PullsListCommitsReq
	Data    *PullsListCommitsResponseBody
}

/*
PullsListFiles performs requests for "pulls/list-files"

List pull requests files.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/files

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
func PullsListFiles(ctx context.Context, req *PullsListFilesReq, opt ...RequestOption) (*PullsListFilesResponse, error) {
	if req == nil {
		req = new(PullsListFilesReq)
	}
	resp := &PullsListFilesResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsListFilesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListFiles performs requests for "pulls/list-files"

List pull requests files.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/files

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
func (c Client) PullsListFiles(ctx context.Context, req *PullsListFilesReq, opt ...RequestOption) (*PullsListFilesResponse, error) {
	return PullsListFiles(ctx, req, append(c, opt...)...)
}

/*
PullsListFilesReq is request data for Client.PullsListFiles

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
type PullsListFilesReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *PullsListFilesReq) url() string {
	return r._url
}

func (r *PullsListFilesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/files", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsListFilesReq) method() string {
	return "GET"
}

func (r *PullsListFilesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListFilesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListFilesReq) body() interface{} {
	return nil
}

func (r *PullsListFilesReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListFilesReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListFilesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *PullsListFilesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListFilesReq) Rel(link RelName, resp *PullsListFilesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListFilesResponseBody is a response body for PullsListFiles

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
type PullsListFilesResponseBody []components.DiffEntry

/*
PullsListFilesResponse is a response for PullsListFiles

https://developer.github.com/v3/pulls/#list-pull-requests-files
*/
type PullsListFilesResponse struct {
	response
	request *PullsListFilesReq
	Data    *PullsListFilesResponseBody
}

/*
PullsListRequestedReviewers performs requests for "pulls/list-requested-reviewers"

List requested reviewers for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#list-requested-reviewers-for-a-pull-request
*/
func PullsListRequestedReviewers(ctx context.Context, req *PullsListRequestedReviewersReq, opt ...RequestOption) (*PullsListRequestedReviewersResponse, error) {
	if req == nil {
		req = new(PullsListRequestedReviewersReq)
	}
	resp := &PullsListRequestedReviewersResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsListRequestedReviewersResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListRequestedReviewers performs requests for "pulls/list-requested-reviewers"

List requested reviewers for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#list-requested-reviewers-for-a-pull-request
*/
func (c Client) PullsListRequestedReviewers(ctx context.Context, req *PullsListRequestedReviewersReq, opt ...RequestOption) (*PullsListRequestedReviewersResponse, error) {
	return PullsListRequestedReviewers(ctx, req, append(c, opt...)...)
}

/*
PullsListRequestedReviewersReq is request data for Client.PullsListRequestedReviewers

https://developer.github.com/v3/pulls/review_requests/#list-requested-reviewers-for-a-pull-request
*/
type PullsListRequestedReviewersReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *PullsListRequestedReviewersReq) url() string {
	return r._url
}

func (r *PullsListRequestedReviewersReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/requested_reviewers", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsListRequestedReviewersReq) method() string {
	return "GET"
}

func (r *PullsListRequestedReviewersReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListRequestedReviewersReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListRequestedReviewersReq) body() interface{} {
	return nil
}

func (r *PullsListRequestedReviewersReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListRequestedReviewersReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListRequestedReviewersReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *PullsListRequestedReviewersReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListRequestedReviewersReq) Rel(link RelName, resp *PullsListRequestedReviewersResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListRequestedReviewersResponseBody is a response body for PullsListRequestedReviewers

https://developer.github.com/v3/pulls/review_requests/#list-requested-reviewers-for-a-pull-request
*/
type PullsListRequestedReviewersResponseBody components.SimplePullRequestReviewRequest

/*
PullsListRequestedReviewersResponse is a response for PullsListRequestedReviewers

https://developer.github.com/v3/pulls/review_requests/#list-requested-reviewers-for-a-pull-request
*/
type PullsListRequestedReviewersResponse struct {
	response
	request *PullsListRequestedReviewersReq
	Data    *PullsListRequestedReviewersResponseBody
}

/*
PullsListReviewComments performs requests for "pulls/list-review-comments"

List review comments on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#list-review-comments-on-a-pull-request
*/
func PullsListReviewComments(ctx context.Context, req *PullsListReviewCommentsReq, opt ...RequestOption) (*PullsListReviewCommentsResponse, error) {
	if req == nil {
		req = new(PullsListReviewCommentsReq)
	}
	resp := &PullsListReviewCommentsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsListReviewCommentsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListReviewComments performs requests for "pulls/list-review-comments"

List review comments on a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/comments

https://developer.github.com/v3/pulls/comments/#list-review-comments-on-a-pull-request
*/
func (c Client) PullsListReviewComments(ctx context.Context, req *PullsListReviewCommentsReq, opt ...RequestOption) (*PullsListReviewCommentsResponse, error) {
	return PullsListReviewComments(ctx, req, append(c, opt...)...)
}

/*
PullsListReviewCommentsReq is request data for Client.PullsListReviewComments

https://developer.github.com/v3/pulls/comments/#list-review-comments-on-a-pull-request
*/
type PullsListReviewCommentsReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// Can be either `created` or `updated` comments.
	Sort *string

	// Can be either `asc` or `desc`. Ignored without `sort` parameter.
	Direction *string

	/*
	This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
	format: `YYYY-MM-DDTHH:MM:SSZ`. Only returns comments `updated` at or after this
	time.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *PullsListReviewCommentsReq) url() string {
	return r._url
}

func (r *PullsListReviewCommentsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/comments", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsListReviewCommentsReq) method() string {
	return "GET"
}

func (r *PullsListReviewCommentsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListReviewCommentsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"comfort-fade":  r.ComfortFadePreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["comfort-fade"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListReviewCommentsReq) body() interface{} {
	return nil
}

func (r *PullsListReviewCommentsReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListReviewCommentsReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListReviewCommentsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *PullsListReviewCommentsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListReviewCommentsReq) Rel(link RelName, resp *PullsListReviewCommentsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListReviewCommentsResponseBody is a response body for PullsListReviewComments

https://developer.github.com/v3/pulls/comments/#list-review-comments-on-a-pull-request
*/
type PullsListReviewCommentsResponseBody []components.PullRequestReviewComment

/*
PullsListReviewCommentsResponse is a response for PullsListReviewComments

https://developer.github.com/v3/pulls/comments/#list-review-comments-on-a-pull-request
*/
type PullsListReviewCommentsResponse struct {
	response
	request *PullsListReviewCommentsReq
	Data    *PullsListReviewCommentsResponseBody
}

/*
PullsListReviewCommentsForRepo performs requests for "pulls/list-review-comments-for-repo"

List review comments in a repository.

  GET /repos/{owner}/{repo}/pulls/comments

https://developer.github.com/v3/pulls/comments/#list-review-comments-in-a-repository
*/
func PullsListReviewCommentsForRepo(ctx context.Context, req *PullsListReviewCommentsForRepoReq, opt ...RequestOption) (*PullsListReviewCommentsForRepoResponse, error) {
	if req == nil {
		req = new(PullsListReviewCommentsForRepoReq)
	}
	resp := &PullsListReviewCommentsForRepoResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsListReviewCommentsForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListReviewCommentsForRepo performs requests for "pulls/list-review-comments-for-repo"

List review comments in a repository.

  GET /repos/{owner}/{repo}/pulls/comments

https://developer.github.com/v3/pulls/comments/#list-review-comments-in-a-repository
*/
func (c Client) PullsListReviewCommentsForRepo(ctx context.Context, req *PullsListReviewCommentsForRepoReq, opt ...RequestOption) (*PullsListReviewCommentsForRepoResponse, error) {
	return PullsListReviewCommentsForRepo(ctx, req, append(c, opt...)...)
}

/*
PullsListReviewCommentsForRepoReq is request data for Client.PullsListReviewCommentsForRepo

https://developer.github.com/v3/pulls/comments/#list-review-comments-in-a-repository
*/
type PullsListReviewCommentsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Can be either `created` or `updated` comments.
	Sort *string

	// Can be either `asc` or `desc`. Ignored without `sort` parameter.
	Direction *string

	/*
	This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
	format: `YYYY-MM-DDTHH:MM:SSZ`. Only returns comments `updated` at or after this
	time.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *PullsListReviewCommentsForRepoReq) url() string {
	return r._url
}

func (r *PullsListReviewCommentsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments", r.Owner, r.Repo)
}

func (r *PullsListReviewCommentsForRepoReq) method() string {
	return "GET"
}

func (r *PullsListReviewCommentsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Sort != nil {
		query.Set("sort", *r.Sort)
	}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListReviewCommentsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{
		"comfort-fade":  r.ComfortFadePreview,
		"squirrel-girl": r.SquirrelGirlPreview,
	}
	if allPreviews {
		previewVals["comfort-fade"] = true
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListReviewCommentsForRepoReq) body() interface{} {
	return nil
}

func (r *PullsListReviewCommentsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListReviewCommentsForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListReviewCommentsForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *PullsListReviewCommentsForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListReviewCommentsForRepoReq) Rel(link RelName, resp *PullsListReviewCommentsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListReviewCommentsForRepoResponseBody is a response body for PullsListReviewCommentsForRepo

https://developer.github.com/v3/pulls/comments/#list-review-comments-in-a-repository
*/
type PullsListReviewCommentsForRepoResponseBody []components.PullRequestReviewComment

/*
PullsListReviewCommentsForRepoResponse is a response for PullsListReviewCommentsForRepo

https://developer.github.com/v3/pulls/comments/#list-review-comments-in-a-repository
*/
type PullsListReviewCommentsForRepoResponse struct {
	response
	request *PullsListReviewCommentsForRepoReq
	Data    *PullsListReviewCommentsForRepoResponseBody
}

/*
PullsListReviews performs requests for "pulls/list-reviews"

List reviews for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-for-a-pull-request
*/
func PullsListReviews(ctx context.Context, req *PullsListReviewsReq, opt ...RequestOption) (*PullsListReviewsResponse, error) {
	if req == nil {
		req = new(PullsListReviewsReq)
	}
	resp := &PullsListReviewsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsListReviewsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsListReviews performs requests for "pulls/list-reviews"

List reviews for a pull request.

  GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-for-a-pull-request
*/
func (c Client) PullsListReviews(ctx context.Context, req *PullsListReviewsReq, opt ...RequestOption) (*PullsListReviewsResponse, error) {
	return PullsListReviews(ctx, req, append(c, opt...)...)
}

/*
PullsListReviewsReq is request data for Client.PullsListReviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-for-a-pull-request
*/
type PullsListReviewsReq struct {
	_url       string
	Owner      string
	Repo       string
	PullNumber int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *PullsListReviewsReq) url() string {
	return r._url
}

func (r *PullsListReviewsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsListReviewsReq) method() string {
	return "GET"
}

func (r *PullsListReviewsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *PullsListReviewsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsListReviewsReq) body() interface{} {
	return nil
}

func (r *PullsListReviewsReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsListReviewsReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsListReviewsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *PullsListReviewsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsListReviewsReq) Rel(link RelName, resp *PullsListReviewsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsListReviewsResponseBody is a response body for PullsListReviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-for-a-pull-request
*/
type PullsListReviewsResponseBody []components.PullRequestReview

/*
PullsListReviewsResponse is a response for PullsListReviews

https://developer.github.com/v3/pulls/reviews/#list-reviews-for-a-pull-request
*/
type PullsListReviewsResponse struct {
	response
	request *PullsListReviewsReq
	Data    *PullsListReviewsResponseBody
}

/*
PullsMerge performs requests for "pulls/merge"

Merge a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
func PullsMerge(ctx context.Context, req *PullsMergeReq, opt ...RequestOption) (*PullsMergeResponse, error) {
	if req == nil {
		req = new(PullsMergeReq)
	}
	resp := &PullsMergeResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsMergeResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsMerge performs requests for "pulls/merge"

Merge a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
func (c Client) PullsMerge(ctx context.Context, req *PullsMergeReq, opt ...RequestOption) (*PullsMergeResponse, error) {
	return PullsMerge(ctx, req, append(c, opt...)...)
}

/*
PullsMergeReq is request data for Client.PullsMerge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
type PullsMergeReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsMergeReqBody
}

func (r *PullsMergeReq) url() string {
	return r._url
}

func (r *PullsMergeReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/merge", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsMergeReq) method() string {
	return "PUT"
}

func (r *PullsMergeReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsMergeReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsMergeReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsMergeReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsMergeReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsMergeReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *PullsMergeReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsMergeReq) Rel(link RelName, resp *PullsMergeResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsMergeReqBody is a request body for pulls/merge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
type PullsMergeReqBody struct {

	// Extra detail to append to automatic commit message.
	CommitMessage *string `json:"commit_message,omitempty"`

	// Title for the automatic commit message.
	CommitTitle *string `json:"commit_title,omitempty"`

	/*
	   Merge method to use. Possible values are `merge`, `squash` or `rebase`. Default
	   is `merge`.
	*/
	MergeMethod *string `json:"merge_method,omitempty"`

	// SHA that pull request head must match to allow merge.
	Sha *string `json:"sha,omitempty"`
}

/*
PullsMergeResponseBody is a response body for PullsMerge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
type PullsMergeResponseBody components.PullRequestMergeResult

/*
PullsMergeResponse is a response for PullsMerge

https://developer.github.com/v3/pulls/#merge-a-pull-request
*/
type PullsMergeResponse struct {
	response
	request *PullsMergeReq
	Data    *PullsMergeResponseBody
}

/*
PullsRemoveRequestedReviewers performs requests for "pulls/remove-requested-reviewers"

Remove requested reviewers from a pull request.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request
*/
func PullsRemoveRequestedReviewers(ctx context.Context, req *PullsRemoveRequestedReviewersReq, opt ...RequestOption) (*PullsRemoveRequestedReviewersResponse, error) {
	if req == nil {
		req = new(PullsRemoveRequestedReviewersReq)
	}
	resp := &PullsRemoveRequestedReviewersResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsRemoveRequestedReviewers performs requests for "pulls/remove-requested-reviewers"

Remove requested reviewers from a pull request.

  DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request
*/
func (c Client) PullsRemoveRequestedReviewers(ctx context.Context, req *PullsRemoveRequestedReviewersReq, opt ...RequestOption) (*PullsRemoveRequestedReviewersResponse, error) {
	return PullsRemoveRequestedReviewers(ctx, req, append(c, opt...)...)
}

/*
PullsRemoveRequestedReviewersReq is request data for Client.PullsRemoveRequestedReviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request
*/
type PullsRemoveRequestedReviewersReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsRemoveRequestedReviewersReqBody
}

func (r *PullsRemoveRequestedReviewersReq) url() string {
	return r._url
}

func (r *PullsRemoveRequestedReviewersReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/requested_reviewers", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsRemoveRequestedReviewersReq) method() string {
	return "DELETE"
}

func (r *PullsRemoveRequestedReviewersReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsRemoveRequestedReviewersReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsRemoveRequestedReviewersReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsRemoveRequestedReviewersReq) dataStatuses() []int {
	return []int{}
}

func (r *PullsRemoveRequestedReviewersReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsRemoveRequestedReviewersReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *PullsRemoveRequestedReviewersReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsRemoveRequestedReviewersReq) Rel(link RelName, resp *PullsRemoveRequestedReviewersResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsRemoveRequestedReviewersReqBody is a request body for pulls/remove-requested-reviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request
*/
type PullsRemoveRequestedReviewersReqBody struct {

	// An array of user `login`s that will be removed.
	Reviewers []string `json:"reviewers,omitempty"`

	// An array of team `slug`s that will be removed.
	TeamReviewers []string `json:"team_reviewers,omitempty"`
}

/*
PullsRemoveRequestedReviewersResponse is a response for PullsRemoveRequestedReviewers

https://developer.github.com/v3/pulls/review_requests/#remove-requested-reviewers-from-a-pull-request
*/
type PullsRemoveRequestedReviewersResponse struct {
	response
	request *PullsRemoveRequestedReviewersReq
}

/*
PullsRequestReviewers performs requests for "pulls/request-reviewers"

Request reviewers for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
func PullsRequestReviewers(ctx context.Context, req *PullsRequestReviewersReq, opt ...RequestOption) (*PullsRequestReviewersResponse, error) {
	if req == nil {
		req = new(PullsRequestReviewersReq)
	}
	resp := &PullsRequestReviewersResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsRequestReviewersResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsRequestReviewers performs requests for "pulls/request-reviewers"

Request reviewers for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
func (c Client) PullsRequestReviewers(ctx context.Context, req *PullsRequestReviewersReq, opt ...RequestOption) (*PullsRequestReviewersResponse, error) {
	return PullsRequestReviewers(ctx, req, append(c, opt...)...)
}

/*
PullsRequestReviewersReq is request data for Client.PullsRequestReviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
type PullsRequestReviewersReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsRequestReviewersReqBody
}

func (r *PullsRequestReviewersReq) url() string {
	return r._url
}

func (r *PullsRequestReviewersReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/requested_reviewers", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsRequestReviewersReq) method() string {
	return "POST"
}

func (r *PullsRequestReviewersReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsRequestReviewersReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsRequestReviewersReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsRequestReviewersReq) dataStatuses() []int {
	return []int{201}
}

func (r *PullsRequestReviewersReq) validStatuses() []int {
	return []int{201}
}

func (r *PullsRequestReviewersReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *PullsRequestReviewersReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsRequestReviewersReq) Rel(link RelName, resp *PullsRequestReviewersResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsRequestReviewersReqBody is a request body for pulls/request-reviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
type PullsRequestReviewersReqBody struct {

	// An array of user `login`s that will be requested.
	Reviewers []string `json:"reviewers,omitempty"`

	// An array of team `slug`s that will be requested.
	TeamReviewers []string `json:"team_reviewers,omitempty"`
}

/*
PullsRequestReviewersResponseBody is a response body for PullsRequestReviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
type PullsRequestReviewersResponseBody components.PullRequestReviewRequest

/*
PullsRequestReviewersResponse is a response for PullsRequestReviewers

https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request
*/
type PullsRequestReviewersResponse struct {
	response
	request *PullsRequestReviewersReq
	Data    *PullsRequestReviewersResponseBody
}

/*
PullsSubmitReview performs requests for "pulls/submit-review"

Submit a review for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
func PullsSubmitReview(ctx context.Context, req *PullsSubmitReviewReq, opt ...RequestOption) (*PullsSubmitReviewResponse, error) {
	if req == nil {
		req = new(PullsSubmitReviewReq)
	}
	resp := &PullsSubmitReviewResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsSubmitReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsSubmitReview performs requests for "pulls/submit-review"

Submit a review for a pull request.

  POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
func (c Client) PullsSubmitReview(ctx context.Context, req *PullsSubmitReviewReq, opt ...RequestOption) (*PullsSubmitReviewResponse, error) {
	return PullsSubmitReview(ctx, req, append(c, opt...)...)
}

/*
PullsSubmitReviewReq is request data for Client.PullsSubmitReview

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
type PullsSubmitReviewReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	ReviewId    int64
	RequestBody PullsSubmitReviewReqBody
}

func (r *PullsSubmitReviewReq) url() string {
	return r._url
}

func (r *PullsSubmitReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v/events", r.Owner, r.Repo, r.PullNumber, r.ReviewId)
}

func (r *PullsSubmitReviewReq) method() string {
	return "POST"
}

func (r *PullsSubmitReviewReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsSubmitReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsSubmitReviewReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsSubmitReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsSubmitReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsSubmitReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *PullsSubmitReviewReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsSubmitReviewReq) Rel(link RelName, resp *PullsSubmitReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsSubmitReviewReqBody is a request body for pulls/submit-review

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
type PullsSubmitReviewReqBody struct {

	// The body text of the pull request review
	Body *string `json:"body,omitempty"`

	/*
	   The review action you want to perform. The review actions include: `APPROVE`,
	   `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns
	   _HTTP 422 (Unrecognizable entity)_ and sets the review action state to
	   `PENDING`, which means you will need to re-submit the pull request review using
	   a review action.
	*/
	Event *string `json:"event"`
}

/*
PullsSubmitReviewResponseBody is a response body for PullsSubmitReview

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
type PullsSubmitReviewResponseBody components.PullRequestReview

/*
PullsSubmitReviewResponse is a response for PullsSubmitReview

https://developer.github.com/v3/pulls/reviews/#submit-a-review-for-a-pull-request
*/
type PullsSubmitReviewResponse struct {
	response
	request *PullsSubmitReviewReq
	Data    *PullsSubmitReviewResponseBody
}

/*
PullsUpdate performs requests for "pulls/update"

Update a pull request.

  PATCH /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
func PullsUpdate(ctx context.Context, req *PullsUpdateReq, opt ...RequestOption) (*PullsUpdateResponse, error) {
	if req == nil {
		req = new(PullsUpdateReq)
	}
	resp := &PullsUpdateResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsUpdateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsUpdate performs requests for "pulls/update"

Update a pull request.

  PATCH /repos/{owner}/{repo}/pulls/{pull_number}

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
func (c Client) PullsUpdate(ctx context.Context, req *PullsUpdateReq, opt ...RequestOption) (*PullsUpdateResponse, error) {
	return PullsUpdate(ctx, req, append(c, opt...)...)
}

/*
PullsUpdateReq is request data for Client.PullsUpdate

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
type PullsUpdateReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsUpdateReqBody

	/*
	You can now use the REST API to add a reason when you lock an issue, and you
	will see lock reasons in responses that include issues or pull requests. You
	will also see lock reasons in `locked` events. This feature is currently
	available for developers to preview. See the [blog
	post](https://developer.github.com/changes/2018-01-10-lock-reason-api-preview)
	for full details. To access this feature, you must set this to true.
	*/
	SailorVPreview bool
}

func (r *PullsUpdateReq) url() string {
	return r._url
}

func (r *PullsUpdateReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsUpdateReq) method() string {
	return "PATCH"
}

func (r *PullsUpdateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsUpdateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"sailor-v": r.SailorVPreview}
	if allPreviews {
		previewVals["sailor-v"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsUpdateReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsUpdateReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsUpdateReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsUpdateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *PullsUpdateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsUpdateReq) Rel(link RelName, resp *PullsUpdateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsUpdateReqBody is a request body for pulls/update

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
type PullsUpdateReqBody struct {

	/*
	   The name of the branch you want your changes pulled into. This should be an
	   existing branch on the current repository. You cannot update the base branch on
	   a pull request to point to another repository.
	*/
	Base *string `json:"base,omitempty"`

	// The contents of the pull request.
	Body *string `json:"body,omitempty"`

	/*
	   Indicates whether [maintainers can
	   modify](https://help.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/)
	   the pull request.
	*/
	MaintainerCanModify *bool `json:"maintainer_can_modify,omitempty"`

	// State of this Pull Request. Either `open` or `closed`.
	State *string `json:"state,omitempty"`

	// The title of the pull request.
	Title *string `json:"title,omitempty"`
}

/*
PullsUpdateResponseBody is a response body for PullsUpdate

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
type PullsUpdateResponseBody components.PullRequest

/*
PullsUpdateResponse is a response for PullsUpdate

https://developer.github.com/v3/pulls/#update-a-pull-request
*/
type PullsUpdateResponse struct {
	response
	request *PullsUpdateReq
	Data    *PullsUpdateResponseBody
}

/*
PullsUpdateBranch performs requests for "pulls/update-branch"

Update a pull request branch.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
func PullsUpdateBranch(ctx context.Context, req *PullsUpdateBranchReq, opt ...RequestOption) (*PullsUpdateBranchResponse, error) {
	if req == nil {
		req = new(PullsUpdateBranchReq)
	}
	resp := &PullsUpdateBranchResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsUpdateBranchResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsUpdateBranch performs requests for "pulls/update-branch"

Update a pull request branch.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
func (c Client) PullsUpdateBranch(ctx context.Context, req *PullsUpdateBranchReq, opt ...RequestOption) (*PullsUpdateBranchResponse, error) {
	return PullsUpdateBranch(ctx, req, append(c, opt...)...)
}

/*
PullsUpdateBranchReq is request data for Client.PullsUpdateBranch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type PullsUpdateBranchReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	RequestBody PullsUpdateBranchReqBody

	/*
	Updating the pull request branch with latest upstream changes is currently
	available for developers to preview. To access this new endpoint during the
	preview period, you must set this to true.
	*/
	LydianPreview bool
}

func (r *PullsUpdateBranchReq) url() string {
	return r._url
}

func (r *PullsUpdateBranchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/update-branch", r.Owner, r.Repo, r.PullNumber)
}

func (r *PullsUpdateBranchReq) method() string {
	return "PUT"
}

func (r *PullsUpdateBranchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsUpdateBranchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"lydian": r.LydianPreview}
	if requiredPreviews {
		previewVals["lydian"] = true
	}
	if allPreviews {
		previewVals["lydian"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsUpdateBranchReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsUpdateBranchReq) dataStatuses() []int {
	return []int{202}
}

func (r *PullsUpdateBranchReq) validStatuses() []int {
	return []int{202}
}

func (r *PullsUpdateBranchReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *PullsUpdateBranchReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsUpdateBranchReq) Rel(link RelName, resp *PullsUpdateBranchResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsUpdateBranchReqBody is a request body for pulls/update-branch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type PullsUpdateBranchReqBody struct {

	/*
	   The expected SHA of the pull request's HEAD ref. This is the most recent commit
	   on the pull request's branch. If the expected SHA does not match the pull
	   request's HEAD, you will receive a `422 Unprocessable Entity` status. You can
	   use the "[List
	   commits](https://developer.github.com/v3/repos/commits/#list-commits)" endpoint
	   to find the most recent commit SHA. Default: SHA of the pull request's current
	   HEAD ref.
	*/
	ExpectedHeadSha *string `json:"expected_head_sha,omitempty"`
}

/*
PullsUpdateBranchResponseBody is a response body for PullsUpdateBranch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type PullsUpdateBranchResponseBody struct {
	Message string `json:"message,omitempty"`
	Url     string `json:"url,omitempty"`
}

/*
PullsUpdateBranchResponse is a response for PullsUpdateBranch

https://developer.github.com/v3/pulls/#update-a-pull-request-branch
*/
type PullsUpdateBranchResponse struct {
	response
	request *PullsUpdateBranchReq
	Data    *PullsUpdateBranchResponseBody
}

/*
PullsUpdateReview performs requests for "pulls/update-review"

Update a review for a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
func PullsUpdateReview(ctx context.Context, req *PullsUpdateReviewReq, opt ...RequestOption) (*PullsUpdateReviewResponse, error) {
	if req == nil {
		req = new(PullsUpdateReviewReq)
	}
	resp := &PullsUpdateReviewResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsUpdateReviewResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsUpdateReview performs requests for "pulls/update-review"

Update a review for a pull request.

  PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
func (c Client) PullsUpdateReview(ctx context.Context, req *PullsUpdateReviewReq, opt ...RequestOption) (*PullsUpdateReviewResponse, error) {
	return PullsUpdateReview(ctx, req, append(c, opt...)...)
}

/*
PullsUpdateReviewReq is request data for Client.PullsUpdateReview

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
type PullsUpdateReviewReq struct {
	_url        string
	Owner       string
	Repo        string
	PullNumber  int64
	ReviewId    int64
	RequestBody PullsUpdateReviewReqBody
}

func (r *PullsUpdateReviewReq) url() string {
	return r._url
}

func (r *PullsUpdateReviewReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/%v/reviews/%v", r.Owner, r.Repo, r.PullNumber, r.ReviewId)
}

func (r *PullsUpdateReviewReq) method() string {
	return "PUT"
}

func (r *PullsUpdateReviewReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsUpdateReviewReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsUpdateReviewReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsUpdateReviewReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsUpdateReviewReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsUpdateReviewReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *PullsUpdateReviewReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsUpdateReviewReq) Rel(link RelName, resp *PullsUpdateReviewResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsUpdateReviewReqBody is a request body for pulls/update-review

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
type PullsUpdateReviewReqBody struct {

	// The body text of the pull request review.
	Body *string `json:"body"`
}

/*
PullsUpdateReviewResponseBody is a response body for PullsUpdateReview

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
type PullsUpdateReviewResponseBody components.PullRequestReview

/*
PullsUpdateReviewResponse is a response for PullsUpdateReview

https://developer.github.com/v3/pulls/reviews/#update-a-review-for-a-pull-request
*/
type PullsUpdateReviewResponse struct {
	response
	request *PullsUpdateReviewReq
	Data    *PullsUpdateReviewResponseBody
}

/*
PullsUpdateReviewComment performs requests for "pulls/update-review-comment"

Update a review comment for a pull request.

  PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
func PullsUpdateReviewComment(ctx context.Context, req *PullsUpdateReviewCommentReq, opt ...RequestOption) (*PullsUpdateReviewCommentResponse, error) {
	if req == nil {
		req = new(PullsUpdateReviewCommentReq)
	}
	resp := &PullsUpdateReviewCommentResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(PullsUpdateReviewCommentResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
PullsUpdateReviewComment performs requests for "pulls/update-review-comment"

Update a review comment for a pull request.

  PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
func (c Client) PullsUpdateReviewComment(ctx context.Context, req *PullsUpdateReviewCommentReq, opt ...RequestOption) (*PullsUpdateReviewCommentResponse, error) {
	return PullsUpdateReviewComment(ctx, req, append(c, opt...)...)
}

/*
PullsUpdateReviewCommentReq is request data for Client.PullsUpdateReviewComment

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
type PullsUpdateReviewCommentReq struct {
	_url        string
	Owner       string
	Repo        string
	CommentId   int64
	RequestBody PullsUpdateReviewCommentReqBody

	/*
	Multi-line comments in a pull request diff is currently available for developers
	to preview. To access the new response fields during the preview period, you
	must set this to true.
	*/
	ComfortFadePreview bool
}

func (r *PullsUpdateReviewCommentReq) url() string {
	return r._url
}

func (r *PullsUpdateReviewCommentReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/pulls/comments/%v", r.Owner, r.Repo, r.CommentId)
}

func (r *PullsUpdateReviewCommentReq) method() string {
	return "PATCH"
}

func (r *PullsUpdateReviewCommentReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *PullsUpdateReviewCommentReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"comfort-fade": r.ComfortFadePreview}
	if allPreviews {
		previewVals["comfort-fade"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *PullsUpdateReviewCommentReq) body() interface{} {
	return r.RequestBody
}

func (r *PullsUpdateReviewCommentReq) dataStatuses() []int {
	return []int{200}
}

func (r *PullsUpdateReviewCommentReq) validStatuses() []int {
	return []int{200}
}

func (r *PullsUpdateReviewCommentReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *PullsUpdateReviewCommentReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *PullsUpdateReviewCommentReq) Rel(link RelName, resp *PullsUpdateReviewCommentResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
PullsUpdateReviewCommentReqBody is a request body for pulls/update-review-comment

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
type PullsUpdateReviewCommentReqBody struct {

	// The text of the reply to the review comment.
	Body *string `json:"body"`
}

/*
PullsUpdateReviewCommentResponseBody is a response body for PullsUpdateReviewComment

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
type PullsUpdateReviewCommentResponseBody components.PullRequestReviewComment

/*
PullsUpdateReviewCommentResponse is a response for PullsUpdateReviewComment

https://developer.github.com/v3/pulls/comments/#update-a-review-comment-for-a-pull-request
*/
type PullsUpdateReviewCommentResponse struct {
	response
	request *PullsUpdateReviewCommentReq
	Data    *PullsUpdateReviewCommentResponseBody
}
