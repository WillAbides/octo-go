// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
UsersAddEmails performs requests for "users/add-emails"

Add email address(es).

  POST /user/emails

https://developer.github.com/v3/users/emails/#add-email-addresses
*/
func UsersAddEmails(ctx context.Context, req *UsersAddEmailsReq, opt ...RequestOption) (*UsersAddEmailsResponse, error) {
	if req == nil {
		req = new(UsersAddEmailsReq)
	}
	resp := &UsersAddEmailsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersAddEmailsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersAddEmails performs requests for "users/add-emails"

Add email address(es).

  POST /user/emails

https://developer.github.com/v3/users/emails/#add-email-addresses
*/
func (c Client) UsersAddEmails(ctx context.Context, req *UsersAddEmailsReq, opt ...RequestOption) (*UsersAddEmailsResponse, error) {
	return UsersAddEmails(ctx, req, append(c, opt...)...)
}

/*
UsersAddEmailsReq is request data for Client.UsersAddEmails

https://developer.github.com/v3/users/emails/#add-email-addresses
*/
type UsersAddEmailsReq struct {
	_url        string
	RequestBody UsersAddEmailsReqBody
}

func (r *UsersAddEmailsReq) url() string {
	return r._url
}

func (r *UsersAddEmailsReq) urlPath() string {
	return fmt.Sprintf("/user/emails")
}

func (r *UsersAddEmailsReq) method() string {
	return "POST"
}

func (r *UsersAddEmailsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersAddEmailsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersAddEmailsReq) body() interface{} {
	return r.RequestBody
}

func (r *UsersAddEmailsReq) dataStatuses() []int {
	return []int{201}
}

func (r *UsersAddEmailsReq) validStatuses() []int {
	return []int{201}
}

func (r *UsersAddEmailsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *UsersAddEmailsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersAddEmailsReq) Rel(link RelName, resp *UsersAddEmailsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersAddEmailsReqBody is a request body for users/add-emails

https://developer.github.com/v3/users/emails/#add-email-addresses
*/
type UsersAddEmailsReqBody struct {

	/*
	   Adds one or more email addresses to your GitHub account. Must contain at least
	   one email address. **Note:** Alternatively, you can pass a single email address
	   or an `array` of emails addresses directly, but we recommend that you pass an
	   object using the `emails` key.
	*/
	Emails []string `json:"emails"`
}

/*
UsersAddEmailsResponseBody is a response body for UsersAddEmails

https://developer.github.com/v3/users/emails/#add-email-addresses
*/
type UsersAddEmailsResponseBody []struct {
	components.Email
}

/*
UsersAddEmailsResponse is a response for UsersAddEmails

https://developer.github.com/v3/users/emails/#add-email-addresses
*/
type UsersAddEmailsResponse struct {
	response
	request *UsersAddEmailsReq
	Data    *UsersAddEmailsResponseBody
}

/*
UsersBlock performs requests for "users/block"

Block a user.

  PUT /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#block-a-user
*/
func UsersBlock(ctx context.Context, req *UsersBlockReq, opt ...RequestOption) (*UsersBlockResponse, error) {
	if req == nil {
		req = new(UsersBlockReq)
	}
	resp := &UsersBlockResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersBlock performs requests for "users/block"

Block a user.

  PUT /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#block-a-user
*/
func (c Client) UsersBlock(ctx context.Context, req *UsersBlockReq, opt ...RequestOption) (*UsersBlockResponse, error) {
	return UsersBlock(ctx, req, append(c, opt...)...)
}

/*
UsersBlockReq is request data for Client.UsersBlock

https://developer.github.com/v3/users/blocking/#block-a-user
*/
type UsersBlockReq struct {
	_url     string
	Username string
}

func (r *UsersBlockReq) url() string {
	return r._url
}

func (r *UsersBlockReq) urlPath() string {
	return fmt.Sprintf("/user/blocks/%v", r.Username)
}

func (r *UsersBlockReq) method() string {
	return "PUT"
}

func (r *UsersBlockReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersBlockReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersBlockReq) body() interface{} {
	return nil
}

func (r *UsersBlockReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersBlockReq) validStatuses() []int {
	return []int{204}
}

func (r *UsersBlockReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersBlockReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersBlockReq) Rel(link RelName, resp *UsersBlockResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersBlockResponse is a response for UsersBlock

https://developer.github.com/v3/users/blocking/#block-a-user
*/
type UsersBlockResponse struct {
	response
	request *UsersBlockReq
}

/*
UsersCheckBlocked performs requests for "users/check-blocked"

Check whether you've blocked a user.

  GET /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#check-whether-youve-blocked-a-user
*/
func UsersCheckBlocked(ctx context.Context, req *UsersCheckBlockedReq, opt ...RequestOption) (*UsersCheckBlockedResponse, error) {
	if req == nil {
		req = new(UsersCheckBlockedReq)
	}
	resp := &UsersCheckBlockedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCheckBlocked performs requests for "users/check-blocked"

Check whether you've blocked a user.

  GET /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#check-whether-youve-blocked-a-user
*/
func (c Client) UsersCheckBlocked(ctx context.Context, req *UsersCheckBlockedReq, opt ...RequestOption) (*UsersCheckBlockedResponse, error) {
	return UsersCheckBlocked(ctx, req, append(c, opt...)...)
}

/*
UsersCheckBlockedReq is request data for Client.UsersCheckBlocked

https://developer.github.com/v3/users/blocking/#check-whether-youve-blocked-a-user
*/
type UsersCheckBlockedReq struct {
	_url     string
	Username string
}

func (r *UsersCheckBlockedReq) url() string {
	return r._url
}

func (r *UsersCheckBlockedReq) urlPath() string {
	return fmt.Sprintf("/user/blocks/%v", r.Username)
}

func (r *UsersCheckBlockedReq) method() string {
	return "GET"
}

func (r *UsersCheckBlockedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersCheckBlockedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersCheckBlockedReq) body() interface{} {
	return nil
}

func (r *UsersCheckBlockedReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersCheckBlockedReq) validStatuses() []int {
	return []int{204}
}

func (r *UsersCheckBlockedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// HTTPRequest builds an *http.Request
func (r *UsersCheckBlockedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCheckBlockedReq) Rel(link RelName, resp *UsersCheckBlockedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCheckBlockedResponse is a response for UsersCheckBlocked

https://developer.github.com/v3/users/blocking/#check-whether-youve-blocked-a-user
*/
type UsersCheckBlockedResponse struct {
	response
	request *UsersCheckBlockedReq
	Data    bool
}

/*
UsersCheckFollowing performs requests for "users/check-following"

Check if you are following a user.

  GET /user/following/{username}

https://developer.github.com/v3/users/followers/#check-if-you-are-following-a-user
*/
func UsersCheckFollowing(ctx context.Context, req *UsersCheckFollowingReq, opt ...RequestOption) (*UsersCheckFollowingResponse, error) {
	if req == nil {
		req = new(UsersCheckFollowingReq)
	}
	resp := &UsersCheckFollowingResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCheckFollowing performs requests for "users/check-following"

Check if you are following a user.

  GET /user/following/{username}

https://developer.github.com/v3/users/followers/#check-if-you-are-following-a-user
*/
func (c Client) UsersCheckFollowing(ctx context.Context, req *UsersCheckFollowingReq, opt ...RequestOption) (*UsersCheckFollowingResponse, error) {
	return UsersCheckFollowing(ctx, req, append(c, opt...)...)
}

/*
UsersCheckFollowingReq is request data for Client.UsersCheckFollowing

https://developer.github.com/v3/users/followers/#check-if-you-are-following-a-user
*/
type UsersCheckFollowingReq struct {
	_url     string
	Username string
}

func (r *UsersCheckFollowingReq) url() string {
	return r._url
}

func (r *UsersCheckFollowingReq) urlPath() string {
	return fmt.Sprintf("/user/following/%v", r.Username)
}

func (r *UsersCheckFollowingReq) method() string {
	return "GET"
}

func (r *UsersCheckFollowingReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersCheckFollowingReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersCheckFollowingReq) body() interface{} {
	return nil
}

func (r *UsersCheckFollowingReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersCheckFollowingReq) validStatuses() []int {
	return []int{204}
}

func (r *UsersCheckFollowingReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// HTTPRequest builds an *http.Request
func (r *UsersCheckFollowingReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCheckFollowingReq) Rel(link RelName, resp *UsersCheckFollowingResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCheckFollowingResponse is a response for UsersCheckFollowing

https://developer.github.com/v3/users/followers/#check-if-you-are-following-a-user
*/
type UsersCheckFollowingResponse struct {
	response
	request *UsersCheckFollowingReq
	Data    bool
}

/*
UsersCheckFollowingForUser performs requests for "users/check-following-for-user"

Check if one user follows another.

  GET /users/{username}/following/{target_user}

https://developer.github.com/v3/users/followers/#check-if-one-user-follows-another
*/
func UsersCheckFollowingForUser(ctx context.Context, req *UsersCheckFollowingForUserReq, opt ...RequestOption) (*UsersCheckFollowingForUserResponse, error) {
	if req == nil {
		req = new(UsersCheckFollowingForUserReq)
	}
	resp := &UsersCheckFollowingForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCheckFollowingForUser performs requests for "users/check-following-for-user"

Check if one user follows another.

  GET /users/{username}/following/{target_user}

https://developer.github.com/v3/users/followers/#check-if-one-user-follows-another
*/
func (c Client) UsersCheckFollowingForUser(ctx context.Context, req *UsersCheckFollowingForUserReq, opt ...RequestOption) (*UsersCheckFollowingForUserResponse, error) {
	return UsersCheckFollowingForUser(ctx, req, append(c, opt...)...)
}

/*
UsersCheckFollowingForUserReq is request data for Client.UsersCheckFollowingForUser

https://developer.github.com/v3/users/followers/#check-if-one-user-follows-another
*/
type UsersCheckFollowingForUserReq struct {
	_url       string
	Username   string
	TargetUser string
}

func (r *UsersCheckFollowingForUserReq) url() string {
	return r._url
}

func (r *UsersCheckFollowingForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/following/%v", r.Username, r.TargetUser)
}

func (r *UsersCheckFollowingForUserReq) method() string {
	return "GET"
}

func (r *UsersCheckFollowingForUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersCheckFollowingForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersCheckFollowingForUserReq) body() interface{} {
	return nil
}

func (r *UsersCheckFollowingForUserReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersCheckFollowingForUserReq) validStatuses() []int {
	return []int{204}
}

func (r *UsersCheckFollowingForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// HTTPRequest builds an *http.Request
func (r *UsersCheckFollowingForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCheckFollowingForUserReq) Rel(link RelName, resp *UsersCheckFollowingForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCheckFollowingForUserResponse is a response for UsersCheckFollowingForUser

https://developer.github.com/v3/users/followers/#check-if-one-user-follows-another
*/
type UsersCheckFollowingForUserResponse struct {
	response
	request *UsersCheckFollowingForUserReq
	Data    bool
}

/*
UsersCreateGpgKey performs requests for "users/create-gpg-key"

Create a GPG key.

  POST /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key
*/
func UsersCreateGpgKey(ctx context.Context, req *UsersCreateGpgKeyReq, opt ...RequestOption) (*UsersCreateGpgKeyResponse, error) {
	if req == nil {
		req = new(UsersCreateGpgKeyReq)
	}
	resp := &UsersCreateGpgKeyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersCreateGpgKeyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCreateGpgKey performs requests for "users/create-gpg-key"

Create a GPG key.

  POST /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key
*/
func (c Client) UsersCreateGpgKey(ctx context.Context, req *UsersCreateGpgKeyReq, opt ...RequestOption) (*UsersCreateGpgKeyResponse, error) {
	return UsersCreateGpgKey(ctx, req, append(c, opt...)...)
}

/*
UsersCreateGpgKeyReq is request data for Client.UsersCreateGpgKey

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key
*/
type UsersCreateGpgKeyReq struct {
	_url        string
	RequestBody UsersCreateGpgKeyReqBody
}

func (r *UsersCreateGpgKeyReq) url() string {
	return r._url
}

func (r *UsersCreateGpgKeyReq) urlPath() string {
	return fmt.Sprintf("/user/gpg_keys")
}

func (r *UsersCreateGpgKeyReq) method() string {
	return "POST"
}

func (r *UsersCreateGpgKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersCreateGpgKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersCreateGpgKeyReq) body() interface{} {
	return r.RequestBody
}

func (r *UsersCreateGpgKeyReq) dataStatuses() []int {
	return []int{201}
}

func (r *UsersCreateGpgKeyReq) validStatuses() []int {
	return []int{201}
}

func (r *UsersCreateGpgKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *UsersCreateGpgKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCreateGpgKeyReq) Rel(link RelName, resp *UsersCreateGpgKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCreateGpgKeyReqBody is a request body for users/create-gpg-key

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key
*/
type UsersCreateGpgKeyReqBody struct {

	/*
	   Your GPG key, generated in ASCII-armored format. See "[Generating a new GPG
	   key](https://help.github.com/articles/generating-a-new-gpg-key/)" for help
	   creating a GPG key.
	*/
	ArmoredPublicKey *string `json:"armored_public_key,omitempty"`
}

/*
UsersCreateGpgKeyResponseBody is a response body for UsersCreateGpgKey

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key
*/
type UsersCreateGpgKeyResponseBody struct {
	components.GpgKey
}

/*
UsersCreateGpgKeyResponse is a response for UsersCreateGpgKey

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key
*/
type UsersCreateGpgKeyResponse struct {
	response
	request *UsersCreateGpgKeyReq
	Data    *UsersCreateGpgKeyResponseBody
}

/*
UsersCreatePublicKey performs requests for "users/create-public-key"

Create a public key.

  POST /user/keys

https://developer.github.com/v3/users/keys/#create-a-public-key
*/
func UsersCreatePublicKey(ctx context.Context, req *UsersCreatePublicKeyReq, opt ...RequestOption) (*UsersCreatePublicKeyResponse, error) {
	if req == nil {
		req = new(UsersCreatePublicKeyReq)
	}
	resp := &UsersCreatePublicKeyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersCreatePublicKeyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCreatePublicKey performs requests for "users/create-public-key"

Create a public key.

  POST /user/keys

https://developer.github.com/v3/users/keys/#create-a-public-key
*/
func (c Client) UsersCreatePublicKey(ctx context.Context, req *UsersCreatePublicKeyReq, opt ...RequestOption) (*UsersCreatePublicKeyResponse, error) {
	return UsersCreatePublicKey(ctx, req, append(c, opt...)...)
}

/*
UsersCreatePublicKeyReq is request data for Client.UsersCreatePublicKey

https://developer.github.com/v3/users/keys/#create-a-public-key
*/
type UsersCreatePublicKeyReq struct {
	_url        string
	RequestBody UsersCreatePublicKeyReqBody
}

func (r *UsersCreatePublicKeyReq) url() string {
	return r._url
}

func (r *UsersCreatePublicKeyReq) urlPath() string {
	return fmt.Sprintf("/user/keys")
}

func (r *UsersCreatePublicKeyReq) method() string {
	return "POST"
}

func (r *UsersCreatePublicKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersCreatePublicKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersCreatePublicKeyReq) body() interface{} {
	return r.RequestBody
}

func (r *UsersCreatePublicKeyReq) dataStatuses() []int {
	return []int{201}
}

func (r *UsersCreatePublicKeyReq) validStatuses() []int {
	return []int{201}
}

func (r *UsersCreatePublicKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *UsersCreatePublicKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCreatePublicKeyReq) Rel(link RelName, resp *UsersCreatePublicKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCreatePublicKeyReqBody is a request body for users/create-public-key

https://developer.github.com/v3/users/keys/#create-a-public-key
*/
type UsersCreatePublicKeyReqBody struct {

	/*
	   The public SSH key to add to your GitHub account. See "[Generating a new SSH
	   key](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/)"
	   for guidance on how to create a public SSH key.
	*/
	Key *string `json:"key,omitempty"`

	/*
	   A descriptive name for the new key. Use a name that will help you recognize this
	   key in your GitHub account. For example, if you're using a personal Mac, you
	   might call this key "Personal MacBook Air".
	*/
	Title *string `json:"title,omitempty"`
}

/*
UsersCreatePublicKeyResponseBody is a response body for UsersCreatePublicKey

https://developer.github.com/v3/users/keys/#create-a-public-key
*/
type UsersCreatePublicKeyResponseBody struct {
	components.ActionsPublicKey
}

/*
UsersCreatePublicKeyResponse is a response for UsersCreatePublicKey

https://developer.github.com/v3/users/keys/#create-a-public-key
*/
type UsersCreatePublicKeyResponse struct {
	response
	request *UsersCreatePublicKeyReq
	Data    *UsersCreatePublicKeyResponseBody
}

/*
UsersDeleteEmails performs requests for "users/delete-emails"

Delete email address(es).

  DELETE /user/emails

https://developer.github.com/v3/users/emails/#delete-email-addresses
*/
func UsersDeleteEmails(ctx context.Context, req *UsersDeleteEmailsReq, opt ...RequestOption) (*UsersDeleteEmailsResponse, error) {
	if req == nil {
		req = new(UsersDeleteEmailsReq)
	}
	resp := &UsersDeleteEmailsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersDeleteEmails performs requests for "users/delete-emails"

Delete email address(es).

  DELETE /user/emails

https://developer.github.com/v3/users/emails/#delete-email-addresses
*/
func (c Client) UsersDeleteEmails(ctx context.Context, req *UsersDeleteEmailsReq, opt ...RequestOption) (*UsersDeleteEmailsResponse, error) {
	return UsersDeleteEmails(ctx, req, append(c, opt...)...)
}

/*
UsersDeleteEmailsReq is request data for Client.UsersDeleteEmails

https://developer.github.com/v3/users/emails/#delete-email-addresses
*/
type UsersDeleteEmailsReq struct {
	_url        string
	RequestBody UsersDeleteEmailsReqBody
}

func (r *UsersDeleteEmailsReq) url() string {
	return r._url
}

func (r *UsersDeleteEmailsReq) urlPath() string {
	return fmt.Sprintf("/user/emails")
}

func (r *UsersDeleteEmailsReq) method() string {
	return "DELETE"
}

func (r *UsersDeleteEmailsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersDeleteEmailsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersDeleteEmailsReq) body() interface{} {
	return r.RequestBody
}

func (r *UsersDeleteEmailsReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersDeleteEmailsReq) validStatuses() []int {
	return []int{204}
}

func (r *UsersDeleteEmailsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *UsersDeleteEmailsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersDeleteEmailsReq) Rel(link RelName, resp *UsersDeleteEmailsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersDeleteEmailsReqBody is a request body for users/delete-emails

https://developer.github.com/v3/users/emails/#delete-email-addresses
*/
type UsersDeleteEmailsReqBody struct {

	/*
	   Deletes one or more email addresses from your GitHub account. Must contain at
	   least one email address. **Note:** Alternatively, you can pass a single email
	   address or an `array` of emails addresses directly, but we recommend that you
	   pass an object using the `emails` key.
	*/
	Emails []string `json:"emails"`
}

/*
UsersDeleteEmailsResponse is a response for UsersDeleteEmails

https://developer.github.com/v3/users/emails/#delete-email-addresses
*/
type UsersDeleteEmailsResponse struct {
	response
	request *UsersDeleteEmailsReq
}

/*
UsersDeleteGpgKey performs requests for "users/delete-gpg-key"

Delete a GPG key.

  DELETE /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key
*/
func UsersDeleteGpgKey(ctx context.Context, req *UsersDeleteGpgKeyReq, opt ...RequestOption) (*UsersDeleteGpgKeyResponse, error) {
	if req == nil {
		req = new(UsersDeleteGpgKeyReq)
	}
	resp := &UsersDeleteGpgKeyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersDeleteGpgKey performs requests for "users/delete-gpg-key"

Delete a GPG key.

  DELETE /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key
*/
func (c Client) UsersDeleteGpgKey(ctx context.Context, req *UsersDeleteGpgKeyReq, opt ...RequestOption) (*UsersDeleteGpgKeyResponse, error) {
	return UsersDeleteGpgKey(ctx, req, append(c, opt...)...)
}

/*
UsersDeleteGpgKeyReq is request data for Client.UsersDeleteGpgKey

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key
*/
type UsersDeleteGpgKeyReq struct {
	_url     string
	GpgKeyId int64
}

func (r *UsersDeleteGpgKeyReq) url() string {
	return r._url
}

func (r *UsersDeleteGpgKeyReq) urlPath() string {
	return fmt.Sprintf("/user/gpg_keys/%v", r.GpgKeyId)
}

func (r *UsersDeleteGpgKeyReq) method() string {
	return "DELETE"
}

func (r *UsersDeleteGpgKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersDeleteGpgKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersDeleteGpgKeyReq) body() interface{} {
	return nil
}

func (r *UsersDeleteGpgKeyReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersDeleteGpgKeyReq) validStatuses() []int {
	return []int{204}
}

func (r *UsersDeleteGpgKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersDeleteGpgKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersDeleteGpgKeyReq) Rel(link RelName, resp *UsersDeleteGpgKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersDeleteGpgKeyResponse is a response for UsersDeleteGpgKey

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key
*/
type UsersDeleteGpgKeyResponse struct {
	response
	request *UsersDeleteGpgKeyReq
}

/*
UsersDeletePublicKey performs requests for "users/delete-public-key"

Delete a public key.

  DELETE /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#delete-a-public-key
*/
func UsersDeletePublicKey(ctx context.Context, req *UsersDeletePublicKeyReq, opt ...RequestOption) (*UsersDeletePublicKeyResponse, error) {
	if req == nil {
		req = new(UsersDeletePublicKeyReq)
	}
	resp := &UsersDeletePublicKeyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersDeletePublicKey performs requests for "users/delete-public-key"

Delete a public key.

  DELETE /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#delete-a-public-key
*/
func (c Client) UsersDeletePublicKey(ctx context.Context, req *UsersDeletePublicKeyReq, opt ...RequestOption) (*UsersDeletePublicKeyResponse, error) {
	return UsersDeletePublicKey(ctx, req, append(c, opt...)...)
}

/*
UsersDeletePublicKeyReq is request data for Client.UsersDeletePublicKey

https://developer.github.com/v3/users/keys/#delete-a-public-key
*/
type UsersDeletePublicKeyReq struct {
	_url  string
	KeyId int64
}

func (r *UsersDeletePublicKeyReq) url() string {
	return r._url
}

func (r *UsersDeletePublicKeyReq) urlPath() string {
	return fmt.Sprintf("/user/keys/%v", r.KeyId)
}

func (r *UsersDeletePublicKeyReq) method() string {
	return "DELETE"
}

func (r *UsersDeletePublicKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersDeletePublicKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersDeletePublicKeyReq) body() interface{} {
	return nil
}

func (r *UsersDeletePublicKeyReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersDeletePublicKeyReq) validStatuses() []int {
	return []int{204}
}

func (r *UsersDeletePublicKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersDeletePublicKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersDeletePublicKeyReq) Rel(link RelName, resp *UsersDeletePublicKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersDeletePublicKeyResponse is a response for UsersDeletePublicKey

https://developer.github.com/v3/users/keys/#delete-a-public-key
*/
type UsersDeletePublicKeyResponse struct {
	response
	request *UsersDeletePublicKeyReq
}

/*
UsersFollow performs requests for "users/follow"

Follow a user.

  PUT /user/following/{username}

https://developer.github.com/v3/users/followers/#follow-a-user
*/
func UsersFollow(ctx context.Context, req *UsersFollowReq, opt ...RequestOption) (*UsersFollowResponse, error) {
	if req == nil {
		req = new(UsersFollowReq)
	}
	resp := &UsersFollowResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersFollow performs requests for "users/follow"

Follow a user.

  PUT /user/following/{username}

https://developer.github.com/v3/users/followers/#follow-a-user
*/
func (c Client) UsersFollow(ctx context.Context, req *UsersFollowReq, opt ...RequestOption) (*UsersFollowResponse, error) {
	return UsersFollow(ctx, req, append(c, opt...)...)
}

/*
UsersFollowReq is request data for Client.UsersFollow

https://developer.github.com/v3/users/followers/#follow-a-user
*/
type UsersFollowReq struct {
	_url     string
	Username string
}

func (r *UsersFollowReq) url() string {
	return r._url
}

func (r *UsersFollowReq) urlPath() string {
	return fmt.Sprintf("/user/following/%v", r.Username)
}

func (r *UsersFollowReq) method() string {
	return "PUT"
}

func (r *UsersFollowReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersFollowReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersFollowReq) body() interface{} {
	return nil
}

func (r *UsersFollowReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersFollowReq) validStatuses() []int {
	return []int{204}
}

func (r *UsersFollowReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersFollowReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersFollowReq) Rel(link RelName, resp *UsersFollowResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersFollowResponse is a response for UsersFollow

https://developer.github.com/v3/users/followers/#follow-a-user
*/
type UsersFollowResponse struct {
	response
	request *UsersFollowReq
}

/*
UsersGetAuthenticated performs requests for "users/get-authenticated"

Get the authenticated user.

  GET /user

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
func UsersGetAuthenticated(ctx context.Context, req *UsersGetAuthenticatedReq, opt ...RequestOption) (*UsersGetAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersGetAuthenticatedReq)
	}
	resp := &UsersGetAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersGetAuthenticatedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetAuthenticated performs requests for "users/get-authenticated"

Get the authenticated user.

  GET /user

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
func (c Client) UsersGetAuthenticated(ctx context.Context, req *UsersGetAuthenticatedReq, opt ...RequestOption) (*UsersGetAuthenticatedResponse, error) {
	return UsersGetAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersGetAuthenticatedReq is request data for Client.UsersGetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type UsersGetAuthenticatedReq struct {
	_url string
}

func (r *UsersGetAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersGetAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user")
}

func (r *UsersGetAuthenticatedReq) method() string {
	return "GET"
}

func (r *UsersGetAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersGetAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersGetAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersGetAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersGetAuthenticatedReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersGetAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersGetAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetAuthenticatedReq) Rel(link RelName, resp *UsersGetAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetAuthenticatedResponseBody is a response body for UsersGetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type UsersGetAuthenticatedResponseBody struct {
	components.PrivateUser
}

/*
UsersGetAuthenticatedResponse is a response for UsersGetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type UsersGetAuthenticatedResponse struct {
	response
	request *UsersGetAuthenticatedReq
	Data    *UsersGetAuthenticatedResponseBody
}

/*
UsersGetByUsername performs requests for "users/get-by-username"

Get a single user.

  GET /users/{username}

https://developer.github.com/v3/users/#get-a-single-user
*/
func UsersGetByUsername(ctx context.Context, req *UsersGetByUsernameReq, opt ...RequestOption) (*UsersGetByUsernameResponse, error) {
	if req == nil {
		req = new(UsersGetByUsernameReq)
	}
	resp := &UsersGetByUsernameResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersGetByUsernameResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetByUsername performs requests for "users/get-by-username"

Get a single user.

  GET /users/{username}

https://developer.github.com/v3/users/#get-a-single-user
*/
func (c Client) UsersGetByUsername(ctx context.Context, req *UsersGetByUsernameReq, opt ...RequestOption) (*UsersGetByUsernameResponse, error) {
	return UsersGetByUsername(ctx, req, append(c, opt...)...)
}

/*
UsersGetByUsernameReq is request data for Client.UsersGetByUsername

https://developer.github.com/v3/users/#get-a-single-user
*/
type UsersGetByUsernameReq struct {
	_url     string
	Username string
}

func (r *UsersGetByUsernameReq) url() string {
	return r._url
}

func (r *UsersGetByUsernameReq) urlPath() string {
	return fmt.Sprintf("/users/%v", r.Username)
}

func (r *UsersGetByUsernameReq) method() string {
	return "GET"
}

func (r *UsersGetByUsernameReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersGetByUsernameReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersGetByUsernameReq) body() interface{} {
	return nil
}

func (r *UsersGetByUsernameReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersGetByUsernameReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersGetByUsernameReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersGetByUsernameReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetByUsernameReq) Rel(link RelName, resp *UsersGetByUsernameResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetByUsernameResponseBody is a response body for UsersGetByUsername

https://developer.github.com/v3/users/#get-a-single-user
*/
type UsersGetByUsernameResponseBody struct {
	components.PublicUser
}

/*
UsersGetByUsernameResponse is a response for UsersGetByUsername

https://developer.github.com/v3/users/#get-a-single-user
*/
type UsersGetByUsernameResponse struct {
	response
	request *UsersGetByUsernameReq
	Data    *UsersGetByUsernameResponseBody
}

/*
UsersGetContextForUser performs requests for "users/get-context-for-user"

Get contextual information about a user.

  GET /users/{username}/hovercard

https://developer.github.com/v3/users/#get-contextual-information-about-a-user
*/
func UsersGetContextForUser(ctx context.Context, req *UsersGetContextForUserReq, opt ...RequestOption) (*UsersGetContextForUserResponse, error) {
	if req == nil {
		req = new(UsersGetContextForUserReq)
	}
	resp := &UsersGetContextForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersGetContextForUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetContextForUser performs requests for "users/get-context-for-user"

Get contextual information about a user.

  GET /users/{username}/hovercard

https://developer.github.com/v3/users/#get-contextual-information-about-a-user
*/
func (c Client) UsersGetContextForUser(ctx context.Context, req *UsersGetContextForUserReq, opt ...RequestOption) (*UsersGetContextForUserResponse, error) {
	return UsersGetContextForUser(ctx, req, append(c, opt...)...)
}

/*
UsersGetContextForUserReq is request data for Client.UsersGetContextForUser

https://developer.github.com/v3/users/#get-contextual-information-about-a-user
*/
type UsersGetContextForUserReq struct {
	_url     string
	Username string

	/*
	Identifies which additional information you'd like to receive about the person's
	hovercard. Can be `organization`, `repository`, `issue`, `pull_request`.
	**Required** when using `subject_id`.
	*/
	SubjectType *string

	/*
	Uses the ID for the `subject_type` you specified. **Required** when using
	`subject_type`.
	*/
	SubjectId *string
}

func (r *UsersGetContextForUserReq) url() string {
	return r._url
}

func (r *UsersGetContextForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/hovercard", r.Username)
}

func (r *UsersGetContextForUserReq) method() string {
	return "GET"
}

func (r *UsersGetContextForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.SubjectType != nil {
		query.Set("subject_type", *r.SubjectType)
	}
	if r.SubjectId != nil {
		query.Set("subject_id", *r.SubjectId)
	}
	return query
}

func (r *UsersGetContextForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersGetContextForUserReq) body() interface{} {
	return nil
}

func (r *UsersGetContextForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersGetContextForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersGetContextForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersGetContextForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetContextForUserReq) Rel(link RelName, resp *UsersGetContextForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetContextForUserResponseBody is a response body for UsersGetContextForUser

https://developer.github.com/v3/users/#get-contextual-information-about-a-user
*/
type UsersGetContextForUserResponseBody struct {
	components.Hovercard
}

/*
UsersGetContextForUserResponse is a response for UsersGetContextForUser

https://developer.github.com/v3/users/#get-contextual-information-about-a-user
*/
type UsersGetContextForUserResponse struct {
	response
	request *UsersGetContextForUserReq
	Data    *UsersGetContextForUserResponseBody
}

/*
UsersGetGpgKey performs requests for "users/get-gpg-key"

Get a single GPG key.

  GET /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#get-a-single-gpg-key
*/
func UsersGetGpgKey(ctx context.Context, req *UsersGetGpgKeyReq, opt ...RequestOption) (*UsersGetGpgKeyResponse, error) {
	if req == nil {
		req = new(UsersGetGpgKeyReq)
	}
	resp := &UsersGetGpgKeyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersGetGpgKeyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetGpgKey performs requests for "users/get-gpg-key"

Get a single GPG key.

  GET /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#get-a-single-gpg-key
*/
func (c Client) UsersGetGpgKey(ctx context.Context, req *UsersGetGpgKeyReq, opt ...RequestOption) (*UsersGetGpgKeyResponse, error) {
	return UsersGetGpgKey(ctx, req, append(c, opt...)...)
}

/*
UsersGetGpgKeyReq is request data for Client.UsersGetGpgKey

https://developer.github.com/v3/users/gpg_keys/#get-a-single-gpg-key
*/
type UsersGetGpgKeyReq struct {
	_url     string
	GpgKeyId int64
}

func (r *UsersGetGpgKeyReq) url() string {
	return r._url
}

func (r *UsersGetGpgKeyReq) urlPath() string {
	return fmt.Sprintf("/user/gpg_keys/%v", r.GpgKeyId)
}

func (r *UsersGetGpgKeyReq) method() string {
	return "GET"
}

func (r *UsersGetGpgKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersGetGpgKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersGetGpgKeyReq) body() interface{} {
	return nil
}

func (r *UsersGetGpgKeyReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersGetGpgKeyReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersGetGpgKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersGetGpgKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetGpgKeyReq) Rel(link RelName, resp *UsersGetGpgKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetGpgKeyResponseBody is a response body for UsersGetGpgKey

https://developer.github.com/v3/users/gpg_keys/#get-a-single-gpg-key
*/
type UsersGetGpgKeyResponseBody struct {
	components.GpgKey
}

/*
UsersGetGpgKeyResponse is a response for UsersGetGpgKey

https://developer.github.com/v3/users/gpg_keys/#get-a-single-gpg-key
*/
type UsersGetGpgKeyResponse struct {
	response
	request *UsersGetGpgKeyReq
	Data    *UsersGetGpgKeyResponseBody
}

/*
UsersGetPublicKey performs requests for "users/get-public-key"

Get a single public key.

  GET /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#get-a-single-public-key
*/
func UsersGetPublicKey(ctx context.Context, req *UsersGetPublicKeyReq, opt ...RequestOption) (*UsersGetPublicKeyResponse, error) {
	if req == nil {
		req = new(UsersGetPublicKeyReq)
	}
	resp := &UsersGetPublicKeyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersGetPublicKeyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetPublicKey performs requests for "users/get-public-key"

Get a single public key.

  GET /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#get-a-single-public-key
*/
func (c Client) UsersGetPublicKey(ctx context.Context, req *UsersGetPublicKeyReq, opt ...RequestOption) (*UsersGetPublicKeyResponse, error) {
	return UsersGetPublicKey(ctx, req, append(c, opt...)...)
}

/*
UsersGetPublicKeyReq is request data for Client.UsersGetPublicKey

https://developer.github.com/v3/users/keys/#get-a-single-public-key
*/
type UsersGetPublicKeyReq struct {
	_url  string
	KeyId int64
}

func (r *UsersGetPublicKeyReq) url() string {
	return r._url
}

func (r *UsersGetPublicKeyReq) urlPath() string {
	return fmt.Sprintf("/user/keys/%v", r.KeyId)
}

func (r *UsersGetPublicKeyReq) method() string {
	return "GET"
}

func (r *UsersGetPublicKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersGetPublicKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersGetPublicKeyReq) body() interface{} {
	return nil
}

func (r *UsersGetPublicKeyReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersGetPublicKeyReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersGetPublicKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersGetPublicKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetPublicKeyReq) Rel(link RelName, resp *UsersGetPublicKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetPublicKeyResponseBody is a response body for UsersGetPublicKey

https://developer.github.com/v3/users/keys/#get-a-single-public-key
*/
type UsersGetPublicKeyResponseBody struct {
	components.ActionsPublicKey
}

/*
UsersGetPublicKeyResponse is a response for UsersGetPublicKey

https://developer.github.com/v3/users/keys/#get-a-single-public-key
*/
type UsersGetPublicKeyResponse struct {
	response
	request *UsersGetPublicKeyReq
	Data    *UsersGetPublicKeyResponseBody
}

/*
UsersList performs requests for "users/list"

Get all users.

  GET /users

https://developer.github.com/v3/users/#get-all-users
*/
func UsersList(ctx context.Context, req *UsersListReq, opt ...RequestOption) (*UsersListResponse, error) {
	if req == nil {
		req = new(UsersListReq)
	}
	resp := &UsersListResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersListResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersList performs requests for "users/list"

Get all users.

  GET /users

https://developer.github.com/v3/users/#get-all-users
*/
func (c Client) UsersList(ctx context.Context, req *UsersListReq, opt ...RequestOption) (*UsersListResponse, error) {
	return UsersList(ctx, req, append(c, opt...)...)
}

/*
UsersListReq is request data for Client.UsersList

https://developer.github.com/v3/users/#get-all-users
*/
type UsersListReq struct {
	_url string

	// The integer ID of the last User that you've seen.
	Since *string
}

func (r *UsersListReq) url() string {
	return r._url
}

func (r *UsersListReq) urlPath() string {
	return fmt.Sprintf("/users")
}

func (r *UsersListReq) method() string {
	return "GET"
}

func (r *UsersListReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	return query
}

func (r *UsersListReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListReq) body() interface{} {
	return nil
}

func (r *UsersListReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListReq) Rel(link RelName, resp *UsersListResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListResponseBody is a response body for UsersList

https://developer.github.com/v3/users/#get-all-users
*/
type UsersListResponseBody []struct {
	components.SimpleUser
}

/*
UsersListResponse is a response for UsersList

https://developer.github.com/v3/users/#get-all-users
*/
type UsersListResponse struct {
	response
	request *UsersListReq
	Data    *UsersListResponseBody
}

/*
UsersListBlocked performs requests for "users/list-blocked"

List blocked users.

  GET /user/blocks

https://developer.github.com/v3/users/blocking/#list-blocked-users
*/
func UsersListBlocked(ctx context.Context, req *UsersListBlockedReq, opt ...RequestOption) (*UsersListBlockedResponse, error) {
	if req == nil {
		req = new(UsersListBlockedReq)
	}
	resp := &UsersListBlockedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersListBlockedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListBlocked performs requests for "users/list-blocked"

List blocked users.

  GET /user/blocks

https://developer.github.com/v3/users/blocking/#list-blocked-users
*/
func (c Client) UsersListBlocked(ctx context.Context, req *UsersListBlockedReq, opt ...RequestOption) (*UsersListBlockedResponse, error) {
	return UsersListBlocked(ctx, req, append(c, opt...)...)
}

/*
UsersListBlockedReq is request data for Client.UsersListBlocked

https://developer.github.com/v3/users/blocking/#list-blocked-users
*/
type UsersListBlockedReq struct {
	_url string
}

func (r *UsersListBlockedReq) url() string {
	return r._url
}

func (r *UsersListBlockedReq) urlPath() string {
	return fmt.Sprintf("/user/blocks")
}

func (r *UsersListBlockedReq) method() string {
	return "GET"
}

func (r *UsersListBlockedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersListBlockedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListBlockedReq) body() interface{} {
	return nil
}

func (r *UsersListBlockedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListBlockedReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListBlockedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListBlockedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListBlockedReq) Rel(link RelName, resp *UsersListBlockedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListBlockedResponseBody is a response body for UsersListBlocked

https://developer.github.com/v3/users/blocking/#list-blocked-users
*/
type UsersListBlockedResponseBody []struct {
	components.SimpleUser
}

/*
UsersListBlockedResponse is a response for UsersListBlocked

https://developer.github.com/v3/users/blocking/#list-blocked-users
*/
type UsersListBlockedResponse struct {
	response
	request *UsersListBlockedReq
	Data    *UsersListBlockedResponseBody
}

/*
UsersListEmails performs requests for "users/list-emails"

List email addresses for a user.

  GET /user/emails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-a-user
*/
func UsersListEmails(ctx context.Context, req *UsersListEmailsReq, opt ...RequestOption) (*UsersListEmailsResponse, error) {
	if req == nil {
		req = new(UsersListEmailsReq)
	}
	resp := &UsersListEmailsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersListEmailsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListEmails performs requests for "users/list-emails"

List email addresses for a user.

  GET /user/emails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-a-user
*/
func (c Client) UsersListEmails(ctx context.Context, req *UsersListEmailsReq, opt ...RequestOption) (*UsersListEmailsResponse, error) {
	return UsersListEmails(ctx, req, append(c, opt...)...)
}

/*
UsersListEmailsReq is request data for Client.UsersListEmails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-a-user
*/
type UsersListEmailsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListEmailsReq) url() string {
	return r._url
}

func (r *UsersListEmailsReq) urlPath() string {
	return fmt.Sprintf("/user/emails")
}

func (r *UsersListEmailsReq) method() string {
	return "GET"
}

func (r *UsersListEmailsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListEmailsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListEmailsReq) body() interface{} {
	return nil
}

func (r *UsersListEmailsReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListEmailsReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListEmailsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListEmailsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListEmailsReq) Rel(link RelName, resp *UsersListEmailsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListEmailsResponseBody is a response body for UsersListEmails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-a-user
*/
type UsersListEmailsResponseBody []struct {
	components.Email
}

/*
UsersListEmailsResponse is a response for UsersListEmails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-a-user
*/
type UsersListEmailsResponse struct {
	response
	request *UsersListEmailsReq
	Data    *UsersListEmailsResponseBody
}

/*
UsersListFollowedByAuthenticated performs requests for "users/list-followed-by-authenticated"

List users followed by the authenticated user.

  GET /user/following

https://developer.github.com/v3/users/followers/#list-users-followed-by-the-authenticated-user
*/
func UsersListFollowedByAuthenticated(ctx context.Context, req *UsersListFollowedByAuthenticatedReq, opt ...RequestOption) (*UsersListFollowedByAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersListFollowedByAuthenticatedReq)
	}
	resp := &UsersListFollowedByAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersListFollowedByAuthenticatedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListFollowedByAuthenticated performs requests for "users/list-followed-by-authenticated"

List users followed by the authenticated user.

  GET /user/following

https://developer.github.com/v3/users/followers/#list-users-followed-by-the-authenticated-user
*/
func (c Client) UsersListFollowedByAuthenticated(ctx context.Context, req *UsersListFollowedByAuthenticatedReq, opt ...RequestOption) (*UsersListFollowedByAuthenticatedResponse, error) {
	return UsersListFollowedByAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersListFollowedByAuthenticatedReq is request data for Client.UsersListFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#list-users-followed-by-the-authenticated-user
*/
type UsersListFollowedByAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListFollowedByAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersListFollowedByAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/following")
}

func (r *UsersListFollowedByAuthenticatedReq) method() string {
	return "GET"
}

func (r *UsersListFollowedByAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListFollowedByAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListFollowedByAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersListFollowedByAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowedByAuthenticatedReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowedByAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListFollowedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListFollowedByAuthenticatedReq) Rel(link RelName, resp *UsersListFollowedByAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListFollowedByAuthenticatedResponseBody is a response body for UsersListFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#list-users-followed-by-the-authenticated-user
*/
type UsersListFollowedByAuthenticatedResponseBody []struct {
	components.SimpleUser
}

/*
UsersListFollowedByAuthenticatedResponse is a response for UsersListFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#list-users-followed-by-the-authenticated-user
*/
type UsersListFollowedByAuthenticatedResponse struct {
	response
	request *UsersListFollowedByAuthenticatedReq
	Data    *UsersListFollowedByAuthenticatedResponseBody
}

/*
UsersListFollowersForAuthenticatedUser performs requests for "users/list-followers-for-authenticated-user"

List followers of the authenticated user.

  GET /user/followers

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
func UsersListFollowersForAuthenticatedUser(ctx context.Context, req *UsersListFollowersForAuthenticatedUserReq, opt ...RequestOption) (*UsersListFollowersForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(UsersListFollowersForAuthenticatedUserReq)
	}
	resp := &UsersListFollowersForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersListFollowersForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListFollowersForAuthenticatedUser performs requests for "users/list-followers-for-authenticated-user"

List followers of the authenticated user.

  GET /user/followers

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
func (c Client) UsersListFollowersForAuthenticatedUser(ctx context.Context, req *UsersListFollowersForAuthenticatedUserReq, opt ...RequestOption) (*UsersListFollowersForAuthenticatedUserResponse, error) {
	return UsersListFollowersForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
UsersListFollowersForAuthenticatedUserReq is request data for Client.UsersListFollowersForAuthenticatedUser

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type UsersListFollowersForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListFollowersForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *UsersListFollowersForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/followers")
}

func (r *UsersListFollowersForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *UsersListFollowersForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListFollowersForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListFollowersForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *UsersListFollowersForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowersForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowersForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListFollowersForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListFollowersForAuthenticatedUserReq) Rel(link RelName, resp *UsersListFollowersForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListFollowersForAuthenticatedUserResponseBody is a response body for UsersListFollowersForAuthenticatedUser

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type UsersListFollowersForAuthenticatedUserResponseBody []struct {
	components.SimpleUser
}

/*
UsersListFollowersForAuthenticatedUserResponse is a response for UsersListFollowersForAuthenticatedUser

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type UsersListFollowersForAuthenticatedUserResponse struct {
	response
	request *UsersListFollowersForAuthenticatedUserReq
	Data    *UsersListFollowersForAuthenticatedUserResponseBody
}

/*
UsersListFollowersForUser performs requests for "users/list-followers-for-user"

List followers of a user.

  GET /users/{username}/followers

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
func UsersListFollowersForUser(ctx context.Context, req *UsersListFollowersForUserReq, opt ...RequestOption) (*UsersListFollowersForUserResponse, error) {
	if req == nil {
		req = new(UsersListFollowersForUserReq)
	}
	resp := &UsersListFollowersForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersListFollowersForUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListFollowersForUser performs requests for "users/list-followers-for-user"

List followers of a user.

  GET /users/{username}/followers

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
func (c Client) UsersListFollowersForUser(ctx context.Context, req *UsersListFollowersForUserReq, opt ...RequestOption) (*UsersListFollowersForUserResponse, error) {
	return UsersListFollowersForUser(ctx, req, append(c, opt...)...)
}

/*
UsersListFollowersForUserReq is request data for Client.UsersListFollowersForUser

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type UsersListFollowersForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListFollowersForUserReq) url() string {
	return r._url
}

func (r *UsersListFollowersForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/followers", r.Username)
}

func (r *UsersListFollowersForUserReq) method() string {
	return "GET"
}

func (r *UsersListFollowersForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListFollowersForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListFollowersForUserReq) body() interface{} {
	return nil
}

func (r *UsersListFollowersForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowersForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowersForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListFollowersForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListFollowersForUserReq) Rel(link RelName, resp *UsersListFollowersForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListFollowersForUserResponseBody is a response body for UsersListFollowersForUser

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type UsersListFollowersForUserResponseBody []struct {
	components.SimpleUser
}

/*
UsersListFollowersForUserResponse is a response for UsersListFollowersForUser

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type UsersListFollowersForUserResponse struct {
	response
	request *UsersListFollowersForUserReq
	Data    *UsersListFollowersForUserResponseBody
}

/*
UsersListFollowingForUser performs requests for "users/list-following-for-user"

List users followed by another user.

  GET /users/{username}/following

https://developer.github.com/v3/users/followers/#list-users-followed-by-another-user
*/
func UsersListFollowingForUser(ctx context.Context, req *UsersListFollowingForUserReq, opt ...RequestOption) (*UsersListFollowingForUserResponse, error) {
	if req == nil {
		req = new(UsersListFollowingForUserReq)
	}
	resp := &UsersListFollowingForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersListFollowingForUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListFollowingForUser performs requests for "users/list-following-for-user"

List users followed by another user.

  GET /users/{username}/following

https://developer.github.com/v3/users/followers/#list-users-followed-by-another-user
*/
func (c Client) UsersListFollowingForUser(ctx context.Context, req *UsersListFollowingForUserReq, opt ...RequestOption) (*UsersListFollowingForUserResponse, error) {
	return UsersListFollowingForUser(ctx, req, append(c, opt...)...)
}

/*
UsersListFollowingForUserReq is request data for Client.UsersListFollowingForUser

https://developer.github.com/v3/users/followers/#list-users-followed-by-another-user
*/
type UsersListFollowingForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListFollowingForUserReq) url() string {
	return r._url
}

func (r *UsersListFollowingForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/following", r.Username)
}

func (r *UsersListFollowingForUserReq) method() string {
	return "GET"
}

func (r *UsersListFollowingForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListFollowingForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListFollowingForUserReq) body() interface{} {
	return nil
}

func (r *UsersListFollowingForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowingForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowingForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListFollowingForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListFollowingForUserReq) Rel(link RelName, resp *UsersListFollowingForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListFollowingForUserResponseBody is a response body for UsersListFollowingForUser

https://developer.github.com/v3/users/followers/#list-users-followed-by-another-user
*/
type UsersListFollowingForUserResponseBody []struct {
	components.SimpleUser
}

/*
UsersListFollowingForUserResponse is a response for UsersListFollowingForUser

https://developer.github.com/v3/users/followers/#list-users-followed-by-another-user
*/
type UsersListFollowingForUserResponse struct {
	response
	request *UsersListFollowingForUserReq
	Data    *UsersListFollowingForUserResponseBody
}

/*
UsersListGpgKeys performs requests for "users/list-gpg-keys"

List your GPG keys.

  GET /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-your-gpg-keys
*/
func UsersListGpgKeys(ctx context.Context, req *UsersListGpgKeysReq, opt ...RequestOption) (*UsersListGpgKeysResponse, error) {
	if req == nil {
		req = new(UsersListGpgKeysReq)
	}
	resp := &UsersListGpgKeysResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersListGpgKeysResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListGpgKeys performs requests for "users/list-gpg-keys"

List your GPG keys.

  GET /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-your-gpg-keys
*/
func (c Client) UsersListGpgKeys(ctx context.Context, req *UsersListGpgKeysReq, opt ...RequestOption) (*UsersListGpgKeysResponse, error) {
	return UsersListGpgKeys(ctx, req, append(c, opt...)...)
}

/*
UsersListGpgKeysReq is request data for Client.UsersListGpgKeys

https://developer.github.com/v3/users/gpg_keys/#list-your-gpg-keys
*/
type UsersListGpgKeysReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListGpgKeysReq) url() string {
	return r._url
}

func (r *UsersListGpgKeysReq) urlPath() string {
	return fmt.Sprintf("/user/gpg_keys")
}

func (r *UsersListGpgKeysReq) method() string {
	return "GET"
}

func (r *UsersListGpgKeysReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListGpgKeysReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListGpgKeysReq) body() interface{} {
	return nil
}

func (r *UsersListGpgKeysReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListGpgKeysReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListGpgKeysReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListGpgKeysReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListGpgKeysReq) Rel(link RelName, resp *UsersListGpgKeysResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListGpgKeysResponseBody is a response body for UsersListGpgKeys

https://developer.github.com/v3/users/gpg_keys/#list-your-gpg-keys
*/
type UsersListGpgKeysResponseBody []struct {
	components.GpgKey
}

/*
UsersListGpgKeysResponse is a response for UsersListGpgKeys

https://developer.github.com/v3/users/gpg_keys/#list-your-gpg-keys
*/
type UsersListGpgKeysResponse struct {
	response
	request *UsersListGpgKeysReq
	Data    *UsersListGpgKeysResponseBody
}

/*
UsersListGpgKeysForUser performs requests for "users/list-gpg-keys-for-user"

List GPG keys for a user.

  GET /users/{username}/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
func UsersListGpgKeysForUser(ctx context.Context, req *UsersListGpgKeysForUserReq, opt ...RequestOption) (*UsersListGpgKeysForUserResponse, error) {
	if req == nil {
		req = new(UsersListGpgKeysForUserReq)
	}
	resp := &UsersListGpgKeysForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersListGpgKeysForUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListGpgKeysForUser performs requests for "users/list-gpg-keys-for-user"

List GPG keys for a user.

  GET /users/{username}/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
func (c Client) UsersListGpgKeysForUser(ctx context.Context, req *UsersListGpgKeysForUserReq, opt ...RequestOption) (*UsersListGpgKeysForUserResponse, error) {
	return UsersListGpgKeysForUser(ctx, req, append(c, opt...)...)
}

/*
UsersListGpgKeysForUserReq is request data for Client.UsersListGpgKeysForUser

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type UsersListGpgKeysForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListGpgKeysForUserReq) url() string {
	return r._url
}

func (r *UsersListGpgKeysForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/gpg_keys", r.Username)
}

func (r *UsersListGpgKeysForUserReq) method() string {
	return "GET"
}

func (r *UsersListGpgKeysForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListGpgKeysForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListGpgKeysForUserReq) body() interface{} {
	return nil
}

func (r *UsersListGpgKeysForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListGpgKeysForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListGpgKeysForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListGpgKeysForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListGpgKeysForUserReq) Rel(link RelName, resp *UsersListGpgKeysForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListGpgKeysForUserResponseBody is a response body for UsersListGpgKeysForUser

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type UsersListGpgKeysForUserResponseBody []struct {
	components.GpgKey
}

/*
UsersListGpgKeysForUserResponse is a response for UsersListGpgKeysForUser

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type UsersListGpgKeysForUserResponse struct {
	response
	request *UsersListGpgKeysForUserReq
	Data    *UsersListGpgKeysForUserResponseBody
}

/*
UsersListPublicEmails performs requests for "users/list-public-emails"

List public email addresses for a user.

  GET /user/public_emails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-a-user
*/
func UsersListPublicEmails(ctx context.Context, req *UsersListPublicEmailsReq, opt ...RequestOption) (*UsersListPublicEmailsResponse, error) {
	if req == nil {
		req = new(UsersListPublicEmailsReq)
	}
	resp := &UsersListPublicEmailsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersListPublicEmailsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListPublicEmails performs requests for "users/list-public-emails"

List public email addresses for a user.

  GET /user/public_emails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-a-user
*/
func (c Client) UsersListPublicEmails(ctx context.Context, req *UsersListPublicEmailsReq, opt ...RequestOption) (*UsersListPublicEmailsResponse, error) {
	return UsersListPublicEmails(ctx, req, append(c, opt...)...)
}

/*
UsersListPublicEmailsReq is request data for Client.UsersListPublicEmails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-a-user
*/
type UsersListPublicEmailsReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListPublicEmailsReq) url() string {
	return r._url
}

func (r *UsersListPublicEmailsReq) urlPath() string {
	return fmt.Sprintf("/user/public_emails")
}

func (r *UsersListPublicEmailsReq) method() string {
	return "GET"
}

func (r *UsersListPublicEmailsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListPublicEmailsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListPublicEmailsReq) body() interface{} {
	return nil
}

func (r *UsersListPublicEmailsReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListPublicEmailsReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListPublicEmailsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListPublicEmailsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListPublicEmailsReq) Rel(link RelName, resp *UsersListPublicEmailsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListPublicEmailsResponseBody is a response body for UsersListPublicEmails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-a-user
*/
type UsersListPublicEmailsResponseBody []struct {
	components.Email
}

/*
UsersListPublicEmailsResponse is a response for UsersListPublicEmails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-a-user
*/
type UsersListPublicEmailsResponse struct {
	response
	request *UsersListPublicEmailsReq
	Data    *UsersListPublicEmailsResponseBody
}

/*
UsersListPublicKeys performs requests for "users/list-public-keys"

List your public keys.

  GET /user/keys

https://developer.github.com/v3/users/keys/#list-your-public-keys
*/
func UsersListPublicKeys(ctx context.Context, req *UsersListPublicKeysReq, opt ...RequestOption) (*UsersListPublicKeysResponse, error) {
	if req == nil {
		req = new(UsersListPublicKeysReq)
	}
	resp := &UsersListPublicKeysResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersListPublicKeysResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListPublicKeys performs requests for "users/list-public-keys"

List your public keys.

  GET /user/keys

https://developer.github.com/v3/users/keys/#list-your-public-keys
*/
func (c Client) UsersListPublicKeys(ctx context.Context, req *UsersListPublicKeysReq, opt ...RequestOption) (*UsersListPublicKeysResponse, error) {
	return UsersListPublicKeys(ctx, req, append(c, opt...)...)
}

/*
UsersListPublicKeysReq is request data for Client.UsersListPublicKeys

https://developer.github.com/v3/users/keys/#list-your-public-keys
*/
type UsersListPublicKeysReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListPublicKeysReq) url() string {
	return r._url
}

func (r *UsersListPublicKeysReq) urlPath() string {
	return fmt.Sprintf("/user/keys")
}

func (r *UsersListPublicKeysReq) method() string {
	return "GET"
}

func (r *UsersListPublicKeysReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListPublicKeysReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListPublicKeysReq) body() interface{} {
	return nil
}

func (r *UsersListPublicKeysReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListPublicKeysReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListPublicKeysReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListPublicKeysReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListPublicKeysReq) Rel(link RelName, resp *UsersListPublicKeysResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListPublicKeysResponseBody is a response body for UsersListPublicKeys

https://developer.github.com/v3/users/keys/#list-your-public-keys
*/
type UsersListPublicKeysResponseBody []struct {
	components.ActionsPublicKey
}

/*
UsersListPublicKeysResponse is a response for UsersListPublicKeys

https://developer.github.com/v3/users/keys/#list-your-public-keys
*/
type UsersListPublicKeysResponse struct {
	response
	request *UsersListPublicKeysReq
	Data    *UsersListPublicKeysResponseBody
}

/*
UsersListPublicKeysForUser performs requests for "users/list-public-keys-for-user"

List public keys for a user.

  GET /users/{username}/keys

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
func UsersListPublicKeysForUser(ctx context.Context, req *UsersListPublicKeysForUserReq, opt ...RequestOption) (*UsersListPublicKeysForUserResponse, error) {
	if req == nil {
		req = new(UsersListPublicKeysForUserReq)
	}
	resp := &UsersListPublicKeysForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersListPublicKeysForUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListPublicKeysForUser performs requests for "users/list-public-keys-for-user"

List public keys for a user.

  GET /users/{username}/keys

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
func (c Client) UsersListPublicKeysForUser(ctx context.Context, req *UsersListPublicKeysForUserReq, opt ...RequestOption) (*UsersListPublicKeysForUserResponse, error) {
	return UsersListPublicKeysForUser(ctx, req, append(c, opt...)...)
}

/*
UsersListPublicKeysForUserReq is request data for Client.UsersListPublicKeysForUser

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type UsersListPublicKeysForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListPublicKeysForUserReq) url() string {
	return r._url
}

func (r *UsersListPublicKeysForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/keys", r.Username)
}

func (r *UsersListPublicKeysForUserReq) method() string {
	return "GET"
}

func (r *UsersListPublicKeysForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListPublicKeysForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListPublicKeysForUserReq) body() interface{} {
	return nil
}

func (r *UsersListPublicKeysForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListPublicKeysForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListPublicKeysForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListPublicKeysForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListPublicKeysForUserReq) Rel(link RelName, resp *UsersListPublicKeysForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListPublicKeysForUserResponseBody is a response body for UsersListPublicKeysForUser

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type UsersListPublicKeysForUserResponseBody []struct {
	components.KeySimple
}

/*
UsersListPublicKeysForUserResponse is a response for UsersListPublicKeysForUser

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type UsersListPublicKeysForUserResponse struct {
	response
	request *UsersListPublicKeysForUserReq
	Data    *UsersListPublicKeysForUserResponseBody
}

/*
UsersTogglePrimaryEmailVisibility performs requests for "users/toggle-primary-email-visibility"

Toggle primary email visibility.

  PATCH /user/email/visibility

https://developer.github.com/v3/users/emails/#toggle-primary-email-visibility
*/
func UsersTogglePrimaryEmailVisibility(ctx context.Context, req *UsersTogglePrimaryEmailVisibilityReq, opt ...RequestOption) (*UsersTogglePrimaryEmailVisibilityResponse, error) {
	if req == nil {
		req = new(UsersTogglePrimaryEmailVisibilityReq)
	}
	resp := &UsersTogglePrimaryEmailVisibilityResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersTogglePrimaryEmailVisibilityResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersTogglePrimaryEmailVisibility performs requests for "users/toggle-primary-email-visibility"

Toggle primary email visibility.

  PATCH /user/email/visibility

https://developer.github.com/v3/users/emails/#toggle-primary-email-visibility
*/
func (c Client) UsersTogglePrimaryEmailVisibility(ctx context.Context, req *UsersTogglePrimaryEmailVisibilityReq, opt ...RequestOption) (*UsersTogglePrimaryEmailVisibilityResponse, error) {
	return UsersTogglePrimaryEmailVisibility(ctx, req, append(c, opt...)...)
}

/*
UsersTogglePrimaryEmailVisibilityReq is request data for Client.UsersTogglePrimaryEmailVisibility

https://developer.github.com/v3/users/emails/#toggle-primary-email-visibility
*/
type UsersTogglePrimaryEmailVisibilityReq struct {
	_url        string
	RequestBody UsersTogglePrimaryEmailVisibilityReqBody
}

func (r *UsersTogglePrimaryEmailVisibilityReq) url() string {
	return r._url
}

func (r *UsersTogglePrimaryEmailVisibilityReq) urlPath() string {
	return fmt.Sprintf("/user/email/visibility")
}

func (r *UsersTogglePrimaryEmailVisibilityReq) method() string {
	return "PATCH"
}

func (r *UsersTogglePrimaryEmailVisibilityReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersTogglePrimaryEmailVisibilityReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersTogglePrimaryEmailVisibilityReq) body() interface{} {
	return r.RequestBody
}

func (r *UsersTogglePrimaryEmailVisibilityReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersTogglePrimaryEmailVisibilityReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersTogglePrimaryEmailVisibilityReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *UsersTogglePrimaryEmailVisibilityReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersTogglePrimaryEmailVisibilityReq) Rel(link RelName, resp *UsersTogglePrimaryEmailVisibilityResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersTogglePrimaryEmailVisibilityReqBody is a request body for users/toggle-primary-email-visibility

https://developer.github.com/v3/users/emails/#toggle-primary-email-visibility
*/
type UsersTogglePrimaryEmailVisibilityReqBody struct {

	// Specify the _primary_ email address that needs a visibility change.
	Email *string `json:"email"`

	/*
	   Use `public` to enable an authenticated user to view the specified email
	   address, or use `private` so this primary email address cannot be seen publicly.
	*/
	Visibility *string `json:"visibility"`
}

/*
UsersTogglePrimaryEmailVisibilityResponseBody is a response body for UsersTogglePrimaryEmailVisibility

https://developer.github.com/v3/users/emails/#toggle-primary-email-visibility
*/
type UsersTogglePrimaryEmailVisibilityResponseBody []struct {
	components.Email
}

/*
UsersTogglePrimaryEmailVisibilityResponse is a response for UsersTogglePrimaryEmailVisibility

https://developer.github.com/v3/users/emails/#toggle-primary-email-visibility
*/
type UsersTogglePrimaryEmailVisibilityResponse struct {
	response
	request *UsersTogglePrimaryEmailVisibilityReq
	Data    *UsersTogglePrimaryEmailVisibilityResponseBody
}

/*
UsersUnblock performs requests for "users/unblock"

Unblock a user.

  DELETE /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
func UsersUnblock(ctx context.Context, req *UsersUnblockReq, opt ...RequestOption) (*UsersUnblockResponse, error) {
	if req == nil {
		req = new(UsersUnblockReq)
	}
	resp := &UsersUnblockResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersUnblock performs requests for "users/unblock"

Unblock a user.

  DELETE /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
func (c Client) UsersUnblock(ctx context.Context, req *UsersUnblockReq, opt ...RequestOption) (*UsersUnblockResponse, error) {
	return UsersUnblock(ctx, req, append(c, opt...)...)
}

/*
UsersUnblockReq is request data for Client.UsersUnblock

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
type UsersUnblockReq struct {
	_url     string
	Username string
}

func (r *UsersUnblockReq) url() string {
	return r._url
}

func (r *UsersUnblockReq) urlPath() string {
	return fmt.Sprintf("/user/blocks/%v", r.Username)
}

func (r *UsersUnblockReq) method() string {
	return "DELETE"
}

func (r *UsersUnblockReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersUnblockReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersUnblockReq) body() interface{} {
	return nil
}

func (r *UsersUnblockReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersUnblockReq) validStatuses() []int {
	return []int{204}
}

func (r *UsersUnblockReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersUnblockReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersUnblockReq) Rel(link RelName, resp *UsersUnblockResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersUnblockResponse is a response for UsersUnblock

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
type UsersUnblockResponse struct {
	response
	request *UsersUnblockReq
}

/*
UsersUnfollow performs requests for "users/unfollow"

Unfollow a user.

  DELETE /user/following/{username}

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
func UsersUnfollow(ctx context.Context, req *UsersUnfollowReq, opt ...RequestOption) (*UsersUnfollowResponse, error) {
	if req == nil {
		req = new(UsersUnfollowReq)
	}
	resp := &UsersUnfollowResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersUnfollow performs requests for "users/unfollow"

Unfollow a user.

  DELETE /user/following/{username}

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
func (c Client) UsersUnfollow(ctx context.Context, req *UsersUnfollowReq, opt ...RequestOption) (*UsersUnfollowResponse, error) {
	return UsersUnfollow(ctx, req, append(c, opt...)...)
}

/*
UsersUnfollowReq is request data for Client.UsersUnfollow

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
type UsersUnfollowReq struct {
	_url     string
	Username string
}

func (r *UsersUnfollowReq) url() string {
	return r._url
}

func (r *UsersUnfollowReq) urlPath() string {
	return fmt.Sprintf("/user/following/%v", r.Username)
}

func (r *UsersUnfollowReq) method() string {
	return "DELETE"
}

func (r *UsersUnfollowReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersUnfollowReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersUnfollowReq) body() interface{} {
	return nil
}

func (r *UsersUnfollowReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersUnfollowReq) validStatuses() []int {
	return []int{204}
}

func (r *UsersUnfollowReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersUnfollowReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersUnfollowReq) Rel(link RelName, resp *UsersUnfollowResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersUnfollowResponse is a response for UsersUnfollow

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
type UsersUnfollowResponse struct {
	response
	request *UsersUnfollowReq
}

/*
UsersUpdateAuthenticated performs requests for "users/update-authenticated"

Update the authenticated user.

  PATCH /user

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
func UsersUpdateAuthenticated(ctx context.Context, req *UsersUpdateAuthenticatedReq, opt ...RequestOption) (*UsersUpdateAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersUpdateAuthenticatedReq)
	}
	resp := &UsersUpdateAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(UsersUpdateAuthenticatedResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersUpdateAuthenticated performs requests for "users/update-authenticated"

Update the authenticated user.

  PATCH /user

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
func (c Client) UsersUpdateAuthenticated(ctx context.Context, req *UsersUpdateAuthenticatedReq, opt ...RequestOption) (*UsersUpdateAuthenticatedResponse, error) {
	return UsersUpdateAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersUpdateAuthenticatedReq is request data for Client.UsersUpdateAuthenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedReq struct {
	_url        string
	RequestBody UsersUpdateAuthenticatedReqBody
}

func (r *UsersUpdateAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersUpdateAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user")
}

func (r *UsersUpdateAuthenticatedReq) method() string {
	return "PATCH"
}

func (r *UsersUpdateAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersUpdateAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersUpdateAuthenticatedReq) body() interface{} {
	return r.RequestBody
}

func (r *UsersUpdateAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersUpdateAuthenticatedReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersUpdateAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *UsersUpdateAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersUpdateAuthenticatedReq) Rel(link RelName, resp *UsersUpdateAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersUpdateAuthenticatedReqBody is a request body for users/update-authenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedReqBody struct {

	// The new short biography of the user.
	Bio *string `json:"bio,omitempty"`

	// The new blog URL of the user.
	Blog *string `json:"blog,omitempty"`

	// The new company of the user.
	Company *string `json:"company,omitempty"`

	// The publicly visible email address of the user.
	Email *string `json:"email,omitempty"`

	// The new hiring availability of the user.
	Hireable *bool `json:"hireable,omitempty"`

	// The new location of the user.
	Location *string `json:"location,omitempty"`

	// The new name of the user.
	Name *string `json:"name,omitempty"`
}

/*
UsersUpdateAuthenticatedResponseBody is a response body for UsersUpdateAuthenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedResponseBody struct {
	components.PrivateUser
}

/*
UsersUpdateAuthenticatedResponse is a response for UsersUpdateAuthenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedResponse struct {
	response
	request *UsersUpdateAuthenticatedReq
	Data    *UsersUpdateAuthenticatedResponseBody
}
