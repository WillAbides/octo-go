// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"encoding/json"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
UsersAddEmailForAuthenticated performs requests for "users/add-email-for-authenticated"

Add an email address for the authenticated user.

  POST /user/emails

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
func UsersAddEmailForAuthenticated(ctx context.Context, req *UsersAddEmailForAuthenticatedReq, opt ...options.Option) (*UsersAddEmailForAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersAddEmailForAuthenticatedReq)
	}
	resp := &UsersAddEmailForAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Email{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersAddEmailForAuthenticated performs requests for "users/add-email-for-authenticated"

Add an email address for the authenticated user.

  POST /user/emails

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
func (c Client) UsersAddEmailForAuthenticated(ctx context.Context, req *UsersAddEmailForAuthenticatedReq, opt ...options.Option) (*UsersAddEmailForAuthenticatedResponse, error) {
	return UsersAddEmailForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersAddEmailForAuthenticatedReq is request data for Client.UsersAddEmailForAuthenticated

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
type UsersAddEmailForAuthenticatedReq struct {
	_url        string
	RequestBody UsersAddEmailForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *UsersAddEmailForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersAddEmailForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "users/add-email-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/emails"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersAddEmailForAuthenticatedReq) Rel(link RelName, resp *UsersAddEmailForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersAddEmailForAuthenticatedReqBody is a request body for users/add-email-for-authenticated

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
type UsersAddEmailForAuthenticatedReqBody struct {

	/*
	Adds one or more email addresses to your GitHub account. Must contain at least
	one email address. **Note:** Alternatively, you can pass a single email address
	or an `array` of emails addresses directly, but we recommend that you pass an
	object using the `emails` key.
	*/
	Emails []string `json:"emails"`
}

/*
UsersAddEmailForAuthenticatedResponse is a response for UsersAddEmailForAuthenticated

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
type UsersAddEmailForAuthenticatedResponse struct {
	internal.Response
	request *UsersAddEmailForAuthenticatedReq
	Data    []components.Email
}

/*
UsersBlock performs requests for "users/block"

Block a user.

  PUT /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#block-a-user
*/
func UsersBlock(ctx context.Context, req *UsersBlockReq, opt ...options.Option) (*UsersBlockResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersBlockReq)
	}
	resp := &UsersBlockResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersBlock performs requests for "users/block"

Block a user.

  PUT /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#block-a-user
*/
func (c Client) UsersBlock(ctx context.Context, req *UsersBlockReq, opt ...options.Option) (*UsersBlockResponse, error) {
	return UsersBlock(ctx, req, append(c, opt...)...)
}

/*
UsersBlockReq is request data for Client.UsersBlock

https://developer.github.com/v3/users/blocking/#block-a-user
*/
type UsersBlockReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *UsersBlockReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersBlockReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "users/block",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/blocks/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersBlockReq) Rel(link RelName, resp *UsersBlockResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersBlockResponse is a response for UsersBlock

https://developer.github.com/v3/users/blocking/#block-a-user
*/
type UsersBlockResponse struct {
	internal.Response
	request *UsersBlockReq
}

/*
UsersCheckBlocked performs requests for "users/check-blocked"

Check if a user is blocked by the authenticated user.

  GET /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
func UsersCheckBlocked(ctx context.Context, req *UsersCheckBlockedReq, opt ...options.Option) (*UsersCheckBlockedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersCheckBlockedReq)
	}
	resp := &UsersCheckBlockedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCheckBlocked performs requests for "users/check-blocked"

Check if a user is blocked by the authenticated user.

  GET /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
func (c Client) UsersCheckBlocked(ctx context.Context, req *UsersCheckBlockedReq, opt ...options.Option) (*UsersCheckBlockedResponse, error) {
	return UsersCheckBlocked(ctx, req, append(c, opt...)...)
}

/*
UsersCheckBlockedReq is request data for Client.UsersCheckBlocked

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
type UsersCheckBlockedReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *UsersCheckBlockedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersCheckBlockedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "users/check-blocked",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/blocks/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCheckBlockedReq) Rel(link RelName, resp *UsersCheckBlockedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCheckBlockedResponse is a response for UsersCheckBlocked

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
type UsersCheckBlockedResponse struct {
	internal.Response
	request *UsersCheckBlockedReq
}

/*
UsersCheckFollowingForUser performs requests for "users/check-following-for-user"

Check if a user follows another user.

  GET /users/{username}/following/{target_user}

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
func UsersCheckFollowingForUser(ctx context.Context, req *UsersCheckFollowingForUserReq, opt ...options.Option) (*UsersCheckFollowingForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersCheckFollowingForUserReq)
	}
	resp := &UsersCheckFollowingForUserResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCheckFollowingForUser performs requests for "users/check-following-for-user"

Check if a user follows another user.

  GET /users/{username}/following/{target_user}

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
func (c Client) UsersCheckFollowingForUser(ctx context.Context, req *UsersCheckFollowingForUserReq, opt ...options.Option) (*UsersCheckFollowingForUserResponse, error) {
	return UsersCheckFollowingForUser(ctx, req, append(c, opt...)...)
}

/*
UsersCheckFollowingForUserReq is request data for Client.UsersCheckFollowingForUser

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
type UsersCheckFollowingForUserReq struct {
	_url     string
	Username string

	// target_user parameter
	TargetUser string
}

// HTTPRequest builds an *http.Request
func (r *UsersCheckFollowingForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersCheckFollowingForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "users/check-following-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/following/%v", r.Username, r.TargetUser),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCheckFollowingForUserReq) Rel(link RelName, resp *UsersCheckFollowingForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCheckFollowingForUserResponse is a response for UsersCheckFollowingForUser

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
type UsersCheckFollowingForUserResponse struct {
	internal.Response
	request *UsersCheckFollowingForUserReq
	Data    bool
}

/*
UsersCheckPersonIsFollowedByAuthenticated performs requests for "users/check-person-is-followed-by-authenticated"

Check if a person is followed by the authenticated user.

  GET /user/following/{username}

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
func UsersCheckPersonIsFollowedByAuthenticated(ctx context.Context, req *UsersCheckPersonIsFollowedByAuthenticatedReq, opt ...options.Option) (*UsersCheckPersonIsFollowedByAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersCheckPersonIsFollowedByAuthenticatedReq)
	}
	resp := &UsersCheckPersonIsFollowedByAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCheckPersonIsFollowedByAuthenticated performs requests for "users/check-person-is-followed-by-authenticated"

Check if a person is followed by the authenticated user.

  GET /user/following/{username}

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
func (c Client) UsersCheckPersonIsFollowedByAuthenticated(ctx context.Context, req *UsersCheckPersonIsFollowedByAuthenticatedReq, opt ...options.Option) (*UsersCheckPersonIsFollowedByAuthenticatedResponse, error) {
	return UsersCheckPersonIsFollowedByAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersCheckPersonIsFollowedByAuthenticatedReq is request data for Client.UsersCheckPersonIsFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
type UsersCheckPersonIsFollowedByAuthenticatedReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "users/check-person-is-followed-by-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/following/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) Rel(link RelName, resp *UsersCheckPersonIsFollowedByAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCheckPersonIsFollowedByAuthenticatedResponse is a response for UsersCheckPersonIsFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
type UsersCheckPersonIsFollowedByAuthenticatedResponse struct {
	internal.Response
	request *UsersCheckPersonIsFollowedByAuthenticatedReq
}

/*
UsersCreateGpgKeyForAuthenticated performs requests for "users/create-gpg-key-for-authenticated"

Create a GPG key for the authenticated user.

  POST /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
func UsersCreateGpgKeyForAuthenticated(ctx context.Context, req *UsersCreateGpgKeyForAuthenticatedReq, opt ...options.Option) (*UsersCreateGpgKeyForAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersCreateGpgKeyForAuthenticatedReq)
	}
	resp := &UsersCreateGpgKeyForAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GpgKey{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCreateGpgKeyForAuthenticated performs requests for "users/create-gpg-key-for-authenticated"

Create a GPG key for the authenticated user.

  POST /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
func (c Client) UsersCreateGpgKeyForAuthenticated(ctx context.Context, req *UsersCreateGpgKeyForAuthenticatedReq, opt ...options.Option) (*UsersCreateGpgKeyForAuthenticatedResponse, error) {
	return UsersCreateGpgKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersCreateGpgKeyForAuthenticatedReq is request data for Client.UsersCreateGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
type UsersCreateGpgKeyForAuthenticatedReq struct {
	_url        string
	RequestBody UsersCreateGpgKeyForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *UsersCreateGpgKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersCreateGpgKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "users/create-gpg-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/gpg_keys"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCreateGpgKeyForAuthenticatedReq) Rel(link RelName, resp *UsersCreateGpgKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCreateGpgKeyForAuthenticatedReqBody is a request body for users/create-gpg-key-for-authenticated

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
type UsersCreateGpgKeyForAuthenticatedReqBody struct {

	// A GPG key in ASCII-armored format.
	ArmoredPublicKey *string `json:"armored_public_key"`
}

/*
UsersCreateGpgKeyForAuthenticatedResponse is a response for UsersCreateGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
type UsersCreateGpgKeyForAuthenticatedResponse struct {
	internal.Response
	request *UsersCreateGpgKeyForAuthenticatedReq
	Data    components.GpgKey
}

/*
UsersCreatePublicSshKeyForAuthenticated performs requests for "users/create-public-ssh-key-for-authenticated"

Create a public SSH key for the authenticated user.

  POST /user/keys

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
func UsersCreatePublicSshKeyForAuthenticated(ctx context.Context, req *UsersCreatePublicSshKeyForAuthenticatedReq, opt ...options.Option) (*UsersCreatePublicSshKeyForAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersCreatePublicSshKeyForAuthenticatedReq)
	}
	resp := &UsersCreatePublicSshKeyForAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Key{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCreatePublicSshKeyForAuthenticated performs requests for "users/create-public-ssh-key-for-authenticated"

Create a public SSH key for the authenticated user.

  POST /user/keys

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
func (c Client) UsersCreatePublicSshKeyForAuthenticated(ctx context.Context, req *UsersCreatePublicSshKeyForAuthenticatedReq, opt ...options.Option) (*UsersCreatePublicSshKeyForAuthenticatedResponse, error) {
	return UsersCreatePublicSshKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersCreatePublicSshKeyForAuthenticatedReq is request data for Client.UsersCreatePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
type UsersCreatePublicSshKeyForAuthenticatedReq struct {
	_url        string
	RequestBody UsersCreatePublicSshKeyForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *UsersCreatePublicSshKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersCreatePublicSshKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "users/create-public-ssh-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/keys"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCreatePublicSshKeyForAuthenticatedReq) Rel(link RelName, resp *UsersCreatePublicSshKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCreatePublicSshKeyForAuthenticatedReqBody is a request body for users/create-public-ssh-key-for-authenticated

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
type UsersCreatePublicSshKeyForAuthenticatedReqBody struct {

	// The public SSH key to add to your GitHub account.
	Key *string `json:"key"`

	// A descriptive name for the new key.
	Title *string `json:"title,omitempty"`
}

/*
UsersCreatePublicSshKeyForAuthenticatedResponse is a response for UsersCreatePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
type UsersCreatePublicSshKeyForAuthenticatedResponse struct {
	internal.Response
	request *UsersCreatePublicSshKeyForAuthenticatedReq
	Data    components.Key
}

/*
UsersDeleteEmailForAuthenticated performs requests for "users/delete-email-for-authenticated"

Delete an email address for the authenticated user.

  DELETE /user/emails

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
func UsersDeleteEmailForAuthenticated(ctx context.Context, req *UsersDeleteEmailForAuthenticatedReq, opt ...options.Option) (*UsersDeleteEmailForAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersDeleteEmailForAuthenticatedReq)
	}
	resp := &UsersDeleteEmailForAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersDeleteEmailForAuthenticated performs requests for "users/delete-email-for-authenticated"

Delete an email address for the authenticated user.

  DELETE /user/emails

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
func (c Client) UsersDeleteEmailForAuthenticated(ctx context.Context, req *UsersDeleteEmailForAuthenticatedReq, opt ...options.Option) (*UsersDeleteEmailForAuthenticatedResponse, error) {
	return UsersDeleteEmailForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersDeleteEmailForAuthenticatedReq is request data for Client.UsersDeleteEmailForAuthenticated

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
type UsersDeleteEmailForAuthenticatedReq struct {
	_url        string
	RequestBody UsersDeleteEmailForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *UsersDeleteEmailForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersDeleteEmailForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "DELETE",
		OperationID:      "users/delete-email-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/emails"),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersDeleteEmailForAuthenticatedReq) Rel(link RelName, resp *UsersDeleteEmailForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersDeleteEmailForAuthenticatedReqBody is a request body for users/delete-email-for-authenticated

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
type UsersDeleteEmailForAuthenticatedReqBody struct {

	// Email addresses associated with the GitHub user account.
	Emails []string `json:"emails"`
}

/*
UsersDeleteEmailForAuthenticatedResponse is a response for UsersDeleteEmailForAuthenticated

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
type UsersDeleteEmailForAuthenticatedResponse struct {
	internal.Response
	request *UsersDeleteEmailForAuthenticatedReq
}

/*
UsersDeleteGpgKeyForAuthenticated performs requests for "users/delete-gpg-key-for-authenticated"

Delete a GPG key for the authenticated user.

  DELETE /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
func UsersDeleteGpgKeyForAuthenticated(ctx context.Context, req *UsersDeleteGpgKeyForAuthenticatedReq, opt ...options.Option) (*UsersDeleteGpgKeyForAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersDeleteGpgKeyForAuthenticatedReq)
	}
	resp := &UsersDeleteGpgKeyForAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersDeleteGpgKeyForAuthenticated performs requests for "users/delete-gpg-key-for-authenticated"

Delete a GPG key for the authenticated user.

  DELETE /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
func (c Client) UsersDeleteGpgKeyForAuthenticated(ctx context.Context, req *UsersDeleteGpgKeyForAuthenticatedReq, opt ...options.Option) (*UsersDeleteGpgKeyForAuthenticatedResponse, error) {
	return UsersDeleteGpgKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersDeleteGpgKeyForAuthenticatedReq is request data for Client.UsersDeleteGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
type UsersDeleteGpgKeyForAuthenticatedReq struct {
	_url string

	// gpg_key_id parameter
	GpgKeyId int64
}

// HTTPRequest builds an *http.Request
func (r *UsersDeleteGpgKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersDeleteGpgKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "users/delete-gpg-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/gpg_keys/%v", r.GpgKeyId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersDeleteGpgKeyForAuthenticatedReq) Rel(link RelName, resp *UsersDeleteGpgKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersDeleteGpgKeyForAuthenticatedResponse is a response for UsersDeleteGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
type UsersDeleteGpgKeyForAuthenticatedResponse struct {
	internal.Response
	request *UsersDeleteGpgKeyForAuthenticatedReq
}

/*
UsersDeletePublicSshKeyForAuthenticated performs requests for "users/delete-public-ssh-key-for-authenticated"

Delete a public SSH key for the authenticated user.

  DELETE /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
func UsersDeletePublicSshKeyForAuthenticated(ctx context.Context, req *UsersDeletePublicSshKeyForAuthenticatedReq, opt ...options.Option) (*UsersDeletePublicSshKeyForAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersDeletePublicSshKeyForAuthenticatedReq)
	}
	resp := &UsersDeletePublicSshKeyForAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersDeletePublicSshKeyForAuthenticated performs requests for "users/delete-public-ssh-key-for-authenticated"

Delete a public SSH key for the authenticated user.

  DELETE /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
func (c Client) UsersDeletePublicSshKeyForAuthenticated(ctx context.Context, req *UsersDeletePublicSshKeyForAuthenticatedReq, opt ...options.Option) (*UsersDeletePublicSshKeyForAuthenticatedResponse, error) {
	return UsersDeletePublicSshKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersDeletePublicSshKeyForAuthenticatedReq is request data for Client.UsersDeletePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
type UsersDeletePublicSshKeyForAuthenticatedReq struct {
	_url string

	// key_id parameter
	KeyId int64
}

// HTTPRequest builds an *http.Request
func (r *UsersDeletePublicSshKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersDeletePublicSshKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "users/delete-public-ssh-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/keys/%v", r.KeyId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersDeletePublicSshKeyForAuthenticatedReq) Rel(link RelName, resp *UsersDeletePublicSshKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersDeletePublicSshKeyForAuthenticatedResponse is a response for UsersDeletePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
type UsersDeletePublicSshKeyForAuthenticatedResponse struct {
	internal.Response
	request *UsersDeletePublicSshKeyForAuthenticatedReq
}

/*
UsersFollow performs requests for "users/follow"

Follow a user.

  PUT /user/following/{username}

https://developer.github.com/v3/users/followers/#follow-a-user
*/
func UsersFollow(ctx context.Context, req *UsersFollowReq, opt ...options.Option) (*UsersFollowResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersFollowReq)
	}
	resp := &UsersFollowResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersFollow performs requests for "users/follow"

Follow a user.

  PUT /user/following/{username}

https://developer.github.com/v3/users/followers/#follow-a-user
*/
func (c Client) UsersFollow(ctx context.Context, req *UsersFollowReq, opt ...options.Option) (*UsersFollowResponse, error) {
	return UsersFollow(ctx, req, append(c, opt...)...)
}

/*
UsersFollowReq is request data for Client.UsersFollow

https://developer.github.com/v3/users/followers/#follow-a-user
*/
type UsersFollowReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *UsersFollowReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersFollowReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "users/follow",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/following/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersFollowReq) Rel(link RelName, resp *UsersFollowResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersFollowResponse is a response for UsersFollow

https://developer.github.com/v3/users/followers/#follow-a-user
*/
type UsersFollowResponse struct {
	internal.Response
	request *UsersFollowReq
}

/*
UsersGetAuthenticated performs requests for "users/get-authenticated"

Get the authenticated user.

  GET /user

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
func UsersGetAuthenticated(ctx context.Context, req *UsersGetAuthenticatedReq, opt ...options.Option) (*UsersGetAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersGetAuthenticatedReq)
	}
	resp := &UsersGetAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = UsersGetAuthenticatedResponseBody{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetAuthenticated performs requests for "users/get-authenticated"

Get the authenticated user.

  GET /user

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
func (c Client) UsersGetAuthenticated(ctx context.Context, req *UsersGetAuthenticatedReq, opt ...options.Option) (*UsersGetAuthenticatedResponse, error) {
	return UsersGetAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersGetAuthenticatedReq is request data for Client.UsersGetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type UsersGetAuthenticatedReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *UsersGetAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersGetAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/get-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetAuthenticatedReq) Rel(link RelName, resp *UsersGetAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetAuthenticatedResponseBody is a response body for UsersGetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type UsersGetAuthenticatedResponseBody struct {
	oneOfField string

	// Private User
	privateUser components.PrivateUser

	// Public User
	publicUser components.PublicUser
}

// Value returns UsersGetAuthenticatedResponseBody's value. The type will be one of PrivateUser or PublicUser.
func (c *UsersGetAuthenticatedResponseBody) Value() interface{} {
	switch c.oneOfField {
	case "privateUser":
		return c.privateUser
	case "publicUser":
		return c.publicUser
	}
	return nil
}

// SetValue sets UsersGetAuthenticatedResponseBody's value. The type must be one of PrivateUser or PublicUser.
func (c *UsersGetAuthenticatedResponseBody) SetValue(value interface{}) {
	switch v := value.(type) {
	case components.PrivateUser:
		c.privateUser = v
	case components.PublicUser:
		c.publicUser = v
	default:
		panic("type not acceptable")
	}
}

func (c *UsersGetAuthenticatedResponseBody) MarshalJSON() ([]byte, error) {
	switch c.oneOfField {
	case "privateUser":
		return json.Marshal(&c.privateUser)
	case "publicUser":
		return json.Marshal(&c.publicUser)
	}
	return json.Marshal(interface{}(nil))
}

func (c *UsersGetAuthenticatedResponseBody) UnmarshalJSON(data []byte) error {
	var err error
	err = json.Unmarshal(data, &c.privateUser)
	if err == nil {
		c.oneOfField = "privateUser"
		return nil
	}
	err = json.Unmarshal(data, &c.publicUser)
	if err == nil {
		c.oneOfField = "publicUser"
		return nil
	}
	return fmt.Errorf("could not unmarshal json")
}

/*
UsersGetAuthenticatedResponse is a response for UsersGetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type UsersGetAuthenticatedResponse struct {
	internal.Response
	request *UsersGetAuthenticatedReq
	Data    UsersGetAuthenticatedResponseBody
}

/*
UsersGetByUsername performs requests for "users/get-by-username"

Get a user.

  GET /users/{username}

https://developer.github.com/v3/users/#get-a-user
*/
func UsersGetByUsername(ctx context.Context, req *UsersGetByUsernameReq, opt ...options.Option) (*UsersGetByUsernameResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersGetByUsernameReq)
	}
	resp := &UsersGetByUsernameResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = UsersGetByUsernameResponseBody{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetByUsername performs requests for "users/get-by-username"

Get a user.

  GET /users/{username}

https://developer.github.com/v3/users/#get-a-user
*/
func (c Client) UsersGetByUsername(ctx context.Context, req *UsersGetByUsernameReq, opt ...options.Option) (*UsersGetByUsernameResponse, error) {
	return UsersGetByUsername(ctx, req, append(c, opt...)...)
}

/*
UsersGetByUsernameReq is request data for Client.UsersGetByUsername

https://developer.github.com/v3/users/#get-a-user
*/
type UsersGetByUsernameReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *UsersGetByUsernameReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersGetByUsernameReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/get-by-username",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetByUsernameReq) Rel(link RelName, resp *UsersGetByUsernameResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetByUsernameResponseBody is a response body for UsersGetByUsername

https://developer.github.com/v3/users/#get-a-user
*/
type UsersGetByUsernameResponseBody struct {
	oneOfField string

	// Private User
	privateUser components.PrivateUser

	// Public User
	publicUser components.PublicUser
}

// Value returns UsersGetByUsernameResponseBody's value. The type will be one of PrivateUser or PublicUser.
func (c *UsersGetByUsernameResponseBody) Value() interface{} {
	switch c.oneOfField {
	case "privateUser":
		return c.privateUser
	case "publicUser":
		return c.publicUser
	}
	return nil
}

// SetValue sets UsersGetByUsernameResponseBody's value. The type must be one of PrivateUser or PublicUser.
func (c *UsersGetByUsernameResponseBody) SetValue(value interface{}) {
	switch v := value.(type) {
	case components.PrivateUser:
		c.privateUser = v
	case components.PublicUser:
		c.publicUser = v
	default:
		panic("type not acceptable")
	}
}

func (c *UsersGetByUsernameResponseBody) MarshalJSON() ([]byte, error) {
	switch c.oneOfField {
	case "privateUser":
		return json.Marshal(&c.privateUser)
	case "publicUser":
		return json.Marshal(&c.publicUser)
	}
	return json.Marshal(interface{}(nil))
}

func (c *UsersGetByUsernameResponseBody) UnmarshalJSON(data []byte) error {
	var err error
	err = json.Unmarshal(data, &c.privateUser)
	if err == nil {
		c.oneOfField = "privateUser"
		return nil
	}
	err = json.Unmarshal(data, &c.publicUser)
	if err == nil {
		c.oneOfField = "publicUser"
		return nil
	}
	return fmt.Errorf("could not unmarshal json")
}

/*
UsersGetByUsernameResponse is a response for UsersGetByUsername

https://developer.github.com/v3/users/#get-a-user
*/
type UsersGetByUsernameResponse struct {
	internal.Response
	request *UsersGetByUsernameReq
	Data    UsersGetByUsernameResponseBody
}

/*
UsersGetContextForUser performs requests for "users/get-context-for-user"

Get contextual information for a user.

  GET /users/{username}/hovercard

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
func UsersGetContextForUser(ctx context.Context, req *UsersGetContextForUserReq, opt ...options.Option) (*UsersGetContextForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersGetContextForUserReq)
	}
	resp := &UsersGetContextForUserResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Hovercard{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetContextForUser performs requests for "users/get-context-for-user"

Get contextual information for a user.

  GET /users/{username}/hovercard

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
func (c Client) UsersGetContextForUser(ctx context.Context, req *UsersGetContextForUserReq, opt ...options.Option) (*UsersGetContextForUserResponse, error) {
	return UsersGetContextForUser(ctx, req, append(c, opt...)...)
}

/*
UsersGetContextForUserReq is request data for Client.UsersGetContextForUser

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
type UsersGetContextForUserReq struct {
	_url     string
	Username string

	/*
	Identifies which additional information you'd like to receive about the person's
	hovercard. Can be `organization`, `repository`, `issue`, `pull_request`.
	**Required** when using `subject_id`.
	*/
	SubjectType *string

	/*
	Uses the ID for the `subject_type` you specified. **Required** when using
	`subject_type`.
	*/
	SubjectId *string
}

// HTTPRequest builds an *http.Request
func (r *UsersGetContextForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersGetContextForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.SubjectType != nil {
		query.Set("subject_type", *r.SubjectType)
	}
	if r.SubjectId != nil {
		query.Set("subject_id", *r.SubjectId)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/get-context-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/hovercard", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetContextForUserReq) Rel(link RelName, resp *UsersGetContextForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetContextForUserResponse is a response for UsersGetContextForUser

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
type UsersGetContextForUserResponse struct {
	internal.Response
	request *UsersGetContextForUserReq
	Data    components.Hovercard
}

/*
UsersGetGpgKeyForAuthenticated performs requests for "users/get-gpg-key-for-authenticated"

Get a GPG key for the authenticated user.

  GET /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
func UsersGetGpgKeyForAuthenticated(ctx context.Context, req *UsersGetGpgKeyForAuthenticatedReq, opt ...options.Option) (*UsersGetGpgKeyForAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersGetGpgKeyForAuthenticatedReq)
	}
	resp := &UsersGetGpgKeyForAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GpgKey{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetGpgKeyForAuthenticated performs requests for "users/get-gpg-key-for-authenticated"

Get a GPG key for the authenticated user.

  GET /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
func (c Client) UsersGetGpgKeyForAuthenticated(ctx context.Context, req *UsersGetGpgKeyForAuthenticatedReq, opt ...options.Option) (*UsersGetGpgKeyForAuthenticatedResponse, error) {
	return UsersGetGpgKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersGetGpgKeyForAuthenticatedReq is request data for Client.UsersGetGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
type UsersGetGpgKeyForAuthenticatedReq struct {
	_url string

	// gpg_key_id parameter
	GpgKeyId int64
}

// HTTPRequest builds an *http.Request
func (r *UsersGetGpgKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersGetGpgKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/get-gpg-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/gpg_keys/%v", r.GpgKeyId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetGpgKeyForAuthenticatedReq) Rel(link RelName, resp *UsersGetGpgKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetGpgKeyForAuthenticatedResponse is a response for UsersGetGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
type UsersGetGpgKeyForAuthenticatedResponse struct {
	internal.Response
	request *UsersGetGpgKeyForAuthenticatedReq
	Data    components.GpgKey
}

/*
UsersGetPublicSshKeyForAuthenticated performs requests for "users/get-public-ssh-key-for-authenticated"

Get a public SSH key for the authenticated user.

  GET /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
func UsersGetPublicSshKeyForAuthenticated(ctx context.Context, req *UsersGetPublicSshKeyForAuthenticatedReq, opt ...options.Option) (*UsersGetPublicSshKeyForAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersGetPublicSshKeyForAuthenticatedReq)
	}
	resp := &UsersGetPublicSshKeyForAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Key{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetPublicSshKeyForAuthenticated performs requests for "users/get-public-ssh-key-for-authenticated"

Get a public SSH key for the authenticated user.

  GET /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
func (c Client) UsersGetPublicSshKeyForAuthenticated(ctx context.Context, req *UsersGetPublicSshKeyForAuthenticatedReq, opt ...options.Option) (*UsersGetPublicSshKeyForAuthenticatedResponse, error) {
	return UsersGetPublicSshKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersGetPublicSshKeyForAuthenticatedReq is request data for Client.UsersGetPublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
type UsersGetPublicSshKeyForAuthenticatedReq struct {
	_url string

	// key_id parameter
	KeyId int64
}

// HTTPRequest builds an *http.Request
func (r *UsersGetPublicSshKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersGetPublicSshKeyForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/get-public-ssh-key-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/keys/%v", r.KeyId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetPublicSshKeyForAuthenticatedReq) Rel(link RelName, resp *UsersGetPublicSshKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetPublicSshKeyForAuthenticatedResponse is a response for UsersGetPublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
type UsersGetPublicSshKeyForAuthenticatedResponse struct {
	internal.Response
	request *UsersGetPublicSshKeyForAuthenticatedReq
	Data    components.Key
}

/*
UsersList performs requests for "users/list"

List users.

  GET /users

https://developer.github.com/v3/users/#list-users
*/
func UsersList(ctx context.Context, req *UsersListReq, opt ...options.Option) (*UsersListResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersListReq)
	}
	resp := &UsersListResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersList performs requests for "users/list"

List users.

  GET /users

https://developer.github.com/v3/users/#list-users
*/
func (c Client) UsersList(ctx context.Context, req *UsersListReq, opt ...options.Option) (*UsersListResponse, error) {
	return UsersList(ctx, req, append(c, opt...)...)
}

/*
UsersListReq is request data for Client.UsersList

https://developer.github.com/v3/users/#list-users
*/
type UsersListReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64
}

// HTTPRequest builds an *http.Request
func (r *UsersListReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/list",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListReq) Rel(link RelName, resp *UsersListResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListResponse is a response for UsersList

https://developer.github.com/v3/users/#list-users
*/
type UsersListResponse struct {
	internal.Response
	request *UsersListReq
	Data    []components.SimpleUser
}

/*
UsersListBlockedByAuthenticated performs requests for "users/list-blocked-by-authenticated"

List users blocked by the authenticated user.

  GET /user/blocks

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
func UsersListBlockedByAuthenticated(ctx context.Context, req *UsersListBlockedByAuthenticatedReq, opt ...options.Option) (*UsersListBlockedByAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersListBlockedByAuthenticatedReq)
	}
	resp := &UsersListBlockedByAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListBlockedByAuthenticated performs requests for "users/list-blocked-by-authenticated"

List users blocked by the authenticated user.

  GET /user/blocks

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
func (c Client) UsersListBlockedByAuthenticated(ctx context.Context, req *UsersListBlockedByAuthenticatedReq, opt ...options.Option) (*UsersListBlockedByAuthenticatedResponse, error) {
	return UsersListBlockedByAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersListBlockedByAuthenticatedReq is request data for Client.UsersListBlockedByAuthenticated

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
type UsersListBlockedByAuthenticatedReq struct {
	_url string
}

// HTTPRequest builds an *http.Request
func (r *UsersListBlockedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersListBlockedByAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-blocked-by-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/blocks"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListBlockedByAuthenticatedReq) Rel(link RelName, resp *UsersListBlockedByAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListBlockedByAuthenticatedResponse is a response for UsersListBlockedByAuthenticated

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
type UsersListBlockedByAuthenticatedResponse struct {
	internal.Response
	request *UsersListBlockedByAuthenticatedReq
	Data    []components.SimpleUser
}

/*
UsersListEmailsForAuthenticated performs requests for "users/list-emails-for-authenticated"

List email addresses for the authenticated user.

  GET /user/emails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
func UsersListEmailsForAuthenticated(ctx context.Context, req *UsersListEmailsForAuthenticatedReq, opt ...options.Option) (*UsersListEmailsForAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersListEmailsForAuthenticatedReq)
	}
	resp := &UsersListEmailsForAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Email{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListEmailsForAuthenticated performs requests for "users/list-emails-for-authenticated"

List email addresses for the authenticated user.

  GET /user/emails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
func (c Client) UsersListEmailsForAuthenticated(ctx context.Context, req *UsersListEmailsForAuthenticatedReq, opt ...options.Option) (*UsersListEmailsForAuthenticatedResponse, error) {
	return UsersListEmailsForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersListEmailsForAuthenticatedReq is request data for Client.UsersListEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
type UsersListEmailsForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *UsersListEmailsForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersListEmailsForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-emails-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/emails"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListEmailsForAuthenticatedReq) Rel(link RelName, resp *UsersListEmailsForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListEmailsForAuthenticatedResponse is a response for UsersListEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
type UsersListEmailsForAuthenticatedResponse struct {
	internal.Response
	request *UsersListEmailsForAuthenticatedReq
	Data    []components.Email
}

/*
UsersListFollowedByAuthenticated performs requests for "users/list-followed-by-authenticated"

List the people the authenticated user follows.

  GET /user/following

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
func UsersListFollowedByAuthenticated(ctx context.Context, req *UsersListFollowedByAuthenticatedReq, opt ...options.Option) (*UsersListFollowedByAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersListFollowedByAuthenticatedReq)
	}
	resp := &UsersListFollowedByAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListFollowedByAuthenticated performs requests for "users/list-followed-by-authenticated"

List the people the authenticated user follows.

  GET /user/following

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
func (c Client) UsersListFollowedByAuthenticated(ctx context.Context, req *UsersListFollowedByAuthenticatedReq, opt ...options.Option) (*UsersListFollowedByAuthenticatedResponse, error) {
	return UsersListFollowedByAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersListFollowedByAuthenticatedReq is request data for Client.UsersListFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
type UsersListFollowedByAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *UsersListFollowedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersListFollowedByAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-followed-by-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/following"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListFollowedByAuthenticatedReq) Rel(link RelName, resp *UsersListFollowedByAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListFollowedByAuthenticatedResponse is a response for UsersListFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
type UsersListFollowedByAuthenticatedResponse struct {
	internal.Response
	request *UsersListFollowedByAuthenticatedReq
	Data    []components.SimpleUser
}

/*
UsersListFollowersForAuthenticatedUser performs requests for "users/list-followers-for-authenticated-user"

List followers of the authenticated user.

  GET /user/followers

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
func UsersListFollowersForAuthenticatedUser(ctx context.Context, req *UsersListFollowersForAuthenticatedUserReq, opt ...options.Option) (*UsersListFollowersForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersListFollowersForAuthenticatedUserReq)
	}
	resp := &UsersListFollowersForAuthenticatedUserResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListFollowersForAuthenticatedUser performs requests for "users/list-followers-for-authenticated-user"

List followers of the authenticated user.

  GET /user/followers

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
func (c Client) UsersListFollowersForAuthenticatedUser(ctx context.Context, req *UsersListFollowersForAuthenticatedUserReq, opt ...options.Option) (*UsersListFollowersForAuthenticatedUserResponse, error) {
	return UsersListFollowersForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
UsersListFollowersForAuthenticatedUserReq is request data for Client.UsersListFollowersForAuthenticatedUser

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type UsersListFollowersForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *UsersListFollowersForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersListFollowersForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-followers-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/followers"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListFollowersForAuthenticatedUserReq) Rel(link RelName, resp *UsersListFollowersForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListFollowersForAuthenticatedUserResponse is a response for UsersListFollowersForAuthenticatedUser

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type UsersListFollowersForAuthenticatedUserResponse struct {
	internal.Response
	request *UsersListFollowersForAuthenticatedUserReq
	Data    []components.SimpleUser
}

/*
UsersListFollowersForUser performs requests for "users/list-followers-for-user"

List followers of a user.

  GET /users/{username}/followers

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
func UsersListFollowersForUser(ctx context.Context, req *UsersListFollowersForUserReq, opt ...options.Option) (*UsersListFollowersForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersListFollowersForUserReq)
	}
	resp := &UsersListFollowersForUserResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListFollowersForUser performs requests for "users/list-followers-for-user"

List followers of a user.

  GET /users/{username}/followers

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
func (c Client) UsersListFollowersForUser(ctx context.Context, req *UsersListFollowersForUserReq, opt ...options.Option) (*UsersListFollowersForUserResponse, error) {
	return UsersListFollowersForUser(ctx, req, append(c, opt...)...)
}

/*
UsersListFollowersForUserReq is request data for Client.UsersListFollowersForUser

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type UsersListFollowersForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *UsersListFollowersForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersListFollowersForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-followers-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/followers", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListFollowersForUserReq) Rel(link RelName, resp *UsersListFollowersForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListFollowersForUserResponse is a response for UsersListFollowersForUser

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type UsersListFollowersForUserResponse struct {
	internal.Response
	request *UsersListFollowersForUserReq
	Data    []components.SimpleUser
}

/*
UsersListFollowingForUser performs requests for "users/list-following-for-user"

List the people a user follows.

  GET /users/{username}/following

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
func UsersListFollowingForUser(ctx context.Context, req *UsersListFollowingForUserReq, opt ...options.Option) (*UsersListFollowingForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersListFollowingForUserReq)
	}
	resp := &UsersListFollowingForUserResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListFollowingForUser performs requests for "users/list-following-for-user"

List the people a user follows.

  GET /users/{username}/following

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
func (c Client) UsersListFollowingForUser(ctx context.Context, req *UsersListFollowingForUserReq, opt ...options.Option) (*UsersListFollowingForUserResponse, error) {
	return UsersListFollowingForUser(ctx, req, append(c, opt...)...)
}

/*
UsersListFollowingForUserReq is request data for Client.UsersListFollowingForUser

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
type UsersListFollowingForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *UsersListFollowingForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersListFollowingForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-following-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/following", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListFollowingForUserReq) Rel(link RelName, resp *UsersListFollowingForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListFollowingForUserResponse is a response for UsersListFollowingForUser

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
type UsersListFollowingForUserResponse struct {
	internal.Response
	request *UsersListFollowingForUserReq
	Data    []components.SimpleUser
}

/*
UsersListGpgKeysForAuthenticated performs requests for "users/list-gpg-keys-for-authenticated"

List GPG keys for the authenticated user.

  GET /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
func UsersListGpgKeysForAuthenticated(ctx context.Context, req *UsersListGpgKeysForAuthenticatedReq, opt ...options.Option) (*UsersListGpgKeysForAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersListGpgKeysForAuthenticatedReq)
	}
	resp := &UsersListGpgKeysForAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.GpgKey{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListGpgKeysForAuthenticated performs requests for "users/list-gpg-keys-for-authenticated"

List GPG keys for the authenticated user.

  GET /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
func (c Client) UsersListGpgKeysForAuthenticated(ctx context.Context, req *UsersListGpgKeysForAuthenticatedReq, opt ...options.Option) (*UsersListGpgKeysForAuthenticatedResponse, error) {
	return UsersListGpgKeysForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersListGpgKeysForAuthenticatedReq is request data for Client.UsersListGpgKeysForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
type UsersListGpgKeysForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *UsersListGpgKeysForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersListGpgKeysForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-gpg-keys-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/gpg_keys"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListGpgKeysForAuthenticatedReq) Rel(link RelName, resp *UsersListGpgKeysForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListGpgKeysForAuthenticatedResponse is a response for UsersListGpgKeysForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
type UsersListGpgKeysForAuthenticatedResponse struct {
	internal.Response
	request *UsersListGpgKeysForAuthenticatedReq
	Data    []components.GpgKey
}

/*
UsersListGpgKeysForUser performs requests for "users/list-gpg-keys-for-user"

List GPG keys for a user.

  GET /users/{username}/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
func UsersListGpgKeysForUser(ctx context.Context, req *UsersListGpgKeysForUserReq, opt ...options.Option) (*UsersListGpgKeysForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersListGpgKeysForUserReq)
	}
	resp := &UsersListGpgKeysForUserResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.GpgKey{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListGpgKeysForUser performs requests for "users/list-gpg-keys-for-user"

List GPG keys for a user.

  GET /users/{username}/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
func (c Client) UsersListGpgKeysForUser(ctx context.Context, req *UsersListGpgKeysForUserReq, opt ...options.Option) (*UsersListGpgKeysForUserResponse, error) {
	return UsersListGpgKeysForUser(ctx, req, append(c, opt...)...)
}

/*
UsersListGpgKeysForUserReq is request data for Client.UsersListGpgKeysForUser

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type UsersListGpgKeysForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *UsersListGpgKeysForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersListGpgKeysForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-gpg-keys-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/gpg_keys", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListGpgKeysForUserReq) Rel(link RelName, resp *UsersListGpgKeysForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListGpgKeysForUserResponse is a response for UsersListGpgKeysForUser

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type UsersListGpgKeysForUserResponse struct {
	internal.Response
	request *UsersListGpgKeysForUserReq
	Data    []components.GpgKey
}

/*
UsersListPublicEmailsForAuthenticated performs requests for "users/list-public-emails-for-authenticated"

List public email addresses for the authenticated user.

  GET /user/public_emails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
func UsersListPublicEmailsForAuthenticated(ctx context.Context, req *UsersListPublicEmailsForAuthenticatedReq, opt ...options.Option) (*UsersListPublicEmailsForAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersListPublicEmailsForAuthenticatedReq)
	}
	resp := &UsersListPublicEmailsForAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Email{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListPublicEmailsForAuthenticated performs requests for "users/list-public-emails-for-authenticated"

List public email addresses for the authenticated user.

  GET /user/public_emails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
func (c Client) UsersListPublicEmailsForAuthenticated(ctx context.Context, req *UsersListPublicEmailsForAuthenticatedReq, opt ...options.Option) (*UsersListPublicEmailsForAuthenticatedResponse, error) {
	return UsersListPublicEmailsForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersListPublicEmailsForAuthenticatedReq is request data for Client.UsersListPublicEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
type UsersListPublicEmailsForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *UsersListPublicEmailsForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersListPublicEmailsForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-public-emails-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/public_emails"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListPublicEmailsForAuthenticatedReq) Rel(link RelName, resp *UsersListPublicEmailsForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListPublicEmailsForAuthenticatedResponse is a response for UsersListPublicEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
type UsersListPublicEmailsForAuthenticatedResponse struct {
	internal.Response
	request *UsersListPublicEmailsForAuthenticatedReq
	Data    []components.Email
}

/*
UsersListPublicKeysForUser performs requests for "users/list-public-keys-for-user"

List public keys for a user.

  GET /users/{username}/keys

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
func UsersListPublicKeysForUser(ctx context.Context, req *UsersListPublicKeysForUserReq, opt ...options.Option) (*UsersListPublicKeysForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersListPublicKeysForUserReq)
	}
	resp := &UsersListPublicKeysForUserResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.KeySimple{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListPublicKeysForUser performs requests for "users/list-public-keys-for-user"

List public keys for a user.

  GET /users/{username}/keys

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
func (c Client) UsersListPublicKeysForUser(ctx context.Context, req *UsersListPublicKeysForUserReq, opt ...options.Option) (*UsersListPublicKeysForUserResponse, error) {
	return UsersListPublicKeysForUser(ctx, req, append(c, opt...)...)
}

/*
UsersListPublicKeysForUserReq is request data for Client.UsersListPublicKeysForUser

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type UsersListPublicKeysForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *UsersListPublicKeysForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersListPublicKeysForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-public-keys-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/keys", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListPublicKeysForUserReq) Rel(link RelName, resp *UsersListPublicKeysForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListPublicKeysForUserResponse is a response for UsersListPublicKeysForUser

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type UsersListPublicKeysForUserResponse struct {
	internal.Response
	request *UsersListPublicKeysForUserReq
	Data    []components.KeySimple
}

/*
UsersListPublicSshKeysForAuthenticated performs requests for "users/list-public-ssh-keys-for-authenticated"

List public SSH keys for the authenticated user.

  GET /user/keys

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
func UsersListPublicSshKeysForAuthenticated(ctx context.Context, req *UsersListPublicSshKeysForAuthenticatedReq, opt ...options.Option) (*UsersListPublicSshKeysForAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersListPublicSshKeysForAuthenticatedReq)
	}
	resp := &UsersListPublicSshKeysForAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Key{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListPublicSshKeysForAuthenticated performs requests for "users/list-public-ssh-keys-for-authenticated"

List public SSH keys for the authenticated user.

  GET /user/keys

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
func (c Client) UsersListPublicSshKeysForAuthenticated(ctx context.Context, req *UsersListPublicSshKeysForAuthenticatedReq, opt ...options.Option) (*UsersListPublicSshKeysForAuthenticatedResponse, error) {
	return UsersListPublicSshKeysForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersListPublicSshKeysForAuthenticatedReq is request data for Client.UsersListPublicSshKeysForAuthenticated

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
type UsersListPublicSshKeysForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *UsersListPublicSshKeysForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersListPublicSshKeysForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "users/list-public-ssh-keys-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/keys"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListPublicSshKeysForAuthenticatedReq) Rel(link RelName, resp *UsersListPublicSshKeysForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListPublicSshKeysForAuthenticatedResponse is a response for UsersListPublicSshKeysForAuthenticated

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
type UsersListPublicSshKeysForAuthenticatedResponse struct {
	internal.Response
	request *UsersListPublicSshKeysForAuthenticatedReq
	Data    []components.Key
}

/*
UsersSetPrimaryEmailVisibilityForAuthenticated performs requests for "users/set-primary-email-visibility-for-authenticated"

Set primary email visibility for the authenticated user.

  PATCH /user/email/visibility

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
func UsersSetPrimaryEmailVisibilityForAuthenticated(ctx context.Context, req *UsersSetPrimaryEmailVisibilityForAuthenticatedReq, opt ...options.Option) (*UsersSetPrimaryEmailVisibilityForAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersSetPrimaryEmailVisibilityForAuthenticatedReq)
	}
	resp := &UsersSetPrimaryEmailVisibilityForAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Email{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersSetPrimaryEmailVisibilityForAuthenticated performs requests for "users/set-primary-email-visibility-for-authenticated"

Set primary email visibility for the authenticated user.

  PATCH /user/email/visibility

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
func (c Client) UsersSetPrimaryEmailVisibilityForAuthenticated(ctx context.Context, req *UsersSetPrimaryEmailVisibilityForAuthenticatedReq, opt ...options.Option) (*UsersSetPrimaryEmailVisibilityForAuthenticatedResponse, error) {
	return UsersSetPrimaryEmailVisibilityForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersSetPrimaryEmailVisibilityForAuthenticatedReq is request data for Client.UsersSetPrimaryEmailVisibilityForAuthenticated

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
type UsersSetPrimaryEmailVisibilityForAuthenticatedReq struct {
	_url        string
	RequestBody UsersSetPrimaryEmailVisibilityForAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "users/set-primary-email-visibility-for-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/email/visibility"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) Rel(link RelName, resp *UsersSetPrimaryEmailVisibilityForAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersSetPrimaryEmailVisibilityForAuthenticatedReqBody is a request body for users/set-primary-email-visibility-for-authenticated

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
type UsersSetPrimaryEmailVisibilityForAuthenticatedReqBody struct {

	// An email address associated with the GitHub user account to manage.
	Email *string `json:"email"`

	// Denotes whether an email is publically visible.
	Visibility *string `json:"visibility"`
}

/*
UsersSetPrimaryEmailVisibilityForAuthenticatedResponse is a response for UsersSetPrimaryEmailVisibilityForAuthenticated

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
type UsersSetPrimaryEmailVisibilityForAuthenticatedResponse struct {
	internal.Response
	request *UsersSetPrimaryEmailVisibilityForAuthenticatedReq
	Data    []components.Email
}

/*
UsersUnblock performs requests for "users/unblock"

Unblock a user.

  DELETE /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
func UsersUnblock(ctx context.Context, req *UsersUnblockReq, opt ...options.Option) (*UsersUnblockResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersUnblockReq)
	}
	resp := &UsersUnblockResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersUnblock performs requests for "users/unblock"

Unblock a user.

  DELETE /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
func (c Client) UsersUnblock(ctx context.Context, req *UsersUnblockReq, opt ...options.Option) (*UsersUnblockResponse, error) {
	return UsersUnblock(ctx, req, append(c, opt...)...)
}

/*
UsersUnblockReq is request data for Client.UsersUnblock

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
type UsersUnblockReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *UsersUnblockReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersUnblockReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "users/unblock",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/blocks/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersUnblockReq) Rel(link RelName, resp *UsersUnblockResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersUnblockResponse is a response for UsersUnblock

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
type UsersUnblockResponse struct {
	internal.Response
	request *UsersUnblockReq
}

/*
UsersUnfollow performs requests for "users/unfollow"

Unfollow a user.

  DELETE /user/following/{username}

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
func UsersUnfollow(ctx context.Context, req *UsersUnfollowReq, opt ...options.Option) (*UsersUnfollowResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersUnfollowReq)
	}
	resp := &UsersUnfollowResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersUnfollow performs requests for "users/unfollow"

Unfollow a user.

  DELETE /user/following/{username}

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
func (c Client) UsersUnfollow(ctx context.Context, req *UsersUnfollowReq, opt ...options.Option) (*UsersUnfollowResponse, error) {
	return UsersUnfollow(ctx, req, append(c, opt...)...)
}

/*
UsersUnfollowReq is request data for Client.UsersUnfollow

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
type UsersUnfollowReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *UsersUnfollowReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersUnfollowReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "users/unfollow",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/following/%v", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersUnfollowReq) Rel(link RelName, resp *UsersUnfollowResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersUnfollowResponse is a response for UsersUnfollow

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
type UsersUnfollowResponse struct {
	internal.Response
	request *UsersUnfollowReq
}

/*
UsersUpdateAuthenticated performs requests for "users/update-authenticated"

Update the authenticated user.

  PATCH /user

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
func UsersUpdateAuthenticated(ctx context.Context, req *UsersUpdateAuthenticatedReq, opt ...options.Option) (*UsersUpdateAuthenticatedResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(UsersUpdateAuthenticatedReq)
	}
	resp := &UsersUpdateAuthenticatedResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PrivateUser{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersUpdateAuthenticated performs requests for "users/update-authenticated"

Update the authenticated user.

  PATCH /user

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
func (c Client) UsersUpdateAuthenticated(ctx context.Context, req *UsersUpdateAuthenticatedReq, opt ...options.Option) (*UsersUpdateAuthenticatedResponse, error) {
	return UsersUpdateAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersUpdateAuthenticatedReq is request data for Client.UsersUpdateAuthenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedReq struct {
	_url        string
	RequestBody UsersUpdateAuthenticatedReqBody
}

// HTTPRequest builds an *http.Request
func (r *UsersUpdateAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *UsersUpdateAuthenticatedReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "users/update-authenticated",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersUpdateAuthenticatedReq) Rel(link RelName, resp *UsersUpdateAuthenticatedResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersUpdateAuthenticatedReqBody is a request body for users/update-authenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedReqBody struct {

	// The new short biography of the user.
	Bio *string `json:"bio,omitempty"`

	// The new blog URL of the user.
	Blog *string `json:"blog,omitempty"`

	// The new company of the user.
	Company *string `json:"company,omitempty"`

	// The publicly visible email address of the user.
	Email *string `json:"email,omitempty"`

	// The new hiring availability of the user.
	Hireable *bool `json:"hireable,omitempty"`

	// The new location of the user.
	Location *string `json:"location,omitempty"`

	// The new name of the user.
	Name *string `json:"name,omitempty"`

	// The new Twitter username of the user.
	TwitterUsername *string `json:"twitter_username,omitempty"`
}

/*
UsersUpdateAuthenticatedResponse is a response for UsersUpdateAuthenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedResponse struct {
	internal.Response
	request *UsersUpdateAuthenticatedReq
	Data    components.PrivateUser
}
