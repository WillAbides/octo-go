// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"encoding/json"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
UsersAddEmailForAuthenticated performs requests for "users/add-email-for-authenticated"

Add an email address for the authenticated user.

  POST /user/emails

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
func UsersAddEmailForAuthenticated(ctx context.Context, req *UsersAddEmailForAuthenticatedReq, opt ...RequestOption) (*UsersAddEmailForAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersAddEmailForAuthenticatedReq)
	}
	resp := &UsersAddEmailForAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersAddEmailForAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersAddEmailForAuthenticated performs requests for "users/add-email-for-authenticated"

Add an email address for the authenticated user.

  POST /user/emails

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
func (c Client) UsersAddEmailForAuthenticated(ctx context.Context, req *UsersAddEmailForAuthenticatedReq, opt ...RequestOption) (*UsersAddEmailForAuthenticatedResponse, error) {
	return UsersAddEmailForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersAddEmailForAuthenticatedReq is request data for Client.UsersAddEmailForAuthenticated

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
type UsersAddEmailForAuthenticatedReq struct {
	_url        string
	RequestBody UsersAddEmailForAuthenticatedReqBody
}

func (r *UsersAddEmailForAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersAddEmailForAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/emails")
}

func (r *UsersAddEmailForAuthenticatedReq) method() string {
	return "POST"
}

func (r *UsersAddEmailForAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersAddEmailForAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersAddEmailForAuthenticatedReq) body() interface{} {
	return r.RequestBody
}

func (r *UsersAddEmailForAuthenticatedReq) dataStatuses() []int {
	return []int{201}
}

func (r *UsersAddEmailForAuthenticatedReq) validStatuses() []int {
	return []int{201, 304}
}

func (r *UsersAddEmailForAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *UsersAddEmailForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersAddEmailForAuthenticatedReq) Rel(link RelName, resp *UsersAddEmailForAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersAddEmailForAuthenticatedReqBody is a request body for users/add-email-for-authenticated

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
type UsersAddEmailForAuthenticatedReqBody struct {

	/*
	Adds one or more email addresses to your GitHub account. Must contain at least
	one email address. **Note:** Alternatively, you can pass a single email address
	or an `array` of emails addresses directly, but we recommend that you pass an
	object using the `emails` key.
	*/
	Emails []string `json:"emails"`
}

/*
UsersAddEmailForAuthenticatedResponseBody is a response body for UsersAddEmailForAuthenticated

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
type UsersAddEmailForAuthenticatedResponseBody []components.Email

/*
UsersAddEmailForAuthenticatedResponse is a response for UsersAddEmailForAuthenticated

https://developer.github.com/v3/users/emails/#add-an-email-address-for-the-authenticated-user
*/
type UsersAddEmailForAuthenticatedResponse struct {
	response
	request *UsersAddEmailForAuthenticatedReq
	Data    UsersAddEmailForAuthenticatedResponseBody
}

/*
UsersBlock performs requests for "users/block"

Block a user.

  PUT /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#block-a-user
*/
func UsersBlock(ctx context.Context, req *UsersBlockReq, opt ...RequestOption) (*UsersBlockResponse, error) {
	if req == nil {
		req = new(UsersBlockReq)
	}
	resp := &UsersBlockResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersBlock performs requests for "users/block"

Block a user.

  PUT /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#block-a-user
*/
func (c Client) UsersBlock(ctx context.Context, req *UsersBlockReq, opt ...RequestOption) (*UsersBlockResponse, error) {
	return UsersBlock(ctx, req, append(c, opt...)...)
}

/*
UsersBlockReq is request data for Client.UsersBlock

https://developer.github.com/v3/users/blocking/#block-a-user
*/
type UsersBlockReq struct {
	_url     string
	Username string
}

func (r *UsersBlockReq) url() string {
	return r._url
}

func (r *UsersBlockReq) urlPath() string {
	return fmt.Sprintf("/user/blocks/%v", r.Username)
}

func (r *UsersBlockReq) method() string {
	return "PUT"
}

func (r *UsersBlockReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersBlockReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersBlockReq) body() interface{} {
	return nil
}

func (r *UsersBlockReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersBlockReq) validStatuses() []int {
	return []int{204, 304}
}

func (r *UsersBlockReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersBlockReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersBlockReq) Rel(link RelName, resp *UsersBlockResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersBlockResponse is a response for UsersBlock

https://developer.github.com/v3/users/blocking/#block-a-user
*/
type UsersBlockResponse struct {
	response
	request *UsersBlockReq
}

/*
UsersCheckBlocked performs requests for "users/check-blocked"

Check if a user is blocked by the authenticated user.

  GET /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
func UsersCheckBlocked(ctx context.Context, req *UsersCheckBlockedReq, opt ...RequestOption) (*UsersCheckBlockedResponse, error) {
	if req == nil {
		req = new(UsersCheckBlockedReq)
	}
	resp := &UsersCheckBlockedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCheckBlocked performs requests for "users/check-blocked"

Check if a user is blocked by the authenticated user.

  GET /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
func (c Client) UsersCheckBlocked(ctx context.Context, req *UsersCheckBlockedReq, opt ...RequestOption) (*UsersCheckBlockedResponse, error) {
	return UsersCheckBlocked(ctx, req, append(c, opt...)...)
}

/*
UsersCheckBlockedReq is request data for Client.UsersCheckBlocked

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
type UsersCheckBlockedReq struct {
	_url     string
	Username string
}

func (r *UsersCheckBlockedReq) url() string {
	return r._url
}

func (r *UsersCheckBlockedReq) urlPath() string {
	return fmt.Sprintf("/user/blocks/%v", r.Username)
}

func (r *UsersCheckBlockedReq) method() string {
	return "GET"
}

func (r *UsersCheckBlockedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersCheckBlockedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersCheckBlockedReq) body() interface{} {
	return nil
}

func (r *UsersCheckBlockedReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersCheckBlockedReq) validStatuses() []int {
	return []int{204, 304}
}

func (r *UsersCheckBlockedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersCheckBlockedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCheckBlockedReq) Rel(link RelName, resp *UsersCheckBlockedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCheckBlockedResponse is a response for UsersCheckBlocked

https://developer.github.com/v3/users/blocking/#check-if-a-user-is-blocked-by-the-authenticated-user
*/
type UsersCheckBlockedResponse struct {
	response
	request *UsersCheckBlockedReq
}

/*
UsersCheckFollowingForUser performs requests for "users/check-following-for-user"

Check if a user follows another user.

  GET /users/{username}/following/{target_user}

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
func UsersCheckFollowingForUser(ctx context.Context, req *UsersCheckFollowingForUserReq, opt ...RequestOption) (*UsersCheckFollowingForUserResponse, error) {
	if req == nil {
		req = new(UsersCheckFollowingForUserReq)
	}
	resp := &UsersCheckFollowingForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCheckFollowingForUser performs requests for "users/check-following-for-user"

Check if a user follows another user.

  GET /users/{username}/following/{target_user}

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
func (c Client) UsersCheckFollowingForUser(ctx context.Context, req *UsersCheckFollowingForUserReq, opt ...RequestOption) (*UsersCheckFollowingForUserResponse, error) {
	return UsersCheckFollowingForUser(ctx, req, append(c, opt...)...)
}

/*
UsersCheckFollowingForUserReq is request data for Client.UsersCheckFollowingForUser

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
type UsersCheckFollowingForUserReq struct {
	_url     string
	Username string

	// target_user parameter
	TargetUser string
}

func (r *UsersCheckFollowingForUserReq) url() string {
	return r._url
}

func (r *UsersCheckFollowingForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/following/%v", r.Username, r.TargetUser)
}

func (r *UsersCheckFollowingForUserReq) method() string {
	return "GET"
}

func (r *UsersCheckFollowingForUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersCheckFollowingForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersCheckFollowingForUserReq) body() interface{} {
	return nil
}

func (r *UsersCheckFollowingForUserReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersCheckFollowingForUserReq) validStatuses() []int {
	return []int{204}
}

func (r *UsersCheckFollowingForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// HTTPRequest builds an *http.Request
func (r *UsersCheckFollowingForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCheckFollowingForUserReq) Rel(link RelName, resp *UsersCheckFollowingForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCheckFollowingForUserResponse is a response for UsersCheckFollowingForUser

https://developer.github.com/v3/users/followers/#check-if-a-user-follows-another-user
*/
type UsersCheckFollowingForUserResponse struct {
	response
	request *UsersCheckFollowingForUserReq
	Data    bool
}

/*
UsersCheckPersonIsFollowedByAuthenticated performs requests for "users/check-person-is-followed-by-authenticated"

Check if a person is followed by the authenticated user.

  GET /user/following/{username}

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
func UsersCheckPersonIsFollowedByAuthenticated(ctx context.Context, req *UsersCheckPersonIsFollowedByAuthenticatedReq, opt ...RequestOption) (*UsersCheckPersonIsFollowedByAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersCheckPersonIsFollowedByAuthenticatedReq)
	}
	resp := &UsersCheckPersonIsFollowedByAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCheckPersonIsFollowedByAuthenticated performs requests for "users/check-person-is-followed-by-authenticated"

Check if a person is followed by the authenticated user.

  GET /user/following/{username}

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
func (c Client) UsersCheckPersonIsFollowedByAuthenticated(ctx context.Context, req *UsersCheckPersonIsFollowedByAuthenticatedReq, opt ...RequestOption) (*UsersCheckPersonIsFollowedByAuthenticatedResponse, error) {
	return UsersCheckPersonIsFollowedByAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersCheckPersonIsFollowedByAuthenticatedReq is request data for Client.UsersCheckPersonIsFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
type UsersCheckPersonIsFollowedByAuthenticatedReq struct {
	_url     string
	Username string
}

func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/following/%v", r.Username)
}

func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) method() string {
	return "GET"
}

func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) validStatuses() []int {
	return []int{204, 304}
}

func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCheckPersonIsFollowedByAuthenticatedReq) Rel(link RelName, resp *UsersCheckPersonIsFollowedByAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCheckPersonIsFollowedByAuthenticatedResponse is a response for UsersCheckPersonIsFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#check-if-a-person-is-followed-by-the-authenticated-user
*/
type UsersCheckPersonIsFollowedByAuthenticatedResponse struct {
	response
	request *UsersCheckPersonIsFollowedByAuthenticatedReq
}

/*
UsersCreateGpgKeyForAuthenticated performs requests for "users/create-gpg-key-for-authenticated"

Create a GPG key for the authenticated user.

  POST /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
func UsersCreateGpgKeyForAuthenticated(ctx context.Context, req *UsersCreateGpgKeyForAuthenticatedReq, opt ...RequestOption) (*UsersCreateGpgKeyForAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersCreateGpgKeyForAuthenticatedReq)
	}
	resp := &UsersCreateGpgKeyForAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersCreateGpgKeyForAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCreateGpgKeyForAuthenticated performs requests for "users/create-gpg-key-for-authenticated"

Create a GPG key for the authenticated user.

  POST /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
func (c Client) UsersCreateGpgKeyForAuthenticated(ctx context.Context, req *UsersCreateGpgKeyForAuthenticatedReq, opt ...RequestOption) (*UsersCreateGpgKeyForAuthenticatedResponse, error) {
	return UsersCreateGpgKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersCreateGpgKeyForAuthenticatedReq is request data for Client.UsersCreateGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
type UsersCreateGpgKeyForAuthenticatedReq struct {
	_url        string
	RequestBody UsersCreateGpgKeyForAuthenticatedReqBody
}

func (r *UsersCreateGpgKeyForAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersCreateGpgKeyForAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/gpg_keys")
}

func (r *UsersCreateGpgKeyForAuthenticatedReq) method() string {
	return "POST"
}

func (r *UsersCreateGpgKeyForAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersCreateGpgKeyForAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersCreateGpgKeyForAuthenticatedReq) body() interface{} {
	return r.RequestBody
}

func (r *UsersCreateGpgKeyForAuthenticatedReq) dataStatuses() []int {
	return []int{201}
}

func (r *UsersCreateGpgKeyForAuthenticatedReq) validStatuses() []int {
	return []int{201, 304}
}

func (r *UsersCreateGpgKeyForAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *UsersCreateGpgKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCreateGpgKeyForAuthenticatedReq) Rel(link RelName, resp *UsersCreateGpgKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCreateGpgKeyForAuthenticatedReqBody is a request body for users/create-gpg-key-for-authenticated

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
type UsersCreateGpgKeyForAuthenticatedReqBody struct {

	// A GPG key in ASCII-armored format.
	ArmoredPublicKey *string `json:"armored_public_key"`
}

/*
UsersCreateGpgKeyForAuthenticatedResponseBody is a response body for UsersCreateGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
type UsersCreateGpgKeyForAuthenticatedResponseBody components.GpgKey

/*
UsersCreateGpgKeyForAuthenticatedResponse is a response for UsersCreateGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key-for-the-authenticated-user
*/
type UsersCreateGpgKeyForAuthenticatedResponse struct {
	response
	request *UsersCreateGpgKeyForAuthenticatedReq
	Data    UsersCreateGpgKeyForAuthenticatedResponseBody
}

/*
UsersCreatePublicSshKeyForAuthenticated performs requests for "users/create-public-ssh-key-for-authenticated"

Create a public SSH key for the authenticated user.

  POST /user/keys

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
func UsersCreatePublicSshKeyForAuthenticated(ctx context.Context, req *UsersCreatePublicSshKeyForAuthenticatedReq, opt ...RequestOption) (*UsersCreatePublicSshKeyForAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersCreatePublicSshKeyForAuthenticatedReq)
	}
	resp := &UsersCreatePublicSshKeyForAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersCreatePublicSshKeyForAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersCreatePublicSshKeyForAuthenticated performs requests for "users/create-public-ssh-key-for-authenticated"

Create a public SSH key for the authenticated user.

  POST /user/keys

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
func (c Client) UsersCreatePublicSshKeyForAuthenticated(ctx context.Context, req *UsersCreatePublicSshKeyForAuthenticatedReq, opt ...RequestOption) (*UsersCreatePublicSshKeyForAuthenticatedResponse, error) {
	return UsersCreatePublicSshKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersCreatePublicSshKeyForAuthenticatedReq is request data for Client.UsersCreatePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
type UsersCreatePublicSshKeyForAuthenticatedReq struct {
	_url        string
	RequestBody UsersCreatePublicSshKeyForAuthenticatedReqBody
}

func (r *UsersCreatePublicSshKeyForAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersCreatePublicSshKeyForAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/keys")
}

func (r *UsersCreatePublicSshKeyForAuthenticatedReq) method() string {
	return "POST"
}

func (r *UsersCreatePublicSshKeyForAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersCreatePublicSshKeyForAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersCreatePublicSshKeyForAuthenticatedReq) body() interface{} {
	return r.RequestBody
}

func (r *UsersCreatePublicSshKeyForAuthenticatedReq) dataStatuses() []int {
	return []int{201}
}

func (r *UsersCreatePublicSshKeyForAuthenticatedReq) validStatuses() []int {
	return []int{201, 304}
}

func (r *UsersCreatePublicSshKeyForAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *UsersCreatePublicSshKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersCreatePublicSshKeyForAuthenticatedReq) Rel(link RelName, resp *UsersCreatePublicSshKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersCreatePublicSshKeyForAuthenticatedReqBody is a request body for users/create-public-ssh-key-for-authenticated

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
type UsersCreatePublicSshKeyForAuthenticatedReqBody struct {

	// The public SSH key to add to your GitHub account.
	Key *string `json:"key"`

	// A descriptive name for the new key.
	Title *string `json:"title,omitempty"`
}

/*
UsersCreatePublicSshKeyForAuthenticatedResponseBody is a response body for UsersCreatePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
type UsersCreatePublicSshKeyForAuthenticatedResponseBody components.Key

/*
UsersCreatePublicSshKeyForAuthenticatedResponse is a response for UsersCreatePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#create-a-public-ssh-key-for-the-authenticated-user
*/
type UsersCreatePublicSshKeyForAuthenticatedResponse struct {
	response
	request *UsersCreatePublicSshKeyForAuthenticatedReq
	Data    UsersCreatePublicSshKeyForAuthenticatedResponseBody
}

/*
UsersDeleteEmailForAuthenticated performs requests for "users/delete-email-for-authenticated"

Delete an email address for the authenticated user.

  DELETE /user/emails

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
func UsersDeleteEmailForAuthenticated(ctx context.Context, req *UsersDeleteEmailForAuthenticatedReq, opt ...RequestOption) (*UsersDeleteEmailForAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersDeleteEmailForAuthenticatedReq)
	}
	resp := &UsersDeleteEmailForAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersDeleteEmailForAuthenticated performs requests for "users/delete-email-for-authenticated"

Delete an email address for the authenticated user.

  DELETE /user/emails

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
func (c Client) UsersDeleteEmailForAuthenticated(ctx context.Context, req *UsersDeleteEmailForAuthenticatedReq, opt ...RequestOption) (*UsersDeleteEmailForAuthenticatedResponse, error) {
	return UsersDeleteEmailForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersDeleteEmailForAuthenticatedReq is request data for Client.UsersDeleteEmailForAuthenticated

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
type UsersDeleteEmailForAuthenticatedReq struct {
	_url        string
	RequestBody UsersDeleteEmailForAuthenticatedReqBody
}

func (r *UsersDeleteEmailForAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersDeleteEmailForAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/emails")
}

func (r *UsersDeleteEmailForAuthenticatedReq) method() string {
	return "DELETE"
}

func (r *UsersDeleteEmailForAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersDeleteEmailForAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"content-type": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersDeleteEmailForAuthenticatedReq) body() interface{} {
	return r.RequestBody
}

func (r *UsersDeleteEmailForAuthenticatedReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersDeleteEmailForAuthenticatedReq) validStatuses() []int {
	return []int{204, 304}
}

func (r *UsersDeleteEmailForAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *UsersDeleteEmailForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersDeleteEmailForAuthenticatedReq) Rel(link RelName, resp *UsersDeleteEmailForAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersDeleteEmailForAuthenticatedReqBody is a request body for users/delete-email-for-authenticated

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
type UsersDeleteEmailForAuthenticatedReqBody struct {

	// Email addresses associated with the GitHub user account.
	Emails []string `json:"emails"`
}

/*
UsersDeleteEmailForAuthenticatedResponse is a response for UsersDeleteEmailForAuthenticated

https://developer.github.com/v3/users/emails/#delete-an-email-address-for-the-authenticated-user
*/
type UsersDeleteEmailForAuthenticatedResponse struct {
	response
	request *UsersDeleteEmailForAuthenticatedReq
}

/*
UsersDeleteGpgKeyForAuthenticated performs requests for "users/delete-gpg-key-for-authenticated"

Delete a GPG key for the authenticated user.

  DELETE /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
func UsersDeleteGpgKeyForAuthenticated(ctx context.Context, req *UsersDeleteGpgKeyForAuthenticatedReq, opt ...RequestOption) (*UsersDeleteGpgKeyForAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersDeleteGpgKeyForAuthenticatedReq)
	}
	resp := &UsersDeleteGpgKeyForAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersDeleteGpgKeyForAuthenticated performs requests for "users/delete-gpg-key-for-authenticated"

Delete a GPG key for the authenticated user.

  DELETE /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
func (c Client) UsersDeleteGpgKeyForAuthenticated(ctx context.Context, req *UsersDeleteGpgKeyForAuthenticatedReq, opt ...RequestOption) (*UsersDeleteGpgKeyForAuthenticatedResponse, error) {
	return UsersDeleteGpgKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersDeleteGpgKeyForAuthenticatedReq is request data for Client.UsersDeleteGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
type UsersDeleteGpgKeyForAuthenticatedReq struct {
	_url string

	// gpg_key_id parameter
	GpgKeyId int64
}

func (r *UsersDeleteGpgKeyForAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersDeleteGpgKeyForAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/gpg_keys/%v", r.GpgKeyId)
}

func (r *UsersDeleteGpgKeyForAuthenticatedReq) method() string {
	return "DELETE"
}

func (r *UsersDeleteGpgKeyForAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersDeleteGpgKeyForAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersDeleteGpgKeyForAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersDeleteGpgKeyForAuthenticatedReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersDeleteGpgKeyForAuthenticatedReq) validStatuses() []int {
	return []int{204, 304}
}

func (r *UsersDeleteGpgKeyForAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersDeleteGpgKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersDeleteGpgKeyForAuthenticatedReq) Rel(link RelName, resp *UsersDeleteGpgKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersDeleteGpgKeyForAuthenticatedResponse is a response for UsersDeleteGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key-for-the-authenticated-user
*/
type UsersDeleteGpgKeyForAuthenticatedResponse struct {
	response
	request *UsersDeleteGpgKeyForAuthenticatedReq
}

/*
UsersDeletePublicSshKeyForAuthenticated performs requests for "users/delete-public-ssh-key-for-authenticated"

Delete a public SSH key for the authenticated user.

  DELETE /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
func UsersDeletePublicSshKeyForAuthenticated(ctx context.Context, req *UsersDeletePublicSshKeyForAuthenticatedReq, opt ...RequestOption) (*UsersDeletePublicSshKeyForAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersDeletePublicSshKeyForAuthenticatedReq)
	}
	resp := &UsersDeletePublicSshKeyForAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersDeletePublicSshKeyForAuthenticated performs requests for "users/delete-public-ssh-key-for-authenticated"

Delete a public SSH key for the authenticated user.

  DELETE /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
func (c Client) UsersDeletePublicSshKeyForAuthenticated(ctx context.Context, req *UsersDeletePublicSshKeyForAuthenticatedReq, opt ...RequestOption) (*UsersDeletePublicSshKeyForAuthenticatedResponse, error) {
	return UsersDeletePublicSshKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersDeletePublicSshKeyForAuthenticatedReq is request data for Client.UsersDeletePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
type UsersDeletePublicSshKeyForAuthenticatedReq struct {
	_url string

	// key_id parameter
	KeyId int64
}

func (r *UsersDeletePublicSshKeyForAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersDeletePublicSshKeyForAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/keys/%v", r.KeyId)
}

func (r *UsersDeletePublicSshKeyForAuthenticatedReq) method() string {
	return "DELETE"
}

func (r *UsersDeletePublicSshKeyForAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersDeletePublicSshKeyForAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersDeletePublicSshKeyForAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersDeletePublicSshKeyForAuthenticatedReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersDeletePublicSshKeyForAuthenticatedReq) validStatuses() []int {
	return []int{204, 304}
}

func (r *UsersDeletePublicSshKeyForAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersDeletePublicSshKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersDeletePublicSshKeyForAuthenticatedReq) Rel(link RelName, resp *UsersDeletePublicSshKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersDeletePublicSshKeyForAuthenticatedResponse is a response for UsersDeletePublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#delete-a-public-ssh-key-for-the-authenticated-user
*/
type UsersDeletePublicSshKeyForAuthenticatedResponse struct {
	response
	request *UsersDeletePublicSshKeyForAuthenticatedReq
}

/*
UsersFollow performs requests for "users/follow"

Follow a user.

  PUT /user/following/{username}

https://developer.github.com/v3/users/followers/#follow-a-user
*/
func UsersFollow(ctx context.Context, req *UsersFollowReq, opt ...RequestOption) (*UsersFollowResponse, error) {
	if req == nil {
		req = new(UsersFollowReq)
	}
	resp := &UsersFollowResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersFollow performs requests for "users/follow"

Follow a user.

  PUT /user/following/{username}

https://developer.github.com/v3/users/followers/#follow-a-user
*/
func (c Client) UsersFollow(ctx context.Context, req *UsersFollowReq, opt ...RequestOption) (*UsersFollowResponse, error) {
	return UsersFollow(ctx, req, append(c, opt...)...)
}

/*
UsersFollowReq is request data for Client.UsersFollow

https://developer.github.com/v3/users/followers/#follow-a-user
*/
type UsersFollowReq struct {
	_url     string
	Username string
}

func (r *UsersFollowReq) url() string {
	return r._url
}

func (r *UsersFollowReq) urlPath() string {
	return fmt.Sprintf("/user/following/%v", r.Username)
}

func (r *UsersFollowReq) method() string {
	return "PUT"
}

func (r *UsersFollowReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersFollowReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersFollowReq) body() interface{} {
	return nil
}

func (r *UsersFollowReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersFollowReq) validStatuses() []int {
	return []int{204, 304}
}

func (r *UsersFollowReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersFollowReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersFollowReq) Rel(link RelName, resp *UsersFollowResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersFollowResponse is a response for UsersFollow

https://developer.github.com/v3/users/followers/#follow-a-user
*/
type UsersFollowResponse struct {
	response
	request *UsersFollowReq
}

/*
UsersGetAuthenticated performs requests for "users/get-authenticated"

Get the authenticated user.

  GET /user

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
func UsersGetAuthenticated(ctx context.Context, req *UsersGetAuthenticatedReq, opt ...RequestOption) (*UsersGetAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersGetAuthenticatedReq)
	}
	resp := &UsersGetAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersGetAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetAuthenticated performs requests for "users/get-authenticated"

Get the authenticated user.

  GET /user

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
func (c Client) UsersGetAuthenticated(ctx context.Context, req *UsersGetAuthenticatedReq, opt ...RequestOption) (*UsersGetAuthenticatedResponse, error) {
	return UsersGetAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersGetAuthenticatedReq is request data for Client.UsersGetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type UsersGetAuthenticatedReq struct {
	_url string
}

func (r *UsersGetAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersGetAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user")
}

func (r *UsersGetAuthenticatedReq) method() string {
	return "GET"
}

func (r *UsersGetAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersGetAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersGetAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersGetAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersGetAuthenticatedReq) validStatuses() []int {
	return []int{200, 304}
}

func (r *UsersGetAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersGetAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetAuthenticatedReq) Rel(link RelName, resp *UsersGetAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetAuthenticatedResponseBody is a response body for UsersGetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type UsersGetAuthenticatedResponseBody struct {
	oneOfField string

	// Private User
	privateUser components.PrivateUser

	// Public User
	publicUser components.PublicUser
}

// Value returns UsersGetAuthenticatedResponseBody's value. The type will be one of PrivateUser or PublicUser.
func (c *UsersGetAuthenticatedResponseBody) Value() interface{} {
	switch c.oneOfField {
	case "privateUser":
		return c.privateUser
	case "publicUser":
		return c.publicUser
	}
	return nil
}

// SetValue sets UsersGetAuthenticatedResponseBody's value. The type must be one of PrivateUser or PublicUser.
func (c *UsersGetAuthenticatedResponseBody) SetValue(value interface{}) {
	switch v := value.(type) {
	case components.PrivateUser:
		c.privateUser = v
	case components.PublicUser:
		c.publicUser = v
	default:
		panic("type not acceptable")
	}
}

func (c *UsersGetAuthenticatedResponseBody) MarshalJSON() ([]byte, error) {
	switch c.oneOfField {
	case "privateUser":
		return json.Marshal(&c.privateUser)
	case "publicUser":
		return json.Marshal(&c.publicUser)
	}
	return json.Marshal(interface{}(nil))
}

func (c *UsersGetAuthenticatedResponseBody) UnmarshalJSON(data []byte) error {
	var err error
	err = json.Unmarshal(data, &c.privateUser)
	if err == nil {
		c.oneOfField = "privateUser"
		return nil
	}
	err = json.Unmarshal(data, &c.publicUser)
	if err == nil {
		c.oneOfField = "publicUser"
		return nil
	}
	return fmt.Errorf("could not unmarshal json")
}

/*
UsersGetAuthenticatedResponse is a response for UsersGetAuthenticated

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type UsersGetAuthenticatedResponse struct {
	response
	request *UsersGetAuthenticatedReq
	Data    UsersGetAuthenticatedResponseBody
}

/*
UsersGetByUsername performs requests for "users/get-by-username"

Get a user.

  GET /users/{username}

https://developer.github.com/v3/users/#get-a-user
*/
func UsersGetByUsername(ctx context.Context, req *UsersGetByUsernameReq, opt ...RequestOption) (*UsersGetByUsernameResponse, error) {
	if req == nil {
		req = new(UsersGetByUsernameReq)
	}
	resp := &UsersGetByUsernameResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersGetByUsernameResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetByUsername performs requests for "users/get-by-username"

Get a user.

  GET /users/{username}

https://developer.github.com/v3/users/#get-a-user
*/
func (c Client) UsersGetByUsername(ctx context.Context, req *UsersGetByUsernameReq, opt ...RequestOption) (*UsersGetByUsernameResponse, error) {
	return UsersGetByUsername(ctx, req, append(c, opt...)...)
}

/*
UsersGetByUsernameReq is request data for Client.UsersGetByUsername

https://developer.github.com/v3/users/#get-a-user
*/
type UsersGetByUsernameReq struct {
	_url     string
	Username string
}

func (r *UsersGetByUsernameReq) url() string {
	return r._url
}

func (r *UsersGetByUsernameReq) urlPath() string {
	return fmt.Sprintf("/users/%v", r.Username)
}

func (r *UsersGetByUsernameReq) method() string {
	return "GET"
}

func (r *UsersGetByUsernameReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersGetByUsernameReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersGetByUsernameReq) body() interface{} {
	return nil
}

func (r *UsersGetByUsernameReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersGetByUsernameReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersGetByUsernameReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersGetByUsernameReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetByUsernameReq) Rel(link RelName, resp *UsersGetByUsernameResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetByUsernameResponseBody is a response body for UsersGetByUsername

https://developer.github.com/v3/users/#get-a-user
*/
type UsersGetByUsernameResponseBody struct {
	oneOfField string

	// Private User
	privateUser components.PrivateUser

	// Public User
	publicUser components.PublicUser
}

// Value returns UsersGetByUsernameResponseBody's value. The type will be one of PrivateUser or PublicUser.
func (c *UsersGetByUsernameResponseBody) Value() interface{} {
	switch c.oneOfField {
	case "privateUser":
		return c.privateUser
	case "publicUser":
		return c.publicUser
	}
	return nil
}

// SetValue sets UsersGetByUsernameResponseBody's value. The type must be one of PrivateUser or PublicUser.
func (c *UsersGetByUsernameResponseBody) SetValue(value interface{}) {
	switch v := value.(type) {
	case components.PrivateUser:
		c.privateUser = v
	case components.PublicUser:
		c.publicUser = v
	default:
		panic("type not acceptable")
	}
}

func (c *UsersGetByUsernameResponseBody) MarshalJSON() ([]byte, error) {
	switch c.oneOfField {
	case "privateUser":
		return json.Marshal(&c.privateUser)
	case "publicUser":
		return json.Marshal(&c.publicUser)
	}
	return json.Marshal(interface{}(nil))
}

func (c *UsersGetByUsernameResponseBody) UnmarshalJSON(data []byte) error {
	var err error
	err = json.Unmarshal(data, &c.privateUser)
	if err == nil {
		c.oneOfField = "privateUser"
		return nil
	}
	err = json.Unmarshal(data, &c.publicUser)
	if err == nil {
		c.oneOfField = "publicUser"
		return nil
	}
	return fmt.Errorf("could not unmarshal json")
}

/*
UsersGetByUsernameResponse is a response for UsersGetByUsername

https://developer.github.com/v3/users/#get-a-user
*/
type UsersGetByUsernameResponse struct {
	response
	request *UsersGetByUsernameReq
	Data    UsersGetByUsernameResponseBody
}

/*
UsersGetContextForUser performs requests for "users/get-context-for-user"

Get contextual information for a user.

  GET /users/{username}/hovercard

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
func UsersGetContextForUser(ctx context.Context, req *UsersGetContextForUserReq, opt ...RequestOption) (*UsersGetContextForUserResponse, error) {
	if req == nil {
		req = new(UsersGetContextForUserReq)
	}
	resp := &UsersGetContextForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersGetContextForUserResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetContextForUser performs requests for "users/get-context-for-user"

Get contextual information for a user.

  GET /users/{username}/hovercard

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
func (c Client) UsersGetContextForUser(ctx context.Context, req *UsersGetContextForUserReq, opt ...RequestOption) (*UsersGetContextForUserResponse, error) {
	return UsersGetContextForUser(ctx, req, append(c, opt...)...)
}

/*
UsersGetContextForUserReq is request data for Client.UsersGetContextForUser

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
type UsersGetContextForUserReq struct {
	_url     string
	Username string

	/*
	Identifies which additional information you'd like to receive about the person's
	hovercard. Can be `organization`, `repository`, `issue`, `pull_request`.
	**Required** when using `subject_id`.
	*/
	SubjectType *string

	/*
	Uses the ID for the `subject_type` you specified. **Required** when using
	`subject_type`.
	*/
	SubjectId *string
}

func (r *UsersGetContextForUserReq) url() string {
	return r._url
}

func (r *UsersGetContextForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/hovercard", r.Username)
}

func (r *UsersGetContextForUserReq) method() string {
	return "GET"
}

func (r *UsersGetContextForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.SubjectType != nil {
		query.Set("subject_type", *r.SubjectType)
	}
	if r.SubjectId != nil {
		query.Set("subject_id", *r.SubjectId)
	}
	return query
}

func (r *UsersGetContextForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersGetContextForUserReq) body() interface{} {
	return nil
}

func (r *UsersGetContextForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersGetContextForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersGetContextForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersGetContextForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetContextForUserReq) Rel(link RelName, resp *UsersGetContextForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetContextForUserResponseBody is a response body for UsersGetContextForUser

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
type UsersGetContextForUserResponseBody components.Hovercard

/*
UsersGetContextForUserResponse is a response for UsersGetContextForUser

https://developer.github.com/v3/users/#get-contextual-information-for-a-user
*/
type UsersGetContextForUserResponse struct {
	response
	request *UsersGetContextForUserReq
	Data    UsersGetContextForUserResponseBody
}

/*
UsersGetGpgKeyForAuthenticated performs requests for "users/get-gpg-key-for-authenticated"

Get a GPG key for the authenticated user.

  GET /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
func UsersGetGpgKeyForAuthenticated(ctx context.Context, req *UsersGetGpgKeyForAuthenticatedReq, opt ...RequestOption) (*UsersGetGpgKeyForAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersGetGpgKeyForAuthenticatedReq)
	}
	resp := &UsersGetGpgKeyForAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersGetGpgKeyForAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetGpgKeyForAuthenticated performs requests for "users/get-gpg-key-for-authenticated"

Get a GPG key for the authenticated user.

  GET /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
func (c Client) UsersGetGpgKeyForAuthenticated(ctx context.Context, req *UsersGetGpgKeyForAuthenticatedReq, opt ...RequestOption) (*UsersGetGpgKeyForAuthenticatedResponse, error) {
	return UsersGetGpgKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersGetGpgKeyForAuthenticatedReq is request data for Client.UsersGetGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
type UsersGetGpgKeyForAuthenticatedReq struct {
	_url string

	// gpg_key_id parameter
	GpgKeyId int64
}

func (r *UsersGetGpgKeyForAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersGetGpgKeyForAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/gpg_keys/%v", r.GpgKeyId)
}

func (r *UsersGetGpgKeyForAuthenticatedReq) method() string {
	return "GET"
}

func (r *UsersGetGpgKeyForAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersGetGpgKeyForAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersGetGpgKeyForAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersGetGpgKeyForAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersGetGpgKeyForAuthenticatedReq) validStatuses() []int {
	return []int{200, 304}
}

func (r *UsersGetGpgKeyForAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersGetGpgKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetGpgKeyForAuthenticatedReq) Rel(link RelName, resp *UsersGetGpgKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetGpgKeyForAuthenticatedResponseBody is a response body for UsersGetGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
type UsersGetGpgKeyForAuthenticatedResponseBody components.GpgKey

/*
UsersGetGpgKeyForAuthenticatedResponse is a response for UsersGetGpgKeyForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#get-a-gpg-key-for-the-authenticated-user
*/
type UsersGetGpgKeyForAuthenticatedResponse struct {
	response
	request *UsersGetGpgKeyForAuthenticatedReq
	Data    UsersGetGpgKeyForAuthenticatedResponseBody
}

/*
UsersGetPublicSshKeyForAuthenticated performs requests for "users/get-public-ssh-key-for-authenticated"

Get a public SSH key for the authenticated user.

  GET /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
func UsersGetPublicSshKeyForAuthenticated(ctx context.Context, req *UsersGetPublicSshKeyForAuthenticatedReq, opt ...RequestOption) (*UsersGetPublicSshKeyForAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersGetPublicSshKeyForAuthenticatedReq)
	}
	resp := &UsersGetPublicSshKeyForAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersGetPublicSshKeyForAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersGetPublicSshKeyForAuthenticated performs requests for "users/get-public-ssh-key-for-authenticated"

Get a public SSH key for the authenticated user.

  GET /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
func (c Client) UsersGetPublicSshKeyForAuthenticated(ctx context.Context, req *UsersGetPublicSshKeyForAuthenticatedReq, opt ...RequestOption) (*UsersGetPublicSshKeyForAuthenticatedResponse, error) {
	return UsersGetPublicSshKeyForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersGetPublicSshKeyForAuthenticatedReq is request data for Client.UsersGetPublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
type UsersGetPublicSshKeyForAuthenticatedReq struct {
	_url string

	// key_id parameter
	KeyId int64
}

func (r *UsersGetPublicSshKeyForAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersGetPublicSshKeyForAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/keys/%v", r.KeyId)
}

func (r *UsersGetPublicSshKeyForAuthenticatedReq) method() string {
	return "GET"
}

func (r *UsersGetPublicSshKeyForAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersGetPublicSshKeyForAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersGetPublicSshKeyForAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersGetPublicSshKeyForAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersGetPublicSshKeyForAuthenticatedReq) validStatuses() []int {
	return []int{200, 304}
}

func (r *UsersGetPublicSshKeyForAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersGetPublicSshKeyForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersGetPublicSshKeyForAuthenticatedReq) Rel(link RelName, resp *UsersGetPublicSshKeyForAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersGetPublicSshKeyForAuthenticatedResponseBody is a response body for UsersGetPublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
type UsersGetPublicSshKeyForAuthenticatedResponseBody components.Key

/*
UsersGetPublicSshKeyForAuthenticatedResponse is a response for UsersGetPublicSshKeyForAuthenticated

https://developer.github.com/v3/users/keys/#get-a-public-ssh-key-for-the-authenticated-user
*/
type UsersGetPublicSshKeyForAuthenticatedResponse struct {
	response
	request *UsersGetPublicSshKeyForAuthenticatedReq
	Data    UsersGetPublicSshKeyForAuthenticatedResponseBody
}

/*
UsersList performs requests for "users/list"

List users.

  GET /users

https://developer.github.com/v3/users/#list-users
*/
func UsersList(ctx context.Context, req *UsersListReq, opt ...RequestOption) (*UsersListResponse, error) {
	if req == nil {
		req = new(UsersListReq)
	}
	resp := &UsersListResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersListResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersList performs requests for "users/list"

List users.

  GET /users

https://developer.github.com/v3/users/#list-users
*/
func (c Client) UsersList(ctx context.Context, req *UsersListReq, opt ...RequestOption) (*UsersListResponse, error) {
	return UsersList(ctx, req, append(c, opt...)...)
}

/*
UsersListReq is request data for Client.UsersList

https://developer.github.com/v3/users/#list-users
*/
type UsersListReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64
}

func (r *UsersListReq) url() string {
	return r._url
}

func (r *UsersListReq) urlPath() string {
	return fmt.Sprintf("/users")
}

func (r *UsersListReq) method() string {
	return "GET"
}

func (r *UsersListReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	return query
}

func (r *UsersListReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListReq) body() interface{} {
	return nil
}

func (r *UsersListReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListReq) validStatuses() []int {
	return []int{200, 304}
}

func (r *UsersListReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListReq) Rel(link RelName, resp *UsersListResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListResponseBody is a response body for UsersList

https://developer.github.com/v3/users/#list-users
*/
type UsersListResponseBody []components.SimpleUser

/*
UsersListResponse is a response for UsersList

https://developer.github.com/v3/users/#list-users
*/
type UsersListResponse struct {
	response
	request *UsersListReq
	Data    UsersListResponseBody
}

/*
UsersListBlockedByAuthenticated performs requests for "users/list-blocked-by-authenticated"

List users blocked by the authenticated user.

  GET /user/blocks

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
func UsersListBlockedByAuthenticated(ctx context.Context, req *UsersListBlockedByAuthenticatedReq, opt ...RequestOption) (*UsersListBlockedByAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersListBlockedByAuthenticatedReq)
	}
	resp := &UsersListBlockedByAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersListBlockedByAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListBlockedByAuthenticated performs requests for "users/list-blocked-by-authenticated"

List users blocked by the authenticated user.

  GET /user/blocks

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
func (c Client) UsersListBlockedByAuthenticated(ctx context.Context, req *UsersListBlockedByAuthenticatedReq, opt ...RequestOption) (*UsersListBlockedByAuthenticatedResponse, error) {
	return UsersListBlockedByAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersListBlockedByAuthenticatedReq is request data for Client.UsersListBlockedByAuthenticated

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
type UsersListBlockedByAuthenticatedReq struct {
	_url string
}

func (r *UsersListBlockedByAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersListBlockedByAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/blocks")
}

func (r *UsersListBlockedByAuthenticatedReq) method() string {
	return "GET"
}

func (r *UsersListBlockedByAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersListBlockedByAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListBlockedByAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersListBlockedByAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListBlockedByAuthenticatedReq) validStatuses() []int {
	return []int{200, 304}
}

func (r *UsersListBlockedByAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListBlockedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListBlockedByAuthenticatedReq) Rel(link RelName, resp *UsersListBlockedByAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListBlockedByAuthenticatedResponseBody is a response body for UsersListBlockedByAuthenticated

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
type UsersListBlockedByAuthenticatedResponseBody []components.SimpleUser

/*
UsersListBlockedByAuthenticatedResponse is a response for UsersListBlockedByAuthenticated

https://developer.github.com/v3/users/blocking/#list-users-blocked-by-the-authenticated-user
*/
type UsersListBlockedByAuthenticatedResponse struct {
	response
	request *UsersListBlockedByAuthenticatedReq
	Data    UsersListBlockedByAuthenticatedResponseBody
}

/*
UsersListEmailsForAuthenticated performs requests for "users/list-emails-for-authenticated"

List email addresses for the authenticated user.

  GET /user/emails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
func UsersListEmailsForAuthenticated(ctx context.Context, req *UsersListEmailsForAuthenticatedReq, opt ...RequestOption) (*UsersListEmailsForAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersListEmailsForAuthenticatedReq)
	}
	resp := &UsersListEmailsForAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersListEmailsForAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListEmailsForAuthenticated performs requests for "users/list-emails-for-authenticated"

List email addresses for the authenticated user.

  GET /user/emails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
func (c Client) UsersListEmailsForAuthenticated(ctx context.Context, req *UsersListEmailsForAuthenticatedReq, opt ...RequestOption) (*UsersListEmailsForAuthenticatedResponse, error) {
	return UsersListEmailsForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersListEmailsForAuthenticatedReq is request data for Client.UsersListEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
type UsersListEmailsForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListEmailsForAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersListEmailsForAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/emails")
}

func (r *UsersListEmailsForAuthenticatedReq) method() string {
	return "GET"
}

func (r *UsersListEmailsForAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListEmailsForAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListEmailsForAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersListEmailsForAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListEmailsForAuthenticatedReq) validStatuses() []int {
	return []int{200, 304}
}

func (r *UsersListEmailsForAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListEmailsForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListEmailsForAuthenticatedReq) Rel(link RelName, resp *UsersListEmailsForAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListEmailsForAuthenticatedResponseBody is a response body for UsersListEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
type UsersListEmailsForAuthenticatedResponseBody []components.Email

/*
UsersListEmailsForAuthenticatedResponse is a response for UsersListEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-email-addresses-for-the-authenticated-user
*/
type UsersListEmailsForAuthenticatedResponse struct {
	response
	request *UsersListEmailsForAuthenticatedReq
	Data    UsersListEmailsForAuthenticatedResponseBody
}

/*
UsersListFollowedByAuthenticated performs requests for "users/list-followed-by-authenticated"

List the people the authenticated user follows.

  GET /user/following

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
func UsersListFollowedByAuthenticated(ctx context.Context, req *UsersListFollowedByAuthenticatedReq, opt ...RequestOption) (*UsersListFollowedByAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersListFollowedByAuthenticatedReq)
	}
	resp := &UsersListFollowedByAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersListFollowedByAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListFollowedByAuthenticated performs requests for "users/list-followed-by-authenticated"

List the people the authenticated user follows.

  GET /user/following

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
func (c Client) UsersListFollowedByAuthenticated(ctx context.Context, req *UsersListFollowedByAuthenticatedReq, opt ...RequestOption) (*UsersListFollowedByAuthenticatedResponse, error) {
	return UsersListFollowedByAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersListFollowedByAuthenticatedReq is request data for Client.UsersListFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
type UsersListFollowedByAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListFollowedByAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersListFollowedByAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/following")
}

func (r *UsersListFollowedByAuthenticatedReq) method() string {
	return "GET"
}

func (r *UsersListFollowedByAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListFollowedByAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListFollowedByAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersListFollowedByAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowedByAuthenticatedReq) validStatuses() []int {
	return []int{200, 304}
}

func (r *UsersListFollowedByAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListFollowedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListFollowedByAuthenticatedReq) Rel(link RelName, resp *UsersListFollowedByAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListFollowedByAuthenticatedResponseBody is a response body for UsersListFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
type UsersListFollowedByAuthenticatedResponseBody []components.SimpleUser

/*
UsersListFollowedByAuthenticatedResponse is a response for UsersListFollowedByAuthenticated

https://developer.github.com/v3/users/followers/#list-the-people-the-authenticated-user-follows
*/
type UsersListFollowedByAuthenticatedResponse struct {
	response
	request *UsersListFollowedByAuthenticatedReq
	Data    UsersListFollowedByAuthenticatedResponseBody
}

/*
UsersListFollowersForAuthenticatedUser performs requests for "users/list-followers-for-authenticated-user"

List followers of the authenticated user.

  GET /user/followers

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
func UsersListFollowersForAuthenticatedUser(ctx context.Context, req *UsersListFollowersForAuthenticatedUserReq, opt ...RequestOption) (*UsersListFollowersForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(UsersListFollowersForAuthenticatedUserReq)
	}
	resp := &UsersListFollowersForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersListFollowersForAuthenticatedUserResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListFollowersForAuthenticatedUser performs requests for "users/list-followers-for-authenticated-user"

List followers of the authenticated user.

  GET /user/followers

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
func (c Client) UsersListFollowersForAuthenticatedUser(ctx context.Context, req *UsersListFollowersForAuthenticatedUserReq, opt ...RequestOption) (*UsersListFollowersForAuthenticatedUserResponse, error) {
	return UsersListFollowersForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
UsersListFollowersForAuthenticatedUserReq is request data for Client.UsersListFollowersForAuthenticatedUser

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type UsersListFollowersForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListFollowersForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *UsersListFollowersForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/followers")
}

func (r *UsersListFollowersForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *UsersListFollowersForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListFollowersForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListFollowersForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *UsersListFollowersForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowersForAuthenticatedUserReq) validStatuses() []int {
	return []int{200, 304}
}

func (r *UsersListFollowersForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListFollowersForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListFollowersForAuthenticatedUserReq) Rel(link RelName, resp *UsersListFollowersForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListFollowersForAuthenticatedUserResponseBody is a response body for UsersListFollowersForAuthenticatedUser

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type UsersListFollowersForAuthenticatedUserResponseBody []components.SimpleUser

/*
UsersListFollowersForAuthenticatedUserResponse is a response for UsersListFollowersForAuthenticatedUser

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type UsersListFollowersForAuthenticatedUserResponse struct {
	response
	request *UsersListFollowersForAuthenticatedUserReq
	Data    UsersListFollowersForAuthenticatedUserResponseBody
}

/*
UsersListFollowersForUser performs requests for "users/list-followers-for-user"

List followers of a user.

  GET /users/{username}/followers

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
func UsersListFollowersForUser(ctx context.Context, req *UsersListFollowersForUserReq, opt ...RequestOption) (*UsersListFollowersForUserResponse, error) {
	if req == nil {
		req = new(UsersListFollowersForUserReq)
	}
	resp := &UsersListFollowersForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersListFollowersForUserResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListFollowersForUser performs requests for "users/list-followers-for-user"

List followers of a user.

  GET /users/{username}/followers

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
func (c Client) UsersListFollowersForUser(ctx context.Context, req *UsersListFollowersForUserReq, opt ...RequestOption) (*UsersListFollowersForUserResponse, error) {
	return UsersListFollowersForUser(ctx, req, append(c, opt...)...)
}

/*
UsersListFollowersForUserReq is request data for Client.UsersListFollowersForUser

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type UsersListFollowersForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListFollowersForUserReq) url() string {
	return r._url
}

func (r *UsersListFollowersForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/followers", r.Username)
}

func (r *UsersListFollowersForUserReq) method() string {
	return "GET"
}

func (r *UsersListFollowersForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListFollowersForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListFollowersForUserReq) body() interface{} {
	return nil
}

func (r *UsersListFollowersForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowersForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowersForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListFollowersForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListFollowersForUserReq) Rel(link RelName, resp *UsersListFollowersForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListFollowersForUserResponseBody is a response body for UsersListFollowersForUser

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type UsersListFollowersForUserResponseBody []components.SimpleUser

/*
UsersListFollowersForUserResponse is a response for UsersListFollowersForUser

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type UsersListFollowersForUserResponse struct {
	response
	request *UsersListFollowersForUserReq
	Data    UsersListFollowersForUserResponseBody
}

/*
UsersListFollowingForUser performs requests for "users/list-following-for-user"

List the people a user follows.

  GET /users/{username}/following

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
func UsersListFollowingForUser(ctx context.Context, req *UsersListFollowingForUserReq, opt ...RequestOption) (*UsersListFollowingForUserResponse, error) {
	if req == nil {
		req = new(UsersListFollowingForUserReq)
	}
	resp := &UsersListFollowingForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersListFollowingForUserResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListFollowingForUser performs requests for "users/list-following-for-user"

List the people a user follows.

  GET /users/{username}/following

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
func (c Client) UsersListFollowingForUser(ctx context.Context, req *UsersListFollowingForUserReq, opt ...RequestOption) (*UsersListFollowingForUserResponse, error) {
	return UsersListFollowingForUser(ctx, req, append(c, opt...)...)
}

/*
UsersListFollowingForUserReq is request data for Client.UsersListFollowingForUser

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
type UsersListFollowingForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListFollowingForUserReq) url() string {
	return r._url
}

func (r *UsersListFollowingForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/following", r.Username)
}

func (r *UsersListFollowingForUserReq) method() string {
	return "GET"
}

func (r *UsersListFollowingForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListFollowingForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListFollowingForUserReq) body() interface{} {
	return nil
}

func (r *UsersListFollowingForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowingForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListFollowingForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListFollowingForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListFollowingForUserReq) Rel(link RelName, resp *UsersListFollowingForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListFollowingForUserResponseBody is a response body for UsersListFollowingForUser

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
type UsersListFollowingForUserResponseBody []components.SimpleUser

/*
UsersListFollowingForUserResponse is a response for UsersListFollowingForUser

https://developer.github.com/v3/users/followers/#list-the-people-a-user-follows
*/
type UsersListFollowingForUserResponse struct {
	response
	request *UsersListFollowingForUserReq
	Data    UsersListFollowingForUserResponseBody
}

/*
UsersListGpgKeysForAuthenticated performs requests for "users/list-gpg-keys-for-authenticated"

List GPG keys for the authenticated user.

  GET /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
func UsersListGpgKeysForAuthenticated(ctx context.Context, req *UsersListGpgKeysForAuthenticatedReq, opt ...RequestOption) (*UsersListGpgKeysForAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersListGpgKeysForAuthenticatedReq)
	}
	resp := &UsersListGpgKeysForAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersListGpgKeysForAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListGpgKeysForAuthenticated performs requests for "users/list-gpg-keys-for-authenticated"

List GPG keys for the authenticated user.

  GET /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
func (c Client) UsersListGpgKeysForAuthenticated(ctx context.Context, req *UsersListGpgKeysForAuthenticatedReq, opt ...RequestOption) (*UsersListGpgKeysForAuthenticatedResponse, error) {
	return UsersListGpgKeysForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersListGpgKeysForAuthenticatedReq is request data for Client.UsersListGpgKeysForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
type UsersListGpgKeysForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListGpgKeysForAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersListGpgKeysForAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/gpg_keys")
}

func (r *UsersListGpgKeysForAuthenticatedReq) method() string {
	return "GET"
}

func (r *UsersListGpgKeysForAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListGpgKeysForAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListGpgKeysForAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersListGpgKeysForAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListGpgKeysForAuthenticatedReq) validStatuses() []int {
	return []int{200, 304}
}

func (r *UsersListGpgKeysForAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListGpgKeysForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListGpgKeysForAuthenticatedReq) Rel(link RelName, resp *UsersListGpgKeysForAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListGpgKeysForAuthenticatedResponseBody is a response body for UsersListGpgKeysForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
type UsersListGpgKeysForAuthenticatedResponseBody []components.GpgKey

/*
UsersListGpgKeysForAuthenticatedResponse is a response for UsersListGpgKeysForAuthenticated

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-the-authenticated-user
*/
type UsersListGpgKeysForAuthenticatedResponse struct {
	response
	request *UsersListGpgKeysForAuthenticatedReq
	Data    UsersListGpgKeysForAuthenticatedResponseBody
}

/*
UsersListGpgKeysForUser performs requests for "users/list-gpg-keys-for-user"

List GPG keys for a user.

  GET /users/{username}/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
func UsersListGpgKeysForUser(ctx context.Context, req *UsersListGpgKeysForUserReq, opt ...RequestOption) (*UsersListGpgKeysForUserResponse, error) {
	if req == nil {
		req = new(UsersListGpgKeysForUserReq)
	}
	resp := &UsersListGpgKeysForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersListGpgKeysForUserResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListGpgKeysForUser performs requests for "users/list-gpg-keys-for-user"

List GPG keys for a user.

  GET /users/{username}/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
func (c Client) UsersListGpgKeysForUser(ctx context.Context, req *UsersListGpgKeysForUserReq, opt ...RequestOption) (*UsersListGpgKeysForUserResponse, error) {
	return UsersListGpgKeysForUser(ctx, req, append(c, opt...)...)
}

/*
UsersListGpgKeysForUserReq is request data for Client.UsersListGpgKeysForUser

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type UsersListGpgKeysForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListGpgKeysForUserReq) url() string {
	return r._url
}

func (r *UsersListGpgKeysForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/gpg_keys", r.Username)
}

func (r *UsersListGpgKeysForUserReq) method() string {
	return "GET"
}

func (r *UsersListGpgKeysForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListGpgKeysForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListGpgKeysForUserReq) body() interface{} {
	return nil
}

func (r *UsersListGpgKeysForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListGpgKeysForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListGpgKeysForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListGpgKeysForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListGpgKeysForUserReq) Rel(link RelName, resp *UsersListGpgKeysForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListGpgKeysForUserResponseBody is a response body for UsersListGpgKeysForUser

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type UsersListGpgKeysForUserResponseBody []components.GpgKey

/*
UsersListGpgKeysForUserResponse is a response for UsersListGpgKeysForUser

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type UsersListGpgKeysForUserResponse struct {
	response
	request *UsersListGpgKeysForUserReq
	Data    UsersListGpgKeysForUserResponseBody
}

/*
UsersListPublicEmailsForAuthenticated performs requests for "users/list-public-emails-for-authenticated"

List public email addresses for the authenticated user.

  GET /user/public_emails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
func UsersListPublicEmailsForAuthenticated(ctx context.Context, req *UsersListPublicEmailsForAuthenticatedReq, opt ...RequestOption) (*UsersListPublicEmailsForAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersListPublicEmailsForAuthenticatedReq)
	}
	resp := &UsersListPublicEmailsForAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersListPublicEmailsForAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListPublicEmailsForAuthenticated performs requests for "users/list-public-emails-for-authenticated"

List public email addresses for the authenticated user.

  GET /user/public_emails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
func (c Client) UsersListPublicEmailsForAuthenticated(ctx context.Context, req *UsersListPublicEmailsForAuthenticatedReq, opt ...RequestOption) (*UsersListPublicEmailsForAuthenticatedResponse, error) {
	return UsersListPublicEmailsForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersListPublicEmailsForAuthenticatedReq is request data for Client.UsersListPublicEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
type UsersListPublicEmailsForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListPublicEmailsForAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersListPublicEmailsForAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/public_emails")
}

func (r *UsersListPublicEmailsForAuthenticatedReq) method() string {
	return "GET"
}

func (r *UsersListPublicEmailsForAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListPublicEmailsForAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListPublicEmailsForAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersListPublicEmailsForAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListPublicEmailsForAuthenticatedReq) validStatuses() []int {
	return []int{200, 304}
}

func (r *UsersListPublicEmailsForAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListPublicEmailsForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListPublicEmailsForAuthenticatedReq) Rel(link RelName, resp *UsersListPublicEmailsForAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListPublicEmailsForAuthenticatedResponseBody is a response body for UsersListPublicEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
type UsersListPublicEmailsForAuthenticatedResponseBody []components.Email

/*
UsersListPublicEmailsForAuthenticatedResponse is a response for UsersListPublicEmailsForAuthenticated

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-the-authenticated-user
*/
type UsersListPublicEmailsForAuthenticatedResponse struct {
	response
	request *UsersListPublicEmailsForAuthenticatedReq
	Data    UsersListPublicEmailsForAuthenticatedResponseBody
}

/*
UsersListPublicKeysForUser performs requests for "users/list-public-keys-for-user"

List public keys for a user.

  GET /users/{username}/keys

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
func UsersListPublicKeysForUser(ctx context.Context, req *UsersListPublicKeysForUserReq, opt ...RequestOption) (*UsersListPublicKeysForUserResponse, error) {
	if req == nil {
		req = new(UsersListPublicKeysForUserReq)
	}
	resp := &UsersListPublicKeysForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersListPublicKeysForUserResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListPublicKeysForUser performs requests for "users/list-public-keys-for-user"

List public keys for a user.

  GET /users/{username}/keys

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
func (c Client) UsersListPublicKeysForUser(ctx context.Context, req *UsersListPublicKeysForUserReq, opt ...RequestOption) (*UsersListPublicKeysForUserResponse, error) {
	return UsersListPublicKeysForUser(ctx, req, append(c, opt...)...)
}

/*
UsersListPublicKeysForUserReq is request data for Client.UsersListPublicKeysForUser

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type UsersListPublicKeysForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListPublicKeysForUserReq) url() string {
	return r._url
}

func (r *UsersListPublicKeysForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/keys", r.Username)
}

func (r *UsersListPublicKeysForUserReq) method() string {
	return "GET"
}

func (r *UsersListPublicKeysForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListPublicKeysForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListPublicKeysForUserReq) body() interface{} {
	return nil
}

func (r *UsersListPublicKeysForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListPublicKeysForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *UsersListPublicKeysForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListPublicKeysForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListPublicKeysForUserReq) Rel(link RelName, resp *UsersListPublicKeysForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListPublicKeysForUserResponseBody is a response body for UsersListPublicKeysForUser

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type UsersListPublicKeysForUserResponseBody []components.KeySimple

/*
UsersListPublicKeysForUserResponse is a response for UsersListPublicKeysForUser

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type UsersListPublicKeysForUserResponse struct {
	response
	request *UsersListPublicKeysForUserReq
	Data    UsersListPublicKeysForUserResponseBody
}

/*
UsersListPublicSshKeysForAuthenticated performs requests for "users/list-public-ssh-keys-for-authenticated"

List public SSH keys for the authenticated user.

  GET /user/keys

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
func UsersListPublicSshKeysForAuthenticated(ctx context.Context, req *UsersListPublicSshKeysForAuthenticatedReq, opt ...RequestOption) (*UsersListPublicSshKeysForAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersListPublicSshKeysForAuthenticatedReq)
	}
	resp := &UsersListPublicSshKeysForAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersListPublicSshKeysForAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersListPublicSshKeysForAuthenticated performs requests for "users/list-public-ssh-keys-for-authenticated"

List public SSH keys for the authenticated user.

  GET /user/keys

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
func (c Client) UsersListPublicSshKeysForAuthenticated(ctx context.Context, req *UsersListPublicSshKeysForAuthenticatedReq, opt ...RequestOption) (*UsersListPublicSshKeysForAuthenticatedResponse, error) {
	return UsersListPublicSshKeysForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersListPublicSshKeysForAuthenticatedReq is request data for Client.UsersListPublicSshKeysForAuthenticated

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
type UsersListPublicSshKeysForAuthenticatedReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *UsersListPublicSshKeysForAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersListPublicSshKeysForAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/keys")
}

func (r *UsersListPublicSshKeysForAuthenticatedReq) method() string {
	return "GET"
}

func (r *UsersListPublicSshKeysForAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *UsersListPublicSshKeysForAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersListPublicSshKeysForAuthenticatedReq) body() interface{} {
	return nil
}

func (r *UsersListPublicSshKeysForAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersListPublicSshKeysForAuthenticatedReq) validStatuses() []int {
	return []int{200, 304}
}

func (r *UsersListPublicSshKeysForAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersListPublicSshKeysForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersListPublicSshKeysForAuthenticatedReq) Rel(link RelName, resp *UsersListPublicSshKeysForAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersListPublicSshKeysForAuthenticatedResponseBody is a response body for UsersListPublicSshKeysForAuthenticated

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
type UsersListPublicSshKeysForAuthenticatedResponseBody []components.Key

/*
UsersListPublicSshKeysForAuthenticatedResponse is a response for UsersListPublicSshKeysForAuthenticated

https://developer.github.com/v3/users/keys/#list-public-ssh-keys-for-the-authenticated-user
*/
type UsersListPublicSshKeysForAuthenticatedResponse struct {
	response
	request *UsersListPublicSshKeysForAuthenticatedReq
	Data    UsersListPublicSshKeysForAuthenticatedResponseBody
}

/*
UsersSetPrimaryEmailVisibilityForAuthenticated performs requests for "users/set-primary-email-visibility-for-authenticated"

Set primary email visibility for the authenticated user.

  PATCH /user/email/visibility

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
func UsersSetPrimaryEmailVisibilityForAuthenticated(ctx context.Context, req *UsersSetPrimaryEmailVisibilityForAuthenticatedReq, opt ...RequestOption) (*UsersSetPrimaryEmailVisibilityForAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersSetPrimaryEmailVisibilityForAuthenticatedReq)
	}
	resp := &UsersSetPrimaryEmailVisibilityForAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersSetPrimaryEmailVisibilityForAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersSetPrimaryEmailVisibilityForAuthenticated performs requests for "users/set-primary-email-visibility-for-authenticated"

Set primary email visibility for the authenticated user.

  PATCH /user/email/visibility

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
func (c Client) UsersSetPrimaryEmailVisibilityForAuthenticated(ctx context.Context, req *UsersSetPrimaryEmailVisibilityForAuthenticatedReq, opt ...RequestOption) (*UsersSetPrimaryEmailVisibilityForAuthenticatedResponse, error) {
	return UsersSetPrimaryEmailVisibilityForAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersSetPrimaryEmailVisibilityForAuthenticatedReq is request data for Client.UsersSetPrimaryEmailVisibilityForAuthenticated

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
type UsersSetPrimaryEmailVisibilityForAuthenticatedReq struct {
	_url        string
	RequestBody UsersSetPrimaryEmailVisibilityForAuthenticatedReqBody
}

func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/email/visibility")
}

func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) method() string {
	return "PATCH"
}

func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) body() interface{} {
	return r.RequestBody
}

func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) validStatuses() []int {
	return []int{200, 304}
}

func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) Rel(link RelName, resp *UsersSetPrimaryEmailVisibilityForAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersSetPrimaryEmailVisibilityForAuthenticatedReqBody is a request body for users/set-primary-email-visibility-for-authenticated

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
type UsersSetPrimaryEmailVisibilityForAuthenticatedReqBody struct {

	// An email address associated with the GitHub user account to manage.
	Email *string `json:"email"`

	// Denotes whether an email is publically visible.
	Visibility *string `json:"visibility"`
}

/*
UsersSetPrimaryEmailVisibilityForAuthenticatedResponseBody is a response body for UsersSetPrimaryEmailVisibilityForAuthenticated

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
type UsersSetPrimaryEmailVisibilityForAuthenticatedResponseBody []components.Email

/*
UsersSetPrimaryEmailVisibilityForAuthenticatedResponse is a response for UsersSetPrimaryEmailVisibilityForAuthenticated

https://developer.github.com/v3/users/emails/#set-primary-email-visibility-for-the-authenticated-user
*/
type UsersSetPrimaryEmailVisibilityForAuthenticatedResponse struct {
	response
	request *UsersSetPrimaryEmailVisibilityForAuthenticatedReq
	Data    UsersSetPrimaryEmailVisibilityForAuthenticatedResponseBody
}

/*
UsersUnblock performs requests for "users/unblock"

Unblock a user.

  DELETE /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
func UsersUnblock(ctx context.Context, req *UsersUnblockReq, opt ...RequestOption) (*UsersUnblockResponse, error) {
	if req == nil {
		req = new(UsersUnblockReq)
	}
	resp := &UsersUnblockResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersUnblock performs requests for "users/unblock"

Unblock a user.

  DELETE /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
func (c Client) UsersUnblock(ctx context.Context, req *UsersUnblockReq, opt ...RequestOption) (*UsersUnblockResponse, error) {
	return UsersUnblock(ctx, req, append(c, opt...)...)
}

/*
UsersUnblockReq is request data for Client.UsersUnblock

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
type UsersUnblockReq struct {
	_url     string
	Username string
}

func (r *UsersUnblockReq) url() string {
	return r._url
}

func (r *UsersUnblockReq) urlPath() string {
	return fmt.Sprintf("/user/blocks/%v", r.Username)
}

func (r *UsersUnblockReq) method() string {
	return "DELETE"
}

func (r *UsersUnblockReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersUnblockReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersUnblockReq) body() interface{} {
	return nil
}

func (r *UsersUnblockReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersUnblockReq) validStatuses() []int {
	return []int{204, 304}
}

func (r *UsersUnblockReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersUnblockReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersUnblockReq) Rel(link RelName, resp *UsersUnblockResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersUnblockResponse is a response for UsersUnblock

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
type UsersUnblockResponse struct {
	response
	request *UsersUnblockReq
}

/*
UsersUnfollow performs requests for "users/unfollow"

Unfollow a user.

  DELETE /user/following/{username}

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
func UsersUnfollow(ctx context.Context, req *UsersUnfollowReq, opt ...RequestOption) (*UsersUnfollowResponse, error) {
	if req == nil {
		req = new(UsersUnfollowReq)
	}
	resp := &UsersUnfollowResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersUnfollow performs requests for "users/unfollow"

Unfollow a user.

  DELETE /user/following/{username}

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
func (c Client) UsersUnfollow(ctx context.Context, req *UsersUnfollowReq, opt ...RequestOption) (*UsersUnfollowResponse, error) {
	return UsersUnfollow(ctx, req, append(c, opt...)...)
}

/*
UsersUnfollowReq is request data for Client.UsersUnfollow

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
type UsersUnfollowReq struct {
	_url     string
	Username string
}

func (r *UsersUnfollowReq) url() string {
	return r._url
}

func (r *UsersUnfollowReq) urlPath() string {
	return fmt.Sprintf("/user/following/%v", r.Username)
}

func (r *UsersUnfollowReq) method() string {
	return "DELETE"
}

func (r *UsersUnfollowReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersUnfollowReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersUnfollowReq) body() interface{} {
	return nil
}

func (r *UsersUnfollowReq) dataStatuses() []int {
	return []int{}
}

func (r *UsersUnfollowReq) validStatuses() []int {
	return []int{204, 304}
}

func (r *UsersUnfollowReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *UsersUnfollowReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersUnfollowReq) Rel(link RelName, resp *UsersUnfollowResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersUnfollowResponse is a response for UsersUnfollow

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
type UsersUnfollowResponse struct {
	response
	request *UsersUnfollowReq
}

/*
UsersUpdateAuthenticated performs requests for "users/update-authenticated"

Update the authenticated user.

  PATCH /user

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
func UsersUpdateAuthenticated(ctx context.Context, req *UsersUpdateAuthenticatedReq, opt ...RequestOption) (*UsersUpdateAuthenticatedResponse, error) {
	if req == nil {
		req = new(UsersUpdateAuthenticatedReq)
	}
	resp := &UsersUpdateAuthenticatedResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = UsersUpdateAuthenticatedResponseBody{}
	err = r.decodeBody(&resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
UsersUpdateAuthenticated performs requests for "users/update-authenticated"

Update the authenticated user.

  PATCH /user

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
func (c Client) UsersUpdateAuthenticated(ctx context.Context, req *UsersUpdateAuthenticatedReq, opt ...RequestOption) (*UsersUpdateAuthenticatedResponse, error) {
	return UsersUpdateAuthenticated(ctx, req, append(c, opt...)...)
}

/*
UsersUpdateAuthenticatedReq is request data for Client.UsersUpdateAuthenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedReq struct {
	_url        string
	RequestBody UsersUpdateAuthenticatedReqBody
}

func (r *UsersUpdateAuthenticatedReq) url() string {
	return r._url
}

func (r *UsersUpdateAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user")
}

func (r *UsersUpdateAuthenticatedReq) method() string {
	return "PATCH"
}

func (r *UsersUpdateAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *UsersUpdateAuthenticatedReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{
		"accept":       String("application/json"),
		"content-type": String("application/json"),
	}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *UsersUpdateAuthenticatedReq) body() interface{} {
	return r.RequestBody
}

func (r *UsersUpdateAuthenticatedReq) dataStatuses() []int {
	return []int{200}
}

func (r *UsersUpdateAuthenticatedReq) validStatuses() []int {
	return []int{200, 304}
}

func (r *UsersUpdateAuthenticatedReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *UsersUpdateAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *UsersUpdateAuthenticatedReq) Rel(link RelName, resp *UsersUpdateAuthenticatedResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
UsersUpdateAuthenticatedReqBody is a request body for users/update-authenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedReqBody struct {

	// The new short biography of the user.
	Bio *string `json:"bio,omitempty"`

	// The new blog URL of the user.
	Blog *string `json:"blog,omitempty"`

	// The new company of the user.
	Company *string `json:"company,omitempty"`

	// The publicly visible email address of the user.
	Email *string `json:"email,omitempty"`

	// The new hiring availability of the user.
	Hireable *bool `json:"hireable,omitempty"`

	// The new location of the user.
	Location *string `json:"location,omitempty"`

	// The new name of the user.
	Name *string `json:"name,omitempty"`

	// The new Twitter username of the user.
	TwitterUsername *string `json:"twitter_username,omitempty"`
}

/*
UsersUpdateAuthenticatedResponseBody is a response body for UsersUpdateAuthenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedResponseBody components.PrivateUser

/*
UsersUpdateAuthenticatedResponse is a response for UsersUpdateAuthenticated

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedResponse struct {
	response
	request *UsersUpdateAuthenticatedReq
	Data    UsersUpdateAuthenticatedResponseBody
}
