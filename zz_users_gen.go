// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
)

/*
UsersAddEmailsReq builds requests for "users/add-emails"

Add email address(es).

  POST /user/emails

https://developer.github.com/v3/users/emails/#add-email-addresses
*/
type UsersAddEmailsReq struct {
	RequestBody UsersAddEmailsReqBody
}

func (r UsersAddEmailsReq) urlPath() string {
	return fmt.Sprintf("/user/emails")
}

func (r UsersAddEmailsReq) method() string {
	return "POST"
}

func (r UsersAddEmailsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersAddEmailsReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersAddEmailsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), r.RequestBody, opt)
}

/*
UsersAddEmailsReqBody is a request body for users/add-emails

API documentation: https://developer.github.com/v3/users/emails/#add-email-addresses
*/
type UsersAddEmailsReqBody struct {

	/*
	   Adds one or more email addresses to your GitHub account. Must contain at least
	   one email address. **Note:** Alternatively, you can pass a single email address
	   or an `array` of emails addresses directly, but we recommend that you pass an
	   object using the `emails` key.
	*/
	Emails []string `json:"emails"`
}

/*
UsersAddEmailsResponseBody201 is a response body for users/add-emails

API documentation: https://developer.github.com/v3/users/emails/#add-email-addresses
*/
type UsersAddEmailsResponseBody201 []struct {
	Email      string `json:"email,omitempty"`
	Primary    bool   `json:"primary,omitempty"`
	Verified   bool   `json:"verified,omitempty"`
	Visibility string `json:"visibility,omitempty"`
}

/*
UsersBlockReq builds requests for "users/block"

Block a user.

  PUT /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#block-a-user
*/
type UsersBlockReq struct {
	Username string
}

func (r UsersBlockReq) urlPath() string {
	return fmt.Sprintf("/user/blocks/%v", r.Username)
}

func (r UsersBlockReq) method() string {
	return "PUT"
}

func (r UsersBlockReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersBlockReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersBlockReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersCheckBlockedReq builds requests for "users/check-blocked"

Check whether you've blocked a user.

  GET /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#check-whether-youve-blocked-a-user
*/
type UsersCheckBlockedReq struct {
	Username string
}

func (r UsersCheckBlockedReq) urlPath() string {
	return fmt.Sprintf("/user/blocks/%v", r.Username)
}

func (r UsersCheckBlockedReq) method() string {
	return "GET"
}

func (r UsersCheckBlockedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersCheckBlockedReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersCheckBlockedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersCheckFollowingReq builds requests for "users/check-following"

Check if you are following a user.

  GET /user/following/{username}

https://developer.github.com/v3/users/followers/#check-if-you-are-following-a-user
*/
type UsersCheckFollowingReq struct {
	Username string
}

func (r UsersCheckFollowingReq) urlPath() string {
	return fmt.Sprintf("/user/following/%v", r.Username)
}

func (r UsersCheckFollowingReq) method() string {
	return "GET"
}

func (r UsersCheckFollowingReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersCheckFollowingReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersCheckFollowingReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersCheckFollowingForUserReq builds requests for "users/check-following-for-user"

Check if one user follows another.

  GET /users/{username}/following/{target_user}

https://developer.github.com/v3/users/followers/#check-if-one-user-follows-another
*/
type UsersCheckFollowingForUserReq struct {
	Username   string
	TargetUser string
}

func (r UsersCheckFollowingForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/following/%v", r.Username, r.TargetUser)
}

func (r UsersCheckFollowingForUserReq) method() string {
	return "GET"
}

func (r UsersCheckFollowingForUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersCheckFollowingForUserReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersCheckFollowingForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersCreateGpgKeyReq builds requests for "users/create-gpg-key"

Create a GPG key.

  POST /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key
*/
type UsersCreateGpgKeyReq struct {
	RequestBody UsersCreateGpgKeyReqBody
}

func (r UsersCreateGpgKeyReq) urlPath() string {
	return fmt.Sprintf("/user/gpg_keys")
}

func (r UsersCreateGpgKeyReq) method() string {
	return "POST"
}

func (r UsersCreateGpgKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersCreateGpgKeyReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersCreateGpgKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), r.RequestBody, opt)
}

/*
UsersCreateGpgKeyReqBody is a request body for users/create-gpg-key

API documentation: https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key
*/
type UsersCreateGpgKeyReqBody struct {

	/*
	   Your GPG key, generated in ASCII-armored format. See "[Generating a new GPG
	   key](https://help.github.com/articles/generating-a-new-gpg-key/)" for help
	   creating a GPG key.
	*/
	ArmoredPublicKey *string `json:"armored_public_key,omitempty"`
}

/*
UsersCreateGpgKeyResponseBody201 is a response body for users/create-gpg-key

API documentation: https://developer.github.com/v3/users/gpg_keys/#create-a-gpg-key
*/
type UsersCreateGpgKeyResponseBody201 struct {
	CanCertify        bool   `json:"can_certify,omitempty"`
	CanEncryptComms   bool   `json:"can_encrypt_comms,omitempty"`
	CanEncryptStorage bool   `json:"can_encrypt_storage,omitempty"`
	CanSign           bool   `json:"can_sign,omitempty"`
	CreatedAt         string `json:"created_at,omitempty"`
	Emails            []struct {
		Email    string `json:"email,omitempty"`
		Verified bool   `json:"verified,omitempty"`
	} `json:"emails,omitempty"`
	ExpiresAt    string `json:"expires_at,omitempty"`
	Id           int64  `json:"id,omitempty"`
	KeyId        string `json:"key_id,omitempty"`
	PrimaryKeyId string `json:"primary_key_id,omitempty"`
	PublicKey    string `json:"public_key,omitempty"`
	Subkeys      []struct {
		CanCertify        bool          `json:"can_certify,omitempty"`
		CanEncryptComms   bool          `json:"can_encrypt_comms,omitempty"`
		CanEncryptStorage bool          `json:"can_encrypt_storage,omitempty"`
		CanSign           bool          `json:"can_sign,omitempty"`
		CreatedAt         string        `json:"created_at,omitempty"`
		Emails            []interface{} `json:"emails,omitempty"`
		ExpiresAt         string        `json:"expires_at,omitempty"`
		Id                int64         `json:"id,omitempty"`
		KeyId             string        `json:"key_id,omitempty"`
		PrimaryKeyId      int64         `json:"primary_key_id,omitempty"`
		PublicKey         string        `json:"public_key,omitempty"`
		Subkeys           []interface{} `json:"subkeys,omitempty"`
	} `json:"subkeys,omitempty"`
}

/*
UsersCreatePublicKeyReq builds requests for "users/create-public-key"

Create a public key.

  POST /user/keys

https://developer.github.com/v3/users/keys/#create-a-public-key
*/
type UsersCreatePublicKeyReq struct {
	RequestBody UsersCreatePublicKeyReqBody
}

func (r UsersCreatePublicKeyReq) urlPath() string {
	return fmt.Sprintf("/user/keys")
}

func (r UsersCreatePublicKeyReq) method() string {
	return "POST"
}

func (r UsersCreatePublicKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersCreatePublicKeyReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersCreatePublicKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), r.RequestBody, opt)
}

/*
UsersCreatePublicKeyReqBody is a request body for users/create-public-key

API documentation: https://developer.github.com/v3/users/keys/#create-a-public-key
*/
type UsersCreatePublicKeyReqBody struct {

	/*
	   The public SSH key to add to your GitHub account. See "[Generating a new SSH
	   key](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/)"
	   for guidance on how to create a public SSH key.
	*/
	Key *string `json:"key,omitempty"`

	/*
	   A descriptive name for the new key. Use a name that will help you recognize this
	   key in your GitHub account. For example, if you're using a personal Mac, you
	   might call this key "Personal MacBook Air".
	*/
	Title *string `json:"title,omitempty"`
}

/*
UsersCreatePublicKeyResponseBody201 is a response body for users/create-public-key

API documentation: https://developer.github.com/v3/users/keys/#create-a-public-key
*/
type UsersCreatePublicKeyResponseBody201 struct {
	Key   string `json:"key,omitempty"`
	KeyId string `json:"key_id,omitempty"`
}

/*
UsersDeleteEmailsReq builds requests for "users/delete-emails"

Delete email address(es).

  DELETE /user/emails

https://developer.github.com/v3/users/emails/#delete-email-addresses
*/
type UsersDeleteEmailsReq struct {
	RequestBody UsersDeleteEmailsReqBody
}

func (r UsersDeleteEmailsReq) urlPath() string {
	return fmt.Sprintf("/user/emails")
}

func (r UsersDeleteEmailsReq) method() string {
	return "DELETE"
}

func (r UsersDeleteEmailsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersDeleteEmailsReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersDeleteEmailsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), r.RequestBody, opt)
}

/*
UsersDeleteEmailsReqBody is a request body for users/delete-emails

API documentation: https://developer.github.com/v3/users/emails/#delete-email-addresses
*/
type UsersDeleteEmailsReqBody struct {

	/*
	   Deletes one or more email addresses from your GitHub account. Must contain at
	   least one email address. **Note:** Alternatively, you can pass a single email
	   address or an `array` of emails addresses directly, but we recommend that you
	   pass an object using the `emails` key.
	*/
	Emails []string `json:"emails"`
}

/*
UsersDeleteGpgKeyReq builds requests for "users/delete-gpg-key"

Delete a GPG key.

  DELETE /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#delete-a-gpg-key
*/
type UsersDeleteGpgKeyReq struct {
	GpgKeyId int64
}

func (r UsersDeleteGpgKeyReq) urlPath() string {
	return fmt.Sprintf("/user/gpg_keys/%v", r.GpgKeyId)
}

func (r UsersDeleteGpgKeyReq) method() string {
	return "DELETE"
}

func (r UsersDeleteGpgKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersDeleteGpgKeyReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersDeleteGpgKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersDeletePublicKeyReq builds requests for "users/delete-public-key"

Delete a public key.

  DELETE /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#delete-a-public-key
*/
type UsersDeletePublicKeyReq struct {
	KeyId int64
}

func (r UsersDeletePublicKeyReq) urlPath() string {
	return fmt.Sprintf("/user/keys/%v", r.KeyId)
}

func (r UsersDeletePublicKeyReq) method() string {
	return "DELETE"
}

func (r UsersDeletePublicKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersDeletePublicKeyReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersDeletePublicKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersFollowReq builds requests for "users/follow"

Follow a user.

  PUT /user/following/{username}

https://developer.github.com/v3/users/followers/#follow-a-user
*/
type UsersFollowReq struct {
	Username string
}

func (r UsersFollowReq) urlPath() string {
	return fmt.Sprintf("/user/following/%v", r.Username)
}

func (r UsersFollowReq) method() string {
	return "PUT"
}

func (r UsersFollowReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersFollowReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersFollowReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersGetAuthenticatedReq builds requests for "users/get-authenticated"

Get the authenticated user.

  GET /user

https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type UsersGetAuthenticatedReq struct{}

func (r UsersGetAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user")
}

func (r UsersGetAuthenticatedReq) method() string {
	return "GET"
}

func (r UsersGetAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersGetAuthenticatedReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersGetAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersGetAuthenticatedResponseBody200 is a response body for users/get-authenticated

API documentation: https://developer.github.com/v3/users/#get-the-authenticated-user
*/
type UsersGetAuthenticatedResponseBody200 struct {
	AvatarUrl         string      `json:"avatar_url,omitempty"`
	Bio               string      `json:"bio,omitempty"`
	Blog              string      `json:"blog,omitempty"`
	Collaborators     int64       `json:"collaborators,omitempty"`
	Company           string      `json:"company,omitempty"`
	CreatedAt         string      `json:"created_at,omitempty"`
	DiskUsage         json.Number `json:"disk_usage,omitempty"`
	Email             string      `json:"email,omitempty"`
	EventsUrl         string      `json:"events_url,omitempty"`
	Followers         int64       `json:"followers,omitempty"`
	FollowersUrl      string      `json:"followers_url,omitempty"`
	Following         int64       `json:"following,omitempty"`
	FollowingUrl      string      `json:"following_url,omitempty"`
	GistsUrl          string      `json:"gists_url,omitempty"`
	GravatarId        string      `json:"gravatar_id,omitempty"`
	Hireable          bool        `json:"hireable,omitempty"`
	HtmlUrl           string      `json:"html_url,omitempty"`
	Id                int64       `json:"id,omitempty"`
	Location          string      `json:"location,omitempty"`
	Login             string      `json:"login,omitempty"`
	Name              string      `json:"name,omitempty"`
	NodeId            string      `json:"node_id,omitempty"`
	OrganizationsUrl  string      `json:"organizations_url,omitempty"`
	OwnedPrivateRepos int64       `json:"owned_private_repos,omitempty"`
	Plan              struct {
		Collaborators int64       `json:"collaborators,omitempty"`
		Name          string      `json:"name,omitempty"`
		PrivateRepos  int64       `json:"private_repos,omitempty"`
		Space         json.Number `json:"space,omitempty"`
	} `json:"plan,omitempty"`
	PrivateGists            int64  `json:"private_gists,omitempty"`
	PublicGists             int64  `json:"public_gists,omitempty"`
	PublicRepos             int64  `json:"public_repos,omitempty"`
	ReceivedEventsUrl       string `json:"received_events_url,omitempty"`
	ReposUrl                string `json:"repos_url,omitempty"`
	SiteAdmin               bool   `json:"site_admin,omitempty"`
	StarredUrl              string `json:"starred_url,omitempty"`
	SubscriptionsUrl        string `json:"subscriptions_url,omitempty"`
	TotalPrivateRepos       int64  `json:"total_private_repos,omitempty"`
	TwoFactorAuthentication bool   `json:"two_factor_authentication,omitempty"`
	Type                    string `json:"type,omitempty"`
	UpdatedAt               string `json:"updated_at,omitempty"`
	Url                     string `json:"url,omitempty"`
}

/*
UsersGetByUsernameReq builds requests for "users/get-by-username"

Get a single user.

  GET /users/{username}

https://developer.github.com/v3/users/#get-a-single-user
*/
type UsersGetByUsernameReq struct {
	Username string
}

func (r UsersGetByUsernameReq) urlPath() string {
	return fmt.Sprintf("/users/%v", r.Username)
}

func (r UsersGetByUsernameReq) method() string {
	return "GET"
}

func (r UsersGetByUsernameReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersGetByUsernameReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersGetByUsernameReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersGetByUsernameResponseBody200 is a response body for users/get-by-username

API documentation: https://developer.github.com/v3/users/#get-a-single-user
*/
type UsersGetByUsernameResponseBody200 struct {
	AvatarUrl         string `json:"avatar_url,omitempty"`
	Bio               string `json:"bio,omitempty"`
	Blog              string `json:"blog,omitempty"`
	Company           string `json:"company,omitempty"`
	CreatedAt         string `json:"created_at,omitempty"`
	Email             string `json:"email,omitempty"`
	EventsUrl         string `json:"events_url,omitempty"`
	Followers         int64  `json:"followers,omitempty"`
	FollowersUrl      string `json:"followers_url,omitempty"`
	Following         int64  `json:"following,omitempty"`
	FollowingUrl      string `json:"following_url,omitempty"`
	GistsUrl          string `json:"gists_url,omitempty"`
	GravatarId        string `json:"gravatar_id,omitempty"`
	Hireable          bool   `json:"hireable,omitempty"`
	HtmlUrl           string `json:"html_url,omitempty"`
	Id                int64  `json:"id,omitempty"`
	Location          string `json:"location,omitempty"`
	Login             string `json:"login,omitempty"`
	Name              string `json:"name,omitempty"`
	NodeId            string `json:"node_id,omitempty"`
	OrganizationsUrl  string `json:"organizations_url,omitempty"`
	PublicGists       int64  `json:"public_gists,omitempty"`
	PublicRepos       int64  `json:"public_repos,omitempty"`
	ReceivedEventsUrl string `json:"received_events_url,omitempty"`
	ReposUrl          string `json:"repos_url,omitempty"`
	SiteAdmin         bool   `json:"site_admin,omitempty"`
	StarredUrl        string `json:"starred_url,omitempty"`
	SubscriptionsUrl  string `json:"subscriptions_url,omitempty"`
	Type              string `json:"type,omitempty"`
	UpdatedAt         string `json:"updated_at,omitempty"`
	Url               string `json:"url,omitempty"`
}

/*
UsersGetContextForUserReq builds requests for "users/get-context-for-user"

Get contextual information about a user.

  GET /users/{username}/hovercard

https://developer.github.com/v3/users/#get-contextual-information-about-a-user
*/
type UsersGetContextForUserReq struct {
	Username string

	/*
	Identifies which additional information you'd like to receive about the person's
	hovercard. Can be `organization`, `repository`, `issue`, `pull_request`.
	**Required** when using `subject_id`.
	*/
	SubjectType *string

	/*
	Uses the ID for the `subject_type` you specified. **Required** when using
	`subject_type`.
	*/
	SubjectId *string
}

func (r UsersGetContextForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/hovercard", r.Username)
}

func (r UsersGetContextForUserReq) method() string {
	return "GET"
}

func (r UsersGetContextForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.SubjectType != nil {
		query.Set("subject_type", *r.SubjectType)
	}
	if r.SubjectId != nil {
		query.Set("subject_id", *r.SubjectId)
	}
	return query
}

func (r UsersGetContextForUserReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersGetContextForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersGetContextForUserResponseBody200 is a response body for users/get-context-for-user

API documentation: https://developer.github.com/v3/users/#get-contextual-information-about-a-user
*/
type UsersGetContextForUserResponseBody200 struct {
	Contexts []struct {
		Message string `json:"message,omitempty"`
		Octicon string `json:"octicon,omitempty"`
	} `json:"contexts,omitempty"`
}

/*
UsersGetGpgKeyReq builds requests for "users/get-gpg-key"

Get a single GPG key.

  GET /user/gpg_keys/{gpg_key_id}

https://developer.github.com/v3/users/gpg_keys/#get-a-single-gpg-key
*/
type UsersGetGpgKeyReq struct {
	GpgKeyId int64
}

func (r UsersGetGpgKeyReq) urlPath() string {
	return fmt.Sprintf("/user/gpg_keys/%v", r.GpgKeyId)
}

func (r UsersGetGpgKeyReq) method() string {
	return "GET"
}

func (r UsersGetGpgKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersGetGpgKeyReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersGetGpgKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersGetGpgKeyResponseBody200 is a response body for users/get-gpg-key

API documentation: https://developer.github.com/v3/users/gpg_keys/#get-a-single-gpg-key
*/
type UsersGetGpgKeyResponseBody200 struct {
	CanCertify        bool   `json:"can_certify,omitempty"`
	CanEncryptComms   bool   `json:"can_encrypt_comms,omitempty"`
	CanEncryptStorage bool   `json:"can_encrypt_storage,omitempty"`
	CanSign           bool   `json:"can_sign,omitempty"`
	CreatedAt         string `json:"created_at,omitempty"`
	Emails            []struct {
		Email    string `json:"email,omitempty"`
		Verified bool   `json:"verified,omitempty"`
	} `json:"emails,omitempty"`
	ExpiresAt    string `json:"expires_at,omitempty"`
	Id           int64  `json:"id,omitempty"`
	KeyId        string `json:"key_id,omitempty"`
	PrimaryKeyId string `json:"primary_key_id,omitempty"`
	PublicKey    string `json:"public_key,omitempty"`
	Subkeys      []struct {
		CanCertify        bool          `json:"can_certify,omitempty"`
		CanEncryptComms   bool          `json:"can_encrypt_comms,omitempty"`
		CanEncryptStorage bool          `json:"can_encrypt_storage,omitempty"`
		CanSign           bool          `json:"can_sign,omitempty"`
		CreatedAt         string        `json:"created_at,omitempty"`
		Emails            []interface{} `json:"emails,omitempty"`
		ExpiresAt         string        `json:"expires_at,omitempty"`
		Id                int64         `json:"id,omitempty"`
		KeyId             string        `json:"key_id,omitempty"`
		PrimaryKeyId      int64         `json:"primary_key_id,omitempty"`
		PublicKey         string        `json:"public_key,omitempty"`
		Subkeys           []interface{} `json:"subkeys,omitempty"`
	} `json:"subkeys,omitempty"`
}

/*
UsersGetPublicKeyReq builds requests for "users/get-public-key"

Get a single public key.

  GET /user/keys/{key_id}

https://developer.github.com/v3/users/keys/#get-a-single-public-key
*/
type UsersGetPublicKeyReq struct {
	KeyId int64
}

func (r UsersGetPublicKeyReq) urlPath() string {
	return fmt.Sprintf("/user/keys/%v", r.KeyId)
}

func (r UsersGetPublicKeyReq) method() string {
	return "GET"
}

func (r UsersGetPublicKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersGetPublicKeyReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersGetPublicKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersGetPublicKeyResponseBody200 is a response body for users/get-public-key

API documentation: https://developer.github.com/v3/users/keys/#get-a-single-public-key
*/
type UsersGetPublicKeyResponseBody200 struct {
	Key   string `json:"key,omitempty"`
	KeyId string `json:"key_id,omitempty"`
}

/*
UsersListReq builds requests for "users/list"

Get all users.

  GET /users

https://developer.github.com/v3/users/#get-all-users
*/
type UsersListReq struct {

	// The integer ID of the last User that you've seen.
	Since *string
}

func (r UsersListReq) urlPath() string {
	return fmt.Sprintf("/users")
}

func (r UsersListReq) method() string {
	return "GET"
}

func (r UsersListReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	return query
}

func (r UsersListReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersListReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersListResponseBody200 is a response body for users/list

API documentation: https://developer.github.com/v3/users/#get-all-users
*/
type UsersListResponseBody200 []struct {
	AvatarUrl         string `json:"avatar_url,omitempty"`
	EventsUrl         string `json:"events_url,omitempty"`
	FollowersUrl      string `json:"followers_url,omitempty"`
	FollowingUrl      string `json:"following_url,omitempty"`
	GistsUrl          string `json:"gists_url,omitempty"`
	GravatarId        string `json:"gravatar_id,omitempty"`
	HtmlUrl           string `json:"html_url,omitempty"`
	Id                int64  `json:"id,omitempty"`
	Login             string `json:"login,omitempty"`
	NodeId            string `json:"node_id,omitempty"`
	OrganizationsUrl  string `json:"organizations_url,omitempty"`
	ReceivedEventsUrl string `json:"received_events_url,omitempty"`
	ReposUrl          string `json:"repos_url,omitempty"`
	SiteAdmin         bool   `json:"site_admin,omitempty"`
	StarredUrl        string `json:"starred_url,omitempty"`
	SubscriptionsUrl  string `json:"subscriptions_url,omitempty"`
	Type              string `json:"type,omitempty"`
	Url               string `json:"url,omitempty"`
}

/*
UsersListBlockedReq builds requests for "users/list-blocked"

List blocked users.

  GET /user/blocks

https://developer.github.com/v3/users/blocking/#list-blocked-users
*/
type UsersListBlockedReq struct{}

func (r UsersListBlockedReq) urlPath() string {
	return fmt.Sprintf("/user/blocks")
}

func (r UsersListBlockedReq) method() string {
	return "GET"
}

func (r UsersListBlockedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersListBlockedReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersListBlockedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersListBlockedResponseBody200 is a response body for users/list-blocked

API documentation: https://developer.github.com/v3/users/blocking/#list-blocked-users
*/
type UsersListBlockedResponseBody200 []struct {
	AvatarUrl         string `json:"avatar_url,omitempty"`
	EventsUrl         string `json:"events_url,omitempty"`
	FollowersUrl      string `json:"followers_url,omitempty"`
	FollowingUrl      string `json:"following_url,omitempty"`
	GistsUrl          string `json:"gists_url,omitempty"`
	GravatarId        string `json:"gravatar_id,omitempty"`
	HtmlUrl           string `json:"html_url,omitempty"`
	Id                int64  `json:"id,omitempty"`
	Login             string `json:"login,omitempty"`
	NodeId            string `json:"node_id,omitempty"`
	OrganizationsUrl  string `json:"organizations_url,omitempty"`
	ReceivedEventsUrl string `json:"received_events_url,omitempty"`
	ReposUrl          string `json:"repos_url,omitempty"`
	SiteAdmin         bool   `json:"site_admin,omitempty"`
	StarredUrl        string `json:"starred_url,omitempty"`
	SubscriptionsUrl  string `json:"subscriptions_url,omitempty"`
	Type              string `json:"type,omitempty"`
	Url               string `json:"url,omitempty"`
}

/*
UsersListEmailsReq builds requests for "users/list-emails"

List email addresses for a user.

  GET /user/emails

https://developer.github.com/v3/users/emails/#list-email-addresses-for-a-user
*/
type UsersListEmailsReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r UsersListEmailsReq) urlPath() string {
	return fmt.Sprintf("/user/emails")
}

func (r UsersListEmailsReq) method() string {
	return "GET"
}

func (r UsersListEmailsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r UsersListEmailsReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersListEmailsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersListEmailsResponseBody200 is a response body for users/list-emails

API documentation: https://developer.github.com/v3/users/emails/#list-email-addresses-for-a-user
*/
type UsersListEmailsResponseBody200 []struct {
	Email      string `json:"email,omitempty"`
	Primary    bool   `json:"primary,omitempty"`
	Verified   bool   `json:"verified,omitempty"`
	Visibility string `json:"visibility,omitempty"`
}

/*
UsersListFollowedByAuthenticatedReq builds requests for "users/list-followed-by-authenticated"

List users followed by the authenticated user.

  GET /user/following

https://developer.github.com/v3/users/followers/#list-users-followed-by-the-authenticated-user
*/
type UsersListFollowedByAuthenticatedReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r UsersListFollowedByAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user/following")
}

func (r UsersListFollowedByAuthenticatedReq) method() string {
	return "GET"
}

func (r UsersListFollowedByAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r UsersListFollowedByAuthenticatedReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersListFollowedByAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersListFollowedByAuthenticatedResponseBody200 is a response body for users/list-followed-by-authenticated

API documentation: https://developer.github.com/v3/users/followers/#list-users-followed-by-the-authenticated-user
*/
type UsersListFollowedByAuthenticatedResponseBody200 []struct {
	AvatarUrl         string `json:"avatar_url,omitempty"`
	EventsUrl         string `json:"events_url,omitempty"`
	FollowersUrl      string `json:"followers_url,omitempty"`
	FollowingUrl      string `json:"following_url,omitempty"`
	GistsUrl          string `json:"gists_url,omitempty"`
	GravatarId        string `json:"gravatar_id,omitempty"`
	HtmlUrl           string `json:"html_url,omitempty"`
	Id                int64  `json:"id,omitempty"`
	Login             string `json:"login,omitempty"`
	NodeId            string `json:"node_id,omitempty"`
	OrganizationsUrl  string `json:"organizations_url,omitempty"`
	ReceivedEventsUrl string `json:"received_events_url,omitempty"`
	ReposUrl          string `json:"repos_url,omitempty"`
	SiteAdmin         bool   `json:"site_admin,omitempty"`
	StarredUrl        string `json:"starred_url,omitempty"`
	SubscriptionsUrl  string `json:"subscriptions_url,omitempty"`
	Type              string `json:"type,omitempty"`
	Url               string `json:"url,omitempty"`
}

/*
UsersListFollowersForAuthenticatedUserReq builds requests for "users/list-followers-for-authenticated-user"

List followers of the authenticated user.

  GET /user/followers

https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type UsersListFollowersForAuthenticatedUserReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r UsersListFollowersForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/followers")
}

func (r UsersListFollowersForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r UsersListFollowersForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r UsersListFollowersForAuthenticatedUserReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersListFollowersForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersListFollowersForAuthenticatedUserResponseBody200 is a response body for users/list-followers-for-authenticated-user

API documentation: https://developer.github.com/v3/users/followers/#list-followers-of-the-authenticated-user
*/
type UsersListFollowersForAuthenticatedUserResponseBody200 []struct {
	AvatarUrl         string `json:"avatar_url,omitempty"`
	EventsUrl         string `json:"events_url,omitempty"`
	FollowersUrl      string `json:"followers_url,omitempty"`
	FollowingUrl      string `json:"following_url,omitempty"`
	GistsUrl          string `json:"gists_url,omitempty"`
	GravatarId        string `json:"gravatar_id,omitempty"`
	HtmlUrl           string `json:"html_url,omitempty"`
	Id                int64  `json:"id,omitempty"`
	Login             string `json:"login,omitempty"`
	NodeId            string `json:"node_id,omitempty"`
	OrganizationsUrl  string `json:"organizations_url,omitempty"`
	ReceivedEventsUrl string `json:"received_events_url,omitempty"`
	ReposUrl          string `json:"repos_url,omitempty"`
	SiteAdmin         bool   `json:"site_admin,omitempty"`
	StarredUrl        string `json:"starred_url,omitempty"`
	SubscriptionsUrl  string `json:"subscriptions_url,omitempty"`
	Type              string `json:"type,omitempty"`
	Url               string `json:"url,omitempty"`
}

/*
UsersListFollowersForUserReq builds requests for "users/list-followers-for-user"

List followers of a user.

  GET /users/{username}/followers

https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type UsersListFollowersForUserReq struct {
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r UsersListFollowersForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/followers", r.Username)
}

func (r UsersListFollowersForUserReq) method() string {
	return "GET"
}

func (r UsersListFollowersForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r UsersListFollowersForUserReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersListFollowersForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersListFollowersForUserResponseBody200 is a response body for users/list-followers-for-user

API documentation: https://developer.github.com/v3/users/followers/#list-followers-of-a-user
*/
type UsersListFollowersForUserResponseBody200 []struct {
	AvatarUrl         string `json:"avatar_url,omitempty"`
	EventsUrl         string `json:"events_url,omitempty"`
	FollowersUrl      string `json:"followers_url,omitempty"`
	FollowingUrl      string `json:"following_url,omitempty"`
	GistsUrl          string `json:"gists_url,omitempty"`
	GravatarId        string `json:"gravatar_id,omitempty"`
	HtmlUrl           string `json:"html_url,omitempty"`
	Id                int64  `json:"id,omitempty"`
	Login             string `json:"login,omitempty"`
	NodeId            string `json:"node_id,omitempty"`
	OrganizationsUrl  string `json:"organizations_url,omitempty"`
	ReceivedEventsUrl string `json:"received_events_url,omitempty"`
	ReposUrl          string `json:"repos_url,omitempty"`
	SiteAdmin         bool   `json:"site_admin,omitempty"`
	StarredUrl        string `json:"starred_url,omitempty"`
	SubscriptionsUrl  string `json:"subscriptions_url,omitempty"`
	Type              string `json:"type,omitempty"`
	Url               string `json:"url,omitempty"`
}

/*
UsersListFollowingForUserReq builds requests for "users/list-following-for-user"

List users followed by another user.

  GET /users/{username}/following

https://developer.github.com/v3/users/followers/#list-users-followed-by-another-user
*/
type UsersListFollowingForUserReq struct {
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r UsersListFollowingForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/following", r.Username)
}

func (r UsersListFollowingForUserReq) method() string {
	return "GET"
}

func (r UsersListFollowingForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r UsersListFollowingForUserReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersListFollowingForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersListFollowingForUserResponseBody200 is a response body for users/list-following-for-user

API documentation: https://developer.github.com/v3/users/followers/#list-users-followed-by-another-user
*/
type UsersListFollowingForUserResponseBody200 []struct {
	AvatarUrl         string `json:"avatar_url,omitempty"`
	EventsUrl         string `json:"events_url,omitempty"`
	FollowersUrl      string `json:"followers_url,omitempty"`
	FollowingUrl      string `json:"following_url,omitempty"`
	GistsUrl          string `json:"gists_url,omitempty"`
	GravatarId        string `json:"gravatar_id,omitempty"`
	HtmlUrl           string `json:"html_url,omitempty"`
	Id                int64  `json:"id,omitempty"`
	Login             string `json:"login,omitempty"`
	NodeId            string `json:"node_id,omitempty"`
	OrganizationsUrl  string `json:"organizations_url,omitempty"`
	ReceivedEventsUrl string `json:"received_events_url,omitempty"`
	ReposUrl          string `json:"repos_url,omitempty"`
	SiteAdmin         bool   `json:"site_admin,omitempty"`
	StarredUrl        string `json:"starred_url,omitempty"`
	SubscriptionsUrl  string `json:"subscriptions_url,omitempty"`
	Type              string `json:"type,omitempty"`
	Url               string `json:"url,omitempty"`
}

/*
UsersListGpgKeysReq builds requests for "users/list-gpg-keys"

List your GPG keys.

  GET /user/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-your-gpg-keys
*/
type UsersListGpgKeysReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r UsersListGpgKeysReq) urlPath() string {
	return fmt.Sprintf("/user/gpg_keys")
}

func (r UsersListGpgKeysReq) method() string {
	return "GET"
}

func (r UsersListGpgKeysReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r UsersListGpgKeysReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersListGpgKeysReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersListGpgKeysResponseBody200 is a response body for users/list-gpg-keys

API documentation: https://developer.github.com/v3/users/gpg_keys/#list-your-gpg-keys
*/
type UsersListGpgKeysResponseBody200 []struct {
	CanCertify        bool   `json:"can_certify,omitempty"`
	CanEncryptComms   bool   `json:"can_encrypt_comms,omitempty"`
	CanEncryptStorage bool   `json:"can_encrypt_storage,omitempty"`
	CanSign           bool   `json:"can_sign,omitempty"`
	CreatedAt         string `json:"created_at,omitempty"`
	Emails            []struct {
		Email    string `json:"email,omitempty"`
		Verified bool   `json:"verified,omitempty"`
	} `json:"emails,omitempty"`
	ExpiresAt    string `json:"expires_at,omitempty"`
	Id           int64  `json:"id,omitempty"`
	KeyId        string `json:"key_id,omitempty"`
	PrimaryKeyId string `json:"primary_key_id,omitempty"`
	PublicKey    string `json:"public_key,omitempty"`
	Subkeys      []struct {
		CanCertify        bool          `json:"can_certify,omitempty"`
		CanEncryptComms   bool          `json:"can_encrypt_comms,omitempty"`
		CanEncryptStorage bool          `json:"can_encrypt_storage,omitempty"`
		CanSign           bool          `json:"can_sign,omitempty"`
		CreatedAt         string        `json:"created_at,omitempty"`
		Emails            []interface{} `json:"emails,omitempty"`
		ExpiresAt         string        `json:"expires_at,omitempty"`
		Id                int64         `json:"id,omitempty"`
		KeyId             string        `json:"key_id,omitempty"`
		PrimaryKeyId      int64         `json:"primary_key_id,omitempty"`
		PublicKey         string        `json:"public_key,omitempty"`
		Subkeys           []interface{} `json:"subkeys,omitempty"`
	} `json:"subkeys,omitempty"`
}

/*
UsersListGpgKeysForUserReq builds requests for "users/list-gpg-keys-for-user"

List GPG keys for a user.

  GET /users/{username}/gpg_keys

https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type UsersListGpgKeysForUserReq struct {
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r UsersListGpgKeysForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/gpg_keys", r.Username)
}

func (r UsersListGpgKeysForUserReq) method() string {
	return "GET"
}

func (r UsersListGpgKeysForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r UsersListGpgKeysForUserReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersListGpgKeysForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersListGpgKeysForUserResponseBody200 is a response body for users/list-gpg-keys-for-user

API documentation: https://developer.github.com/v3/users/gpg_keys/#list-gpg-keys-for-a-user
*/
type UsersListGpgKeysForUserResponseBody200 []struct {
	CanCertify        bool   `json:"can_certify,omitempty"`
	CanEncryptComms   bool   `json:"can_encrypt_comms,omitempty"`
	CanEncryptStorage bool   `json:"can_encrypt_storage,omitempty"`
	CanSign           bool   `json:"can_sign,omitempty"`
	CreatedAt         string `json:"created_at,omitempty"`
	Emails            []struct {
		Email    string `json:"email,omitempty"`
		Verified bool   `json:"verified,omitempty"`
	} `json:"emails,omitempty"`
	ExpiresAt    string `json:"expires_at,omitempty"`
	Id           int64  `json:"id,omitempty"`
	KeyId        string `json:"key_id,omitempty"`
	PrimaryKeyId string `json:"primary_key_id,omitempty"`
	PublicKey    string `json:"public_key,omitempty"`
	Subkeys      []struct {
		CanCertify        bool          `json:"can_certify,omitempty"`
		CanEncryptComms   bool          `json:"can_encrypt_comms,omitempty"`
		CanEncryptStorage bool          `json:"can_encrypt_storage,omitempty"`
		CanSign           bool          `json:"can_sign,omitempty"`
		CreatedAt         string        `json:"created_at,omitempty"`
		Emails            []interface{} `json:"emails,omitempty"`
		ExpiresAt         string        `json:"expires_at,omitempty"`
		Id                int64         `json:"id,omitempty"`
		KeyId             string        `json:"key_id,omitempty"`
		PrimaryKeyId      int64         `json:"primary_key_id,omitempty"`
		PublicKey         string        `json:"public_key,omitempty"`
		Subkeys           []interface{} `json:"subkeys,omitempty"`
	} `json:"subkeys,omitempty"`
}

/*
UsersListPublicEmailsReq builds requests for "users/list-public-emails"

List public email addresses for a user.

  GET /user/public_emails

https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-a-user
*/
type UsersListPublicEmailsReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r UsersListPublicEmailsReq) urlPath() string {
	return fmt.Sprintf("/user/public_emails")
}

func (r UsersListPublicEmailsReq) method() string {
	return "GET"
}

func (r UsersListPublicEmailsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r UsersListPublicEmailsReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersListPublicEmailsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersListPublicEmailsResponseBody200 is a response body for users/list-public-emails

API documentation: https://developer.github.com/v3/users/emails/#list-public-email-addresses-for-a-user
*/
type UsersListPublicEmailsResponseBody200 []struct {
	Email      string `json:"email,omitempty"`
	Primary    bool   `json:"primary,omitempty"`
	Verified   bool   `json:"verified,omitempty"`
	Visibility string `json:"visibility,omitempty"`
}

/*
UsersListPublicKeysReq builds requests for "users/list-public-keys"

List your public keys.

  GET /user/keys

https://developer.github.com/v3/users/keys/#list-your-public-keys
*/
type UsersListPublicKeysReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r UsersListPublicKeysReq) urlPath() string {
	return fmt.Sprintf("/user/keys")
}

func (r UsersListPublicKeysReq) method() string {
	return "GET"
}

func (r UsersListPublicKeysReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r UsersListPublicKeysReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersListPublicKeysReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersListPublicKeysResponseBody200 is a response body for users/list-public-keys

API documentation: https://developer.github.com/v3/users/keys/#list-your-public-keys
*/
type UsersListPublicKeysResponseBody200 []struct {
	Key   string `json:"key,omitempty"`
	KeyId string `json:"key_id,omitempty"`
}

/*
UsersListPublicKeysForUserReq builds requests for "users/list-public-keys-for-user"

List public keys for a user.

  GET /users/{username}/keys

https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type UsersListPublicKeysForUserReq struct {
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r UsersListPublicKeysForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/keys", r.Username)
}

func (r UsersListPublicKeysForUserReq) method() string {
	return "GET"
}

func (r UsersListPublicKeysForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r UsersListPublicKeysForUserReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersListPublicKeysForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersListPublicKeysForUserResponseBody200 is a response body for users/list-public-keys-for-user

API documentation: https://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
*/
type UsersListPublicKeysForUserResponseBody200 []struct {
	Id  int64  `json:"id,omitempty"`
	Key string `json:"key,omitempty"`
}

/*
UsersTogglePrimaryEmailVisibilityReq builds requests for "users/toggle-primary-email-visibility"

Toggle primary email visibility.

  PATCH /user/email/visibility

https://developer.github.com/v3/users/emails/#toggle-primary-email-visibility
*/
type UsersTogglePrimaryEmailVisibilityReq struct {
	RequestBody UsersTogglePrimaryEmailVisibilityReqBody
}

func (r UsersTogglePrimaryEmailVisibilityReq) urlPath() string {
	return fmt.Sprintf("/user/email/visibility")
}

func (r UsersTogglePrimaryEmailVisibilityReq) method() string {
	return "PATCH"
}

func (r UsersTogglePrimaryEmailVisibilityReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersTogglePrimaryEmailVisibilityReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersTogglePrimaryEmailVisibilityReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), r.RequestBody, opt)
}

/*
UsersTogglePrimaryEmailVisibilityReqBody is a request body for users/toggle-primary-email-visibility

API documentation: https://developer.github.com/v3/users/emails/#toggle-primary-email-visibility
*/
type UsersTogglePrimaryEmailVisibilityReqBody struct {

	// Specify the _primary_ email address that needs a visibility change.
	Email *string `json:"email"`

	/*
	   Use `public` to enable an authenticated user to view the specified email
	   address, or use `private` so this primary email address cannot be seen publicly.
	*/
	Visibility *string `json:"visibility"`
}

/*
UsersTogglePrimaryEmailVisibilityResponseBody200 is a response body for users/toggle-primary-email-visibility

API documentation: https://developer.github.com/v3/users/emails/#toggle-primary-email-visibility
*/
type UsersTogglePrimaryEmailVisibilityResponseBody200 []struct {
	Email      string `json:"email,omitempty"`
	Primary    bool   `json:"primary,omitempty"`
	Verified   bool   `json:"verified,omitempty"`
	Visibility string `json:"visibility,omitempty"`
}

/*
UsersUnblockReq builds requests for "users/unblock"

Unblock a user.

  DELETE /user/blocks/{username}

https://developer.github.com/v3/users/blocking/#unblock-a-user
*/
type UsersUnblockReq struct {
	Username string
}

func (r UsersUnblockReq) urlPath() string {
	return fmt.Sprintf("/user/blocks/%v", r.Username)
}

func (r UsersUnblockReq) method() string {
	return "DELETE"
}

func (r UsersUnblockReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersUnblockReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersUnblockReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersUnfollowReq builds requests for "users/unfollow"

Unfollow a user.

  DELETE /user/following/{username}

https://developer.github.com/v3/users/followers/#unfollow-a-user
*/
type UsersUnfollowReq struct {
	Username string
}

func (r UsersUnfollowReq) urlPath() string {
	return fmt.Sprintf("/user/following/%v", r.Username)
}

func (r UsersUnfollowReq) method() string {
	return "DELETE"
}

func (r UsersUnfollowReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersUnfollowReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersUnfollowReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), nil, opt)
}

/*
UsersUpdateAuthenticatedReq builds requests for "users/update-authenticated"

Update the authenticated user.

  PATCH /user

https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedReq struct {
	RequestBody UsersUpdateAuthenticatedReqBody
}

func (r UsersUpdateAuthenticatedReq) urlPath() string {
	return fmt.Sprintf("/user")
}

func (r UsersUpdateAuthenticatedReq) method() string {
	return "PATCH"
}

func (r UsersUpdateAuthenticatedReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r UsersUpdateAuthenticatedReq) header() http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

// HTTPRequest creates an http request
func (r UsersUpdateAuthenticatedReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return httpRequest(ctx, r.urlPath(), r.method(), r.urlQuery(), r.header(), r.RequestBody, opt)
}

/*
UsersUpdateAuthenticatedReqBody is a request body for users/update-authenticated

API documentation: https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedReqBody struct {

	// The new short biography of the user.
	Bio *string `json:"bio,omitempty"`

	// The new blog URL of the user.
	Blog *string `json:"blog,omitempty"`

	// The new company of the user.
	Company *string `json:"company,omitempty"`

	// The publicly visible email address of the user.
	Email *string `json:"email,omitempty"`

	// The new hiring availability of the user.
	Hireable *bool `json:"hireable,omitempty"`

	// The new location of the user.
	Location *string `json:"location,omitempty"`

	// The new name of the user.
	Name *string `json:"name,omitempty"`
}

/*
UsersUpdateAuthenticatedResponseBody200 is a response body for users/update-authenticated

API documentation: https://developer.github.com/v3/users/#update-the-authenticated-user
*/
type UsersUpdateAuthenticatedResponseBody200 struct {
	AvatarUrl         string      `json:"avatar_url,omitempty"`
	Bio               string      `json:"bio,omitempty"`
	Blog              string      `json:"blog,omitempty"`
	Collaborators     int64       `json:"collaborators,omitempty"`
	Company           string      `json:"company,omitempty"`
	CreatedAt         string      `json:"created_at,omitempty"`
	DiskUsage         json.Number `json:"disk_usage,omitempty"`
	Email             string      `json:"email,omitempty"`
	EventsUrl         string      `json:"events_url,omitempty"`
	Followers         int64       `json:"followers,omitempty"`
	FollowersUrl      string      `json:"followers_url,omitempty"`
	Following         int64       `json:"following,omitempty"`
	FollowingUrl      string      `json:"following_url,omitempty"`
	GistsUrl          string      `json:"gists_url,omitempty"`
	GravatarId        string      `json:"gravatar_id,omitempty"`
	Hireable          bool        `json:"hireable,omitempty"`
	HtmlUrl           string      `json:"html_url,omitempty"`
	Id                int64       `json:"id,omitempty"`
	Location          string      `json:"location,omitempty"`
	Login             string      `json:"login,omitempty"`
	Name              string      `json:"name,omitempty"`
	NodeId            string      `json:"node_id,omitempty"`
	OrganizationsUrl  string      `json:"organizations_url,omitempty"`
	OwnedPrivateRepos int64       `json:"owned_private_repos,omitempty"`
	Plan              struct {
		Collaborators int64       `json:"collaborators,omitempty"`
		Name          string      `json:"name,omitempty"`
		PrivateRepos  int64       `json:"private_repos,omitempty"`
		Space         json.Number `json:"space,omitempty"`
	} `json:"plan,omitempty"`
	PrivateGists            int64  `json:"private_gists,omitempty"`
	PublicGists             int64  `json:"public_gists,omitempty"`
	PublicRepos             int64  `json:"public_repos,omitempty"`
	ReceivedEventsUrl       string `json:"received_events_url,omitempty"`
	ReposUrl                string `json:"repos_url,omitempty"`
	SiteAdmin               bool   `json:"site_admin,omitempty"`
	StarredUrl              string `json:"starred_url,omitempty"`
	SubscriptionsUrl        string `json:"subscriptions_url,omitempty"`
	TotalPrivateRepos       int64  `json:"total_private_repos,omitempty"`
	TwoFactorAuthentication bool   `json:"two_factor_authentication,omitempty"`
	Type                    string `json:"type,omitempty"`
	UpdatedAt               string `json:"updated_at,omitempty"`
	Url                     string `json:"url,omitempty"`
}
