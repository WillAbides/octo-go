// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
ScimDeleteUserFromOrg performs requests for "scim/delete-user-from-org"

Delete a SCIM user from an organization.

  DELETE /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#delete-a-scim-user-from-an-organization
*/
func ScimDeleteUserFromOrg(ctx context.Context, req *ScimDeleteUserFromOrgReq, opt ...options.Option) (*ScimDeleteUserFromOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ScimDeleteUserFromOrgReq)
	}
	resp := &ScimDeleteUserFromOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ScimDeleteUserFromOrg performs requests for "scim/delete-user-from-org"

Delete a SCIM user from an organization.

  DELETE /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#delete-a-scim-user-from-an-organization
*/
func (c Client) ScimDeleteUserFromOrg(ctx context.Context, req *ScimDeleteUserFromOrgReq, opt ...options.Option) (*ScimDeleteUserFromOrgResponse, error) {
	return ScimDeleteUserFromOrg(ctx, req, append(c, opt...)...)
}

/*
ScimDeleteUserFromOrgReq is request data for Client.ScimDeleteUserFromOrg

https://developer.github.com/v3/scim/#delete-a-scim-user-from-an-organization
*/
type ScimDeleteUserFromOrgReq struct {
	_url string
	Org  string

	// scim_user_id parameter
	ScimUserId string
}

// HTTPRequest builds an *http.Request
func (r *ScimDeleteUserFromOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ScimDeleteUserFromOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "scim/delete-user-from-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/scim/v2/organizations/%v/Users/%v", r.Org, r.ScimUserId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ScimDeleteUserFromOrgReq) Rel(link string, resp *ScimDeleteUserFromOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ScimDeleteUserFromOrgResponse is a response for ScimDeleteUserFromOrg

https://developer.github.com/v3/scim/#delete-a-scim-user-from-an-organization
*/
type ScimDeleteUserFromOrgResponse struct {
	common.Response
	request *ScimDeleteUserFromOrgReq
}

/*
ScimGetProvisioningInformationForUser performs requests for "scim/get-provisioning-information-for-user"

Get SCIM provisioning information for a user.

  GET /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#get-scim-provisioning-information-for-a-user
*/
func ScimGetProvisioningInformationForUser(ctx context.Context, req *ScimGetProvisioningInformationForUserReq, opt ...options.Option) (*ScimGetProvisioningInformationForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ScimGetProvisioningInformationForUserReq)
	}
	resp := &ScimGetProvisioningInformationForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ScimUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ScimGetProvisioningInformationForUser performs requests for "scim/get-provisioning-information-for-user"

Get SCIM provisioning information for a user.

  GET /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#get-scim-provisioning-information-for-a-user
*/
func (c Client) ScimGetProvisioningInformationForUser(ctx context.Context, req *ScimGetProvisioningInformationForUserReq, opt ...options.Option) (*ScimGetProvisioningInformationForUserResponse, error) {
	return ScimGetProvisioningInformationForUser(ctx, req, append(c, opt...)...)
}

/*
ScimGetProvisioningInformationForUserReq is request data for Client.ScimGetProvisioningInformationForUser

https://developer.github.com/v3/scim/#get-scim-provisioning-information-for-a-user
*/
type ScimGetProvisioningInformationForUserReq struct {
	_url string
	Org  string

	// scim_user_id parameter
	ScimUserId string
}

// HTTPRequest builds an *http.Request
func (r *ScimGetProvisioningInformationForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ScimGetProvisioningInformationForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/scim+json")},
		Method:           "GET",
		OperationID:      "scim/get-provisioning-information-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/scim/v2/organizations/%v/Users/%v", r.Org, r.ScimUserId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ScimGetProvisioningInformationForUserReq) Rel(link string, resp *ScimGetProvisioningInformationForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ScimGetProvisioningInformationForUserResponse is a response for ScimGetProvisioningInformationForUser

https://developer.github.com/v3/scim/#get-scim-provisioning-information-for-a-user
*/
type ScimGetProvisioningInformationForUserResponse struct {
	common.Response
	request *ScimGetProvisioningInformationForUserReq
	Data    components.ScimUser
}

/*
ScimListProvisionedIdentities performs requests for "scim/list-provisioned-identities"

List SCIM provisioned identities.

  GET /scim/v2/organizations/{org}/Users

https://developer.github.com/v3/scim/#list-scim-provisioned-identities
*/
func ScimListProvisionedIdentities(ctx context.Context, req *ScimListProvisionedIdentitiesReq, opt ...options.Option) (*ScimListProvisionedIdentitiesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ScimListProvisionedIdentitiesReq)
	}
	resp := &ScimListProvisionedIdentitiesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ScimUserList{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ScimListProvisionedIdentities performs requests for "scim/list-provisioned-identities"

List SCIM provisioned identities.

  GET /scim/v2/organizations/{org}/Users

https://developer.github.com/v3/scim/#list-scim-provisioned-identities
*/
func (c Client) ScimListProvisionedIdentities(ctx context.Context, req *ScimListProvisionedIdentitiesReq, opt ...options.Option) (*ScimListProvisionedIdentitiesResponse, error) {
	return ScimListProvisionedIdentities(ctx, req, append(c, opt...)...)
}

/*
ScimListProvisionedIdentitiesReq is request data for Client.ScimListProvisionedIdentities

https://developer.github.com/v3/scim/#list-scim-provisioned-identities
*/
type ScimListProvisionedIdentitiesReq struct {
	_url string
	Org  string

	// Used for pagination: the index of the first result to return.
	StartIndex *int64

	// Used for pagination: the number of results to return.
	Count *int64

	/*
	Filters results using the equals query parameter operator (`eq`). You can filter
	results that are equal to `id`, `userName`, `emails`, and `external_id`. For
	example, to search for an identity with the `userName` Octocat, you would use
	this query:

	`?filter=userName%20eq%20\"Octocat\"`.

	To filter results for for the identity with the email `octocat@github.com`, you
	would use this query:

	`?filter=emails%20eq%20\"octocat@github.com\"`.
	*/
	Filter *string
}

// HTTPRequest builds an *http.Request
func (r *ScimListProvisionedIdentitiesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ScimListProvisionedIdentitiesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.StartIndex != nil {
		query.Set("startIndex", strconv.FormatInt(*r.StartIndex, 10))
	}
	if r.Count != nil {
		query.Set("count", strconv.FormatInt(*r.Count, 10))
	}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/scim+json")},
		Method:           "GET",
		OperationID:      "scim/list-provisioned-identities",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/scim/v2/organizations/%v/Users", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ScimListProvisionedIdentitiesReq) Rel(link string, resp *ScimListProvisionedIdentitiesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ScimListProvisionedIdentitiesResponse is a response for ScimListProvisionedIdentities

https://developer.github.com/v3/scim/#list-scim-provisioned-identities
*/
type ScimListProvisionedIdentitiesResponse struct {
	common.Response
	request *ScimListProvisionedIdentitiesReq
	Data    components.ScimUserList
}

/*
ScimProvisionAndInviteUser performs requests for "scim/provision-and-invite-user"

Provision and invite a SCIM user.

  POST /scim/v2/organizations/{org}/Users

https://developer.github.com/v3/scim/#provision-and-invite-a-scim-user
*/
func ScimProvisionAndInviteUser(ctx context.Context, req *ScimProvisionAndInviteUserReq, opt ...options.Option) (*ScimProvisionAndInviteUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ScimProvisionAndInviteUserReq)
	}
	resp := &ScimProvisionAndInviteUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ScimUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ScimProvisionAndInviteUser performs requests for "scim/provision-and-invite-user"

Provision and invite a SCIM user.

  POST /scim/v2/organizations/{org}/Users

https://developer.github.com/v3/scim/#provision-and-invite-a-scim-user
*/
func (c Client) ScimProvisionAndInviteUser(ctx context.Context, req *ScimProvisionAndInviteUserReq, opt ...options.Option) (*ScimProvisionAndInviteUserResponse, error) {
	return ScimProvisionAndInviteUser(ctx, req, append(c, opt...)...)
}

/*
ScimProvisionAndInviteUserReq is request data for Client.ScimProvisionAndInviteUser

https://developer.github.com/v3/scim/#provision-and-invite-a-scim-user
*/
type ScimProvisionAndInviteUserReq struct {
	_url        string
	Org         string
	RequestBody ScimProvisionAndInviteUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *ScimProvisionAndInviteUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ScimProvisionAndInviteUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/scim+json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "scim/provision-and-invite-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/scim/v2/organizations/%v/Users", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ScimProvisionAndInviteUserReq) Rel(link string, resp *ScimProvisionAndInviteUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ScimProvisionAndInviteUserReqBodyEmails is a value for ScimProvisionAndInviteUserReqBody's Emails field
type ScimProvisionAndInviteUserReqBodyEmails struct {
	Primary *bool   `json:"primary,omitempty"`
	Type    *string `json:"type,omitempty"`
	Value   *string `json:"value"`
}

// ScimProvisionAndInviteUserReqBodyName is a value for ScimProvisionAndInviteUserReqBody's Name field
type ScimProvisionAndInviteUserReqBodyName struct {
	FamilyName *string `json:"familyName"`
	GivenName  *string `json:"givenName"`
}

/*
ScimProvisionAndInviteUserReqBody is a request body for scim/provision-and-invite-user

https://developer.github.com/v3/scim/#provision-and-invite-a-scim-user
*/
type ScimProvisionAndInviteUserReqBody struct {
	Active      *bool   `json:"active,omitempty"`
	DisplayName *string `json:"displayName,omitempty"`

	// user emails
	Emails     []ScimProvisionAndInviteUserReqBodyEmails `json:"emails"`
	ExternalId *string                                   `json:"externalId,omitempty"`
	Groups     []string                                  `json:"groups,omitempty"`
	Name       *ScimProvisionAndInviteUserReqBodyName    `json:"name"`
	Schemas    []string                                  `json:"schemas,omitempty"`

	// Configured by the admin. Could be an email, login, or username
	UserName *string `json:"userName"`
}

/*
ScimProvisionAndInviteUserResponse is a response for ScimProvisionAndInviteUser

https://developer.github.com/v3/scim/#provision-and-invite-a-scim-user
*/
type ScimProvisionAndInviteUserResponse struct {
	common.Response
	request *ScimProvisionAndInviteUserReq
	Data    components.ScimUser
}

/*
ScimSetInformationForProvisionedUser performs requests for "scim/set-information-for-provisioned-user"

Update a provisioned organization membership.

  PUT /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#set-scim-information-for-a-provisioned-user
*/
func ScimSetInformationForProvisionedUser(ctx context.Context, req *ScimSetInformationForProvisionedUserReq, opt ...options.Option) (*ScimSetInformationForProvisionedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ScimSetInformationForProvisionedUserReq)
	}
	resp := &ScimSetInformationForProvisionedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ScimUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ScimSetInformationForProvisionedUser performs requests for "scim/set-information-for-provisioned-user"

Update a provisioned organization membership.

  PUT /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#set-scim-information-for-a-provisioned-user
*/
func (c Client) ScimSetInformationForProvisionedUser(ctx context.Context, req *ScimSetInformationForProvisionedUserReq, opt ...options.Option) (*ScimSetInformationForProvisionedUserResponse, error) {
	return ScimSetInformationForProvisionedUser(ctx, req, append(c, opt...)...)
}

/*
ScimSetInformationForProvisionedUserReq is request data for Client.ScimSetInformationForProvisionedUser

https://developer.github.com/v3/scim/#set-scim-information-for-a-provisioned-user
*/
type ScimSetInformationForProvisionedUserReq struct {
	_url string
	Org  string

	// scim_user_id parameter
	ScimUserId  string
	RequestBody ScimSetInformationForProvisionedUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *ScimSetInformationForProvisionedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ScimSetInformationForProvisionedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/scim+json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "scim/set-information-for-provisioned-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/scim/v2/organizations/%v/Users/%v", r.Org, r.ScimUserId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ScimSetInformationForProvisionedUserReq) Rel(link string, resp *ScimSetInformationForProvisionedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ScimSetInformationForProvisionedUserReqBodyEmails is a value for ScimSetInformationForProvisionedUserReqBody's Emails field
type ScimSetInformationForProvisionedUserReqBodyEmails struct {
	Primary *bool   `json:"primary,omitempty"`
	Type    *string `json:"type,omitempty"`
	Value   *string `json:"value"`
}

// ScimSetInformationForProvisionedUserReqBodyName is a value for ScimSetInformationForProvisionedUserReqBody's Name field
type ScimSetInformationForProvisionedUserReqBodyName struct {
	FamilyName *string `json:"familyName"`
	GivenName  *string `json:"givenName"`
}

/*
ScimSetInformationForProvisionedUserReqBody is a request body for scim/set-information-for-provisioned-user

https://developer.github.com/v3/scim/#set-scim-information-for-a-provisioned-user
*/
type ScimSetInformationForProvisionedUserReqBody struct {
	Active      *bool   `json:"active,omitempty"`
	DisplayName *string `json:"displayName,omitempty"`

	// user emails
	Emails     []ScimSetInformationForProvisionedUserReqBodyEmails `json:"emails"`
	ExternalId *string                                             `json:"externalId,omitempty"`
	Groups     []string                                            `json:"groups,omitempty"`
	Name       *ScimSetInformationForProvisionedUserReqBodyName    `json:"name"`
	Schemas    []string                                            `json:"schemas,omitempty"`

	// Configured by the admin. Could be an email, login, or username
	UserName *string `json:"userName"`
}

/*
ScimSetInformationForProvisionedUserResponse is a response for ScimSetInformationForProvisionedUser

https://developer.github.com/v3/scim/#set-scim-information-for-a-provisioned-user
*/
type ScimSetInformationForProvisionedUserResponse struct {
	common.Response
	request *ScimSetInformationForProvisionedUserReq
	Data    components.ScimUser
}

/*
ScimUpdateAttributeForUser performs requests for "scim/update-attribute-for-user"

Update an attribute for a SCIM user.

  PATCH /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#update-an-attribute-for-a-scim-user
*/
func ScimUpdateAttributeForUser(ctx context.Context, req *ScimUpdateAttributeForUserReq, opt ...options.Option) (*ScimUpdateAttributeForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ScimUpdateAttributeForUserReq)
	}
	resp := &ScimUpdateAttributeForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ScimUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ScimUpdateAttributeForUser performs requests for "scim/update-attribute-for-user"

Update an attribute for a SCIM user.

  PATCH /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#update-an-attribute-for-a-scim-user
*/
func (c Client) ScimUpdateAttributeForUser(ctx context.Context, req *ScimUpdateAttributeForUserReq, opt ...options.Option) (*ScimUpdateAttributeForUserResponse, error) {
	return ScimUpdateAttributeForUser(ctx, req, append(c, opt...)...)
}

/*
ScimUpdateAttributeForUserReq is request data for Client.ScimUpdateAttributeForUser

https://developer.github.com/v3/scim/#update-an-attribute-for-a-scim-user
*/
type ScimUpdateAttributeForUserReq struct {
	_url string
	Org  string

	// scim_user_id parameter
	ScimUserId  string
	RequestBody ScimUpdateAttributeForUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *ScimUpdateAttributeForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ScimUpdateAttributeForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/scim+json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "scim/update-attribute-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/scim/v2/organizations/%v/Users/%v", r.Org, r.ScimUserId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ScimUpdateAttributeForUserReq) Rel(link string, resp *ScimUpdateAttributeForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// ScimUpdateAttributeForUserReqBodyOperations is a value for ScimUpdateAttributeForUserReqBody's Operations field
type ScimUpdateAttributeForUserReqBodyOperations struct {
	Op    *string                                           `json:"op"`
	Path  *string                                           `json:"path,omitempty"`
	Value *ScimUpdateAttributeForUserReqBodyOperationsValue `json:"value,omitempty"`
}

// ScimUpdateAttributeForUserReqBodyOperationsValue is a value for ScimUpdateAttributeForUserReqBodyOperations's Value field
type ScimUpdateAttributeForUserReqBodyOperationsValue struct {
	Active     *bool   `json:"active,omitempty"`
	ExternalId *string `json:"externalId,omitempty"`
	FamilyName *string `json:"familyName,omitempty"`
	GivenName  *string `json:"givenName,omitempty"`
	UserName   *string `json:"userName,omitempty"`
}

/*
ScimUpdateAttributeForUserReqBody is a request body for scim/update-attribute-for-user

https://developer.github.com/v3/scim/#update-an-attribute-for-a-scim-user
*/
type ScimUpdateAttributeForUserReqBody struct {

	// Set of operations to be performed
	Operations []ScimUpdateAttributeForUserReqBodyOperations `json:"Operations"`
	Schemas    []string                                      `json:"schemas,omitempty"`
}

/*
ScimUpdateAttributeForUserResponse is a response for ScimUpdateAttributeForUser

https://developer.github.com/v3/scim/#update-an-attribute-for-a-scim-user
*/
type ScimUpdateAttributeForUserResponse struct {
	common.Response
	request *ScimUpdateAttributeForUserReq
	Data    components.ScimUser
}
