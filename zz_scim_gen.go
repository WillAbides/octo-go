// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
ScimGetProvisioningDetailsForUser performs requests for "scim/get-provisioning-details-for-user"

Get provisioning details for a single user.

  GET /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#get-provisioning-details-for-a-single-user
*/
func (c *Client) ScimGetProvisioningDetailsForUser(ctx context.Context, req *ScimGetProvisioningDetailsForUserReq, opt ...RequestOption) (*ScimGetProvisioningDetailsForUserResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ScimGetProvisioningDetailsForUserResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ScimGetProvisioningDetailsForUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ScimGetProvisioningDetailsForUserReq is request data for Client.ScimGetProvisioningDetailsForUser

https://developer.github.com/v3/scim/#get-provisioning-details-for-a-single-user
*/
type ScimGetProvisioningDetailsForUserReq struct {
	_url       string
	Org        string
	ScimUserId int64
}

func (r *ScimGetProvisioningDetailsForUserReq) url() string {
	return r._url
}

func (r *ScimGetProvisioningDetailsForUserReq) urlPath() string {
	return fmt.Sprintf("/scim/v2/organizations/%v/Users/%v", r.Org, r.ScimUserId)
}

func (r *ScimGetProvisioningDetailsForUserReq) method() string {
	return "GET"
}

func (r *ScimGetProvisioningDetailsForUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ScimGetProvisioningDetailsForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ScimGetProvisioningDetailsForUserReq) body() interface{} {
	return nil
}

func (r *ScimGetProvisioningDetailsForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *ScimGetProvisioningDetailsForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *ScimGetProvisioningDetailsForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ScimGetProvisioningDetailsForUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ScimGetProvisioningDetailsForUserReq) Rel(link RelName, resp *ScimGetProvisioningDetailsForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ScimGetProvisioningDetailsForUserResponseBody is a response body for ScimGetProvisioningDetailsForUser

https://developer.github.com/v3/scim/#get-provisioning-details-for-a-single-user
*/
type ScimGetProvisioningDetailsForUserResponseBody struct {
	components.ScimUser
}

/*
ScimGetProvisioningDetailsForUserResponse is a response for ScimGetProvisioningDetailsForUser

https://developer.github.com/v3/scim/#get-provisioning-details-for-a-single-user
*/
type ScimGetProvisioningDetailsForUserResponse struct {
	response
	request *ScimGetProvisioningDetailsForUserReq
	Data    *ScimGetProvisioningDetailsForUserResponseBody
}

/*
ScimListProvisionedIdentities performs requests for "scim/list-provisioned-identities"

Get a list of provisioned identities.

  GET /scim/v2/organizations/{org}/Users

https://developer.github.com/v3/scim/#get-a-list-of-provisioned-identities
*/
func (c *Client) ScimListProvisionedIdentities(ctx context.Context, req *ScimListProvisionedIdentitiesReq, opt ...RequestOption) (*ScimListProvisionedIdentitiesResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ScimListProvisionedIdentitiesResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ScimListProvisionedIdentitiesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ScimListProvisionedIdentitiesReq is request data for Client.ScimListProvisionedIdentities

https://developer.github.com/v3/scim/#get-a-list-of-provisioned-identities
*/
type ScimListProvisionedIdentitiesReq struct {
	_url string
	Org  string

	// Used for pagination: the index of the first result to return.
	StartIndex *int64

	// Used for pagination: the number of results to return.
	Count *int64

	/*
	Filters results using the equals query parameter operator (`eq`). You can filter
	results that are equal to `id`, `userName`, `emails`, and `external_id`. For
	example, to search for an identity with the `userName` Octocat, you would use
	this query: `?filter=userName%20eq%20\"Octocat\"`.
	*/
	Filter *string
}

func (r *ScimListProvisionedIdentitiesReq) url() string {
	return r._url
}

func (r *ScimListProvisionedIdentitiesReq) urlPath() string {
	return fmt.Sprintf("/scim/v2/organizations/%v/Users", r.Org)
}

func (r *ScimListProvisionedIdentitiesReq) method() string {
	return "GET"
}

func (r *ScimListProvisionedIdentitiesReq) urlQuery() url.Values {
	query := url.Values{}
	if r.StartIndex != nil {
		query.Set("startIndex", strconv.FormatInt(*r.StartIndex, 10))
	}
	if r.Count != nil {
		query.Set("count", strconv.FormatInt(*r.Count, 10))
	}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	return query
}

func (r *ScimListProvisionedIdentitiesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ScimListProvisionedIdentitiesReq) body() interface{} {
	return nil
}

func (r *ScimListProvisionedIdentitiesReq) dataStatuses() []int {
	return []int{200}
}

func (r *ScimListProvisionedIdentitiesReq) validStatuses() []int {
	return []int{200}
}

func (r *ScimListProvisionedIdentitiesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ScimListProvisionedIdentitiesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ScimListProvisionedIdentitiesReq) Rel(link RelName, resp *ScimListProvisionedIdentitiesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ScimListProvisionedIdentitiesResponseBody is a response body for ScimListProvisionedIdentities

https://developer.github.com/v3/scim/#get-a-list-of-provisioned-identities
*/
type ScimListProvisionedIdentitiesResponseBody struct {
	components.ScimUserList
}

/*
ScimListProvisionedIdentitiesResponse is a response for ScimListProvisionedIdentities

https://developer.github.com/v3/scim/#get-a-list-of-provisioned-identities
*/
type ScimListProvisionedIdentitiesResponse struct {
	response
	request *ScimListProvisionedIdentitiesReq
	Data    *ScimListProvisionedIdentitiesResponseBody
}

/*
ScimProvisionAndInviteUsers performs requests for "scim/provision-and-invite-users"

Provision and invite users.

  POST /scim/v2/organizations/{org}/Users

https://developer.github.com/v3/scim/#provision-and-invite-users
*/
func (c *Client) ScimProvisionAndInviteUsers(ctx context.Context, req *ScimProvisionAndInviteUsersReq, opt ...RequestOption) (*ScimProvisionAndInviteUsersResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ScimProvisionAndInviteUsersResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ScimProvisionAndInviteUsersResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ScimProvisionAndInviteUsersReq is request data for Client.ScimProvisionAndInviteUsers

https://developer.github.com/v3/scim/#provision-and-invite-users
*/
type ScimProvisionAndInviteUsersReq struct {
	_url string
	Org  string
}

func (r *ScimProvisionAndInviteUsersReq) url() string {
	return r._url
}

func (r *ScimProvisionAndInviteUsersReq) urlPath() string {
	return fmt.Sprintf("/scim/v2/organizations/%v/Users", r.Org)
}

func (r *ScimProvisionAndInviteUsersReq) method() string {
	return "POST"
}

func (r *ScimProvisionAndInviteUsersReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ScimProvisionAndInviteUsersReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ScimProvisionAndInviteUsersReq) body() interface{} {
	return nil
}

func (r *ScimProvisionAndInviteUsersReq) dataStatuses() []int {
	return []int{201}
}

func (r *ScimProvisionAndInviteUsersReq) validStatuses() []int {
	return []int{201}
}

func (r *ScimProvisionAndInviteUsersReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ScimProvisionAndInviteUsersReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ScimProvisionAndInviteUsersReq) Rel(link RelName, resp *ScimProvisionAndInviteUsersResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ScimProvisionAndInviteUsersResponseBody is a response body for ScimProvisionAndInviteUsers

https://developer.github.com/v3/scim/#provision-and-invite-users
*/
type ScimProvisionAndInviteUsersResponseBody struct {
	components.ScimUser
}

/*
ScimProvisionAndInviteUsersResponse is a response for ScimProvisionAndInviteUsers

https://developer.github.com/v3/scim/#provision-and-invite-users
*/
type ScimProvisionAndInviteUsersResponse struct {
	response
	request *ScimProvisionAndInviteUsersReq
	Data    *ScimProvisionAndInviteUsersResponseBody
}

/*
ScimRemoveUserFromOrg performs requests for "scim/remove-user-from-org"

Remove a user from the organization.

  DELETE /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#remove-a-user-from-the-organization
*/
func (c *Client) ScimRemoveUserFromOrg(ctx context.Context, req *ScimRemoveUserFromOrgReq, opt ...RequestOption) (*ScimRemoveUserFromOrgResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ScimRemoveUserFromOrgResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ScimRemoveUserFromOrgReq is request data for Client.ScimRemoveUserFromOrg

https://developer.github.com/v3/scim/#remove-a-user-from-the-organization
*/
type ScimRemoveUserFromOrgReq struct {
	_url       string
	Org        string
	ScimUserId int64
}

func (r *ScimRemoveUserFromOrgReq) url() string {
	return r._url
}

func (r *ScimRemoveUserFromOrgReq) urlPath() string {
	return fmt.Sprintf("/scim/v2/organizations/%v/Users/%v", r.Org, r.ScimUserId)
}

func (r *ScimRemoveUserFromOrgReq) method() string {
	return "DELETE"
}

func (r *ScimRemoveUserFromOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ScimRemoveUserFromOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ScimRemoveUserFromOrgReq) body() interface{} {
	return nil
}

func (r *ScimRemoveUserFromOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *ScimRemoveUserFromOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *ScimRemoveUserFromOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ScimRemoveUserFromOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ScimRemoveUserFromOrgReq) Rel(link RelName, resp *ScimRemoveUserFromOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ScimRemoveUserFromOrgResponse is a response for ScimRemoveUserFromOrg

https://developer.github.com/v3/scim/#remove-a-user-from-the-organization
*/
type ScimRemoveUserFromOrgResponse struct {
	response
	request *ScimRemoveUserFromOrgReq
}

/*
ScimReplaceProvisionedUserInformation performs requests for "scim/replace-provisioned-user-information"

Replace a provisioned user's information.

  PUT /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#replace-a-provisioned-users-information
*/
func (c *Client) ScimReplaceProvisionedUserInformation(ctx context.Context, req *ScimReplaceProvisionedUserInformationReq, opt ...RequestOption) (*ScimReplaceProvisionedUserInformationResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ScimReplaceProvisionedUserInformationResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ScimReplaceProvisionedUserInformationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ScimReplaceProvisionedUserInformationReq is request data for Client.ScimReplaceProvisionedUserInformation

https://developer.github.com/v3/scim/#replace-a-provisioned-users-information
*/
type ScimReplaceProvisionedUserInformationReq struct {
	_url       string
	Org        string
	ScimUserId int64
}

func (r *ScimReplaceProvisionedUserInformationReq) url() string {
	return r._url
}

func (r *ScimReplaceProvisionedUserInformationReq) urlPath() string {
	return fmt.Sprintf("/scim/v2/organizations/%v/Users/%v", r.Org, r.ScimUserId)
}

func (r *ScimReplaceProvisionedUserInformationReq) method() string {
	return "PUT"
}

func (r *ScimReplaceProvisionedUserInformationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ScimReplaceProvisionedUserInformationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ScimReplaceProvisionedUserInformationReq) body() interface{} {
	return nil
}

func (r *ScimReplaceProvisionedUserInformationReq) dataStatuses() []int {
	return []int{200}
}

func (r *ScimReplaceProvisionedUserInformationReq) validStatuses() []int {
	return []int{200}
}

func (r *ScimReplaceProvisionedUserInformationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ScimReplaceProvisionedUserInformationReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ScimReplaceProvisionedUserInformationReq) Rel(link RelName, resp *ScimReplaceProvisionedUserInformationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ScimReplaceProvisionedUserInformationResponseBody is a response body for ScimReplaceProvisionedUserInformation

https://developer.github.com/v3/scim/#replace-a-provisioned-users-information
*/
type ScimReplaceProvisionedUserInformationResponseBody struct {
	components.ScimUser
}

/*
ScimReplaceProvisionedUserInformationResponse is a response for ScimReplaceProvisionedUserInformation

https://developer.github.com/v3/scim/#replace-a-provisioned-users-information
*/
type ScimReplaceProvisionedUserInformationResponse struct {
	response
	request *ScimReplaceProvisionedUserInformationReq
	Data    *ScimReplaceProvisionedUserInformationResponseBody
}

/*
ScimUpdateUserAttribute performs requests for "scim/update-user-attribute"

Update a user attribute.

  PATCH /scim/v2/organizations/{org}/Users/{scim_user_id}

https://developer.github.com/v3/scim/#update-a-user-attribute
*/
func (c *Client) ScimUpdateUserAttribute(ctx context.Context, req *ScimUpdateUserAttributeReq, opt ...RequestOption) (*ScimUpdateUserAttributeResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ScimUpdateUserAttributeResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ScimUpdateUserAttributeResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ScimUpdateUserAttributeReq is request data for Client.ScimUpdateUserAttribute

https://developer.github.com/v3/scim/#update-a-user-attribute
*/
type ScimUpdateUserAttributeReq struct {
	_url       string
	Org        string
	ScimUserId int64
}

func (r *ScimUpdateUserAttributeReq) url() string {
	return r._url
}

func (r *ScimUpdateUserAttributeReq) urlPath() string {
	return fmt.Sprintf("/scim/v2/organizations/%v/Users/%v", r.Org, r.ScimUserId)
}

func (r *ScimUpdateUserAttributeReq) method() string {
	return "PATCH"
}

func (r *ScimUpdateUserAttributeReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ScimUpdateUserAttributeReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ScimUpdateUserAttributeReq) body() interface{} {
	return nil
}

func (r *ScimUpdateUserAttributeReq) dataStatuses() []int {
	return []int{200}
}

func (r *ScimUpdateUserAttributeReq) validStatuses() []int {
	return []int{200}
}

func (r *ScimUpdateUserAttributeReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ScimUpdateUserAttributeReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ScimUpdateUserAttributeReq) Rel(link RelName, resp *ScimUpdateUserAttributeResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ScimUpdateUserAttributeResponseBody is a response body for ScimUpdateUserAttribute

https://developer.github.com/v3/scim/#update-a-user-attribute
*/
type ScimUpdateUserAttributeResponseBody struct {
	components.ScimUser2
}

/*
ScimUpdateUserAttributeResponse is a response for ScimUpdateUserAttribute

https://developer.github.com/v3/scim/#update-a-user-attribute
*/
type ScimUpdateUserAttributeResponse struct {
	response
	request *ScimUpdateUserAttributeReq
	Data    *ScimUpdateUserAttributeResponseBody
}
