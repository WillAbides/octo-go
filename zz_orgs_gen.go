// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
OrgsAddOrUpdateMembership performs requests for "orgs/add-or-update-membership"

Add or update organization membership.

  PUT /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#add-or-update-organization-membership
*/
func OrgsAddOrUpdateMembership(ctx context.Context, req *OrgsAddOrUpdateMembershipReq, opt ...RequestOption) (*OrgsAddOrUpdateMembershipResponse, error) {
	if req == nil {
		req = new(OrgsAddOrUpdateMembershipReq)
	}
	resp := &OrgsAddOrUpdateMembershipResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsAddOrUpdateMembershipResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsAddOrUpdateMembership performs requests for "orgs/add-or-update-membership"

Add or update organization membership.

  PUT /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#add-or-update-organization-membership
*/
func (c Client) OrgsAddOrUpdateMembership(ctx context.Context, req *OrgsAddOrUpdateMembershipReq, opt ...RequestOption) (*OrgsAddOrUpdateMembershipResponse, error) {
	return OrgsAddOrUpdateMembership(ctx, req, append(c, opt...)...)
}

/*
OrgsAddOrUpdateMembershipReq is request data for Client.OrgsAddOrUpdateMembership

https://developer.github.com/v3/orgs/members/#add-or-update-organization-membership
*/
type OrgsAddOrUpdateMembershipReq struct {
	_url        string
	Org         string
	Username    string
	RequestBody OrgsAddOrUpdateMembershipReqBody
}

func (r *OrgsAddOrUpdateMembershipReq) url() string {
	return r._url
}

func (r *OrgsAddOrUpdateMembershipReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username)
}

func (r *OrgsAddOrUpdateMembershipReq) method() string {
	return "PUT"
}

func (r *OrgsAddOrUpdateMembershipReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsAddOrUpdateMembershipReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsAddOrUpdateMembershipReq) body() interface{} {
	return r.RequestBody
}

func (r *OrgsAddOrUpdateMembershipReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsAddOrUpdateMembershipReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsAddOrUpdateMembershipReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *OrgsAddOrUpdateMembershipReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsAddOrUpdateMembershipReq) Rel(link RelName, resp *OrgsAddOrUpdateMembershipResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsAddOrUpdateMembershipReqBody is a request body for orgs/add-or-update-membership

https://developer.github.com/v3/orgs/members/#add-or-update-organization-membership
*/
type OrgsAddOrUpdateMembershipReqBody struct {

	/*
	   The role to give the user in the organization. Can be one of:
	   \* `admin` - The user will become an owner of the organization.
	   \* `member` - The user will become a non-owner member of the organization.
	*/
	Role *string `json:"role,omitempty"`
}

/*
OrgsAddOrUpdateMembershipResponseBody is a response body for OrgsAddOrUpdateMembership

https://developer.github.com/v3/orgs/members/#add-or-update-organization-membership
*/
type OrgsAddOrUpdateMembershipResponseBody struct {
	components.OrgMembership
}

/*
OrgsAddOrUpdateMembershipResponse is a response for OrgsAddOrUpdateMembership

https://developer.github.com/v3/orgs/members/#add-or-update-organization-membership
*/
type OrgsAddOrUpdateMembershipResponse struct {
	response
	request *OrgsAddOrUpdateMembershipReq
	Data    *OrgsAddOrUpdateMembershipResponseBody
}

/*
OrgsBlockUser performs requests for "orgs/block-user"

Block a user.

  PUT /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#block-a-user
*/
func OrgsBlockUser(ctx context.Context, req *OrgsBlockUserReq, opt ...RequestOption) (*OrgsBlockUserResponse, error) {
	if req == nil {
		req = new(OrgsBlockUserReq)
	}
	resp := &OrgsBlockUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsBlockUser performs requests for "orgs/block-user"

Block a user.

  PUT /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#block-a-user
*/
func (c Client) OrgsBlockUser(ctx context.Context, req *OrgsBlockUserReq, opt ...RequestOption) (*OrgsBlockUserResponse, error) {
	return OrgsBlockUser(ctx, req, append(c, opt...)...)
}

/*
OrgsBlockUserReq is request data for Client.OrgsBlockUser

https://developer.github.com/v3/orgs/blocking/#block-a-user
*/
type OrgsBlockUserReq struct {
	_url     string
	Org      string
	Username string
}

func (r *OrgsBlockUserReq) url() string {
	return r._url
}

func (r *OrgsBlockUserReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username)
}

func (r *OrgsBlockUserReq) method() string {
	return "PUT"
}

func (r *OrgsBlockUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsBlockUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsBlockUserReq) body() interface{} {
	return nil
}

func (r *OrgsBlockUserReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsBlockUserReq) validStatuses() []int {
	return []int{204}
}

func (r *OrgsBlockUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsBlockUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsBlockUserReq) Rel(link RelName, resp *OrgsBlockUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsBlockUserResponse is a response for OrgsBlockUser

https://developer.github.com/v3/orgs/blocking/#block-a-user
*/
type OrgsBlockUserResponse struct {
	response
	request *OrgsBlockUserReq
}

/*
OrgsCheckBlockedUser performs requests for "orgs/check-blocked-user"

Check whether a user is blocked from an organization.

  GET /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#check-whether-a-user-is-blocked-from-an-organization
*/
func OrgsCheckBlockedUser(ctx context.Context, req *OrgsCheckBlockedUserReq, opt ...RequestOption) (*OrgsCheckBlockedUserResponse, error) {
	if req == nil {
		req = new(OrgsCheckBlockedUserReq)
	}
	resp := &OrgsCheckBlockedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsCheckBlockedUser performs requests for "orgs/check-blocked-user"

Check whether a user is blocked from an organization.

  GET /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#check-whether-a-user-is-blocked-from-an-organization
*/
func (c Client) OrgsCheckBlockedUser(ctx context.Context, req *OrgsCheckBlockedUserReq, opt ...RequestOption) (*OrgsCheckBlockedUserResponse, error) {
	return OrgsCheckBlockedUser(ctx, req, append(c, opt...)...)
}

/*
OrgsCheckBlockedUserReq is request data for Client.OrgsCheckBlockedUser

https://developer.github.com/v3/orgs/blocking/#check-whether-a-user-is-blocked-from-an-organization
*/
type OrgsCheckBlockedUserReq struct {
	_url     string
	Org      string
	Username string
}

func (r *OrgsCheckBlockedUserReq) url() string {
	return r._url
}

func (r *OrgsCheckBlockedUserReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username)
}

func (r *OrgsCheckBlockedUserReq) method() string {
	return "GET"
}

func (r *OrgsCheckBlockedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsCheckBlockedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsCheckBlockedUserReq) body() interface{} {
	return nil
}

func (r *OrgsCheckBlockedUserReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsCheckBlockedUserReq) validStatuses() []int {
	return []int{204}
}

func (r *OrgsCheckBlockedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// HTTPRequest builds an *http.Request
func (r *OrgsCheckBlockedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsCheckBlockedUserReq) Rel(link RelName, resp *OrgsCheckBlockedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsCheckBlockedUserResponse is a response for OrgsCheckBlockedUser

https://developer.github.com/v3/orgs/blocking/#check-whether-a-user-is-blocked-from-an-organization
*/
type OrgsCheckBlockedUserResponse struct {
	response
	request *OrgsCheckBlockedUserReq
	Data    bool
}

/*
OrgsCheckMembership performs requests for "orgs/check-membership"

Check membership.

  GET /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#check-membership
*/
func OrgsCheckMembership(ctx context.Context, req *OrgsCheckMembershipReq, opt ...RequestOption) (*OrgsCheckMembershipResponse, error) {
	if req == nil {
		req = new(OrgsCheckMembershipReq)
	}
	resp := &OrgsCheckMembershipResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsCheckMembership performs requests for "orgs/check-membership"

Check membership.

  GET /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#check-membership
*/
func (c Client) OrgsCheckMembership(ctx context.Context, req *OrgsCheckMembershipReq, opt ...RequestOption) (*OrgsCheckMembershipResponse, error) {
	return OrgsCheckMembership(ctx, req, append(c, opt...)...)
}

/*
OrgsCheckMembershipReq is request data for Client.OrgsCheckMembership

https://developer.github.com/v3/orgs/members/#check-membership
*/
type OrgsCheckMembershipReq struct {
	_url     string
	Org      string
	Username string
}

func (r *OrgsCheckMembershipReq) url() string {
	return r._url
}

func (r *OrgsCheckMembershipReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/members/%v", r.Org, r.Username)
}

func (r *OrgsCheckMembershipReq) method() string {
	return "GET"
}

func (r *OrgsCheckMembershipReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsCheckMembershipReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsCheckMembershipReq) body() interface{} {
	return nil
}

func (r *OrgsCheckMembershipReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsCheckMembershipReq) validStatuses() []int {
	return []int{204, 302}
}

func (r *OrgsCheckMembershipReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsCheckMembershipReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsCheckMembershipReq) Rel(link RelName, resp *OrgsCheckMembershipResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsCheckMembershipResponse is a response for OrgsCheckMembership

https://developer.github.com/v3/orgs/members/#check-membership
*/
type OrgsCheckMembershipResponse struct {
	response
	request *OrgsCheckMembershipReq
}

/*
OrgsCheckPublicMembership performs requests for "orgs/check-public-membership"

Check public membership.

  GET /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#check-public-membership
*/
func OrgsCheckPublicMembership(ctx context.Context, req *OrgsCheckPublicMembershipReq, opt ...RequestOption) (*OrgsCheckPublicMembershipResponse, error) {
	if req == nil {
		req = new(OrgsCheckPublicMembershipReq)
	}
	resp := &OrgsCheckPublicMembershipResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsCheckPublicMembership performs requests for "orgs/check-public-membership"

Check public membership.

  GET /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#check-public-membership
*/
func (c Client) OrgsCheckPublicMembership(ctx context.Context, req *OrgsCheckPublicMembershipReq, opt ...RequestOption) (*OrgsCheckPublicMembershipResponse, error) {
	return OrgsCheckPublicMembership(ctx, req, append(c, opt...)...)
}

/*
OrgsCheckPublicMembershipReq is request data for Client.OrgsCheckPublicMembership

https://developer.github.com/v3/orgs/members/#check-public-membership
*/
type OrgsCheckPublicMembershipReq struct {
	_url     string
	Org      string
	Username string
}

func (r *OrgsCheckPublicMembershipReq) url() string {
	return r._url
}

func (r *OrgsCheckPublicMembershipReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username)
}

func (r *OrgsCheckPublicMembershipReq) method() string {
	return "GET"
}

func (r *OrgsCheckPublicMembershipReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsCheckPublicMembershipReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsCheckPublicMembershipReq) body() interface{} {
	return nil
}

func (r *OrgsCheckPublicMembershipReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsCheckPublicMembershipReq) validStatuses() []int {
	return []int{204}
}

func (r *OrgsCheckPublicMembershipReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// HTTPRequest builds an *http.Request
func (r *OrgsCheckPublicMembershipReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsCheckPublicMembershipReq) Rel(link RelName, resp *OrgsCheckPublicMembershipResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsCheckPublicMembershipResponse is a response for OrgsCheckPublicMembership

https://developer.github.com/v3/orgs/members/#check-public-membership
*/
type OrgsCheckPublicMembershipResponse struct {
	response
	request *OrgsCheckPublicMembershipReq
	Data    bool
}

/*
OrgsConcealMembership performs requests for "orgs/conceal-membership"

Conceal a user's membership.

  DELETE /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#conceal-a-users-membership
*/
func OrgsConcealMembership(ctx context.Context, req *OrgsConcealMembershipReq, opt ...RequestOption) (*OrgsConcealMembershipResponse, error) {
	if req == nil {
		req = new(OrgsConcealMembershipReq)
	}
	resp := &OrgsConcealMembershipResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsConcealMembership performs requests for "orgs/conceal-membership"

Conceal a user's membership.

  DELETE /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#conceal-a-users-membership
*/
func (c Client) OrgsConcealMembership(ctx context.Context, req *OrgsConcealMembershipReq, opt ...RequestOption) (*OrgsConcealMembershipResponse, error) {
	return OrgsConcealMembership(ctx, req, append(c, opt...)...)
}

/*
OrgsConcealMembershipReq is request data for Client.OrgsConcealMembership

https://developer.github.com/v3/orgs/members/#conceal-a-users-membership
*/
type OrgsConcealMembershipReq struct {
	_url     string
	Org      string
	Username string
}

func (r *OrgsConcealMembershipReq) url() string {
	return r._url
}

func (r *OrgsConcealMembershipReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username)
}

func (r *OrgsConcealMembershipReq) method() string {
	return "DELETE"
}

func (r *OrgsConcealMembershipReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsConcealMembershipReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsConcealMembershipReq) body() interface{} {
	return nil
}

func (r *OrgsConcealMembershipReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsConcealMembershipReq) validStatuses() []int {
	return []int{204}
}

func (r *OrgsConcealMembershipReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsConcealMembershipReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsConcealMembershipReq) Rel(link RelName, resp *OrgsConcealMembershipResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsConcealMembershipResponse is a response for OrgsConcealMembership

https://developer.github.com/v3/orgs/members/#conceal-a-users-membership
*/
type OrgsConcealMembershipResponse struct {
	response
	request *OrgsConcealMembershipReq
}

/*
OrgsConvertMemberToOutsideCollaborator performs requests for "orgs/convert-member-to-outside-collaborator"

Convert member to outside collaborator.

  PUT /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#convert-member-to-outside-collaborator
*/
func OrgsConvertMemberToOutsideCollaborator(ctx context.Context, req *OrgsConvertMemberToOutsideCollaboratorReq, opt ...RequestOption) (*OrgsConvertMemberToOutsideCollaboratorResponse, error) {
	if req == nil {
		req = new(OrgsConvertMemberToOutsideCollaboratorReq)
	}
	resp := &OrgsConvertMemberToOutsideCollaboratorResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsConvertMemberToOutsideCollaborator performs requests for "orgs/convert-member-to-outside-collaborator"

Convert member to outside collaborator.

  PUT /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#convert-member-to-outside-collaborator
*/
func (c Client) OrgsConvertMemberToOutsideCollaborator(ctx context.Context, req *OrgsConvertMemberToOutsideCollaboratorReq, opt ...RequestOption) (*OrgsConvertMemberToOutsideCollaboratorResponse, error) {
	return OrgsConvertMemberToOutsideCollaborator(ctx, req, append(c, opt...)...)
}

/*
OrgsConvertMemberToOutsideCollaboratorReq is request data for Client.OrgsConvertMemberToOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#convert-member-to-outside-collaborator
*/
type OrgsConvertMemberToOutsideCollaboratorReq struct {
	_url     string
	Org      string
	Username string
}

func (r *OrgsConvertMemberToOutsideCollaboratorReq) url() string {
	return r._url
}

func (r *OrgsConvertMemberToOutsideCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/outside_collaborators/%v", r.Org, r.Username)
}

func (r *OrgsConvertMemberToOutsideCollaboratorReq) method() string {
	return "PUT"
}

func (r *OrgsConvertMemberToOutsideCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsConvertMemberToOutsideCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsConvertMemberToOutsideCollaboratorReq) body() interface{} {
	return nil
}

func (r *OrgsConvertMemberToOutsideCollaboratorReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsConvertMemberToOutsideCollaboratorReq) validStatuses() []int {
	return []int{204}
}

func (r *OrgsConvertMemberToOutsideCollaboratorReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsConvertMemberToOutsideCollaboratorReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsConvertMemberToOutsideCollaboratorReq) Rel(link RelName, resp *OrgsConvertMemberToOutsideCollaboratorResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsConvertMemberToOutsideCollaboratorResponse is a response for OrgsConvertMemberToOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#convert-member-to-outside-collaborator
*/
type OrgsConvertMemberToOutsideCollaboratorResponse struct {
	response
	request *OrgsConvertMemberToOutsideCollaboratorReq
}

/*
OrgsCreateHook performs requests for "orgs/create-hook"

Create a hook.

  POST /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#create-a-hook
*/
func OrgsCreateHook(ctx context.Context, req *OrgsCreateHookReq, opt ...RequestOption) (*OrgsCreateHookResponse, error) {
	if req == nil {
		req = new(OrgsCreateHookReq)
	}
	resp := &OrgsCreateHookResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsCreateHookResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsCreateHook performs requests for "orgs/create-hook"

Create a hook.

  POST /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#create-a-hook
*/
func (c Client) OrgsCreateHook(ctx context.Context, req *OrgsCreateHookReq, opt ...RequestOption) (*OrgsCreateHookResponse, error) {
	return OrgsCreateHook(ctx, req, append(c, opt...)...)
}

/*
OrgsCreateHookReq is request data for Client.OrgsCreateHook

https://developer.github.com/v3/orgs/hooks/#create-a-hook
*/
type OrgsCreateHookReq struct {
	_url        string
	Org         string
	RequestBody OrgsCreateHookReqBody
}

func (r *OrgsCreateHookReq) url() string {
	return r._url
}

func (r *OrgsCreateHookReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/hooks", r.Org)
}

func (r *OrgsCreateHookReq) method() string {
	return "POST"
}

func (r *OrgsCreateHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsCreateHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsCreateHookReq) body() interface{} {
	return r.RequestBody
}

func (r *OrgsCreateHookReq) dataStatuses() []int {
	return []int{201}
}

func (r *OrgsCreateHookReq) validStatuses() []int {
	return []int{201}
}

func (r *OrgsCreateHookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *OrgsCreateHookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsCreateHookReq) Rel(link RelName, resp *OrgsCreateHookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// OrgsCreateHookReqBodyConfig is a value for OrgsCreateHookReqBody's Config field
type OrgsCreateHookReqBodyConfig struct {

	/*
	   The media type used to serialize the payloads. Supported values include `json`
	   and `form`. The default is `form`.
	*/
	ContentType *string `json:"content_type,omitempty"`

	/*
	   Determines whether the SSL certificate of the host for `url` will be verified
	   when delivering payloads. Supported values include `0` (verification is
	   performed) and `1` (verification is not performed). The default is `0`. **We
	   strongly recommend not setting this to `1` as you are subject to
	   man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	   If provided, the `secret` will be used as the `key` to generate the HMAC hex
	   digest value in the
	   [`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	   header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
OrgsCreateHookReqBody is a request body for orgs/create-hook

https://developer.github.com/v3/orgs/hooks/#create-a-hook
*/
type OrgsCreateHookReqBody struct {

	/*
	   Determines if notifications are sent when the webhook is triggered. Set to
	   `true` to send notifications.
	*/
	Active *bool `json:"active,omitempty"`

	/*
	   Key/value pairs to provide settings for this webhook. [These are defined
	   below](https://developer.github.com/v3/orgs/hooks/#create-hook-config-params).
	*/
	Config *OrgsCreateHookReqBodyConfig `json:"config"`

	/*
	   Determines what [events](https://developer.github.com/webhooks/event-payloads)
	   the hook is triggered for.
	*/
	Events []string `json:"events,omitempty"`

	// Must be passed as "web".
	Name *string `json:"name"`
}

/*
OrgsCreateHookResponseBody is a response body for OrgsCreateHook

https://developer.github.com/v3/orgs/hooks/#create-a-hook
*/
type OrgsCreateHookResponseBody struct {
	components.OrgHook
}

/*
OrgsCreateHookResponse is a response for OrgsCreateHook

https://developer.github.com/v3/orgs/hooks/#create-a-hook
*/
type OrgsCreateHookResponse struct {
	response
	request *OrgsCreateHookReq
	Data    *OrgsCreateHookResponseBody
}

/*
OrgsCreateInvitation performs requests for "orgs/create-invitation"

Create organization invitation.

  POST /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#create-organization-invitation
*/
func OrgsCreateInvitation(ctx context.Context, req *OrgsCreateInvitationReq, opt ...RequestOption) (*OrgsCreateInvitationResponse, error) {
	if req == nil {
		req = new(OrgsCreateInvitationReq)
	}
	resp := &OrgsCreateInvitationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsCreateInvitationResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsCreateInvitation performs requests for "orgs/create-invitation"

Create organization invitation.

  POST /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#create-organization-invitation
*/
func (c Client) OrgsCreateInvitation(ctx context.Context, req *OrgsCreateInvitationReq, opt ...RequestOption) (*OrgsCreateInvitationResponse, error) {
	return OrgsCreateInvitation(ctx, req, append(c, opt...)...)
}

/*
OrgsCreateInvitationReq is request data for Client.OrgsCreateInvitation

https://developer.github.com/v3/orgs/members/#create-organization-invitation
*/
type OrgsCreateInvitationReq struct {
	_url        string
	Org         string
	RequestBody OrgsCreateInvitationReqBody
}

func (r *OrgsCreateInvitationReq) url() string {
	return r._url
}

func (r *OrgsCreateInvitationReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/invitations", r.Org)
}

func (r *OrgsCreateInvitationReq) method() string {
	return "POST"
}

func (r *OrgsCreateInvitationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsCreateInvitationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsCreateInvitationReq) body() interface{} {
	return r.RequestBody
}

func (r *OrgsCreateInvitationReq) dataStatuses() []int {
	return []int{201}
}

func (r *OrgsCreateInvitationReq) validStatuses() []int {
	return []int{201}
}

func (r *OrgsCreateInvitationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *OrgsCreateInvitationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsCreateInvitationReq) Rel(link RelName, resp *OrgsCreateInvitationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsCreateInvitationReqBody is a request body for orgs/create-invitation

https://developer.github.com/v3/orgs/members/#create-organization-invitation
*/
type OrgsCreateInvitationReqBody struct {

	/*
	   **Required unless you provide `invitee_id`**. Email address of the person you
	   are inviting, which can be an existing GitHub user.
	*/
	Email *string `json:"email,omitempty"`

	/*
	   **Required unless you provide `email`**. GitHub user ID for the person you are
	   inviting.
	*/
	InviteeId *int64 `json:"invitee_id,omitempty"`

	/*
	   Specify role for new member. Can be one of:
	   \* `admin` - Organization owners with full administrative rights to the
	   organization and complete access to all repositories and teams.
	   \* `direct_member` - Non-owner organization members with ability to see other
	   members and join teams by invitation.
	   \* `billing_manager` - Non-owner organization members with ability to manage the
	   billing settings of your organization.
	*/
	Role *string `json:"role,omitempty"`

	// Specify IDs for the teams you want to invite new members to.
	TeamIds []int64 `json:"team_ids,omitempty"`
}

/*
OrgsCreateInvitationResponseBody is a response body for OrgsCreateInvitation

https://developer.github.com/v3/orgs/members/#create-organization-invitation
*/
type OrgsCreateInvitationResponseBody struct {
	components.OrganizationInvitation
}

/*
OrgsCreateInvitationResponse is a response for OrgsCreateInvitation

https://developer.github.com/v3/orgs/members/#create-organization-invitation
*/
type OrgsCreateInvitationResponse struct {
	response
	request *OrgsCreateInvitationReq
	Data    *OrgsCreateInvitationResponseBody
}

/*
OrgsDeleteHook performs requests for "orgs/delete-hook"

Delete a hook.

  DELETE /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#delete-a-hook
*/
func OrgsDeleteHook(ctx context.Context, req *OrgsDeleteHookReq, opt ...RequestOption) (*OrgsDeleteHookResponse, error) {
	if req == nil {
		req = new(OrgsDeleteHookReq)
	}
	resp := &OrgsDeleteHookResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsDeleteHook performs requests for "orgs/delete-hook"

Delete a hook.

  DELETE /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#delete-a-hook
*/
func (c Client) OrgsDeleteHook(ctx context.Context, req *OrgsDeleteHookReq, opt ...RequestOption) (*OrgsDeleteHookResponse, error) {
	return OrgsDeleteHook(ctx, req, append(c, opt...)...)
}

/*
OrgsDeleteHookReq is request data for Client.OrgsDeleteHook

https://developer.github.com/v3/orgs/hooks/#delete-a-hook
*/
type OrgsDeleteHookReq struct {
	_url   string
	Org    string
	HookId int64
}

func (r *OrgsDeleteHookReq) url() string {
	return r._url
}

func (r *OrgsDeleteHookReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId)
}

func (r *OrgsDeleteHookReq) method() string {
	return "DELETE"
}

func (r *OrgsDeleteHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsDeleteHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsDeleteHookReq) body() interface{} {
	return nil
}

func (r *OrgsDeleteHookReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsDeleteHookReq) validStatuses() []int {
	return []int{204}
}

func (r *OrgsDeleteHookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsDeleteHookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsDeleteHookReq) Rel(link RelName, resp *OrgsDeleteHookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsDeleteHookResponse is a response for OrgsDeleteHook

https://developer.github.com/v3/orgs/hooks/#delete-a-hook
*/
type OrgsDeleteHookResponse struct {
	response
	request *OrgsDeleteHookReq
}

/*
OrgsGet performs requests for "orgs/get"

Get an organization.

  GET /orgs/{org}

https://developer.github.com/v3/orgs/#get-an-organization
*/
func OrgsGet(ctx context.Context, req *OrgsGetReq, opt ...RequestOption) (*OrgsGetResponse, error) {
	if req == nil {
		req = new(OrgsGetReq)
	}
	resp := &OrgsGetResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsGetResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsGet performs requests for "orgs/get"

Get an organization.

  GET /orgs/{org}

https://developer.github.com/v3/orgs/#get-an-organization
*/
func (c Client) OrgsGet(ctx context.Context, req *OrgsGetReq, opt ...RequestOption) (*OrgsGetResponse, error) {
	return OrgsGet(ctx, req, append(c, opt...)...)
}

/*
OrgsGetReq is request data for Client.OrgsGet

https://developer.github.com/v3/orgs/#get-an-organization
*/
type OrgsGetReq struct {
	_url string
	Org  string

	/*
	New repository creation permissions are available to preview. You can now use
	`members_can_create_public_repositories`,
	`members_can_create_private_repositories`, and
	`members_can_create_internal_repositories`. You can only allow members to create
	internal repositories if your organization is associated with an enterprise
	account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. These
	parameters provide more granular permissions to configure the type of
	repositories organization members can create.

	To access these new parameters during the preview period, you must set this to
	true.
	*/
	SurturPreview bool
}

func (r *OrgsGetReq) url() string {
	return r._url
}

func (r *OrgsGetReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v", r.Org)
}

func (r *OrgsGetReq) method() string {
	return "GET"
}

func (r *OrgsGetReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsGetReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"surtur": r.SurturPreview}
	if allPreviews {
		previewVals["surtur"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsGetReq) body() interface{} {
	return nil
}

func (r *OrgsGetReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsGetReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsGetReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsGetReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsGetReq) Rel(link RelName, resp *OrgsGetResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsGetResponseBody is a response body for OrgsGet

https://developer.github.com/v3/orgs/#get-an-organization
*/
type OrgsGetResponseBody struct {
	components.OrganizationFull
}

/*
OrgsGetResponse is a response for OrgsGet

https://developer.github.com/v3/orgs/#get-an-organization
*/
type OrgsGetResponse struct {
	response
	request *OrgsGetReq
	Data    *OrgsGetResponseBody
}

/*
OrgsGetHook performs requests for "orgs/get-hook"

Get single hook.

  GET /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#get-single-hook
*/
func OrgsGetHook(ctx context.Context, req *OrgsGetHookReq, opt ...RequestOption) (*OrgsGetHookResponse, error) {
	if req == nil {
		req = new(OrgsGetHookReq)
	}
	resp := &OrgsGetHookResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsGetHookResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsGetHook performs requests for "orgs/get-hook"

Get single hook.

  GET /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#get-single-hook
*/
func (c Client) OrgsGetHook(ctx context.Context, req *OrgsGetHookReq, opt ...RequestOption) (*OrgsGetHookResponse, error) {
	return OrgsGetHook(ctx, req, append(c, opt...)...)
}

/*
OrgsGetHookReq is request data for Client.OrgsGetHook

https://developer.github.com/v3/orgs/hooks/#get-single-hook
*/
type OrgsGetHookReq struct {
	_url   string
	Org    string
	HookId int64
}

func (r *OrgsGetHookReq) url() string {
	return r._url
}

func (r *OrgsGetHookReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId)
}

func (r *OrgsGetHookReq) method() string {
	return "GET"
}

func (r *OrgsGetHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsGetHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsGetHookReq) body() interface{} {
	return nil
}

func (r *OrgsGetHookReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsGetHookReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsGetHookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsGetHookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsGetHookReq) Rel(link RelName, resp *OrgsGetHookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsGetHookResponseBody is a response body for OrgsGetHook

https://developer.github.com/v3/orgs/hooks/#get-single-hook
*/
type OrgsGetHookResponseBody struct {
	components.OrgHook
}

/*
OrgsGetHookResponse is a response for OrgsGetHook

https://developer.github.com/v3/orgs/hooks/#get-single-hook
*/
type OrgsGetHookResponse struct {
	response
	request *OrgsGetHookReq
	Data    *OrgsGetHookResponseBody
}

/*
OrgsGetMembership performs requests for "orgs/get-membership"

Get organization membership.

  GET /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#get-organization-membership
*/
func OrgsGetMembership(ctx context.Context, req *OrgsGetMembershipReq, opt ...RequestOption) (*OrgsGetMembershipResponse, error) {
	if req == nil {
		req = new(OrgsGetMembershipReq)
	}
	resp := &OrgsGetMembershipResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsGetMembershipResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsGetMembership performs requests for "orgs/get-membership"

Get organization membership.

  GET /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#get-organization-membership
*/
func (c Client) OrgsGetMembership(ctx context.Context, req *OrgsGetMembershipReq, opt ...RequestOption) (*OrgsGetMembershipResponse, error) {
	return OrgsGetMembership(ctx, req, append(c, opt...)...)
}

/*
OrgsGetMembershipReq is request data for Client.OrgsGetMembership

https://developer.github.com/v3/orgs/members/#get-organization-membership
*/
type OrgsGetMembershipReq struct {
	_url     string
	Org      string
	Username string
}

func (r *OrgsGetMembershipReq) url() string {
	return r._url
}

func (r *OrgsGetMembershipReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username)
}

func (r *OrgsGetMembershipReq) method() string {
	return "GET"
}

func (r *OrgsGetMembershipReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsGetMembershipReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsGetMembershipReq) body() interface{} {
	return nil
}

func (r *OrgsGetMembershipReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsGetMembershipReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsGetMembershipReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsGetMembershipReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsGetMembershipReq) Rel(link RelName, resp *OrgsGetMembershipResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsGetMembershipResponseBody is a response body for OrgsGetMembership

https://developer.github.com/v3/orgs/members/#get-organization-membership
*/
type OrgsGetMembershipResponseBody struct {
	components.OrgMembership
}

/*
OrgsGetMembershipResponse is a response for OrgsGetMembership

https://developer.github.com/v3/orgs/members/#get-organization-membership
*/
type OrgsGetMembershipResponse struct {
	response
	request *OrgsGetMembershipReq
	Data    *OrgsGetMembershipResponseBody
}

/*
OrgsGetMembershipForAuthenticatedUser performs requests for "orgs/get-membership-for-authenticated-user"

Get your organization membership.

  GET /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#get-your-organization-membership
*/
func OrgsGetMembershipForAuthenticatedUser(ctx context.Context, req *OrgsGetMembershipForAuthenticatedUserReq, opt ...RequestOption) (*OrgsGetMembershipForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(OrgsGetMembershipForAuthenticatedUserReq)
	}
	resp := &OrgsGetMembershipForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsGetMembershipForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsGetMembershipForAuthenticatedUser performs requests for "orgs/get-membership-for-authenticated-user"

Get your organization membership.

  GET /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#get-your-organization-membership
*/
func (c Client) OrgsGetMembershipForAuthenticatedUser(ctx context.Context, req *OrgsGetMembershipForAuthenticatedUserReq, opt ...RequestOption) (*OrgsGetMembershipForAuthenticatedUserResponse, error) {
	return OrgsGetMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
OrgsGetMembershipForAuthenticatedUserReq is request data for Client.OrgsGetMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#get-your-organization-membership
*/
type OrgsGetMembershipForAuthenticatedUserReq struct {
	_url string
	Org  string
}

func (r *OrgsGetMembershipForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *OrgsGetMembershipForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/memberships/orgs/%v", r.Org)
}

func (r *OrgsGetMembershipForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *OrgsGetMembershipForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsGetMembershipForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsGetMembershipForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *OrgsGetMembershipForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsGetMembershipForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsGetMembershipForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsGetMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsGetMembershipForAuthenticatedUserReq) Rel(link RelName, resp *OrgsGetMembershipForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsGetMembershipForAuthenticatedUserResponseBody is a response body for OrgsGetMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#get-your-organization-membership
*/
type OrgsGetMembershipForAuthenticatedUserResponseBody struct {
	components.OrgMembership
}

/*
OrgsGetMembershipForAuthenticatedUserResponse is a response for OrgsGetMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#get-your-organization-membership
*/
type OrgsGetMembershipForAuthenticatedUserResponse struct {
	response
	request *OrgsGetMembershipForAuthenticatedUserReq
	Data    *OrgsGetMembershipForAuthenticatedUserResponseBody
}

/*
OrgsList performs requests for "orgs/list"

List all organizations.

  GET /organizations

https://developer.github.com/v3/orgs/#list-all-organizations
*/
func OrgsList(ctx context.Context, req *OrgsListReq, opt ...RequestOption) (*OrgsListResponse, error) {
	if req == nil {
		req = new(OrgsListReq)
	}
	resp := &OrgsListResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsListResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsList performs requests for "orgs/list"

List all organizations.

  GET /organizations

https://developer.github.com/v3/orgs/#list-all-organizations
*/
func (c Client) OrgsList(ctx context.Context, req *OrgsListReq, opt ...RequestOption) (*OrgsListResponse, error) {
	return OrgsList(ctx, req, append(c, opt...)...)
}

/*
OrgsListReq is request data for Client.OrgsList

https://developer.github.com/v3/orgs/#list-all-organizations
*/
type OrgsListReq struct {
	_url string

	// The integer ID of the last organization that you've seen.
	Since *int64
}

func (r *OrgsListReq) url() string {
	return r._url
}

func (r *OrgsListReq) urlPath() string {
	return fmt.Sprintf("/organizations")
}

func (r *OrgsListReq) method() string {
	return "GET"
}

func (r *OrgsListReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", strconv.FormatInt(*r.Since, 10))
	}
	return query
}

func (r *OrgsListReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsListReq) body() interface{} {
	return nil
}

func (r *OrgsListReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsListReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsListReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsListReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListReq) Rel(link RelName, resp *OrgsListResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListResponseBody is a response body for OrgsList

https://developer.github.com/v3/orgs/#list-all-organizations
*/
type OrgsListResponseBody []struct {
	components.OrganizationSimple
}

/*
OrgsListResponse is a response for OrgsList

https://developer.github.com/v3/orgs/#list-all-organizations
*/
type OrgsListResponse struct {
	response
	request *OrgsListReq
	Data    *OrgsListResponseBody
}

/*
OrgsListBlockedUsers performs requests for "orgs/list-blocked-users"

List blocked users.

  GET /orgs/{org}/blocks

https://developer.github.com/v3/orgs/blocking/#list-blocked-users
*/
func OrgsListBlockedUsers(ctx context.Context, req *OrgsListBlockedUsersReq, opt ...RequestOption) (*OrgsListBlockedUsersResponse, error) {
	if req == nil {
		req = new(OrgsListBlockedUsersReq)
	}
	resp := &OrgsListBlockedUsersResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsListBlockedUsersResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListBlockedUsers performs requests for "orgs/list-blocked-users"

List blocked users.

  GET /orgs/{org}/blocks

https://developer.github.com/v3/orgs/blocking/#list-blocked-users
*/
func (c Client) OrgsListBlockedUsers(ctx context.Context, req *OrgsListBlockedUsersReq, opt ...RequestOption) (*OrgsListBlockedUsersResponse, error) {
	return OrgsListBlockedUsers(ctx, req, append(c, opt...)...)
}

/*
OrgsListBlockedUsersReq is request data for Client.OrgsListBlockedUsers

https://developer.github.com/v3/orgs/blocking/#list-blocked-users
*/
type OrgsListBlockedUsersReq struct {
	_url string
	Org  string
}

func (r *OrgsListBlockedUsersReq) url() string {
	return r._url
}

func (r *OrgsListBlockedUsersReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/blocks", r.Org)
}

func (r *OrgsListBlockedUsersReq) method() string {
	return "GET"
}

func (r *OrgsListBlockedUsersReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsListBlockedUsersReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsListBlockedUsersReq) body() interface{} {
	return nil
}

func (r *OrgsListBlockedUsersReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsListBlockedUsersReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsListBlockedUsersReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsListBlockedUsersReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListBlockedUsersReq) Rel(link RelName, resp *OrgsListBlockedUsersResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListBlockedUsersResponseBody is a response body for OrgsListBlockedUsers

https://developer.github.com/v3/orgs/blocking/#list-blocked-users
*/
type OrgsListBlockedUsersResponseBody []struct {
	components.SimpleUser
}

/*
OrgsListBlockedUsersResponse is a response for OrgsListBlockedUsers

https://developer.github.com/v3/orgs/blocking/#list-blocked-users
*/
type OrgsListBlockedUsersResponse struct {
	response
	request *OrgsListBlockedUsersReq
	Data    *OrgsListBlockedUsersResponseBody
}

/*
OrgsListCredentialAuthorizations performs requests for "orgs/list-credential-authorizations"

List credential authorizations for an organization.

  GET /orgs/{org}/credential-authorizations

https://developer.github.com/v3/orgs/#list-credential-authorizations-for-an-organization
*/
func OrgsListCredentialAuthorizations(ctx context.Context, req *OrgsListCredentialAuthorizationsReq, opt ...RequestOption) (*OrgsListCredentialAuthorizationsResponse, error) {
	if req == nil {
		req = new(OrgsListCredentialAuthorizationsReq)
	}
	resp := &OrgsListCredentialAuthorizationsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsListCredentialAuthorizationsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListCredentialAuthorizations performs requests for "orgs/list-credential-authorizations"

List credential authorizations for an organization.

  GET /orgs/{org}/credential-authorizations

https://developer.github.com/v3/orgs/#list-credential-authorizations-for-an-organization
*/
func (c Client) OrgsListCredentialAuthorizations(ctx context.Context, req *OrgsListCredentialAuthorizationsReq, opt ...RequestOption) (*OrgsListCredentialAuthorizationsResponse, error) {
	return OrgsListCredentialAuthorizations(ctx, req, append(c, opt...)...)
}

/*
OrgsListCredentialAuthorizationsReq is request data for Client.OrgsListCredentialAuthorizations

https://developer.github.com/v3/orgs/#list-credential-authorizations-for-an-organization
*/
type OrgsListCredentialAuthorizationsReq struct {
	_url string
	Org  string
}

func (r *OrgsListCredentialAuthorizationsReq) url() string {
	return r._url
}

func (r *OrgsListCredentialAuthorizationsReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/credential-authorizations", r.Org)
}

func (r *OrgsListCredentialAuthorizationsReq) method() string {
	return "GET"
}

func (r *OrgsListCredentialAuthorizationsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsListCredentialAuthorizationsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsListCredentialAuthorizationsReq) body() interface{} {
	return nil
}

func (r *OrgsListCredentialAuthorizationsReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsListCredentialAuthorizationsReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsListCredentialAuthorizationsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsListCredentialAuthorizationsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListCredentialAuthorizationsReq) Rel(link RelName, resp *OrgsListCredentialAuthorizationsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListCredentialAuthorizationsResponseBody is a response body for OrgsListCredentialAuthorizations

https://developer.github.com/v3/orgs/#list-credential-authorizations-for-an-organization
*/
type OrgsListCredentialAuthorizationsResponseBody []struct {
	components.CredentialAuthorization
}

/*
OrgsListCredentialAuthorizationsResponse is a response for OrgsListCredentialAuthorizations

https://developer.github.com/v3/orgs/#list-credential-authorizations-for-an-organization
*/
type OrgsListCredentialAuthorizationsResponse struct {
	response
	request *OrgsListCredentialAuthorizationsReq
	Data    *OrgsListCredentialAuthorizationsResponseBody
}

/*
OrgsListForAuthenticatedUser performs requests for "orgs/list-for-authenticated-user"

List your organizations.

  GET /user/orgs

https://developer.github.com/v3/orgs/#list-your-organizations
*/
func OrgsListForAuthenticatedUser(ctx context.Context, req *OrgsListForAuthenticatedUserReq, opt ...RequestOption) (*OrgsListForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(OrgsListForAuthenticatedUserReq)
	}
	resp := &OrgsListForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsListForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListForAuthenticatedUser performs requests for "orgs/list-for-authenticated-user"

List your organizations.

  GET /user/orgs

https://developer.github.com/v3/orgs/#list-your-organizations
*/
func (c Client) OrgsListForAuthenticatedUser(ctx context.Context, req *OrgsListForAuthenticatedUserReq, opt ...RequestOption) (*OrgsListForAuthenticatedUserResponse, error) {
	return OrgsListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
OrgsListForAuthenticatedUserReq is request data for Client.OrgsListForAuthenticatedUser

https://developer.github.com/v3/orgs/#list-your-organizations
*/
type OrgsListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *OrgsListForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *OrgsListForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/orgs")
}

func (r *OrgsListForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *OrgsListForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *OrgsListForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsListForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *OrgsListForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsListForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsListForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListForAuthenticatedUserReq) Rel(link RelName, resp *OrgsListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListForAuthenticatedUserResponseBody is a response body for OrgsListForAuthenticatedUser

https://developer.github.com/v3/orgs/#list-your-organizations
*/
type OrgsListForAuthenticatedUserResponseBody []struct {
	components.OrganizationSimple
}

/*
OrgsListForAuthenticatedUserResponse is a response for OrgsListForAuthenticatedUser

https://developer.github.com/v3/orgs/#list-your-organizations
*/
type OrgsListForAuthenticatedUserResponse struct {
	response
	request *OrgsListForAuthenticatedUserReq
	Data    *OrgsListForAuthenticatedUserResponseBody
}

/*
OrgsListForUser performs requests for "orgs/list-for-user"

List user organizations.

  GET /users/{username}/orgs

https://developer.github.com/v3/orgs/#list-user-organizations
*/
func OrgsListForUser(ctx context.Context, req *OrgsListForUserReq, opt ...RequestOption) (*OrgsListForUserResponse, error) {
	if req == nil {
		req = new(OrgsListForUserReq)
	}
	resp := &OrgsListForUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsListForUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListForUser performs requests for "orgs/list-for-user"

List user organizations.

  GET /users/{username}/orgs

https://developer.github.com/v3/orgs/#list-user-organizations
*/
func (c Client) OrgsListForUser(ctx context.Context, req *OrgsListForUserReq, opt ...RequestOption) (*OrgsListForUserResponse, error) {
	return OrgsListForUser(ctx, req, append(c, opt...)...)
}

/*
OrgsListForUserReq is request data for Client.OrgsListForUser

https://developer.github.com/v3/orgs/#list-user-organizations
*/
type OrgsListForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *OrgsListForUserReq) url() string {
	return r._url
}

func (r *OrgsListForUserReq) urlPath() string {
	return fmt.Sprintf("/users/%v/orgs", r.Username)
}

func (r *OrgsListForUserReq) method() string {
	return "GET"
}

func (r *OrgsListForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *OrgsListForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsListForUserReq) body() interface{} {
	return nil
}

func (r *OrgsListForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsListForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsListForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsListForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListForUserReq) Rel(link RelName, resp *OrgsListForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListForUserResponseBody is a response body for OrgsListForUser

https://developer.github.com/v3/orgs/#list-user-organizations
*/
type OrgsListForUserResponseBody []struct {
	components.OrganizationSimple
}

/*
OrgsListForUserResponse is a response for OrgsListForUser

https://developer.github.com/v3/orgs/#list-user-organizations
*/
type OrgsListForUserResponse struct {
	response
	request *OrgsListForUserReq
	Data    *OrgsListForUserResponseBody
}

/*
OrgsListHooks performs requests for "orgs/list-hooks"

List hooks.

  GET /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#list-hooks
*/
func OrgsListHooks(ctx context.Context, req *OrgsListHooksReq, opt ...RequestOption) (*OrgsListHooksResponse, error) {
	if req == nil {
		req = new(OrgsListHooksReq)
	}
	resp := &OrgsListHooksResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsListHooksResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListHooks performs requests for "orgs/list-hooks"

List hooks.

  GET /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#list-hooks
*/
func (c Client) OrgsListHooks(ctx context.Context, req *OrgsListHooksReq, opt ...RequestOption) (*OrgsListHooksResponse, error) {
	return OrgsListHooks(ctx, req, append(c, opt...)...)
}

/*
OrgsListHooksReq is request data for Client.OrgsListHooks

https://developer.github.com/v3/orgs/hooks/#list-hooks
*/
type OrgsListHooksReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *OrgsListHooksReq) url() string {
	return r._url
}

func (r *OrgsListHooksReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/hooks", r.Org)
}

func (r *OrgsListHooksReq) method() string {
	return "GET"
}

func (r *OrgsListHooksReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *OrgsListHooksReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsListHooksReq) body() interface{} {
	return nil
}

func (r *OrgsListHooksReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsListHooksReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsListHooksReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsListHooksReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListHooksReq) Rel(link RelName, resp *OrgsListHooksResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListHooksResponseBody is a response body for OrgsListHooks

https://developer.github.com/v3/orgs/hooks/#list-hooks
*/
type OrgsListHooksResponseBody []struct {
	components.OrgHook
}

/*
OrgsListHooksResponse is a response for OrgsListHooks

https://developer.github.com/v3/orgs/hooks/#list-hooks
*/
type OrgsListHooksResponse struct {
	response
	request *OrgsListHooksReq
	Data    *OrgsListHooksResponseBody
}

/*
OrgsListInstallations performs requests for "orgs/list-installations"

List installations for an organization.

  GET /orgs/{org}/installations

https://developer.github.com/v3/orgs/#list-installations-for-an-organization
*/
func OrgsListInstallations(ctx context.Context, req *OrgsListInstallationsReq, opt ...RequestOption) (*OrgsListInstallationsResponse, error) {
	if req == nil {
		req = new(OrgsListInstallationsReq)
	}
	resp := &OrgsListInstallationsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsListInstallationsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListInstallations performs requests for "orgs/list-installations"

List installations for an organization.

  GET /orgs/{org}/installations

https://developer.github.com/v3/orgs/#list-installations-for-an-organization
*/
func (c Client) OrgsListInstallations(ctx context.Context, req *OrgsListInstallationsReq, opt ...RequestOption) (*OrgsListInstallationsResponse, error) {
	return OrgsListInstallations(ctx, req, append(c, opt...)...)
}

/*
OrgsListInstallationsReq is request data for Client.OrgsListInstallations

https://developer.github.com/v3/orgs/#list-installations-for-an-organization
*/
type OrgsListInstallationsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

func (r *OrgsListInstallationsReq) url() string {
	return r._url
}

func (r *OrgsListInstallationsReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/installations", r.Org)
}

func (r *OrgsListInstallationsReq) method() string {
	return "GET"
}

func (r *OrgsListInstallationsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *OrgsListInstallationsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"machine-man": r.MachineManPreview}
	if requiredPreviews {
		previewVals["machine-man"] = true
	}
	if allPreviews {
		previewVals["machine-man"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsListInstallationsReq) body() interface{} {
	return nil
}

func (r *OrgsListInstallationsReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsListInstallationsReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsListInstallationsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsListInstallationsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListInstallationsReq) Rel(link RelName, resp *OrgsListInstallationsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListInstallationsResponseBody is a response body for OrgsListInstallations

https://developer.github.com/v3/orgs/#list-installations-for-an-organization
*/
type OrgsListInstallationsResponseBody struct {
	Installations []struct {
		components.Installation3
	} `json:"installations,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
OrgsListInstallationsResponse is a response for OrgsListInstallations

https://developer.github.com/v3/orgs/#list-installations-for-an-organization
*/
type OrgsListInstallationsResponse struct {
	response
	request *OrgsListInstallationsReq
	Data    *OrgsListInstallationsResponseBody
}

/*
OrgsListInvitationTeams performs requests for "orgs/list-invitation-teams"

List organization invitation teams.

  GET /orgs/{org}/invitations/{invitation_id}/teams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
func OrgsListInvitationTeams(ctx context.Context, req *OrgsListInvitationTeamsReq, opt ...RequestOption) (*OrgsListInvitationTeamsResponse, error) {
	if req == nil {
		req = new(OrgsListInvitationTeamsReq)
	}
	resp := &OrgsListInvitationTeamsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsListInvitationTeamsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListInvitationTeams performs requests for "orgs/list-invitation-teams"

List organization invitation teams.

  GET /orgs/{org}/invitations/{invitation_id}/teams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
func (c Client) OrgsListInvitationTeams(ctx context.Context, req *OrgsListInvitationTeamsReq, opt ...RequestOption) (*OrgsListInvitationTeamsResponse, error) {
	return OrgsListInvitationTeams(ctx, req, append(c, opt...)...)
}

/*
OrgsListInvitationTeamsReq is request data for Client.OrgsListInvitationTeams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
type OrgsListInvitationTeamsReq struct {
	_url         string
	Org          string
	InvitationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *OrgsListInvitationTeamsReq) url() string {
	return r._url
}

func (r *OrgsListInvitationTeamsReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/invitations/%v/teams", r.Org, r.InvitationId)
}

func (r *OrgsListInvitationTeamsReq) method() string {
	return "GET"
}

func (r *OrgsListInvitationTeamsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *OrgsListInvitationTeamsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsListInvitationTeamsReq) body() interface{} {
	return nil
}

func (r *OrgsListInvitationTeamsReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsListInvitationTeamsReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsListInvitationTeamsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsListInvitationTeamsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListInvitationTeamsReq) Rel(link RelName, resp *OrgsListInvitationTeamsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListInvitationTeamsResponseBody is a response body for OrgsListInvitationTeams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
type OrgsListInvitationTeamsResponseBody []struct {
	components.Team
}

/*
OrgsListInvitationTeamsResponse is a response for OrgsListInvitationTeams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
type OrgsListInvitationTeamsResponse struct {
	response
	request *OrgsListInvitationTeamsReq
	Data    *OrgsListInvitationTeamsResponseBody
}

/*
OrgsListMembers performs requests for "orgs/list-members"

Members list.

  GET /orgs/{org}/members

https://developer.github.com/v3/orgs/members/#members-list
*/
func OrgsListMembers(ctx context.Context, req *OrgsListMembersReq, opt ...RequestOption) (*OrgsListMembersResponse, error) {
	if req == nil {
		req = new(OrgsListMembersReq)
	}
	resp := &OrgsListMembersResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsListMembersResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListMembers performs requests for "orgs/list-members"

Members list.

  GET /orgs/{org}/members

https://developer.github.com/v3/orgs/members/#members-list
*/
func (c Client) OrgsListMembers(ctx context.Context, req *OrgsListMembersReq, opt ...RequestOption) (*OrgsListMembersResponse, error) {
	return OrgsListMembers(ctx, req, append(c, opt...)...)
}

/*
OrgsListMembersReq is request data for Client.OrgsListMembers

https://developer.github.com/v3/orgs/members/#members-list
*/
type OrgsListMembersReq struct {
	_url string
	Org  string

	/*
	Filter members returned in the list. Can be one of:
	\* `2fa_disabled` - Members without [two-factor
	authentication](https://github.com/blog/1614-two-factor-authentication) enabled.
	Available for organization owners.
	\* `all` - All members the authenticated user can see.
	*/
	Filter *string

	/*
	Filter members returned by their role. Can be one of:
	\* `all` - All members of the organization, regardless of role.
	\* `admin` - Organization owners.
	\* `member` - Non-owner organization members.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *OrgsListMembersReq) url() string {
	return r._url
}

func (r *OrgsListMembersReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/members", r.Org)
}

func (r *OrgsListMembersReq) method() string {
	return "GET"
}

func (r *OrgsListMembersReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *OrgsListMembersReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsListMembersReq) body() interface{} {
	return nil
}

func (r *OrgsListMembersReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsListMembersReq) validStatuses() []int {
	return []int{200, 302}
}

func (r *OrgsListMembersReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsListMembersReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListMembersReq) Rel(link RelName, resp *OrgsListMembersResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListMembersResponseBody is a response body for OrgsListMembers

https://developer.github.com/v3/orgs/members/#members-list
*/
type OrgsListMembersResponseBody []struct {
	components.SimpleUser
}

/*
OrgsListMembersResponse is a response for OrgsListMembers

https://developer.github.com/v3/orgs/members/#members-list
*/
type OrgsListMembersResponse struct {
	response
	request *OrgsListMembersReq
	Data    *OrgsListMembersResponseBody
}

/*
OrgsListMemberships performs requests for "orgs/list-memberships"

List your organization memberships.

  GET /user/memberships/orgs

https://developer.github.com/v3/orgs/members/#list-your-organization-memberships
*/
func OrgsListMemberships(ctx context.Context, req *OrgsListMembershipsReq, opt ...RequestOption) (*OrgsListMembershipsResponse, error) {
	if req == nil {
		req = new(OrgsListMembershipsReq)
	}
	resp := &OrgsListMembershipsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsListMembershipsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListMemberships performs requests for "orgs/list-memberships"

List your organization memberships.

  GET /user/memberships/orgs

https://developer.github.com/v3/orgs/members/#list-your-organization-memberships
*/
func (c Client) OrgsListMemberships(ctx context.Context, req *OrgsListMembershipsReq, opt ...RequestOption) (*OrgsListMembershipsResponse, error) {
	return OrgsListMemberships(ctx, req, append(c, opt...)...)
}

/*
OrgsListMembershipsReq is request data for Client.OrgsListMemberships

https://developer.github.com/v3/orgs/members/#list-your-organization-memberships
*/
type OrgsListMembershipsReq struct {
	_url string

	/*
	Indicates the state of the memberships to return. Can be either `active` or
	`pending`. If not specified, the API returns both active and pending
	memberships.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *OrgsListMembershipsReq) url() string {
	return r._url
}

func (r *OrgsListMembershipsReq) urlPath() string {
	return fmt.Sprintf("/user/memberships/orgs")
}

func (r *OrgsListMembershipsReq) method() string {
	return "GET"
}

func (r *OrgsListMembershipsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *OrgsListMembershipsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsListMembershipsReq) body() interface{} {
	return nil
}

func (r *OrgsListMembershipsReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsListMembershipsReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsListMembershipsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsListMembershipsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListMembershipsReq) Rel(link RelName, resp *OrgsListMembershipsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListMembershipsResponseBody is a response body for OrgsListMemberships

https://developer.github.com/v3/orgs/members/#list-your-organization-memberships
*/
type OrgsListMembershipsResponseBody []struct {
	components.OrgMembership
}

/*
OrgsListMembershipsResponse is a response for OrgsListMemberships

https://developer.github.com/v3/orgs/members/#list-your-organization-memberships
*/
type OrgsListMembershipsResponse struct {
	response
	request *OrgsListMembershipsReq
	Data    *OrgsListMembershipsResponseBody
}

/*
OrgsListOutsideCollaborators performs requests for "orgs/list-outside-collaborators"

List outside collaborators.

  GET /orgs/{org}/outside_collaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators
*/
func OrgsListOutsideCollaborators(ctx context.Context, req *OrgsListOutsideCollaboratorsReq, opt ...RequestOption) (*OrgsListOutsideCollaboratorsResponse, error) {
	if req == nil {
		req = new(OrgsListOutsideCollaboratorsReq)
	}
	resp := &OrgsListOutsideCollaboratorsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsListOutsideCollaboratorsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListOutsideCollaborators performs requests for "orgs/list-outside-collaborators"

List outside collaborators.

  GET /orgs/{org}/outside_collaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators
*/
func (c Client) OrgsListOutsideCollaborators(ctx context.Context, req *OrgsListOutsideCollaboratorsReq, opt ...RequestOption) (*OrgsListOutsideCollaboratorsResponse, error) {
	return OrgsListOutsideCollaborators(ctx, req, append(c, opt...)...)
}

/*
OrgsListOutsideCollaboratorsReq is request data for Client.OrgsListOutsideCollaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators
*/
type OrgsListOutsideCollaboratorsReq struct {
	_url string
	Org  string

	/*
	Filter the list of outside collaborators. Can be one of:
	\* `2fa_disabled`: Outside collaborators without [two-factor
	authentication](https://github.com/blog/1614-two-factor-authentication) enabled.
	\* `all`: All outside collaborators.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *OrgsListOutsideCollaboratorsReq) url() string {
	return r._url
}

func (r *OrgsListOutsideCollaboratorsReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/outside_collaborators", r.Org)
}

func (r *OrgsListOutsideCollaboratorsReq) method() string {
	return "GET"
}

func (r *OrgsListOutsideCollaboratorsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *OrgsListOutsideCollaboratorsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsListOutsideCollaboratorsReq) body() interface{} {
	return nil
}

func (r *OrgsListOutsideCollaboratorsReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsListOutsideCollaboratorsReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsListOutsideCollaboratorsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsListOutsideCollaboratorsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListOutsideCollaboratorsReq) Rel(link RelName, resp *OrgsListOutsideCollaboratorsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListOutsideCollaboratorsResponseBody is a response body for OrgsListOutsideCollaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators
*/
type OrgsListOutsideCollaboratorsResponseBody []struct {
	components.SimpleUser
}

/*
OrgsListOutsideCollaboratorsResponse is a response for OrgsListOutsideCollaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators
*/
type OrgsListOutsideCollaboratorsResponse struct {
	response
	request *OrgsListOutsideCollaboratorsReq
	Data    *OrgsListOutsideCollaboratorsResponseBody
}

/*
OrgsListPendingInvitations performs requests for "orgs/list-pending-invitations"

List pending organization invitations.

  GET /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
func OrgsListPendingInvitations(ctx context.Context, req *OrgsListPendingInvitationsReq, opt ...RequestOption) (*OrgsListPendingInvitationsResponse, error) {
	if req == nil {
		req = new(OrgsListPendingInvitationsReq)
	}
	resp := &OrgsListPendingInvitationsResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsListPendingInvitationsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListPendingInvitations performs requests for "orgs/list-pending-invitations"

List pending organization invitations.

  GET /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
func (c Client) OrgsListPendingInvitations(ctx context.Context, req *OrgsListPendingInvitationsReq, opt ...RequestOption) (*OrgsListPendingInvitationsResponse, error) {
	return OrgsListPendingInvitations(ctx, req, append(c, opt...)...)
}

/*
OrgsListPendingInvitationsReq is request data for Client.OrgsListPendingInvitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
type OrgsListPendingInvitationsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *OrgsListPendingInvitationsReq) url() string {
	return r._url
}

func (r *OrgsListPendingInvitationsReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/invitations", r.Org)
}

func (r *OrgsListPendingInvitationsReq) method() string {
	return "GET"
}

func (r *OrgsListPendingInvitationsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *OrgsListPendingInvitationsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsListPendingInvitationsReq) body() interface{} {
	return nil
}

func (r *OrgsListPendingInvitationsReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsListPendingInvitationsReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsListPendingInvitationsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsListPendingInvitationsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListPendingInvitationsReq) Rel(link RelName, resp *OrgsListPendingInvitationsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListPendingInvitationsResponseBody is a response body for OrgsListPendingInvitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
type OrgsListPendingInvitationsResponseBody []struct {
	components.OrganizationInvitation
}

/*
OrgsListPendingInvitationsResponse is a response for OrgsListPendingInvitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
type OrgsListPendingInvitationsResponse struct {
	response
	request *OrgsListPendingInvitationsReq
	Data    *OrgsListPendingInvitationsResponseBody
}

/*
OrgsListPublicMembers performs requests for "orgs/list-public-members"

Public members list.

  GET /orgs/{org}/public_members

https://developer.github.com/v3/orgs/members/#public-members-list
*/
func OrgsListPublicMembers(ctx context.Context, req *OrgsListPublicMembersReq, opt ...RequestOption) (*OrgsListPublicMembersResponse, error) {
	if req == nil {
		req = new(OrgsListPublicMembersReq)
	}
	resp := &OrgsListPublicMembersResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsListPublicMembersResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListPublicMembers performs requests for "orgs/list-public-members"

Public members list.

  GET /orgs/{org}/public_members

https://developer.github.com/v3/orgs/members/#public-members-list
*/
func (c Client) OrgsListPublicMembers(ctx context.Context, req *OrgsListPublicMembersReq, opt ...RequestOption) (*OrgsListPublicMembersResponse, error) {
	return OrgsListPublicMembers(ctx, req, append(c, opt...)...)
}

/*
OrgsListPublicMembersReq is request data for Client.OrgsListPublicMembers

https://developer.github.com/v3/orgs/members/#public-members-list
*/
type OrgsListPublicMembersReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *OrgsListPublicMembersReq) url() string {
	return r._url
}

func (r *OrgsListPublicMembersReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/public_members", r.Org)
}

func (r *OrgsListPublicMembersReq) method() string {
	return "GET"
}

func (r *OrgsListPublicMembersReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *OrgsListPublicMembersReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsListPublicMembersReq) body() interface{} {
	return nil
}

func (r *OrgsListPublicMembersReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsListPublicMembersReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsListPublicMembersReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsListPublicMembersReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListPublicMembersReq) Rel(link RelName, resp *OrgsListPublicMembersResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListPublicMembersResponseBody is a response body for OrgsListPublicMembers

https://developer.github.com/v3/orgs/members/#public-members-list
*/
type OrgsListPublicMembersResponseBody []struct {
	components.SimpleUser
}

/*
OrgsListPublicMembersResponse is a response for OrgsListPublicMembers

https://developer.github.com/v3/orgs/members/#public-members-list
*/
type OrgsListPublicMembersResponse struct {
	response
	request *OrgsListPublicMembersReq
	Data    *OrgsListPublicMembersResponseBody
}

/*
OrgsPingHook performs requests for "orgs/ping-hook"

Ping a hook.

  POST /orgs/{org}/hooks/{hook_id}/pings

https://developer.github.com/v3/orgs/hooks/#ping-a-hook
*/
func OrgsPingHook(ctx context.Context, req *OrgsPingHookReq, opt ...RequestOption) (*OrgsPingHookResponse, error) {
	if req == nil {
		req = new(OrgsPingHookReq)
	}
	resp := &OrgsPingHookResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsPingHook performs requests for "orgs/ping-hook"

Ping a hook.

  POST /orgs/{org}/hooks/{hook_id}/pings

https://developer.github.com/v3/orgs/hooks/#ping-a-hook
*/
func (c Client) OrgsPingHook(ctx context.Context, req *OrgsPingHookReq, opt ...RequestOption) (*OrgsPingHookResponse, error) {
	return OrgsPingHook(ctx, req, append(c, opt...)...)
}

/*
OrgsPingHookReq is request data for Client.OrgsPingHook

https://developer.github.com/v3/orgs/hooks/#ping-a-hook
*/
type OrgsPingHookReq struct {
	_url   string
	Org    string
	HookId int64
}

func (r *OrgsPingHookReq) url() string {
	return r._url
}

func (r *OrgsPingHookReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/hooks/%v/pings", r.Org, r.HookId)
}

func (r *OrgsPingHookReq) method() string {
	return "POST"
}

func (r *OrgsPingHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsPingHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsPingHookReq) body() interface{} {
	return nil
}

func (r *OrgsPingHookReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsPingHookReq) validStatuses() []int {
	return []int{204}
}

func (r *OrgsPingHookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsPingHookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsPingHookReq) Rel(link RelName, resp *OrgsPingHookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsPingHookResponse is a response for OrgsPingHook

https://developer.github.com/v3/orgs/hooks/#ping-a-hook
*/
type OrgsPingHookResponse struct {
	response
	request *OrgsPingHookReq
}

/*
OrgsPublicizeMembership performs requests for "orgs/publicize-membership"

Publicize a user's membership.

  PUT /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#publicize-a-users-membership
*/
func OrgsPublicizeMembership(ctx context.Context, req *OrgsPublicizeMembershipReq, opt ...RequestOption) (*OrgsPublicizeMembershipResponse, error) {
	if req == nil {
		req = new(OrgsPublicizeMembershipReq)
	}
	resp := &OrgsPublicizeMembershipResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsPublicizeMembership performs requests for "orgs/publicize-membership"

Publicize a user's membership.

  PUT /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#publicize-a-users-membership
*/
func (c Client) OrgsPublicizeMembership(ctx context.Context, req *OrgsPublicizeMembershipReq, opt ...RequestOption) (*OrgsPublicizeMembershipResponse, error) {
	return OrgsPublicizeMembership(ctx, req, append(c, opt...)...)
}

/*
OrgsPublicizeMembershipReq is request data for Client.OrgsPublicizeMembership

https://developer.github.com/v3/orgs/members/#publicize-a-users-membership
*/
type OrgsPublicizeMembershipReq struct {
	_url     string
	Org      string
	Username string
}

func (r *OrgsPublicizeMembershipReq) url() string {
	return r._url
}

func (r *OrgsPublicizeMembershipReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username)
}

func (r *OrgsPublicizeMembershipReq) method() string {
	return "PUT"
}

func (r *OrgsPublicizeMembershipReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsPublicizeMembershipReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsPublicizeMembershipReq) body() interface{} {
	return nil
}

func (r *OrgsPublicizeMembershipReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsPublicizeMembershipReq) validStatuses() []int {
	return []int{204}
}

func (r *OrgsPublicizeMembershipReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsPublicizeMembershipReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsPublicizeMembershipReq) Rel(link RelName, resp *OrgsPublicizeMembershipResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsPublicizeMembershipResponse is a response for OrgsPublicizeMembership

https://developer.github.com/v3/orgs/members/#publicize-a-users-membership
*/
type OrgsPublicizeMembershipResponse struct {
	response
	request *OrgsPublicizeMembershipReq
}

/*
OrgsRemoveCredentialAuthorization performs requests for "orgs/remove-credential-authorization"

Remove a credential authorization for an organization.

  DELETE /orgs/{org}/credential-authorizations/{credential_id}

https://developer.github.com/v3/orgs/#remove-a-credential-authorization-for-an-organization
*/
func OrgsRemoveCredentialAuthorization(ctx context.Context, req *OrgsRemoveCredentialAuthorizationReq, opt ...RequestOption) (*OrgsRemoveCredentialAuthorizationResponse, error) {
	if req == nil {
		req = new(OrgsRemoveCredentialAuthorizationReq)
	}
	resp := &OrgsRemoveCredentialAuthorizationResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsRemoveCredentialAuthorization performs requests for "orgs/remove-credential-authorization"

Remove a credential authorization for an organization.

  DELETE /orgs/{org}/credential-authorizations/{credential_id}

https://developer.github.com/v3/orgs/#remove-a-credential-authorization-for-an-organization
*/
func (c Client) OrgsRemoveCredentialAuthorization(ctx context.Context, req *OrgsRemoveCredentialAuthorizationReq, opt ...RequestOption) (*OrgsRemoveCredentialAuthorizationResponse, error) {
	return OrgsRemoveCredentialAuthorization(ctx, req, append(c, opt...)...)
}

/*
OrgsRemoveCredentialAuthorizationReq is request data for Client.OrgsRemoveCredentialAuthorization

https://developer.github.com/v3/orgs/#remove-a-credential-authorization-for-an-organization
*/
type OrgsRemoveCredentialAuthorizationReq struct {
	_url         string
	Org          string
	CredentialId int64
}

func (r *OrgsRemoveCredentialAuthorizationReq) url() string {
	return r._url
}

func (r *OrgsRemoveCredentialAuthorizationReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/credential-authorizations/%v", r.Org, r.CredentialId)
}

func (r *OrgsRemoveCredentialAuthorizationReq) method() string {
	return "DELETE"
}

func (r *OrgsRemoveCredentialAuthorizationReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsRemoveCredentialAuthorizationReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsRemoveCredentialAuthorizationReq) body() interface{} {
	return nil
}

func (r *OrgsRemoveCredentialAuthorizationReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsRemoveCredentialAuthorizationReq) validStatuses() []int {
	return []int{204}
}

func (r *OrgsRemoveCredentialAuthorizationReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsRemoveCredentialAuthorizationReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsRemoveCredentialAuthorizationReq) Rel(link RelName, resp *OrgsRemoveCredentialAuthorizationResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsRemoveCredentialAuthorizationResponse is a response for OrgsRemoveCredentialAuthorization

https://developer.github.com/v3/orgs/#remove-a-credential-authorization-for-an-organization
*/
type OrgsRemoveCredentialAuthorizationResponse struct {
	response
	request *OrgsRemoveCredentialAuthorizationReq
}

/*
OrgsRemoveMember performs requests for "orgs/remove-member"

Remove a member.

  DELETE /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#remove-a-member
*/
func OrgsRemoveMember(ctx context.Context, req *OrgsRemoveMemberReq, opt ...RequestOption) (*OrgsRemoveMemberResponse, error) {
	if req == nil {
		req = new(OrgsRemoveMemberReq)
	}
	resp := &OrgsRemoveMemberResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsRemoveMember performs requests for "orgs/remove-member"

Remove a member.

  DELETE /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#remove-a-member
*/
func (c Client) OrgsRemoveMember(ctx context.Context, req *OrgsRemoveMemberReq, opt ...RequestOption) (*OrgsRemoveMemberResponse, error) {
	return OrgsRemoveMember(ctx, req, append(c, opt...)...)
}

/*
OrgsRemoveMemberReq is request data for Client.OrgsRemoveMember

https://developer.github.com/v3/orgs/members/#remove-a-member
*/
type OrgsRemoveMemberReq struct {
	_url     string
	Org      string
	Username string
}

func (r *OrgsRemoveMemberReq) url() string {
	return r._url
}

func (r *OrgsRemoveMemberReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/members/%v", r.Org, r.Username)
}

func (r *OrgsRemoveMemberReq) method() string {
	return "DELETE"
}

func (r *OrgsRemoveMemberReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsRemoveMemberReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsRemoveMemberReq) body() interface{} {
	return nil
}

func (r *OrgsRemoveMemberReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsRemoveMemberReq) validStatuses() []int {
	return []int{204}
}

func (r *OrgsRemoveMemberReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsRemoveMemberReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsRemoveMemberReq) Rel(link RelName, resp *OrgsRemoveMemberResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsRemoveMemberResponse is a response for OrgsRemoveMember

https://developer.github.com/v3/orgs/members/#remove-a-member
*/
type OrgsRemoveMemberResponse struct {
	response
	request *OrgsRemoveMemberReq
}

/*
OrgsRemoveMembership performs requests for "orgs/remove-membership"

Remove organization membership.

  DELETE /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#remove-organization-membership
*/
func OrgsRemoveMembership(ctx context.Context, req *OrgsRemoveMembershipReq, opt ...RequestOption) (*OrgsRemoveMembershipResponse, error) {
	if req == nil {
		req = new(OrgsRemoveMembershipReq)
	}
	resp := &OrgsRemoveMembershipResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsRemoveMembership performs requests for "orgs/remove-membership"

Remove organization membership.

  DELETE /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#remove-organization-membership
*/
func (c Client) OrgsRemoveMembership(ctx context.Context, req *OrgsRemoveMembershipReq, opt ...RequestOption) (*OrgsRemoveMembershipResponse, error) {
	return OrgsRemoveMembership(ctx, req, append(c, opt...)...)
}

/*
OrgsRemoveMembershipReq is request data for Client.OrgsRemoveMembership

https://developer.github.com/v3/orgs/members/#remove-organization-membership
*/
type OrgsRemoveMembershipReq struct {
	_url     string
	Org      string
	Username string
}

func (r *OrgsRemoveMembershipReq) url() string {
	return r._url
}

func (r *OrgsRemoveMembershipReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username)
}

func (r *OrgsRemoveMembershipReq) method() string {
	return "DELETE"
}

func (r *OrgsRemoveMembershipReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsRemoveMembershipReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsRemoveMembershipReq) body() interface{} {
	return nil
}

func (r *OrgsRemoveMembershipReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsRemoveMembershipReq) validStatuses() []int {
	return []int{204}
}

func (r *OrgsRemoveMembershipReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsRemoveMembershipReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsRemoveMembershipReq) Rel(link RelName, resp *OrgsRemoveMembershipResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsRemoveMembershipResponse is a response for OrgsRemoveMembership

https://developer.github.com/v3/orgs/members/#remove-organization-membership
*/
type OrgsRemoveMembershipResponse struct {
	response
	request *OrgsRemoveMembershipReq
}

/*
OrgsRemoveOutsideCollaborator performs requests for "orgs/remove-outside-collaborator"

Remove outside collaborator.

  DELETE /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator
*/
func OrgsRemoveOutsideCollaborator(ctx context.Context, req *OrgsRemoveOutsideCollaboratorReq, opt ...RequestOption) (*OrgsRemoveOutsideCollaboratorResponse, error) {
	if req == nil {
		req = new(OrgsRemoveOutsideCollaboratorReq)
	}
	resp := &OrgsRemoveOutsideCollaboratorResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsRemoveOutsideCollaborator performs requests for "orgs/remove-outside-collaborator"

Remove outside collaborator.

  DELETE /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator
*/
func (c Client) OrgsRemoveOutsideCollaborator(ctx context.Context, req *OrgsRemoveOutsideCollaboratorReq, opt ...RequestOption) (*OrgsRemoveOutsideCollaboratorResponse, error) {
	return OrgsRemoveOutsideCollaborator(ctx, req, append(c, opt...)...)
}

/*
OrgsRemoveOutsideCollaboratorReq is request data for Client.OrgsRemoveOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator
*/
type OrgsRemoveOutsideCollaboratorReq struct {
	_url     string
	Org      string
	Username string
}

func (r *OrgsRemoveOutsideCollaboratorReq) url() string {
	return r._url
}

func (r *OrgsRemoveOutsideCollaboratorReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/outside_collaborators/%v", r.Org, r.Username)
}

func (r *OrgsRemoveOutsideCollaboratorReq) method() string {
	return "DELETE"
}

func (r *OrgsRemoveOutsideCollaboratorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsRemoveOutsideCollaboratorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsRemoveOutsideCollaboratorReq) body() interface{} {
	return nil
}

func (r *OrgsRemoveOutsideCollaboratorReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsRemoveOutsideCollaboratorReq) validStatuses() []int {
	return []int{204}
}

func (r *OrgsRemoveOutsideCollaboratorReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsRemoveOutsideCollaboratorReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsRemoveOutsideCollaboratorReq) Rel(link RelName, resp *OrgsRemoveOutsideCollaboratorResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsRemoveOutsideCollaboratorResponse is a response for OrgsRemoveOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator
*/
type OrgsRemoveOutsideCollaboratorResponse struct {
	response
	request *OrgsRemoveOutsideCollaboratorReq
}

/*
OrgsUnblockUser performs requests for "orgs/unblock-user"

Unblock a user.

  DELETE /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#unblock-a-user
*/
func OrgsUnblockUser(ctx context.Context, req *OrgsUnblockUserReq, opt ...RequestOption) (*OrgsUnblockUserResponse, error) {
	if req == nil {
		req = new(OrgsUnblockUserReq)
	}
	resp := &OrgsUnblockUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsUnblockUser performs requests for "orgs/unblock-user"

Unblock a user.

  DELETE /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#unblock-a-user
*/
func (c Client) OrgsUnblockUser(ctx context.Context, req *OrgsUnblockUserReq, opt ...RequestOption) (*OrgsUnblockUserResponse, error) {
	return OrgsUnblockUser(ctx, req, append(c, opt...)...)
}

/*
OrgsUnblockUserReq is request data for Client.OrgsUnblockUser

https://developer.github.com/v3/orgs/blocking/#unblock-a-user
*/
type OrgsUnblockUserReq struct {
	_url     string
	Org      string
	Username string
}

func (r *OrgsUnblockUserReq) url() string {
	return r._url
}

func (r *OrgsUnblockUserReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username)
}

func (r *OrgsUnblockUserReq) method() string {
	return "DELETE"
}

func (r *OrgsUnblockUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsUnblockUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsUnblockUserReq) body() interface{} {
	return nil
}

func (r *OrgsUnblockUserReq) dataStatuses() []int {
	return []int{}
}

func (r *OrgsUnblockUserReq) validStatuses() []int {
	return []int{204}
}

func (r *OrgsUnblockUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *OrgsUnblockUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsUnblockUserReq) Rel(link RelName, resp *OrgsUnblockUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsUnblockUserResponse is a response for OrgsUnblockUser

https://developer.github.com/v3/orgs/blocking/#unblock-a-user
*/
type OrgsUnblockUserResponse struct {
	response
	request *OrgsUnblockUserReq
}

/*
OrgsUpdate performs requests for "orgs/update"

Edit an organization.

  PATCH /orgs/{org}

https://developer.github.com/v3/orgs/#edit-an-organization
*/
func OrgsUpdate(ctx context.Context, req *OrgsUpdateReq, opt ...RequestOption) (*OrgsUpdateResponse, error) {
	if req == nil {
		req = new(OrgsUpdateReq)
	}
	resp := &OrgsUpdateResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsUpdateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsUpdate performs requests for "orgs/update"

Edit an organization.

  PATCH /orgs/{org}

https://developer.github.com/v3/orgs/#edit-an-organization
*/
func (c Client) OrgsUpdate(ctx context.Context, req *OrgsUpdateReq, opt ...RequestOption) (*OrgsUpdateResponse, error) {
	return OrgsUpdate(ctx, req, append(c, opt...)...)
}

/*
OrgsUpdateReq is request data for Client.OrgsUpdate

https://developer.github.com/v3/orgs/#edit-an-organization
*/
type OrgsUpdateReq struct {
	_url        string
	Org         string
	RequestBody OrgsUpdateReqBody

	/*
	New repository creation permissions are available to preview. You can now use
	`members_can_create_public_repositories`,
	`members_can_create_private_repositories`, and
	`members_can_create_internal_repositories`. You can only allow members to create
	internal repositories if your organization is associated with an enterprise
	account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. These
	parameters provide more granular permissions to configure the type of
	repositories organization members can create.

	To access these new parameters during the preview period, you must set this to
	true.
	*/
	SurturPreview bool
}

func (r *OrgsUpdateReq) url() string {
	return r._url
}

func (r *OrgsUpdateReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v", r.Org)
}

func (r *OrgsUpdateReq) method() string {
	return "PATCH"
}

func (r *OrgsUpdateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsUpdateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"surtur": r.SurturPreview}
	if allPreviews {
		previewVals["surtur"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsUpdateReq) body() interface{} {
	return r.RequestBody
}

func (r *OrgsUpdateReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsUpdateReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsUpdateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *OrgsUpdateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsUpdateReq) Rel(link RelName, resp *OrgsUpdateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsUpdateReqBody is a request body for orgs/update

https://developer.github.com/v3/orgs/#edit-an-organization
*/
type OrgsUpdateReqBody struct {

	// Billing email address. This address is not publicized.
	BillingEmail *string `json:"billing_email,omitempty"`

	// The company name.
	Company *string `json:"company,omitempty"`

	/*
	   Default permission level members have for organization repositories:
	   \* `read` - can pull, but not push to or administer this repository.
	   \* `write` - can pull and push, but not administer this repository.
	   \* `admin` - can pull, push, and administer this repository.
	   \* `none` - no permissions granted by default.
	*/
	DefaultRepositoryPermission *string `json:"default_repository_permission,omitempty"`

	// The description of the company.
	Description *string `json:"description,omitempty"`

	// The publicly visible email address.
	Email *string `json:"email,omitempty"`

	// Toggles whether an organization can use organization projects.
	HasOrganizationProjects *bool `json:"has_organization_projects,omitempty"`

	/*
	   Toggles whether repositories that belong to the organization can use repository
	   projects.
	*/
	HasRepositoryProjects *bool `json:"has_repository_projects,omitempty"`

	// The location.
	Location *string `json:"location,omitempty"`

	/*
	   Specifies which types of repositories non-admin organization members can create.
	   Can be one of:
	   \* `all` - all organization members can create public and private repositories.
	   \* `private` - members can create private repositories. This option is only
	   available to repositories that are part of an organization on GitHub Enterprise
	   Cloud.
	   \* `none` - only admin members can create repositories.
	   **Note:** This parameter is deprecated and will be removed in the future. Its
	   return value ignores internal repositories. Using this parameter overrides
	   values set in `members_can_create_repositories`. See [this
	   note](https://developer.github.com/v3/orgs/#members_can_create_repositories) for
	   details.
	*/
	MembersAllowedRepositoryCreationType *string `json:"members_allowed_repository_creation_type,omitempty"`

	/*
	   Toggles whether organization members can create internal repositories, which are
	   visible to all enterprise members. You can only allow members to create internal
	   repositories if your organization is associated with an enterprise account using
	   GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. Can be one of:
	   \* `true` - all organization members can create internal repositories.
	   \* `false` - only organization owners can create internal repositories.
	   Default: `true`. For more information, see "[Restricting repository creation in
	   your
	   organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	   in the GitHub Help documentation.
	*/
	MembersCanCreateInternalRepositories *bool `json:"members_can_create_internal_repositories,omitempty"`

	/*
	   Toggles whether organization members can create private repositories, which are
	   visible to organization members with permission. Can be one of:
	   \* `true` - all organization members can create private repositories.
	   \* `false` - only organization owners can create private repositories.
	   Default: `true`. For more information, see "[Restricting repository creation in
	   your
	   organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	   in the GitHub Help documentation.
	*/
	MembersCanCreatePrivateRepositories *bool `json:"members_can_create_private_repositories,omitempty"`

	/*
	   Toggles whether organization members can create public repositories, which are
	   visible to anyone. Can be one of:
	   \* `true` - all organization members can create public repositories.
	   \* `false` - only organization owners can create public repositories.
	   Default: `true`. For more information, see "[Restricting repository creation in
	   your
	   organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	   in the GitHub Help documentation.
	*/
	MembersCanCreatePublicRepositories *bool `json:"members_can_create_public_repositories,omitempty"`

	/*
	   Toggles the ability of non-admin organization members to create repositories.
	   Can be one of:
	   \* `true` - all organization members can create repositories.
	   \* `false` - only organization owners can create repositories.
	   Default: `true`
	   **Note:** A parameter can override this parameter. See
	   `members_allowed_repository_creation_type` in this table for details. **Note:**
	   A parameter can override this parameter. See
	   `members_allowed_repository_creation_type` in this table for details.
	*/
	MembersCanCreateRepositories *bool `json:"members_can_create_repositories,omitempty"`

	// The shorthand name of the company.
	Name *string `json:"name,omitempty"`
}

/*
OrgsUpdateResponseBody is a response body for OrgsUpdate

https://developer.github.com/v3/orgs/#edit-an-organization
*/
type OrgsUpdateResponseBody struct {
	components.OrganizationFull
}

/*
OrgsUpdateResponse is a response for OrgsUpdate

https://developer.github.com/v3/orgs/#edit-an-organization
*/
type OrgsUpdateResponse struct {
	response
	request *OrgsUpdateReq
	Data    *OrgsUpdateResponseBody
}

/*
OrgsUpdateHook performs requests for "orgs/update-hook"

Edit a hook.

  PATCH /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#edit-a-hook
*/
func OrgsUpdateHook(ctx context.Context, req *OrgsUpdateHookReq, opt ...RequestOption) (*OrgsUpdateHookResponse, error) {
	if req == nil {
		req = new(OrgsUpdateHookReq)
	}
	resp := &OrgsUpdateHookResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsUpdateHookResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsUpdateHook performs requests for "orgs/update-hook"

Edit a hook.

  PATCH /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#edit-a-hook
*/
func (c Client) OrgsUpdateHook(ctx context.Context, req *OrgsUpdateHookReq, opt ...RequestOption) (*OrgsUpdateHookResponse, error) {
	return OrgsUpdateHook(ctx, req, append(c, opt...)...)
}

/*
OrgsUpdateHookReq is request data for Client.OrgsUpdateHook

https://developer.github.com/v3/orgs/hooks/#edit-a-hook
*/
type OrgsUpdateHookReq struct {
	_url        string
	Org         string
	HookId      int64
	RequestBody OrgsUpdateHookReqBody
}

func (r *OrgsUpdateHookReq) url() string {
	return r._url
}

func (r *OrgsUpdateHookReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId)
}

func (r *OrgsUpdateHookReq) method() string {
	return "PATCH"
}

func (r *OrgsUpdateHookReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsUpdateHookReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsUpdateHookReq) body() interface{} {
	return r.RequestBody
}

func (r *OrgsUpdateHookReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsUpdateHookReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsUpdateHookReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *OrgsUpdateHookReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsUpdateHookReq) Rel(link RelName, resp *OrgsUpdateHookResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// OrgsUpdateHookReqBodyConfig is a value for OrgsUpdateHookReqBody's Config field
type OrgsUpdateHookReqBodyConfig struct {

	/*
	   The media type used to serialize the payloads. Supported values include `json`
	   and `form`. The default is `form`.
	*/
	ContentType *string `json:"content_type,omitempty"`

	/*
	   Determines whether the SSL certificate of the host for `url` will be verified
	   when delivering payloads. Supported values include `0` (verification is
	   performed) and `1` (verification is not performed). The default is `0`. **We
	   strongly recommend not setting this to `1` as you are subject to
	   man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	   If provided, the `secret` will be used as the `key` to generate the HMAC hex
	   digest value in the
	   [`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	   header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
OrgsUpdateHookReqBody is a request body for orgs/update-hook

https://developer.github.com/v3/orgs/hooks/#edit-a-hook
*/
type OrgsUpdateHookReqBody struct {

	/*
	   Determines if notifications are sent when the webhook is triggered. Set to
	   `true` to send notifications.
	*/
	Active *bool `json:"active,omitempty"`

	/*
	   Key/value pairs to provide settings for this webhook. [These are defined
	   below](https://developer.github.com/v3/orgs/hooks/#update-hook-config-params).
	*/
	Config *OrgsUpdateHookReqBodyConfig `json:"config,omitempty"`

	/*
	   Determines what [events](https://developer.github.com/webhooks/event-payloads)
	   the hook is triggered for.
	*/
	Events []string `json:"events,omitempty"`
}

/*
OrgsUpdateHookResponseBody is a response body for OrgsUpdateHook

https://developer.github.com/v3/orgs/hooks/#edit-a-hook
*/
type OrgsUpdateHookResponseBody struct {
	components.OrgHook
}

/*
OrgsUpdateHookResponse is a response for OrgsUpdateHook

https://developer.github.com/v3/orgs/hooks/#edit-a-hook
*/
type OrgsUpdateHookResponse struct {
	response
	request *OrgsUpdateHookReq
	Data    *OrgsUpdateHookResponseBody
}

/*
OrgsUpdateMembership performs requests for "orgs/update-membership"

Edit your organization membership.

  PATCH /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#edit-your-organization-membership
*/
func OrgsUpdateMembership(ctx context.Context, req *OrgsUpdateMembershipReq, opt ...RequestOption) (*OrgsUpdateMembershipResponse, error) {
	if req == nil {
		req = new(OrgsUpdateMembershipReq)
	}
	resp := &OrgsUpdateMembershipResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(OrgsUpdateMembershipResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsUpdateMembership performs requests for "orgs/update-membership"

Edit your organization membership.

  PATCH /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#edit-your-organization-membership
*/
func (c Client) OrgsUpdateMembership(ctx context.Context, req *OrgsUpdateMembershipReq, opt ...RequestOption) (*OrgsUpdateMembershipResponse, error) {
	return OrgsUpdateMembership(ctx, req, append(c, opt...)...)
}

/*
OrgsUpdateMembershipReq is request data for Client.OrgsUpdateMembership

https://developer.github.com/v3/orgs/members/#edit-your-organization-membership
*/
type OrgsUpdateMembershipReq struct {
	_url        string
	Org         string
	RequestBody OrgsUpdateMembershipReqBody
}

func (r *OrgsUpdateMembershipReq) url() string {
	return r._url
}

func (r *OrgsUpdateMembershipReq) urlPath() string {
	return fmt.Sprintf("/user/memberships/orgs/%v", r.Org)
}

func (r *OrgsUpdateMembershipReq) method() string {
	return "PATCH"
}

func (r *OrgsUpdateMembershipReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *OrgsUpdateMembershipReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *OrgsUpdateMembershipReq) body() interface{} {
	return r.RequestBody
}

func (r *OrgsUpdateMembershipReq) dataStatuses() []int {
	return []int{200}
}

func (r *OrgsUpdateMembershipReq) validStatuses() []int {
	return []int{200}
}

func (r *OrgsUpdateMembershipReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *OrgsUpdateMembershipReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsUpdateMembershipReq) Rel(link RelName, resp *OrgsUpdateMembershipResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsUpdateMembershipReqBody is a request body for orgs/update-membership

https://developer.github.com/v3/orgs/members/#edit-your-organization-membership
*/
type OrgsUpdateMembershipReqBody struct {

	// The state that the membership should be in. Only `"active"` will be accepted.
	State *string `json:"state"`
}

/*
OrgsUpdateMembershipResponseBody is a response body for OrgsUpdateMembership

https://developer.github.com/v3/orgs/members/#edit-your-organization-membership
*/
type OrgsUpdateMembershipResponseBody struct {
	components.OrgMembership
}

/*
OrgsUpdateMembershipResponse is a response for OrgsUpdateMembership

https://developer.github.com/v3/orgs/members/#edit-your-organization-membership
*/
type OrgsUpdateMembershipResponse struct {
	response
	request *OrgsUpdateMembershipReq
	Data    *OrgsUpdateMembershipResponseBody
}
