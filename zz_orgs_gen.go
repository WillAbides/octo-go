// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
OrgsBlockUser performs requests for "orgs/block-user"

Block a user from an organization.

  PUT /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
func OrgsBlockUser(ctx context.Context, req *OrgsBlockUserReq, opt ...options.Option) (*OrgsBlockUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsBlockUserReq)
	}
	resp := &OrgsBlockUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsBlockUser performs requests for "orgs/block-user"

Block a user from an organization.

  PUT /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
func (c Client) OrgsBlockUser(ctx context.Context, req *OrgsBlockUserReq, opt ...options.Option) (*OrgsBlockUserResponse, error) {
	return OrgsBlockUser(ctx, req, append(c, opt...)...)
}

/*
OrgsBlockUserReq is request data for Client.OrgsBlockUser

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
type OrgsBlockUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *OrgsBlockUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsBlockUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "orgs/block-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsBlockUserReq) Rel(link string, resp *OrgsBlockUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsBlockUserResponse is a response for OrgsBlockUser

https://developer.github.com/v3/orgs/blocking/#block-a-user-from-an-organization
*/
type OrgsBlockUserResponse struct {
	common.Response
	request *OrgsBlockUserReq
}

/*
OrgsCheckBlockedUser performs requests for "orgs/check-blocked-user"

Check if a user is blocked by an organization.

  GET /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
func OrgsCheckBlockedUser(ctx context.Context, req *OrgsCheckBlockedUserReq, opt ...options.Option) (*OrgsCheckBlockedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsCheckBlockedUserReq)
	}
	resp := &OrgsCheckBlockedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsCheckBlockedUser performs requests for "orgs/check-blocked-user"

Check if a user is blocked by an organization.

  GET /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
func (c Client) OrgsCheckBlockedUser(ctx context.Context, req *OrgsCheckBlockedUserReq, opt ...options.Option) (*OrgsCheckBlockedUserResponse, error) {
	return OrgsCheckBlockedUser(ctx, req, append(c, opt...)...)
}

/*
OrgsCheckBlockedUserReq is request data for Client.OrgsCheckBlockedUser

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
type OrgsCheckBlockedUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *OrgsCheckBlockedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsCheckBlockedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "orgs/check-blocked-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsCheckBlockedUserReq) Rel(link string, resp *OrgsCheckBlockedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsCheckBlockedUserResponse is a response for OrgsCheckBlockedUser

https://developer.github.com/v3/orgs/blocking/#check-if-a-user-is-blocked-by-an-organization
*/
type OrgsCheckBlockedUserResponse struct {
	common.Response
	request *OrgsCheckBlockedUserReq
	Data    bool
}

/*
OrgsCheckMembershipForUser performs requests for "orgs/check-membership-for-user"

Check organization membership for a user.

  GET /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
func OrgsCheckMembershipForUser(ctx context.Context, req *OrgsCheckMembershipForUserReq, opt ...options.Option) (*OrgsCheckMembershipForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsCheckMembershipForUserReq)
	}
	resp := &OrgsCheckMembershipForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsCheckMembershipForUser performs requests for "orgs/check-membership-for-user"

Check organization membership for a user.

  GET /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
func (c Client) OrgsCheckMembershipForUser(ctx context.Context, req *OrgsCheckMembershipForUserReq, opt ...options.Option) (*OrgsCheckMembershipForUserResponse, error) {
	return OrgsCheckMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
OrgsCheckMembershipForUserReq is request data for Client.OrgsCheckMembershipForUser

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
type OrgsCheckMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *OrgsCheckMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsCheckMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "orgs/check-membership-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/members/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204, 302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsCheckMembershipForUserReq) Rel(link string, resp *OrgsCheckMembershipForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsCheckMembershipForUserResponse is a response for OrgsCheckMembershipForUser

https://developer.github.com/v3/orgs/members/#check-organization-membership-for-a-user
*/
type OrgsCheckMembershipForUserResponse struct {
	common.Response
	request *OrgsCheckMembershipForUserReq
}

/*
OrgsCheckPublicMembershipForUser performs requests for "orgs/check-public-membership-for-user"

Check public organization membership for a user.

  GET /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
func OrgsCheckPublicMembershipForUser(ctx context.Context, req *OrgsCheckPublicMembershipForUserReq, opt ...options.Option) (*OrgsCheckPublicMembershipForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsCheckPublicMembershipForUserReq)
	}
	resp := &OrgsCheckPublicMembershipForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsCheckPublicMembershipForUser performs requests for "orgs/check-public-membership-for-user"

Check public organization membership for a user.

  GET /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
func (c Client) OrgsCheckPublicMembershipForUser(ctx context.Context, req *OrgsCheckPublicMembershipForUserReq, opt ...options.Option) (*OrgsCheckPublicMembershipForUserResponse, error) {
	return OrgsCheckPublicMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
OrgsCheckPublicMembershipForUserReq is request data for Client.OrgsCheckPublicMembershipForUser

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
type OrgsCheckPublicMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *OrgsCheckPublicMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsCheckPublicMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "orgs/check-public-membership-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsCheckPublicMembershipForUserReq) Rel(link string, resp *OrgsCheckPublicMembershipForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsCheckPublicMembershipForUserResponse is a response for OrgsCheckPublicMembershipForUser

https://developer.github.com/v3/orgs/members/#check-public-organization-membership-for-a-user
*/
type OrgsCheckPublicMembershipForUserResponse struct {
	common.Response
	request *OrgsCheckPublicMembershipForUserReq
	Data    bool
}

/*
OrgsConvertMemberToOutsideCollaborator performs requests for "orgs/convert-member-to-outside-collaborator"

Convert an organization member to outside collaborator.

  PUT /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
func OrgsConvertMemberToOutsideCollaborator(ctx context.Context, req *OrgsConvertMemberToOutsideCollaboratorReq, opt ...options.Option) (*OrgsConvertMemberToOutsideCollaboratorResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsConvertMemberToOutsideCollaboratorReq)
	}
	resp := &OrgsConvertMemberToOutsideCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsConvertMemberToOutsideCollaborator performs requests for "orgs/convert-member-to-outside-collaborator"

Convert an organization member to outside collaborator.

  PUT /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
func (c Client) OrgsConvertMemberToOutsideCollaborator(ctx context.Context, req *OrgsConvertMemberToOutsideCollaboratorReq, opt ...options.Option) (*OrgsConvertMemberToOutsideCollaboratorResponse, error) {
	return OrgsConvertMemberToOutsideCollaborator(ctx, req, append(c, opt...)...)
}

/*
OrgsConvertMemberToOutsideCollaboratorReq is request data for Client.OrgsConvertMemberToOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
type OrgsConvertMemberToOutsideCollaboratorReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *OrgsConvertMemberToOutsideCollaboratorReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsConvertMemberToOutsideCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "orgs/convert-member-to-outside-collaborator",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/outside_collaborators/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{202, 204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsConvertMemberToOutsideCollaboratorReq) Rel(link string, resp *OrgsConvertMemberToOutsideCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsConvertMemberToOutsideCollaboratorResponse is a response for OrgsConvertMemberToOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#convert-an-organization-member-to-outside-collaborator
*/
type OrgsConvertMemberToOutsideCollaboratorResponse struct {
	common.Response
	request *OrgsConvertMemberToOutsideCollaboratorReq
}

/*
OrgsCreateInvitation performs requests for "orgs/create-invitation"

Create an organization invitation.

  POST /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
func OrgsCreateInvitation(ctx context.Context, req *OrgsCreateInvitationReq, opt ...options.Option) (*OrgsCreateInvitationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsCreateInvitationReq)
	}
	resp := &OrgsCreateInvitationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrganizationInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsCreateInvitation performs requests for "orgs/create-invitation"

Create an organization invitation.

  POST /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
func (c Client) OrgsCreateInvitation(ctx context.Context, req *OrgsCreateInvitationReq, opt ...options.Option) (*OrgsCreateInvitationResponse, error) {
	return OrgsCreateInvitation(ctx, req, append(c, opt...)...)
}

/*
OrgsCreateInvitationReq is request data for Client.OrgsCreateInvitation

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
type OrgsCreateInvitationReq struct {
	_url        string
	Org         string
	RequestBody OrgsCreateInvitationReqBody
}

// HTTPRequest builds an *http.Request
func (r *OrgsCreateInvitationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsCreateInvitationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "orgs/create-invitation",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/invitations", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsCreateInvitationReq) Rel(link string, resp *OrgsCreateInvitationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsCreateInvitationReqBody is a request body for orgs/create-invitation

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
type OrgsCreateInvitationReqBody struct {

	/*
	**Required unless you provide `invitee_id`**. Email address of the person you
	are inviting, which can be an existing GitHub user.
	*/
	Email *string `json:"email,omitempty"`

	// **Required unless you provide `email`**. GitHub user ID for the person you are inviting.
	InviteeId *int64 `json:"invitee_id,omitempty"`

	/*
	Specify role for new member. Can be one of:
	\* `admin` - Organization owners with full administrative rights to the
	organization and complete access to all repositories and teams.
	\* `direct_member` - Non-owner organization members with ability to see other
	members and join teams by invitation.
	\* `billing_manager` - Non-owner organization members with ability to manage the
	billing settings of your organization.
	*/
	Role *string `json:"role,omitempty"`

	// Specify IDs for the teams you want to invite new members to.
	TeamIds []int64 `json:"team_ids,omitempty"`
}

/*
OrgsCreateInvitationResponse is a response for OrgsCreateInvitation

https://developer.github.com/v3/orgs/members/#create-an-organization-invitation
*/
type OrgsCreateInvitationResponse struct {
	common.Response
	request *OrgsCreateInvitationReq
	Data    components.OrganizationInvitation
}

/*
OrgsCreateWebhook performs requests for "orgs/create-webhook"

Create an organization webhook.

  POST /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
func OrgsCreateWebhook(ctx context.Context, req *OrgsCreateWebhookReq, opt ...options.Option) (*OrgsCreateWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsCreateWebhookReq)
	}
	resp := &OrgsCreateWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgHook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsCreateWebhook performs requests for "orgs/create-webhook"

Create an organization webhook.

  POST /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
func (c Client) OrgsCreateWebhook(ctx context.Context, req *OrgsCreateWebhookReq, opt ...options.Option) (*OrgsCreateWebhookResponse, error) {
	return OrgsCreateWebhook(ctx, req, append(c, opt...)...)
}

/*
OrgsCreateWebhookReq is request data for Client.OrgsCreateWebhook

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
type OrgsCreateWebhookReq struct {
	_url        string
	Org         string
	RequestBody OrgsCreateWebhookReqBody
}

// HTTPRequest builds an *http.Request
func (r *OrgsCreateWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsCreateWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "orgs/create-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/hooks", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsCreateWebhookReq) Rel(link string, resp *OrgsCreateWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// OrgsCreateWebhookReqBodyConfig is a value for OrgsCreateWebhookReqBody's Config field
type OrgsCreateWebhookReqBodyConfig struct {

	// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
	ContentType *string `json:"content_type,omitempty"`

	/*
	Determines whether the SSL certificate of the host for `url` will be verified
	when delivering payloads. Supported values include `0` (verification is
	performed) and `1` (verification is not performed). The default is `0`. **We
	strongly recommend not setting this to `1` as you are subject to
	man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`
	Password    *string `json:"password,omitempty"`

	/*
	If provided, the `secret` will be used as the `key` to generate the HMAC hex
	digest value in the
	[`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url      *string `json:"url"`
	Username *string `json:"username,omitempty"`
}

/*
OrgsCreateWebhookReqBody is a request body for orgs/create-webhook

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
type OrgsCreateWebhookReqBody struct {

	// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
	Active *bool `json:"active,omitempty"`

	/*
	Key/value pairs to provide settings for this webhook. [These are defined
	below](https://developer.github.com/v3/orgs/hooks/#create-hook-config-params).
	*/
	Config *OrgsCreateWebhookReqBodyConfig `json:"config"`

	// Determines what [events](https://developer.github.com/webhooks/event-payloads) the hook is triggered for.
	Events []string `json:"events,omitempty"`

	// Must be passed as "web".
	Name *string `json:"name"`
}

/*
OrgsCreateWebhookResponse is a response for OrgsCreateWebhook

https://developer.github.com/v3/orgs/hooks/#create-an-organization-webhook
*/
type OrgsCreateWebhookResponse struct {
	common.Response
	request *OrgsCreateWebhookReq
	Data    components.OrgHook
}

/*
OrgsDeleteWebhook performs requests for "orgs/delete-webhook"

Delete an organization webhook.

  DELETE /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
func OrgsDeleteWebhook(ctx context.Context, req *OrgsDeleteWebhookReq, opt ...options.Option) (*OrgsDeleteWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsDeleteWebhookReq)
	}
	resp := &OrgsDeleteWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsDeleteWebhook performs requests for "orgs/delete-webhook"

Delete an organization webhook.

  DELETE /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
func (c Client) OrgsDeleteWebhook(ctx context.Context, req *OrgsDeleteWebhookReq, opt ...options.Option) (*OrgsDeleteWebhookResponse, error) {
	return OrgsDeleteWebhook(ctx, req, append(c, opt...)...)
}

/*
OrgsDeleteWebhookReq is request data for Client.OrgsDeleteWebhook

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
type OrgsDeleteWebhookReq struct {
	_url   string
	Org    string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsDeleteWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsDeleteWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "orgs/delete-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsDeleteWebhookReq) Rel(link string, resp *OrgsDeleteWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsDeleteWebhookResponse is a response for OrgsDeleteWebhook

https://developer.github.com/v3/orgs/hooks/#delete-an-organization-webhook
*/
type OrgsDeleteWebhookResponse struct {
	common.Response
	request *OrgsDeleteWebhookReq
	Data    bool
}

/*
OrgsGet performs requests for "orgs/get"

Get an organization.

  GET /orgs/{org}

https://developer.github.com/v3/orgs/#get-an-organization
*/
func OrgsGet(ctx context.Context, req *OrgsGetReq, opt ...options.Option) (*OrgsGetResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsGetReq)
	}
	resp := &OrgsGetResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrganizationFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsGet performs requests for "orgs/get"

Get an organization.

  GET /orgs/{org}

https://developer.github.com/v3/orgs/#get-an-organization
*/
func (c Client) OrgsGet(ctx context.Context, req *OrgsGetReq, opt ...options.Option) (*OrgsGetResponse, error) {
	return OrgsGet(ctx, req, append(c, opt...)...)
}

/*
OrgsGetReq is request data for Client.OrgsGet

https://developer.github.com/v3/orgs/#get-an-organization
*/
type OrgsGetReq struct {
	_url string
	Org  string

	/*
	New repository creation permissions are available to preview. You can now use
	`members_can_create_public_repositories`,
	`members_can_create_private_repositories`, and
	`members_can_create_internal_repositories`. You can only allow members to create
	internal repositories if your organization is associated with an enterprise
	account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. These
	parameters provide more granular permissions to configure the type of
	repositories organization members can create.

	To access these new parameters during the preview period, you must set this to
	true.
	*/
	SurturPreview bool
}

// HTTPRequest builds an *http.Request
func (r *OrgsGetReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsGetReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"surtur"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/get",
		Previews:         map[string]bool{"surtur": r.SurturPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsGetReq) Rel(link string, resp *OrgsGetResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsGetResponse is a response for OrgsGet

https://developer.github.com/v3/orgs/#get-an-organization
*/
type OrgsGetResponse struct {
	common.Response
	request *OrgsGetReq
	Data    components.OrganizationFull
}

/*
OrgsGetMembershipForAuthenticatedUser performs requests for "orgs/get-membership-for-authenticated-user"

Get an organization membership for the authenticated user.

  GET /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
func OrgsGetMembershipForAuthenticatedUser(ctx context.Context, req *OrgsGetMembershipForAuthenticatedUserReq, opt ...options.Option) (*OrgsGetMembershipForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsGetMembershipForAuthenticatedUserReq)
	}
	resp := &OrgsGetMembershipForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsGetMembershipForAuthenticatedUser performs requests for "orgs/get-membership-for-authenticated-user"

Get an organization membership for the authenticated user.

  GET /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
func (c Client) OrgsGetMembershipForAuthenticatedUser(ctx context.Context, req *OrgsGetMembershipForAuthenticatedUserReq, opt ...options.Option) (*OrgsGetMembershipForAuthenticatedUserResponse, error) {
	return OrgsGetMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
OrgsGetMembershipForAuthenticatedUserReq is request data for Client.OrgsGetMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
type OrgsGetMembershipForAuthenticatedUserReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *OrgsGetMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsGetMembershipForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/get-membership-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/memberships/orgs/%v", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsGetMembershipForAuthenticatedUserReq) Rel(link string, resp *OrgsGetMembershipForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsGetMembershipForAuthenticatedUserResponse is a response for OrgsGetMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#get-an-organization-membership-for-the-authenticated-user
*/
type OrgsGetMembershipForAuthenticatedUserResponse struct {
	common.Response
	request *OrgsGetMembershipForAuthenticatedUserReq
	Data    components.OrgMembership
}

/*
OrgsGetMembershipForUser performs requests for "orgs/get-membership-for-user"

Get organization membership for a user.

  GET /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
func OrgsGetMembershipForUser(ctx context.Context, req *OrgsGetMembershipForUserReq, opt ...options.Option) (*OrgsGetMembershipForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsGetMembershipForUserReq)
	}
	resp := &OrgsGetMembershipForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsGetMembershipForUser performs requests for "orgs/get-membership-for-user"

Get organization membership for a user.

  GET /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
func (c Client) OrgsGetMembershipForUser(ctx context.Context, req *OrgsGetMembershipForUserReq, opt ...options.Option) (*OrgsGetMembershipForUserResponse, error) {
	return OrgsGetMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
OrgsGetMembershipForUserReq is request data for Client.OrgsGetMembershipForUser

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
type OrgsGetMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *OrgsGetMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsGetMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/get-membership-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsGetMembershipForUserReq) Rel(link string, resp *OrgsGetMembershipForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsGetMembershipForUserResponse is a response for OrgsGetMembershipForUser

https://developer.github.com/v3/orgs/members/#get-organization-membership-for-a-user
*/
type OrgsGetMembershipForUserResponse struct {
	common.Response
	request *OrgsGetMembershipForUserReq
	Data    components.OrgMembership
}

/*
OrgsGetWebhook performs requests for "orgs/get-webhook"

Get an organization webhook.

  GET /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
func OrgsGetWebhook(ctx context.Context, req *OrgsGetWebhookReq, opt ...options.Option) (*OrgsGetWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsGetWebhookReq)
	}
	resp := &OrgsGetWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgHook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsGetWebhook performs requests for "orgs/get-webhook"

Get an organization webhook.

  GET /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
func (c Client) OrgsGetWebhook(ctx context.Context, req *OrgsGetWebhookReq, opt ...options.Option) (*OrgsGetWebhookResponse, error) {
	return OrgsGetWebhook(ctx, req, append(c, opt...)...)
}

/*
OrgsGetWebhookReq is request data for Client.OrgsGetWebhook

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
type OrgsGetWebhookReq struct {
	_url   string
	Org    string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsGetWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsGetWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/get-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsGetWebhookReq) Rel(link string, resp *OrgsGetWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsGetWebhookResponse is a response for OrgsGetWebhook

https://developer.github.com/v3/orgs/hooks/#get-an-organization-webhook
*/
type OrgsGetWebhookResponse struct {
	common.Response
	request *OrgsGetWebhookReq
	Data    components.OrgHook
}

/*
OrgsList performs requests for "orgs/list"

List organizations.

  GET /organizations

https://developer.github.com/v3/orgs/#list-organizations
*/
func OrgsList(ctx context.Context, req *OrgsListReq, opt ...options.Option) (*OrgsListResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsListReq)
	}
	resp := &OrgsListResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrganizationSimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsList performs requests for "orgs/list"

List organizations.

  GET /organizations

https://developer.github.com/v3/orgs/#list-organizations
*/
func (c Client) OrgsList(ctx context.Context, req *OrgsListReq, opt ...options.Option) (*OrgsListResponse, error) {
	return OrgsList(ctx, req, append(c, opt...)...)
}

/*
OrgsListReq is request data for Client.OrgsList

https://developer.github.com/v3/orgs/#list-organizations
*/
type OrgsListReq struct {
	_url string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string

	// Results per page (max 100)
	PerPage *int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsListReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/list",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/organizations"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListReq) Rel(link string, resp *OrgsListResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListResponse is a response for OrgsList

https://developer.github.com/v3/orgs/#list-organizations
*/
type OrgsListResponse struct {
	common.Response
	request *OrgsListReq
	Data    []components.OrganizationSimple
}

/*
OrgsListAppInstallations performs requests for "orgs/list-app-installations"

List app installations for an organization.

  GET /orgs/{org}/installations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
func OrgsListAppInstallations(ctx context.Context, req *OrgsListAppInstallationsReq, opt ...options.Option) (*OrgsListAppInstallationsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsListAppInstallationsReq)
	}
	resp := &OrgsListAppInstallationsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = OrgsListAppInstallationsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListAppInstallations performs requests for "orgs/list-app-installations"

List app installations for an organization.

  GET /orgs/{org}/installations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
func (c Client) OrgsListAppInstallations(ctx context.Context, req *OrgsListAppInstallationsReq, opt ...options.Option) (*OrgsListAppInstallationsResponse, error) {
	return OrgsListAppInstallations(ctx, req, append(c, opt...)...)
}

/*
OrgsListAppInstallationsReq is request data for Client.OrgsListAppInstallations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
type OrgsListAppInstallationsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	To access the API with your GitHub App, you must set this to true for your
	requests.
	*/
	MachineManPreview bool
}

// HTTPRequest builds an *http.Request
func (r *OrgsListAppInstallationsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsListAppInstallationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"machine-man"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/list-app-installations",
		Previews:         map[string]bool{"machine-man": r.MachineManPreview},
		RequiredPreviews: []string{"machine-man"},
		URLPath:          fmt.Sprintf("/orgs/%v/installations", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListAppInstallationsReq) Rel(link string, resp *OrgsListAppInstallationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListAppInstallationsResponseBody is a response body for OrgsListAppInstallations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
type OrgsListAppInstallationsResponseBody struct {
	Installations []components.Installation `json:"installations,omitempty"`
	TotalCount    int64                     `json:"total_count,omitempty"`
}

/*
OrgsListAppInstallationsResponse is a response for OrgsListAppInstallations

https://developer.github.com/v3/orgs/#list-app-installations-for-an-organization
*/
type OrgsListAppInstallationsResponse struct {
	common.Response
	request *OrgsListAppInstallationsReq
	Data    OrgsListAppInstallationsResponseBody
}

/*
OrgsListBlockedUsers performs requests for "orgs/list-blocked-users"

List users blocked by an organization.

  GET /orgs/{org}/blocks

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
func OrgsListBlockedUsers(ctx context.Context, req *OrgsListBlockedUsersReq, opt ...options.Option) (*OrgsListBlockedUsersResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsListBlockedUsersReq)
	}
	resp := &OrgsListBlockedUsersResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListBlockedUsers performs requests for "orgs/list-blocked-users"

List users blocked by an organization.

  GET /orgs/{org}/blocks

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
func (c Client) OrgsListBlockedUsers(ctx context.Context, req *OrgsListBlockedUsersReq, opt ...options.Option) (*OrgsListBlockedUsersResponse, error) {
	return OrgsListBlockedUsers(ctx, req, append(c, opt...)...)
}

/*
OrgsListBlockedUsersReq is request data for Client.OrgsListBlockedUsers

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
type OrgsListBlockedUsersReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *OrgsListBlockedUsersReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsListBlockedUsersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/list-blocked-users",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/blocks", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListBlockedUsersReq) Rel(link string, resp *OrgsListBlockedUsersResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListBlockedUsersResponse is a response for OrgsListBlockedUsers

https://developer.github.com/v3/orgs/blocking/#list-users-blocked-by-an-organization
*/
type OrgsListBlockedUsersResponse struct {
	common.Response
	request *OrgsListBlockedUsersReq
	Data    []components.SimpleUser
}

/*
OrgsListForAuthenticatedUser performs requests for "orgs/list-for-authenticated-user"

List organizations for the authenticated user.

  GET /user/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
func OrgsListForAuthenticatedUser(ctx context.Context, req *OrgsListForAuthenticatedUserReq, opt ...options.Option) (*OrgsListForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsListForAuthenticatedUserReq)
	}
	resp := &OrgsListForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrganizationSimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListForAuthenticatedUser performs requests for "orgs/list-for-authenticated-user"

List organizations for the authenticated user.

  GET /user/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
func (c Client) OrgsListForAuthenticatedUser(ctx context.Context, req *OrgsListForAuthenticatedUserReq, opt ...options.Option) (*OrgsListForAuthenticatedUserResponse, error) {
	return OrgsListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
OrgsListForAuthenticatedUserReq is request data for Client.OrgsListForAuthenticatedUser

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
type OrgsListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsListForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/list-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/orgs"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListForAuthenticatedUserReq) Rel(link string, resp *OrgsListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListForAuthenticatedUserResponse is a response for OrgsListForAuthenticatedUser

https://developer.github.com/v3/orgs/#list-organizations-for-the-authenticated-user
*/
type OrgsListForAuthenticatedUserResponse struct {
	common.Response
	request *OrgsListForAuthenticatedUserReq
	Data    []components.OrganizationSimple
}

/*
OrgsListForUser performs requests for "orgs/list-for-user"

List organizations for a user.

  GET /users/{username}/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
func OrgsListForUser(ctx context.Context, req *OrgsListForUserReq, opt ...options.Option) (*OrgsListForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsListForUserReq)
	}
	resp := &OrgsListForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrganizationSimple{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListForUser performs requests for "orgs/list-for-user"

List organizations for a user.

  GET /users/{username}/orgs

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
func (c Client) OrgsListForUser(ctx context.Context, req *OrgsListForUserReq, opt ...options.Option) (*OrgsListForUserResponse, error) {
	return OrgsListForUser(ctx, req, append(c, opt...)...)
}

/*
OrgsListForUserReq is request data for Client.OrgsListForUser

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
type OrgsListForUserReq struct {
	_url     string
	Username string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsListForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsListForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/list-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/orgs", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListForUserReq) Rel(link string, resp *OrgsListForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListForUserResponse is a response for OrgsListForUser

https://developer.github.com/v3/orgs/#list-organizations-for-a-user
*/
type OrgsListForUserResponse struct {
	common.Response
	request *OrgsListForUserReq
	Data    []components.OrganizationSimple
}

/*
OrgsListInvitationTeams performs requests for "orgs/list-invitation-teams"

List organization invitation teams.

  GET /orgs/{org}/invitations/{invitation_id}/teams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
func OrgsListInvitationTeams(ctx context.Context, req *OrgsListInvitationTeamsReq, opt ...options.Option) (*OrgsListInvitationTeamsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsListInvitationTeamsReq)
	}
	resp := &OrgsListInvitationTeamsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListInvitationTeams performs requests for "orgs/list-invitation-teams"

List organization invitation teams.

  GET /orgs/{org}/invitations/{invitation_id}/teams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
func (c Client) OrgsListInvitationTeams(ctx context.Context, req *OrgsListInvitationTeamsReq, opt ...options.Option) (*OrgsListInvitationTeamsResponse, error) {
	return OrgsListInvitationTeams(ctx, req, append(c, opt...)...)
}

/*
OrgsListInvitationTeamsReq is request data for Client.OrgsListInvitationTeams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
type OrgsListInvitationTeamsReq struct {
	_url string
	Org  string

	// invitation_id parameter
	InvitationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsListInvitationTeamsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsListInvitationTeamsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/list-invitation-teams",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/invitations/%v/teams", r.Org, r.InvitationId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListInvitationTeamsReq) Rel(link string, resp *OrgsListInvitationTeamsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListInvitationTeamsResponse is a response for OrgsListInvitationTeams

https://developer.github.com/v3/orgs/members/#list-organization-invitation-teams
*/
type OrgsListInvitationTeamsResponse struct {
	common.Response
	request *OrgsListInvitationTeamsReq
	Data    []components.Team
}

/*
OrgsListMembers performs requests for "orgs/list-members"

List organization members.

  GET /orgs/{org}/members

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
func OrgsListMembers(ctx context.Context, req *OrgsListMembersReq, opt ...options.Option) (*OrgsListMembersResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsListMembersReq)
	}
	resp := &OrgsListMembersResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListMembers performs requests for "orgs/list-members"

List organization members.

  GET /orgs/{org}/members

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
func (c Client) OrgsListMembers(ctx context.Context, req *OrgsListMembersReq, opt ...options.Option) (*OrgsListMembersResponse, error) {
	return OrgsListMembers(ctx, req, append(c, opt...)...)
}

/*
OrgsListMembersReq is request data for Client.OrgsListMembers

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
type OrgsListMembersReq struct {
	_url string
	Org  string

	/*
	Filter members returned in the list. Can be one of:
	\* `2fa_disabled` - Members without [two-factor
	authentication](https://github.com/blog/1614-two-factor-authentication) enabled.
	Available for organization owners.
	\* `all` - All members the authenticated user can see.
	*/
	Filter *string

	/*
	Filter members returned by their role. Can be one of:
	\* `all` - All members of the organization, regardless of role.
	\* `admin` - Organization owners.
	\* `member` - Non-owner organization members.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsListMembersReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsListMembersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/list-members",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/members", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200, 302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListMembersReq) Rel(link string, resp *OrgsListMembersResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListMembersResponse is a response for OrgsListMembers

https://developer.github.com/v3/orgs/members/#list-organization-members
*/
type OrgsListMembersResponse struct {
	common.Response
	request *OrgsListMembersReq
	Data    []components.SimpleUser
}

/*
OrgsListMembershipsForAuthenticatedUser performs requests for "orgs/list-memberships-for-authenticated-user"

List organization memberships for the authenticated user.

  GET /user/memberships/orgs

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
func OrgsListMembershipsForAuthenticatedUser(ctx context.Context, req *OrgsListMembershipsForAuthenticatedUserReq, opt ...options.Option) (*OrgsListMembershipsForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsListMembershipsForAuthenticatedUserReq)
	}
	resp := &OrgsListMembershipsForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrgMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListMembershipsForAuthenticatedUser performs requests for "orgs/list-memberships-for-authenticated-user"

List organization memberships for the authenticated user.

  GET /user/memberships/orgs

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
func (c Client) OrgsListMembershipsForAuthenticatedUser(ctx context.Context, req *OrgsListMembershipsForAuthenticatedUserReq, opt ...options.Option) (*OrgsListMembershipsForAuthenticatedUserResponse, error) {
	return OrgsListMembershipsForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
OrgsListMembershipsForAuthenticatedUserReq is request data for Client.OrgsListMembershipsForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
type OrgsListMembershipsForAuthenticatedUserReq struct {
	_url string

	/*
	Indicates the state of the memberships to return. Can be either `active` or
	`pending`. If not specified, the API returns both active and pending
	memberships.
	*/
	State *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsListMembershipsForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsListMembershipsForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.State != nil {
		query.Set("state", *r.State)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/list-memberships-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/memberships/orgs"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListMembershipsForAuthenticatedUserReq) Rel(link string, resp *OrgsListMembershipsForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListMembershipsForAuthenticatedUserResponse is a response for OrgsListMembershipsForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#list-organization-memberships-for-the-authenticated-user
*/
type OrgsListMembershipsForAuthenticatedUserResponse struct {
	common.Response
	request *OrgsListMembershipsForAuthenticatedUserReq
	Data    []components.OrgMembership
}

/*
OrgsListOutsideCollaborators performs requests for "orgs/list-outside-collaborators"

List outside collaborators for an organization.

  GET /orgs/{org}/outside_collaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
func OrgsListOutsideCollaborators(ctx context.Context, req *OrgsListOutsideCollaboratorsReq, opt ...options.Option) (*OrgsListOutsideCollaboratorsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsListOutsideCollaboratorsReq)
	}
	resp := &OrgsListOutsideCollaboratorsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListOutsideCollaborators performs requests for "orgs/list-outside-collaborators"

List outside collaborators for an organization.

  GET /orgs/{org}/outside_collaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
func (c Client) OrgsListOutsideCollaborators(ctx context.Context, req *OrgsListOutsideCollaboratorsReq, opt ...options.Option) (*OrgsListOutsideCollaboratorsResponse, error) {
	return OrgsListOutsideCollaborators(ctx, req, append(c, opt...)...)
}

/*
OrgsListOutsideCollaboratorsReq is request data for Client.OrgsListOutsideCollaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
type OrgsListOutsideCollaboratorsReq struct {
	_url string
	Org  string

	/*
	Filter the list of outside collaborators. Can be one of:
	\* `2fa_disabled`: Outside collaborators without [two-factor
	authentication](https://github.com/blog/1614-two-factor-authentication) enabled.
	\* `all`: All outside collaborators.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsListOutsideCollaboratorsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsListOutsideCollaboratorsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/list-outside-collaborators",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/outside_collaborators", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListOutsideCollaboratorsReq) Rel(link string, resp *OrgsListOutsideCollaboratorsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListOutsideCollaboratorsResponse is a response for OrgsListOutsideCollaborators

https://developer.github.com/v3/orgs/outside_collaborators/#list-outside-collaborators-for-an-organization
*/
type OrgsListOutsideCollaboratorsResponse struct {
	common.Response
	request *OrgsListOutsideCollaboratorsReq
	Data    []components.SimpleUser
}

/*
OrgsListPendingInvitations performs requests for "orgs/list-pending-invitations"

List pending organization invitations.

  GET /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
func OrgsListPendingInvitations(ctx context.Context, req *OrgsListPendingInvitationsReq, opt ...options.Option) (*OrgsListPendingInvitationsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsListPendingInvitationsReq)
	}
	resp := &OrgsListPendingInvitationsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrganizationInvitation{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListPendingInvitations performs requests for "orgs/list-pending-invitations"

List pending organization invitations.

  GET /orgs/{org}/invitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
func (c Client) OrgsListPendingInvitations(ctx context.Context, req *OrgsListPendingInvitationsReq, opt ...options.Option) (*OrgsListPendingInvitationsResponse, error) {
	return OrgsListPendingInvitations(ctx, req, append(c, opt...)...)
}

/*
OrgsListPendingInvitationsReq is request data for Client.OrgsListPendingInvitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
type OrgsListPendingInvitationsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsListPendingInvitationsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsListPendingInvitationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/list-pending-invitations",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/invitations", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListPendingInvitationsReq) Rel(link string, resp *OrgsListPendingInvitationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListPendingInvitationsResponse is a response for OrgsListPendingInvitations

https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations
*/
type OrgsListPendingInvitationsResponse struct {
	common.Response
	request *OrgsListPendingInvitationsReq
	Data    []components.OrganizationInvitation
}

/*
OrgsListPublicMembers performs requests for "orgs/list-public-members"

List public organization members.

  GET /orgs/{org}/public_members

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
func OrgsListPublicMembers(ctx context.Context, req *OrgsListPublicMembersReq, opt ...options.Option) (*OrgsListPublicMembersResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsListPublicMembersReq)
	}
	resp := &OrgsListPublicMembersResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListPublicMembers performs requests for "orgs/list-public-members"

List public organization members.

  GET /orgs/{org}/public_members

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
func (c Client) OrgsListPublicMembers(ctx context.Context, req *OrgsListPublicMembersReq, opt ...options.Option) (*OrgsListPublicMembersResponse, error) {
	return OrgsListPublicMembers(ctx, req, append(c, opt...)...)
}

/*
OrgsListPublicMembersReq is request data for Client.OrgsListPublicMembers

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
type OrgsListPublicMembersReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsListPublicMembersReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsListPublicMembersReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/list-public-members",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/public_members", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListPublicMembersReq) Rel(link string, resp *OrgsListPublicMembersResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListPublicMembersResponse is a response for OrgsListPublicMembers

https://developer.github.com/v3/orgs/members/#list-public-organization-members
*/
type OrgsListPublicMembersResponse struct {
	common.Response
	request *OrgsListPublicMembersReq
	Data    []components.SimpleUser
}

/*
OrgsListSamlSsoAuthorizations performs requests for "orgs/list-saml-sso-authorizations"

List SAML SSO authorizations for an organization.

  GET /orgs/{org}/credential-authorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
func OrgsListSamlSsoAuthorizations(ctx context.Context, req *OrgsListSamlSsoAuthorizationsReq, opt ...options.Option) (*OrgsListSamlSsoAuthorizationsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsListSamlSsoAuthorizationsReq)
	}
	resp := &OrgsListSamlSsoAuthorizationsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.CredentialAuthorization{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListSamlSsoAuthorizations performs requests for "orgs/list-saml-sso-authorizations"

List SAML SSO authorizations for an organization.

  GET /orgs/{org}/credential-authorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
func (c Client) OrgsListSamlSsoAuthorizations(ctx context.Context, req *OrgsListSamlSsoAuthorizationsReq, opt ...options.Option) (*OrgsListSamlSsoAuthorizationsResponse, error) {
	return OrgsListSamlSsoAuthorizations(ctx, req, append(c, opt...)...)
}

/*
OrgsListSamlSsoAuthorizationsReq is request data for Client.OrgsListSamlSsoAuthorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
type OrgsListSamlSsoAuthorizationsReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *OrgsListSamlSsoAuthorizationsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsListSamlSsoAuthorizationsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/list-saml-sso-authorizations",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/credential-authorizations", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListSamlSsoAuthorizationsReq) Rel(link string, resp *OrgsListSamlSsoAuthorizationsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListSamlSsoAuthorizationsResponse is a response for OrgsListSamlSsoAuthorizations

https://developer.github.com/v3/orgs/#list-saml-sso-authorizations-for-an-organization
*/
type OrgsListSamlSsoAuthorizationsResponse struct {
	common.Response
	request *OrgsListSamlSsoAuthorizationsReq
	Data    []components.CredentialAuthorization
}

/*
OrgsListWebhooks performs requests for "orgs/list-webhooks"

List organization webhooks.

  GET /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
func OrgsListWebhooks(ctx context.Context, req *OrgsListWebhooksReq, opt ...options.Option) (*OrgsListWebhooksResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsListWebhooksReq)
	}
	resp := &OrgsListWebhooksResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrgHook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsListWebhooks performs requests for "orgs/list-webhooks"

List organization webhooks.

  GET /orgs/{org}/hooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
func (c Client) OrgsListWebhooks(ctx context.Context, req *OrgsListWebhooksReq, opt ...options.Option) (*OrgsListWebhooksResponse, error) {
	return OrgsListWebhooks(ctx, req, append(c, opt...)...)
}

/*
OrgsListWebhooksReq is request data for Client.OrgsListWebhooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
type OrgsListWebhooksReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsListWebhooksReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsListWebhooksReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "orgs/list-webhooks",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/hooks", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsListWebhooksReq) Rel(link string, resp *OrgsListWebhooksResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsListWebhooksResponse is a response for OrgsListWebhooks

https://developer.github.com/v3/orgs/hooks/#list-organization-webhooks
*/
type OrgsListWebhooksResponse struct {
	common.Response
	request *OrgsListWebhooksReq
	Data    []components.OrgHook
}

/*
OrgsPingWebhook performs requests for "orgs/ping-webhook"

Ping an organization webhook.

  POST /orgs/{org}/hooks/{hook_id}/pings

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
func OrgsPingWebhook(ctx context.Context, req *OrgsPingWebhookReq, opt ...options.Option) (*OrgsPingWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsPingWebhookReq)
	}
	resp := &OrgsPingWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsPingWebhook performs requests for "orgs/ping-webhook"

Ping an organization webhook.

  POST /orgs/{org}/hooks/{hook_id}/pings

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
func (c Client) OrgsPingWebhook(ctx context.Context, req *OrgsPingWebhookReq, opt ...options.Option) (*OrgsPingWebhookResponse, error) {
	return OrgsPingWebhook(ctx, req, append(c, opt...)...)
}

/*
OrgsPingWebhookReq is request data for Client.OrgsPingWebhook

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
type OrgsPingWebhookReq struct {
	_url   string
	Org    string
	HookId int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsPingWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsPingWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "POST",
		OperationID:      "orgs/ping-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/hooks/%v/pings", r.Org, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsPingWebhookReq) Rel(link string, resp *OrgsPingWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsPingWebhookResponse is a response for OrgsPingWebhook

https://developer.github.com/v3/orgs/hooks/#ping-an-organization-webhook
*/
type OrgsPingWebhookResponse struct {
	common.Response
	request *OrgsPingWebhookReq
	Data    bool
}

/*
OrgsRemoveMember performs requests for "orgs/remove-member"

Remove an organization member.

  DELETE /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
func OrgsRemoveMember(ctx context.Context, req *OrgsRemoveMemberReq, opt ...options.Option) (*OrgsRemoveMemberResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsRemoveMemberReq)
	}
	resp := &OrgsRemoveMemberResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsRemoveMember performs requests for "orgs/remove-member"

Remove an organization member.

  DELETE /orgs/{org}/members/{username}

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
func (c Client) OrgsRemoveMember(ctx context.Context, req *OrgsRemoveMemberReq, opt ...options.Option) (*OrgsRemoveMemberResponse, error) {
	return OrgsRemoveMember(ctx, req, append(c, opt...)...)
}

/*
OrgsRemoveMemberReq is request data for Client.OrgsRemoveMember

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
type OrgsRemoveMemberReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *OrgsRemoveMemberReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsRemoveMemberReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "orgs/remove-member",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/members/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsRemoveMemberReq) Rel(link string, resp *OrgsRemoveMemberResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsRemoveMemberResponse is a response for OrgsRemoveMember

https://developer.github.com/v3/orgs/members/#remove-an-organization-member
*/
type OrgsRemoveMemberResponse struct {
	common.Response
	request *OrgsRemoveMemberReq
}

/*
OrgsRemoveMembershipForUser performs requests for "orgs/remove-membership-for-user"

Remove organization membership for a user.

  DELETE /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
func OrgsRemoveMembershipForUser(ctx context.Context, req *OrgsRemoveMembershipForUserReq, opt ...options.Option) (*OrgsRemoveMembershipForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsRemoveMembershipForUserReq)
	}
	resp := &OrgsRemoveMembershipForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsRemoveMembershipForUser performs requests for "orgs/remove-membership-for-user"

Remove organization membership for a user.

  DELETE /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
func (c Client) OrgsRemoveMembershipForUser(ctx context.Context, req *OrgsRemoveMembershipForUserReq, opt ...options.Option) (*OrgsRemoveMembershipForUserResponse, error) {
	return OrgsRemoveMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
OrgsRemoveMembershipForUserReq is request data for Client.OrgsRemoveMembershipForUser

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
type OrgsRemoveMembershipForUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *OrgsRemoveMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsRemoveMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "orgs/remove-membership-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsRemoveMembershipForUserReq) Rel(link string, resp *OrgsRemoveMembershipForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsRemoveMembershipForUserResponse is a response for OrgsRemoveMembershipForUser

https://developer.github.com/v3/orgs/members/#remove-organization-membership-for-a-user
*/
type OrgsRemoveMembershipForUserResponse struct {
	common.Response
	request *OrgsRemoveMembershipForUserReq
}

/*
OrgsRemoveOutsideCollaborator performs requests for "orgs/remove-outside-collaborator"

Remove outside collaborator from an organization.

  DELETE /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
func OrgsRemoveOutsideCollaborator(ctx context.Context, req *OrgsRemoveOutsideCollaboratorReq, opt ...options.Option) (*OrgsRemoveOutsideCollaboratorResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsRemoveOutsideCollaboratorReq)
	}
	resp := &OrgsRemoveOutsideCollaboratorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsRemoveOutsideCollaborator performs requests for "orgs/remove-outside-collaborator"

Remove outside collaborator from an organization.

  DELETE /orgs/{org}/outside_collaborators/{username}

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
func (c Client) OrgsRemoveOutsideCollaborator(ctx context.Context, req *OrgsRemoveOutsideCollaboratorReq, opt ...options.Option) (*OrgsRemoveOutsideCollaboratorResponse, error) {
	return OrgsRemoveOutsideCollaborator(ctx, req, append(c, opt...)...)
}

/*
OrgsRemoveOutsideCollaboratorReq is request data for Client.OrgsRemoveOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
type OrgsRemoveOutsideCollaboratorReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *OrgsRemoveOutsideCollaboratorReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsRemoveOutsideCollaboratorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "orgs/remove-outside-collaborator",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/outside_collaborators/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsRemoveOutsideCollaboratorReq) Rel(link string, resp *OrgsRemoveOutsideCollaboratorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsRemoveOutsideCollaboratorResponse is a response for OrgsRemoveOutsideCollaborator

https://developer.github.com/v3/orgs/outside_collaborators/#remove-outside-collaborator-from-an-organization
*/
type OrgsRemoveOutsideCollaboratorResponse struct {
	common.Response
	request *OrgsRemoveOutsideCollaboratorReq
}

/*
OrgsRemovePublicMembershipForAuthenticatedUser performs requests for "orgs/remove-public-membership-for-authenticated-user"

Remove public organization membership for the authenticated user.

  DELETE /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
func OrgsRemovePublicMembershipForAuthenticatedUser(ctx context.Context, req *OrgsRemovePublicMembershipForAuthenticatedUserReq, opt ...options.Option) (*OrgsRemovePublicMembershipForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsRemovePublicMembershipForAuthenticatedUserReq)
	}
	resp := &OrgsRemovePublicMembershipForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsRemovePublicMembershipForAuthenticatedUser performs requests for "orgs/remove-public-membership-for-authenticated-user"

Remove public organization membership for the authenticated user.

  DELETE /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
func (c Client) OrgsRemovePublicMembershipForAuthenticatedUser(ctx context.Context, req *OrgsRemovePublicMembershipForAuthenticatedUserReq, opt ...options.Option) (*OrgsRemovePublicMembershipForAuthenticatedUserResponse, error) {
	return OrgsRemovePublicMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
OrgsRemovePublicMembershipForAuthenticatedUserReq is request data for Client.OrgsRemovePublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
type OrgsRemovePublicMembershipForAuthenticatedUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *OrgsRemovePublicMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsRemovePublicMembershipForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "orgs/remove-public-membership-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsRemovePublicMembershipForAuthenticatedUserReq) Rel(link string, resp *OrgsRemovePublicMembershipForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsRemovePublicMembershipForAuthenticatedUserResponse is a response for OrgsRemovePublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#remove-public-organization-membership-for-the-authenticated-user
*/
type OrgsRemovePublicMembershipForAuthenticatedUserResponse struct {
	common.Response
	request *OrgsRemovePublicMembershipForAuthenticatedUserReq
}

/*
OrgsRemoveSamlSsoAuthorization performs requests for "orgs/remove-saml-sso-authorization"

Remove a SAML SSO authorization for an organization.

  DELETE /orgs/{org}/credential-authorizations/{credential_id}

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
func OrgsRemoveSamlSsoAuthorization(ctx context.Context, req *OrgsRemoveSamlSsoAuthorizationReq, opt ...options.Option) (*OrgsRemoveSamlSsoAuthorizationResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsRemoveSamlSsoAuthorizationReq)
	}
	resp := &OrgsRemoveSamlSsoAuthorizationResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsRemoveSamlSsoAuthorization performs requests for "orgs/remove-saml-sso-authorization"

Remove a SAML SSO authorization for an organization.

  DELETE /orgs/{org}/credential-authorizations/{credential_id}

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
func (c Client) OrgsRemoveSamlSsoAuthorization(ctx context.Context, req *OrgsRemoveSamlSsoAuthorizationReq, opt ...options.Option) (*OrgsRemoveSamlSsoAuthorizationResponse, error) {
	return OrgsRemoveSamlSsoAuthorization(ctx, req, append(c, opt...)...)
}

/*
OrgsRemoveSamlSsoAuthorizationReq is request data for Client.OrgsRemoveSamlSsoAuthorization

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
type OrgsRemoveSamlSsoAuthorizationReq struct {
	_url string
	Org  string

	// credential_id parameter
	CredentialId int64
}

// HTTPRequest builds an *http.Request
func (r *OrgsRemoveSamlSsoAuthorizationReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsRemoveSamlSsoAuthorizationReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "orgs/remove-saml-sso-authorization",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/credential-authorizations/%v", r.Org, r.CredentialId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsRemoveSamlSsoAuthorizationReq) Rel(link string, resp *OrgsRemoveSamlSsoAuthorizationResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsRemoveSamlSsoAuthorizationResponse is a response for OrgsRemoveSamlSsoAuthorization

https://developer.github.com/v3/orgs/#remove-a-saml-sso-authorization-for-an-organization
*/
type OrgsRemoveSamlSsoAuthorizationResponse struct {
	common.Response
	request *OrgsRemoveSamlSsoAuthorizationReq
	Data    bool
}

/*
OrgsSetMembershipForUser performs requests for "orgs/set-membership-for-user"

Set organization membership for a user.

  PUT /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
func OrgsSetMembershipForUser(ctx context.Context, req *OrgsSetMembershipForUserReq, opt ...options.Option) (*OrgsSetMembershipForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsSetMembershipForUserReq)
	}
	resp := &OrgsSetMembershipForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsSetMembershipForUser performs requests for "orgs/set-membership-for-user"

Set organization membership for a user.

  PUT /orgs/{org}/memberships/{username}

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
func (c Client) OrgsSetMembershipForUser(ctx context.Context, req *OrgsSetMembershipForUserReq, opt ...options.Option) (*OrgsSetMembershipForUserResponse, error) {
	return OrgsSetMembershipForUser(ctx, req, append(c, opt...)...)
}

/*
OrgsSetMembershipForUserReq is request data for Client.OrgsSetMembershipForUser

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
type OrgsSetMembershipForUserReq struct {
	_url        string
	Org         string
	Username    string
	RequestBody OrgsSetMembershipForUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *OrgsSetMembershipForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsSetMembershipForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "orgs/set-membership-for-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/memberships/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsSetMembershipForUserReq) Rel(link string, resp *OrgsSetMembershipForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsSetMembershipForUserReqBody is a request body for orgs/set-membership-for-user

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
type OrgsSetMembershipForUserReqBody struct {

	/*
	The role to give the user in the organization. Can be one of:
	\* `admin` - The user will become an owner of the organization.
	\* `member` - The user will become a non-owner member of the organization.
	*/
	Role *string `json:"role,omitempty"`
}

/*
OrgsSetMembershipForUserResponse is a response for OrgsSetMembershipForUser

https://developer.github.com/v3/orgs/members/#set-organization-membership-for-a-user
*/
type OrgsSetMembershipForUserResponse struct {
	common.Response
	request *OrgsSetMembershipForUserReq
	Data    components.OrgMembership
}

/*
OrgsSetPublicMembershipForAuthenticatedUser performs requests for "orgs/set-public-membership-for-authenticated-user"

Set public organization membership for the authenticated user.

  PUT /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
func OrgsSetPublicMembershipForAuthenticatedUser(ctx context.Context, req *OrgsSetPublicMembershipForAuthenticatedUserReq, opt ...options.Option) (*OrgsSetPublicMembershipForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsSetPublicMembershipForAuthenticatedUserReq)
	}
	resp := &OrgsSetPublicMembershipForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsSetPublicMembershipForAuthenticatedUser performs requests for "orgs/set-public-membership-for-authenticated-user"

Set public organization membership for the authenticated user.

  PUT /orgs/{org}/public_members/{username}

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
func (c Client) OrgsSetPublicMembershipForAuthenticatedUser(ctx context.Context, req *OrgsSetPublicMembershipForAuthenticatedUserReq, opt ...options.Option) (*OrgsSetPublicMembershipForAuthenticatedUserResponse, error) {
	return OrgsSetPublicMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
OrgsSetPublicMembershipForAuthenticatedUserReq is request data for Client.OrgsSetPublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
type OrgsSetPublicMembershipForAuthenticatedUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *OrgsSetPublicMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsSetPublicMembershipForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "orgs/set-public-membership-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/public_members/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsSetPublicMembershipForAuthenticatedUserReq) Rel(link string, resp *OrgsSetPublicMembershipForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsSetPublicMembershipForAuthenticatedUserResponse is a response for OrgsSetPublicMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#set-public-organization-membership-for-the-authenticated-user
*/
type OrgsSetPublicMembershipForAuthenticatedUserResponse struct {
	common.Response
	request *OrgsSetPublicMembershipForAuthenticatedUserReq
}

/*
OrgsUnblockUser performs requests for "orgs/unblock-user"

Unblock a user from an organization.

  DELETE /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
func OrgsUnblockUser(ctx context.Context, req *OrgsUnblockUserReq, opt ...options.Option) (*OrgsUnblockUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsUnblockUserReq)
	}
	resp := &OrgsUnblockUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsUnblockUser performs requests for "orgs/unblock-user"

Unblock a user from an organization.

  DELETE /orgs/{org}/blocks/{username}

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
func (c Client) OrgsUnblockUser(ctx context.Context, req *OrgsUnblockUserReq, opt ...options.Option) (*OrgsUnblockUserResponse, error) {
	return OrgsUnblockUser(ctx, req, append(c, opt...)...)
}

/*
OrgsUnblockUserReq is request data for Client.OrgsUnblockUser

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
type OrgsUnblockUserReq struct {
	_url     string
	Org      string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *OrgsUnblockUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsUnblockUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "orgs/unblock-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/blocks/%v", r.Org, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsUnblockUserReq) Rel(link string, resp *OrgsUnblockUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsUnblockUserResponse is a response for OrgsUnblockUser

https://developer.github.com/v3/orgs/blocking/#unblock-a-user-from-an-organization
*/
type OrgsUnblockUserResponse struct {
	common.Response
	request *OrgsUnblockUserReq
}

/*
OrgsUpdate performs requests for "orgs/update"

Update an organization.

  PATCH /orgs/{org}

https://developer.github.com/v3/orgs/#update-an-organization
*/
func OrgsUpdate(ctx context.Context, req *OrgsUpdateReq, opt ...options.Option) (*OrgsUpdateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsUpdateReq)
	}
	resp := &OrgsUpdateResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrganizationFull{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsUpdate performs requests for "orgs/update"

Update an organization.

  PATCH /orgs/{org}

https://developer.github.com/v3/orgs/#update-an-organization
*/
func (c Client) OrgsUpdate(ctx context.Context, req *OrgsUpdateReq, opt ...options.Option) (*OrgsUpdateResponse, error) {
	return OrgsUpdate(ctx, req, append(c, opt...)...)
}

/*
OrgsUpdateReq is request data for Client.OrgsUpdate

https://developer.github.com/v3/orgs/#update-an-organization
*/
type OrgsUpdateReq struct {
	_url        string
	Org         string
	RequestBody OrgsUpdateReqBody

	/*
	New repository creation permissions are available to preview. You can now use
	`members_can_create_public_repositories`,
	`members_can_create_private_repositories`, and
	`members_can_create_internal_repositories`. You can only allow members to create
	internal repositories if your organization is associated with an enterprise
	account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. These
	parameters provide more granular permissions to configure the type of
	repositories organization members can create.

	To access these new parameters during the preview period, you must set this to
	true.
	*/
	SurturPreview bool
}

// HTTPRequest builds an *http.Request
func (r *OrgsUpdateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsUpdateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"surtur"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "orgs/update",
		Previews:         map[string]bool{"surtur": r.SurturPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsUpdateReq) Rel(link string, resp *OrgsUpdateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsUpdateReqBody is a request body for orgs/update

https://developer.github.com/v3/orgs/#update-an-organization
*/
type OrgsUpdateReqBody struct {

	// Billing email address. This address is not publicized.
	BillingEmail *string `json:"billing_email,omitempty"`
	Blog         *string `json:"blog,omitempty"`

	// The company name.
	Company *string `json:"company,omitempty"`

	/*
	Default permission level members have for organization repositories:
	\* `read` - can pull, but not push to or administer this repository.
	\* `write` - can pull and push, but not administer this repository.
	\* `admin` - can pull, push, and administer this repository.
	\* `none` - no permissions granted by default.
	*/
	DefaultRepositoryPermission *string `json:"default_repository_permission,omitempty"`

	// The description of the company.
	Description *string `json:"description,omitempty"`

	// The publicly visible email address.
	Email *string `json:"email,omitempty"`

	// Toggles whether an organization can use organization projects.
	HasOrganizationProjects *bool `json:"has_organization_projects,omitempty"`

	// Toggles whether repositories that belong to the organization can use repository projects.
	HasRepositoryProjects *bool `json:"has_repository_projects,omitempty"`

	// The location.
	Location *string `json:"location,omitempty"`

	/*
	Specifies which types of repositories non-admin organization members can create.
	Can be one of:
	\* `all` - all organization members can create public and private repositories.
	\* `private` - members can create private repositories. This option is only
	available to repositories that are part of an organization on GitHub Enterprise
	Cloud.
	\* `none` - only admin members can create repositories.
	**Note:** This parameter is deprecated and will be removed in the future. Its
	return value ignores internal repositories. Using this parameter overrides
	values set in `members_can_create_repositories`. See [this
	note](https://developer.github.com/v3/orgs/#members_can_create_repositories) for
	details.
	*/
	MembersAllowedRepositoryCreationType *string `json:"members_allowed_repository_creation_type,omitempty"`

	/*
	Toggles whether organization members can create internal repositories, which are
	visible to all enterprise members. You can only allow members to create internal
	repositories if your organization is associated with an enterprise account using
	GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. Can be one of:
	\* `true` - all organization members can create internal repositories.
	\* `false` - only organization owners can create internal repositories.
	Default: `true`. For more information, see "[Restricting repository creation in
	your
	organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	in the GitHub Help documentation.
	*/
	MembersCanCreateInternalRepositories *bool `json:"members_can_create_internal_repositories,omitempty"`

	/*
	Toggles whether organization members can create private repositories, which are
	visible to organization members with permission. Can be one of:
	\* `true` - all organization members can create private repositories.
	\* `false` - only organization owners can create private repositories.
	Default: `true`. For more information, see "[Restricting repository creation in
	your
	organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	in the GitHub Help documentation.
	*/
	MembersCanCreatePrivateRepositories *bool `json:"members_can_create_private_repositories,omitempty"`

	/*
	Toggles whether organization members can create public repositories, which are
	visible to anyone. Can be one of:
	\* `true` - all organization members can create public repositories.
	\* `false` - only organization owners can create public repositories.
	Default: `true`. For more information, see "[Restricting repository creation in
	your
	organization](https://help.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)"
	in the GitHub Help documentation.
	*/
	MembersCanCreatePublicRepositories *bool `json:"members_can_create_public_repositories,omitempty"`

	/*
	Toggles the ability of non-admin organization members to create repositories.
	Can be one of:
	\* `true` - all organization members can create repositories.
	\* `false` - only organization owners can create repositories.
	Default: `true`
	**Note:** A parameter can override this parameter. See
	`members_allowed_repository_creation_type` in this table for details. **Note:**
	A parameter can override this parameter. See
	`members_allowed_repository_creation_type` in this table for details.
	*/
	MembersCanCreateRepositories *bool `json:"members_can_create_repositories,omitempty"`

	// The shorthand name of the company.
	Name *string `json:"name,omitempty"`

	// The Twitter username of the company.
	TwitterUsername *string `json:"twitter_username,omitempty"`
}

/*
OrgsUpdateResponse is a response for OrgsUpdate

https://developer.github.com/v3/orgs/#update-an-organization
*/
type OrgsUpdateResponse struct {
	common.Response
	request *OrgsUpdateReq
	Data    components.OrganizationFull
}

/*
OrgsUpdateMembershipForAuthenticatedUser performs requests for "orgs/update-membership-for-authenticated-user"

Update an organization membership for the authenticated user.

  PATCH /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
func OrgsUpdateMembershipForAuthenticatedUser(ctx context.Context, req *OrgsUpdateMembershipForAuthenticatedUserReq, opt ...options.Option) (*OrgsUpdateMembershipForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsUpdateMembershipForAuthenticatedUserReq)
	}
	resp := &OrgsUpdateMembershipForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgMembership{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsUpdateMembershipForAuthenticatedUser performs requests for "orgs/update-membership-for-authenticated-user"

Update an organization membership for the authenticated user.

  PATCH /user/memberships/orgs/{org}

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
func (c Client) OrgsUpdateMembershipForAuthenticatedUser(ctx context.Context, req *OrgsUpdateMembershipForAuthenticatedUserReq, opt ...options.Option) (*OrgsUpdateMembershipForAuthenticatedUserResponse, error) {
	return OrgsUpdateMembershipForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
OrgsUpdateMembershipForAuthenticatedUserReq is request data for Client.OrgsUpdateMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
type OrgsUpdateMembershipForAuthenticatedUserReq struct {
	_url        string
	Org         string
	RequestBody OrgsUpdateMembershipForAuthenticatedUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *OrgsUpdateMembershipForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsUpdateMembershipForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "orgs/update-membership-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/memberships/orgs/%v", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsUpdateMembershipForAuthenticatedUserReq) Rel(link string, resp *OrgsUpdateMembershipForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
OrgsUpdateMembershipForAuthenticatedUserReqBody is a request body for orgs/update-membership-for-authenticated-user

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
type OrgsUpdateMembershipForAuthenticatedUserReqBody struct {

	// The state that the membership should be in. Only `"active"` will be accepted.
	State *string `json:"state"`
}

/*
OrgsUpdateMembershipForAuthenticatedUserResponse is a response for OrgsUpdateMembershipForAuthenticatedUser

https://developer.github.com/v3/orgs/members/#update-an-organization-membership-for-the-authenticated-user
*/
type OrgsUpdateMembershipForAuthenticatedUserResponse struct {
	common.Response
	request *OrgsUpdateMembershipForAuthenticatedUserReq
	Data    components.OrgMembership
}

/*
OrgsUpdateWebhook performs requests for "orgs/update-webhook"

Update an organization webhook.

  PATCH /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
func OrgsUpdateWebhook(ctx context.Context, req *OrgsUpdateWebhookReq, opt ...options.Option) (*OrgsUpdateWebhookResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(OrgsUpdateWebhookReq)
	}
	resp := &OrgsUpdateWebhookResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrgHook{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
OrgsUpdateWebhook performs requests for "orgs/update-webhook"

Update an organization webhook.

  PATCH /orgs/{org}/hooks/{hook_id}

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
func (c Client) OrgsUpdateWebhook(ctx context.Context, req *OrgsUpdateWebhookReq, opt ...options.Option) (*OrgsUpdateWebhookResponse, error) {
	return OrgsUpdateWebhook(ctx, req, append(c, opt...)...)
}

/*
OrgsUpdateWebhookReq is request data for Client.OrgsUpdateWebhook

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
type OrgsUpdateWebhookReq struct {
	_url        string
	Org         string
	HookId      int64
	RequestBody OrgsUpdateWebhookReqBody
}

// HTTPRequest builds an *http.Request
func (r *OrgsUpdateWebhookReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *OrgsUpdateWebhookReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "orgs/update-webhook",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/hooks/%v", r.Org, r.HookId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *OrgsUpdateWebhookReq) Rel(link string, resp *OrgsUpdateWebhookResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// OrgsUpdateWebhookReqBodyConfig is a value for OrgsUpdateWebhookReqBody's Config field
type OrgsUpdateWebhookReqBodyConfig struct {

	// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
	ContentType *string `json:"content_type,omitempty"`

	/*
	Determines whether the SSL certificate of the host for `url` will be verified
	when delivering payloads. Supported values include `0` (verification is
	performed) and `1` (verification is not performed). The default is `0`. **We
	strongly recommend not setting this to `1` as you are subject to
	man-in-the-middle and other attacks.**
	*/
	InsecureSsl *string `json:"insecure_ssl,omitempty"`

	/*
	If provided, the `secret` will be used as the `key` to generate the HMAC hex
	digest value in the
	[`X-Hub-Signature`](https://developer.github.com/webhooks/event-payloads/#delivery-headers)
	header.
	*/
	Secret *string `json:"secret,omitempty"`

	// The URL to which the payloads will be delivered.
	Url *string `json:"url"`
}

/*
OrgsUpdateWebhookReqBody is a request body for orgs/update-webhook

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
type OrgsUpdateWebhookReqBody struct {

	// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
	Active *bool `json:"active,omitempty"`

	/*
	Key/value pairs to provide settings for this webhook. [These are defined
	below](https://developer.github.com/v3/orgs/hooks/#update-hook-config-params).
	*/
	Config *OrgsUpdateWebhookReqBodyConfig `json:"config,omitempty"`

	// Determines what [events](https://developer.github.com/webhooks/event-payloads) the hook is triggered for.
	Events []string `json:"events,omitempty"`
	Name   *string  `json:"name,omitempty"`
}

/*
OrgsUpdateWebhookResponse is a response for OrgsUpdateWebhook

https://developer.github.com/v3/orgs/hooks/#update-an-organization-webhook
*/
type OrgsUpdateWebhookResponse struct {
	common.Response
	request *OrgsUpdateWebhookReq
	Data    components.OrgHook
}
