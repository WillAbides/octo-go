// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
MigrationsCancelImport performs requests for "migrations/cancel-import"

Cancel an import.

  DELETE /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
func MigrationsCancelImport(ctx context.Context, req *MigrationsCancelImportReq, opt ...options.Option) (*MigrationsCancelImportResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsCancelImportReq)
	}
	resp := &MigrationsCancelImportResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsCancelImport performs requests for "migrations/cancel-import"

Cancel an import.

  DELETE /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
func (c Client) MigrationsCancelImport(ctx context.Context, req *MigrationsCancelImportReq, opt ...options.Option) (*MigrationsCancelImportResponse, error) {
	return MigrationsCancelImport(ctx, req, append(c, opt...)...)
}

/*
MigrationsCancelImportReq is request data for Client.MigrationsCancelImport

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
type MigrationsCancelImportReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *MigrationsCancelImportReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsCancelImportReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "migrations/cancel-import",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsCancelImportReq) Rel(link RelName, resp *MigrationsCancelImportResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsCancelImportResponse is a response for MigrationsCancelImport

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
type MigrationsCancelImportResponse struct {
	common.Response
	request *MigrationsCancelImportReq
}

/*
MigrationsDeleteArchiveForAuthenticatedUser performs requests for "migrations/delete-archive-for-authenticated-user"

Delete a user migration archive.

  DELETE /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
func MigrationsDeleteArchiveForAuthenticatedUser(ctx context.Context, req *MigrationsDeleteArchiveForAuthenticatedUserReq, opt ...options.Option) (*MigrationsDeleteArchiveForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsDeleteArchiveForAuthenticatedUserReq)
	}
	resp := &MigrationsDeleteArchiveForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsDeleteArchiveForAuthenticatedUser performs requests for "migrations/delete-archive-for-authenticated-user"

Delete a user migration archive.

  DELETE /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
func (c Client) MigrationsDeleteArchiveForAuthenticatedUser(ctx context.Context, req *MigrationsDeleteArchiveForAuthenticatedUserReq, opt ...options.Option) (*MigrationsDeleteArchiveForAuthenticatedUserResponse, error) {
	return MigrationsDeleteArchiveForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
MigrationsDeleteArchiveForAuthenticatedUserReq is request data for Client.MigrationsDeleteArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
type MigrationsDeleteArchiveForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "migrations/delete-archive-for-authenticated-user",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v/archive", r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) Rel(link RelName, resp *MigrationsDeleteArchiveForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsDeleteArchiveForAuthenticatedUserResponse is a response for MigrationsDeleteArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
type MigrationsDeleteArchiveForAuthenticatedUserResponse struct {
	common.Response
	request *MigrationsDeleteArchiveForAuthenticatedUserReq
}

/*
MigrationsDeleteArchiveForOrg performs requests for "migrations/delete-archive-for-org"

Delete an organization migration archive.

  DELETE /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
func MigrationsDeleteArchiveForOrg(ctx context.Context, req *MigrationsDeleteArchiveForOrgReq, opt ...options.Option) (*MigrationsDeleteArchiveForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsDeleteArchiveForOrgReq)
	}
	resp := &MigrationsDeleteArchiveForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsDeleteArchiveForOrg performs requests for "migrations/delete-archive-for-org"

Delete an organization migration archive.

  DELETE /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
func (c Client) MigrationsDeleteArchiveForOrg(ctx context.Context, req *MigrationsDeleteArchiveForOrgReq, opt ...options.Option) (*MigrationsDeleteArchiveForOrgResponse, error) {
	return MigrationsDeleteArchiveForOrg(ctx, req, append(c, opt...)...)
}

/*
MigrationsDeleteArchiveForOrgReq is request data for Client.MigrationsDeleteArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
type MigrationsDeleteArchiveForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *MigrationsDeleteArchiveForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsDeleteArchiveForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "migrations/delete-archive-for-org",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v/archive", r.Org, r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsDeleteArchiveForOrgReq) Rel(link RelName, resp *MigrationsDeleteArchiveForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsDeleteArchiveForOrgResponse is a response for MigrationsDeleteArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
type MigrationsDeleteArchiveForOrgResponse struct {
	common.Response
	request *MigrationsDeleteArchiveForOrgReq
	Data    bool
}

/*
MigrationsDownloadArchiveForOrg performs requests for "migrations/download-archive-for-org"

Download an organization migration archive.

  GET /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
func MigrationsDownloadArchiveForOrg(ctx context.Context, req *MigrationsDownloadArchiveForOrgReq, opt ...options.Option) (*MigrationsDownloadArchiveForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsDownloadArchiveForOrgReq)
	}
	resp := &MigrationsDownloadArchiveForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsDownloadArchiveForOrg performs requests for "migrations/download-archive-for-org"

Download an organization migration archive.

  GET /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
func (c Client) MigrationsDownloadArchiveForOrg(ctx context.Context, req *MigrationsDownloadArchiveForOrgReq, opt ...options.Option) (*MigrationsDownloadArchiveForOrgResponse, error) {
	return MigrationsDownloadArchiveForOrg(ctx, req, append(c, opt...)...)
}

/*
MigrationsDownloadArchiveForOrgReq is request data for Client.MigrationsDownloadArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
type MigrationsDownloadArchiveForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *MigrationsDownloadArchiveForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsDownloadArchiveForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "migrations/download-archive-for-org",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v/archive", r.Org, r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsDownloadArchiveForOrgReq) Rel(link RelName, resp *MigrationsDownloadArchiveForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsDownloadArchiveForOrgResponse is a response for MigrationsDownloadArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
type MigrationsDownloadArchiveForOrgResponse struct {
	common.Response
	request *MigrationsDownloadArchiveForOrgReq
}

/*
MigrationsGetArchiveForAuthenticatedUser performs requests for "migrations/get-archive-for-authenticated-user"

Download a user migration archive.

  GET /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
func MigrationsGetArchiveForAuthenticatedUser(ctx context.Context, req *MigrationsGetArchiveForAuthenticatedUserReq, opt ...options.Option) (*MigrationsGetArchiveForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsGetArchiveForAuthenticatedUserReq)
	}
	resp := &MigrationsGetArchiveForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsGetArchiveForAuthenticatedUser performs requests for "migrations/get-archive-for-authenticated-user"

Download a user migration archive.

  GET /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
func (c Client) MigrationsGetArchiveForAuthenticatedUser(ctx context.Context, req *MigrationsGetArchiveForAuthenticatedUserReq, opt ...options.Option) (*MigrationsGetArchiveForAuthenticatedUserResponse, error) {
	return MigrationsGetArchiveForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
MigrationsGetArchiveForAuthenticatedUserReq is request data for Client.MigrationsGetArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
type MigrationsGetArchiveForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *MigrationsGetArchiveForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "migrations/get-archive-for-authenticated-user",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v/archive", r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{302, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsGetArchiveForAuthenticatedUserReq) Rel(link RelName, resp *MigrationsGetArchiveForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsGetArchiveForAuthenticatedUserResponse is a response for MigrationsGetArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
type MigrationsGetArchiveForAuthenticatedUserResponse struct {
	common.Response
	request *MigrationsGetArchiveForAuthenticatedUserReq
}

/*
MigrationsGetCommitAuthors performs requests for "migrations/get-commit-authors"

Get commit authors.

  GET /repos/{owner}/{repo}/import/authors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
func MigrationsGetCommitAuthors(ctx context.Context, req *MigrationsGetCommitAuthorsReq, opt ...options.Option) (*MigrationsGetCommitAuthorsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsGetCommitAuthorsReq)
	}
	resp := &MigrationsGetCommitAuthorsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.PorterAuthor{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsGetCommitAuthors performs requests for "migrations/get-commit-authors"

Get commit authors.

  GET /repos/{owner}/{repo}/import/authors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
func (c Client) MigrationsGetCommitAuthors(ctx context.Context, req *MigrationsGetCommitAuthorsReq, opt ...options.Option) (*MigrationsGetCommitAuthorsResponse, error) {
	return MigrationsGetCommitAuthors(ctx, req, append(c, opt...)...)
}

/*
MigrationsGetCommitAuthorsReq is request data for Client.MigrationsGetCommitAuthors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
type MigrationsGetCommitAuthorsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Only show notifications updated after the given time. This is a timestamp in
	[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
	`YYYY-MM-DDTHH:MM:SSZ`.
	*/
	Since *string
}

// HTTPRequest builds an *http.Request
func (r *MigrationsGetCommitAuthorsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsGetCommitAuthorsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/get-commit-authors",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import/authors", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsGetCommitAuthorsReq) Rel(link RelName, resp *MigrationsGetCommitAuthorsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsGetCommitAuthorsResponse is a response for MigrationsGetCommitAuthors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
type MigrationsGetCommitAuthorsResponse struct {
	common.Response
	request *MigrationsGetCommitAuthorsReq
	Data    []components.PorterAuthor
}

/*
MigrationsGetImportStatus performs requests for "migrations/get-import-status"

Get an import status.

  GET /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
func MigrationsGetImportStatus(ctx context.Context, req *MigrationsGetImportStatusReq, opt ...options.Option) (*MigrationsGetImportStatusResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsGetImportStatusReq)
	}
	resp := &MigrationsGetImportStatusResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Import{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsGetImportStatus performs requests for "migrations/get-import-status"

Get an import status.

  GET /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
func (c Client) MigrationsGetImportStatus(ctx context.Context, req *MigrationsGetImportStatusReq, opt ...options.Option) (*MigrationsGetImportStatusResponse, error) {
	return MigrationsGetImportStatus(ctx, req, append(c, opt...)...)
}

/*
MigrationsGetImportStatusReq is request data for Client.MigrationsGetImportStatus

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
type MigrationsGetImportStatusReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *MigrationsGetImportStatusReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsGetImportStatusReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/get-import-status",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsGetImportStatusReq) Rel(link RelName, resp *MigrationsGetImportStatusResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsGetImportStatusResponse is a response for MigrationsGetImportStatus

https://developer.github.com/v3/migrations/source_imports/#get-an-import-status
*/
type MigrationsGetImportStatusResponse struct {
	common.Response
	request *MigrationsGetImportStatusReq
	Data    components.Import
}

/*
MigrationsGetLargeFiles performs requests for "migrations/get-large-files"

Get large files.

  GET /repos/{owner}/{repo}/import/large_files

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
func MigrationsGetLargeFiles(ctx context.Context, req *MigrationsGetLargeFilesReq, opt ...options.Option) (*MigrationsGetLargeFilesResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsGetLargeFilesReq)
	}
	resp := &MigrationsGetLargeFilesResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.PorterLargeFile{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsGetLargeFiles performs requests for "migrations/get-large-files"

Get large files.

  GET /repos/{owner}/{repo}/import/large_files

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
func (c Client) MigrationsGetLargeFiles(ctx context.Context, req *MigrationsGetLargeFilesReq, opt ...options.Option) (*MigrationsGetLargeFilesResponse, error) {
	return MigrationsGetLargeFiles(ctx, req, append(c, opt...)...)
}

/*
MigrationsGetLargeFilesReq is request data for Client.MigrationsGetLargeFiles

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
type MigrationsGetLargeFilesReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *MigrationsGetLargeFilesReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsGetLargeFilesReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/get-large-files",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import/large_files", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsGetLargeFilesReq) Rel(link RelName, resp *MigrationsGetLargeFilesResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsGetLargeFilesResponse is a response for MigrationsGetLargeFiles

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
type MigrationsGetLargeFilesResponse struct {
	common.Response
	request *MigrationsGetLargeFilesReq
	Data    []components.PorterLargeFile
}

/*
MigrationsGetStatusForAuthenticatedUser performs requests for "migrations/get-status-for-authenticated-user"

Get a user migration status.

  GET /user/migrations/{migration_id}

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
func MigrationsGetStatusForAuthenticatedUser(ctx context.Context, req *MigrationsGetStatusForAuthenticatedUserReq, opt ...options.Option) (*MigrationsGetStatusForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsGetStatusForAuthenticatedUserReq)
	}
	resp := &MigrationsGetStatusForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Migration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsGetStatusForAuthenticatedUser performs requests for "migrations/get-status-for-authenticated-user"

Get a user migration status.

  GET /user/migrations/{migration_id}

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
func (c Client) MigrationsGetStatusForAuthenticatedUser(ctx context.Context, req *MigrationsGetStatusForAuthenticatedUserReq, opt ...options.Option) (*MigrationsGetStatusForAuthenticatedUserResponse, error) {
	return MigrationsGetStatusForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
MigrationsGetStatusForAuthenticatedUserReq is request data for Client.MigrationsGetStatusForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
type MigrationsGetStatusForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *MigrationsGetStatusForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/get-status-for-authenticated-user",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v", r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsGetStatusForAuthenticatedUserReq) Rel(link RelName, resp *MigrationsGetStatusForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsGetStatusForAuthenticatedUserResponse is a response for MigrationsGetStatusForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#get-a-user-migration-status
*/
type MigrationsGetStatusForAuthenticatedUserResponse struct {
	common.Response
	request *MigrationsGetStatusForAuthenticatedUserReq
	Data    components.Migration
}

/*
MigrationsGetStatusForOrg performs requests for "migrations/get-status-for-org"

Get an organization migration status.

  GET /orgs/{org}/migrations/{migration_id}

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
func MigrationsGetStatusForOrg(ctx context.Context, req *MigrationsGetStatusForOrgReq, opt ...options.Option) (*MigrationsGetStatusForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsGetStatusForOrgReq)
	}
	resp := &MigrationsGetStatusForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Migration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsGetStatusForOrg performs requests for "migrations/get-status-for-org"

Get an organization migration status.

  GET /orgs/{org}/migrations/{migration_id}

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
func (c Client) MigrationsGetStatusForOrg(ctx context.Context, req *MigrationsGetStatusForOrgReq, opt ...options.Option) (*MigrationsGetStatusForOrgResponse, error) {
	return MigrationsGetStatusForOrg(ctx, req, append(c, opt...)...)
}

/*
MigrationsGetStatusForOrgReq is request data for Client.MigrationsGetStatusForOrg

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
type MigrationsGetStatusForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *MigrationsGetStatusForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsGetStatusForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/get-status-for-org",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v", r.Org, r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsGetStatusForOrgReq) Rel(link RelName, resp *MigrationsGetStatusForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsGetStatusForOrgResponse is a response for MigrationsGetStatusForOrg

https://developer.github.com/v3/migrations/orgs/#get-an-organization-migration-status
*/
type MigrationsGetStatusForOrgResponse struct {
	common.Response
	request *MigrationsGetStatusForOrgReq
	Data    components.Migration
}

/*
MigrationsListForAuthenticatedUser performs requests for "migrations/list-for-authenticated-user"

List user migrations.

  GET /user/migrations

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
func MigrationsListForAuthenticatedUser(ctx context.Context, req *MigrationsListForAuthenticatedUserReq, opt ...options.Option) (*MigrationsListForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsListForAuthenticatedUserReq)
	}
	resp := &MigrationsListForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Migration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsListForAuthenticatedUser performs requests for "migrations/list-for-authenticated-user"

List user migrations.

  GET /user/migrations

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
func (c Client) MigrationsListForAuthenticatedUser(ctx context.Context, req *MigrationsListForAuthenticatedUserReq, opt ...options.Option) (*MigrationsListForAuthenticatedUserResponse, error) {
	return MigrationsListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
MigrationsListForAuthenticatedUserReq is request data for Client.MigrationsListForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
type MigrationsListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *MigrationsListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsListForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/list-for-authenticated-user",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsListForAuthenticatedUserReq) Rel(link RelName, resp *MigrationsListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsListForAuthenticatedUserResponse is a response for MigrationsListForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
type MigrationsListForAuthenticatedUserResponse struct {
	common.Response
	request *MigrationsListForAuthenticatedUserReq
	Data    []components.Migration
}

/*
MigrationsListForOrg performs requests for "migrations/list-for-org"

List organization migrations.

  GET /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
func MigrationsListForOrg(ctx context.Context, req *MigrationsListForOrgReq, opt ...options.Option) (*MigrationsListForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsListForOrgReq)
	}
	resp := &MigrationsListForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Migration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsListForOrg performs requests for "migrations/list-for-org"

List organization migrations.

  GET /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
func (c Client) MigrationsListForOrg(ctx context.Context, req *MigrationsListForOrgReq, opt ...options.Option) (*MigrationsListForOrgResponse, error) {
	return MigrationsListForOrg(ctx, req, append(c, opt...)...)
}

/*
MigrationsListForOrgReq is request data for Client.MigrationsListForOrg

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
type MigrationsListForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *MigrationsListForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsListForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/list-for-org",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsListForOrgReq) Rel(link RelName, resp *MigrationsListForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsListForOrgResponse is a response for MigrationsListForOrg

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
type MigrationsListForOrgResponse struct {
	common.Response
	request *MigrationsListForOrgReq
	Data    []components.Migration
}

/*
MigrationsListReposForOrg performs requests for "migrations/list-repos-for-org"

List repositories in an organization migration.

  GET /orgs/{org}/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
func MigrationsListReposForOrg(ctx context.Context, req *MigrationsListReposForOrgReq, opt ...options.Option) (*MigrationsListReposForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsListReposForOrgReq)
	}
	resp := &MigrationsListReposForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsListReposForOrg performs requests for "migrations/list-repos-for-org"

List repositories in an organization migration.

  GET /orgs/{org}/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
func (c Client) MigrationsListReposForOrg(ctx context.Context, req *MigrationsListReposForOrgReq, opt ...options.Option) (*MigrationsListReposForOrgResponse, error) {
	return MigrationsListReposForOrg(ctx, req, append(c, opt...)...)
}

/*
MigrationsListReposForOrgReq is request data for Client.MigrationsListReposForOrg

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
type MigrationsListReposForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *MigrationsListReposForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsListReposForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/list-repos-for-org",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v/repositories", r.Org, r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsListReposForOrgReq) Rel(link RelName, resp *MigrationsListReposForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsListReposForOrgResponse is a response for MigrationsListReposForOrg

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
type MigrationsListReposForOrgResponse struct {
	common.Response
	request *MigrationsListReposForOrgReq
	Data    []components.MinimalRepository
}

/*
MigrationsListReposForUser performs requests for "migrations/list-repos-for-user"

List repositories for a user migration.

  GET /user/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
func MigrationsListReposForUser(ctx context.Context, req *MigrationsListReposForUserReq, opt ...options.Option) (*MigrationsListReposForUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsListReposForUserReq)
	}
	resp := &MigrationsListReposForUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsListReposForUser performs requests for "migrations/list-repos-for-user"

List repositories for a user migration.

  GET /user/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
func (c Client) MigrationsListReposForUser(ctx context.Context, req *MigrationsListReposForUserReq, opt ...options.Option) (*MigrationsListReposForUserResponse, error) {
	return MigrationsListReposForUser(ctx, req, append(c, opt...)...)
}

/*
MigrationsListReposForUserReq is request data for Client.MigrationsListReposForUser

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
type MigrationsListReposForUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *MigrationsListReposForUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsListReposForUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "migrations/list-repos-for-user",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v/repositories", r.MigrationId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsListReposForUserReq) Rel(link RelName, resp *MigrationsListReposForUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsListReposForUserResponse is a response for MigrationsListReposForUser

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
type MigrationsListReposForUserResponse struct {
	common.Response
	request *MigrationsListReposForUserReq
	Data    []components.MinimalRepository
}

/*
MigrationsMapCommitAuthor performs requests for "migrations/map-commit-author"

Map a commit author.

  PATCH /repos/{owner}/{repo}/import/authors/{author_id}

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
func MigrationsMapCommitAuthor(ctx context.Context, req *MigrationsMapCommitAuthorReq, opt ...options.Option) (*MigrationsMapCommitAuthorResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsMapCommitAuthorReq)
	}
	resp := &MigrationsMapCommitAuthorResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PorterAuthor{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsMapCommitAuthor performs requests for "migrations/map-commit-author"

Map a commit author.

  PATCH /repos/{owner}/{repo}/import/authors/{author_id}

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
func (c Client) MigrationsMapCommitAuthor(ctx context.Context, req *MigrationsMapCommitAuthorReq, opt ...options.Option) (*MigrationsMapCommitAuthorResponse, error) {
	return MigrationsMapCommitAuthor(ctx, req, append(c, opt...)...)
}

/*
MigrationsMapCommitAuthorReq is request data for Client.MigrationsMapCommitAuthor

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MigrationsMapCommitAuthorReq struct {
	_url  string
	Owner string
	Repo  string

	// author_id parameter
	AuthorId    int64
	RequestBody MigrationsMapCommitAuthorReqBody
}

// HTTPRequest builds an *http.Request
func (r *MigrationsMapCommitAuthorReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsMapCommitAuthorReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "migrations/map-commit-author",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import/authors/%v", r.Owner, r.Repo, r.AuthorId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsMapCommitAuthorReq) Rel(link RelName, resp *MigrationsMapCommitAuthorResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsMapCommitAuthorReqBody is a request body for migrations/map-commit-author

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MigrationsMapCommitAuthorReqBody struct {

	// The new Git author email.
	Email *string `json:"email,omitempty"`

	// The new Git author name.
	Name     *string `json:"name,omitempty"`
	RemoteId *string `json:"remote_id,omitempty"`
}

/*
MigrationsMapCommitAuthorResponse is a response for MigrationsMapCommitAuthor

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MigrationsMapCommitAuthorResponse struct {
	common.Response
	request *MigrationsMapCommitAuthorReq
	Data    components.PorterAuthor
}

/*
MigrationsSetLfsPreference performs requests for "migrations/set-lfs-preference"

Update Git LFS preference.

  PATCH /repos/{owner}/{repo}/import/lfs

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
func MigrationsSetLfsPreference(ctx context.Context, req *MigrationsSetLfsPreferenceReq, opt ...options.Option) (*MigrationsSetLfsPreferenceResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsSetLfsPreferenceReq)
	}
	resp := &MigrationsSetLfsPreferenceResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Import{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsSetLfsPreference performs requests for "migrations/set-lfs-preference"

Update Git LFS preference.

  PATCH /repos/{owner}/{repo}/import/lfs

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
func (c Client) MigrationsSetLfsPreference(ctx context.Context, req *MigrationsSetLfsPreferenceReq, opt ...options.Option) (*MigrationsSetLfsPreferenceResponse, error) {
	return MigrationsSetLfsPreference(ctx, req, append(c, opt...)...)
}

/*
MigrationsSetLfsPreferenceReq is request data for Client.MigrationsSetLfsPreference

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
type MigrationsSetLfsPreferenceReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody MigrationsSetLfsPreferenceReqBody
}

// HTTPRequest builds an *http.Request
func (r *MigrationsSetLfsPreferenceReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsSetLfsPreferenceReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "migrations/set-lfs-preference",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import/lfs", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsSetLfsPreferenceReq) Rel(link RelName, resp *MigrationsSetLfsPreferenceResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsSetLfsPreferenceReqBody is a request body for migrations/set-lfs-preference

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
type MigrationsSetLfsPreferenceReqBody struct {

	/*
	Can be one of `opt_in` (large files will be stored using Git LFS) or `opt_out`
	(large files will be removed during the import).
	*/
	UseLfs *string `json:"use_lfs"`
}

/*
MigrationsSetLfsPreferenceResponse is a response for MigrationsSetLfsPreference

https://developer.github.com/v3/migrations/source_imports/#update-git-lfs-preference
*/
type MigrationsSetLfsPreferenceResponse struct {
	common.Response
	request *MigrationsSetLfsPreferenceReq
	Data    components.Import
}

/*
MigrationsStartForAuthenticatedUser performs requests for "migrations/start-for-authenticated-user"

Start a user migration.

  POST /user/migrations

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
func MigrationsStartForAuthenticatedUser(ctx context.Context, req *MigrationsStartForAuthenticatedUserReq, opt ...options.Option) (*MigrationsStartForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsStartForAuthenticatedUserReq)
	}
	resp := &MigrationsStartForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Migration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsStartForAuthenticatedUser performs requests for "migrations/start-for-authenticated-user"

Start a user migration.

  POST /user/migrations

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
func (c Client) MigrationsStartForAuthenticatedUser(ctx context.Context, req *MigrationsStartForAuthenticatedUserReq, opt ...options.Option) (*MigrationsStartForAuthenticatedUserResponse, error) {
	return MigrationsStartForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
MigrationsStartForAuthenticatedUserReq is request data for Client.MigrationsStartForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type MigrationsStartForAuthenticatedUserReq struct {
	_url        string
	RequestBody MigrationsStartForAuthenticatedUserReqBody
}

// HTTPRequest builds an *http.Request
func (r *MigrationsStartForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsStartForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "migrations/start-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/migrations"),
		URLQuery:         query,
		ValidStatuses:    []int{201, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsStartForAuthenticatedUserReq) Rel(link RelName, resp *MigrationsStartForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsStartForAuthenticatedUserReqBody is a request body for migrations/start-for-authenticated-user

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type MigrationsStartForAuthenticatedUserReqBody struct {

	// Exclude attributes from the API response to improve performance
	Exclude []string `json:"exclude,omitempty"`

	// Do not include attachments in the migration
	ExcludeAttachments *bool `json:"exclude_attachments,omitempty"`

	// Lock the repositories being migrated at the start of the migration
	LockRepositories *bool    `json:"lock_repositories,omitempty"`
	Repositories     []string `json:"repositories"`
}

/*
MigrationsStartForAuthenticatedUserResponse is a response for MigrationsStartForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type MigrationsStartForAuthenticatedUserResponse struct {
	common.Response
	request *MigrationsStartForAuthenticatedUserReq
	Data    components.Migration
}

/*
MigrationsStartForOrg performs requests for "migrations/start-for-org"

Start an organization migration.

  POST /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
func MigrationsStartForOrg(ctx context.Context, req *MigrationsStartForOrgReq, opt ...options.Option) (*MigrationsStartForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsStartForOrgReq)
	}
	resp := &MigrationsStartForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Migration{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsStartForOrg performs requests for "migrations/start-for-org"

Start an organization migration.

  POST /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
func (c Client) MigrationsStartForOrg(ctx context.Context, req *MigrationsStartForOrgReq, opt ...options.Option) (*MigrationsStartForOrgResponse, error) {
	return MigrationsStartForOrg(ctx, req, append(c, opt...)...)
}

/*
MigrationsStartForOrgReq is request data for Client.MigrationsStartForOrg

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type MigrationsStartForOrgReq struct {
	_url        string
	Org         string
	RequestBody MigrationsStartForOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *MigrationsStartForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsStartForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "migrations/start-for-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsStartForOrgReq) Rel(link RelName, resp *MigrationsStartForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsStartForOrgReqBody is a request body for migrations/start-for-org

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type MigrationsStartForOrgReqBody struct {
	Exclude []string `json:"exclude,omitempty"`

	// Indicates whether attachments should be excluded from the migration (to reduce migration archive file size).
	ExcludeAttachments *bool `json:"exclude_attachments,omitempty"`

	// Indicates whether repositories should be locked (to prevent manipulation) while migrating data.
	LockRepositories *bool `json:"lock_repositories,omitempty"`

	// A list of arrays indicating which repositories should be migrated.
	Repositories []string `json:"repositories"`
}

/*
MigrationsStartForOrgResponse is a response for MigrationsStartForOrg

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type MigrationsStartForOrgResponse struct {
	common.Response
	request *MigrationsStartForOrgReq
	Data    components.Migration
}

/*
MigrationsStartImport performs requests for "migrations/start-import"

Start an import.

  PUT /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
func MigrationsStartImport(ctx context.Context, req *MigrationsStartImportReq, opt ...options.Option) (*MigrationsStartImportResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsStartImportReq)
	}
	resp := &MigrationsStartImportResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Import{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsStartImport performs requests for "migrations/start-import"

Start an import.

  PUT /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
func (c Client) MigrationsStartImport(ctx context.Context, req *MigrationsStartImportReq, opt ...options.Option) (*MigrationsStartImportResponse, error) {
	return MigrationsStartImport(ctx, req, append(c, opt...)...)
}

/*
MigrationsStartImportReq is request data for Client.MigrationsStartImport

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type MigrationsStartImportReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody MigrationsStartImportReqBody
}

// HTTPRequest builds an *http.Request
func (r *MigrationsStartImportReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsStartImportReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "migrations/start-import",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsStartImportReq) Rel(link RelName, resp *MigrationsStartImportResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsStartImportReqBody is a request body for migrations/start-import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type MigrationsStartImportReqBody struct {

	// For a tfvc import, the name of the project that is being imported.
	TfvcProject *string `json:"tfvc_project,omitempty"`

	/*
	The originating VCS type. Can be one of `subversion`, `git`, `mercurial`, or
	`tfvc`. Please be aware that without this parameter, the import job will take
	additional time to detect the VCS type before beginning the import. This
	detection step will be reflected in the response.
	*/
	Vcs *string `json:"vcs,omitempty"`

	// If authentication is required, the password to provide to `vcs_url`.
	VcsPassword *string `json:"vcs_password,omitempty"`

	// The URL of the originating repository.
	VcsUrl *string `json:"vcs_url"`

	// If authentication is required, the username to provide to `vcs_url`.
	VcsUsername *string `json:"vcs_username,omitempty"`
}

/*
MigrationsStartImportResponse is a response for MigrationsStartImport

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type MigrationsStartImportResponse struct {
	common.Response
	request *MigrationsStartImportReq
	Data    components.Import
}

/*
MigrationsUnlockRepoForAuthenticatedUser performs requests for "migrations/unlock-repo-for-authenticated-user"

Unlock a user repository.

  DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
func MigrationsUnlockRepoForAuthenticatedUser(ctx context.Context, req *MigrationsUnlockRepoForAuthenticatedUserReq, opt ...options.Option) (*MigrationsUnlockRepoForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsUnlockRepoForAuthenticatedUserReq)
	}
	resp := &MigrationsUnlockRepoForAuthenticatedUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsUnlockRepoForAuthenticatedUser performs requests for "migrations/unlock-repo-for-authenticated-user"

Unlock a user repository.

  DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
func (c Client) MigrationsUnlockRepoForAuthenticatedUser(ctx context.Context, req *MigrationsUnlockRepoForAuthenticatedUserReq, opt ...options.Option) (*MigrationsUnlockRepoForAuthenticatedUserResponse, error) {
	return MigrationsUnlockRepoForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
MigrationsUnlockRepoForAuthenticatedUserReq is request data for Client.MigrationsUnlockRepoForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
type MigrationsUnlockRepoForAuthenticatedUserReq struct {
	_url string

	// migration_id parameter
	MigrationId int64

	// repo_name parameter
	RepoName string

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *MigrationsUnlockRepoForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "migrations/unlock-repo-for-authenticated-user",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/user/migrations/%v/repos/%v/lock", r.MigrationId, r.RepoName),
		URLQuery:         query,
		ValidStatuses:    []int{204, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsUnlockRepoForAuthenticatedUserReq) Rel(link RelName, resp *MigrationsUnlockRepoForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsUnlockRepoForAuthenticatedUserResponse is a response for MigrationsUnlockRepoForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
type MigrationsUnlockRepoForAuthenticatedUserResponse struct {
	common.Response
	request *MigrationsUnlockRepoForAuthenticatedUserReq
}

/*
MigrationsUnlockRepoForOrg performs requests for "migrations/unlock-repo-for-org"

Unlock an organization repository.

  DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
func MigrationsUnlockRepoForOrg(ctx context.Context, req *MigrationsUnlockRepoForOrgReq, opt ...options.Option) (*MigrationsUnlockRepoForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsUnlockRepoForOrgReq)
	}
	resp := &MigrationsUnlockRepoForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsUnlockRepoForOrg performs requests for "migrations/unlock-repo-for-org"

Unlock an organization repository.

  DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
func (c Client) MigrationsUnlockRepoForOrg(ctx context.Context, req *MigrationsUnlockRepoForOrgReq, opt ...options.Option) (*MigrationsUnlockRepoForOrgResponse, error) {
	return MigrationsUnlockRepoForOrg(ctx, req, append(c, opt...)...)
}

/*
MigrationsUnlockRepoForOrgReq is request data for Client.MigrationsUnlockRepoForOrg

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
type MigrationsUnlockRepoForOrgReq struct {
	_url string
	Org  string

	// migration_id parameter
	MigrationId int64

	// repo_name parameter
	RepoName string

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

// HTTPRequest builds an *http.Request
func (r *MigrationsUnlockRepoForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsUnlockRepoForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"wyandotte"},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "migrations/unlock-repo-for-org",
		Previews:         map[string]bool{"wyandotte": r.WyandottePreview},
		RequiredPreviews: []string{"wyandotte"},
		URLPath:          fmt.Sprintf("/orgs/%v/migrations/%v/repos/%v/lock", r.Org, r.MigrationId, r.RepoName),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsUnlockRepoForOrgReq) Rel(link RelName, resp *MigrationsUnlockRepoForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsUnlockRepoForOrgResponse is a response for MigrationsUnlockRepoForOrg

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
type MigrationsUnlockRepoForOrgResponse struct {
	common.Response
	request *MigrationsUnlockRepoForOrgReq
	Data    bool
}

/*
MigrationsUpdateImport performs requests for "migrations/update-import"

Update an import.

  PATCH /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
func MigrationsUpdateImport(ctx context.Context, req *MigrationsUpdateImportReq, opt ...options.Option) (*MigrationsUpdateImportResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(MigrationsUpdateImportReq)
	}
	resp := &MigrationsUpdateImportResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Import{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsUpdateImport performs requests for "migrations/update-import"

Update an import.

  PATCH /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
func (c Client) MigrationsUpdateImport(ctx context.Context, req *MigrationsUpdateImportReq, opt ...options.Option) (*MigrationsUpdateImportResponse, error) {
	return MigrationsUpdateImport(ctx, req, append(c, opt...)...)
}

/*
MigrationsUpdateImportReq is request data for Client.MigrationsUpdateImport

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
type MigrationsUpdateImportReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody MigrationsUpdateImportReqBody
}

// HTTPRequest builds an *http.Request
func (r *MigrationsUpdateImportReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *MigrationsUpdateImportReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "migrations/update-import",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsUpdateImportReq) Rel(link RelName, resp *MigrationsUpdateImportResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsUpdateImportReqBody is a request body for migrations/update-import

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
type MigrationsUpdateImportReqBody struct {
	TfvcProject *string `json:"tfvc_project,omitempty"`
	Vcs         *string `json:"vcs,omitempty"`

	// The password to provide to the originating repository.
	VcsPassword *string `json:"vcs_password,omitempty"`

	// The username to provide to the originating repository.
	VcsUsername *string `json:"vcs_username,omitempty"`
}

/*
MigrationsUpdateImportResponse is a response for MigrationsUpdateImport

https://developer.github.com/v3/migrations/source_imports/#update-an-import
*/
type MigrationsUpdateImportResponse struct {
	common.Response
	request *MigrationsUpdateImportReq
	Data    components.Import
}
