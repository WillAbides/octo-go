// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
MigrationsCancelImportReq builds requests for "migrations/cancel-import"

Cancel an import.

  DELETE /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
type MigrationsCancelImportReq struct {
	Owner string
	Repo  string
}

func (r *MigrationsCancelImportReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo)
}

func (r *MigrationsCancelImportReq) method() string {
	return "DELETE"
}

func (r *MigrationsCancelImportReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsCancelImportReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsCancelImportReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsCancelImportReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsDeleteArchiveForAuthenticatedUserReq builds requests for "migrations/delete-archive-for-authenticated-user"

Delete a user migration archive.

  DELETE /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
type MigrationsDeleteArchiveForAuthenticatedUserReq struct {
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/migrations/%v/archive", r.MigrationId)
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) method() string {
	return "DELETE"
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsDeleteArchiveForOrgReq builds requests for "migrations/delete-archive-for-org"

Delete an organization migration archive.

  DELETE /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
type MigrationsDeleteArchiveForOrgReq struct {
	Org         string
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsDeleteArchiveForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations/%v/archive", r.Org, r.MigrationId)
}

func (r *MigrationsDeleteArchiveForOrgReq) method() string {
	return "DELETE"
}

func (r *MigrationsDeleteArchiveForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsDeleteArchiveForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsDeleteArchiveForOrgReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsDeleteArchiveForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsDownloadArchiveForOrgReq builds requests for "migrations/download-archive-for-org"

Download an organization migration archive.

  GET /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
type MigrationsDownloadArchiveForOrgReq struct {
	Org         string
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsDownloadArchiveForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations/%v/archive", r.Org, r.MigrationId)
}

func (r *MigrationsDownloadArchiveForOrgReq) method() string {
	return "GET"
}

func (r *MigrationsDownloadArchiveForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsDownloadArchiveForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsDownloadArchiveForOrgReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsDownloadArchiveForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsGetArchiveForAuthenticatedUserReq builds requests for "migrations/get-archive-for-authenticated-user"

Download a user migration archive.

  GET /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
type MigrationsGetArchiveForAuthenticatedUserReq struct {
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/migrations/%v/archive", r.MigrationId)
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsGetArchiveForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsGetCommitAuthorsReq builds requests for "migrations/get-commit-authors"

Get commit authors.

  GET /repos/{owner}/{repo}/import/authors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
type MigrationsGetCommitAuthorsReq struct {
	Owner string
	Repo  string

	/*
	Only authors found after this id are returned. Provide the highest author ID
	you've seen so far. New authors may be added to the list at any point while the
	importer is performing the `raw` step.
	*/
	Since *string
}

func (r *MigrationsGetCommitAuthorsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import/authors", r.Owner, r.Repo)
}

func (r *MigrationsGetCommitAuthorsReq) method() string {
	return "GET"
}

func (r *MigrationsGetCommitAuthorsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	return query
}

func (r *MigrationsGetCommitAuthorsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsGetCommitAuthorsReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsGetCommitAuthorsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsGetCommitAuthorsResponseBody200 is a response body for migrations/get-commit-authors

API documentation: https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
type MigrationsGetCommitAuthorsResponseBody200 []struct {
	components.PorterAuthor
}

/*
MigrationsGetImportProgressReq builds requests for "migrations/get-import-progress"

Get import progress.

  GET /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#get-import-progress
*/
type MigrationsGetImportProgressReq struct {
	Owner string
	Repo  string
}

func (r *MigrationsGetImportProgressReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo)
}

func (r *MigrationsGetImportProgressReq) method() string {
	return "GET"
}

func (r *MigrationsGetImportProgressReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsGetImportProgressReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsGetImportProgressReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsGetImportProgressReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsGetImportProgressResponseBody200 is a response body for migrations/get-import-progress

API documentation: https://developer.github.com/v3/migrations/source_imports/#get-import-progress
*/
type MigrationsGetImportProgressResponseBody200 struct {
	components.Import
}

/*
MigrationsGetLargeFilesReq builds requests for "migrations/get-large-files"

Get large files.

  GET /repos/{owner}/{repo}/import/large_files

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
type MigrationsGetLargeFilesReq struct {
	Owner string
	Repo  string
}

func (r *MigrationsGetLargeFilesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import/large_files", r.Owner, r.Repo)
}

func (r *MigrationsGetLargeFilesReq) method() string {
	return "GET"
}

func (r *MigrationsGetLargeFilesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsGetLargeFilesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsGetLargeFilesReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsGetLargeFilesReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsGetLargeFilesResponseBody200 is a response body for migrations/get-large-files

API documentation: https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
type MigrationsGetLargeFilesResponseBody200 []struct {
	components.PorterLargeFile
}

/*
MigrationsGetStatusForAuthenticatedUserReq builds requests for "migrations/get-status-for-authenticated-user"

Get the status of a user migration.

  GET /user/migrations/{migration_id}

https://developer.github.com/v3/migrations/users/#get-the-status-of-a-user-migration
*/
type MigrationsGetStatusForAuthenticatedUserReq struct {
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/migrations/%v", r.MigrationId)
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsGetStatusForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsGetStatusForAuthenticatedUserResponseBody200 is a response body for migrations/get-status-for-authenticated-user

API documentation: https://developer.github.com/v3/migrations/users/#get-the-status-of-a-user-migration
*/
type MigrationsGetStatusForAuthenticatedUserResponseBody200 struct {
	components.Migration
}

/*
MigrationsGetStatusForOrgReq builds requests for "migrations/get-status-for-org"

Get the status of an organization migration.

  GET /orgs/{org}/migrations/{migration_id}

https://developer.github.com/v3/migrations/orgs/#get-the-status-of-an-organization-migration
*/
type MigrationsGetStatusForOrgReq struct {
	Org         string
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsGetStatusForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations/%v", r.Org, r.MigrationId)
}

func (r *MigrationsGetStatusForOrgReq) method() string {
	return "GET"
}

func (r *MigrationsGetStatusForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsGetStatusForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsGetStatusForOrgReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsGetStatusForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsGetStatusForOrgResponseBody200 is a response body for migrations/get-status-for-org

API documentation: https://developer.github.com/v3/migrations/orgs/#get-the-status-of-an-organization-migration
*/
type MigrationsGetStatusForOrgResponseBody200 struct {
	components.MigrationWithShortOrg
}

/*
MigrationsListForAuthenticatedUserReq builds requests for "migrations/list-for-authenticated-user"

List user migrations.

  GET /user/migrations

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
type MigrationsListForAuthenticatedUserReq struct {

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsListForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/migrations")
}

func (r *MigrationsListForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *MigrationsListForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *MigrationsListForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsListForAuthenticatedUserReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsListForAuthenticatedUserResponseBody200 is a response body for migrations/list-for-authenticated-user

API documentation: https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
type MigrationsListForAuthenticatedUserResponseBody200 []struct {
	components.Migration
}

/*
MigrationsListForOrgReq builds requests for "migrations/list-for-org"

List organization migrations.

  GET /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
type MigrationsListForOrgReq struct {
	Org string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsListForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations", r.Org)
}

func (r *MigrationsListForOrgReq) method() string {
	return "GET"
}

func (r *MigrationsListForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *MigrationsListForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsListForOrgReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsListForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsListForOrgResponseBody200 is a response body for migrations/list-for-org

API documentation: https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
type MigrationsListForOrgResponseBody200 []struct {
	components.MigrationWithShortOrg
}

/*
MigrationsListReposForOrgReq builds requests for "migrations/list-repos-for-org"

List repositories in an organization migration.

  GET /orgs/{org}/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
type MigrationsListReposForOrgReq struct {
	Org         string
	MigrationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsListReposForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations/%v/repositories", r.Org, r.MigrationId)
}

func (r *MigrationsListReposForOrgReq) method() string {
	return "GET"
}

func (r *MigrationsListReposForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *MigrationsListReposForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsListReposForOrgReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsListReposForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsListReposForOrgResponseBody200 is a response body for migrations/list-repos-for-org

API documentation: https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
type MigrationsListReposForOrgResponseBody200 []struct {
	components.MinimalRepository
}

/*
MigrationsListReposForUserReq builds requests for "migrations/list-repos-for-user"

List repositories for a user migration.

  GET /user/{migration_id}/repositories

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
type MigrationsListReposForUserReq struct {
	MigrationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsListReposForUserReq) urlPath() string {
	return fmt.Sprintf("/user/%v/repositories", r.MigrationId)
}

func (r *MigrationsListReposForUserReq) method() string {
	return "GET"
}

func (r *MigrationsListReposForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *MigrationsListReposForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsListReposForUserReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsListReposForUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsListReposForUserResponseBody200 is a response body for migrations/list-repos-for-user

API documentation: https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
type MigrationsListReposForUserResponseBody200 []struct {
	components.MinimalRepository
}

/*
MigrationsMapCommitAuthorReq builds requests for "migrations/map-commit-author"

Map a commit author.

  PATCH /repos/{owner}/{repo}/import/authors/{author_id}

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MigrationsMapCommitAuthorReq struct {
	Owner       string
	Repo        string
	AuthorId    int64
	RequestBody MigrationsMapCommitAuthorReqBody
}

func (r *MigrationsMapCommitAuthorReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import/authors/%v", r.Owner, r.Repo, r.AuthorId)
}

func (r *MigrationsMapCommitAuthorReq) method() string {
	return "PATCH"
}

func (r *MigrationsMapCommitAuthorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsMapCommitAuthorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsMapCommitAuthorReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *MigrationsMapCommitAuthorReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsMapCommitAuthorReqBody is a request body for migrations/map-commit-author

API documentation: https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MigrationsMapCommitAuthorReqBody struct {

	// The new Git author email.
	Email *string `json:"email,omitempty"`

	// The new Git author name.
	Name *string `json:"name,omitempty"`
}

/*
MigrationsMapCommitAuthorResponseBody200 is a response body for migrations/map-commit-author

API documentation: https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MigrationsMapCommitAuthorResponseBody200 struct {
	components.PorterAuthor
}

/*
MigrationsSetLfsPreferenceReq builds requests for "migrations/set-lfs-preference"

Set Git LFS preference.

  PATCH /repos/{owner}/{repo}/import/lfs

https://developer.github.com/v3/migrations/source_imports/#set-git-lfs-preference
*/
type MigrationsSetLfsPreferenceReq struct {
	Owner       string
	Repo        string
	RequestBody MigrationsSetLfsPreferenceReqBody
}

func (r *MigrationsSetLfsPreferenceReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import/lfs", r.Owner, r.Repo)
}

func (r *MigrationsSetLfsPreferenceReq) method() string {
	return "PATCH"
}

func (r *MigrationsSetLfsPreferenceReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsSetLfsPreferenceReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsSetLfsPreferenceReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *MigrationsSetLfsPreferenceReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsSetLfsPreferenceReqBody is a request body for migrations/set-lfs-preference

API documentation: https://developer.github.com/v3/migrations/source_imports/#set-git-lfs-preference
*/
type MigrationsSetLfsPreferenceReqBody struct {

	/*
	   Can be one of `opt_in` (large files will be stored using Git LFS) or `opt_out`
	   (large files will be removed during the import).
	*/
	UseLfs *string `json:"use_lfs"`
}

/*
MigrationsSetLfsPreferenceResponseBody200 is a response body for migrations/set-lfs-preference

API documentation: https://developer.github.com/v3/migrations/source_imports/#set-git-lfs-preference
*/
type MigrationsSetLfsPreferenceResponseBody200 struct {
	components.Import
}

/*
MigrationsStartForAuthenticatedUserReq builds requests for "migrations/start-for-authenticated-user"

Start a user migration.

  POST /user/migrations

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type MigrationsStartForAuthenticatedUserReq struct {
	RequestBody MigrationsStartForAuthenticatedUserReqBody
}

func (r *MigrationsStartForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/migrations")
}

func (r *MigrationsStartForAuthenticatedUserReq) method() string {
	return "POST"
}

func (r *MigrationsStartForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsStartForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsStartForAuthenticatedUserReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *MigrationsStartForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsStartForAuthenticatedUserReqBody is a request body for migrations/start-for-authenticated-user

API documentation: https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type MigrationsStartForAuthenticatedUserReqBody struct {

	/*
	   Does not include attachments uploaded to GitHub.com in the migration data when
	   set to `true`. Excluding attachments will reduce the migration archive file
	   size.
	*/
	ExcludeAttachments *bool `json:"exclude_attachments,omitempty"`

	/*
	   Locks the `repositories` to prevent changes during the migration when set to
	   `true`.
	*/
	LockRepositories *bool `json:"lock_repositories,omitempty"`

	// An array of repositories to include in the migration.
	Repositories []string `json:"repositories"`
}

/*
MigrationsStartForAuthenticatedUserResponseBody201 is a response body for migrations/start-for-authenticated-user

API documentation: https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type MigrationsStartForAuthenticatedUserResponseBody201 struct {
	components.Migration
}

/*
MigrationsStartForOrgReq builds requests for "migrations/start-for-org"

Start an organization migration.

  POST /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type MigrationsStartForOrgReq struct {
	Org         string
	RequestBody MigrationsStartForOrgReqBody
}

func (r *MigrationsStartForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations", r.Org)
}

func (r *MigrationsStartForOrgReq) method() string {
	return "POST"
}

func (r *MigrationsStartForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsStartForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsStartForOrgReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *MigrationsStartForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsStartForOrgReqBody is a request body for migrations/start-for-org

API documentation: https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type MigrationsStartForOrgReqBody struct {

	/*
	   Indicates whether attachments should be excluded from the migration (to reduce
	   migration archive file size).
	*/
	ExcludeAttachments *bool `json:"exclude_attachments,omitempty"`

	/*
	   Indicates whether repositories should be locked (to prevent manipulation) while
	   migrating data.
	*/
	LockRepositories *bool `json:"lock_repositories,omitempty"`

	// A list of arrays indicating which repositories should be migrated.
	Repositories []string `json:"repositories"`
}

/*
MigrationsStartForOrgResponseBody201 is a response body for migrations/start-for-org

API documentation: https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type MigrationsStartForOrgResponseBody201 struct {
	components.MigrationWithShortOrg
}

/*
MigrationsStartImportReq builds requests for "migrations/start-import"

Start an import.

  PUT /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type MigrationsStartImportReq struct {
	Owner       string
	Repo        string
	RequestBody MigrationsStartImportReqBody
}

func (r *MigrationsStartImportReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo)
}

func (r *MigrationsStartImportReq) method() string {
	return "PUT"
}

func (r *MigrationsStartImportReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsStartImportReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsStartImportReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *MigrationsStartImportReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsStartImportReqBody is a request body for migrations/start-import

API documentation: https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type MigrationsStartImportReqBody struct {

	// For a tfvc import, the name of the project that is being imported.
	TfvcProject *string `json:"tfvc_project,omitempty"`

	/*
	   The originating VCS type. Can be one of `subversion`, `git`, `mercurial`, or
	   `tfvc`. Please be aware that without this parameter, the import job will take
	   additional time to detect the VCS type before beginning the import. This
	   detection step will be reflected in the response.
	*/
	Vcs *string `json:"vcs,omitempty"`

	// If authentication is required, the password to provide to `vcs_url`.
	VcsPassword *string `json:"vcs_password,omitempty"`

	// The URL of the originating repository.
	VcsUrl *string `json:"vcs_url"`

	// If authentication is required, the username to provide to `vcs_url`.
	VcsUsername *string `json:"vcs_username,omitempty"`
}

/*
MigrationsStartImportResponseBody201 is a response body for migrations/start-import

API documentation: https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type MigrationsStartImportResponseBody201 struct {
	components.Import2
}

/*
MigrationsUnlockRepoForAuthenticatedUserReq builds requests for "migrations/unlock-repo-for-authenticated-user"

Unlock a user repository.

  DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
type MigrationsUnlockRepoForAuthenticatedUserReq struct {
	MigrationId int64
	RepoName    string

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/migrations/%v/repos/%v/lock", r.MigrationId, r.RepoName)
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) method() string {
	return "DELETE"
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsUnlockRepoForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsUnlockRepoForOrgReq builds requests for "migrations/unlock-repo-for-org"

Unlock an organization repository.

  DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
type MigrationsUnlockRepoForOrgReq struct {
	Org         string
	MigrationId int64
	RepoName    string

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsUnlockRepoForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations/%v/repos/%v/lock", r.Org, r.MigrationId, r.RepoName)
}

func (r *MigrationsUnlockRepoForOrgReq) method() string {
	return "DELETE"
}

func (r *MigrationsUnlockRepoForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsUnlockRepoForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsUnlockRepoForOrgReq) body() interface{} {
	return nil
}

// HTTPRequest creates an http request
func (r *MigrationsUnlockRepoForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsUpdateImportReq builds requests for "migrations/update-import"

Update existing import.

  PATCH /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#update-existing-import
*/
type MigrationsUpdateImportReq struct {
	Owner       string
	Repo        string
	RequestBody MigrationsUpdateImportReqBody
}

func (r *MigrationsUpdateImportReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo)
}

func (r *MigrationsUpdateImportReq) method() string {
	return "PATCH"
}

func (r *MigrationsUpdateImportReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsUpdateImportReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsUpdateImportReq) body() interface{} {
	return r.RequestBody
}

// HTTPRequest creates an http request
func (r *MigrationsUpdateImportReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
MigrationsUpdateImportReqBody is a request body for migrations/update-import

API documentation: https://developer.github.com/v3/migrations/source_imports/#update-existing-import
*/
type MigrationsUpdateImportReqBody struct {

	// The password to provide to the originating repository.
	VcsPassword *string `json:"vcs_password,omitempty"`

	// The username to provide to the originating repository.
	VcsUsername *string `json:"vcs_username,omitempty"`
}

/*
MigrationsUpdateImportResponseBody200 is a response body for migrations/update-import

API documentation: https://developer.github.com/v3/migrations/source_imports/#update-existing-import
*/
type MigrationsUpdateImportResponseBody200 struct {
	components.Import3
}
