// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
MigrationsCancelImport performs requests for "migrations/cancel-import"

Cancel an import.

  DELETE /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
func (c *Client) MigrationsCancelImport(ctx context.Context, req *MigrationsCancelImportReq, opt ...RequestOption) (*MigrationsCancelImportResponse, error) {
	if req == nil {
		req = new(MigrationsCancelImportReq)
	}
	resp := &MigrationsCancelImportResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsCancelImportReq is request data for Client.MigrationsCancelImport

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
type MigrationsCancelImportReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *MigrationsCancelImportReq) url() string {
	return r._url
}

func (r *MigrationsCancelImportReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo)
}

func (r *MigrationsCancelImportReq) method() string {
	return "DELETE"
}

func (r *MigrationsCancelImportReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsCancelImportReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsCancelImportReq) body() interface{} {
	return nil
}

func (r *MigrationsCancelImportReq) dataStatuses() []int {
	return []int{}
}

func (r *MigrationsCancelImportReq) validStatuses() []int {
	return []int{204}
}

func (r *MigrationsCancelImportReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsCancelImportReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsCancelImportReq) Rel(link RelName, resp *MigrationsCancelImportResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsCancelImportResponse is a response for MigrationsCancelImport

https://developer.github.com/v3/migrations/source_imports/#cancel-an-import
*/
type MigrationsCancelImportResponse struct {
	response
	request *MigrationsCancelImportReq
}

/*
MigrationsDeleteArchiveForAuthenticatedUser performs requests for "migrations/delete-archive-for-authenticated-user"

Delete a user migration archive.

  DELETE /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
func (c *Client) MigrationsDeleteArchiveForAuthenticatedUser(ctx context.Context, req *MigrationsDeleteArchiveForAuthenticatedUserReq, opt ...RequestOption) (*MigrationsDeleteArchiveForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(MigrationsDeleteArchiveForAuthenticatedUserReq)
	}
	resp := &MigrationsDeleteArchiveForAuthenticatedUserResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsDeleteArchiveForAuthenticatedUserReq is request data for Client.MigrationsDeleteArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
type MigrationsDeleteArchiveForAuthenticatedUserReq struct {
	_url        string
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/migrations/%v/archive", r.MigrationId)
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) method() string {
	return "DELETE"
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) dataStatuses() []int {
	return []int{}
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) validStatuses() []int {
	return []int{204}
}

func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsDeleteArchiveForAuthenticatedUserReq) Rel(link RelName, resp *MigrationsDeleteArchiveForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsDeleteArchiveForAuthenticatedUserResponse is a response for MigrationsDeleteArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#delete-a-user-migration-archive
*/
type MigrationsDeleteArchiveForAuthenticatedUserResponse struct {
	response
	request *MigrationsDeleteArchiveForAuthenticatedUserReq
}

/*
MigrationsDeleteArchiveForOrg performs requests for "migrations/delete-archive-for-org"

Delete an organization migration archive.

  DELETE /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
func (c *Client) MigrationsDeleteArchiveForOrg(ctx context.Context, req *MigrationsDeleteArchiveForOrgReq, opt ...RequestOption) (*MigrationsDeleteArchiveForOrgResponse, error) {
	if req == nil {
		req = new(MigrationsDeleteArchiveForOrgReq)
	}
	resp := &MigrationsDeleteArchiveForOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsDeleteArchiveForOrgReq is request data for Client.MigrationsDeleteArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
type MigrationsDeleteArchiveForOrgReq struct {
	_url        string
	Org         string
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsDeleteArchiveForOrgReq) url() string {
	return r._url
}

func (r *MigrationsDeleteArchiveForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations/%v/archive", r.Org, r.MigrationId)
}

func (r *MigrationsDeleteArchiveForOrgReq) method() string {
	return "DELETE"
}

func (r *MigrationsDeleteArchiveForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsDeleteArchiveForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsDeleteArchiveForOrgReq) body() interface{} {
	return nil
}

func (r *MigrationsDeleteArchiveForOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *MigrationsDeleteArchiveForOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *MigrationsDeleteArchiveForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsDeleteArchiveForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsDeleteArchiveForOrgReq) Rel(link RelName, resp *MigrationsDeleteArchiveForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsDeleteArchiveForOrgResponse is a response for MigrationsDeleteArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#delete-an-organization-migration-archive
*/
type MigrationsDeleteArchiveForOrgResponse struct {
	response
	request *MigrationsDeleteArchiveForOrgReq
}

/*
MigrationsDownloadArchiveForOrg performs requests for "migrations/download-archive-for-org"

Download an organization migration archive.

  GET /orgs/{org}/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
func (c *Client) MigrationsDownloadArchiveForOrg(ctx context.Context, req *MigrationsDownloadArchiveForOrgReq, opt ...RequestOption) (*MigrationsDownloadArchiveForOrgResponse, error) {
	if req == nil {
		req = new(MigrationsDownloadArchiveForOrgReq)
	}
	resp := &MigrationsDownloadArchiveForOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsDownloadArchiveForOrgReq is request data for Client.MigrationsDownloadArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
type MigrationsDownloadArchiveForOrgReq struct {
	_url        string
	Org         string
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsDownloadArchiveForOrgReq) url() string {
	return r._url
}

func (r *MigrationsDownloadArchiveForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations/%v/archive", r.Org, r.MigrationId)
}

func (r *MigrationsDownloadArchiveForOrgReq) method() string {
	return "GET"
}

func (r *MigrationsDownloadArchiveForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsDownloadArchiveForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsDownloadArchiveForOrgReq) body() interface{} {
	return nil
}

func (r *MigrationsDownloadArchiveForOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *MigrationsDownloadArchiveForOrgReq) validStatuses() []int {
	return []int{302}
}

func (r *MigrationsDownloadArchiveForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrRedirectOnly}
}

// httpRequest creates an http request
func (r *MigrationsDownloadArchiveForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsDownloadArchiveForOrgReq) Rel(link RelName, resp *MigrationsDownloadArchiveForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsDownloadArchiveForOrgResponse is a response for MigrationsDownloadArchiveForOrg

https://developer.github.com/v3/migrations/orgs/#download-an-organization-migration-archive
*/
type MigrationsDownloadArchiveForOrgResponse struct {
	response
	request *MigrationsDownloadArchiveForOrgReq
}

/*
MigrationsGetArchiveForAuthenticatedUser performs requests for "migrations/get-archive-for-authenticated-user"

Download a user migration archive.

  GET /user/migrations/{migration_id}/archive

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
func (c *Client) MigrationsGetArchiveForAuthenticatedUser(ctx context.Context, req *MigrationsGetArchiveForAuthenticatedUserReq, opt ...RequestOption) (*MigrationsGetArchiveForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(MigrationsGetArchiveForAuthenticatedUserReq)
	}
	resp := &MigrationsGetArchiveForAuthenticatedUserResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsGetArchiveForAuthenticatedUserReq is request data for Client.MigrationsGetArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
type MigrationsGetArchiveForAuthenticatedUserReq struct {
	_url        string
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/migrations/%v/archive", r.MigrationId)
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) dataStatuses() []int {
	return []int{}
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) validStatuses() []int {
	return []int{302}
}

func (r *MigrationsGetArchiveForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrRedirectOnly}
}

// httpRequest creates an http request
func (r *MigrationsGetArchiveForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsGetArchiveForAuthenticatedUserReq) Rel(link RelName, resp *MigrationsGetArchiveForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsGetArchiveForAuthenticatedUserResponse is a response for MigrationsGetArchiveForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#download-a-user-migration-archive
*/
type MigrationsGetArchiveForAuthenticatedUserResponse struct {
	response
	request *MigrationsGetArchiveForAuthenticatedUserReq
}

/*
MigrationsGetCommitAuthors performs requests for "migrations/get-commit-authors"

Get commit authors.

  GET /repos/{owner}/{repo}/import/authors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
func (c *Client) MigrationsGetCommitAuthors(ctx context.Context, req *MigrationsGetCommitAuthorsReq, opt ...RequestOption) (*MigrationsGetCommitAuthorsResponse, error) {
	if req == nil {
		req = new(MigrationsGetCommitAuthorsReq)
	}
	resp := &MigrationsGetCommitAuthorsResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsGetCommitAuthorsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsGetCommitAuthorsReq is request data for Client.MigrationsGetCommitAuthors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
type MigrationsGetCommitAuthorsReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Only authors found after this id are returned. Provide the highest author ID
	you've seen so far. New authors may be added to the list at any point while the
	importer is performing the `raw` step.
	*/
	Since *string
}

func (r *MigrationsGetCommitAuthorsReq) url() string {
	return r._url
}

func (r *MigrationsGetCommitAuthorsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import/authors", r.Owner, r.Repo)
}

func (r *MigrationsGetCommitAuthorsReq) method() string {
	return "GET"
}

func (r *MigrationsGetCommitAuthorsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Since != nil {
		query.Set("since", *r.Since)
	}
	return query
}

func (r *MigrationsGetCommitAuthorsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsGetCommitAuthorsReq) body() interface{} {
	return nil
}

func (r *MigrationsGetCommitAuthorsReq) dataStatuses() []int {
	return []int{200}
}

func (r *MigrationsGetCommitAuthorsReq) validStatuses() []int {
	return []int{200}
}

func (r *MigrationsGetCommitAuthorsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsGetCommitAuthorsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsGetCommitAuthorsReq) Rel(link RelName, resp *MigrationsGetCommitAuthorsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsGetCommitAuthorsResponseBody is a response body for MigrationsGetCommitAuthors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
type MigrationsGetCommitAuthorsResponseBody []struct {
	components.PorterAuthor
}

/*
MigrationsGetCommitAuthorsResponse is a response for MigrationsGetCommitAuthors

https://developer.github.com/v3/migrations/source_imports/#get-commit-authors
*/
type MigrationsGetCommitAuthorsResponse struct {
	response
	request *MigrationsGetCommitAuthorsReq
	Data    *MigrationsGetCommitAuthorsResponseBody
}

/*
MigrationsGetImportProgress performs requests for "migrations/get-import-progress"

Get import progress.

  GET /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#get-import-progress
*/
func (c *Client) MigrationsGetImportProgress(ctx context.Context, req *MigrationsGetImportProgressReq, opt ...RequestOption) (*MigrationsGetImportProgressResponse, error) {
	if req == nil {
		req = new(MigrationsGetImportProgressReq)
	}
	resp := &MigrationsGetImportProgressResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsGetImportProgressResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsGetImportProgressReq is request data for Client.MigrationsGetImportProgress

https://developer.github.com/v3/migrations/source_imports/#get-import-progress
*/
type MigrationsGetImportProgressReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *MigrationsGetImportProgressReq) url() string {
	return r._url
}

func (r *MigrationsGetImportProgressReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo)
}

func (r *MigrationsGetImportProgressReq) method() string {
	return "GET"
}

func (r *MigrationsGetImportProgressReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsGetImportProgressReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsGetImportProgressReq) body() interface{} {
	return nil
}

func (r *MigrationsGetImportProgressReq) dataStatuses() []int {
	return []int{200}
}

func (r *MigrationsGetImportProgressReq) validStatuses() []int {
	return []int{200}
}

func (r *MigrationsGetImportProgressReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsGetImportProgressReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsGetImportProgressReq) Rel(link RelName, resp *MigrationsGetImportProgressResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsGetImportProgressResponseBody is a response body for MigrationsGetImportProgress

https://developer.github.com/v3/migrations/source_imports/#get-import-progress
*/
type MigrationsGetImportProgressResponseBody struct {
	components.Import
}

/*
MigrationsGetImportProgressResponse is a response for MigrationsGetImportProgress

https://developer.github.com/v3/migrations/source_imports/#get-import-progress
*/
type MigrationsGetImportProgressResponse struct {
	response
	request *MigrationsGetImportProgressReq
	Data    *MigrationsGetImportProgressResponseBody
}

/*
MigrationsGetLargeFiles performs requests for "migrations/get-large-files"

Get large files.

  GET /repos/{owner}/{repo}/import/large_files

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
func (c *Client) MigrationsGetLargeFiles(ctx context.Context, req *MigrationsGetLargeFilesReq, opt ...RequestOption) (*MigrationsGetLargeFilesResponse, error) {
	if req == nil {
		req = new(MigrationsGetLargeFilesReq)
	}
	resp := &MigrationsGetLargeFilesResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsGetLargeFilesResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsGetLargeFilesReq is request data for Client.MigrationsGetLargeFiles

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
type MigrationsGetLargeFilesReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *MigrationsGetLargeFilesReq) url() string {
	return r._url
}

func (r *MigrationsGetLargeFilesReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import/large_files", r.Owner, r.Repo)
}

func (r *MigrationsGetLargeFilesReq) method() string {
	return "GET"
}

func (r *MigrationsGetLargeFilesReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsGetLargeFilesReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsGetLargeFilesReq) body() interface{} {
	return nil
}

func (r *MigrationsGetLargeFilesReq) dataStatuses() []int {
	return []int{200}
}

func (r *MigrationsGetLargeFilesReq) validStatuses() []int {
	return []int{200}
}

func (r *MigrationsGetLargeFilesReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsGetLargeFilesReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsGetLargeFilesReq) Rel(link RelName, resp *MigrationsGetLargeFilesResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsGetLargeFilesResponseBody is a response body for MigrationsGetLargeFiles

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
type MigrationsGetLargeFilesResponseBody []struct {
	components.PorterLargeFile
}

/*
MigrationsGetLargeFilesResponse is a response for MigrationsGetLargeFiles

https://developer.github.com/v3/migrations/source_imports/#get-large-files
*/
type MigrationsGetLargeFilesResponse struct {
	response
	request *MigrationsGetLargeFilesReq
	Data    *MigrationsGetLargeFilesResponseBody
}

/*
MigrationsGetStatusForAuthenticatedUser performs requests for "migrations/get-status-for-authenticated-user"

Get the status of a user migration.

  GET /user/migrations/{migration_id}

https://developer.github.com/v3/migrations/users/#get-the-status-of-a-user-migration
*/
func (c *Client) MigrationsGetStatusForAuthenticatedUser(ctx context.Context, req *MigrationsGetStatusForAuthenticatedUserReq, opt ...RequestOption) (*MigrationsGetStatusForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(MigrationsGetStatusForAuthenticatedUserReq)
	}
	resp := &MigrationsGetStatusForAuthenticatedUserResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsGetStatusForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsGetStatusForAuthenticatedUserReq is request data for Client.MigrationsGetStatusForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#get-the-status-of-a-user-migration
*/
type MigrationsGetStatusForAuthenticatedUserReq struct {
	_url        string
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/migrations/%v", r.MigrationId)
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *MigrationsGetStatusForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsGetStatusForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsGetStatusForAuthenticatedUserReq) Rel(link RelName, resp *MigrationsGetStatusForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsGetStatusForAuthenticatedUserResponseBody is a response body for MigrationsGetStatusForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#get-the-status-of-a-user-migration
*/
type MigrationsGetStatusForAuthenticatedUserResponseBody struct {
	components.Migration
}

/*
MigrationsGetStatusForAuthenticatedUserResponse is a response for MigrationsGetStatusForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#get-the-status-of-a-user-migration
*/
type MigrationsGetStatusForAuthenticatedUserResponse struct {
	response
	request *MigrationsGetStatusForAuthenticatedUserReq
	Data    *MigrationsGetStatusForAuthenticatedUserResponseBody
}

/*
MigrationsGetStatusForOrg performs requests for "migrations/get-status-for-org"

Get the status of an organization migration.

  GET /orgs/{org}/migrations/{migration_id}

https://developer.github.com/v3/migrations/orgs/#get-the-status-of-an-organization-migration
*/
func (c *Client) MigrationsGetStatusForOrg(ctx context.Context, req *MigrationsGetStatusForOrgReq, opt ...RequestOption) (*MigrationsGetStatusForOrgResponse, error) {
	if req == nil {
		req = new(MigrationsGetStatusForOrgReq)
	}
	resp := &MigrationsGetStatusForOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsGetStatusForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsGetStatusForOrgReq is request data for Client.MigrationsGetStatusForOrg

https://developer.github.com/v3/migrations/orgs/#get-the-status-of-an-organization-migration
*/
type MigrationsGetStatusForOrgReq struct {
	_url        string
	Org         string
	MigrationId int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsGetStatusForOrgReq) url() string {
	return r._url
}

func (r *MigrationsGetStatusForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations/%v", r.Org, r.MigrationId)
}

func (r *MigrationsGetStatusForOrgReq) method() string {
	return "GET"
}

func (r *MigrationsGetStatusForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsGetStatusForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsGetStatusForOrgReq) body() interface{} {
	return nil
}

func (r *MigrationsGetStatusForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *MigrationsGetStatusForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *MigrationsGetStatusForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsGetStatusForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsGetStatusForOrgReq) Rel(link RelName, resp *MigrationsGetStatusForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsGetStatusForOrgResponseBody is a response body for MigrationsGetStatusForOrg

https://developer.github.com/v3/migrations/orgs/#get-the-status-of-an-organization-migration
*/
type MigrationsGetStatusForOrgResponseBody struct {
	components.MigrationWithShortOrg
}

/*
MigrationsGetStatusForOrgResponse is a response for MigrationsGetStatusForOrg

https://developer.github.com/v3/migrations/orgs/#get-the-status-of-an-organization-migration
*/
type MigrationsGetStatusForOrgResponse struct {
	response
	request *MigrationsGetStatusForOrgReq
	Data    *MigrationsGetStatusForOrgResponseBody
}

/*
MigrationsListForAuthenticatedUser performs requests for "migrations/list-for-authenticated-user"

List user migrations.

  GET /user/migrations

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
func (c *Client) MigrationsListForAuthenticatedUser(ctx context.Context, req *MigrationsListForAuthenticatedUserReq, opt ...RequestOption) (*MigrationsListForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(MigrationsListForAuthenticatedUserReq)
	}
	resp := &MigrationsListForAuthenticatedUserResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsListForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsListForAuthenticatedUserReq is request data for Client.MigrationsListForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
type MigrationsListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsListForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *MigrationsListForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/migrations")
}

func (r *MigrationsListForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *MigrationsListForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *MigrationsListForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsListForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *MigrationsListForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *MigrationsListForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *MigrationsListForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsListForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsListForAuthenticatedUserReq) Rel(link RelName, resp *MigrationsListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsListForAuthenticatedUserResponseBody is a response body for MigrationsListForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
type MigrationsListForAuthenticatedUserResponseBody []struct {
	components.Migration
}

/*
MigrationsListForAuthenticatedUserResponse is a response for MigrationsListForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#list-user-migrations
*/
type MigrationsListForAuthenticatedUserResponse struct {
	response
	request *MigrationsListForAuthenticatedUserReq
	Data    *MigrationsListForAuthenticatedUserResponseBody
}

/*
MigrationsListForOrg performs requests for "migrations/list-for-org"

List organization migrations.

  GET /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
func (c *Client) MigrationsListForOrg(ctx context.Context, req *MigrationsListForOrgReq, opt ...RequestOption) (*MigrationsListForOrgResponse, error) {
	if req == nil {
		req = new(MigrationsListForOrgReq)
	}
	resp := &MigrationsListForOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsListForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsListForOrgReq is request data for Client.MigrationsListForOrg

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
type MigrationsListForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsListForOrgReq) url() string {
	return r._url
}

func (r *MigrationsListForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations", r.Org)
}

func (r *MigrationsListForOrgReq) method() string {
	return "GET"
}

func (r *MigrationsListForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *MigrationsListForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsListForOrgReq) body() interface{} {
	return nil
}

func (r *MigrationsListForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *MigrationsListForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *MigrationsListForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsListForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsListForOrgReq) Rel(link RelName, resp *MigrationsListForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsListForOrgResponseBody is a response body for MigrationsListForOrg

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
type MigrationsListForOrgResponseBody []struct {
	components.MigrationWithShortOrg
}

/*
MigrationsListForOrgResponse is a response for MigrationsListForOrg

https://developer.github.com/v3/migrations/orgs/#list-organization-migrations
*/
type MigrationsListForOrgResponse struct {
	response
	request *MigrationsListForOrgReq
	Data    *MigrationsListForOrgResponseBody
}

/*
MigrationsListReposForOrg performs requests for "migrations/list-repos-for-org"

List repositories in an organization migration.

  GET /orgs/{org}/migrations/{migration_id}/repositories

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
func (c *Client) MigrationsListReposForOrg(ctx context.Context, req *MigrationsListReposForOrgReq, opt ...RequestOption) (*MigrationsListReposForOrgResponse, error) {
	if req == nil {
		req = new(MigrationsListReposForOrgReq)
	}
	resp := &MigrationsListReposForOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsListReposForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsListReposForOrgReq is request data for Client.MigrationsListReposForOrg

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
type MigrationsListReposForOrgReq struct {
	_url        string
	Org         string
	MigrationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsListReposForOrgReq) url() string {
	return r._url
}

func (r *MigrationsListReposForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations/%v/repositories", r.Org, r.MigrationId)
}

func (r *MigrationsListReposForOrgReq) method() string {
	return "GET"
}

func (r *MigrationsListReposForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *MigrationsListReposForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsListReposForOrgReq) body() interface{} {
	return nil
}

func (r *MigrationsListReposForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *MigrationsListReposForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *MigrationsListReposForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsListReposForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsListReposForOrgReq) Rel(link RelName, resp *MigrationsListReposForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsListReposForOrgResponseBody is a response body for MigrationsListReposForOrg

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
type MigrationsListReposForOrgResponseBody []struct {
	components.MinimalRepository
}

/*
MigrationsListReposForOrgResponse is a response for MigrationsListReposForOrg

https://developer.github.com/v3/migrations/orgs/#list-repositories-in-an-organization-migration
*/
type MigrationsListReposForOrgResponse struct {
	response
	request *MigrationsListReposForOrgReq
	Data    *MigrationsListReposForOrgResponseBody
}

/*
MigrationsListReposForUser performs requests for "migrations/list-repos-for-user"

List repositories for a user migration.

  GET /user/{migration_id}/repositories

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
func (c *Client) MigrationsListReposForUser(ctx context.Context, req *MigrationsListReposForUserReq, opt ...RequestOption) (*MigrationsListReposForUserResponse, error) {
	if req == nil {
		req = new(MigrationsListReposForUserReq)
	}
	resp := &MigrationsListReposForUserResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsListReposForUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsListReposForUserReq is request data for Client.MigrationsListReposForUser

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
type MigrationsListReposForUserReq struct {
	_url        string
	MigrationId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsListReposForUserReq) url() string {
	return r._url
}

func (r *MigrationsListReposForUserReq) urlPath() string {
	return fmt.Sprintf("/user/%v/repositories", r.MigrationId)
}

func (r *MigrationsListReposForUserReq) method() string {
	return "GET"
}

func (r *MigrationsListReposForUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *MigrationsListReposForUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsListReposForUserReq) body() interface{} {
	return nil
}

func (r *MigrationsListReposForUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *MigrationsListReposForUserReq) validStatuses() []int {
	return []int{200}
}

func (r *MigrationsListReposForUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsListReposForUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsListReposForUserReq) Rel(link RelName, resp *MigrationsListReposForUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsListReposForUserResponseBody is a response body for MigrationsListReposForUser

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
type MigrationsListReposForUserResponseBody []struct {
	components.MinimalRepository
}

/*
MigrationsListReposForUserResponse is a response for MigrationsListReposForUser

https://developer.github.com/v3/migrations/users/#list-repositories-for-a-user-migration
*/
type MigrationsListReposForUserResponse struct {
	response
	request *MigrationsListReposForUserReq
	Data    *MigrationsListReposForUserResponseBody
}

/*
MigrationsMapCommitAuthor performs requests for "migrations/map-commit-author"

Map a commit author.

  PATCH /repos/{owner}/{repo}/import/authors/{author_id}

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
func (c *Client) MigrationsMapCommitAuthor(ctx context.Context, req *MigrationsMapCommitAuthorReq, opt ...RequestOption) (*MigrationsMapCommitAuthorResponse, error) {
	if req == nil {
		req = new(MigrationsMapCommitAuthorReq)
	}
	resp := &MigrationsMapCommitAuthorResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsMapCommitAuthorResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsMapCommitAuthorReq is request data for Client.MigrationsMapCommitAuthor

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MigrationsMapCommitAuthorReq struct {
	_url        string
	Owner       string
	Repo        string
	AuthorId    int64
	RequestBody MigrationsMapCommitAuthorReqBody
}

func (r *MigrationsMapCommitAuthorReq) url() string {
	return r._url
}

func (r *MigrationsMapCommitAuthorReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import/authors/%v", r.Owner, r.Repo, r.AuthorId)
}

func (r *MigrationsMapCommitAuthorReq) method() string {
	return "PATCH"
}

func (r *MigrationsMapCommitAuthorReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsMapCommitAuthorReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsMapCommitAuthorReq) body() interface{} {
	return r.RequestBody
}

func (r *MigrationsMapCommitAuthorReq) dataStatuses() []int {
	return []int{200}
}

func (r *MigrationsMapCommitAuthorReq) validStatuses() []int {
	return []int{200}
}

func (r *MigrationsMapCommitAuthorReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *MigrationsMapCommitAuthorReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsMapCommitAuthorReq) Rel(link RelName, resp *MigrationsMapCommitAuthorResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsMapCommitAuthorReqBody is a request body for migrations/map-commit-author

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MigrationsMapCommitAuthorReqBody struct {

	// The new Git author email.
	Email *string `json:"email,omitempty"`

	// The new Git author name.
	Name *string `json:"name,omitempty"`
}

/*
MigrationsMapCommitAuthorResponseBody is a response body for MigrationsMapCommitAuthor

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MigrationsMapCommitAuthorResponseBody struct {
	components.PorterAuthor
}

/*
MigrationsMapCommitAuthorResponse is a response for MigrationsMapCommitAuthor

https://developer.github.com/v3/migrations/source_imports/#map-a-commit-author
*/
type MigrationsMapCommitAuthorResponse struct {
	response
	request *MigrationsMapCommitAuthorReq
	Data    *MigrationsMapCommitAuthorResponseBody
}

/*
MigrationsSetLfsPreference performs requests for "migrations/set-lfs-preference"

Set Git LFS preference.

  PATCH /repos/{owner}/{repo}/import/lfs

https://developer.github.com/v3/migrations/source_imports/#set-git-lfs-preference
*/
func (c *Client) MigrationsSetLfsPreference(ctx context.Context, req *MigrationsSetLfsPreferenceReq, opt ...RequestOption) (*MigrationsSetLfsPreferenceResponse, error) {
	if req == nil {
		req = new(MigrationsSetLfsPreferenceReq)
	}
	resp := &MigrationsSetLfsPreferenceResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsSetLfsPreferenceResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsSetLfsPreferenceReq is request data for Client.MigrationsSetLfsPreference

https://developer.github.com/v3/migrations/source_imports/#set-git-lfs-preference
*/
type MigrationsSetLfsPreferenceReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody MigrationsSetLfsPreferenceReqBody
}

func (r *MigrationsSetLfsPreferenceReq) url() string {
	return r._url
}

func (r *MigrationsSetLfsPreferenceReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import/lfs", r.Owner, r.Repo)
}

func (r *MigrationsSetLfsPreferenceReq) method() string {
	return "PATCH"
}

func (r *MigrationsSetLfsPreferenceReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsSetLfsPreferenceReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsSetLfsPreferenceReq) body() interface{} {
	return r.RequestBody
}

func (r *MigrationsSetLfsPreferenceReq) dataStatuses() []int {
	return []int{200}
}

func (r *MigrationsSetLfsPreferenceReq) validStatuses() []int {
	return []int{200}
}

func (r *MigrationsSetLfsPreferenceReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *MigrationsSetLfsPreferenceReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsSetLfsPreferenceReq) Rel(link RelName, resp *MigrationsSetLfsPreferenceResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsSetLfsPreferenceReqBody is a request body for migrations/set-lfs-preference

https://developer.github.com/v3/migrations/source_imports/#set-git-lfs-preference
*/
type MigrationsSetLfsPreferenceReqBody struct {

	/*
	   Can be one of `opt_in` (large files will be stored using Git LFS) or `opt_out`
	   (large files will be removed during the import).
	*/
	UseLfs *string `json:"use_lfs"`
}

/*
MigrationsSetLfsPreferenceResponseBody is a response body for MigrationsSetLfsPreference

https://developer.github.com/v3/migrations/source_imports/#set-git-lfs-preference
*/
type MigrationsSetLfsPreferenceResponseBody struct {
	components.Import
}

/*
MigrationsSetLfsPreferenceResponse is a response for MigrationsSetLfsPreference

https://developer.github.com/v3/migrations/source_imports/#set-git-lfs-preference
*/
type MigrationsSetLfsPreferenceResponse struct {
	response
	request *MigrationsSetLfsPreferenceReq
	Data    *MigrationsSetLfsPreferenceResponseBody
}

/*
MigrationsStartForAuthenticatedUser performs requests for "migrations/start-for-authenticated-user"

Start a user migration.

  POST /user/migrations

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
func (c *Client) MigrationsStartForAuthenticatedUser(ctx context.Context, req *MigrationsStartForAuthenticatedUserReq, opt ...RequestOption) (*MigrationsStartForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(MigrationsStartForAuthenticatedUserReq)
	}
	resp := &MigrationsStartForAuthenticatedUserResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsStartForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsStartForAuthenticatedUserReq is request data for Client.MigrationsStartForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type MigrationsStartForAuthenticatedUserReq struct {
	_url        string
	RequestBody MigrationsStartForAuthenticatedUserReqBody
}

func (r *MigrationsStartForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *MigrationsStartForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/migrations")
}

func (r *MigrationsStartForAuthenticatedUserReq) method() string {
	return "POST"
}

func (r *MigrationsStartForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsStartForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsStartForAuthenticatedUserReq) body() interface{} {
	return r.RequestBody
}

func (r *MigrationsStartForAuthenticatedUserReq) dataStatuses() []int {
	return []int{201}
}

func (r *MigrationsStartForAuthenticatedUserReq) validStatuses() []int {
	return []int{201}
}

func (r *MigrationsStartForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *MigrationsStartForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsStartForAuthenticatedUserReq) Rel(link RelName, resp *MigrationsStartForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsStartForAuthenticatedUserReqBody is a request body for migrations/start-for-authenticated-user

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type MigrationsStartForAuthenticatedUserReqBody struct {

	/*
	   Does not include attachments uploaded to GitHub.com in the migration data when
	   set to `true`. Excluding attachments will reduce the migration archive file
	   size.
	*/
	ExcludeAttachments *bool `json:"exclude_attachments,omitempty"`

	/*
	   Locks the `repositories` to prevent changes during the migration when set to
	   `true`.
	*/
	LockRepositories *bool `json:"lock_repositories,omitempty"`

	// An array of repositories to include in the migration.
	Repositories []string `json:"repositories"`
}

/*
MigrationsStartForAuthenticatedUserResponseBody is a response body for MigrationsStartForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type MigrationsStartForAuthenticatedUserResponseBody struct {
	components.Migration
}

/*
MigrationsStartForAuthenticatedUserResponse is a response for MigrationsStartForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#start-a-user-migration
*/
type MigrationsStartForAuthenticatedUserResponse struct {
	response
	request *MigrationsStartForAuthenticatedUserReq
	Data    *MigrationsStartForAuthenticatedUserResponseBody
}

/*
MigrationsStartForOrg performs requests for "migrations/start-for-org"

Start an organization migration.

  POST /orgs/{org}/migrations

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
func (c *Client) MigrationsStartForOrg(ctx context.Context, req *MigrationsStartForOrgReq, opt ...RequestOption) (*MigrationsStartForOrgResponse, error) {
	if req == nil {
		req = new(MigrationsStartForOrgReq)
	}
	resp := &MigrationsStartForOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsStartForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsStartForOrgReq is request data for Client.MigrationsStartForOrg

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type MigrationsStartForOrgReq struct {
	_url        string
	Org         string
	RequestBody MigrationsStartForOrgReqBody
}

func (r *MigrationsStartForOrgReq) url() string {
	return r._url
}

func (r *MigrationsStartForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations", r.Org)
}

func (r *MigrationsStartForOrgReq) method() string {
	return "POST"
}

func (r *MigrationsStartForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsStartForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsStartForOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *MigrationsStartForOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *MigrationsStartForOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *MigrationsStartForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *MigrationsStartForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsStartForOrgReq) Rel(link RelName, resp *MigrationsStartForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsStartForOrgReqBody is a request body for migrations/start-for-org

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type MigrationsStartForOrgReqBody struct {

	/*
	   Indicates whether attachments should be excluded from the migration (to reduce
	   migration archive file size).
	*/
	ExcludeAttachments *bool `json:"exclude_attachments,omitempty"`

	/*
	   Indicates whether repositories should be locked (to prevent manipulation) while
	   migrating data.
	*/
	LockRepositories *bool `json:"lock_repositories,omitempty"`

	// A list of arrays indicating which repositories should be migrated.
	Repositories []string `json:"repositories"`
}

/*
MigrationsStartForOrgResponseBody is a response body for MigrationsStartForOrg

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type MigrationsStartForOrgResponseBody struct {
	components.MigrationWithShortOrg
}

/*
MigrationsStartForOrgResponse is a response for MigrationsStartForOrg

https://developer.github.com/v3/migrations/orgs/#start-an-organization-migration
*/
type MigrationsStartForOrgResponse struct {
	response
	request *MigrationsStartForOrgReq
	Data    *MigrationsStartForOrgResponseBody
}

/*
MigrationsStartImport performs requests for "migrations/start-import"

Start an import.

  PUT /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
func (c *Client) MigrationsStartImport(ctx context.Context, req *MigrationsStartImportReq, opt ...RequestOption) (*MigrationsStartImportResponse, error) {
	if req == nil {
		req = new(MigrationsStartImportReq)
	}
	resp := &MigrationsStartImportResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsStartImportResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsStartImportReq is request data for Client.MigrationsStartImport

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type MigrationsStartImportReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody MigrationsStartImportReqBody
}

func (r *MigrationsStartImportReq) url() string {
	return r._url
}

func (r *MigrationsStartImportReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo)
}

func (r *MigrationsStartImportReq) method() string {
	return "PUT"
}

func (r *MigrationsStartImportReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsStartImportReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsStartImportReq) body() interface{} {
	return r.RequestBody
}

func (r *MigrationsStartImportReq) dataStatuses() []int {
	return []int{201}
}

func (r *MigrationsStartImportReq) validStatuses() []int {
	return []int{201}
}

func (r *MigrationsStartImportReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *MigrationsStartImportReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsStartImportReq) Rel(link RelName, resp *MigrationsStartImportResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsStartImportReqBody is a request body for migrations/start-import

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type MigrationsStartImportReqBody struct {

	// For a tfvc import, the name of the project that is being imported.
	TfvcProject *string `json:"tfvc_project,omitempty"`

	/*
	   The originating VCS type. Can be one of `subversion`, `git`, `mercurial`, or
	   `tfvc`. Please be aware that without this parameter, the import job will take
	   additional time to detect the VCS type before beginning the import. This
	   detection step will be reflected in the response.
	*/
	Vcs *string `json:"vcs,omitempty"`

	// If authentication is required, the password to provide to `vcs_url`.
	VcsPassword *string `json:"vcs_password,omitempty"`

	// The URL of the originating repository.
	VcsUrl *string `json:"vcs_url"`

	// If authentication is required, the username to provide to `vcs_url`.
	VcsUsername *string `json:"vcs_username,omitempty"`
}

/*
MigrationsStartImportResponseBody is a response body for MigrationsStartImport

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type MigrationsStartImportResponseBody struct {
	components.Import2
}

/*
MigrationsStartImportResponse is a response for MigrationsStartImport

https://developer.github.com/v3/migrations/source_imports/#start-an-import
*/
type MigrationsStartImportResponse struct {
	response
	request *MigrationsStartImportReq
	Data    *MigrationsStartImportResponseBody
}

/*
MigrationsUnlockRepoForAuthenticatedUser performs requests for "migrations/unlock-repo-for-authenticated-user"

Unlock a user repository.

  DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
func (c *Client) MigrationsUnlockRepoForAuthenticatedUser(ctx context.Context, req *MigrationsUnlockRepoForAuthenticatedUserReq, opt ...RequestOption) (*MigrationsUnlockRepoForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(MigrationsUnlockRepoForAuthenticatedUserReq)
	}
	resp := &MigrationsUnlockRepoForAuthenticatedUserResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsUnlockRepoForAuthenticatedUserReq is request data for Client.MigrationsUnlockRepoForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
type MigrationsUnlockRepoForAuthenticatedUserReq struct {
	_url        string
	MigrationId int64
	RepoName    string

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/migrations/%v/repos/%v/lock", r.MigrationId, r.RepoName)
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) method() string {
	return "DELETE"
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) dataStatuses() []int {
	return []int{}
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) validStatuses() []int {
	return []int{204}
}

func (r *MigrationsUnlockRepoForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsUnlockRepoForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsUnlockRepoForAuthenticatedUserReq) Rel(link RelName, resp *MigrationsUnlockRepoForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsUnlockRepoForAuthenticatedUserResponse is a response for MigrationsUnlockRepoForAuthenticatedUser

https://developer.github.com/v3/migrations/users/#unlock-a-user-repository
*/
type MigrationsUnlockRepoForAuthenticatedUserResponse struct {
	response
	request *MigrationsUnlockRepoForAuthenticatedUserReq
}

/*
MigrationsUnlockRepoForOrg performs requests for "migrations/unlock-repo-for-org"

Unlock an organization repository.

  DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
func (c *Client) MigrationsUnlockRepoForOrg(ctx context.Context, req *MigrationsUnlockRepoForOrgReq, opt ...RequestOption) (*MigrationsUnlockRepoForOrgResponse, error) {
	if req == nil {
		req = new(MigrationsUnlockRepoForOrgReq)
	}
	resp := &MigrationsUnlockRepoForOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsUnlockRepoForOrgReq is request data for Client.MigrationsUnlockRepoForOrg

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
type MigrationsUnlockRepoForOrgReq struct {
	_url        string
	Org         string
	MigrationId int64
	RepoName    string

	// To access the Migrations API, you must set this to true.
	WyandottePreview bool
}

func (r *MigrationsUnlockRepoForOrgReq) url() string {
	return r._url
}

func (r *MigrationsUnlockRepoForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/migrations/%v/repos/%v/lock", r.Org, r.MigrationId, r.RepoName)
}

func (r *MigrationsUnlockRepoForOrgReq) method() string {
	return "DELETE"
}

func (r *MigrationsUnlockRepoForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsUnlockRepoForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"wyandotte": r.WyandottePreview}
	if requiredPreviews {
		previewVals["wyandotte"] = true
	}
	if allPreviews {
		previewVals["wyandotte"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsUnlockRepoForOrgReq) body() interface{} {
	return nil
}

func (r *MigrationsUnlockRepoForOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *MigrationsUnlockRepoForOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *MigrationsUnlockRepoForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *MigrationsUnlockRepoForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsUnlockRepoForOrgReq) Rel(link RelName, resp *MigrationsUnlockRepoForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsUnlockRepoForOrgResponse is a response for MigrationsUnlockRepoForOrg

https://developer.github.com/v3/migrations/orgs/#unlock-an-organization-repository
*/
type MigrationsUnlockRepoForOrgResponse struct {
	response
	request *MigrationsUnlockRepoForOrgReq
}

/*
MigrationsUpdateImport performs requests for "migrations/update-import"

Update existing import.

  PATCH /repos/{owner}/{repo}/import

https://developer.github.com/v3/migrations/source_imports/#update-existing-import
*/
func (c *Client) MigrationsUpdateImport(ctx context.Context, req *MigrationsUpdateImportReq, opt ...RequestOption) (*MigrationsUpdateImportResponse, error) {
	if req == nil {
		req = new(MigrationsUpdateImportReq)
	}
	resp := &MigrationsUpdateImportResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(MigrationsUpdateImportResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
MigrationsUpdateImportReq is request data for Client.MigrationsUpdateImport

https://developer.github.com/v3/migrations/source_imports/#update-existing-import
*/
type MigrationsUpdateImportReq struct {
	_url        string
	Owner       string
	Repo        string
	RequestBody MigrationsUpdateImportReqBody
}

func (r *MigrationsUpdateImportReq) url() string {
	return r._url
}

func (r *MigrationsUpdateImportReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/import", r.Owner, r.Repo)
}

func (r *MigrationsUpdateImportReq) method() string {
	return "PATCH"
}

func (r *MigrationsUpdateImportReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *MigrationsUpdateImportReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *MigrationsUpdateImportReq) body() interface{} {
	return r.RequestBody
}

func (r *MigrationsUpdateImportReq) dataStatuses() []int {
	return []int{200}
}

func (r *MigrationsUpdateImportReq) validStatuses() []int {
	return []int{200}
}

func (r *MigrationsUpdateImportReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *MigrationsUpdateImportReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *MigrationsUpdateImportReq) Rel(link RelName, resp *MigrationsUpdateImportResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
MigrationsUpdateImportReqBody is a request body for migrations/update-import

https://developer.github.com/v3/migrations/source_imports/#update-existing-import
*/
type MigrationsUpdateImportReqBody struct {

	// The password to provide to the originating repository.
	VcsPassword *string `json:"vcs_password,omitempty"`

	// The username to provide to the originating repository.
	VcsUsername *string `json:"vcs_username,omitempty"`
}

/*
MigrationsUpdateImportResponseBody is a response body for MigrationsUpdateImport

https://developer.github.com/v3/migrations/source_imports/#update-existing-import
*/
type MigrationsUpdateImportResponseBody struct {
	components.Import3
}

/*
MigrationsUpdateImportResponse is a response for MigrationsUpdateImport

https://developer.github.com/v3/migrations/source_imports/#update-existing-import
*/
type MigrationsUpdateImportResponse struct {
	response
	request *MigrationsUpdateImportReq
	Data    *MigrationsUpdateImportResponseBody
}
