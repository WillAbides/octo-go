// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
TeamsAddOrUpdateMembershipForUserInOrg performs requests for "teams/add-or-update-membership-for-user-in-org"

Add or update team membership for a user.

  PUT /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
func TeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateMembershipForUserInOrgResponse, error) {
	if req == nil {
		req = new(TeamsAddOrUpdateMembershipForUserInOrgReq)
	}
	resp := &TeamsAddOrUpdateMembershipForUserInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsAddOrUpdateMembershipForUserInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateMembershipForUserInOrg performs requests for "teams/add-or-update-membership-for-user-in-org"

Add or update team membership for a user.

  PUT /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
func (c Client) TeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateMembershipForUserInOrgResponse, error) {
	return TeamsAddOrUpdateMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateMembershipForUserInOrgReq is request data for Client.TeamsAddOrUpdateMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type TeamsAddOrUpdateMembershipForUserInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	Username    string
	RequestBody TeamsAddOrUpdateMembershipForUserInOrgReqBody
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) url() string {
	return r._url
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username)
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) method() string {
	return "PUT"
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) Rel(link RelName, resp *TeamsAddOrUpdateMembershipForUserInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateMembershipForUserInOrgReqBody is a request body for teams/add-or-update-membership-for-user-in-org

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type TeamsAddOrUpdateMembershipForUserInOrgReqBody struct {

	/*
	   The role that this user should have in the team. Can be one of:
	   \* `member` - a normal member of the team.
	   \* `maintainer` - a team maintainer. Able to add/remove other team members,
	   promote other team members to team maintainer, and edit the team's name and
	   description.
	*/
	Role *string `json:"role,omitempty"`
}

/*
TeamsAddOrUpdateMembershipForUserInOrgResponseBody is a response body for TeamsAddOrUpdateMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type TeamsAddOrUpdateMembershipForUserInOrgResponseBody struct {
	components.TeamMembership
}

/*
TeamsAddOrUpdateMembershipForUserInOrgResponse is a response for TeamsAddOrUpdateMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type TeamsAddOrUpdateMembershipForUserInOrgResponse struct {
	response
	request *TeamsAddOrUpdateMembershipForUserInOrgReq
	Data    *TeamsAddOrUpdateMembershipForUserInOrgResponseBody
}

/*
TeamsAddOrUpdateProjectPermissionsInOrg performs requests for "teams/add-or-update-project-permissions-in-org"

Add or update team project permissions.

  PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
func TeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateProjectPermissionsInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateProjectPermissionsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsAddOrUpdateProjectPermissionsInOrgReq)
	}
	resp := &TeamsAddOrUpdateProjectPermissionsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateProjectPermissionsInOrg performs requests for "teams/add-or-update-project-permissions-in-org"

Add or update team project permissions.

  PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
func (c Client) TeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateProjectPermissionsInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateProjectPermissionsInOrgResponse, error) {
	return TeamsAddOrUpdateProjectPermissionsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateProjectPermissionsInOrgReq is request data for Client.TeamsAddOrUpdateProjectPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type TeamsAddOrUpdateProjectPermissionsInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	ProjectId   int64
	RequestBody TeamsAddOrUpdateProjectPermissionsInOrgReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) url() string {
	return r._url
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId)
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) method() string {
	return "PUT"
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) Rel(link RelName, resp *TeamsAddOrUpdateProjectPermissionsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateProjectPermissionsInOrgReqBody is a request body for teams/add-or-update-project-permissions-in-org

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type TeamsAddOrUpdateProjectPermissionsInOrgReqBody struct {

	/*
	   The permission to grant to the team for this project. Can be one of:
	   \* `read` - team members can read, but not write to or administer this project.
	   \* `write` - team members can read and write, but not administer this project.
	   \* `admin` - team members can read, write and administer this project.
	   Default: the team's `permission` attribute will be used to determine what
	   permission to grant the team on this project. Note that, if you choose not to
	   pass any parameters, you'll need to set `Content-Length` to zero when calling
	   out to this endpoint. For more information, see "[HTTP
	   verbs](https://developer.github.com/v3/#http-verbs)."
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
TeamsAddOrUpdateProjectPermissionsInOrgResponse is a response for TeamsAddOrUpdateProjectPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type TeamsAddOrUpdateProjectPermissionsInOrgResponse struct {
	response
	request *TeamsAddOrUpdateProjectPermissionsInOrgReq
}

/*
TeamsAddOrUpdateRepoPermissionsInOrg performs requests for "teams/add-or-update-repo-permissions-in-org"

Add or update team repository permissions.

  PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
func TeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateRepoPermissionsInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateRepoPermissionsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsAddOrUpdateRepoPermissionsInOrgReq)
	}
	resp := &TeamsAddOrUpdateRepoPermissionsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateRepoPermissionsInOrg performs requests for "teams/add-or-update-repo-permissions-in-org"

Add or update team repository permissions.

  PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
func (c Client) TeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateRepoPermissionsInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateRepoPermissionsInOrgResponse, error) {
	return TeamsAddOrUpdateRepoPermissionsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateRepoPermissionsInOrgReq is request data for Client.TeamsAddOrUpdateRepoPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type TeamsAddOrUpdateRepoPermissionsInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	Owner       string
	Repo        string
	RequestBody TeamsAddOrUpdateRepoPermissionsInOrgReqBody
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) url() string {
	return r._url
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo)
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) method() string {
	return "PUT"
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) Rel(link RelName, resp *TeamsAddOrUpdateRepoPermissionsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateRepoPermissionsInOrgReqBody is a request body for teams/add-or-update-repo-permissions-in-org

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type TeamsAddOrUpdateRepoPermissionsInOrgReqBody struct {

	/*
	   The permission to grant the team on this repository. Can be one of:
	   \* `pull` - team members can pull, but not push to or administer this
	   repository.
	   \* `push` - team members can pull and push, but not administer this repository.
	   \* `admin` - team members can pull, push and administer this repository.
	   \* `maintain` - team members can manage the repository without access to
	   sensitive or destructive actions. Recommended for project managers. Only applies
	   to repositories owned by organizations.
	   \* `triage` - team members can proactively manage issues and pull requests
	   without write access. Recommended for contributors who triage a repository. Only
	   applies to repositories owned by organizations.

	   If no permission is specified, the team's `permission` attribute will be used to
	   determine what permission to grant the team on this repository.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
TeamsAddOrUpdateRepoPermissionsInOrgResponse is a response for TeamsAddOrUpdateRepoPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type TeamsAddOrUpdateRepoPermissionsInOrgResponse struct {
	response
	request *TeamsAddOrUpdateRepoPermissionsInOrgReq
}

/*
TeamsCheckPermissionsForProjectInOrg performs requests for "teams/check-permissions-for-project-in-org"

Check team permissions for a project.

  GET /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
func TeamsCheckPermissionsForProjectInOrg(ctx context.Context, req *TeamsCheckPermissionsForProjectInOrgReq, opt ...RequestOption) (*TeamsCheckPermissionsForProjectInOrgResponse, error) {
	if req == nil {
		req = new(TeamsCheckPermissionsForProjectInOrgReq)
	}
	resp := &TeamsCheckPermissionsForProjectInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCheckPermissionsForProjectInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCheckPermissionsForProjectInOrg performs requests for "teams/check-permissions-for-project-in-org"

Check team permissions for a project.

  GET /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
func (c Client) TeamsCheckPermissionsForProjectInOrg(ctx context.Context, req *TeamsCheckPermissionsForProjectInOrgReq, opt ...RequestOption) (*TeamsCheckPermissionsForProjectInOrgResponse, error) {
	return TeamsCheckPermissionsForProjectInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCheckPermissionsForProjectInOrgReq is request data for Client.TeamsCheckPermissionsForProjectInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
type TeamsCheckPermissionsForProjectInOrgReq struct {
	_url      string
	Org       string
	TeamSlug  string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) url() string {
	return r._url
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId)
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) method() string {
	return "GET"
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCheckPermissionsForProjectInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCheckPermissionsForProjectInOrgReq) Rel(link RelName, resp *TeamsCheckPermissionsForProjectInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCheckPermissionsForProjectInOrgResponseBody is a response body for TeamsCheckPermissionsForProjectInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
type TeamsCheckPermissionsForProjectInOrgResponseBody struct {
	components.TeamProject
}

/*
TeamsCheckPermissionsForProjectInOrgResponse is a response for TeamsCheckPermissionsForProjectInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
type TeamsCheckPermissionsForProjectInOrgResponse struct {
	response
	request *TeamsCheckPermissionsForProjectInOrgReq
	Data    *TeamsCheckPermissionsForProjectInOrgResponseBody
}

/*
TeamsCheckPermissionsForRepoInOrg performs requests for "teams/check-permissions-for-repo-in-org"

Check team permissions for a repository.

  GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
func TeamsCheckPermissionsForRepoInOrg(ctx context.Context, req *TeamsCheckPermissionsForRepoInOrgReq, opt ...RequestOption) (*TeamsCheckPermissionsForRepoInOrgResponse, error) {
	if req == nil {
		req = new(TeamsCheckPermissionsForRepoInOrgReq)
	}
	resp := &TeamsCheckPermissionsForRepoInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCheckPermissionsForRepoInOrg performs requests for "teams/check-permissions-for-repo-in-org"

Check team permissions for a repository.

  GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
func (c Client) TeamsCheckPermissionsForRepoInOrg(ctx context.Context, req *TeamsCheckPermissionsForRepoInOrgReq, opt ...RequestOption) (*TeamsCheckPermissionsForRepoInOrgResponse, error) {
	return TeamsCheckPermissionsForRepoInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCheckPermissionsForRepoInOrgReq is request data for Client.TeamsCheckPermissionsForRepoInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
type TeamsCheckPermissionsForRepoInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
	Owner    string
	Repo     string
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) url() string {
	return r._url
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo)
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) method() string {
	return "GET"
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) validStatuses() []int {
	return []int{200, 204}
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCheckPermissionsForRepoInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCheckPermissionsForRepoInOrgReq) Rel(link RelName, resp *TeamsCheckPermissionsForRepoInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCheckPermissionsForRepoInOrgResponse is a response for TeamsCheckPermissionsForRepoInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
type TeamsCheckPermissionsForRepoInOrgResponse struct {
	response
	request *TeamsCheckPermissionsForRepoInOrgReq
}

/*
TeamsCreate performs requests for "teams/create"

Create a team.

  POST /orgs/{org}/teams

https://developer.github.com/v3/teams/#create-a-team
*/
func TeamsCreate(ctx context.Context, req *TeamsCreateReq, opt ...RequestOption) (*TeamsCreateResponse, error) {
	if req == nil {
		req = new(TeamsCreateReq)
	}
	resp := &TeamsCreateResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreate performs requests for "teams/create"

Create a team.

  POST /orgs/{org}/teams

https://developer.github.com/v3/teams/#create-a-team
*/
func (c Client) TeamsCreate(ctx context.Context, req *TeamsCreateReq, opt ...RequestOption) (*TeamsCreateResponse, error) {
	return TeamsCreate(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateReq is request data for Client.TeamsCreate

https://developer.github.com/v3/teams/#create-a-team
*/
type TeamsCreateReq struct {
	_url        string
	Org         string
	RequestBody TeamsCreateReqBody
}

func (r *TeamsCreateReq) url() string {
	return r._url
}

func (r *TeamsCreateReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams", r.Org)
}

func (r *TeamsCreateReq) method() string {
	return "POST"
}

func (r *TeamsCreateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateReq) Rel(link RelName, resp *TeamsCreateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateReqBody is a request body for teams/create

https://developer.github.com/v3/teams/#create-a-team
*/
type TeamsCreateReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// List GitHub IDs for organization members who will become team maintainers.
	Maintainers []string `json:"maintainers,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	   **Deprecated**. The permission that new repositories will be added to the team
	   with when none is specified. Can be one of:
	   \* `pull` - team members can pull, but not push to or administer newly-added
	   repositories.
	   \* `push` - team members can pull and push, but not administer newly-added
	   repositories.
	   \* `admin` - team members can pull, push and administer newly-added
	   repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	   The level of privacy this team should have. The options are:
	   **For a non-nested team:**
	   \* `secret` - only visible to organization owners and members of this team.
	   \* `closed` - visible to all members of this organization.
	   Default: `secret`
	   **For a parent or child team:**
	   \* `closed` - visible to all members of this organization.
	   Default for child team: `closed`
	*/
	Privacy *string `json:"privacy,omitempty"`

	/*
	   The full name (e.g., "organization-name/repository-name") of repositories to add
	   the team to.
	*/
	RepoNames []string `json:"repo_names,omitempty"`
}

/*
TeamsCreateResponseBody is a response body for TeamsCreate

https://developer.github.com/v3/teams/#create-a-team
*/
type TeamsCreateResponseBody struct {
	components.TeamFull
}

/*
TeamsCreateResponse is a response for TeamsCreate

https://developer.github.com/v3/teams/#create-a-team
*/
type TeamsCreateResponse struct {
	response
	request *TeamsCreateReq
	Data    *TeamsCreateResponseBody
}

/*
TeamsCreateDiscussionCommentInOrg performs requests for "teams/create-discussion-comment-in-org"

Create a discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
func TeamsCreateDiscussionCommentInOrg(ctx context.Context, req *TeamsCreateDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsCreateDiscussionCommentInOrgResponse, error) {
	if req == nil {
		req = new(TeamsCreateDiscussionCommentInOrgReq)
	}
	resp := &TeamsCreateDiscussionCommentInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateDiscussionCommentInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateDiscussionCommentInOrg performs requests for "teams/create-discussion-comment-in-org"

Create a discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
func (c Client) TeamsCreateDiscussionCommentInOrg(ctx context.Context, req *TeamsCreateDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsCreateDiscussionCommentInOrgResponse, error) {
	return TeamsCreateDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateDiscussionCommentInOrgReq is request data for Client.TeamsCreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type TeamsCreateDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      TeamsCreateDiscussionCommentInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsCreateDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *TeamsCreateDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsCreateDiscussionCommentInOrgReq) method() string {
	return "POST"
}

func (r *TeamsCreateDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateDiscussionCommentInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsCreateDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateDiscussionCommentInOrgReqBody is a request body for teams/create-discussion-comment-in-org

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type TeamsCreateDiscussionCommentInOrgReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
TeamsCreateDiscussionCommentInOrgResponseBody is a response body for TeamsCreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type TeamsCreateDiscussionCommentInOrgResponseBody struct {
	components.TeamDiscussionComment
}

/*
TeamsCreateDiscussionCommentInOrgResponse is a response for TeamsCreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type TeamsCreateDiscussionCommentInOrgResponse struct {
	response
	request *TeamsCreateDiscussionCommentInOrgReq
	Data    *TeamsCreateDiscussionCommentInOrgResponseBody
}

/*
TeamsCreateDiscussionInOrg performs requests for "teams/create-discussion-in-org"

Create a discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
func TeamsCreateDiscussionInOrg(ctx context.Context, req *TeamsCreateDiscussionInOrgReq, opt ...RequestOption) (*TeamsCreateDiscussionInOrgResponse, error) {
	if req == nil {
		req = new(TeamsCreateDiscussionInOrgReq)
	}
	resp := &TeamsCreateDiscussionInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateDiscussionInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateDiscussionInOrg performs requests for "teams/create-discussion-in-org"

Create a discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
func (c Client) TeamsCreateDiscussionInOrg(ctx context.Context, req *TeamsCreateDiscussionInOrgReq, opt ...RequestOption) (*TeamsCreateDiscussionInOrgResponse, error) {
	return TeamsCreateDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateDiscussionInOrgReq is request data for Client.TeamsCreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	RequestBody TeamsCreateDiscussionInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsCreateDiscussionInOrgReq) url() string {
	return r._url
}

func (r *TeamsCreateDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions", r.Org, r.TeamSlug)
}

func (r *TeamsCreateDiscussionInOrgReq) method() string {
	return "POST"
}

func (r *TeamsCreateDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateDiscussionInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateDiscussionInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionInOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateDiscussionInOrgReq) Rel(link RelName, resp *TeamsCreateDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateDiscussionInOrgReqBody is a request body for teams/create-discussion-in-org

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body"`

	/*
	   Private posts are only visible to team members, organization owners, and team
	   maintainers. Public posts are visible to all members of the organization. Set to
	   `true` to create a private post.
	*/
	Private *bool `json:"private,omitempty"`

	// The discussion post's title.
	Title *string `json:"title"`
}

/*
TeamsCreateDiscussionInOrgResponseBody is a response body for TeamsCreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgResponseBody struct {
	components.TeamDiscussion
}

/*
TeamsCreateDiscussionInOrgResponse is a response for TeamsCreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgResponse struct {
	response
	request *TeamsCreateDiscussionInOrgReq
	Data    *TeamsCreateDiscussionInOrgResponseBody
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrg performs requests for "teams/create-or-update-id-p-group-connections-in-org"

Create or update IdP group connections.

  PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
func TeamsCreateOrUpdateIdPGroupConnectionsInOrg(ctx context.Context, req *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq, opt ...RequestOption) (*TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq)
	}
	resp := &TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrg performs requests for "teams/create-or-update-id-p-group-connections-in-org"

Create or update IdP group connections.

  PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
func (c Client) TeamsCreateOrUpdateIdPGroupConnectionsInOrg(ctx context.Context, req *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq, opt ...RequestOption) (*TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse, error) {
	return TeamsCreateOrUpdateIdPGroupConnectionsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq is request data for Client.TeamsCreateOrUpdateIdPGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	RequestBody TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBody
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) url() string {
	return r._url
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/team-sync/group-mappings", r.Org, r.TeamSlug)
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) method() string {
	return "PATCH"
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) Rel(link RelName, resp *TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBodyGroups is a value for TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBody's Groups field
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBodyGroups struct {

	// Description of the IdP group.
	GroupDescription *string `json:"group_description"`

	// ID of the IdP group.
	GroupId *string `json:"group_id"`

	// Name of the IdP group.
	GroupName *string `json:"group_name"`
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBody is a request body for teams/create-or-update-id-p-group-connections-in-org

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBody struct {

	/*
	   The IdP groups you want to connect to a GitHub team. When updating, the new
	   `groups` object will replace the original one. You must include any existing
	   groups that you don't want to remove.
	*/
	Groups []TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBodyGroups `json:"groups"`
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponseBody is a response body for TeamsCreateOrUpdateIdPGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponseBody struct {
	components.GroupMapping
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse is a response for TeamsCreateOrUpdateIdPGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse struct {
	response
	request *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq
	Data    *TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponseBody
}

/*
TeamsDeleteDiscussionCommentInOrg performs requests for "teams/delete-discussion-comment-in-org"

Delete a discussion comment.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
func TeamsDeleteDiscussionCommentInOrg(ctx context.Context, req *TeamsDeleteDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsDeleteDiscussionCommentInOrgResponse, error) {
	if req == nil {
		req = new(TeamsDeleteDiscussionCommentInOrgReq)
	}
	resp := &TeamsDeleteDiscussionCommentInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteDiscussionCommentInOrg performs requests for "teams/delete-discussion-comment-in-org"

Delete a discussion comment.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
func (c Client) TeamsDeleteDiscussionCommentInOrg(ctx context.Context, req *TeamsDeleteDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsDeleteDiscussionCommentInOrgResponse, error) {
	return TeamsDeleteDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteDiscussionCommentInOrgReq is request data for Client.TeamsDeleteDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
type TeamsDeleteDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber)
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsDeleteDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteDiscussionCommentInOrgResponse is a response for TeamsDeleteDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
type TeamsDeleteDiscussionCommentInOrgResponse struct {
	response
	request *TeamsDeleteDiscussionCommentInOrgReq
}

/*
TeamsDeleteDiscussionInOrg performs requests for "teams/delete-discussion-in-org"

Delete a discussion.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
func TeamsDeleteDiscussionInOrg(ctx context.Context, req *TeamsDeleteDiscussionInOrgReq, opt ...RequestOption) (*TeamsDeleteDiscussionInOrgResponse, error) {
	if req == nil {
		req = new(TeamsDeleteDiscussionInOrgReq)
	}
	resp := &TeamsDeleteDiscussionInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteDiscussionInOrg performs requests for "teams/delete-discussion-in-org"

Delete a discussion.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
func (c Client) TeamsDeleteDiscussionInOrg(ctx context.Context, req *TeamsDeleteDiscussionInOrgReq, opt ...RequestOption) (*TeamsDeleteDiscussionInOrgResponse, error) {
	return TeamsDeleteDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteDiscussionInOrgReq is request data for Client.TeamsDeleteDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
type TeamsDeleteDiscussionInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
}

func (r *TeamsDeleteDiscussionInOrgReq) url() string {
	return r._url
}

func (r *TeamsDeleteDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsDeleteDiscussionInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsDeleteDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsDeleteDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsDeleteDiscussionInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsDeleteDiscussionInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsDeleteDiscussionInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsDeleteDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteDiscussionInOrgReq) Rel(link RelName, resp *TeamsDeleteDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteDiscussionInOrgResponse is a response for TeamsDeleteDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
type TeamsDeleteDiscussionInOrgResponse struct {
	response
	request *TeamsDeleteDiscussionInOrgReq
}

/*
TeamsDeleteInOrg performs requests for "teams/delete-in-org"

Delete a team.

  DELETE /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#delete-a-team
*/
func TeamsDeleteInOrg(ctx context.Context, req *TeamsDeleteInOrgReq, opt ...RequestOption) (*TeamsDeleteInOrgResponse, error) {
	if req == nil {
		req = new(TeamsDeleteInOrgReq)
	}
	resp := &TeamsDeleteInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteInOrg performs requests for "teams/delete-in-org"

Delete a team.

  DELETE /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#delete-a-team
*/
func (c Client) TeamsDeleteInOrg(ctx context.Context, req *TeamsDeleteInOrgReq, opt ...RequestOption) (*TeamsDeleteInOrgResponse, error) {
	return TeamsDeleteInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteInOrgReq is request data for Client.TeamsDeleteInOrg

https://developer.github.com/v3/teams/#delete-a-team
*/
type TeamsDeleteInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
}

func (r *TeamsDeleteInOrgReq) url() string {
	return r._url
}

func (r *TeamsDeleteInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug)
}

func (r *TeamsDeleteInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsDeleteInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsDeleteInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsDeleteInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsDeleteInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsDeleteInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsDeleteInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteInOrgReq) Rel(link RelName, resp *TeamsDeleteInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteInOrgResponse is a response for TeamsDeleteInOrg

https://developer.github.com/v3/teams/#delete-a-team
*/
type TeamsDeleteInOrgResponse struct {
	response
	request *TeamsDeleteInOrgReq
}

/*
TeamsGetByName performs requests for "teams/get-by-name"

Get a team by name.

  GET /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
func TeamsGetByName(ctx context.Context, req *TeamsGetByNameReq, opt ...RequestOption) (*TeamsGetByNameResponse, error) {
	if req == nil {
		req = new(TeamsGetByNameReq)
	}
	resp := &TeamsGetByNameResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetByNameResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetByName performs requests for "teams/get-by-name"

Get a team by name.

  GET /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
func (c Client) TeamsGetByName(ctx context.Context, req *TeamsGetByNameReq, opt ...RequestOption) (*TeamsGetByNameResponse, error) {
	return TeamsGetByName(ctx, req, append(c, opt...)...)
}

/*
TeamsGetByNameReq is request data for Client.TeamsGetByName

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
type TeamsGetByNameReq struct {
	_url     string
	Org      string
	TeamSlug string
}

func (r *TeamsGetByNameReq) url() string {
	return r._url
}

func (r *TeamsGetByNameReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug)
}

func (r *TeamsGetByNameReq) method() string {
	return "GET"
}

func (r *TeamsGetByNameReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetByNameReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetByNameReq) body() interface{} {
	return nil
}

func (r *TeamsGetByNameReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetByNameReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetByNameReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetByNameReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetByNameReq) Rel(link RelName, resp *TeamsGetByNameResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetByNameResponseBody is a response body for TeamsGetByName

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
type TeamsGetByNameResponseBody struct {
	components.TeamFull
}

/*
TeamsGetByNameResponse is a response for TeamsGetByName

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
type TeamsGetByNameResponse struct {
	response
	request *TeamsGetByNameReq
	Data    *TeamsGetByNameResponseBody
}

/*
TeamsGetDiscussionCommentInOrg performs requests for "teams/get-discussion-comment-in-org"

Get a discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
func TeamsGetDiscussionCommentInOrg(ctx context.Context, req *TeamsGetDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsGetDiscussionCommentInOrgResponse, error) {
	if req == nil {
		req = new(TeamsGetDiscussionCommentInOrgReq)
	}
	resp := &TeamsGetDiscussionCommentInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetDiscussionCommentInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetDiscussionCommentInOrg performs requests for "teams/get-discussion-comment-in-org"

Get a discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
func (c Client) TeamsGetDiscussionCommentInOrg(ctx context.Context, req *TeamsGetDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsGetDiscussionCommentInOrgResponse, error) {
	return TeamsGetDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsGetDiscussionCommentInOrgReq is request data for Client.TeamsGetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
type TeamsGetDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsGetDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *TeamsGetDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber)
}

func (r *TeamsGetDiscussionCommentInOrgReq) method() string {
	return "GET"
}

func (r *TeamsGetDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetDiscussionCommentInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsGetDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsGetDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetDiscussionCommentInOrgResponseBody is a response body for TeamsGetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
type TeamsGetDiscussionCommentInOrgResponseBody struct {
	components.TeamDiscussionComment
}

/*
TeamsGetDiscussionCommentInOrgResponse is a response for TeamsGetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
type TeamsGetDiscussionCommentInOrgResponse struct {
	response
	request *TeamsGetDiscussionCommentInOrgReq
	Data    *TeamsGetDiscussionCommentInOrgResponseBody
}

/*
TeamsGetDiscussionInOrg performs requests for "teams/get-discussion-in-org"

Get a discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
func TeamsGetDiscussionInOrg(ctx context.Context, req *TeamsGetDiscussionInOrgReq, opt ...RequestOption) (*TeamsGetDiscussionInOrgResponse, error) {
	if req == nil {
		req = new(TeamsGetDiscussionInOrgReq)
	}
	resp := &TeamsGetDiscussionInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetDiscussionInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetDiscussionInOrg performs requests for "teams/get-discussion-in-org"

Get a discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
func (c Client) TeamsGetDiscussionInOrg(ctx context.Context, req *TeamsGetDiscussionInOrgReq, opt ...RequestOption) (*TeamsGetDiscussionInOrgResponse, error) {
	return TeamsGetDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsGetDiscussionInOrgReq is request data for Client.TeamsGetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
type TeamsGetDiscussionInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsGetDiscussionInOrgReq) url() string {
	return r._url
}

func (r *TeamsGetDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsGetDiscussionInOrgReq) method() string {
	return "GET"
}

func (r *TeamsGetDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetDiscussionInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsGetDiscussionInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetDiscussionInOrgReq) Rel(link RelName, resp *TeamsGetDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetDiscussionInOrgResponseBody is a response body for TeamsGetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
type TeamsGetDiscussionInOrgResponseBody struct {
	components.TeamDiscussion
}

/*
TeamsGetDiscussionInOrgResponse is a response for TeamsGetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
type TeamsGetDiscussionInOrgResponse struct {
	response
	request *TeamsGetDiscussionInOrgReq
	Data    *TeamsGetDiscussionInOrgResponseBody
}

/*
TeamsGetMembershipForUserInOrg performs requests for "teams/get-membership-for-user-in-org"

Get team membership for a user.

  GET /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
func TeamsGetMembershipForUserInOrg(ctx context.Context, req *TeamsGetMembershipForUserInOrgReq, opt ...RequestOption) (*TeamsGetMembershipForUserInOrgResponse, error) {
	if req == nil {
		req = new(TeamsGetMembershipForUserInOrgReq)
	}
	resp := &TeamsGetMembershipForUserInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetMembershipForUserInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetMembershipForUserInOrg performs requests for "teams/get-membership-for-user-in-org"

Get team membership for a user.

  GET /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
func (c Client) TeamsGetMembershipForUserInOrg(ctx context.Context, req *TeamsGetMembershipForUserInOrgReq, opt ...RequestOption) (*TeamsGetMembershipForUserInOrgResponse, error) {
	return TeamsGetMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsGetMembershipForUserInOrgReq is request data for Client.TeamsGetMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
type TeamsGetMembershipForUserInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
	Username string
}

func (r *TeamsGetMembershipForUserInOrgReq) url() string {
	return r._url
}

func (r *TeamsGetMembershipForUserInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username)
}

func (r *TeamsGetMembershipForUserInOrgReq) method() string {
	return "GET"
}

func (r *TeamsGetMembershipForUserInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetMembershipForUserInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetMembershipForUserInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsGetMembershipForUserInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetMembershipForUserInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetMembershipForUserInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetMembershipForUserInOrgReq) Rel(link RelName, resp *TeamsGetMembershipForUserInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetMembershipForUserInOrgResponseBody is a response body for TeamsGetMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
type TeamsGetMembershipForUserInOrgResponseBody struct {
	components.TeamMembership
}

/*
TeamsGetMembershipForUserInOrgResponse is a response for TeamsGetMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
type TeamsGetMembershipForUserInOrgResponse struct {
	response
	request *TeamsGetMembershipForUserInOrgReq
	Data    *TeamsGetMembershipForUserInOrgResponseBody
}

/*
TeamsList performs requests for "teams/list"

List teams.

  GET /orgs/{org}/teams

https://developer.github.com/v3/teams/#list-teams
*/
func TeamsList(ctx context.Context, req *TeamsListReq, opt ...RequestOption) (*TeamsListResponse, error) {
	if req == nil {
		req = new(TeamsListReq)
	}
	resp := &TeamsListResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsList performs requests for "teams/list"

List teams.

  GET /orgs/{org}/teams

https://developer.github.com/v3/teams/#list-teams
*/
func (c Client) TeamsList(ctx context.Context, req *TeamsListReq, opt ...RequestOption) (*TeamsListResponse, error) {
	return TeamsList(ctx, req, append(c, opt...)...)
}

/*
TeamsListReq is request data for Client.TeamsList

https://developer.github.com/v3/teams/#list-teams
*/
type TeamsListReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListReq) url() string {
	return r._url
}

func (r *TeamsListReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams", r.Org)
}

func (r *TeamsListReq) method() string {
	return "GET"
}

func (r *TeamsListReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListReq) body() interface{} {
	return nil
}

func (r *TeamsListReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListReq) Rel(link RelName, resp *TeamsListResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListResponseBody is a response body for TeamsList

https://developer.github.com/v3/teams/#list-teams
*/
type TeamsListResponseBody []struct {
	components.Team
}

/*
TeamsListResponse is a response for TeamsList

https://developer.github.com/v3/teams/#list-teams
*/
type TeamsListResponse struct {
	response
	request *TeamsListReq
	Data    *TeamsListResponseBody
}

/*
TeamsListChildInOrg performs requests for "teams/list-child-in-org"

List child teams.

  GET /orgs/{org}/teams/{team_slug}/teams

https://developer.github.com/v3/teams/#list-child-teams
*/
func TeamsListChildInOrg(ctx context.Context, req *TeamsListChildInOrgReq, opt ...RequestOption) (*TeamsListChildInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListChildInOrgReq)
	}
	resp := &TeamsListChildInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListChildInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListChildInOrg performs requests for "teams/list-child-in-org"

List child teams.

  GET /orgs/{org}/teams/{team_slug}/teams

https://developer.github.com/v3/teams/#list-child-teams
*/
func (c Client) TeamsListChildInOrg(ctx context.Context, req *TeamsListChildInOrgReq, opt ...RequestOption) (*TeamsListChildInOrgResponse, error) {
	return TeamsListChildInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListChildInOrgReq is request data for Client.TeamsListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type TeamsListChildInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListChildInOrgReq) url() string {
	return r._url
}

func (r *TeamsListChildInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/teams", r.Org, r.TeamSlug)
}

func (r *TeamsListChildInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListChildInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListChildInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListChildInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListChildInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListChildInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListChildInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListChildInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListChildInOrgReq) Rel(link RelName, resp *TeamsListChildInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListChildInOrgResponseBody is a response body for TeamsListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type TeamsListChildInOrgResponseBody []struct {
	components.Team2
}

/*
TeamsListChildInOrgResponse is a response for TeamsListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type TeamsListChildInOrgResponse struct {
	response
	request *TeamsListChildInOrgReq
	Data    *TeamsListChildInOrgResponseBody
}

/*
TeamsListDiscussionCommentsInOrg performs requests for "teams/list-discussion-comments-in-org"

List discussion comments.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
func TeamsListDiscussionCommentsInOrg(ctx context.Context, req *TeamsListDiscussionCommentsInOrgReq, opt ...RequestOption) (*TeamsListDiscussionCommentsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListDiscussionCommentsInOrgReq)
	}
	resp := &TeamsListDiscussionCommentsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListDiscussionCommentsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListDiscussionCommentsInOrg performs requests for "teams/list-discussion-comments-in-org"

List discussion comments.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
func (c Client) TeamsListDiscussionCommentsInOrg(ctx context.Context, req *TeamsListDiscussionCommentsInOrgReq, opt ...RequestOption) (*TeamsListDiscussionCommentsInOrgResponse, error) {
	return TeamsListDiscussionCommentsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListDiscussionCommentsInOrgReq is request data for Client.TeamsListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
type TeamsListDiscussionCommentsInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64

	/*
	Sorts the discussion comments by the date they were created. To return the
	oldest comments first, set to `asc`. Can be one of `asc` or `desc`.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsListDiscussionCommentsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListDiscussionCommentsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsListDiscussionCommentsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListDiscussionCommentsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListDiscussionCommentsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListDiscussionCommentsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListDiscussionCommentsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionCommentsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionCommentsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListDiscussionCommentsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListDiscussionCommentsInOrgReq) Rel(link RelName, resp *TeamsListDiscussionCommentsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListDiscussionCommentsInOrgResponseBody is a response body for TeamsListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
type TeamsListDiscussionCommentsInOrgResponseBody []struct {
	components.TeamDiscussionComment
}

/*
TeamsListDiscussionCommentsInOrgResponse is a response for TeamsListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
type TeamsListDiscussionCommentsInOrgResponse struct {
	response
	request *TeamsListDiscussionCommentsInOrgReq
	Data    *TeamsListDiscussionCommentsInOrgResponseBody
}

/*
TeamsListDiscussionsInOrg performs requests for "teams/list-discussions-in-org"

List discussions.

  GET /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
func TeamsListDiscussionsInOrg(ctx context.Context, req *TeamsListDiscussionsInOrgReq, opt ...RequestOption) (*TeamsListDiscussionsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListDiscussionsInOrgReq)
	}
	resp := &TeamsListDiscussionsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListDiscussionsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListDiscussionsInOrg performs requests for "teams/list-discussions-in-org"

List discussions.

  GET /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
func (c Client) TeamsListDiscussionsInOrg(ctx context.Context, req *TeamsListDiscussionsInOrgReq, opt ...RequestOption) (*TeamsListDiscussionsInOrgResponse, error) {
	return TeamsListDiscussionsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListDiscussionsInOrgReq is request data for Client.TeamsListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type TeamsListDiscussionsInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	/*
	Sorts the discussion comments by the date they were created. To return the
	oldest comments first, set to `asc`. Can be one of `asc` or `desc`.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsListDiscussionsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListDiscussionsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions", r.Org, r.TeamSlug)
}

func (r *TeamsListDiscussionsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListDiscussionsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListDiscussionsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListDiscussionsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListDiscussionsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListDiscussionsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListDiscussionsInOrgReq) Rel(link RelName, resp *TeamsListDiscussionsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListDiscussionsInOrgResponseBody is a response body for TeamsListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type TeamsListDiscussionsInOrgResponseBody []struct {
	components.TeamDiscussion
}

/*
TeamsListDiscussionsInOrgResponse is a response for TeamsListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type TeamsListDiscussionsInOrgResponse struct {
	response
	request *TeamsListDiscussionsInOrgReq
	Data    *TeamsListDiscussionsInOrgResponseBody
}

/*
TeamsListForAuthenticatedUser performs requests for "teams/list-for-authenticated-user"

List teams for the authenticated user.

  GET /user/teams

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
func TeamsListForAuthenticatedUser(ctx context.Context, req *TeamsListForAuthenticatedUserReq, opt ...RequestOption) (*TeamsListForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(TeamsListForAuthenticatedUserReq)
	}
	resp := &TeamsListForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListForAuthenticatedUser performs requests for "teams/list-for-authenticated-user"

List teams for the authenticated user.

  GET /user/teams

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
func (c Client) TeamsListForAuthenticatedUser(ctx context.Context, req *TeamsListForAuthenticatedUserReq, opt ...RequestOption) (*TeamsListForAuthenticatedUserResponse, error) {
	return TeamsListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
TeamsListForAuthenticatedUserReq is request data for Client.TeamsListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
type TeamsListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *TeamsListForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/teams")
}

func (r *TeamsListForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *TeamsListForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *TeamsListForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListForAuthenticatedUserReq) Rel(link RelName, resp *TeamsListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListForAuthenticatedUserResponseBody is a response body for TeamsListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
type TeamsListForAuthenticatedUserResponseBody []struct {
	components.TeamFull
}

/*
TeamsListForAuthenticatedUserResponse is a response for TeamsListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
type TeamsListForAuthenticatedUserResponse struct {
	response
	request *TeamsListForAuthenticatedUserReq
	Data    *TeamsListForAuthenticatedUserResponseBody
}

/*
TeamsListIdPGroupsForOrg performs requests for "teams/list-id-p-groups-for-org"

List IdP groups for an organization.

  GET /orgs/{org}/team-sync/groups

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
func TeamsListIdPGroupsForOrg(ctx context.Context, req *TeamsListIdPGroupsForOrgReq, opt ...RequestOption) (*TeamsListIdPGroupsForOrgResponse, error) {
	if req == nil {
		req = new(TeamsListIdPGroupsForOrgReq)
	}
	resp := &TeamsListIdPGroupsForOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListIdPGroupsForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListIdPGroupsForOrg performs requests for "teams/list-id-p-groups-for-org"

List IdP groups for an organization.

  GET /orgs/{org}/team-sync/groups

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
func (c Client) TeamsListIdPGroupsForOrg(ctx context.Context, req *TeamsListIdPGroupsForOrgReq, opt ...RequestOption) (*TeamsListIdPGroupsForOrgResponse, error) {
	return TeamsListIdPGroupsForOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListIdPGroupsForOrgReq is request data for Client.TeamsListIdPGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
type TeamsListIdPGroupsForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListIdPGroupsForOrgReq) url() string {
	return r._url
}

func (r *TeamsListIdPGroupsForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/team-sync/groups", r.Org)
}

func (r *TeamsListIdPGroupsForOrgReq) method() string {
	return "GET"
}

func (r *TeamsListIdPGroupsForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListIdPGroupsForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListIdPGroupsForOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListIdPGroupsForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListIdPGroupsForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListIdPGroupsForOrgReq) Rel(link RelName, resp *TeamsListIdPGroupsForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListIdPGroupsForOrgResponseBody is a response body for TeamsListIdPGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
type TeamsListIdPGroupsForOrgResponseBody struct {
	components.GroupMapping3
}

/*
TeamsListIdPGroupsForOrgResponse is a response for TeamsListIdPGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
type TeamsListIdPGroupsForOrgResponse struct {
	response
	request *TeamsListIdPGroupsForOrgReq
	Data    *TeamsListIdPGroupsForOrgResponseBody
}

/*
TeamsListIdPGroupsInOrg performs requests for "teams/list-id-p-groups-in-org"

List IdP groups for a team.

  GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
func TeamsListIdPGroupsInOrg(ctx context.Context, req *TeamsListIdPGroupsInOrgReq, opt ...RequestOption) (*TeamsListIdPGroupsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListIdPGroupsInOrgReq)
	}
	resp := &TeamsListIdPGroupsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListIdPGroupsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListIdPGroupsInOrg performs requests for "teams/list-id-p-groups-in-org"

List IdP groups for a team.

  GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
func (c Client) TeamsListIdPGroupsInOrg(ctx context.Context, req *TeamsListIdPGroupsInOrgReq, opt ...RequestOption) (*TeamsListIdPGroupsInOrgResponse, error) {
	return TeamsListIdPGroupsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListIdPGroupsInOrgReq is request data for Client.TeamsListIdPGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type TeamsListIdPGroupsInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
}

func (r *TeamsListIdPGroupsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListIdPGroupsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/team-sync/group-mappings", r.Org, r.TeamSlug)
}

func (r *TeamsListIdPGroupsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListIdPGroupsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsListIdPGroupsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListIdPGroupsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListIdPGroupsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListIdPGroupsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListIdPGroupsInOrgReq) Rel(link RelName, resp *TeamsListIdPGroupsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListIdPGroupsInOrgResponseBody is a response body for TeamsListIdPGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type TeamsListIdPGroupsInOrgResponseBody struct {
	components.GroupMapping3
}

/*
TeamsListIdPGroupsInOrgResponse is a response for TeamsListIdPGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type TeamsListIdPGroupsInOrgResponse struct {
	response
	request *TeamsListIdPGroupsInOrgReq
	Data    *TeamsListIdPGroupsInOrgResponseBody
}

/*
TeamsListMembersInOrg performs requests for "teams/list-members-in-org"

List team members.

  GET /orgs/{org}/teams/{team_slug}/members

https://developer.github.com/v3/teams/members/#list-team-members
*/
func TeamsListMembersInOrg(ctx context.Context, req *TeamsListMembersInOrgReq, opt ...RequestOption) (*TeamsListMembersInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListMembersInOrgReq)
	}
	resp := &TeamsListMembersInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListMembersInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListMembersInOrg performs requests for "teams/list-members-in-org"

List team members.

  GET /orgs/{org}/teams/{team_slug}/members

https://developer.github.com/v3/teams/members/#list-team-members
*/
func (c Client) TeamsListMembersInOrg(ctx context.Context, req *TeamsListMembersInOrgReq, opt ...RequestOption) (*TeamsListMembersInOrgResponse, error) {
	return TeamsListMembersInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListMembersInOrgReq is request data for Client.TeamsListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type TeamsListMembersInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	/*
	Filters members returned by their role in the team. Can be one of:
	\* `member` - normal members of the team.
	\* `maintainer` - team maintainers.
	\* `all` - all members of the team.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListMembersInOrgReq) url() string {
	return r._url
}

func (r *TeamsListMembersInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/members", r.Org, r.TeamSlug)
}

func (r *TeamsListMembersInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListMembersInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListMembersInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListMembersInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListMembersInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListMembersInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListMembersInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListMembersInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListMembersInOrgReq) Rel(link RelName, resp *TeamsListMembersInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListMembersInOrgResponseBody is a response body for TeamsListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type TeamsListMembersInOrgResponseBody []struct {
	components.SimpleUser
}

/*
TeamsListMembersInOrgResponse is a response for TeamsListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type TeamsListMembersInOrgResponse struct {
	response
	request *TeamsListMembersInOrgReq
	Data    *TeamsListMembersInOrgResponseBody
}

/*
TeamsListPendingInvitationsInOrg performs requests for "teams/list-pending-invitations-in-org"

List pending team invitations.

  GET /orgs/{org}/teams/{team_slug}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
func TeamsListPendingInvitationsInOrg(ctx context.Context, req *TeamsListPendingInvitationsInOrgReq, opt ...RequestOption) (*TeamsListPendingInvitationsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListPendingInvitationsInOrgReq)
	}
	resp := &TeamsListPendingInvitationsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListPendingInvitationsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListPendingInvitationsInOrg performs requests for "teams/list-pending-invitations-in-org"

List pending team invitations.

  GET /orgs/{org}/teams/{team_slug}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
func (c Client) TeamsListPendingInvitationsInOrg(ctx context.Context, req *TeamsListPendingInvitationsInOrgReq, opt ...RequestOption) (*TeamsListPendingInvitationsInOrgResponse, error) {
	return TeamsListPendingInvitationsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListPendingInvitationsInOrgReq is request data for Client.TeamsListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type TeamsListPendingInvitationsInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListPendingInvitationsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListPendingInvitationsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/invitations", r.Org, r.TeamSlug)
}

func (r *TeamsListPendingInvitationsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListPendingInvitationsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListPendingInvitationsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListPendingInvitationsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListPendingInvitationsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListPendingInvitationsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListPendingInvitationsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListPendingInvitationsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListPendingInvitationsInOrgReq) Rel(link RelName, resp *TeamsListPendingInvitationsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListPendingInvitationsInOrgResponseBody is a response body for TeamsListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type TeamsListPendingInvitationsInOrgResponseBody []struct {
	components.OrganizationInvitation
}

/*
TeamsListPendingInvitationsInOrgResponse is a response for TeamsListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type TeamsListPendingInvitationsInOrgResponse struct {
	response
	request *TeamsListPendingInvitationsInOrgReq
	Data    *TeamsListPendingInvitationsInOrgResponseBody
}

/*
TeamsListProjectsInOrg performs requests for "teams/list-projects-in-org"

List team projects.

  GET /orgs/{org}/teams/{team_slug}/projects

https://developer.github.com/v3/teams/#list-team-projects
*/
func TeamsListProjectsInOrg(ctx context.Context, req *TeamsListProjectsInOrgReq, opt ...RequestOption) (*TeamsListProjectsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListProjectsInOrgReq)
	}
	resp := &TeamsListProjectsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListProjectsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListProjectsInOrg performs requests for "teams/list-projects-in-org"

List team projects.

  GET /orgs/{org}/teams/{team_slug}/projects

https://developer.github.com/v3/teams/#list-team-projects
*/
func (c Client) TeamsListProjectsInOrg(ctx context.Context, req *TeamsListProjectsInOrgReq, opt ...RequestOption) (*TeamsListProjectsInOrgResponse, error) {
	return TeamsListProjectsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListProjectsInOrgReq is request data for Client.TeamsListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type TeamsListProjectsInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *TeamsListProjectsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListProjectsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/projects", r.Org, r.TeamSlug)
}

func (r *TeamsListProjectsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListProjectsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListProjectsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListProjectsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListProjectsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListProjectsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListProjectsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListProjectsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListProjectsInOrgReq) Rel(link RelName, resp *TeamsListProjectsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListProjectsInOrgResponseBody is a response body for TeamsListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type TeamsListProjectsInOrgResponseBody []struct {
	components.TeamProject
}

/*
TeamsListProjectsInOrgResponse is a response for TeamsListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type TeamsListProjectsInOrgResponse struct {
	response
	request *TeamsListProjectsInOrgReq
	Data    *TeamsListProjectsInOrgResponseBody
}

/*
TeamsListReposInOrg performs requests for "teams/list-repos-in-org"

List team repositories.

  GET /orgs/{org}/teams/{team_slug}/repos

https://developer.github.com/v3/teams/#list-team-repositories
*/
func TeamsListReposInOrg(ctx context.Context, req *TeamsListReposInOrgReq, opt ...RequestOption) (*TeamsListReposInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListReposInOrgReq)
	}
	resp := &TeamsListReposInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListReposInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListReposInOrg performs requests for "teams/list-repos-in-org"

List team repositories.

  GET /orgs/{org}/teams/{team_slug}/repos

https://developer.github.com/v3/teams/#list-team-repositories
*/
func (c Client) TeamsListReposInOrg(ctx context.Context, req *TeamsListReposInOrgReq, opt ...RequestOption) (*TeamsListReposInOrgResponse, error) {
	return TeamsListReposInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListReposInOrgReq is request data for Client.TeamsListReposInOrg

https://developer.github.com/v3/teams/#list-team-repositories
*/
type TeamsListReposInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListReposInOrgReq) url() string {
	return r._url
}

func (r *TeamsListReposInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/repos", r.Org, r.TeamSlug)
}

func (r *TeamsListReposInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListReposInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListReposInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListReposInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListReposInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListReposInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListReposInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListReposInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListReposInOrgReq) Rel(link RelName, resp *TeamsListReposInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListReposInOrgResponseBody is a response body for TeamsListReposInOrg

https://developer.github.com/v3/teams/#list-team-repositories
*/
type TeamsListReposInOrgResponseBody []struct {
	components.MinimalRepository
}

/*
TeamsListReposInOrgResponse is a response for TeamsListReposInOrg

https://developer.github.com/v3/teams/#list-team-repositories
*/
type TeamsListReposInOrgResponse struct {
	response
	request *TeamsListReposInOrgReq
	Data    *TeamsListReposInOrgResponseBody
}

/*
TeamsRemoveMembershipForUserInOrg performs requests for "teams/remove-membership-for-user-in-org"

Remove team membership for a user.

  DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
func TeamsRemoveMembershipForUserInOrg(ctx context.Context, req *TeamsRemoveMembershipForUserInOrgReq, opt ...RequestOption) (*TeamsRemoveMembershipForUserInOrgResponse, error) {
	if req == nil {
		req = new(TeamsRemoveMembershipForUserInOrgReq)
	}
	resp := &TeamsRemoveMembershipForUserInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveMembershipForUserInOrg performs requests for "teams/remove-membership-for-user-in-org"

Remove team membership for a user.

  DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
func (c Client) TeamsRemoveMembershipForUserInOrg(ctx context.Context, req *TeamsRemoveMembershipForUserInOrgReq, opt ...RequestOption) (*TeamsRemoveMembershipForUserInOrgResponse, error) {
	return TeamsRemoveMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveMembershipForUserInOrgReq is request data for Client.TeamsRemoveMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
type TeamsRemoveMembershipForUserInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
	Username string
}

func (r *TeamsRemoveMembershipForUserInOrgReq) url() string {
	return r._url
}

func (r *TeamsRemoveMembershipForUserInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username)
}

func (r *TeamsRemoveMembershipForUserInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsRemoveMembershipForUserInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsRemoveMembershipForUserInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsRemoveMembershipForUserInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsRemoveMembershipForUserInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsRemoveMembershipForUserInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsRemoveMembershipForUserInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveMembershipForUserInOrgReq) Rel(link RelName, resp *TeamsRemoveMembershipForUserInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveMembershipForUserInOrgResponse is a response for TeamsRemoveMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
type TeamsRemoveMembershipForUserInOrgResponse struct {
	response
	request *TeamsRemoveMembershipForUserInOrgReq
}

/*
TeamsRemoveProjectInOrg performs requests for "teams/remove-project-in-org"

Remove a project from a team.

  DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
func TeamsRemoveProjectInOrg(ctx context.Context, req *TeamsRemoveProjectInOrgReq, opt ...RequestOption) (*TeamsRemoveProjectInOrgResponse, error) {
	if req == nil {
		req = new(TeamsRemoveProjectInOrgReq)
	}
	resp := &TeamsRemoveProjectInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveProjectInOrg performs requests for "teams/remove-project-in-org"

Remove a project from a team.

  DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
func (c Client) TeamsRemoveProjectInOrg(ctx context.Context, req *TeamsRemoveProjectInOrgReq, opt ...RequestOption) (*TeamsRemoveProjectInOrgResponse, error) {
	return TeamsRemoveProjectInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveProjectInOrgReq is request data for Client.TeamsRemoveProjectInOrg

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
type TeamsRemoveProjectInOrgReq struct {
	_url      string
	Org       string
	TeamSlug  string
	ProjectId int64
}

func (r *TeamsRemoveProjectInOrgReq) url() string {
	return r._url
}

func (r *TeamsRemoveProjectInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId)
}

func (r *TeamsRemoveProjectInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsRemoveProjectInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsRemoveProjectInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsRemoveProjectInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsRemoveProjectInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsRemoveProjectInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsRemoveProjectInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveProjectInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveProjectInOrgReq) Rel(link RelName, resp *TeamsRemoveProjectInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveProjectInOrgResponse is a response for TeamsRemoveProjectInOrg

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
type TeamsRemoveProjectInOrgResponse struct {
	response
	request *TeamsRemoveProjectInOrgReq
}

/*
TeamsRemoveRepoInOrg performs requests for "teams/remove-repo-in-org"

Remove a repository from a team.

  DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
func TeamsRemoveRepoInOrg(ctx context.Context, req *TeamsRemoveRepoInOrgReq, opt ...RequestOption) (*TeamsRemoveRepoInOrgResponse, error) {
	if req == nil {
		req = new(TeamsRemoveRepoInOrgReq)
	}
	resp := &TeamsRemoveRepoInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveRepoInOrg performs requests for "teams/remove-repo-in-org"

Remove a repository from a team.

  DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
func (c Client) TeamsRemoveRepoInOrg(ctx context.Context, req *TeamsRemoveRepoInOrgReq, opt ...RequestOption) (*TeamsRemoveRepoInOrgResponse, error) {
	return TeamsRemoveRepoInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveRepoInOrgReq is request data for Client.TeamsRemoveRepoInOrg

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
type TeamsRemoveRepoInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
	Owner    string
	Repo     string
}

func (r *TeamsRemoveRepoInOrgReq) url() string {
	return r._url
}

func (r *TeamsRemoveRepoInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo)
}

func (r *TeamsRemoveRepoInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsRemoveRepoInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsRemoveRepoInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsRemoveRepoInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsRemoveRepoInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsRemoveRepoInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsRemoveRepoInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveRepoInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveRepoInOrgReq) Rel(link RelName, resp *TeamsRemoveRepoInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveRepoInOrgResponse is a response for TeamsRemoveRepoInOrg

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
type TeamsRemoveRepoInOrgResponse struct {
	response
	request *TeamsRemoveRepoInOrgReq
}

/*
TeamsUpdateDiscussionCommentInOrg performs requests for "teams/update-discussion-comment-in-org"

Update a discussion comment.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
func TeamsUpdateDiscussionCommentInOrg(ctx context.Context, req *TeamsUpdateDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsUpdateDiscussionCommentInOrgResponse, error) {
	if req == nil {
		req = new(TeamsUpdateDiscussionCommentInOrgReq)
	}
	resp := &TeamsUpdateDiscussionCommentInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsUpdateDiscussionCommentInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateDiscussionCommentInOrg performs requests for "teams/update-discussion-comment-in-org"

Update a discussion comment.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
func (c Client) TeamsUpdateDiscussionCommentInOrg(ctx context.Context, req *TeamsUpdateDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsUpdateDiscussionCommentInOrgResponse, error) {
	return TeamsUpdateDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateDiscussionCommentInOrgReq is request data for Client.TeamsUpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type TeamsUpdateDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      TeamsUpdateDiscussionCommentInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber)
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) method() string {
	return "PATCH"
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsUpdateDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateDiscussionCommentInOrgReqBody is a request body for teams/update-discussion-comment-in-org

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type TeamsUpdateDiscussionCommentInOrgReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
TeamsUpdateDiscussionCommentInOrgResponseBody is a response body for TeamsUpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type TeamsUpdateDiscussionCommentInOrgResponseBody struct {
	components.TeamDiscussionComment
}

/*
TeamsUpdateDiscussionCommentInOrgResponse is a response for TeamsUpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type TeamsUpdateDiscussionCommentInOrgResponse struct {
	response
	request *TeamsUpdateDiscussionCommentInOrgReq
	Data    *TeamsUpdateDiscussionCommentInOrgResponseBody
}

/*
TeamsUpdateDiscussionInOrg performs requests for "teams/update-discussion-in-org"

Update a discussion.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
func TeamsUpdateDiscussionInOrg(ctx context.Context, req *TeamsUpdateDiscussionInOrgReq, opt ...RequestOption) (*TeamsUpdateDiscussionInOrgResponse, error) {
	if req == nil {
		req = new(TeamsUpdateDiscussionInOrgReq)
	}
	resp := &TeamsUpdateDiscussionInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsUpdateDiscussionInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateDiscussionInOrg performs requests for "teams/update-discussion-in-org"

Update a discussion.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
func (c Client) TeamsUpdateDiscussionInOrg(ctx context.Context, req *TeamsUpdateDiscussionInOrgReq, opt ...RequestOption) (*TeamsUpdateDiscussionInOrgResponse, error) {
	return TeamsUpdateDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateDiscussionInOrgReq is request data for Client.TeamsUpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type TeamsUpdateDiscussionInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      TeamsUpdateDiscussionInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsUpdateDiscussionInOrgReq) url() string {
	return r._url
}

func (r *TeamsUpdateDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsUpdateDiscussionInOrgReq) method() string {
	return "PATCH"
}

func (r *TeamsUpdateDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsUpdateDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsUpdateDiscussionInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsUpdateDiscussionInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateDiscussionInOrgReq) Rel(link RelName, resp *TeamsUpdateDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateDiscussionInOrgReqBody is a request body for teams/update-discussion-in-org

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type TeamsUpdateDiscussionInOrgReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body,omitempty"`

	// The discussion post's title.
	Title *string `json:"title,omitempty"`
}

/*
TeamsUpdateDiscussionInOrgResponseBody is a response body for TeamsUpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type TeamsUpdateDiscussionInOrgResponseBody struct {
	components.TeamDiscussion
}

/*
TeamsUpdateDiscussionInOrgResponse is a response for TeamsUpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type TeamsUpdateDiscussionInOrgResponse struct {
	response
	request *TeamsUpdateDiscussionInOrgReq
	Data    *TeamsUpdateDiscussionInOrgResponseBody
}

/*
TeamsUpdateInOrg performs requests for "teams/update-in-org"

Update a team.

  PATCH /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#update-a-team
*/
func TeamsUpdateInOrg(ctx context.Context, req *TeamsUpdateInOrgReq, opt ...RequestOption) (*TeamsUpdateInOrgResponse, error) {
	if req == nil {
		req = new(TeamsUpdateInOrgReq)
	}
	resp := &TeamsUpdateInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsUpdateInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateInOrg performs requests for "teams/update-in-org"

Update a team.

  PATCH /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#update-a-team
*/
func (c Client) TeamsUpdateInOrg(ctx context.Context, req *TeamsUpdateInOrgReq, opt ...RequestOption) (*TeamsUpdateInOrgResponse, error) {
	return TeamsUpdateInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateInOrgReq is request data for Client.TeamsUpdateInOrg

https://developer.github.com/v3/teams/#update-a-team
*/
type TeamsUpdateInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	RequestBody TeamsUpdateInOrgReqBody
}

func (r *TeamsUpdateInOrgReq) url() string {
	return r._url
}

func (r *TeamsUpdateInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug)
}

func (r *TeamsUpdateInOrgReq) method() string {
	return "PATCH"
}

func (r *TeamsUpdateInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsUpdateInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsUpdateInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsUpdateInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsUpdateInOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsUpdateInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateInOrgReq) Rel(link RelName, resp *TeamsUpdateInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateInOrgReqBody is a request body for teams/update-in-org

https://developer.github.com/v3/teams/#update-a-team
*/
type TeamsUpdateInOrgReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	   **Deprecated**. The permission that new repositories will be added to the team
	   with when none is specified. Can be one of:
	   \* `pull` - team members can pull, but not push to or administer newly-added
	   repositories.
	   \* `push` - team members can pull and push, but not administer newly-added
	   repositories.
	   \* `admin` - team members can pull, push and administer newly-added
	   repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	   The level of privacy this team should have. Editing teams without specifying
	   this parameter leaves `privacy` intact. When a team is nested, the `privacy` for
	   parent teams cannot be `secret`. The options are:
	   **For a non-nested team:**
	   \* `secret` - only visible to organization owners and members of this team.
	   \* `closed` - visible to all members of this organization.
	   **For a parent or child team:**
	   \* `closed` - visible to all members of this organization.
	*/
	Privacy *string `json:"privacy,omitempty"`
}

/*
TeamsUpdateInOrgResponseBody is a response body for TeamsUpdateInOrg

https://developer.github.com/v3/teams/#update-a-team
*/
type TeamsUpdateInOrgResponseBody struct {
	components.TeamFull
}

/*
TeamsUpdateInOrgResponse is a response for TeamsUpdateInOrg

https://developer.github.com/v3/teams/#update-a-team
*/
type TeamsUpdateInOrgResponse struct {
	response
	request *TeamsUpdateInOrgReq
	Data    *TeamsUpdateInOrgResponseBody
}
