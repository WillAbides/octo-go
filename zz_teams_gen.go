// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
TeamsAddMemberLegacy performs requests for "teams/add-member-legacy"

Add team member (Legacy).

  PUT /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
func TeamsAddMemberLegacy(ctx context.Context, req *TeamsAddMemberLegacyReq, opt ...options.Option) (*TeamsAddMemberLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsAddMemberLegacyReq)
	}
	resp := &TeamsAddMemberLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddMemberLegacy performs requests for "teams/add-member-legacy"

Add team member (Legacy).

  PUT /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
func (c Client) TeamsAddMemberLegacy(ctx context.Context, req *TeamsAddMemberLegacyReq, opt ...options.Option) (*TeamsAddMemberLegacyResponse, error) {
	return TeamsAddMemberLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsAddMemberLegacyReq is request data for Client.TeamsAddMemberLegacy

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
type TeamsAddMemberLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddMemberLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsAddMemberLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "teams/add-member-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/members/%v", r.TeamId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddMemberLegacyReq) Rel(link RelName, resp *TeamsAddMemberLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddMemberLegacyResponse is a response for TeamsAddMemberLegacy

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
type TeamsAddMemberLegacyResponse struct {
	internal.Response
	request *TeamsAddMemberLegacyReq
}

/*
TeamsAddOrUpdateMembershipForUserInOrg performs requests for "teams/add-or-update-membership-for-user-in-org"

Add or update team membership for a user.

  PUT /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
func TeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserInOrgReq, opt ...options.Option) (*TeamsAddOrUpdateMembershipForUserInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsAddOrUpdateMembershipForUserInOrgReq)
	}
	resp := &TeamsAddOrUpdateMembershipForUserInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamMembership{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateMembershipForUserInOrg performs requests for "teams/add-or-update-membership-for-user-in-org"

Add or update team membership for a user.

  PUT /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
func (c Client) TeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserInOrgReq, opt ...options.Option) (*TeamsAddOrUpdateMembershipForUserInOrgResponse, error) {
	return TeamsAddOrUpdateMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateMembershipForUserInOrgReq is request data for Client.TeamsAddOrUpdateMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type TeamsAddOrUpdateMembershipForUserInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	Username    string
	RequestBody TeamsAddOrUpdateMembershipForUserInOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-membership-for-user-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) Rel(link RelName, resp *TeamsAddOrUpdateMembershipForUserInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateMembershipForUserInOrgReqBody is a request body for teams/add-or-update-membership-for-user-in-org

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type TeamsAddOrUpdateMembershipForUserInOrgReqBody struct {

	/*
	The role that this user should have in the team. Can be one of:
	\* `member` - a normal member of the team.
	\* `maintainer` - a team maintainer. Able to add/remove other team members,
	promote other team members to team maintainer, and edit the team's name and
	description.
	*/
	Role *string `json:"role,omitempty"`
}

/*
TeamsAddOrUpdateMembershipForUserInOrgResponse is a response for TeamsAddOrUpdateMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type TeamsAddOrUpdateMembershipForUserInOrgResponse struct {
	internal.Response
	request *TeamsAddOrUpdateMembershipForUserInOrgReq
	Data    components.TeamMembership
}

/*
TeamsAddOrUpdateMembershipForUserLegacy performs requests for "teams/add-or-update-membership-for-user-legacy"

Add or update team membership for a user (Legacy).

  PUT /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
func TeamsAddOrUpdateMembershipForUserLegacy(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserLegacyReq, opt ...options.Option) (*TeamsAddOrUpdateMembershipForUserLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsAddOrUpdateMembershipForUserLegacyReq)
	}
	resp := &TeamsAddOrUpdateMembershipForUserLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamMembership{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateMembershipForUserLegacy performs requests for "teams/add-or-update-membership-for-user-legacy"

Add or update team membership for a user (Legacy).

  PUT /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
func (c Client) TeamsAddOrUpdateMembershipForUserLegacy(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserLegacyReq, opt ...options.Option) (*TeamsAddOrUpdateMembershipForUserLegacyResponse, error) {
	return TeamsAddOrUpdateMembershipForUserLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateMembershipForUserLegacyReq is request data for Client.TeamsAddOrUpdateMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
type TeamsAddOrUpdateMembershipForUserLegacyReq struct {
	_url        string
	TeamId      int64
	Username    string
	RequestBody TeamsAddOrUpdateMembershipForUserLegacyReqBody
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-membership-for-user-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/memberships/%v", r.TeamId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) Rel(link RelName, resp *TeamsAddOrUpdateMembershipForUserLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateMembershipForUserLegacyReqBody is a request body for teams/add-or-update-membership-for-user-legacy

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
type TeamsAddOrUpdateMembershipForUserLegacyReqBody struct {

	/*
	The role that this user should have in the team. Can be one of:
	\* `member` - a normal member of the team.
	\* `maintainer` - a team maintainer. Able to add/remove other team members,
	promote other team members to team maintainer, and edit the team's name and
	description.
	*/
	Role *string `json:"role,omitempty"`
}

/*
TeamsAddOrUpdateMembershipForUserLegacyResponse is a response for TeamsAddOrUpdateMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
type TeamsAddOrUpdateMembershipForUserLegacyResponse struct {
	internal.Response
	request *TeamsAddOrUpdateMembershipForUserLegacyReq
	Data    components.TeamMembership
}

/*
TeamsAddOrUpdateProjectPermissionsInOrg performs requests for "teams/add-or-update-project-permissions-in-org"

Add or update team project permissions.

  PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
func TeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateProjectPermissionsInOrgReq, opt ...options.Option) (*TeamsAddOrUpdateProjectPermissionsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsAddOrUpdateProjectPermissionsInOrgReq)
	}
	resp := &TeamsAddOrUpdateProjectPermissionsInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateProjectPermissionsInOrg performs requests for "teams/add-or-update-project-permissions-in-org"

Add or update team project permissions.

  PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
func (c Client) TeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateProjectPermissionsInOrgReq, opt ...options.Option) (*TeamsAddOrUpdateProjectPermissionsInOrgResponse, error) {
	return TeamsAddOrUpdateProjectPermissionsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateProjectPermissionsInOrgReq is request data for Client.TeamsAddOrUpdateProjectPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type TeamsAddOrUpdateProjectPermissionsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	ProjectId   int64
	RequestBody TeamsAddOrUpdateProjectPermissionsInOrgReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-project-permissions-in-org",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) Rel(link RelName, resp *TeamsAddOrUpdateProjectPermissionsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateProjectPermissionsInOrgReqBody is a request body for teams/add-or-update-project-permissions-in-org

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type TeamsAddOrUpdateProjectPermissionsInOrgReqBody struct {

	/*
	The permission to grant to the team for this project. Can be one of:
	\* `read` - team members can read, but not write to or administer this project.
	\* `write` - team members can read and write, but not administer this project.
	\* `admin` - team members can read, write and administer this project.
	Default: the team's `permission` attribute will be used to determine what
	permission to grant the team on this project. Note that, if you choose not to
	pass any parameters, you'll need to set `Content-Length` to zero when calling
	out to this endpoint. For more information, see "[HTTP
	verbs](https://developer.github.com/v3/#http-verbs)."
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
TeamsAddOrUpdateProjectPermissionsInOrgResponse is a response for TeamsAddOrUpdateProjectPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type TeamsAddOrUpdateProjectPermissionsInOrgResponse struct {
	internal.Response
	request *TeamsAddOrUpdateProjectPermissionsInOrgReq
}

/*
TeamsAddOrUpdateProjectPermissionsLegacy performs requests for "teams/add-or-update-project-permissions-legacy"

Add or update team project permissions (Legacy).

  PUT /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
func TeamsAddOrUpdateProjectPermissionsLegacy(ctx context.Context, req *TeamsAddOrUpdateProjectPermissionsLegacyReq, opt ...options.Option) (*TeamsAddOrUpdateProjectPermissionsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsAddOrUpdateProjectPermissionsLegacyReq)
	}
	resp := &TeamsAddOrUpdateProjectPermissionsLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateProjectPermissionsLegacy performs requests for "teams/add-or-update-project-permissions-legacy"

Add or update team project permissions (Legacy).

  PUT /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
func (c Client) TeamsAddOrUpdateProjectPermissionsLegacy(ctx context.Context, req *TeamsAddOrUpdateProjectPermissionsLegacyReq, opt ...options.Option) (*TeamsAddOrUpdateProjectPermissionsLegacyResponse, error) {
	return TeamsAddOrUpdateProjectPermissionsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateProjectPermissionsLegacyReq is request data for Client.TeamsAddOrUpdateProjectPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
type TeamsAddOrUpdateProjectPermissionsLegacyReq struct {
	_url        string
	TeamId      int64
	ProjectId   int64
	RequestBody TeamsAddOrUpdateProjectPermissionsLegacyReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-project-permissions-legacy",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/teams/%v/projects/%v", r.TeamId, r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) Rel(link RelName, resp *TeamsAddOrUpdateProjectPermissionsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateProjectPermissionsLegacyReqBody is a request body for teams/add-or-update-project-permissions-legacy

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
type TeamsAddOrUpdateProjectPermissionsLegacyReqBody struct {

	/*
	The permission to grant to the team for this project. Can be one of:
	\* `read` - team members can read, but not write to or administer this project.
	\* `write` - team members can read and write, but not administer this project.
	\* `admin` - team members can read, write and administer this project.
	Default: the team's `permission` attribute will be used to determine what
	permission to grant the team on this project. Note that, if you choose not to
	pass any parameters, you'll need to set `Content-Length` to zero when calling
	out to this endpoint. For more information, see "[HTTP
	verbs](https://developer.github.com/v3/#http-verbs)."
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
TeamsAddOrUpdateProjectPermissionsLegacyResponse is a response for TeamsAddOrUpdateProjectPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
type TeamsAddOrUpdateProjectPermissionsLegacyResponse struct {
	internal.Response
	request *TeamsAddOrUpdateProjectPermissionsLegacyReq
}

/*
TeamsAddOrUpdateRepoPermissionsInOrg performs requests for "teams/add-or-update-repo-permissions-in-org"

Add or update team repository permissions.

  PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
func TeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateRepoPermissionsInOrgReq, opt ...options.Option) (*TeamsAddOrUpdateRepoPermissionsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsAddOrUpdateRepoPermissionsInOrgReq)
	}
	resp := &TeamsAddOrUpdateRepoPermissionsInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateRepoPermissionsInOrg performs requests for "teams/add-or-update-repo-permissions-in-org"

Add or update team repository permissions.

  PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
func (c Client) TeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateRepoPermissionsInOrgReq, opt ...options.Option) (*TeamsAddOrUpdateRepoPermissionsInOrgResponse, error) {
	return TeamsAddOrUpdateRepoPermissionsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateRepoPermissionsInOrgReq is request data for Client.TeamsAddOrUpdateRepoPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type TeamsAddOrUpdateRepoPermissionsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	Owner       string
	Repo        string
	RequestBody TeamsAddOrUpdateRepoPermissionsInOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-repo-permissions-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) Rel(link RelName, resp *TeamsAddOrUpdateRepoPermissionsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateRepoPermissionsInOrgReqBody is a request body for teams/add-or-update-repo-permissions-in-org

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type TeamsAddOrUpdateRepoPermissionsInOrgReqBody struct {

	/*
	The permission to grant the team on this repository. Can be one of:
	\* `pull` - team members can pull, but not push to or administer this
	repository.
	\* `push` - team members can pull and push, but not administer this repository.
	\* `admin` - team members can pull, push and administer this repository.
	\* `maintain` - team members can manage the repository without access to
	sensitive or destructive actions. Recommended for project managers. Only applies
	to repositories owned by organizations.
	\* `triage` - team members can proactively manage issues and pull requests
	without write access. Recommended for contributors who triage a repository. Only
	applies to repositories owned by organizations.

	If no permission is specified, the team's `permission` attribute will be used to
	determine what permission to grant the team on this repository.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
TeamsAddOrUpdateRepoPermissionsInOrgResponse is a response for TeamsAddOrUpdateRepoPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type TeamsAddOrUpdateRepoPermissionsInOrgResponse struct {
	internal.Response
	request *TeamsAddOrUpdateRepoPermissionsInOrgReq
}

/*
TeamsAddOrUpdateRepoPermissionsLegacy performs requests for "teams/add-or-update-repo-permissions-legacy"

Add or update team repository permissions (Legacy).

  PUT /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
func TeamsAddOrUpdateRepoPermissionsLegacy(ctx context.Context, req *TeamsAddOrUpdateRepoPermissionsLegacyReq, opt ...options.Option) (*TeamsAddOrUpdateRepoPermissionsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsAddOrUpdateRepoPermissionsLegacyReq)
	}
	resp := &TeamsAddOrUpdateRepoPermissionsLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateRepoPermissionsLegacy performs requests for "teams/add-or-update-repo-permissions-legacy"

Add or update team repository permissions (Legacy).

  PUT /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
func (c Client) TeamsAddOrUpdateRepoPermissionsLegacy(ctx context.Context, req *TeamsAddOrUpdateRepoPermissionsLegacyReq, opt ...options.Option) (*TeamsAddOrUpdateRepoPermissionsLegacyResponse, error) {
	return TeamsAddOrUpdateRepoPermissionsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateRepoPermissionsLegacyReq is request data for Client.TeamsAddOrUpdateRepoPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
type TeamsAddOrUpdateRepoPermissionsLegacyReq struct {
	_url        string
	TeamId      int64
	Owner       string
	Repo        string
	RequestBody TeamsAddOrUpdateRepoPermissionsLegacyReqBody
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "PUT",
		OperationID:      "teams/add-or-update-repo-permissions-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/repos/%v/%v", r.TeamId, r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) Rel(link RelName, resp *TeamsAddOrUpdateRepoPermissionsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateRepoPermissionsLegacyReqBody is a request body for teams/add-or-update-repo-permissions-legacy

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
type TeamsAddOrUpdateRepoPermissionsLegacyReqBody struct {

	/*
	The permission to grant the team on this repository. Can be one of:
	\* `pull` - team members can pull, but not push to or administer this
	repository.
	\* `push` - team members can pull and push, but not administer this repository.
	\* `admin` - team members can pull, push and administer this repository.

	If no permission is specified, the team's `permission` attribute will be used to
	determine what permission to grant the team on this repository.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
TeamsAddOrUpdateRepoPermissionsLegacyResponse is a response for TeamsAddOrUpdateRepoPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
type TeamsAddOrUpdateRepoPermissionsLegacyResponse struct {
	internal.Response
	request *TeamsAddOrUpdateRepoPermissionsLegacyReq
}

/*
TeamsCheckPermissionsForProjectInOrg performs requests for "teams/check-permissions-for-project-in-org"

Check team permissions for a project.

  GET /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
func TeamsCheckPermissionsForProjectInOrg(ctx context.Context, req *TeamsCheckPermissionsForProjectInOrgReq, opt ...options.Option) (*TeamsCheckPermissionsForProjectInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsCheckPermissionsForProjectInOrgReq)
	}
	resp := &TeamsCheckPermissionsForProjectInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamProject{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCheckPermissionsForProjectInOrg performs requests for "teams/check-permissions-for-project-in-org"

Check team permissions for a project.

  GET /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
func (c Client) TeamsCheckPermissionsForProjectInOrg(ctx context.Context, req *TeamsCheckPermissionsForProjectInOrgReq, opt ...options.Option) (*TeamsCheckPermissionsForProjectInOrgResponse, error) {
	return TeamsCheckPermissionsForProjectInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCheckPermissionsForProjectInOrgReq is request data for Client.TeamsCheckPermissionsForProjectInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
type TeamsCheckPermissionsForProjectInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug  string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsCheckPermissionsForProjectInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/check-permissions-for-project-in-org",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCheckPermissionsForProjectInOrgReq) Rel(link RelName, resp *TeamsCheckPermissionsForProjectInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCheckPermissionsForProjectInOrgResponse is a response for TeamsCheckPermissionsForProjectInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
type TeamsCheckPermissionsForProjectInOrgResponse struct {
	internal.Response
	request *TeamsCheckPermissionsForProjectInOrgReq
	Data    components.TeamProject
}

/*
TeamsCheckPermissionsForProjectLegacy performs requests for "teams/check-permissions-for-project-legacy"

Check team permissions for a project (Legacy).

  GET /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
func TeamsCheckPermissionsForProjectLegacy(ctx context.Context, req *TeamsCheckPermissionsForProjectLegacyReq, opt ...options.Option) (*TeamsCheckPermissionsForProjectLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsCheckPermissionsForProjectLegacyReq)
	}
	resp := &TeamsCheckPermissionsForProjectLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamProject{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCheckPermissionsForProjectLegacy performs requests for "teams/check-permissions-for-project-legacy"

Check team permissions for a project (Legacy).

  GET /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
func (c Client) TeamsCheckPermissionsForProjectLegacy(ctx context.Context, req *TeamsCheckPermissionsForProjectLegacyReq, opt ...options.Option) (*TeamsCheckPermissionsForProjectLegacyResponse, error) {
	return TeamsCheckPermissionsForProjectLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsCheckPermissionsForProjectLegacyReq is request data for Client.TeamsCheckPermissionsForProjectLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
type TeamsCheckPermissionsForProjectLegacyReq struct {
	_url      string
	TeamId    int64
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsCheckPermissionsForProjectLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsCheckPermissionsForProjectLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/check-permissions-for-project-legacy",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/teams/%v/projects/%v", r.TeamId, r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCheckPermissionsForProjectLegacyReq) Rel(link RelName, resp *TeamsCheckPermissionsForProjectLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCheckPermissionsForProjectLegacyResponse is a response for TeamsCheckPermissionsForProjectLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
type TeamsCheckPermissionsForProjectLegacyResponse struct {
	internal.Response
	request *TeamsCheckPermissionsForProjectLegacyReq
	Data    components.TeamProject
}

/*
TeamsCheckPermissionsForRepoInOrg performs requests for "teams/check-permissions-for-repo-in-org"

Check team permissions for a repository.

  GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
func TeamsCheckPermissionsForRepoInOrg(ctx context.Context, req *TeamsCheckPermissionsForRepoInOrgReq, opt ...options.Option) (*TeamsCheckPermissionsForRepoInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsCheckPermissionsForRepoInOrgReq)
	}
	resp := &TeamsCheckPermissionsForRepoInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamRepository{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCheckPermissionsForRepoInOrg performs requests for "teams/check-permissions-for-repo-in-org"

Check team permissions for a repository.

  GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
func (c Client) TeamsCheckPermissionsForRepoInOrg(ctx context.Context, req *TeamsCheckPermissionsForRepoInOrgReq, opt ...options.Option) (*TeamsCheckPermissionsForRepoInOrgResponse, error) {
	return TeamsCheckPermissionsForRepoInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCheckPermissionsForRepoInOrgReq is request data for Client.TeamsCheckPermissionsForRepoInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
type TeamsCheckPermissionsForRepoInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
	Owner    string
	Repo     string
}

// HTTPRequest builds an *http.Request
func (r *TeamsCheckPermissionsForRepoInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/vnd.github.v3.repository+json")},
		Method:           "GET",
		OperationID:      "teams/check-permissions-for-repo-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCheckPermissionsForRepoInOrgReq) Rel(link RelName, resp *TeamsCheckPermissionsForRepoInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCheckPermissionsForRepoInOrgResponse is a response for TeamsCheckPermissionsForRepoInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
type TeamsCheckPermissionsForRepoInOrgResponse struct {
	internal.Response
	request *TeamsCheckPermissionsForRepoInOrgReq
	Data    components.TeamRepository
}

/*
TeamsCheckPermissionsForRepoLegacy performs requests for "teams/check-permissions-for-repo-legacy"

Check team permissions for a repository (Legacy).

  GET /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
func TeamsCheckPermissionsForRepoLegacy(ctx context.Context, req *TeamsCheckPermissionsForRepoLegacyReq, opt ...options.Option) (*TeamsCheckPermissionsForRepoLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsCheckPermissionsForRepoLegacyReq)
	}
	resp := &TeamsCheckPermissionsForRepoLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamRepository{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCheckPermissionsForRepoLegacy performs requests for "teams/check-permissions-for-repo-legacy"

Check team permissions for a repository (Legacy).

  GET /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
func (c Client) TeamsCheckPermissionsForRepoLegacy(ctx context.Context, req *TeamsCheckPermissionsForRepoLegacyReq, opt ...options.Option) (*TeamsCheckPermissionsForRepoLegacyResponse, error) {
	return TeamsCheckPermissionsForRepoLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsCheckPermissionsForRepoLegacyReq is request data for Client.TeamsCheckPermissionsForRepoLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
type TeamsCheckPermissionsForRepoLegacyReq struct {
	_url   string
	TeamId int64
	Owner  string
	Repo   string
}

// HTTPRequest builds an *http.Request
func (r *TeamsCheckPermissionsForRepoLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsCheckPermissionsForRepoLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/vnd.github.v3.repository+json")},
		Method:           "GET",
		OperationID:      "teams/check-permissions-for-repo-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/repos/%v/%v", r.TeamId, r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200, 204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCheckPermissionsForRepoLegacyReq) Rel(link RelName, resp *TeamsCheckPermissionsForRepoLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCheckPermissionsForRepoLegacyResponse is a response for TeamsCheckPermissionsForRepoLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
type TeamsCheckPermissionsForRepoLegacyResponse struct {
	internal.Response
	request *TeamsCheckPermissionsForRepoLegacyReq
	Data    components.TeamRepository
}

/*
TeamsCreate performs requests for "teams/create"

Create a team.

  POST /orgs/{org}/teams

https://developer.github.com/v3/teams/#create-a-team
*/
func TeamsCreate(ctx context.Context, req *TeamsCreateReq, opt ...options.Option) (*TeamsCreateResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsCreateReq)
	}
	resp := &TeamsCreateResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamFull{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreate performs requests for "teams/create"

Create a team.

  POST /orgs/{org}/teams

https://developer.github.com/v3/teams/#create-a-team
*/
func (c Client) TeamsCreate(ctx context.Context, req *TeamsCreateReq, opt ...options.Option) (*TeamsCreateResponse, error) {
	return TeamsCreate(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateReq is request data for Client.TeamsCreate

https://developer.github.com/v3/teams/#create-a-team
*/
type TeamsCreateReq struct {
	_url        string
	Org         string
	RequestBody TeamsCreateReqBody
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsCreateReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateReq) Rel(link RelName, resp *TeamsCreateResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateReqBody is a request body for teams/create

https://developer.github.com/v3/teams/#create-a-team
*/
type TeamsCreateReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// List GitHub IDs for organization members who will become team maintainers.
	Maintainers []string `json:"maintainers,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	**Deprecated**. The permission that new repositories will be added to the team
	with when none is specified. Can be one of:
	\* `pull` - team members can pull, but not push to or administer newly-added
	repositories.
	\* `push` - team members can pull and push, but not administer newly-added
	repositories.
	\* `admin` - team members can pull, push and administer newly-added
	repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	The level of privacy this team should have. The options are:
	**For a non-nested team:**
	\* `secret` - only visible to organization owners and members of this team.
	\* `closed` - visible to all members of this organization.
	Default: `secret`
	**For a parent or child team:**
	\* `closed` - visible to all members of this organization.
	Default for child team: `closed`
	*/
	Privacy *string `json:"privacy,omitempty"`

	// The full name (e.g., "organization-name/repository-name") of repositories to add the team to.
	RepoNames []string `json:"repo_names,omitempty"`
}

/*
TeamsCreateResponse is a response for TeamsCreate

https://developer.github.com/v3/teams/#create-a-team
*/
type TeamsCreateResponse struct {
	internal.Response
	request *TeamsCreateReq
	Data    components.TeamFull
}

/*
TeamsCreateDiscussionCommentInOrg performs requests for "teams/create-discussion-comment-in-org"

Create a discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
func TeamsCreateDiscussionCommentInOrg(ctx context.Context, req *TeamsCreateDiscussionCommentInOrgReq, opt ...options.Option) (*TeamsCreateDiscussionCommentInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsCreateDiscussionCommentInOrgReq)
	}
	resp := &TeamsCreateDiscussionCommentInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateDiscussionCommentInOrg performs requests for "teams/create-discussion-comment-in-org"

Create a discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
func (c Client) TeamsCreateDiscussionCommentInOrg(ctx context.Context, req *TeamsCreateDiscussionCommentInOrgReq, opt ...options.Option) (*TeamsCreateDiscussionCommentInOrgResponse, error) {
	return TeamsCreateDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateDiscussionCommentInOrgReq is request data for Client.TeamsCreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type TeamsCreateDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      TeamsCreateDiscussionCommentInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsCreateDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create-discussion-comment-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsCreateDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateDiscussionCommentInOrgReqBody is a request body for teams/create-discussion-comment-in-org

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type TeamsCreateDiscussionCommentInOrgReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
TeamsCreateDiscussionCommentInOrgResponse is a response for TeamsCreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type TeamsCreateDiscussionCommentInOrgResponse struct {
	internal.Response
	request *TeamsCreateDiscussionCommentInOrgReq
	Data    components.TeamDiscussionComment
}

/*
TeamsCreateDiscussionCommentLegacy performs requests for "teams/create-discussion-comment-legacy"

Create a discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
func TeamsCreateDiscussionCommentLegacy(ctx context.Context, req *TeamsCreateDiscussionCommentLegacyReq, opt ...options.Option) (*TeamsCreateDiscussionCommentLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsCreateDiscussionCommentLegacyReq)
	}
	resp := &TeamsCreateDiscussionCommentLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateDiscussionCommentLegacy performs requests for "teams/create-discussion-comment-legacy"

Create a discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
func (c Client) TeamsCreateDiscussionCommentLegacy(ctx context.Context, req *TeamsCreateDiscussionCommentLegacyReq, opt ...options.Option) (*TeamsCreateDiscussionCommentLegacyResponse, error) {
	return TeamsCreateDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateDiscussionCommentLegacyReq is request data for Client.TeamsCreateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
type TeamsCreateDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	RequestBody      TeamsCreateDiscussionCommentLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsCreateDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create-discussion-comment-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateDiscussionCommentLegacyReq) Rel(link RelName, resp *TeamsCreateDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateDiscussionCommentLegacyReqBody is a request body for teams/create-discussion-comment-legacy

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
type TeamsCreateDiscussionCommentLegacyReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
TeamsCreateDiscussionCommentLegacyResponse is a response for TeamsCreateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
type TeamsCreateDiscussionCommentLegacyResponse struct {
	internal.Response
	request *TeamsCreateDiscussionCommentLegacyReq
	Data    components.TeamDiscussionComment
}

/*
TeamsCreateDiscussionInOrg performs requests for "teams/create-discussion-in-org"

Create a discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
func TeamsCreateDiscussionInOrg(ctx context.Context, req *TeamsCreateDiscussionInOrgReq, opt ...options.Option) (*TeamsCreateDiscussionInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsCreateDiscussionInOrgReq)
	}
	resp := &TeamsCreateDiscussionInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateDiscussionInOrg performs requests for "teams/create-discussion-in-org"

Create a discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
func (c Client) TeamsCreateDiscussionInOrg(ctx context.Context, req *TeamsCreateDiscussionInOrgReq, opt ...options.Option) (*TeamsCreateDiscussionInOrgResponse, error) {
	return TeamsCreateDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateDiscussionInOrgReq is request data for Client.TeamsCreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	RequestBody TeamsCreateDiscussionInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsCreateDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create-discussion-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateDiscussionInOrgReq) Rel(link RelName, resp *TeamsCreateDiscussionInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateDiscussionInOrgReqBody is a request body for teams/create-discussion-in-org

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body"`

	/*
	Private posts are only visible to team members, organization owners, and team
	maintainers. Public posts are visible to all members of the organization. Set to
	`true` to create a private post.
	*/
	Private *bool `json:"private,omitempty"`

	// The discussion post's title.
	Title *string `json:"title"`
}

/*
TeamsCreateDiscussionInOrgResponse is a response for TeamsCreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgResponse struct {
	internal.Response
	request *TeamsCreateDiscussionInOrgReq
	Data    components.TeamDiscussion
}

/*
TeamsCreateDiscussionLegacy performs requests for "teams/create-discussion-legacy"

Create a discussion (Legacy).

  POST /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
func TeamsCreateDiscussionLegacy(ctx context.Context, req *TeamsCreateDiscussionLegacyReq, opt ...options.Option) (*TeamsCreateDiscussionLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsCreateDiscussionLegacyReq)
	}
	resp := &TeamsCreateDiscussionLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateDiscussionLegacy performs requests for "teams/create-discussion-legacy"

Create a discussion (Legacy).

  POST /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
func (c Client) TeamsCreateDiscussionLegacy(ctx context.Context, req *TeamsCreateDiscussionLegacyReq, opt ...options.Option) (*TeamsCreateDiscussionLegacyResponse, error) {
	return TeamsCreateDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateDiscussionLegacyReq is request data for Client.TeamsCreateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
type TeamsCreateDiscussionLegacyReq struct {
	_url        string
	TeamId      int64
	RequestBody TeamsCreateDiscussionLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsCreateDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "POST",
		OperationID:      "teams/create-discussion-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateDiscussionLegacyReq) Rel(link RelName, resp *TeamsCreateDiscussionLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateDiscussionLegacyReqBody is a request body for teams/create-discussion-legacy

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
type TeamsCreateDiscussionLegacyReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body"`

	/*
	Private posts are only visible to team members, organization owners, and team
	maintainers. Public posts are visible to all members of the organization. Set to
	`true` to create a private post.
	*/
	Private *bool `json:"private,omitempty"`

	// The discussion post's title.
	Title *string `json:"title"`
}

/*
TeamsCreateDiscussionLegacyResponse is a response for TeamsCreateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
type TeamsCreateDiscussionLegacyResponse struct {
	internal.Response
	request *TeamsCreateDiscussionLegacyReq
	Data    components.TeamDiscussion
}

/*
TeamsCreateOrUpdateIdpGroupConnectionsInOrg performs requests for "teams/create-or-update-idp-group-connections-in-org"

Create or update IdP group connections.

  PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
func TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, req *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq, opt ...options.Option) (*TeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq)
	}
	resp := &TeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GroupMapping{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateOrUpdateIdpGroupConnectionsInOrg performs requests for "teams/create-or-update-idp-group-connections-in-org"

Create or update IdP group connections.

  PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
func (c Client) TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, req *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq, opt ...options.Option) (*TeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse, error) {
	return TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq is request data for Client.TeamsCreateOrUpdateIdpGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	RequestBody TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/create-or-update-idp-group-connections-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/team-sync/group-mappings", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) Rel(link RelName, resp *TeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqBodyGroups is a value for TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqBody's Groups field
type TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqBodyGroups struct {

	// Description of the IdP group.
	GroupDescription *string `json:"group_description"`

	// ID of the IdP group.
	GroupId *string `json:"group_id"`

	// Name of the IdP group.
	GroupName *string `json:"group_name"`
}

/*
TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqBody is a request body for teams/create-or-update-idp-group-connections-in-org

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqBody struct {

	/*
	The IdP groups you want to connect to a GitHub team. When updating, the new
	`groups` object will replace the original one. You must include any existing
	groups that you don't want to remove.
	*/
	Groups []TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqBodyGroups `json:"groups"`
}

/*
TeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse is a response for TeamsCreateOrUpdateIdpGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse struct {
	internal.Response
	request *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq
	Data    components.GroupMapping
}

/*
TeamsCreateOrUpdateIdpGroupConnectionsLegacy performs requests for "teams/create-or-update-idp-group-connections-legacy"

Create or update IdP group connections (Legacy).

  PATCH /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
func TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, req *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq, opt ...options.Option) (*TeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq)
	}
	resp := &TeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GroupMapping{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateOrUpdateIdpGroupConnectionsLegacy performs requests for "teams/create-or-update-idp-group-connections-legacy"

Create or update IdP group connections (Legacy).

  PATCH /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
func (c Client) TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, req *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq, opt ...options.Option) (*TeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse, error) {
	return TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq is request data for Client.TeamsCreateOrUpdateIdpGroupConnectionsLegacy

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
type TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq struct {
	_url        string
	TeamId      int64
	RequestBody TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqBody
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/create-or-update-idp-group-connections-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/team-sync/group-mappings", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) Rel(link RelName, resp *TeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqBodyGroups is a value for TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqBody's Groups field
type TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqBodyGroups struct {
	Description *string `json:"description,omitempty"`

	// Description of the IdP group.
	GroupDescription *string `json:"group_description"`

	// ID of the IdP group.
	GroupId *string `json:"group_id"`

	// Name of the IdP group.
	GroupName *string `json:"group_name"`
	Id        *string `json:"id,omitempty"`
	Name      *string `json:"name,omitempty"`
}

/*
TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqBody is a request body for teams/create-or-update-idp-group-connections-legacy

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
type TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqBody struct {

	/*
	The IdP groups you want to connect to a GitHub team. When updating, the new
	`groups` object will replace the original one. You must include any existing
	groups that you don't want to remove.
	*/
	Groups   []TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqBodyGroups `json:"groups"`
	SyncedAt *string                                                     `json:"synced_at,omitempty"`
}

/*
TeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse is a response for TeamsCreateOrUpdateIdpGroupConnectionsLegacy

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
type TeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse struct {
	internal.Response
	request *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq
	Data    components.GroupMapping
}

/*
TeamsDeleteDiscussionCommentInOrg performs requests for "teams/delete-discussion-comment-in-org"

Delete a discussion comment.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
func TeamsDeleteDiscussionCommentInOrg(ctx context.Context, req *TeamsDeleteDiscussionCommentInOrgReq, opt ...options.Option) (*TeamsDeleteDiscussionCommentInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsDeleteDiscussionCommentInOrgReq)
	}
	resp := &TeamsDeleteDiscussionCommentInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteDiscussionCommentInOrg performs requests for "teams/delete-discussion-comment-in-org"

Delete a discussion comment.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
func (c Client) TeamsDeleteDiscussionCommentInOrg(ctx context.Context, req *TeamsDeleteDiscussionCommentInOrgReq, opt ...options.Option) (*TeamsDeleteDiscussionCommentInOrgResponse, error) {
	return TeamsDeleteDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteDiscussionCommentInOrgReq is request data for Client.TeamsDeleteDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
type TeamsDeleteDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/delete-discussion-comment-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsDeleteDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteDiscussionCommentInOrgResponse is a response for TeamsDeleteDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
type TeamsDeleteDiscussionCommentInOrgResponse struct {
	internal.Response
	request *TeamsDeleteDiscussionCommentInOrgReq
}

/*
TeamsDeleteDiscussionCommentLegacy performs requests for "teams/delete-discussion-comment-legacy"

Delete a discussion comment (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
func TeamsDeleteDiscussionCommentLegacy(ctx context.Context, req *TeamsDeleteDiscussionCommentLegacyReq, opt ...options.Option) (*TeamsDeleteDiscussionCommentLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsDeleteDiscussionCommentLegacyReq)
	}
	resp := &TeamsDeleteDiscussionCommentLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteDiscussionCommentLegacy performs requests for "teams/delete-discussion-comment-legacy"

Delete a discussion comment (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
func (c Client) TeamsDeleteDiscussionCommentLegacy(ctx context.Context, req *TeamsDeleteDiscussionCommentLegacyReq, opt ...options.Option) (*TeamsDeleteDiscussionCommentLegacyResponse, error) {
	return TeamsDeleteDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteDiscussionCommentLegacyReq is request data for Client.TeamsDeleteDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
type TeamsDeleteDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsDeleteDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/delete-discussion-comment-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments/%v", r.TeamId, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteDiscussionCommentLegacyReq) Rel(link RelName, resp *TeamsDeleteDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteDiscussionCommentLegacyResponse is a response for TeamsDeleteDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
type TeamsDeleteDiscussionCommentLegacyResponse struct {
	internal.Response
	request *TeamsDeleteDiscussionCommentLegacyReq
}

/*
TeamsDeleteDiscussionInOrg performs requests for "teams/delete-discussion-in-org"

Delete a discussion.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
func TeamsDeleteDiscussionInOrg(ctx context.Context, req *TeamsDeleteDiscussionInOrgReq, opt ...options.Option) (*TeamsDeleteDiscussionInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsDeleteDiscussionInOrgReq)
	}
	resp := &TeamsDeleteDiscussionInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteDiscussionInOrg performs requests for "teams/delete-discussion-in-org"

Delete a discussion.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
func (c Client) TeamsDeleteDiscussionInOrg(ctx context.Context, req *TeamsDeleteDiscussionInOrgReq, opt ...options.Option) (*TeamsDeleteDiscussionInOrgResponse, error) {
	return TeamsDeleteDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteDiscussionInOrgReq is request data for Client.TeamsDeleteDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
type TeamsDeleteDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsDeleteDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/delete-discussion-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteDiscussionInOrgReq) Rel(link RelName, resp *TeamsDeleteDiscussionInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteDiscussionInOrgResponse is a response for TeamsDeleteDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
type TeamsDeleteDiscussionInOrgResponse struct {
	internal.Response
	request *TeamsDeleteDiscussionInOrgReq
}

/*
TeamsDeleteDiscussionLegacy performs requests for "teams/delete-discussion-legacy"

Delete a discussion (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
func TeamsDeleteDiscussionLegacy(ctx context.Context, req *TeamsDeleteDiscussionLegacyReq, opt ...options.Option) (*TeamsDeleteDiscussionLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsDeleteDiscussionLegacyReq)
	}
	resp := &TeamsDeleteDiscussionLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteDiscussionLegacy performs requests for "teams/delete-discussion-legacy"

Delete a discussion (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
func (c Client) TeamsDeleteDiscussionLegacy(ctx context.Context, req *TeamsDeleteDiscussionLegacyReq, opt ...options.Option) (*TeamsDeleteDiscussionLegacyResponse, error) {
	return TeamsDeleteDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteDiscussionLegacyReq is request data for Client.TeamsDeleteDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
type TeamsDeleteDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsDeleteDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/delete-discussion-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteDiscussionLegacyReq) Rel(link RelName, resp *TeamsDeleteDiscussionLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteDiscussionLegacyResponse is a response for TeamsDeleteDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
type TeamsDeleteDiscussionLegacyResponse struct {
	internal.Response
	request *TeamsDeleteDiscussionLegacyReq
}

/*
TeamsDeleteInOrg performs requests for "teams/delete-in-org"

Delete a team.

  DELETE /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#delete-a-team
*/
func TeamsDeleteInOrg(ctx context.Context, req *TeamsDeleteInOrgReq, opt ...options.Option) (*TeamsDeleteInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsDeleteInOrgReq)
	}
	resp := &TeamsDeleteInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteInOrg performs requests for "teams/delete-in-org"

Delete a team.

  DELETE /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#delete-a-team
*/
func (c Client) TeamsDeleteInOrg(ctx context.Context, req *TeamsDeleteInOrgReq, opt ...options.Option) (*TeamsDeleteInOrgResponse, error) {
	return TeamsDeleteInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteInOrgReq is request data for Client.TeamsDeleteInOrg

https://developer.github.com/v3/teams/#delete-a-team
*/
type TeamsDeleteInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsDeleteInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/delete-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteInOrgReq) Rel(link RelName, resp *TeamsDeleteInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteInOrgResponse is a response for TeamsDeleteInOrg

https://developer.github.com/v3/teams/#delete-a-team
*/
type TeamsDeleteInOrgResponse struct {
	internal.Response
	request *TeamsDeleteInOrgReq
}

/*
TeamsDeleteLegacy performs requests for "teams/delete-legacy"

Delete a team (Legacy).

  DELETE /teams/{team_id}

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
func TeamsDeleteLegacy(ctx context.Context, req *TeamsDeleteLegacyReq, opt ...options.Option) (*TeamsDeleteLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsDeleteLegacyReq)
	}
	resp := &TeamsDeleteLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteLegacy performs requests for "teams/delete-legacy"

Delete a team (Legacy).

  DELETE /teams/{team_id}

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
func (c Client) TeamsDeleteLegacy(ctx context.Context, req *TeamsDeleteLegacyReq, opt ...options.Option) (*TeamsDeleteLegacyResponse, error) {
	return TeamsDeleteLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteLegacyReq is request data for Client.TeamsDeleteLegacy

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
type TeamsDeleteLegacyReq struct {
	_url   string
	TeamId int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsDeleteLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/delete-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteLegacyReq) Rel(link RelName, resp *TeamsDeleteLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteLegacyResponse is a response for TeamsDeleteLegacy

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
type TeamsDeleteLegacyResponse struct {
	internal.Response
	request *TeamsDeleteLegacyReq
}

/*
TeamsGetByName performs requests for "teams/get-by-name"

Get a team by name.

  GET /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
func TeamsGetByName(ctx context.Context, req *TeamsGetByNameReq, opt ...options.Option) (*TeamsGetByNameResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsGetByNameReq)
	}
	resp := &TeamsGetByNameResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamFull{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetByName performs requests for "teams/get-by-name"

Get a team by name.

  GET /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
func (c Client) TeamsGetByName(ctx context.Context, req *TeamsGetByNameReq, opt ...options.Option) (*TeamsGetByNameResponse, error) {
	return TeamsGetByName(ctx, req, append(c, opt...)...)
}

/*
TeamsGetByNameReq is request data for Client.TeamsGetByName

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
type TeamsGetByNameReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetByNameReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsGetByNameReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-by-name",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetByNameReq) Rel(link RelName, resp *TeamsGetByNameResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetByNameResponse is a response for TeamsGetByName

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
type TeamsGetByNameResponse struct {
	internal.Response
	request *TeamsGetByNameReq
	Data    components.TeamFull
}

/*
TeamsGetDiscussionCommentInOrg performs requests for "teams/get-discussion-comment-in-org"

Get a discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
func TeamsGetDiscussionCommentInOrg(ctx context.Context, req *TeamsGetDiscussionCommentInOrgReq, opt ...options.Option) (*TeamsGetDiscussionCommentInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsGetDiscussionCommentInOrgReq)
	}
	resp := &TeamsGetDiscussionCommentInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetDiscussionCommentInOrg performs requests for "teams/get-discussion-comment-in-org"

Get a discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
func (c Client) TeamsGetDiscussionCommentInOrg(ctx context.Context, req *TeamsGetDiscussionCommentInOrgReq, opt ...options.Option) (*TeamsGetDiscussionCommentInOrgResponse, error) {
	return TeamsGetDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsGetDiscussionCommentInOrgReq is request data for Client.TeamsGetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
type TeamsGetDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsGetDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-discussion-comment-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsGetDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetDiscussionCommentInOrgResponse is a response for TeamsGetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
type TeamsGetDiscussionCommentInOrgResponse struct {
	internal.Response
	request *TeamsGetDiscussionCommentInOrgReq
	Data    components.TeamDiscussionComment
}

/*
TeamsGetDiscussionCommentLegacy performs requests for "teams/get-discussion-comment-legacy"

Get a discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
func TeamsGetDiscussionCommentLegacy(ctx context.Context, req *TeamsGetDiscussionCommentLegacyReq, opt ...options.Option) (*TeamsGetDiscussionCommentLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsGetDiscussionCommentLegacyReq)
	}
	resp := &TeamsGetDiscussionCommentLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetDiscussionCommentLegacy performs requests for "teams/get-discussion-comment-legacy"

Get a discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
func (c Client) TeamsGetDiscussionCommentLegacy(ctx context.Context, req *TeamsGetDiscussionCommentLegacyReq, opt ...options.Option) (*TeamsGetDiscussionCommentLegacyResponse, error) {
	return TeamsGetDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsGetDiscussionCommentLegacyReq is request data for Client.TeamsGetDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
type TeamsGetDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsGetDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-discussion-comment-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments/%v", r.TeamId, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetDiscussionCommentLegacyReq) Rel(link RelName, resp *TeamsGetDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetDiscussionCommentLegacyResponse is a response for TeamsGetDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
type TeamsGetDiscussionCommentLegacyResponse struct {
	internal.Response
	request *TeamsGetDiscussionCommentLegacyReq
	Data    components.TeamDiscussionComment
}

/*
TeamsGetDiscussionInOrg performs requests for "teams/get-discussion-in-org"

Get a discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
func TeamsGetDiscussionInOrg(ctx context.Context, req *TeamsGetDiscussionInOrgReq, opt ...options.Option) (*TeamsGetDiscussionInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsGetDiscussionInOrgReq)
	}
	resp := &TeamsGetDiscussionInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetDiscussionInOrg performs requests for "teams/get-discussion-in-org"

Get a discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
func (c Client) TeamsGetDiscussionInOrg(ctx context.Context, req *TeamsGetDiscussionInOrgReq, opt ...options.Option) (*TeamsGetDiscussionInOrgResponse, error) {
	return TeamsGetDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsGetDiscussionInOrgReq is request data for Client.TeamsGetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
type TeamsGetDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsGetDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-discussion-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetDiscussionInOrgReq) Rel(link RelName, resp *TeamsGetDiscussionInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetDiscussionInOrgResponse is a response for TeamsGetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
type TeamsGetDiscussionInOrgResponse struct {
	internal.Response
	request *TeamsGetDiscussionInOrgReq
	Data    components.TeamDiscussion
}

/*
TeamsGetDiscussionLegacy performs requests for "teams/get-discussion-legacy"

Get a discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
func TeamsGetDiscussionLegacy(ctx context.Context, req *TeamsGetDiscussionLegacyReq, opt ...options.Option) (*TeamsGetDiscussionLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsGetDiscussionLegacyReq)
	}
	resp := &TeamsGetDiscussionLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetDiscussionLegacy performs requests for "teams/get-discussion-legacy"

Get a discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
func (c Client) TeamsGetDiscussionLegacy(ctx context.Context, req *TeamsGetDiscussionLegacyReq, opt ...options.Option) (*TeamsGetDiscussionLegacyResponse, error) {
	return TeamsGetDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsGetDiscussionLegacyReq is request data for Client.TeamsGetDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
type TeamsGetDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsGetDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-discussion-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetDiscussionLegacyReq) Rel(link RelName, resp *TeamsGetDiscussionLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetDiscussionLegacyResponse is a response for TeamsGetDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
type TeamsGetDiscussionLegacyResponse struct {
	internal.Response
	request *TeamsGetDiscussionLegacyReq
	Data    components.TeamDiscussion
}

/*
TeamsGetLegacy performs requests for "teams/get-legacy"

Get a team (Legacy).

  GET /teams/{team_id}

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
func TeamsGetLegacy(ctx context.Context, req *TeamsGetLegacyReq, opt ...options.Option) (*TeamsGetLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsGetLegacyReq)
	}
	resp := &TeamsGetLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamFull{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetLegacy performs requests for "teams/get-legacy"

Get a team (Legacy).

  GET /teams/{team_id}

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
func (c Client) TeamsGetLegacy(ctx context.Context, req *TeamsGetLegacyReq, opt ...options.Option) (*TeamsGetLegacyResponse, error) {
	return TeamsGetLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsGetLegacyReq is request data for Client.TeamsGetLegacy

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
type TeamsGetLegacyReq struct {
	_url   string
	TeamId int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsGetLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetLegacyReq) Rel(link RelName, resp *TeamsGetLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetLegacyResponse is a response for TeamsGetLegacy

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
type TeamsGetLegacyResponse struct {
	internal.Response
	request *TeamsGetLegacyReq
	Data    components.TeamFull
}

/*
TeamsGetMemberLegacy performs requests for "teams/get-member-legacy"

Get team member (Legacy).

  GET /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
func TeamsGetMemberLegacy(ctx context.Context, req *TeamsGetMemberLegacyReq, opt ...options.Option) (*TeamsGetMemberLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsGetMemberLegacyReq)
	}
	resp := &TeamsGetMemberLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetMemberLegacy performs requests for "teams/get-member-legacy"

Get team member (Legacy).

  GET /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
func (c Client) TeamsGetMemberLegacy(ctx context.Context, req *TeamsGetMemberLegacyReq, opt ...options.Option) (*TeamsGetMemberLegacyResponse, error) {
	return TeamsGetMemberLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsGetMemberLegacyReq is request data for Client.TeamsGetMemberLegacy

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
type TeamsGetMemberLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetMemberLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsGetMemberLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "teams/get-member-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/members/%v", r.TeamId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetMemberLegacyReq) Rel(link RelName, resp *TeamsGetMemberLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetMemberLegacyResponse is a response for TeamsGetMemberLegacy

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
type TeamsGetMemberLegacyResponse struct {
	internal.Response
	request *TeamsGetMemberLegacyReq
	Data    bool
}

/*
TeamsGetMembershipForUserInOrg performs requests for "teams/get-membership-for-user-in-org"

Get team membership for a user.

  GET /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
func TeamsGetMembershipForUserInOrg(ctx context.Context, req *TeamsGetMembershipForUserInOrgReq, opt ...options.Option) (*TeamsGetMembershipForUserInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsGetMembershipForUserInOrgReq)
	}
	resp := &TeamsGetMembershipForUserInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamMembership{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetMembershipForUserInOrg performs requests for "teams/get-membership-for-user-in-org"

Get team membership for a user.

  GET /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
func (c Client) TeamsGetMembershipForUserInOrg(ctx context.Context, req *TeamsGetMembershipForUserInOrgReq, opt ...options.Option) (*TeamsGetMembershipForUserInOrgResponse, error) {
	return TeamsGetMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsGetMembershipForUserInOrgReq is request data for Client.TeamsGetMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
type TeamsGetMembershipForUserInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsGetMembershipForUserInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-membership-for-user-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetMembershipForUserInOrgReq) Rel(link RelName, resp *TeamsGetMembershipForUserInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetMembershipForUserInOrgResponse is a response for TeamsGetMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
type TeamsGetMembershipForUserInOrgResponse struct {
	internal.Response
	request *TeamsGetMembershipForUserInOrgReq
	Data    components.TeamMembership
}

/*
TeamsGetMembershipForUserLegacy performs requests for "teams/get-membership-for-user-legacy"

Get team membership for a user (Legacy).

  GET /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
func TeamsGetMembershipForUserLegacy(ctx context.Context, req *TeamsGetMembershipForUserLegacyReq, opt ...options.Option) (*TeamsGetMembershipForUserLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsGetMembershipForUserLegacyReq)
	}
	resp := &TeamsGetMembershipForUserLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamMembership{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetMembershipForUserLegacy performs requests for "teams/get-membership-for-user-legacy"

Get team membership for a user (Legacy).

  GET /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
func (c Client) TeamsGetMembershipForUserLegacy(ctx context.Context, req *TeamsGetMembershipForUserLegacyReq, opt ...options.Option) (*TeamsGetMembershipForUserLegacyResponse, error) {
	return TeamsGetMembershipForUserLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsGetMembershipForUserLegacyReq is request data for Client.TeamsGetMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
type TeamsGetMembershipForUserLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetMembershipForUserLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsGetMembershipForUserLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/get-membership-for-user-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/memberships/%v", r.TeamId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetMembershipForUserLegacyReq) Rel(link RelName, resp *TeamsGetMembershipForUserLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetMembershipForUserLegacyResponse is a response for TeamsGetMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
type TeamsGetMembershipForUserLegacyResponse struct {
	internal.Response
	request *TeamsGetMembershipForUserLegacyReq
	Data    components.TeamMembership
}

/*
TeamsList performs requests for "teams/list"

List teams.

  GET /orgs/{org}/teams

https://developer.github.com/v3/teams/#list-teams
*/
func TeamsList(ctx context.Context, req *TeamsListReq, opt ...options.Option) (*TeamsListResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListReq)
	}
	resp := &TeamsListResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsList performs requests for "teams/list"

List teams.

  GET /orgs/{org}/teams

https://developer.github.com/v3/teams/#list-teams
*/
func (c Client) TeamsList(ctx context.Context, req *TeamsListReq, opt ...options.Option) (*TeamsListResponse, error) {
	return TeamsList(ctx, req, append(c, opt...)...)
}

/*
TeamsListReq is request data for Client.TeamsList

https://developer.github.com/v3/teams/#list-teams
*/
type TeamsListReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsListReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListReq) Rel(link RelName, resp *TeamsListResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListResponse is a response for TeamsList

https://developer.github.com/v3/teams/#list-teams
*/
type TeamsListResponse struct {
	internal.Response
	request *TeamsListReq
	Data    []components.Team
}

/*
TeamsListChildInOrg performs requests for "teams/list-child-in-org"

List child teams.

  GET /orgs/{org}/teams/{team_slug}/teams

https://developer.github.com/v3/teams/#list-child-teams
*/
func TeamsListChildInOrg(ctx context.Context, req *TeamsListChildInOrgReq, opt ...options.Option) (*TeamsListChildInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListChildInOrgReq)
	}
	resp := &TeamsListChildInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListChildInOrg performs requests for "teams/list-child-in-org"

List child teams.

  GET /orgs/{org}/teams/{team_slug}/teams

https://developer.github.com/v3/teams/#list-child-teams
*/
func (c Client) TeamsListChildInOrg(ctx context.Context, req *TeamsListChildInOrgReq, opt ...options.Option) (*TeamsListChildInOrgResponse, error) {
	return TeamsListChildInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListChildInOrgReq is request data for Client.TeamsListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type TeamsListChildInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsListChildInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListChildInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-child-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/teams", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListChildInOrgReq) Rel(link RelName, resp *TeamsListChildInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListChildInOrgResponse is a response for TeamsListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type TeamsListChildInOrgResponse struct {
	internal.Response
	request *TeamsListChildInOrgReq
	Data    []components.Team
}

/*
TeamsListChildLegacy performs requests for "teams/list-child-legacy"

List child teams (Legacy).

  GET /teams/{team_id}/teams

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
func TeamsListChildLegacy(ctx context.Context, req *TeamsListChildLegacyReq, opt ...options.Option) (*TeamsListChildLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListChildLegacyReq)
	}
	resp := &TeamsListChildLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.Team{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListChildLegacy performs requests for "teams/list-child-legacy"

List child teams (Legacy).

  GET /teams/{team_id}/teams

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
func (c Client) TeamsListChildLegacy(ctx context.Context, req *TeamsListChildLegacyReq, opt ...options.Option) (*TeamsListChildLegacyResponse, error) {
	return TeamsListChildLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListChildLegacyReq is request data for Client.TeamsListChildLegacy

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
type TeamsListChildLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsListChildLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListChildLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-child-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/teams", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListChildLegacyReq) Rel(link RelName, resp *TeamsListChildLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListChildLegacyResponse is a response for TeamsListChildLegacy

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
type TeamsListChildLegacyResponse struct {
	internal.Response
	request *TeamsListChildLegacyReq
	Data    []components.Team
}

/*
TeamsListDiscussionCommentsInOrg performs requests for "teams/list-discussion-comments-in-org"

List discussion comments.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
func TeamsListDiscussionCommentsInOrg(ctx context.Context, req *TeamsListDiscussionCommentsInOrgReq, opt ...options.Option) (*TeamsListDiscussionCommentsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListDiscussionCommentsInOrgReq)
	}
	resp := &TeamsListDiscussionCommentsInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListDiscussionCommentsInOrg performs requests for "teams/list-discussion-comments-in-org"

List discussion comments.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
func (c Client) TeamsListDiscussionCommentsInOrg(ctx context.Context, req *TeamsListDiscussionCommentsInOrgReq, opt ...options.Option) (*TeamsListDiscussionCommentsInOrgResponse, error) {
	return TeamsListDiscussionCommentsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListDiscussionCommentsInOrgReq is request data for Client.TeamsListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
type TeamsListDiscussionCommentsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsListDiscussionCommentsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListDiscussionCommentsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-discussion-comments-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListDiscussionCommentsInOrgReq) Rel(link RelName, resp *TeamsListDiscussionCommentsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListDiscussionCommentsInOrgResponse is a response for TeamsListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
type TeamsListDiscussionCommentsInOrgResponse struct {
	internal.Response
	request *TeamsListDiscussionCommentsInOrgReq
	Data    []components.TeamDiscussionComment
}

/*
TeamsListDiscussionCommentsLegacy performs requests for "teams/list-discussion-comments-legacy"

List discussion comments (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
func TeamsListDiscussionCommentsLegacy(ctx context.Context, req *TeamsListDiscussionCommentsLegacyReq, opt ...options.Option) (*TeamsListDiscussionCommentsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListDiscussionCommentsLegacyReq)
	}
	resp := &TeamsListDiscussionCommentsLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListDiscussionCommentsLegacy performs requests for "teams/list-discussion-comments-legacy"

List discussion comments (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
func (c Client) TeamsListDiscussionCommentsLegacy(ctx context.Context, req *TeamsListDiscussionCommentsLegacyReq, opt ...options.Option) (*TeamsListDiscussionCommentsLegacyResponse, error) {
	return TeamsListDiscussionCommentsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListDiscussionCommentsLegacyReq is request data for Client.TeamsListDiscussionCommentsLegacy

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
type TeamsListDiscussionCommentsLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsListDiscussionCommentsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListDiscussionCommentsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-discussion-comments-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListDiscussionCommentsLegacyReq) Rel(link RelName, resp *TeamsListDiscussionCommentsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListDiscussionCommentsLegacyResponse is a response for TeamsListDiscussionCommentsLegacy

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
type TeamsListDiscussionCommentsLegacyResponse struct {
	internal.Response
	request *TeamsListDiscussionCommentsLegacyReq
	Data    []components.TeamDiscussionComment
}

/*
TeamsListDiscussionsInOrg performs requests for "teams/list-discussions-in-org"

List discussions.

  GET /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
func TeamsListDiscussionsInOrg(ctx context.Context, req *TeamsListDiscussionsInOrgReq, opt ...options.Option) (*TeamsListDiscussionsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListDiscussionsInOrgReq)
	}
	resp := &TeamsListDiscussionsInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListDiscussionsInOrg performs requests for "teams/list-discussions-in-org"

List discussions.

  GET /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
func (c Client) TeamsListDiscussionsInOrg(ctx context.Context, req *TeamsListDiscussionsInOrgReq, opt ...options.Option) (*TeamsListDiscussionsInOrgResponse, error) {
	return TeamsListDiscussionsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListDiscussionsInOrgReq is request data for Client.TeamsListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type TeamsListDiscussionsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsListDiscussionsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListDiscussionsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-discussions-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListDiscussionsInOrgReq) Rel(link RelName, resp *TeamsListDiscussionsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListDiscussionsInOrgResponse is a response for TeamsListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type TeamsListDiscussionsInOrgResponse struct {
	internal.Response
	request *TeamsListDiscussionsInOrgReq
	Data    []components.TeamDiscussion
}

/*
TeamsListDiscussionsLegacy performs requests for "teams/list-discussions-legacy"

List discussions (Legacy).

  GET /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
func TeamsListDiscussionsLegacy(ctx context.Context, req *TeamsListDiscussionsLegacyReq, opt ...options.Option) (*TeamsListDiscussionsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListDiscussionsLegacyReq)
	}
	resp := &TeamsListDiscussionsLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListDiscussionsLegacy performs requests for "teams/list-discussions-legacy"

List discussions (Legacy).

  GET /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
func (c Client) TeamsListDiscussionsLegacy(ctx context.Context, req *TeamsListDiscussionsLegacyReq, opt ...options.Option) (*TeamsListDiscussionsLegacyResponse, error) {
	return TeamsListDiscussionsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListDiscussionsLegacyReq is request data for Client.TeamsListDiscussionsLegacy

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
type TeamsListDiscussionsLegacyReq struct {
	_url   string
	TeamId int64

	// One of `asc` (ascending) or `desc` (descending).
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsListDiscussionsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListDiscussionsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"squirrel-girl"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-discussions-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListDiscussionsLegacyReq) Rel(link RelName, resp *TeamsListDiscussionsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListDiscussionsLegacyResponse is a response for TeamsListDiscussionsLegacy

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
type TeamsListDiscussionsLegacyResponse struct {
	internal.Response
	request *TeamsListDiscussionsLegacyReq
	Data    []components.TeamDiscussion
}

/*
TeamsListForAuthenticatedUser performs requests for "teams/list-for-authenticated-user"

List teams for the authenticated user.

  GET /user/teams

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
func TeamsListForAuthenticatedUser(ctx context.Context, req *TeamsListForAuthenticatedUserReq, opt ...options.Option) (*TeamsListForAuthenticatedUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListForAuthenticatedUserReq)
	}
	resp := &TeamsListForAuthenticatedUserResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamFull{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListForAuthenticatedUser performs requests for "teams/list-for-authenticated-user"

List teams for the authenticated user.

  GET /user/teams

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
func (c Client) TeamsListForAuthenticatedUser(ctx context.Context, req *TeamsListForAuthenticatedUserReq, opt ...options.Option) (*TeamsListForAuthenticatedUserResponse, error) {
	return TeamsListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
TeamsListForAuthenticatedUserReq is request data for Client.TeamsListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
type TeamsListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListForAuthenticatedUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-for-authenticated-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/user/teams"),
		URLQuery:         query,
		ValidStatuses:    []int{200, 304},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListForAuthenticatedUserReq) Rel(link RelName, resp *TeamsListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListForAuthenticatedUserResponse is a response for TeamsListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
type TeamsListForAuthenticatedUserResponse struct {
	internal.Response
	request *TeamsListForAuthenticatedUserReq
	Data    []components.TeamFull
}

/*
TeamsListIdpGroupsForLegacy performs requests for "teams/list-idp-groups-for-legacy"

List IdP groups for a team (Legacy).

  GET /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
func TeamsListIdpGroupsForLegacy(ctx context.Context, req *TeamsListIdpGroupsForLegacyReq, opt ...options.Option) (*TeamsListIdpGroupsForLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListIdpGroupsForLegacyReq)
	}
	resp := &TeamsListIdpGroupsForLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GroupMapping{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListIdpGroupsForLegacy performs requests for "teams/list-idp-groups-for-legacy"

List IdP groups for a team (Legacy).

  GET /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
func (c Client) TeamsListIdpGroupsForLegacy(ctx context.Context, req *TeamsListIdpGroupsForLegacyReq, opt ...options.Option) (*TeamsListIdpGroupsForLegacyResponse, error) {
	return TeamsListIdpGroupsForLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListIdpGroupsForLegacyReq is request data for Client.TeamsListIdpGroupsForLegacy

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
type TeamsListIdpGroupsForLegacyReq struct {
	_url   string
	TeamId int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsListIdpGroupsForLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListIdpGroupsForLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-idp-groups-for-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/team-sync/group-mappings", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListIdpGroupsForLegacyReq) Rel(link RelName, resp *TeamsListIdpGroupsForLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListIdpGroupsForLegacyResponse is a response for TeamsListIdpGroupsForLegacy

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
type TeamsListIdpGroupsForLegacyResponse struct {
	internal.Response
	request *TeamsListIdpGroupsForLegacyReq
	Data    components.GroupMapping
}

/*
TeamsListIdpGroupsForOrg performs requests for "teams/list-idp-groups-for-org"

List IdP groups for an organization.

  GET /orgs/{org}/team-sync/groups

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
func TeamsListIdpGroupsForOrg(ctx context.Context, req *TeamsListIdpGroupsForOrgReq, opt ...options.Option) (*TeamsListIdpGroupsForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListIdpGroupsForOrgReq)
	}
	resp := &TeamsListIdpGroupsForOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GroupMapping{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListIdpGroupsForOrg performs requests for "teams/list-idp-groups-for-org"

List IdP groups for an organization.

  GET /orgs/{org}/team-sync/groups

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
func (c Client) TeamsListIdpGroupsForOrg(ctx context.Context, req *TeamsListIdpGroupsForOrgReq, opt ...options.Option) (*TeamsListIdpGroupsForOrgResponse, error) {
	return TeamsListIdpGroupsForOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListIdpGroupsForOrgReq is request data for Client.TeamsListIdpGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
type TeamsListIdpGroupsForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsListIdpGroupsForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListIdpGroupsForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-idp-groups-for-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/team-sync/groups", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListIdpGroupsForOrgReq) Rel(link RelName, resp *TeamsListIdpGroupsForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListIdpGroupsForOrgResponse is a response for TeamsListIdpGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
type TeamsListIdpGroupsForOrgResponse struct {
	internal.Response
	request *TeamsListIdpGroupsForOrgReq
	Data    components.GroupMapping
}

/*
TeamsListIdpGroupsInOrg performs requests for "teams/list-idp-groups-in-org"

List IdP groups for a team.

  GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
func TeamsListIdpGroupsInOrg(ctx context.Context, req *TeamsListIdpGroupsInOrgReq, opt ...options.Option) (*TeamsListIdpGroupsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListIdpGroupsInOrgReq)
	}
	resp := &TeamsListIdpGroupsInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.GroupMapping{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListIdpGroupsInOrg performs requests for "teams/list-idp-groups-in-org"

List IdP groups for a team.

  GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
func (c Client) TeamsListIdpGroupsInOrg(ctx context.Context, req *TeamsListIdpGroupsInOrgReq, opt ...options.Option) (*TeamsListIdpGroupsInOrgResponse, error) {
	return TeamsListIdpGroupsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListIdpGroupsInOrgReq is request data for Client.TeamsListIdpGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type TeamsListIdpGroupsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
}

// HTTPRequest builds an *http.Request
func (r *TeamsListIdpGroupsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListIdpGroupsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-idp-groups-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/team-sync/group-mappings", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListIdpGroupsInOrgReq) Rel(link RelName, resp *TeamsListIdpGroupsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListIdpGroupsInOrgResponse is a response for TeamsListIdpGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type TeamsListIdpGroupsInOrgResponse struct {
	internal.Response
	request *TeamsListIdpGroupsInOrgReq
	Data    components.GroupMapping
}

/*
TeamsListMembersInOrg performs requests for "teams/list-members-in-org"

List team members.

  GET /orgs/{org}/teams/{team_slug}/members

https://developer.github.com/v3/teams/members/#list-team-members
*/
func TeamsListMembersInOrg(ctx context.Context, req *TeamsListMembersInOrgReq, opt ...options.Option) (*TeamsListMembersInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListMembersInOrgReq)
	}
	resp := &TeamsListMembersInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListMembersInOrg performs requests for "teams/list-members-in-org"

List team members.

  GET /orgs/{org}/teams/{team_slug}/members

https://developer.github.com/v3/teams/members/#list-team-members
*/
func (c Client) TeamsListMembersInOrg(ctx context.Context, req *TeamsListMembersInOrgReq, opt ...options.Option) (*TeamsListMembersInOrgResponse, error) {
	return TeamsListMembersInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListMembersInOrgReq is request data for Client.TeamsListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type TeamsListMembersInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	/*
	Filters members returned by their role in the team. Can be one of:
	\* `member` - normal members of the team.
	\* `maintainer` - team maintainers.
	\* `all` - all members of the team.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsListMembersInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListMembersInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-members-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/members", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListMembersInOrgReq) Rel(link RelName, resp *TeamsListMembersInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListMembersInOrgResponse is a response for TeamsListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type TeamsListMembersInOrgResponse struct {
	internal.Response
	request *TeamsListMembersInOrgReq
	Data    []components.SimpleUser
}

/*
TeamsListMembersLegacy performs requests for "teams/list-members-legacy"

List team members (Legacy).

  GET /teams/{team_id}/members

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
func TeamsListMembersLegacy(ctx context.Context, req *TeamsListMembersLegacyReq, opt ...options.Option) (*TeamsListMembersLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListMembersLegacyReq)
	}
	resp := &TeamsListMembersLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.SimpleUser{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListMembersLegacy performs requests for "teams/list-members-legacy"

List team members (Legacy).

  GET /teams/{team_id}/members

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
func (c Client) TeamsListMembersLegacy(ctx context.Context, req *TeamsListMembersLegacyReq, opt ...options.Option) (*TeamsListMembersLegacyResponse, error) {
	return TeamsListMembersLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListMembersLegacyReq is request data for Client.TeamsListMembersLegacy

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
type TeamsListMembersLegacyReq struct {
	_url   string
	TeamId int64

	/*
	Filters members returned by their role in the team. Can be one of:
	\* `member` - normal members of the team.
	\* `maintainer` - team maintainers.
	\* `all` - all members of the team.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsListMembersLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListMembersLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-members-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/members", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListMembersLegacyReq) Rel(link RelName, resp *TeamsListMembersLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListMembersLegacyResponse is a response for TeamsListMembersLegacy

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
type TeamsListMembersLegacyResponse struct {
	internal.Response
	request *TeamsListMembersLegacyReq
	Data    []components.SimpleUser
}

/*
TeamsListPendingInvitationsInOrg performs requests for "teams/list-pending-invitations-in-org"

List pending team invitations.

  GET /orgs/{org}/teams/{team_slug}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
func TeamsListPendingInvitationsInOrg(ctx context.Context, req *TeamsListPendingInvitationsInOrgReq, opt ...options.Option) (*TeamsListPendingInvitationsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListPendingInvitationsInOrgReq)
	}
	resp := &TeamsListPendingInvitationsInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrganizationInvitation{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListPendingInvitationsInOrg performs requests for "teams/list-pending-invitations-in-org"

List pending team invitations.

  GET /orgs/{org}/teams/{team_slug}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
func (c Client) TeamsListPendingInvitationsInOrg(ctx context.Context, req *TeamsListPendingInvitationsInOrgReq, opt ...options.Option) (*TeamsListPendingInvitationsInOrgResponse, error) {
	return TeamsListPendingInvitationsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListPendingInvitationsInOrgReq is request data for Client.TeamsListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type TeamsListPendingInvitationsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsListPendingInvitationsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListPendingInvitationsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-pending-invitations-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/invitations", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListPendingInvitationsInOrgReq) Rel(link RelName, resp *TeamsListPendingInvitationsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListPendingInvitationsInOrgResponse is a response for TeamsListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type TeamsListPendingInvitationsInOrgResponse struct {
	internal.Response
	request *TeamsListPendingInvitationsInOrgReq
	Data    []components.OrganizationInvitation
}

/*
TeamsListPendingInvitationsLegacy performs requests for "teams/list-pending-invitations-legacy"

List pending team invitations (Legacy).

  GET /teams/{team_id}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
func TeamsListPendingInvitationsLegacy(ctx context.Context, req *TeamsListPendingInvitationsLegacyReq, opt ...options.Option) (*TeamsListPendingInvitationsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListPendingInvitationsLegacyReq)
	}
	resp := &TeamsListPendingInvitationsLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.OrganizationInvitation{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListPendingInvitationsLegacy performs requests for "teams/list-pending-invitations-legacy"

List pending team invitations (Legacy).

  GET /teams/{team_id}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
func (c Client) TeamsListPendingInvitationsLegacy(ctx context.Context, req *TeamsListPendingInvitationsLegacyReq, opt ...options.Option) (*TeamsListPendingInvitationsLegacyResponse, error) {
	return TeamsListPendingInvitationsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListPendingInvitationsLegacyReq is request data for Client.TeamsListPendingInvitationsLegacy

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
type TeamsListPendingInvitationsLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsListPendingInvitationsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListPendingInvitationsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-pending-invitations-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/invitations", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListPendingInvitationsLegacyReq) Rel(link RelName, resp *TeamsListPendingInvitationsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListPendingInvitationsLegacyResponse is a response for TeamsListPendingInvitationsLegacy

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
type TeamsListPendingInvitationsLegacyResponse struct {
	internal.Response
	request *TeamsListPendingInvitationsLegacyReq
	Data    []components.OrganizationInvitation
}

/*
TeamsListProjectsInOrg performs requests for "teams/list-projects-in-org"

List team projects.

  GET /orgs/{org}/teams/{team_slug}/projects

https://developer.github.com/v3/teams/#list-team-projects
*/
func TeamsListProjectsInOrg(ctx context.Context, req *TeamsListProjectsInOrgReq, opt ...options.Option) (*TeamsListProjectsInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListProjectsInOrgReq)
	}
	resp := &TeamsListProjectsInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamProject{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListProjectsInOrg performs requests for "teams/list-projects-in-org"

List team projects.

  GET /orgs/{org}/teams/{team_slug}/projects

https://developer.github.com/v3/teams/#list-team-projects
*/
func (c Client) TeamsListProjectsInOrg(ctx context.Context, req *TeamsListProjectsInOrgReq, opt ...options.Option) (*TeamsListProjectsInOrgResponse, error) {
	return TeamsListProjectsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListProjectsInOrgReq is request data for Client.TeamsListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type TeamsListProjectsInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsListProjectsInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListProjectsInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-projects-in-org",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/projects", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListProjectsInOrgReq) Rel(link RelName, resp *TeamsListProjectsInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListProjectsInOrgResponse is a response for TeamsListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type TeamsListProjectsInOrgResponse struct {
	internal.Response
	request *TeamsListProjectsInOrgReq
	Data    []components.TeamProject
}

/*
TeamsListProjectsLegacy performs requests for "teams/list-projects-legacy"

List team projects (Legacy).

  GET /teams/{team_id}/projects

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
func TeamsListProjectsLegacy(ctx context.Context, req *TeamsListProjectsLegacyReq, opt ...options.Option) (*TeamsListProjectsLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListProjectsLegacyReq)
	}
	resp := &TeamsListProjectsLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.TeamProject{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListProjectsLegacy performs requests for "teams/list-projects-legacy"

List team projects (Legacy).

  GET /teams/{team_id}/projects

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
func (c Client) TeamsListProjectsLegacy(ctx context.Context, req *TeamsListProjectsLegacyReq, opt ...options.Option) (*TeamsListProjectsLegacyResponse, error) {
	return TeamsListProjectsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListProjectsLegacyReq is request data for Client.TeamsListProjectsLegacy

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
type TeamsListProjectsLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsListProjectsLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListProjectsLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{"inertia"},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-projects-legacy",
		Previews:         map[string]bool{"inertia": r.InertiaPreview},
		RequiredPreviews: []string{"inertia"},
		URLPath:          fmt.Sprintf("/teams/%v/projects", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListProjectsLegacyReq) Rel(link RelName, resp *TeamsListProjectsLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListProjectsLegacyResponse is a response for TeamsListProjectsLegacy

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
type TeamsListProjectsLegacyResponse struct {
	internal.Response
	request *TeamsListProjectsLegacyReq
	Data    []components.TeamProject
}

/*
TeamsListReposInOrg performs requests for "teams/list-repos-in-org"

List team repositories.

  GET /orgs/{org}/teams/{team_slug}/repos

https://developer.github.com/v3/teams/#list-team-repositories
*/
func TeamsListReposInOrg(ctx context.Context, req *TeamsListReposInOrgReq, opt ...options.Option) (*TeamsListReposInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListReposInOrgReq)
	}
	resp := &TeamsListReposInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListReposInOrg performs requests for "teams/list-repos-in-org"

List team repositories.

  GET /orgs/{org}/teams/{team_slug}/repos

https://developer.github.com/v3/teams/#list-team-repositories
*/
func (c Client) TeamsListReposInOrg(ctx context.Context, req *TeamsListReposInOrgReq, opt ...options.Option) (*TeamsListReposInOrgResponse, error) {
	return TeamsListReposInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListReposInOrgReq is request data for Client.TeamsListReposInOrg

https://developer.github.com/v3/teams/#list-team-repositories
*/
type TeamsListReposInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsListReposInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListReposInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-repos-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/repos", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListReposInOrgReq) Rel(link RelName, resp *TeamsListReposInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListReposInOrgResponse is a response for TeamsListReposInOrg

https://developer.github.com/v3/teams/#list-team-repositories
*/
type TeamsListReposInOrgResponse struct {
	internal.Response
	request *TeamsListReposInOrgReq
	Data    []components.MinimalRepository
}

/*
TeamsListReposLegacy performs requests for "teams/list-repos-legacy"

List team repositories (Legacy).

  GET /teams/{team_id}/repos

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
func TeamsListReposLegacy(ctx context.Context, req *TeamsListReposLegacyReq, opt ...options.Option) (*TeamsListReposLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsListReposLegacyReq)
	}
	resp := &TeamsListReposLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.MinimalRepository{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListReposLegacy performs requests for "teams/list-repos-legacy"

List team repositories (Legacy).

  GET /teams/{team_id}/repos

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
func (c Client) TeamsListReposLegacy(ctx context.Context, req *TeamsListReposLegacyReq, opt ...options.Option) (*TeamsListReposLegacyResponse, error) {
	return TeamsListReposLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListReposLegacyReq is request data for Client.TeamsListReposLegacy

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
type TeamsListReposLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsListReposLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsListReposLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "teams/list-repos-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/repos", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListReposLegacyReq) Rel(link RelName, resp *TeamsListReposLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListReposLegacyResponse is a response for TeamsListReposLegacy

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
type TeamsListReposLegacyResponse struct {
	internal.Response
	request *TeamsListReposLegacyReq
	Data    []components.MinimalRepository
}

/*
TeamsRemoveMemberLegacy performs requests for "teams/remove-member-legacy"

Remove team member (Legacy).

  DELETE /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
func TeamsRemoveMemberLegacy(ctx context.Context, req *TeamsRemoveMemberLegacyReq, opt ...options.Option) (*TeamsRemoveMemberLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsRemoveMemberLegacyReq)
	}
	resp := &TeamsRemoveMemberLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.SetBoolResult(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveMemberLegacy performs requests for "teams/remove-member-legacy"

Remove team member (Legacy).

  DELETE /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
func (c Client) TeamsRemoveMemberLegacy(ctx context.Context, req *TeamsRemoveMemberLegacyReq, opt ...options.Option) (*TeamsRemoveMemberLegacyResponse, error) {
	return TeamsRemoveMemberLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveMemberLegacyReq is request data for Client.TeamsRemoveMemberLegacy

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
type TeamsRemoveMemberLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveMemberLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsRemoveMemberLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-member-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/members/%v", r.TeamId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveMemberLegacyReq) Rel(link RelName, resp *TeamsRemoveMemberLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveMemberLegacyResponse is a response for TeamsRemoveMemberLegacy

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
type TeamsRemoveMemberLegacyResponse struct {
	internal.Response
	request *TeamsRemoveMemberLegacyReq
	Data    bool
}

/*
TeamsRemoveMembershipForUserInOrg performs requests for "teams/remove-membership-for-user-in-org"

Remove team membership for a user.

  DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
func TeamsRemoveMembershipForUserInOrg(ctx context.Context, req *TeamsRemoveMembershipForUserInOrgReq, opt ...options.Option) (*TeamsRemoveMembershipForUserInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsRemoveMembershipForUserInOrgReq)
	}
	resp := &TeamsRemoveMembershipForUserInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveMembershipForUserInOrg performs requests for "teams/remove-membership-for-user-in-org"

Remove team membership for a user.

  DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
func (c Client) TeamsRemoveMembershipForUserInOrg(ctx context.Context, req *TeamsRemoveMembershipForUserInOrgReq, opt ...options.Option) (*TeamsRemoveMembershipForUserInOrgResponse, error) {
	return TeamsRemoveMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveMembershipForUserInOrgReq is request data for Client.TeamsRemoveMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
type TeamsRemoveMembershipForUserInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsRemoveMembershipForUserInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-membership-for-user-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveMembershipForUserInOrgReq) Rel(link RelName, resp *TeamsRemoveMembershipForUserInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveMembershipForUserInOrgResponse is a response for TeamsRemoveMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
type TeamsRemoveMembershipForUserInOrgResponse struct {
	internal.Response
	request *TeamsRemoveMembershipForUserInOrgReq
}

/*
TeamsRemoveMembershipForUserLegacy performs requests for "teams/remove-membership-for-user-legacy"

Remove team membership for a user (Legacy).

  DELETE /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
func TeamsRemoveMembershipForUserLegacy(ctx context.Context, req *TeamsRemoveMembershipForUserLegacyReq, opt ...options.Option) (*TeamsRemoveMembershipForUserLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsRemoveMembershipForUserLegacyReq)
	}
	resp := &TeamsRemoveMembershipForUserLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveMembershipForUserLegacy performs requests for "teams/remove-membership-for-user-legacy"

Remove team membership for a user (Legacy).

  DELETE /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
func (c Client) TeamsRemoveMembershipForUserLegacy(ctx context.Context, req *TeamsRemoveMembershipForUserLegacyReq, opt ...options.Option) (*TeamsRemoveMembershipForUserLegacyResponse, error) {
	return TeamsRemoveMembershipForUserLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveMembershipForUserLegacyReq is request data for Client.TeamsRemoveMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
type TeamsRemoveMembershipForUserLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveMembershipForUserLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsRemoveMembershipForUserLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-membership-for-user-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/memberships/%v", r.TeamId, r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveMembershipForUserLegacyReq) Rel(link RelName, resp *TeamsRemoveMembershipForUserLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveMembershipForUserLegacyResponse is a response for TeamsRemoveMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
type TeamsRemoveMembershipForUserLegacyResponse struct {
	internal.Response
	request *TeamsRemoveMembershipForUserLegacyReq
}

/*
TeamsRemoveProjectInOrg performs requests for "teams/remove-project-in-org"

Remove a project from a team.

  DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
func TeamsRemoveProjectInOrg(ctx context.Context, req *TeamsRemoveProjectInOrgReq, opt ...options.Option) (*TeamsRemoveProjectInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsRemoveProjectInOrgReq)
	}
	resp := &TeamsRemoveProjectInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveProjectInOrg performs requests for "teams/remove-project-in-org"

Remove a project from a team.

  DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
func (c Client) TeamsRemoveProjectInOrg(ctx context.Context, req *TeamsRemoveProjectInOrgReq, opt ...options.Option) (*TeamsRemoveProjectInOrgResponse, error) {
	return TeamsRemoveProjectInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveProjectInOrgReq is request data for Client.TeamsRemoveProjectInOrg

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
type TeamsRemoveProjectInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug  string
	ProjectId int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveProjectInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsRemoveProjectInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-project-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveProjectInOrgReq) Rel(link RelName, resp *TeamsRemoveProjectInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveProjectInOrgResponse is a response for TeamsRemoveProjectInOrg

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
type TeamsRemoveProjectInOrgResponse struct {
	internal.Response
	request *TeamsRemoveProjectInOrgReq
}

/*
TeamsRemoveProjectLegacy performs requests for "teams/remove-project-legacy"

Remove a project from a team (Legacy).

  DELETE /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
func TeamsRemoveProjectLegacy(ctx context.Context, req *TeamsRemoveProjectLegacyReq, opt ...options.Option) (*TeamsRemoveProjectLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsRemoveProjectLegacyReq)
	}
	resp := &TeamsRemoveProjectLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveProjectLegacy performs requests for "teams/remove-project-legacy"

Remove a project from a team (Legacy).

  DELETE /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
func (c Client) TeamsRemoveProjectLegacy(ctx context.Context, req *TeamsRemoveProjectLegacyReq, opt ...options.Option) (*TeamsRemoveProjectLegacyResponse, error) {
	return TeamsRemoveProjectLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveProjectLegacyReq is request data for Client.TeamsRemoveProjectLegacy

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
type TeamsRemoveProjectLegacyReq struct {
	_url      string
	TeamId    int64
	ProjectId int64
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveProjectLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsRemoveProjectLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-project-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/projects/%v", r.TeamId, r.ProjectId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveProjectLegacyReq) Rel(link RelName, resp *TeamsRemoveProjectLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveProjectLegacyResponse is a response for TeamsRemoveProjectLegacy

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
type TeamsRemoveProjectLegacyResponse struct {
	internal.Response
	request *TeamsRemoveProjectLegacyReq
}

/*
TeamsRemoveRepoInOrg performs requests for "teams/remove-repo-in-org"

Remove a repository from a team.

  DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
func TeamsRemoveRepoInOrg(ctx context.Context, req *TeamsRemoveRepoInOrgReq, opt ...options.Option) (*TeamsRemoveRepoInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsRemoveRepoInOrgReq)
	}
	resp := &TeamsRemoveRepoInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveRepoInOrg performs requests for "teams/remove-repo-in-org"

Remove a repository from a team.

  DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
func (c Client) TeamsRemoveRepoInOrg(ctx context.Context, req *TeamsRemoveRepoInOrgReq, opt ...options.Option) (*TeamsRemoveRepoInOrgResponse, error) {
	return TeamsRemoveRepoInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveRepoInOrgReq is request data for Client.TeamsRemoveRepoInOrg

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
type TeamsRemoveRepoInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug string
	Owner    string
	Repo     string
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveRepoInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsRemoveRepoInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-repo-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveRepoInOrgReq) Rel(link RelName, resp *TeamsRemoveRepoInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveRepoInOrgResponse is a response for TeamsRemoveRepoInOrg

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
type TeamsRemoveRepoInOrgResponse struct {
	internal.Response
	request *TeamsRemoveRepoInOrgReq
}

/*
TeamsRemoveRepoLegacy performs requests for "teams/remove-repo-legacy"

Remove a repository from a team (Legacy).

  DELETE /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
func TeamsRemoveRepoLegacy(ctx context.Context, req *TeamsRemoveRepoLegacyReq, opt ...options.Option) (*TeamsRemoveRepoLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsRemoveRepoLegacyReq)
	}
	resp := &TeamsRemoveRepoLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveRepoLegacy performs requests for "teams/remove-repo-legacy"

Remove a repository from a team (Legacy).

  DELETE /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
func (c Client) TeamsRemoveRepoLegacy(ctx context.Context, req *TeamsRemoveRepoLegacyReq, opt ...options.Option) (*TeamsRemoveRepoLegacyResponse, error) {
	return TeamsRemoveRepoLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveRepoLegacyReq is request data for Client.TeamsRemoveRepoLegacy

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
type TeamsRemoveRepoLegacyReq struct {
	_url   string
	TeamId int64
	Owner  string
	Repo   string
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveRepoLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsRemoveRepoLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "teams/remove-repo-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/repos/%v/%v", r.TeamId, r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveRepoLegacyReq) Rel(link RelName, resp *TeamsRemoveRepoLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveRepoLegacyResponse is a response for TeamsRemoveRepoLegacy

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
type TeamsRemoveRepoLegacyResponse struct {
	internal.Response
	request *TeamsRemoveRepoLegacyReq
}

/*
TeamsUpdateDiscussionCommentInOrg performs requests for "teams/update-discussion-comment-in-org"

Update a discussion comment.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
func TeamsUpdateDiscussionCommentInOrg(ctx context.Context, req *TeamsUpdateDiscussionCommentInOrgReq, opt ...options.Option) (*TeamsUpdateDiscussionCommentInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsUpdateDiscussionCommentInOrgReq)
	}
	resp := &TeamsUpdateDiscussionCommentInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateDiscussionCommentInOrg performs requests for "teams/update-discussion-comment-in-org"

Update a discussion comment.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
func (c Client) TeamsUpdateDiscussionCommentInOrg(ctx context.Context, req *TeamsUpdateDiscussionCommentInOrgReq, opt ...options.Option) (*TeamsUpdateDiscussionCommentInOrgResponse, error) {
	return TeamsUpdateDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateDiscussionCommentInOrgReq is request data for Client.TeamsUpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type TeamsUpdateDiscussionCommentInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      TeamsUpdateDiscussionCommentInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-discussion-comment-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsUpdateDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateDiscussionCommentInOrgReqBody is a request body for teams/update-discussion-comment-in-org

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type TeamsUpdateDiscussionCommentInOrgReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
TeamsUpdateDiscussionCommentInOrgResponse is a response for TeamsUpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type TeamsUpdateDiscussionCommentInOrgResponse struct {
	internal.Response
	request *TeamsUpdateDiscussionCommentInOrgReq
	Data    components.TeamDiscussionComment
}

/*
TeamsUpdateDiscussionCommentLegacy performs requests for "teams/update-discussion-comment-legacy"

Update a discussion comment (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
func TeamsUpdateDiscussionCommentLegacy(ctx context.Context, req *TeamsUpdateDiscussionCommentLegacyReq, opt ...options.Option) (*TeamsUpdateDiscussionCommentLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsUpdateDiscussionCommentLegacyReq)
	}
	resp := &TeamsUpdateDiscussionCommentLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussionComment{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateDiscussionCommentLegacy performs requests for "teams/update-discussion-comment-legacy"

Update a discussion comment (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
func (c Client) TeamsUpdateDiscussionCommentLegacy(ctx context.Context, req *TeamsUpdateDiscussionCommentLegacyReq, opt ...options.Option) (*TeamsUpdateDiscussionCommentLegacyResponse, error) {
	return TeamsUpdateDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateDiscussionCommentLegacyReq is request data for Client.TeamsUpdateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
type TeamsUpdateDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      TeamsUpdateDiscussionCommentLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsUpdateDiscussionCommentLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-discussion-comment-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v/comments/%v", r.TeamId, r.DiscussionNumber, r.CommentNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateDiscussionCommentLegacyReq) Rel(link RelName, resp *TeamsUpdateDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateDiscussionCommentLegacyReqBody is a request body for teams/update-discussion-comment-legacy

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
type TeamsUpdateDiscussionCommentLegacyReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
TeamsUpdateDiscussionCommentLegacyResponse is a response for TeamsUpdateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
type TeamsUpdateDiscussionCommentLegacyResponse struct {
	internal.Response
	request *TeamsUpdateDiscussionCommentLegacyReq
	Data    components.TeamDiscussionComment
}

/*
TeamsUpdateDiscussionInOrg performs requests for "teams/update-discussion-in-org"

Update a discussion.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
func TeamsUpdateDiscussionInOrg(ctx context.Context, req *TeamsUpdateDiscussionInOrgReq, opt ...options.Option) (*TeamsUpdateDiscussionInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsUpdateDiscussionInOrgReq)
	}
	resp := &TeamsUpdateDiscussionInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateDiscussionInOrg performs requests for "teams/update-discussion-in-org"

Update a discussion.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
func (c Client) TeamsUpdateDiscussionInOrg(ctx context.Context, req *TeamsUpdateDiscussionInOrgReq, opt ...options.Option) (*TeamsUpdateDiscussionInOrgResponse, error) {
	return TeamsUpdateDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateDiscussionInOrgReq is request data for Client.TeamsUpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type TeamsUpdateDiscussionInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      TeamsUpdateDiscussionInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsUpdateDiscussionInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-discussion-in-org",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateDiscussionInOrgReq) Rel(link RelName, resp *TeamsUpdateDiscussionInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateDiscussionInOrgReqBody is a request body for teams/update-discussion-in-org

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type TeamsUpdateDiscussionInOrgReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body,omitempty"`

	// The discussion post's title.
	Title *string `json:"title,omitempty"`
}

/*
TeamsUpdateDiscussionInOrgResponse is a response for TeamsUpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type TeamsUpdateDiscussionInOrgResponse struct {
	internal.Response
	request *TeamsUpdateDiscussionInOrgReq
	Data    components.TeamDiscussion
}

/*
TeamsUpdateDiscussionLegacy performs requests for "teams/update-discussion-legacy"

Update a discussion (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
func TeamsUpdateDiscussionLegacy(ctx context.Context, req *TeamsUpdateDiscussionLegacyReq, opt ...options.Option) (*TeamsUpdateDiscussionLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsUpdateDiscussionLegacyReq)
	}
	resp := &TeamsUpdateDiscussionLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamDiscussion{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateDiscussionLegacy performs requests for "teams/update-discussion-legacy"

Update a discussion (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
func (c Client) TeamsUpdateDiscussionLegacy(ctx context.Context, req *TeamsUpdateDiscussionLegacyReq, opt ...options.Option) (*TeamsUpdateDiscussionLegacyResponse, error) {
	return TeamsUpdateDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateDiscussionLegacyReq is request data for Client.TeamsUpdateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
type TeamsUpdateDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	RequestBody      TeamsUpdateDiscussionLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During the preview period, the APIs may
	change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.

	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsUpdateDiscussionLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{"squirrel-girl"},
		Body:         r.RequestBody,
		DataStatuses: []int{200},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-discussion-legacy",
		Previews:         map[string]bool{"squirrel-girl": r.SquirrelGirlPreview},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v/discussions/%v", r.TeamId, r.DiscussionNumber),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateDiscussionLegacyReq) Rel(link RelName, resp *TeamsUpdateDiscussionLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateDiscussionLegacyReqBody is a request body for teams/update-discussion-legacy

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
type TeamsUpdateDiscussionLegacyReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body,omitempty"`

	// The discussion post's title.
	Title *string `json:"title,omitempty"`
}

/*
TeamsUpdateDiscussionLegacyResponse is a response for TeamsUpdateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
type TeamsUpdateDiscussionLegacyResponse struct {
	internal.Response
	request *TeamsUpdateDiscussionLegacyReq
	Data    components.TeamDiscussion
}

/*
TeamsUpdateInOrg performs requests for "teams/update-in-org"

Update a team.

  PATCH /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#update-a-team
*/
func TeamsUpdateInOrg(ctx context.Context, req *TeamsUpdateInOrgReq, opt ...options.Option) (*TeamsUpdateInOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsUpdateInOrgReq)
	}
	resp := &TeamsUpdateInOrgResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamFull{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateInOrg performs requests for "teams/update-in-org"

Update a team.

  PATCH /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#update-a-team
*/
func (c Client) TeamsUpdateInOrg(ctx context.Context, req *TeamsUpdateInOrgReq, opt ...options.Option) (*TeamsUpdateInOrgResponse, error) {
	return TeamsUpdateInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateInOrgReq is request data for Client.TeamsUpdateInOrg

https://developer.github.com/v3/teams/#update-a-team
*/
type TeamsUpdateInOrgReq struct {
	_url string
	Org  string

	// team_slug parameter
	TeamSlug    string
	RequestBody TeamsUpdateInOrgReqBody
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateInOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsUpdateInOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-in-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateInOrgReq) Rel(link RelName, resp *TeamsUpdateInOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateInOrgReqBody is a request body for teams/update-in-org

https://developer.github.com/v3/teams/#update-a-team
*/
type TeamsUpdateInOrgReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	**Deprecated**. The permission that new repositories will be added to the team
	with when none is specified. Can be one of:
	\* `pull` - team members can pull, but not push to or administer newly-added
	repositories.
	\* `push` - team members can pull and push, but not administer newly-added
	repositories.
	\* `admin` - team members can pull, push and administer newly-added
	repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	The level of privacy this team should have. Editing teams without specifying
	this parameter leaves `privacy` intact. When a team is nested, the `privacy` for
	parent teams cannot be `secret`. The options are:
	**For a non-nested team:**
	\* `secret` - only visible to organization owners and members of this team.
	\* `closed` - visible to all members of this organization.
	**For a parent or child team:**
	\* `closed` - visible to all members of this organization.
	*/
	Privacy *string `json:"privacy,omitempty"`
}

/*
TeamsUpdateInOrgResponse is a response for TeamsUpdateInOrg

https://developer.github.com/v3/teams/#update-a-team
*/
type TeamsUpdateInOrgResponse struct {
	internal.Response
	request *TeamsUpdateInOrgReq
	Data    components.TeamFull
}

/*
TeamsUpdateLegacy performs requests for "teams/update-legacy"

Update a team (Legacy).

  PATCH /teams/{team_id}

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
func TeamsUpdateLegacy(ctx context.Context, req *TeamsUpdateLegacyReq, opt ...options.Option) (*TeamsUpdateLegacyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(TeamsUpdateLegacyReq)
	}
	resp := &TeamsUpdateLegacyResponse{request: req}
	r, err := internal.DoRequest(ctx, req.requestBuilder(), opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.TeamFull{}
	err = internal.DecodeResponseBody(r, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateLegacy performs requests for "teams/update-legacy"

Update a team (Legacy).

  PATCH /teams/{team_id}

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
func (c Client) TeamsUpdateLegacy(ctx context.Context, req *TeamsUpdateLegacyReq, opt ...options.Option) (*TeamsUpdateLegacyResponse, error) {
	return TeamsUpdateLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateLegacyReq is request data for Client.TeamsUpdateLegacy

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
type TeamsUpdateLegacyReq struct {
	_url        string
	TeamId      int64
	RequestBody TeamsUpdateLegacyReqBody
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateLegacyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *TeamsUpdateLegacyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:  []string{},
		Body:         r.RequestBody,
		DataStatuses: []int{201},
		ExplicitURL:  r._url,
		HeaderVals: map[string]*string{
			"accept":       String("application/json"),
			"content-type": String("application/json"),
		},
		Method:           "PATCH",
		OperationID:      "teams/update-legacy",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/teams/%v", r.TeamId),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateLegacyReq) Rel(link RelName, resp *TeamsUpdateLegacyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateLegacyReqBody is a request body for teams/update-legacy

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
type TeamsUpdateLegacyReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	**Deprecated**. The permission that new repositories will be added to the team
	with when none is specified. Can be one of:
	\* `pull` - team members can pull, but not push to or administer newly-added
	repositories.
	\* `push` - team members can pull and push, but not administer newly-added
	repositories.
	\* `admin` - team members can pull, push and administer newly-added
	repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	The level of privacy this team should have. Editing teams without specifying
	this parameter leaves `privacy` intact. The options are:
	**For a non-nested team:**
	\* `secret` - only visible to organization owners and members of this team.
	\* `closed` - visible to all members of this organization.
	**For a parent or child team:**
	\* `closed` - visible to all members of this organization.
	*/
	Privacy *string `json:"privacy,omitempty"`
}

/*
TeamsUpdateLegacyResponse is a response for TeamsUpdateLegacy

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
type TeamsUpdateLegacyResponse struct {
	internal.Response
	request *TeamsUpdateLegacyReq
	Data    components.TeamFull
}
