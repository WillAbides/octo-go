// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
TeamsAddMemberLegacy performs requests for "teams/add-member-legacy"

Add team member (Legacy).

  PUT /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
func TeamsAddMemberLegacy(ctx context.Context, req *TeamsAddMemberLegacyReq, opt ...RequestOption) (*TeamsAddMemberLegacyResponse, error) {
	if req == nil {
		req = new(TeamsAddMemberLegacyReq)
	}
	resp := &TeamsAddMemberLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddMemberLegacy performs requests for "teams/add-member-legacy"

Add team member (Legacy).

  PUT /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
func (c Client) TeamsAddMemberLegacy(ctx context.Context, req *TeamsAddMemberLegacyReq, opt ...RequestOption) (*TeamsAddMemberLegacyResponse, error) {
	return TeamsAddMemberLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsAddMemberLegacyReq is request data for Client.TeamsAddMemberLegacy

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
type TeamsAddMemberLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

func (r *TeamsAddMemberLegacyReq) url() string {
	return r._url
}

func (r *TeamsAddMemberLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/members/%v", r.TeamId, r.Username)
}

func (r *TeamsAddMemberLegacyReq) method() string {
	return "PUT"
}

func (r *TeamsAddMemberLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsAddMemberLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsAddMemberLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsAddMemberLegacyReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsAddMemberLegacyReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsAddMemberLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddMemberLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddMemberLegacyReq) Rel(link RelName, resp *TeamsAddMemberLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddMemberLegacyResponse is a response for TeamsAddMemberLegacy

https://developer.github.com/v3/teams/members/#add-team-member-legacy
*/
type TeamsAddMemberLegacyResponse struct {
	response
	request *TeamsAddMemberLegacyReq
}

/*
TeamsAddOrUpdateMembershipForUserInOrg performs requests for "teams/add-or-update-membership-for-user-in-org"

Add or update team membership for a user.

  PUT /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
func TeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateMembershipForUserInOrgResponse, error) {
	if req == nil {
		req = new(TeamsAddOrUpdateMembershipForUserInOrgReq)
	}
	resp := &TeamsAddOrUpdateMembershipForUserInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsAddOrUpdateMembershipForUserInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateMembershipForUserInOrg performs requests for "teams/add-or-update-membership-for-user-in-org"

Add or update team membership for a user.

  PUT /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
func (c Client) TeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateMembershipForUserInOrgResponse, error) {
	return TeamsAddOrUpdateMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateMembershipForUserInOrgReq is request data for Client.TeamsAddOrUpdateMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type TeamsAddOrUpdateMembershipForUserInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	Username    string
	RequestBody TeamsAddOrUpdateMembershipForUserInOrgReqBody
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) url() string {
	return r._url
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username)
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) method() string {
	return "PUT"
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateMembershipForUserInOrgReq) Rel(link RelName, resp *TeamsAddOrUpdateMembershipForUserInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateMembershipForUserInOrgReqBody is a request body for teams/add-or-update-membership-for-user-in-org

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type TeamsAddOrUpdateMembershipForUserInOrgReqBody struct {

	/*
	   The role that this user should have in the team. Can be one of:
	   \* `member` - a normal member of the team.
	   \* `maintainer` - a team maintainer. Able to add/remove other team members,
	   promote other team members to team maintainer, and edit the team's name and
	   description.
	*/
	Role *string `json:"role,omitempty"`
}

/*
TeamsAddOrUpdateMembershipForUserInOrgResponseBody is a response body for TeamsAddOrUpdateMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type TeamsAddOrUpdateMembershipForUserInOrgResponseBody struct {
	components.TeamMembership
}

/*
TeamsAddOrUpdateMembershipForUserInOrgResponse is a response for TeamsAddOrUpdateMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user
*/
type TeamsAddOrUpdateMembershipForUserInOrgResponse struct {
	response
	request *TeamsAddOrUpdateMembershipForUserInOrgReq
	Data    *TeamsAddOrUpdateMembershipForUserInOrgResponseBody
}

/*
TeamsAddOrUpdateMembershipForUserLegacy performs requests for "teams/add-or-update-membership-for-user-legacy"

Add or update team membership for a user (Legacy).

  PUT /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
func TeamsAddOrUpdateMembershipForUserLegacy(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserLegacyReq, opt ...RequestOption) (*TeamsAddOrUpdateMembershipForUserLegacyResponse, error) {
	if req == nil {
		req = new(TeamsAddOrUpdateMembershipForUserLegacyReq)
	}
	resp := &TeamsAddOrUpdateMembershipForUserLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsAddOrUpdateMembershipForUserLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateMembershipForUserLegacy performs requests for "teams/add-or-update-membership-for-user-legacy"

Add or update team membership for a user (Legacy).

  PUT /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
func (c Client) TeamsAddOrUpdateMembershipForUserLegacy(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserLegacyReq, opt ...RequestOption) (*TeamsAddOrUpdateMembershipForUserLegacyResponse, error) {
	return TeamsAddOrUpdateMembershipForUserLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateMembershipForUserLegacyReq is request data for Client.TeamsAddOrUpdateMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
type TeamsAddOrUpdateMembershipForUserLegacyReq struct {
	_url        string
	TeamId      int64
	Username    string
	RequestBody TeamsAddOrUpdateMembershipForUserLegacyReqBody
}

func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) url() string {
	return r._url
}

func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/memberships/%v", r.TeamId, r.Username)
}

func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) method() string {
	return "PUT"
}

func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateMembershipForUserLegacyReq) Rel(link RelName, resp *TeamsAddOrUpdateMembershipForUserLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateMembershipForUserLegacyReqBody is a request body for teams/add-or-update-membership-for-user-legacy

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
type TeamsAddOrUpdateMembershipForUserLegacyReqBody struct {

	/*
	   The role that this user should have in the team. Can be one of:
	   \* `member` - a normal member of the team.
	   \* `maintainer` - a team maintainer. Able to add/remove other team members,
	   promote other team members to team maintainer, and edit the team's name and
	   description.
	*/
	Role *string `json:"role,omitempty"`
}

/*
TeamsAddOrUpdateMembershipForUserLegacyResponseBody is a response body for TeamsAddOrUpdateMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
type TeamsAddOrUpdateMembershipForUserLegacyResponseBody struct {
	components.TeamMembership
}

/*
TeamsAddOrUpdateMembershipForUserLegacyResponse is a response for TeamsAddOrUpdateMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#add-or-update-team-membership-for-a-user-legacy
*/
type TeamsAddOrUpdateMembershipForUserLegacyResponse struct {
	response
	request *TeamsAddOrUpdateMembershipForUserLegacyReq
	Data    *TeamsAddOrUpdateMembershipForUserLegacyResponseBody
}

/*
TeamsAddOrUpdateProjectPermissionsInOrg performs requests for "teams/add-or-update-project-permissions-in-org"

Add or update team project permissions.

  PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
func TeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateProjectPermissionsInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateProjectPermissionsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsAddOrUpdateProjectPermissionsInOrgReq)
	}
	resp := &TeamsAddOrUpdateProjectPermissionsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateProjectPermissionsInOrg performs requests for "teams/add-or-update-project-permissions-in-org"

Add or update team project permissions.

  PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
func (c Client) TeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateProjectPermissionsInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateProjectPermissionsInOrgResponse, error) {
	return TeamsAddOrUpdateProjectPermissionsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateProjectPermissionsInOrgReq is request data for Client.TeamsAddOrUpdateProjectPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type TeamsAddOrUpdateProjectPermissionsInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	ProjectId   int64
	RequestBody TeamsAddOrUpdateProjectPermissionsInOrgReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) url() string {
	return r._url
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId)
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) method() string {
	return "PUT"
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateProjectPermissionsInOrgReq) Rel(link RelName, resp *TeamsAddOrUpdateProjectPermissionsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateProjectPermissionsInOrgReqBody is a request body for teams/add-or-update-project-permissions-in-org

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type TeamsAddOrUpdateProjectPermissionsInOrgReqBody struct {

	/*
	   The permission to grant to the team for this project. Can be one of:
	   \* `read` - team members can read, but not write to or administer this project.
	   \* `write` - team members can read and write, but not administer this project.
	   \* `admin` - team members can read, write and administer this project.
	   Default: the team's `permission` attribute will be used to determine what
	   permission to grant the team on this project. Note that, if you choose not to
	   pass any parameters, you'll need to set `Content-Length` to zero when calling
	   out to this endpoint. For more information, see "[HTTP
	   verbs](https://developer.github.com/v3/#http-verbs)."
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
TeamsAddOrUpdateProjectPermissionsInOrgResponse is a response for TeamsAddOrUpdateProjectPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions
*/
type TeamsAddOrUpdateProjectPermissionsInOrgResponse struct {
	response
	request *TeamsAddOrUpdateProjectPermissionsInOrgReq
}

/*
TeamsAddOrUpdateProjectPermissionsLegacy performs requests for "teams/add-or-update-project-permissions-legacy"

Add or update team project permissions (Legacy).

  PUT /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
func TeamsAddOrUpdateProjectPermissionsLegacy(ctx context.Context, req *TeamsAddOrUpdateProjectPermissionsLegacyReq, opt ...RequestOption) (*TeamsAddOrUpdateProjectPermissionsLegacyResponse, error) {
	if req == nil {
		req = new(TeamsAddOrUpdateProjectPermissionsLegacyReq)
	}
	resp := &TeamsAddOrUpdateProjectPermissionsLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateProjectPermissionsLegacy performs requests for "teams/add-or-update-project-permissions-legacy"

Add or update team project permissions (Legacy).

  PUT /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
func (c Client) TeamsAddOrUpdateProjectPermissionsLegacy(ctx context.Context, req *TeamsAddOrUpdateProjectPermissionsLegacyReq, opt ...RequestOption) (*TeamsAddOrUpdateProjectPermissionsLegacyResponse, error) {
	return TeamsAddOrUpdateProjectPermissionsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateProjectPermissionsLegacyReq is request data for Client.TeamsAddOrUpdateProjectPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
type TeamsAddOrUpdateProjectPermissionsLegacyReq struct {
	_url        string
	TeamId      int64
	ProjectId   int64
	RequestBody TeamsAddOrUpdateProjectPermissionsLegacyReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) url() string {
	return r._url
}

func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/projects/%v", r.TeamId, r.ProjectId)
}

func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) method() string {
	return "PUT"
}

func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateProjectPermissionsLegacyReq) Rel(link RelName, resp *TeamsAddOrUpdateProjectPermissionsLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateProjectPermissionsLegacyReqBody is a request body for teams/add-or-update-project-permissions-legacy

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
type TeamsAddOrUpdateProjectPermissionsLegacyReqBody struct {

	/*
	   The permission to grant to the team for this project. Can be one of:
	   \* `read` - team members can read, but not write to or administer this project.
	   \* `write` - team members can read and write, but not administer this project.
	   \* `admin` - team members can read, write and administer this project.
	   Default: the team's `permission` attribute will be used to determine what
	   permission to grant the team on this project. Note that, if you choose not to
	   pass any parameters, you'll need to set `Content-Length` to zero when calling
	   out to this endpoint. For more information, see "[HTTP
	   verbs](https://developer.github.com/v3/#http-verbs)."
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
TeamsAddOrUpdateProjectPermissionsLegacyResponse is a response for TeamsAddOrUpdateProjectPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-project-permissions-legacy
*/
type TeamsAddOrUpdateProjectPermissionsLegacyResponse struct {
	response
	request *TeamsAddOrUpdateProjectPermissionsLegacyReq
}

/*
TeamsAddOrUpdateRepoPermissionsInOrg performs requests for "teams/add-or-update-repo-permissions-in-org"

Add or update team repository permissions.

  PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
func TeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateRepoPermissionsInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateRepoPermissionsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsAddOrUpdateRepoPermissionsInOrgReq)
	}
	resp := &TeamsAddOrUpdateRepoPermissionsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateRepoPermissionsInOrg performs requests for "teams/add-or-update-repo-permissions-in-org"

Add or update team repository permissions.

  PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
func (c Client) TeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateRepoPermissionsInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateRepoPermissionsInOrgResponse, error) {
	return TeamsAddOrUpdateRepoPermissionsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateRepoPermissionsInOrgReq is request data for Client.TeamsAddOrUpdateRepoPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type TeamsAddOrUpdateRepoPermissionsInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	Owner       string
	Repo        string
	RequestBody TeamsAddOrUpdateRepoPermissionsInOrgReqBody
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) url() string {
	return r._url
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo)
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) method() string {
	return "PUT"
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateRepoPermissionsInOrgReq) Rel(link RelName, resp *TeamsAddOrUpdateRepoPermissionsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateRepoPermissionsInOrgReqBody is a request body for teams/add-or-update-repo-permissions-in-org

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type TeamsAddOrUpdateRepoPermissionsInOrgReqBody struct {

	/*
	   The permission to grant the team on this repository. Can be one of:
	   \* `pull` - team members can pull, but not push to or administer this
	   repository.
	   \* `push` - team members can pull and push, but not administer this repository.
	   \* `admin` - team members can pull, push and administer this repository.
	   \* `maintain` - team members can manage the repository without access to
	   sensitive or destructive actions. Recommended for project managers. Only applies
	   to repositories owned by organizations.
	   \* `triage` - team members can proactively manage issues and pull requests
	   without write access. Recommended for contributors who triage a repository. Only
	   applies to repositories owned by organizations.

	   If no permission is specified, the team's `permission` attribute will be used to
	   determine what permission to grant the team on this repository.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
TeamsAddOrUpdateRepoPermissionsInOrgResponse is a response for TeamsAddOrUpdateRepoPermissionsInOrg

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions
*/
type TeamsAddOrUpdateRepoPermissionsInOrgResponse struct {
	response
	request *TeamsAddOrUpdateRepoPermissionsInOrgReq
}

/*
TeamsAddOrUpdateRepoPermissionsLegacy performs requests for "teams/add-or-update-repo-permissions-legacy"

Add or update team repository permissions (Legacy).

  PUT /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
func TeamsAddOrUpdateRepoPermissionsLegacy(ctx context.Context, req *TeamsAddOrUpdateRepoPermissionsLegacyReq, opt ...RequestOption) (*TeamsAddOrUpdateRepoPermissionsLegacyResponse, error) {
	if req == nil {
		req = new(TeamsAddOrUpdateRepoPermissionsLegacyReq)
	}
	resp := &TeamsAddOrUpdateRepoPermissionsLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateRepoPermissionsLegacy performs requests for "teams/add-or-update-repo-permissions-legacy"

Add or update team repository permissions (Legacy).

  PUT /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
func (c Client) TeamsAddOrUpdateRepoPermissionsLegacy(ctx context.Context, req *TeamsAddOrUpdateRepoPermissionsLegacyReq, opt ...RequestOption) (*TeamsAddOrUpdateRepoPermissionsLegacyResponse, error) {
	return TeamsAddOrUpdateRepoPermissionsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsAddOrUpdateRepoPermissionsLegacyReq is request data for Client.TeamsAddOrUpdateRepoPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
type TeamsAddOrUpdateRepoPermissionsLegacyReq struct {
	_url        string
	TeamId      int64
	Owner       string
	Repo        string
	RequestBody TeamsAddOrUpdateRepoPermissionsLegacyReqBody
}

func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) url() string {
	return r._url
}

func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/repos/%v/%v", r.TeamId, r.Owner, r.Repo)
}

func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) method() string {
	return "PUT"
}

func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateRepoPermissionsLegacyReq) Rel(link RelName, resp *TeamsAddOrUpdateRepoPermissionsLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateRepoPermissionsLegacyReqBody is a request body for teams/add-or-update-repo-permissions-legacy

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
type TeamsAddOrUpdateRepoPermissionsLegacyReqBody struct {

	/*
	   The permission to grant the team on this repository. Can be one of:
	   \* `pull` - team members can pull, but not push to or administer this
	   repository.
	   \* `push` - team members can pull and push, but not administer this repository.
	   \* `admin` - team members can pull, push and administer this repository.

	   If no permission is specified, the team's `permission` attribute will be used to
	   determine what permission to grant the team on this repository.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
TeamsAddOrUpdateRepoPermissionsLegacyResponse is a response for TeamsAddOrUpdateRepoPermissionsLegacy

https://developer.github.com/v3/teams/#add-or-update-team-repository-permissions-legacy
*/
type TeamsAddOrUpdateRepoPermissionsLegacyResponse struct {
	response
	request *TeamsAddOrUpdateRepoPermissionsLegacyReq
}

/*
TeamsCheckPermissionsForProjectInOrg performs requests for "teams/check-permissions-for-project-in-org"

Check team permissions for a project.

  GET /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
func TeamsCheckPermissionsForProjectInOrg(ctx context.Context, req *TeamsCheckPermissionsForProjectInOrgReq, opt ...RequestOption) (*TeamsCheckPermissionsForProjectInOrgResponse, error) {
	if req == nil {
		req = new(TeamsCheckPermissionsForProjectInOrgReq)
	}
	resp := &TeamsCheckPermissionsForProjectInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCheckPermissionsForProjectInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCheckPermissionsForProjectInOrg performs requests for "teams/check-permissions-for-project-in-org"

Check team permissions for a project.

  GET /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
func (c Client) TeamsCheckPermissionsForProjectInOrg(ctx context.Context, req *TeamsCheckPermissionsForProjectInOrgReq, opt ...RequestOption) (*TeamsCheckPermissionsForProjectInOrgResponse, error) {
	return TeamsCheckPermissionsForProjectInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCheckPermissionsForProjectInOrgReq is request data for Client.TeamsCheckPermissionsForProjectInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
type TeamsCheckPermissionsForProjectInOrgReq struct {
	_url      string
	Org       string
	TeamSlug  string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) url() string {
	return r._url
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId)
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) method() string {
	return "GET"
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsCheckPermissionsForProjectInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCheckPermissionsForProjectInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCheckPermissionsForProjectInOrgReq) Rel(link RelName, resp *TeamsCheckPermissionsForProjectInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCheckPermissionsForProjectInOrgResponseBody is a response body for TeamsCheckPermissionsForProjectInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
type TeamsCheckPermissionsForProjectInOrgResponseBody struct {
	components.TeamProject
}

/*
TeamsCheckPermissionsForProjectInOrgResponse is a response for TeamsCheckPermissionsForProjectInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project
*/
type TeamsCheckPermissionsForProjectInOrgResponse struct {
	response
	request *TeamsCheckPermissionsForProjectInOrgReq
	Data    *TeamsCheckPermissionsForProjectInOrgResponseBody
}

/*
TeamsCheckPermissionsForProjectLegacy performs requests for "teams/check-permissions-for-project-legacy"

Check team permissions for a project (Legacy).

  GET /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
func TeamsCheckPermissionsForProjectLegacy(ctx context.Context, req *TeamsCheckPermissionsForProjectLegacyReq, opt ...RequestOption) (*TeamsCheckPermissionsForProjectLegacyResponse, error) {
	if req == nil {
		req = new(TeamsCheckPermissionsForProjectLegacyReq)
	}
	resp := &TeamsCheckPermissionsForProjectLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCheckPermissionsForProjectLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCheckPermissionsForProjectLegacy performs requests for "teams/check-permissions-for-project-legacy"

Check team permissions for a project (Legacy).

  GET /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
func (c Client) TeamsCheckPermissionsForProjectLegacy(ctx context.Context, req *TeamsCheckPermissionsForProjectLegacyReq, opt ...RequestOption) (*TeamsCheckPermissionsForProjectLegacyResponse, error) {
	return TeamsCheckPermissionsForProjectLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsCheckPermissionsForProjectLegacyReq is request data for Client.TeamsCheckPermissionsForProjectLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
type TeamsCheckPermissionsForProjectLegacyReq struct {
	_url      string
	TeamId    int64
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *TeamsCheckPermissionsForProjectLegacyReq) url() string {
	return r._url
}

func (r *TeamsCheckPermissionsForProjectLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/projects/%v", r.TeamId, r.ProjectId)
}

func (r *TeamsCheckPermissionsForProjectLegacyReq) method() string {
	return "GET"
}

func (r *TeamsCheckPermissionsForProjectLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCheckPermissionsForProjectLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCheckPermissionsForProjectLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsCheckPermissionsForProjectLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsCheckPermissionsForProjectLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsCheckPermissionsForProjectLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCheckPermissionsForProjectLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCheckPermissionsForProjectLegacyReq) Rel(link RelName, resp *TeamsCheckPermissionsForProjectLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCheckPermissionsForProjectLegacyResponseBody is a response body for TeamsCheckPermissionsForProjectLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
type TeamsCheckPermissionsForProjectLegacyResponseBody struct {
	components.TeamProject
}

/*
TeamsCheckPermissionsForProjectLegacyResponse is a response for TeamsCheckPermissionsForProjectLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-project-legacy
*/
type TeamsCheckPermissionsForProjectLegacyResponse struct {
	response
	request *TeamsCheckPermissionsForProjectLegacyReq
	Data    *TeamsCheckPermissionsForProjectLegacyResponseBody
}

/*
TeamsCheckPermissionsForRepoInOrg performs requests for "teams/check-permissions-for-repo-in-org"

Check team permissions for a repository.

  GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
func TeamsCheckPermissionsForRepoInOrg(ctx context.Context, req *TeamsCheckPermissionsForRepoInOrgReq, opt ...RequestOption) (*TeamsCheckPermissionsForRepoInOrgResponse, error) {
	if req == nil {
		req = new(TeamsCheckPermissionsForRepoInOrgReq)
	}
	resp := &TeamsCheckPermissionsForRepoInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCheckPermissionsForRepoInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCheckPermissionsForRepoInOrg performs requests for "teams/check-permissions-for-repo-in-org"

Check team permissions for a repository.

  GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
func (c Client) TeamsCheckPermissionsForRepoInOrg(ctx context.Context, req *TeamsCheckPermissionsForRepoInOrgReq, opt ...RequestOption) (*TeamsCheckPermissionsForRepoInOrgResponse, error) {
	return TeamsCheckPermissionsForRepoInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCheckPermissionsForRepoInOrgReq is request data for Client.TeamsCheckPermissionsForRepoInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
type TeamsCheckPermissionsForRepoInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
	Owner    string
	Repo     string
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) url() string {
	return r._url
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo)
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) method() string {
	return "GET"
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) validStatuses() []int {
	return []int{200, 204}
}

func (r *TeamsCheckPermissionsForRepoInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCheckPermissionsForRepoInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCheckPermissionsForRepoInOrgReq) Rel(link RelName, resp *TeamsCheckPermissionsForRepoInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCheckPermissionsForRepoInOrgResponseBody is a response body for TeamsCheckPermissionsForRepoInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
type TeamsCheckPermissionsForRepoInOrgResponseBody struct {
	components.TeamRepository
}

/*
TeamsCheckPermissionsForRepoInOrgResponse is a response for TeamsCheckPermissionsForRepoInOrg

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository
*/
type TeamsCheckPermissionsForRepoInOrgResponse struct {
	response
	request *TeamsCheckPermissionsForRepoInOrgReq
	Data    *TeamsCheckPermissionsForRepoInOrgResponseBody
}

/*
TeamsCheckPermissionsForRepoLegacy performs requests for "teams/check-permissions-for-repo-legacy"

Check team permissions for a repository (Legacy).

  GET /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
func TeamsCheckPermissionsForRepoLegacy(ctx context.Context, req *TeamsCheckPermissionsForRepoLegacyReq, opt ...RequestOption) (*TeamsCheckPermissionsForRepoLegacyResponse, error) {
	if req == nil {
		req = new(TeamsCheckPermissionsForRepoLegacyReq)
	}
	resp := &TeamsCheckPermissionsForRepoLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCheckPermissionsForRepoLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCheckPermissionsForRepoLegacy performs requests for "teams/check-permissions-for-repo-legacy"

Check team permissions for a repository (Legacy).

  GET /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
func (c Client) TeamsCheckPermissionsForRepoLegacy(ctx context.Context, req *TeamsCheckPermissionsForRepoLegacyReq, opt ...RequestOption) (*TeamsCheckPermissionsForRepoLegacyResponse, error) {
	return TeamsCheckPermissionsForRepoLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsCheckPermissionsForRepoLegacyReq is request data for Client.TeamsCheckPermissionsForRepoLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
type TeamsCheckPermissionsForRepoLegacyReq struct {
	_url   string
	TeamId int64
	Owner  string
	Repo   string
}

func (r *TeamsCheckPermissionsForRepoLegacyReq) url() string {
	return r._url
}

func (r *TeamsCheckPermissionsForRepoLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/repos/%v/%v", r.TeamId, r.Owner, r.Repo)
}

func (r *TeamsCheckPermissionsForRepoLegacyReq) method() string {
	return "GET"
}

func (r *TeamsCheckPermissionsForRepoLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCheckPermissionsForRepoLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCheckPermissionsForRepoLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsCheckPermissionsForRepoLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsCheckPermissionsForRepoLegacyReq) validStatuses() []int {
	return []int{200, 204}
}

func (r *TeamsCheckPermissionsForRepoLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCheckPermissionsForRepoLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCheckPermissionsForRepoLegacyReq) Rel(link RelName, resp *TeamsCheckPermissionsForRepoLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCheckPermissionsForRepoLegacyResponseBody is a response body for TeamsCheckPermissionsForRepoLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
type TeamsCheckPermissionsForRepoLegacyResponseBody struct {
	components.TeamRepository
}

/*
TeamsCheckPermissionsForRepoLegacyResponse is a response for TeamsCheckPermissionsForRepoLegacy

https://developer.github.com/v3/teams/#check-team-permissions-for-a-repository-legacy
*/
type TeamsCheckPermissionsForRepoLegacyResponse struct {
	response
	request *TeamsCheckPermissionsForRepoLegacyReq
	Data    *TeamsCheckPermissionsForRepoLegacyResponseBody
}

/*
TeamsCreate performs requests for "teams/create"

Create a team.

  POST /orgs/{org}/teams

https://developer.github.com/v3/teams/#create-a-team
*/
func TeamsCreate(ctx context.Context, req *TeamsCreateReq, opt ...RequestOption) (*TeamsCreateResponse, error) {
	if req == nil {
		req = new(TeamsCreateReq)
	}
	resp := &TeamsCreateResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreate performs requests for "teams/create"

Create a team.

  POST /orgs/{org}/teams

https://developer.github.com/v3/teams/#create-a-team
*/
func (c Client) TeamsCreate(ctx context.Context, req *TeamsCreateReq, opt ...RequestOption) (*TeamsCreateResponse, error) {
	return TeamsCreate(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateReq is request data for Client.TeamsCreate

https://developer.github.com/v3/teams/#create-a-team
*/
type TeamsCreateReq struct {
	_url        string
	Org         string
	RequestBody TeamsCreateReqBody
}

func (r *TeamsCreateReq) url() string {
	return r._url
}

func (r *TeamsCreateReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams", r.Org)
}

func (r *TeamsCreateReq) method() string {
	return "POST"
}

func (r *TeamsCreateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateReq) Rel(link RelName, resp *TeamsCreateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateReqBody is a request body for teams/create

https://developer.github.com/v3/teams/#create-a-team
*/
type TeamsCreateReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// List GitHub IDs for organization members who will become team maintainers.
	Maintainers []string `json:"maintainers,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	   **Deprecated**. The permission that new repositories will be added to the team
	   with when none is specified. Can be one of:
	   \* `pull` - team members can pull, but not push to or administer newly-added
	   repositories.
	   \* `push` - team members can pull and push, but not administer newly-added
	   repositories.
	   \* `admin` - team members can pull, push and administer newly-added
	   repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	   The level of privacy this team should have. The options are:
	   **For a non-nested team:**
	   \* `secret` - only visible to organization owners and members of this team.
	   \* `closed` - visible to all members of this organization.
	   Default: `secret`
	   **For a parent or child team:**
	   \* `closed` - visible to all members of this organization.
	   Default for child team: `closed`
	*/
	Privacy *string `json:"privacy,omitempty"`

	/*
	   The full name (e.g., "organization-name/repository-name") of repositories to add
	   the team to.
	*/
	RepoNames []string `json:"repo_names,omitempty"`
}

/*
TeamsCreateResponseBody is a response body for TeamsCreate

https://developer.github.com/v3/teams/#create-a-team
*/
type TeamsCreateResponseBody struct {
	components.TeamFull
}

/*
TeamsCreateResponse is a response for TeamsCreate

https://developer.github.com/v3/teams/#create-a-team
*/
type TeamsCreateResponse struct {
	response
	request *TeamsCreateReq
	Data    *TeamsCreateResponseBody
}

/*
TeamsCreateDiscussionCommentInOrg performs requests for "teams/create-discussion-comment-in-org"

Create a discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
func TeamsCreateDiscussionCommentInOrg(ctx context.Context, req *TeamsCreateDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsCreateDiscussionCommentInOrgResponse, error) {
	if req == nil {
		req = new(TeamsCreateDiscussionCommentInOrgReq)
	}
	resp := &TeamsCreateDiscussionCommentInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateDiscussionCommentInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateDiscussionCommentInOrg performs requests for "teams/create-discussion-comment-in-org"

Create a discussion comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
func (c Client) TeamsCreateDiscussionCommentInOrg(ctx context.Context, req *TeamsCreateDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsCreateDiscussionCommentInOrgResponse, error) {
	return TeamsCreateDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateDiscussionCommentInOrgReq is request data for Client.TeamsCreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type TeamsCreateDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      TeamsCreateDiscussionCommentInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsCreateDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *TeamsCreateDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsCreateDiscussionCommentInOrgReq) method() string {
	return "POST"
}

func (r *TeamsCreateDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateDiscussionCommentInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsCreateDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateDiscussionCommentInOrgReqBody is a request body for teams/create-discussion-comment-in-org

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type TeamsCreateDiscussionCommentInOrgReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
TeamsCreateDiscussionCommentInOrgResponseBody is a response body for TeamsCreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type TeamsCreateDiscussionCommentInOrgResponseBody struct {
	components.TeamDiscussionComment
}

/*
TeamsCreateDiscussionCommentInOrgResponse is a response for TeamsCreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment
*/
type TeamsCreateDiscussionCommentInOrgResponse struct {
	response
	request *TeamsCreateDiscussionCommentInOrgReq
	Data    *TeamsCreateDiscussionCommentInOrgResponseBody
}

/*
TeamsCreateDiscussionCommentLegacy performs requests for "teams/create-discussion-comment-legacy"

Create a discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
func TeamsCreateDiscussionCommentLegacy(ctx context.Context, req *TeamsCreateDiscussionCommentLegacyReq, opt ...RequestOption) (*TeamsCreateDiscussionCommentLegacyResponse, error) {
	if req == nil {
		req = new(TeamsCreateDiscussionCommentLegacyReq)
	}
	resp := &TeamsCreateDiscussionCommentLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateDiscussionCommentLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateDiscussionCommentLegacy performs requests for "teams/create-discussion-comment-legacy"

Create a discussion comment (Legacy).

  POST /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
func (c Client) TeamsCreateDiscussionCommentLegacy(ctx context.Context, req *TeamsCreateDiscussionCommentLegacyReq, opt ...RequestOption) (*TeamsCreateDiscussionCommentLegacyResponse, error) {
	return TeamsCreateDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateDiscussionCommentLegacyReq is request data for Client.TeamsCreateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
type TeamsCreateDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	RequestBody      TeamsCreateDiscussionCommentLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsCreateDiscussionCommentLegacyReq) url() string {
	return r._url
}

func (r *TeamsCreateDiscussionCommentLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions/%v/comments", r.TeamId, r.DiscussionNumber)
}

func (r *TeamsCreateDiscussionCommentLegacyReq) method() string {
	return "POST"
}

func (r *TeamsCreateDiscussionCommentLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateDiscussionCommentLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateDiscussionCommentLegacyReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateDiscussionCommentLegacyReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionCommentLegacyReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionCommentLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateDiscussionCommentLegacyReq) Rel(link RelName, resp *TeamsCreateDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateDiscussionCommentLegacyReqBody is a request body for teams/create-discussion-comment-legacy

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
type TeamsCreateDiscussionCommentLegacyReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
TeamsCreateDiscussionCommentLegacyResponseBody is a response body for TeamsCreateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
type TeamsCreateDiscussionCommentLegacyResponseBody struct {
	components.TeamDiscussionComment
}

/*
TeamsCreateDiscussionCommentLegacyResponse is a response for TeamsCreateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#create-a-discussion-comment-legacy
*/
type TeamsCreateDiscussionCommentLegacyResponse struct {
	response
	request *TeamsCreateDiscussionCommentLegacyReq
	Data    *TeamsCreateDiscussionCommentLegacyResponseBody
}

/*
TeamsCreateDiscussionInOrg performs requests for "teams/create-discussion-in-org"

Create a discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
func TeamsCreateDiscussionInOrg(ctx context.Context, req *TeamsCreateDiscussionInOrgReq, opt ...RequestOption) (*TeamsCreateDiscussionInOrgResponse, error) {
	if req == nil {
		req = new(TeamsCreateDiscussionInOrgReq)
	}
	resp := &TeamsCreateDiscussionInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateDiscussionInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateDiscussionInOrg performs requests for "teams/create-discussion-in-org"

Create a discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
func (c Client) TeamsCreateDiscussionInOrg(ctx context.Context, req *TeamsCreateDiscussionInOrgReq, opt ...RequestOption) (*TeamsCreateDiscussionInOrgResponse, error) {
	return TeamsCreateDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateDiscussionInOrgReq is request data for Client.TeamsCreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	RequestBody TeamsCreateDiscussionInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsCreateDiscussionInOrgReq) url() string {
	return r._url
}

func (r *TeamsCreateDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions", r.Org, r.TeamSlug)
}

func (r *TeamsCreateDiscussionInOrgReq) method() string {
	return "POST"
}

func (r *TeamsCreateDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateDiscussionInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateDiscussionInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionInOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateDiscussionInOrgReq) Rel(link RelName, resp *TeamsCreateDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateDiscussionInOrgReqBody is a request body for teams/create-discussion-in-org

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body"`

	/*
	   Private posts are only visible to team members, organization owners, and team
	   maintainers. Public posts are visible to all members of the organization. Set to
	   `true` to create a private post.
	*/
	Private *bool `json:"private,omitempty"`

	// The discussion post's title.
	Title *string `json:"title"`
}

/*
TeamsCreateDiscussionInOrgResponseBody is a response body for TeamsCreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgResponseBody struct {
	components.TeamDiscussion
}

/*
TeamsCreateDiscussionInOrgResponse is a response for TeamsCreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgResponse struct {
	response
	request *TeamsCreateDiscussionInOrgReq
	Data    *TeamsCreateDiscussionInOrgResponseBody
}

/*
TeamsCreateDiscussionLegacy performs requests for "teams/create-discussion-legacy"

Create a discussion (Legacy).

  POST /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
func TeamsCreateDiscussionLegacy(ctx context.Context, req *TeamsCreateDiscussionLegacyReq, opt ...RequestOption) (*TeamsCreateDiscussionLegacyResponse, error) {
	if req == nil {
		req = new(TeamsCreateDiscussionLegacyReq)
	}
	resp := &TeamsCreateDiscussionLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateDiscussionLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateDiscussionLegacy performs requests for "teams/create-discussion-legacy"

Create a discussion (Legacy).

  POST /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
func (c Client) TeamsCreateDiscussionLegacy(ctx context.Context, req *TeamsCreateDiscussionLegacyReq, opt ...RequestOption) (*TeamsCreateDiscussionLegacyResponse, error) {
	return TeamsCreateDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateDiscussionLegacyReq is request data for Client.TeamsCreateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
type TeamsCreateDiscussionLegacyReq struct {
	_url        string
	TeamId      int64
	RequestBody TeamsCreateDiscussionLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsCreateDiscussionLegacyReq) url() string {
	return r._url
}

func (r *TeamsCreateDiscussionLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions", r.TeamId)
}

func (r *TeamsCreateDiscussionLegacyReq) method() string {
	return "POST"
}

func (r *TeamsCreateDiscussionLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateDiscussionLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateDiscussionLegacyReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateDiscussionLegacyReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionLegacyReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateDiscussionLegacyReq) Rel(link RelName, resp *TeamsCreateDiscussionLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateDiscussionLegacyReqBody is a request body for teams/create-discussion-legacy

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
type TeamsCreateDiscussionLegacyReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body"`

	/*
	   Private posts are only visible to team members, organization owners, and team
	   maintainers. Public posts are visible to all members of the organization. Set to
	   `true` to create a private post.
	*/
	Private *bool `json:"private,omitempty"`

	// The discussion post's title.
	Title *string `json:"title"`
}

/*
TeamsCreateDiscussionLegacyResponseBody is a response body for TeamsCreateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
type TeamsCreateDiscussionLegacyResponseBody struct {
	components.TeamDiscussion
}

/*
TeamsCreateDiscussionLegacyResponse is a response for TeamsCreateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy
*/
type TeamsCreateDiscussionLegacyResponse struct {
	response
	request *TeamsCreateDiscussionLegacyReq
	Data    *TeamsCreateDiscussionLegacyResponseBody
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrg performs requests for "teams/create-or-update-id-p-group-connections-in-org"

Create or update IdP group connections.

  PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
func TeamsCreateOrUpdateIdPGroupConnectionsInOrg(ctx context.Context, req *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq, opt ...RequestOption) (*TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq)
	}
	resp := &TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrg performs requests for "teams/create-or-update-id-p-group-connections-in-org"

Create or update IdP group connections.

  PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
func (c Client) TeamsCreateOrUpdateIdPGroupConnectionsInOrg(ctx context.Context, req *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq, opt ...RequestOption) (*TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse, error) {
	return TeamsCreateOrUpdateIdPGroupConnectionsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq is request data for Client.TeamsCreateOrUpdateIdPGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	RequestBody TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBody
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) url() string {
	return r._url
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/team-sync/group-mappings", r.Org, r.TeamSlug)
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) method() string {
	return "PATCH"
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) Rel(link RelName, resp *TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBodyGroups is a value for TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBody's Groups field
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBodyGroups struct {

	// Description of the IdP group.
	GroupDescription *string `json:"group_description"`

	// ID of the IdP group.
	GroupId *string `json:"group_id"`

	// Name of the IdP group.
	GroupName *string `json:"group_name"`
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBody is a request body for teams/create-or-update-id-p-group-connections-in-org

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBody struct {

	/*
	   The IdP groups you want to connect to a GitHub team. When updating, the new
	   `groups` object will replace the original one. You must include any existing
	   groups that you don't want to remove.
	*/
	Groups []TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBodyGroups `json:"groups"`
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponseBody is a response body for TeamsCreateOrUpdateIdPGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponseBody struct {
	components.GroupMapping
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse is a response for TeamsCreateOrUpdateIdPGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse struct {
	response
	request *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq
	Data    *TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponseBody
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsLegacy performs requests for "teams/create-or-update-id-p-group-connections-legacy"

Create or update IdP group connections (Legacy).

  PATCH /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
func TeamsCreateOrUpdateIdPGroupConnectionsLegacy(ctx context.Context, req *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq, opt ...RequestOption) (*TeamsCreateOrUpdateIdPGroupConnectionsLegacyResponse, error) {
	if req == nil {
		req = new(TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq)
	}
	resp := &TeamsCreateOrUpdateIdPGroupConnectionsLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateOrUpdateIdPGroupConnectionsLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsLegacy performs requests for "teams/create-or-update-id-p-group-connections-legacy"

Create or update IdP group connections (Legacy).

  PATCH /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
func (c Client) TeamsCreateOrUpdateIdPGroupConnectionsLegacy(ctx context.Context, req *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq, opt ...RequestOption) (*TeamsCreateOrUpdateIdPGroupConnectionsLegacyResponse, error) {
	return TeamsCreateOrUpdateIdPGroupConnectionsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq is request data for Client.TeamsCreateOrUpdateIdPGroupConnectionsLegacy

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
type TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq struct {
	_url        string
	TeamId      int64
	RequestBody TeamsCreateOrUpdateIdPGroupConnectionsLegacyReqBody
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq) url() string {
	return r._url
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/team-sync/group-mappings", r.TeamId)
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq) method() string {
	return "PATCH"
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq) Rel(link RelName, resp *TeamsCreateOrUpdateIdPGroupConnectionsLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// TeamsCreateOrUpdateIdPGroupConnectionsLegacyReqBodyGroups is a value for TeamsCreateOrUpdateIdPGroupConnectionsLegacyReqBody's Groups field
type TeamsCreateOrUpdateIdPGroupConnectionsLegacyReqBodyGroups struct {

	// Description of the IdP group.
	GroupDescription *string `json:"group_description"`

	// ID of the IdP group.
	GroupId *string `json:"group_id"`

	// Name of the IdP group.
	GroupName *string `json:"group_name"`
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsLegacyReqBody is a request body for teams/create-or-update-id-p-group-connections-legacy

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
type TeamsCreateOrUpdateIdPGroupConnectionsLegacyReqBody struct {

	/*
	   The IdP groups you want to connect to a GitHub team. When updating, the new
	   `groups` object will replace the original one. You must include any existing
	   groups that you don't want to remove.
	*/
	Groups []TeamsCreateOrUpdateIdPGroupConnectionsLegacyReqBodyGroups `json:"groups"`
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsLegacyResponseBody is a response body for TeamsCreateOrUpdateIdPGroupConnectionsLegacy

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
type TeamsCreateOrUpdateIdPGroupConnectionsLegacyResponseBody struct {
	components.GroupMapping2
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsLegacyResponse is a response for TeamsCreateOrUpdateIdPGroupConnectionsLegacy

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections-legacy
*/
type TeamsCreateOrUpdateIdPGroupConnectionsLegacyResponse struct {
	response
	request *TeamsCreateOrUpdateIdPGroupConnectionsLegacyReq
	Data    *TeamsCreateOrUpdateIdPGroupConnectionsLegacyResponseBody
}

/*
TeamsDeleteDiscussionCommentInOrg performs requests for "teams/delete-discussion-comment-in-org"

Delete a discussion comment.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
func TeamsDeleteDiscussionCommentInOrg(ctx context.Context, req *TeamsDeleteDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsDeleteDiscussionCommentInOrgResponse, error) {
	if req == nil {
		req = new(TeamsDeleteDiscussionCommentInOrgReq)
	}
	resp := &TeamsDeleteDiscussionCommentInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteDiscussionCommentInOrg performs requests for "teams/delete-discussion-comment-in-org"

Delete a discussion comment.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
func (c Client) TeamsDeleteDiscussionCommentInOrg(ctx context.Context, req *TeamsDeleteDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsDeleteDiscussionCommentInOrgResponse, error) {
	return TeamsDeleteDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteDiscussionCommentInOrgReq is request data for Client.TeamsDeleteDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
type TeamsDeleteDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber)
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsDeleteDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteDiscussionCommentInOrgResponse is a response for TeamsDeleteDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment
*/
type TeamsDeleteDiscussionCommentInOrgResponse struct {
	response
	request *TeamsDeleteDiscussionCommentInOrgReq
}

/*
TeamsDeleteDiscussionCommentLegacy performs requests for "teams/delete-discussion-comment-legacy"

Delete a discussion comment (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
func TeamsDeleteDiscussionCommentLegacy(ctx context.Context, req *TeamsDeleteDiscussionCommentLegacyReq, opt ...RequestOption) (*TeamsDeleteDiscussionCommentLegacyResponse, error) {
	if req == nil {
		req = new(TeamsDeleteDiscussionCommentLegacyReq)
	}
	resp := &TeamsDeleteDiscussionCommentLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteDiscussionCommentLegacy performs requests for "teams/delete-discussion-comment-legacy"

Delete a discussion comment (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
func (c Client) TeamsDeleteDiscussionCommentLegacy(ctx context.Context, req *TeamsDeleteDiscussionCommentLegacyReq, opt ...RequestOption) (*TeamsDeleteDiscussionCommentLegacyResponse, error) {
	return TeamsDeleteDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteDiscussionCommentLegacyReq is request data for Client.TeamsDeleteDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
type TeamsDeleteDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64
}

func (r *TeamsDeleteDiscussionCommentLegacyReq) url() string {
	return r._url
}

func (r *TeamsDeleteDiscussionCommentLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions/%v/comments/%v", r.TeamId, r.DiscussionNumber, r.CommentNumber)
}

func (r *TeamsDeleteDiscussionCommentLegacyReq) method() string {
	return "DELETE"
}

func (r *TeamsDeleteDiscussionCommentLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsDeleteDiscussionCommentLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsDeleteDiscussionCommentLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsDeleteDiscussionCommentLegacyReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsDeleteDiscussionCommentLegacyReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsDeleteDiscussionCommentLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteDiscussionCommentLegacyReq) Rel(link RelName, resp *TeamsDeleteDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteDiscussionCommentLegacyResponse is a response for TeamsDeleteDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#delete-a-discussion-comment-legacy
*/
type TeamsDeleteDiscussionCommentLegacyResponse struct {
	response
	request *TeamsDeleteDiscussionCommentLegacyReq
}

/*
TeamsDeleteDiscussionInOrg performs requests for "teams/delete-discussion-in-org"

Delete a discussion.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
func TeamsDeleteDiscussionInOrg(ctx context.Context, req *TeamsDeleteDiscussionInOrgReq, opt ...RequestOption) (*TeamsDeleteDiscussionInOrgResponse, error) {
	if req == nil {
		req = new(TeamsDeleteDiscussionInOrgReq)
	}
	resp := &TeamsDeleteDiscussionInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteDiscussionInOrg performs requests for "teams/delete-discussion-in-org"

Delete a discussion.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
func (c Client) TeamsDeleteDiscussionInOrg(ctx context.Context, req *TeamsDeleteDiscussionInOrgReq, opt ...RequestOption) (*TeamsDeleteDiscussionInOrgResponse, error) {
	return TeamsDeleteDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteDiscussionInOrgReq is request data for Client.TeamsDeleteDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
type TeamsDeleteDiscussionInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
}

func (r *TeamsDeleteDiscussionInOrgReq) url() string {
	return r._url
}

func (r *TeamsDeleteDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsDeleteDiscussionInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsDeleteDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsDeleteDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsDeleteDiscussionInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsDeleteDiscussionInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsDeleteDiscussionInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsDeleteDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteDiscussionInOrgReq) Rel(link RelName, resp *TeamsDeleteDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteDiscussionInOrgResponse is a response for TeamsDeleteDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
type TeamsDeleteDiscussionInOrgResponse struct {
	response
	request *TeamsDeleteDiscussionInOrgReq
}

/*
TeamsDeleteDiscussionLegacy performs requests for "teams/delete-discussion-legacy"

Delete a discussion (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
func TeamsDeleteDiscussionLegacy(ctx context.Context, req *TeamsDeleteDiscussionLegacyReq, opt ...RequestOption) (*TeamsDeleteDiscussionLegacyResponse, error) {
	if req == nil {
		req = new(TeamsDeleteDiscussionLegacyReq)
	}
	resp := &TeamsDeleteDiscussionLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteDiscussionLegacy performs requests for "teams/delete-discussion-legacy"

Delete a discussion (Legacy).

  DELETE /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
func (c Client) TeamsDeleteDiscussionLegacy(ctx context.Context, req *TeamsDeleteDiscussionLegacyReq, opt ...RequestOption) (*TeamsDeleteDiscussionLegacyResponse, error) {
	return TeamsDeleteDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteDiscussionLegacyReq is request data for Client.TeamsDeleteDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
type TeamsDeleteDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
}

func (r *TeamsDeleteDiscussionLegacyReq) url() string {
	return r._url
}

func (r *TeamsDeleteDiscussionLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions/%v", r.TeamId, r.DiscussionNumber)
}

func (r *TeamsDeleteDiscussionLegacyReq) method() string {
	return "DELETE"
}

func (r *TeamsDeleteDiscussionLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsDeleteDiscussionLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsDeleteDiscussionLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsDeleteDiscussionLegacyReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsDeleteDiscussionLegacyReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsDeleteDiscussionLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteDiscussionLegacyReq) Rel(link RelName, resp *TeamsDeleteDiscussionLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteDiscussionLegacyResponse is a response for TeamsDeleteDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy
*/
type TeamsDeleteDiscussionLegacyResponse struct {
	response
	request *TeamsDeleteDiscussionLegacyReq
}

/*
TeamsDeleteInOrg performs requests for "teams/delete-in-org"

Delete a team.

  DELETE /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#delete-a-team
*/
func TeamsDeleteInOrg(ctx context.Context, req *TeamsDeleteInOrgReq, opt ...RequestOption) (*TeamsDeleteInOrgResponse, error) {
	if req == nil {
		req = new(TeamsDeleteInOrgReq)
	}
	resp := &TeamsDeleteInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteInOrg performs requests for "teams/delete-in-org"

Delete a team.

  DELETE /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#delete-a-team
*/
func (c Client) TeamsDeleteInOrg(ctx context.Context, req *TeamsDeleteInOrgReq, opt ...RequestOption) (*TeamsDeleteInOrgResponse, error) {
	return TeamsDeleteInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteInOrgReq is request data for Client.TeamsDeleteInOrg

https://developer.github.com/v3/teams/#delete-a-team
*/
type TeamsDeleteInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
}

func (r *TeamsDeleteInOrgReq) url() string {
	return r._url
}

func (r *TeamsDeleteInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug)
}

func (r *TeamsDeleteInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsDeleteInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsDeleteInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsDeleteInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsDeleteInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsDeleteInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsDeleteInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteInOrgReq) Rel(link RelName, resp *TeamsDeleteInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteInOrgResponse is a response for TeamsDeleteInOrg

https://developer.github.com/v3/teams/#delete-a-team
*/
type TeamsDeleteInOrgResponse struct {
	response
	request *TeamsDeleteInOrgReq
}

/*
TeamsDeleteLegacy performs requests for "teams/delete-legacy"

Delete a team (Legacy).

  DELETE /teams/{team_id}

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
func TeamsDeleteLegacy(ctx context.Context, req *TeamsDeleteLegacyReq, opt ...RequestOption) (*TeamsDeleteLegacyResponse, error) {
	if req == nil {
		req = new(TeamsDeleteLegacyReq)
	}
	resp := &TeamsDeleteLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteLegacy performs requests for "teams/delete-legacy"

Delete a team (Legacy).

  DELETE /teams/{team_id}

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
func (c Client) TeamsDeleteLegacy(ctx context.Context, req *TeamsDeleteLegacyReq, opt ...RequestOption) (*TeamsDeleteLegacyResponse, error) {
	return TeamsDeleteLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsDeleteLegacyReq is request data for Client.TeamsDeleteLegacy

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
type TeamsDeleteLegacyReq struct {
	_url   string
	TeamId int64
}

func (r *TeamsDeleteLegacyReq) url() string {
	return r._url
}

func (r *TeamsDeleteLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v", r.TeamId)
}

func (r *TeamsDeleteLegacyReq) method() string {
	return "DELETE"
}

func (r *TeamsDeleteLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsDeleteLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsDeleteLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsDeleteLegacyReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsDeleteLegacyReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsDeleteLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsDeleteLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteLegacyReq) Rel(link RelName, resp *TeamsDeleteLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteLegacyResponse is a response for TeamsDeleteLegacy

https://developer.github.com/v3/teams/#delete-a-team-legacy
*/
type TeamsDeleteLegacyResponse struct {
	response
	request *TeamsDeleteLegacyReq
}

/*
TeamsGetByName performs requests for "teams/get-by-name"

Get a team by name.

  GET /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
func TeamsGetByName(ctx context.Context, req *TeamsGetByNameReq, opt ...RequestOption) (*TeamsGetByNameResponse, error) {
	if req == nil {
		req = new(TeamsGetByNameReq)
	}
	resp := &TeamsGetByNameResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetByNameResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetByName performs requests for "teams/get-by-name"

Get a team by name.

  GET /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
func (c Client) TeamsGetByName(ctx context.Context, req *TeamsGetByNameReq, opt ...RequestOption) (*TeamsGetByNameResponse, error) {
	return TeamsGetByName(ctx, req, append(c, opt...)...)
}

/*
TeamsGetByNameReq is request data for Client.TeamsGetByName

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
type TeamsGetByNameReq struct {
	_url     string
	Org      string
	TeamSlug string
}

func (r *TeamsGetByNameReq) url() string {
	return r._url
}

func (r *TeamsGetByNameReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug)
}

func (r *TeamsGetByNameReq) method() string {
	return "GET"
}

func (r *TeamsGetByNameReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetByNameReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetByNameReq) body() interface{} {
	return nil
}

func (r *TeamsGetByNameReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetByNameReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetByNameReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetByNameReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetByNameReq) Rel(link RelName, resp *TeamsGetByNameResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetByNameResponseBody is a response body for TeamsGetByName

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
type TeamsGetByNameResponseBody struct {
	components.TeamFull
}

/*
TeamsGetByNameResponse is a response for TeamsGetByName

https://developer.github.com/v3/teams/#get-a-team-by-name
*/
type TeamsGetByNameResponse struct {
	response
	request *TeamsGetByNameReq
	Data    *TeamsGetByNameResponseBody
}

/*
TeamsGetDiscussionCommentInOrg performs requests for "teams/get-discussion-comment-in-org"

Get a discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
func TeamsGetDiscussionCommentInOrg(ctx context.Context, req *TeamsGetDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsGetDiscussionCommentInOrgResponse, error) {
	if req == nil {
		req = new(TeamsGetDiscussionCommentInOrgReq)
	}
	resp := &TeamsGetDiscussionCommentInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetDiscussionCommentInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetDiscussionCommentInOrg performs requests for "teams/get-discussion-comment-in-org"

Get a discussion comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
func (c Client) TeamsGetDiscussionCommentInOrg(ctx context.Context, req *TeamsGetDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsGetDiscussionCommentInOrgResponse, error) {
	return TeamsGetDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsGetDiscussionCommentInOrgReq is request data for Client.TeamsGetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
type TeamsGetDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsGetDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *TeamsGetDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber)
}

func (r *TeamsGetDiscussionCommentInOrgReq) method() string {
	return "GET"
}

func (r *TeamsGetDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetDiscussionCommentInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsGetDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsGetDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetDiscussionCommentInOrgResponseBody is a response body for TeamsGetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
type TeamsGetDiscussionCommentInOrgResponseBody struct {
	components.TeamDiscussionComment
}

/*
TeamsGetDiscussionCommentInOrgResponse is a response for TeamsGetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment
*/
type TeamsGetDiscussionCommentInOrgResponse struct {
	response
	request *TeamsGetDiscussionCommentInOrgReq
	Data    *TeamsGetDiscussionCommentInOrgResponseBody
}

/*
TeamsGetDiscussionCommentLegacy performs requests for "teams/get-discussion-comment-legacy"

Get a discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
func TeamsGetDiscussionCommentLegacy(ctx context.Context, req *TeamsGetDiscussionCommentLegacyReq, opt ...RequestOption) (*TeamsGetDiscussionCommentLegacyResponse, error) {
	if req == nil {
		req = new(TeamsGetDiscussionCommentLegacyReq)
	}
	resp := &TeamsGetDiscussionCommentLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetDiscussionCommentLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetDiscussionCommentLegacy performs requests for "teams/get-discussion-comment-legacy"

Get a discussion comment (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
func (c Client) TeamsGetDiscussionCommentLegacy(ctx context.Context, req *TeamsGetDiscussionCommentLegacyReq, opt ...RequestOption) (*TeamsGetDiscussionCommentLegacyResponse, error) {
	return TeamsGetDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsGetDiscussionCommentLegacyReq is request data for Client.TeamsGetDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
type TeamsGetDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsGetDiscussionCommentLegacyReq) url() string {
	return r._url
}

func (r *TeamsGetDiscussionCommentLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions/%v/comments/%v", r.TeamId, r.DiscussionNumber, r.CommentNumber)
}

func (r *TeamsGetDiscussionCommentLegacyReq) method() string {
	return "GET"
}

func (r *TeamsGetDiscussionCommentLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetDiscussionCommentLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetDiscussionCommentLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsGetDiscussionCommentLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionCommentLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionCommentLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetDiscussionCommentLegacyReq) Rel(link RelName, resp *TeamsGetDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetDiscussionCommentLegacyResponseBody is a response body for TeamsGetDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
type TeamsGetDiscussionCommentLegacyResponseBody struct {
	components.TeamDiscussionComment
}

/*
TeamsGetDiscussionCommentLegacyResponse is a response for TeamsGetDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#get-a-discussion-comment-legacy
*/
type TeamsGetDiscussionCommentLegacyResponse struct {
	response
	request *TeamsGetDiscussionCommentLegacyReq
	Data    *TeamsGetDiscussionCommentLegacyResponseBody
}

/*
TeamsGetDiscussionInOrg performs requests for "teams/get-discussion-in-org"

Get a discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
func TeamsGetDiscussionInOrg(ctx context.Context, req *TeamsGetDiscussionInOrgReq, opt ...RequestOption) (*TeamsGetDiscussionInOrgResponse, error) {
	if req == nil {
		req = new(TeamsGetDiscussionInOrgReq)
	}
	resp := &TeamsGetDiscussionInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetDiscussionInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetDiscussionInOrg performs requests for "teams/get-discussion-in-org"

Get a discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
func (c Client) TeamsGetDiscussionInOrg(ctx context.Context, req *TeamsGetDiscussionInOrgReq, opt ...RequestOption) (*TeamsGetDiscussionInOrgResponse, error) {
	return TeamsGetDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsGetDiscussionInOrgReq is request data for Client.TeamsGetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
type TeamsGetDiscussionInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsGetDiscussionInOrgReq) url() string {
	return r._url
}

func (r *TeamsGetDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsGetDiscussionInOrgReq) method() string {
	return "GET"
}

func (r *TeamsGetDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetDiscussionInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsGetDiscussionInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetDiscussionInOrgReq) Rel(link RelName, resp *TeamsGetDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetDiscussionInOrgResponseBody is a response body for TeamsGetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
type TeamsGetDiscussionInOrgResponseBody struct {
	components.TeamDiscussion
}

/*
TeamsGetDiscussionInOrgResponse is a response for TeamsGetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-discussion
*/
type TeamsGetDiscussionInOrgResponse struct {
	response
	request *TeamsGetDiscussionInOrgReq
	Data    *TeamsGetDiscussionInOrgResponseBody
}

/*
TeamsGetDiscussionLegacy performs requests for "teams/get-discussion-legacy"

Get a discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
func TeamsGetDiscussionLegacy(ctx context.Context, req *TeamsGetDiscussionLegacyReq, opt ...RequestOption) (*TeamsGetDiscussionLegacyResponse, error) {
	if req == nil {
		req = new(TeamsGetDiscussionLegacyReq)
	}
	resp := &TeamsGetDiscussionLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetDiscussionLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetDiscussionLegacy performs requests for "teams/get-discussion-legacy"

Get a discussion (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
func (c Client) TeamsGetDiscussionLegacy(ctx context.Context, req *TeamsGetDiscussionLegacyReq, opt ...RequestOption) (*TeamsGetDiscussionLegacyResponse, error) {
	return TeamsGetDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsGetDiscussionLegacyReq is request data for Client.TeamsGetDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
type TeamsGetDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsGetDiscussionLegacyReq) url() string {
	return r._url
}

func (r *TeamsGetDiscussionLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions/%v", r.TeamId, r.DiscussionNumber)
}

func (r *TeamsGetDiscussionLegacyReq) method() string {
	return "GET"
}

func (r *TeamsGetDiscussionLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetDiscussionLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetDiscussionLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsGetDiscussionLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetDiscussionLegacyReq) Rel(link RelName, resp *TeamsGetDiscussionLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetDiscussionLegacyResponseBody is a response body for TeamsGetDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
type TeamsGetDiscussionLegacyResponseBody struct {
	components.TeamDiscussion
}

/*
TeamsGetDiscussionLegacyResponse is a response for TeamsGetDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#get-a-discussion-legacy
*/
type TeamsGetDiscussionLegacyResponse struct {
	response
	request *TeamsGetDiscussionLegacyReq
	Data    *TeamsGetDiscussionLegacyResponseBody
}

/*
TeamsGetLegacy performs requests for "teams/get-legacy"

Get a team (Legacy).

  GET /teams/{team_id}

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
func TeamsGetLegacy(ctx context.Context, req *TeamsGetLegacyReq, opt ...RequestOption) (*TeamsGetLegacyResponse, error) {
	if req == nil {
		req = new(TeamsGetLegacyReq)
	}
	resp := &TeamsGetLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetLegacy performs requests for "teams/get-legacy"

Get a team (Legacy).

  GET /teams/{team_id}

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
func (c Client) TeamsGetLegacy(ctx context.Context, req *TeamsGetLegacyReq, opt ...RequestOption) (*TeamsGetLegacyResponse, error) {
	return TeamsGetLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsGetLegacyReq is request data for Client.TeamsGetLegacy

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
type TeamsGetLegacyReq struct {
	_url   string
	TeamId int64
}

func (r *TeamsGetLegacyReq) url() string {
	return r._url
}

func (r *TeamsGetLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v", r.TeamId)
}

func (r *TeamsGetLegacyReq) method() string {
	return "GET"
}

func (r *TeamsGetLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsGetLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetLegacyReq) Rel(link RelName, resp *TeamsGetLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetLegacyResponseBody is a response body for TeamsGetLegacy

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
type TeamsGetLegacyResponseBody struct {
	components.TeamFull
}

/*
TeamsGetLegacyResponse is a response for TeamsGetLegacy

https://developer.github.com/v3/teams/#get-a-team-legacy
*/
type TeamsGetLegacyResponse struct {
	response
	request *TeamsGetLegacyReq
	Data    *TeamsGetLegacyResponseBody
}

/*
TeamsGetMemberLegacy performs requests for "teams/get-member-legacy"

Get team member (Legacy).

  GET /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
func TeamsGetMemberLegacy(ctx context.Context, req *TeamsGetMemberLegacyReq, opt ...RequestOption) (*TeamsGetMemberLegacyResponse, error) {
	if req == nil {
		req = new(TeamsGetMemberLegacyReq)
	}
	resp := &TeamsGetMemberLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetMemberLegacy performs requests for "teams/get-member-legacy"

Get team member (Legacy).

  GET /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
func (c Client) TeamsGetMemberLegacy(ctx context.Context, req *TeamsGetMemberLegacyReq, opt ...RequestOption) (*TeamsGetMemberLegacyResponse, error) {
	return TeamsGetMemberLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsGetMemberLegacyReq is request data for Client.TeamsGetMemberLegacy

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
type TeamsGetMemberLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

func (r *TeamsGetMemberLegacyReq) url() string {
	return r._url
}

func (r *TeamsGetMemberLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/members/%v", r.TeamId, r.Username)
}

func (r *TeamsGetMemberLegacyReq) method() string {
	return "GET"
}

func (r *TeamsGetMemberLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetMemberLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetMemberLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsGetMemberLegacyReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsGetMemberLegacyReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsGetMemberLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetMemberLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetMemberLegacyReq) Rel(link RelName, resp *TeamsGetMemberLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetMemberLegacyResponse is a response for TeamsGetMemberLegacy

https://developer.github.com/v3/teams/members/#get-team-member-legacy
*/
type TeamsGetMemberLegacyResponse struct {
	response
	request *TeamsGetMemberLegacyReq
	Data    bool
}

/*
TeamsGetMembershipForUserInOrg performs requests for "teams/get-membership-for-user-in-org"

Get team membership for a user.

  GET /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
func TeamsGetMembershipForUserInOrg(ctx context.Context, req *TeamsGetMembershipForUserInOrgReq, opt ...RequestOption) (*TeamsGetMembershipForUserInOrgResponse, error) {
	if req == nil {
		req = new(TeamsGetMembershipForUserInOrgReq)
	}
	resp := &TeamsGetMembershipForUserInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetMembershipForUserInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetMembershipForUserInOrg performs requests for "teams/get-membership-for-user-in-org"

Get team membership for a user.

  GET /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
func (c Client) TeamsGetMembershipForUserInOrg(ctx context.Context, req *TeamsGetMembershipForUserInOrgReq, opt ...RequestOption) (*TeamsGetMembershipForUserInOrgResponse, error) {
	return TeamsGetMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsGetMembershipForUserInOrgReq is request data for Client.TeamsGetMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
type TeamsGetMembershipForUserInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
	Username string
}

func (r *TeamsGetMembershipForUserInOrgReq) url() string {
	return r._url
}

func (r *TeamsGetMembershipForUserInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username)
}

func (r *TeamsGetMembershipForUserInOrgReq) method() string {
	return "GET"
}

func (r *TeamsGetMembershipForUserInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetMembershipForUserInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetMembershipForUserInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsGetMembershipForUserInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetMembershipForUserInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetMembershipForUserInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetMembershipForUserInOrgReq) Rel(link RelName, resp *TeamsGetMembershipForUserInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetMembershipForUserInOrgResponseBody is a response body for TeamsGetMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
type TeamsGetMembershipForUserInOrgResponseBody struct {
	components.TeamMembership
}

/*
TeamsGetMembershipForUserInOrgResponse is a response for TeamsGetMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user
*/
type TeamsGetMembershipForUserInOrgResponse struct {
	response
	request *TeamsGetMembershipForUserInOrgReq
	Data    *TeamsGetMembershipForUserInOrgResponseBody
}

/*
TeamsGetMembershipForUserLegacy performs requests for "teams/get-membership-for-user-legacy"

Get team membership for a user (Legacy).

  GET /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
func TeamsGetMembershipForUserLegacy(ctx context.Context, req *TeamsGetMembershipForUserLegacyReq, opt ...RequestOption) (*TeamsGetMembershipForUserLegacyResponse, error) {
	if req == nil {
		req = new(TeamsGetMembershipForUserLegacyReq)
	}
	resp := &TeamsGetMembershipForUserLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetMembershipForUserLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetMembershipForUserLegacy performs requests for "teams/get-membership-for-user-legacy"

Get team membership for a user (Legacy).

  GET /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
func (c Client) TeamsGetMembershipForUserLegacy(ctx context.Context, req *TeamsGetMembershipForUserLegacyReq, opt ...RequestOption) (*TeamsGetMembershipForUserLegacyResponse, error) {
	return TeamsGetMembershipForUserLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsGetMembershipForUserLegacyReq is request data for Client.TeamsGetMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
type TeamsGetMembershipForUserLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

func (r *TeamsGetMembershipForUserLegacyReq) url() string {
	return r._url
}

func (r *TeamsGetMembershipForUserLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/memberships/%v", r.TeamId, r.Username)
}

func (r *TeamsGetMembershipForUserLegacyReq) method() string {
	return "GET"
}

func (r *TeamsGetMembershipForUserLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetMembershipForUserLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetMembershipForUserLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsGetMembershipForUserLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetMembershipForUserLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetMembershipForUserLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsGetMembershipForUserLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetMembershipForUserLegacyReq) Rel(link RelName, resp *TeamsGetMembershipForUserLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetMembershipForUserLegacyResponseBody is a response body for TeamsGetMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
type TeamsGetMembershipForUserLegacyResponseBody struct {
	components.TeamMembership
}

/*
TeamsGetMembershipForUserLegacyResponse is a response for TeamsGetMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#get-team-membership-for-a-user-legacy
*/
type TeamsGetMembershipForUserLegacyResponse struct {
	response
	request *TeamsGetMembershipForUserLegacyReq
	Data    *TeamsGetMembershipForUserLegacyResponseBody
}

/*
TeamsList performs requests for "teams/list"

List teams.

  GET /orgs/{org}/teams

https://developer.github.com/v3/teams/#list-teams
*/
func TeamsList(ctx context.Context, req *TeamsListReq, opt ...RequestOption) (*TeamsListResponse, error) {
	if req == nil {
		req = new(TeamsListReq)
	}
	resp := &TeamsListResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsList performs requests for "teams/list"

List teams.

  GET /orgs/{org}/teams

https://developer.github.com/v3/teams/#list-teams
*/
func (c Client) TeamsList(ctx context.Context, req *TeamsListReq, opt ...RequestOption) (*TeamsListResponse, error) {
	return TeamsList(ctx, req, append(c, opt...)...)
}

/*
TeamsListReq is request data for Client.TeamsList

https://developer.github.com/v3/teams/#list-teams
*/
type TeamsListReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListReq) url() string {
	return r._url
}

func (r *TeamsListReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams", r.Org)
}

func (r *TeamsListReq) method() string {
	return "GET"
}

func (r *TeamsListReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListReq) body() interface{} {
	return nil
}

func (r *TeamsListReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListReq) Rel(link RelName, resp *TeamsListResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListResponseBody is a response body for TeamsList

https://developer.github.com/v3/teams/#list-teams
*/
type TeamsListResponseBody []struct {
	components.Team
}

/*
TeamsListResponse is a response for TeamsList

https://developer.github.com/v3/teams/#list-teams
*/
type TeamsListResponse struct {
	response
	request *TeamsListReq
	Data    *TeamsListResponseBody
}

/*
TeamsListChildInOrg performs requests for "teams/list-child-in-org"

List child teams.

  GET /orgs/{org}/teams/{team_slug}/teams

https://developer.github.com/v3/teams/#list-child-teams
*/
func TeamsListChildInOrg(ctx context.Context, req *TeamsListChildInOrgReq, opt ...RequestOption) (*TeamsListChildInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListChildInOrgReq)
	}
	resp := &TeamsListChildInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListChildInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListChildInOrg performs requests for "teams/list-child-in-org"

List child teams.

  GET /orgs/{org}/teams/{team_slug}/teams

https://developer.github.com/v3/teams/#list-child-teams
*/
func (c Client) TeamsListChildInOrg(ctx context.Context, req *TeamsListChildInOrgReq, opt ...RequestOption) (*TeamsListChildInOrgResponse, error) {
	return TeamsListChildInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListChildInOrgReq is request data for Client.TeamsListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type TeamsListChildInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListChildInOrgReq) url() string {
	return r._url
}

func (r *TeamsListChildInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/teams", r.Org, r.TeamSlug)
}

func (r *TeamsListChildInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListChildInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListChildInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListChildInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListChildInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListChildInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListChildInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListChildInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListChildInOrgReq) Rel(link RelName, resp *TeamsListChildInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListChildInOrgResponseBody is a response body for TeamsListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type TeamsListChildInOrgResponseBody []struct {
	components.Team2
}

/*
TeamsListChildInOrgResponse is a response for TeamsListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type TeamsListChildInOrgResponse struct {
	response
	request *TeamsListChildInOrgReq
	Data    *TeamsListChildInOrgResponseBody
}

/*
TeamsListChildLegacy performs requests for "teams/list-child-legacy"

List child teams (Legacy).

  GET /teams/{team_id}/teams

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
func TeamsListChildLegacy(ctx context.Context, req *TeamsListChildLegacyReq, opt ...RequestOption) (*TeamsListChildLegacyResponse, error) {
	if req == nil {
		req = new(TeamsListChildLegacyReq)
	}
	resp := &TeamsListChildLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListChildLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListChildLegacy performs requests for "teams/list-child-legacy"

List child teams (Legacy).

  GET /teams/{team_id}/teams

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
func (c Client) TeamsListChildLegacy(ctx context.Context, req *TeamsListChildLegacyReq, opt ...RequestOption) (*TeamsListChildLegacyResponse, error) {
	return TeamsListChildLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListChildLegacyReq is request data for Client.TeamsListChildLegacy

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
type TeamsListChildLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListChildLegacyReq) url() string {
	return r._url
}

func (r *TeamsListChildLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/teams", r.TeamId)
}

func (r *TeamsListChildLegacyReq) method() string {
	return "GET"
}

func (r *TeamsListChildLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListChildLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListChildLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsListChildLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListChildLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListChildLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListChildLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListChildLegacyReq) Rel(link RelName, resp *TeamsListChildLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListChildLegacyResponseBody is a response body for TeamsListChildLegacy

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
type TeamsListChildLegacyResponseBody []struct {
	components.Team2
}

/*
TeamsListChildLegacyResponse is a response for TeamsListChildLegacy

https://developer.github.com/v3/teams/#list-child-teams-legacy
*/
type TeamsListChildLegacyResponse struct {
	response
	request *TeamsListChildLegacyReq
	Data    *TeamsListChildLegacyResponseBody
}

/*
TeamsListDiscussionCommentsInOrg performs requests for "teams/list-discussion-comments-in-org"

List discussion comments.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
func TeamsListDiscussionCommentsInOrg(ctx context.Context, req *TeamsListDiscussionCommentsInOrgReq, opt ...RequestOption) (*TeamsListDiscussionCommentsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListDiscussionCommentsInOrgReq)
	}
	resp := &TeamsListDiscussionCommentsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListDiscussionCommentsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListDiscussionCommentsInOrg performs requests for "teams/list-discussion-comments-in-org"

List discussion comments.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
func (c Client) TeamsListDiscussionCommentsInOrg(ctx context.Context, req *TeamsListDiscussionCommentsInOrgReq, opt ...RequestOption) (*TeamsListDiscussionCommentsInOrgResponse, error) {
	return TeamsListDiscussionCommentsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListDiscussionCommentsInOrgReq is request data for Client.TeamsListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
type TeamsListDiscussionCommentsInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64

	/*
	Sorts the discussion comments by the date they were created. To return the
	oldest comments first, set to `asc`. Can be one of `asc` or `desc`.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsListDiscussionCommentsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListDiscussionCommentsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsListDiscussionCommentsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListDiscussionCommentsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListDiscussionCommentsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListDiscussionCommentsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListDiscussionCommentsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionCommentsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionCommentsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListDiscussionCommentsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListDiscussionCommentsInOrgReq) Rel(link RelName, resp *TeamsListDiscussionCommentsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListDiscussionCommentsInOrgResponseBody is a response body for TeamsListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
type TeamsListDiscussionCommentsInOrgResponseBody []struct {
	components.TeamDiscussionComment
}

/*
TeamsListDiscussionCommentsInOrgResponse is a response for TeamsListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments
*/
type TeamsListDiscussionCommentsInOrgResponse struct {
	response
	request *TeamsListDiscussionCommentsInOrgReq
	Data    *TeamsListDiscussionCommentsInOrgResponseBody
}

/*
TeamsListDiscussionCommentsLegacy performs requests for "teams/list-discussion-comments-legacy"

List discussion comments (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
func TeamsListDiscussionCommentsLegacy(ctx context.Context, req *TeamsListDiscussionCommentsLegacyReq, opt ...RequestOption) (*TeamsListDiscussionCommentsLegacyResponse, error) {
	if req == nil {
		req = new(TeamsListDiscussionCommentsLegacyReq)
	}
	resp := &TeamsListDiscussionCommentsLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListDiscussionCommentsLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListDiscussionCommentsLegacy performs requests for "teams/list-discussion-comments-legacy"

List discussion comments (Legacy).

  GET /teams/{team_id}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
func (c Client) TeamsListDiscussionCommentsLegacy(ctx context.Context, req *TeamsListDiscussionCommentsLegacyReq, opt ...RequestOption) (*TeamsListDiscussionCommentsLegacyResponse, error) {
	return TeamsListDiscussionCommentsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListDiscussionCommentsLegacyReq is request data for Client.TeamsListDiscussionCommentsLegacy

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
type TeamsListDiscussionCommentsLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64

	/*
	Sorts the discussion comments by the date they were created. To return the
	oldest comments first, set to `asc`. Can be one of `asc` or `desc`.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsListDiscussionCommentsLegacyReq) url() string {
	return r._url
}

func (r *TeamsListDiscussionCommentsLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions/%v/comments", r.TeamId, r.DiscussionNumber)
}

func (r *TeamsListDiscussionCommentsLegacyReq) method() string {
	return "GET"
}

func (r *TeamsListDiscussionCommentsLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListDiscussionCommentsLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListDiscussionCommentsLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsListDiscussionCommentsLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionCommentsLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionCommentsLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListDiscussionCommentsLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListDiscussionCommentsLegacyReq) Rel(link RelName, resp *TeamsListDiscussionCommentsLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListDiscussionCommentsLegacyResponseBody is a response body for TeamsListDiscussionCommentsLegacy

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
type TeamsListDiscussionCommentsLegacyResponseBody []struct {
	components.TeamDiscussionComment
}

/*
TeamsListDiscussionCommentsLegacyResponse is a response for TeamsListDiscussionCommentsLegacy

https://developer.github.com/v3/teams/discussion_comments/#list-discussion-comments-legacy
*/
type TeamsListDiscussionCommentsLegacyResponse struct {
	response
	request *TeamsListDiscussionCommentsLegacyReq
	Data    *TeamsListDiscussionCommentsLegacyResponseBody
}

/*
TeamsListDiscussionsInOrg performs requests for "teams/list-discussions-in-org"

List discussions.

  GET /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
func TeamsListDiscussionsInOrg(ctx context.Context, req *TeamsListDiscussionsInOrgReq, opt ...RequestOption) (*TeamsListDiscussionsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListDiscussionsInOrgReq)
	}
	resp := &TeamsListDiscussionsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListDiscussionsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListDiscussionsInOrg performs requests for "teams/list-discussions-in-org"

List discussions.

  GET /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
func (c Client) TeamsListDiscussionsInOrg(ctx context.Context, req *TeamsListDiscussionsInOrgReq, opt ...RequestOption) (*TeamsListDiscussionsInOrgResponse, error) {
	return TeamsListDiscussionsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListDiscussionsInOrgReq is request data for Client.TeamsListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type TeamsListDiscussionsInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	/*
	Sorts the discussion comments by the date they were created. To return the
	oldest comments first, set to `asc`. Can be one of `asc` or `desc`.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsListDiscussionsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListDiscussionsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions", r.Org, r.TeamSlug)
}

func (r *TeamsListDiscussionsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListDiscussionsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListDiscussionsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListDiscussionsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListDiscussionsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListDiscussionsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListDiscussionsInOrgReq) Rel(link RelName, resp *TeamsListDiscussionsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListDiscussionsInOrgResponseBody is a response body for TeamsListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type TeamsListDiscussionsInOrgResponseBody []struct {
	components.TeamDiscussion
}

/*
TeamsListDiscussionsInOrgResponse is a response for TeamsListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type TeamsListDiscussionsInOrgResponse struct {
	response
	request *TeamsListDiscussionsInOrgReq
	Data    *TeamsListDiscussionsInOrgResponseBody
}

/*
TeamsListDiscussionsLegacy performs requests for "teams/list-discussions-legacy"

List discussions (Legacy).

  GET /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
func TeamsListDiscussionsLegacy(ctx context.Context, req *TeamsListDiscussionsLegacyReq, opt ...RequestOption) (*TeamsListDiscussionsLegacyResponse, error) {
	if req == nil {
		req = new(TeamsListDiscussionsLegacyReq)
	}
	resp := &TeamsListDiscussionsLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListDiscussionsLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListDiscussionsLegacy performs requests for "teams/list-discussions-legacy"

List discussions (Legacy).

  GET /teams/{team_id}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
func (c Client) TeamsListDiscussionsLegacy(ctx context.Context, req *TeamsListDiscussionsLegacyReq, opt ...RequestOption) (*TeamsListDiscussionsLegacyResponse, error) {
	return TeamsListDiscussionsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListDiscussionsLegacyReq is request data for Client.TeamsListDiscussionsLegacy

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
type TeamsListDiscussionsLegacyReq struct {
	_url   string
	TeamId int64

	/*
	Sorts the discussion comments by the date they were created. To return the
	oldest comments first, set to `asc`. Can be one of `asc` or `desc`.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsListDiscussionsLegacyReq) url() string {
	return r._url
}

func (r *TeamsListDiscussionsLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions", r.TeamId)
}

func (r *TeamsListDiscussionsLegacyReq) method() string {
	return "GET"
}

func (r *TeamsListDiscussionsLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListDiscussionsLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListDiscussionsLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsListDiscussionsLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionsLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionsLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListDiscussionsLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListDiscussionsLegacyReq) Rel(link RelName, resp *TeamsListDiscussionsLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListDiscussionsLegacyResponseBody is a response body for TeamsListDiscussionsLegacy

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
type TeamsListDiscussionsLegacyResponseBody []struct {
	components.TeamDiscussion
}

/*
TeamsListDiscussionsLegacyResponse is a response for TeamsListDiscussionsLegacy

https://developer.github.com/v3/teams/discussions/#list-discussions-legacy
*/
type TeamsListDiscussionsLegacyResponse struct {
	response
	request *TeamsListDiscussionsLegacyReq
	Data    *TeamsListDiscussionsLegacyResponseBody
}

/*
TeamsListForAuthenticatedUser performs requests for "teams/list-for-authenticated-user"

List teams for the authenticated user.

  GET /user/teams

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
func TeamsListForAuthenticatedUser(ctx context.Context, req *TeamsListForAuthenticatedUserReq, opt ...RequestOption) (*TeamsListForAuthenticatedUserResponse, error) {
	if req == nil {
		req = new(TeamsListForAuthenticatedUserReq)
	}
	resp := &TeamsListForAuthenticatedUserResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListForAuthenticatedUser performs requests for "teams/list-for-authenticated-user"

List teams for the authenticated user.

  GET /user/teams

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
func (c Client) TeamsListForAuthenticatedUser(ctx context.Context, req *TeamsListForAuthenticatedUserReq, opt ...RequestOption) (*TeamsListForAuthenticatedUserResponse, error) {
	return TeamsListForAuthenticatedUser(ctx, req, append(c, opt...)...)
}

/*
TeamsListForAuthenticatedUserReq is request data for Client.TeamsListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
type TeamsListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *TeamsListForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/teams")
}

func (r *TeamsListForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *TeamsListForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *TeamsListForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListForAuthenticatedUserReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListForAuthenticatedUserReq) Rel(link RelName, resp *TeamsListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListForAuthenticatedUserResponseBody is a response body for TeamsListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
type TeamsListForAuthenticatedUserResponseBody []struct {
	components.TeamFull
}

/*
TeamsListForAuthenticatedUserResponse is a response for TeamsListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-teams-for-the-authenticated-user
*/
type TeamsListForAuthenticatedUserResponse struct {
	response
	request *TeamsListForAuthenticatedUserReq
	Data    *TeamsListForAuthenticatedUserResponseBody
}

/*
TeamsListIdPGroupsForLegacy performs requests for "teams/list-id-p-groups-for-legacy"

List IdP groups for a team (Legacy).

  GET /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
func TeamsListIdPGroupsForLegacy(ctx context.Context, req *TeamsListIdPGroupsForLegacyReq, opt ...RequestOption) (*TeamsListIdPGroupsForLegacyResponse, error) {
	if req == nil {
		req = new(TeamsListIdPGroupsForLegacyReq)
	}
	resp := &TeamsListIdPGroupsForLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListIdPGroupsForLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListIdPGroupsForLegacy performs requests for "teams/list-id-p-groups-for-legacy"

List IdP groups for a team (Legacy).

  GET /teams/{team_id}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
func (c Client) TeamsListIdPGroupsForLegacy(ctx context.Context, req *TeamsListIdPGroupsForLegacyReq, opt ...RequestOption) (*TeamsListIdPGroupsForLegacyResponse, error) {
	return TeamsListIdPGroupsForLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListIdPGroupsForLegacyReq is request data for Client.TeamsListIdPGroupsForLegacy

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
type TeamsListIdPGroupsForLegacyReq struct {
	_url   string
	TeamId int64
}

func (r *TeamsListIdPGroupsForLegacyReq) url() string {
	return r._url
}

func (r *TeamsListIdPGroupsForLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/team-sync/group-mappings", r.TeamId)
}

func (r *TeamsListIdPGroupsForLegacyReq) method() string {
	return "GET"
}

func (r *TeamsListIdPGroupsForLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsListIdPGroupsForLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListIdPGroupsForLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsListIdPGroupsForLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsForLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsForLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListIdPGroupsForLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListIdPGroupsForLegacyReq) Rel(link RelName, resp *TeamsListIdPGroupsForLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListIdPGroupsForLegacyResponseBody is a response body for TeamsListIdPGroupsForLegacy

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
type TeamsListIdPGroupsForLegacyResponseBody struct {
	components.GroupMapping3
}

/*
TeamsListIdPGroupsForLegacyResponse is a response for TeamsListIdPGroupsForLegacy

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team-legacy
*/
type TeamsListIdPGroupsForLegacyResponse struct {
	response
	request *TeamsListIdPGroupsForLegacyReq
	Data    *TeamsListIdPGroupsForLegacyResponseBody
}

/*
TeamsListIdPGroupsForOrg performs requests for "teams/list-id-p-groups-for-org"

List IdP groups for an organization.

  GET /orgs/{org}/team-sync/groups

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
func TeamsListIdPGroupsForOrg(ctx context.Context, req *TeamsListIdPGroupsForOrgReq, opt ...RequestOption) (*TeamsListIdPGroupsForOrgResponse, error) {
	if req == nil {
		req = new(TeamsListIdPGroupsForOrgReq)
	}
	resp := &TeamsListIdPGroupsForOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListIdPGroupsForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListIdPGroupsForOrg performs requests for "teams/list-id-p-groups-for-org"

List IdP groups for an organization.

  GET /orgs/{org}/team-sync/groups

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
func (c Client) TeamsListIdPGroupsForOrg(ctx context.Context, req *TeamsListIdPGroupsForOrgReq, opt ...RequestOption) (*TeamsListIdPGroupsForOrgResponse, error) {
	return TeamsListIdPGroupsForOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListIdPGroupsForOrgReq is request data for Client.TeamsListIdPGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
type TeamsListIdPGroupsForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListIdPGroupsForOrgReq) url() string {
	return r._url
}

func (r *TeamsListIdPGroupsForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/team-sync/groups", r.Org)
}

func (r *TeamsListIdPGroupsForOrgReq) method() string {
	return "GET"
}

func (r *TeamsListIdPGroupsForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListIdPGroupsForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListIdPGroupsForOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListIdPGroupsForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListIdPGroupsForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListIdPGroupsForOrgReq) Rel(link RelName, resp *TeamsListIdPGroupsForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListIdPGroupsForOrgResponseBody is a response body for TeamsListIdPGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
type TeamsListIdPGroupsForOrgResponseBody struct {
	components.GroupMapping3
}

/*
TeamsListIdPGroupsForOrgResponse is a response for TeamsListIdPGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-an-organization
*/
type TeamsListIdPGroupsForOrgResponse struct {
	response
	request *TeamsListIdPGroupsForOrgReq
	Data    *TeamsListIdPGroupsForOrgResponseBody
}

/*
TeamsListIdPGroupsInOrg performs requests for "teams/list-id-p-groups-in-org"

List IdP groups for a team.

  GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
func TeamsListIdPGroupsInOrg(ctx context.Context, req *TeamsListIdPGroupsInOrgReq, opt ...RequestOption) (*TeamsListIdPGroupsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListIdPGroupsInOrgReq)
	}
	resp := &TeamsListIdPGroupsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListIdPGroupsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListIdPGroupsInOrg performs requests for "teams/list-id-p-groups-in-org"

List IdP groups for a team.

  GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
func (c Client) TeamsListIdPGroupsInOrg(ctx context.Context, req *TeamsListIdPGroupsInOrgReq, opt ...RequestOption) (*TeamsListIdPGroupsInOrgResponse, error) {
	return TeamsListIdPGroupsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListIdPGroupsInOrgReq is request data for Client.TeamsListIdPGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type TeamsListIdPGroupsInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
}

func (r *TeamsListIdPGroupsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListIdPGroupsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/team-sync/group-mappings", r.Org, r.TeamSlug)
}

func (r *TeamsListIdPGroupsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListIdPGroupsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsListIdPGroupsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListIdPGroupsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListIdPGroupsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListIdPGroupsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListIdPGroupsInOrgReq) Rel(link RelName, resp *TeamsListIdPGroupsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListIdPGroupsInOrgResponseBody is a response body for TeamsListIdPGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type TeamsListIdPGroupsInOrgResponseBody struct {
	components.GroupMapping3
}

/*
TeamsListIdPGroupsInOrgResponse is a response for TeamsListIdPGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type TeamsListIdPGroupsInOrgResponse struct {
	response
	request *TeamsListIdPGroupsInOrgReq
	Data    *TeamsListIdPGroupsInOrgResponseBody
}

/*
TeamsListMembersInOrg performs requests for "teams/list-members-in-org"

List team members.

  GET /orgs/{org}/teams/{team_slug}/members

https://developer.github.com/v3/teams/members/#list-team-members
*/
func TeamsListMembersInOrg(ctx context.Context, req *TeamsListMembersInOrgReq, opt ...RequestOption) (*TeamsListMembersInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListMembersInOrgReq)
	}
	resp := &TeamsListMembersInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListMembersInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListMembersInOrg performs requests for "teams/list-members-in-org"

List team members.

  GET /orgs/{org}/teams/{team_slug}/members

https://developer.github.com/v3/teams/members/#list-team-members
*/
func (c Client) TeamsListMembersInOrg(ctx context.Context, req *TeamsListMembersInOrgReq, opt ...RequestOption) (*TeamsListMembersInOrgResponse, error) {
	return TeamsListMembersInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListMembersInOrgReq is request data for Client.TeamsListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type TeamsListMembersInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	/*
	Filters members returned by their role in the team. Can be one of:
	\* `member` - normal members of the team.
	\* `maintainer` - team maintainers.
	\* `all` - all members of the team.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListMembersInOrgReq) url() string {
	return r._url
}

func (r *TeamsListMembersInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/members", r.Org, r.TeamSlug)
}

func (r *TeamsListMembersInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListMembersInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListMembersInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListMembersInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListMembersInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListMembersInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListMembersInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListMembersInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListMembersInOrgReq) Rel(link RelName, resp *TeamsListMembersInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListMembersInOrgResponseBody is a response body for TeamsListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type TeamsListMembersInOrgResponseBody []struct {
	components.SimpleUser
}

/*
TeamsListMembersInOrgResponse is a response for TeamsListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type TeamsListMembersInOrgResponse struct {
	response
	request *TeamsListMembersInOrgReq
	Data    *TeamsListMembersInOrgResponseBody
}

/*
TeamsListMembersLegacy performs requests for "teams/list-members-legacy"

List team members (Legacy).

  GET /teams/{team_id}/members

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
func TeamsListMembersLegacy(ctx context.Context, req *TeamsListMembersLegacyReq, opt ...RequestOption) (*TeamsListMembersLegacyResponse, error) {
	if req == nil {
		req = new(TeamsListMembersLegacyReq)
	}
	resp := &TeamsListMembersLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListMembersLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListMembersLegacy performs requests for "teams/list-members-legacy"

List team members (Legacy).

  GET /teams/{team_id}/members

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
func (c Client) TeamsListMembersLegacy(ctx context.Context, req *TeamsListMembersLegacyReq, opt ...RequestOption) (*TeamsListMembersLegacyResponse, error) {
	return TeamsListMembersLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListMembersLegacyReq is request data for Client.TeamsListMembersLegacy

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
type TeamsListMembersLegacyReq struct {
	_url   string
	TeamId int64

	/*
	Filters members returned by their role in the team. Can be one of:
	\* `member` - normal members of the team.
	\* `maintainer` - team maintainers.
	\* `all` - all members of the team.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListMembersLegacyReq) url() string {
	return r._url
}

func (r *TeamsListMembersLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/members", r.TeamId)
}

func (r *TeamsListMembersLegacyReq) method() string {
	return "GET"
}

func (r *TeamsListMembersLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListMembersLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListMembersLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsListMembersLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListMembersLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListMembersLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListMembersLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListMembersLegacyReq) Rel(link RelName, resp *TeamsListMembersLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListMembersLegacyResponseBody is a response body for TeamsListMembersLegacy

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
type TeamsListMembersLegacyResponseBody []struct {
	components.SimpleUser
}

/*
TeamsListMembersLegacyResponse is a response for TeamsListMembersLegacy

https://developer.github.com/v3/teams/members/#list-team-members-legacy
*/
type TeamsListMembersLegacyResponse struct {
	response
	request *TeamsListMembersLegacyReq
	Data    *TeamsListMembersLegacyResponseBody
}

/*
TeamsListPendingInvitationsInOrg performs requests for "teams/list-pending-invitations-in-org"

List pending team invitations.

  GET /orgs/{org}/teams/{team_slug}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
func TeamsListPendingInvitationsInOrg(ctx context.Context, req *TeamsListPendingInvitationsInOrgReq, opt ...RequestOption) (*TeamsListPendingInvitationsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListPendingInvitationsInOrgReq)
	}
	resp := &TeamsListPendingInvitationsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListPendingInvitationsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListPendingInvitationsInOrg performs requests for "teams/list-pending-invitations-in-org"

List pending team invitations.

  GET /orgs/{org}/teams/{team_slug}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
func (c Client) TeamsListPendingInvitationsInOrg(ctx context.Context, req *TeamsListPendingInvitationsInOrgReq, opt ...RequestOption) (*TeamsListPendingInvitationsInOrgResponse, error) {
	return TeamsListPendingInvitationsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListPendingInvitationsInOrgReq is request data for Client.TeamsListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type TeamsListPendingInvitationsInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListPendingInvitationsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListPendingInvitationsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/invitations", r.Org, r.TeamSlug)
}

func (r *TeamsListPendingInvitationsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListPendingInvitationsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListPendingInvitationsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListPendingInvitationsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListPendingInvitationsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListPendingInvitationsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListPendingInvitationsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListPendingInvitationsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListPendingInvitationsInOrgReq) Rel(link RelName, resp *TeamsListPendingInvitationsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListPendingInvitationsInOrgResponseBody is a response body for TeamsListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type TeamsListPendingInvitationsInOrgResponseBody []struct {
	components.OrganizationInvitation
}

/*
TeamsListPendingInvitationsInOrgResponse is a response for TeamsListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type TeamsListPendingInvitationsInOrgResponse struct {
	response
	request *TeamsListPendingInvitationsInOrgReq
	Data    *TeamsListPendingInvitationsInOrgResponseBody
}

/*
TeamsListPendingInvitationsLegacy performs requests for "teams/list-pending-invitations-legacy"

List pending team invitations (Legacy).

  GET /teams/{team_id}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
func TeamsListPendingInvitationsLegacy(ctx context.Context, req *TeamsListPendingInvitationsLegacyReq, opt ...RequestOption) (*TeamsListPendingInvitationsLegacyResponse, error) {
	if req == nil {
		req = new(TeamsListPendingInvitationsLegacyReq)
	}
	resp := &TeamsListPendingInvitationsLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListPendingInvitationsLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListPendingInvitationsLegacy performs requests for "teams/list-pending-invitations-legacy"

List pending team invitations (Legacy).

  GET /teams/{team_id}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
func (c Client) TeamsListPendingInvitationsLegacy(ctx context.Context, req *TeamsListPendingInvitationsLegacyReq, opt ...RequestOption) (*TeamsListPendingInvitationsLegacyResponse, error) {
	return TeamsListPendingInvitationsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListPendingInvitationsLegacyReq is request data for Client.TeamsListPendingInvitationsLegacy

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
type TeamsListPendingInvitationsLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListPendingInvitationsLegacyReq) url() string {
	return r._url
}

func (r *TeamsListPendingInvitationsLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/invitations", r.TeamId)
}

func (r *TeamsListPendingInvitationsLegacyReq) method() string {
	return "GET"
}

func (r *TeamsListPendingInvitationsLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListPendingInvitationsLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListPendingInvitationsLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsListPendingInvitationsLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListPendingInvitationsLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListPendingInvitationsLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListPendingInvitationsLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListPendingInvitationsLegacyReq) Rel(link RelName, resp *TeamsListPendingInvitationsLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListPendingInvitationsLegacyResponseBody is a response body for TeamsListPendingInvitationsLegacy

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
type TeamsListPendingInvitationsLegacyResponseBody []struct {
	components.OrganizationInvitation
}

/*
TeamsListPendingInvitationsLegacyResponse is a response for TeamsListPendingInvitationsLegacy

https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy
*/
type TeamsListPendingInvitationsLegacyResponse struct {
	response
	request *TeamsListPendingInvitationsLegacyReq
	Data    *TeamsListPendingInvitationsLegacyResponseBody
}

/*
TeamsListProjectsInOrg performs requests for "teams/list-projects-in-org"

List team projects.

  GET /orgs/{org}/teams/{team_slug}/projects

https://developer.github.com/v3/teams/#list-team-projects
*/
func TeamsListProjectsInOrg(ctx context.Context, req *TeamsListProjectsInOrgReq, opt ...RequestOption) (*TeamsListProjectsInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListProjectsInOrgReq)
	}
	resp := &TeamsListProjectsInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListProjectsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListProjectsInOrg performs requests for "teams/list-projects-in-org"

List team projects.

  GET /orgs/{org}/teams/{team_slug}/projects

https://developer.github.com/v3/teams/#list-team-projects
*/
func (c Client) TeamsListProjectsInOrg(ctx context.Context, req *TeamsListProjectsInOrgReq, opt ...RequestOption) (*TeamsListProjectsInOrgResponse, error) {
	return TeamsListProjectsInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListProjectsInOrgReq is request data for Client.TeamsListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type TeamsListProjectsInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *TeamsListProjectsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListProjectsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/projects", r.Org, r.TeamSlug)
}

func (r *TeamsListProjectsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListProjectsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListProjectsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListProjectsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListProjectsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListProjectsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListProjectsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListProjectsInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListProjectsInOrgReq) Rel(link RelName, resp *TeamsListProjectsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListProjectsInOrgResponseBody is a response body for TeamsListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type TeamsListProjectsInOrgResponseBody []struct {
	components.TeamProject
}

/*
TeamsListProjectsInOrgResponse is a response for TeamsListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type TeamsListProjectsInOrgResponse struct {
	response
	request *TeamsListProjectsInOrgReq
	Data    *TeamsListProjectsInOrgResponseBody
}

/*
TeamsListProjectsLegacy performs requests for "teams/list-projects-legacy"

List team projects (Legacy).

  GET /teams/{team_id}/projects

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
func TeamsListProjectsLegacy(ctx context.Context, req *TeamsListProjectsLegacyReq, opt ...RequestOption) (*TeamsListProjectsLegacyResponse, error) {
	if req == nil {
		req = new(TeamsListProjectsLegacyReq)
	}
	resp := &TeamsListProjectsLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListProjectsLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListProjectsLegacy performs requests for "teams/list-projects-legacy"

List team projects (Legacy).

  GET /teams/{team_id}/projects

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
func (c Client) TeamsListProjectsLegacy(ctx context.Context, req *TeamsListProjectsLegacyReq, opt ...RequestOption) (*TeamsListProjectsLegacyResponse, error) {
	return TeamsListProjectsLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListProjectsLegacyReq is request data for Client.TeamsListProjectsLegacy

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
type TeamsListProjectsLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *TeamsListProjectsLegacyReq) url() string {
	return r._url
}

func (r *TeamsListProjectsLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/projects", r.TeamId)
}

func (r *TeamsListProjectsLegacyReq) method() string {
	return "GET"
}

func (r *TeamsListProjectsLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListProjectsLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListProjectsLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsListProjectsLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListProjectsLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListProjectsLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListProjectsLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListProjectsLegacyReq) Rel(link RelName, resp *TeamsListProjectsLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListProjectsLegacyResponseBody is a response body for TeamsListProjectsLegacy

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
type TeamsListProjectsLegacyResponseBody []struct {
	components.TeamProject
}

/*
TeamsListProjectsLegacyResponse is a response for TeamsListProjectsLegacy

https://developer.github.com/v3/teams/#list-team-projects-legacy
*/
type TeamsListProjectsLegacyResponse struct {
	response
	request *TeamsListProjectsLegacyReq
	Data    *TeamsListProjectsLegacyResponseBody
}

/*
TeamsListReposInOrg performs requests for "teams/list-repos-in-org"

List team repositories.

  GET /orgs/{org}/teams/{team_slug}/repos

https://developer.github.com/v3/teams/#list-team-repositories
*/
func TeamsListReposInOrg(ctx context.Context, req *TeamsListReposInOrgReq, opt ...RequestOption) (*TeamsListReposInOrgResponse, error) {
	if req == nil {
		req = new(TeamsListReposInOrgReq)
	}
	resp := &TeamsListReposInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListReposInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListReposInOrg performs requests for "teams/list-repos-in-org"

List team repositories.

  GET /orgs/{org}/teams/{team_slug}/repos

https://developer.github.com/v3/teams/#list-team-repositories
*/
func (c Client) TeamsListReposInOrg(ctx context.Context, req *TeamsListReposInOrgReq, opt ...RequestOption) (*TeamsListReposInOrgResponse, error) {
	return TeamsListReposInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsListReposInOrgReq is request data for Client.TeamsListReposInOrg

https://developer.github.com/v3/teams/#list-team-repositories
*/
type TeamsListReposInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListReposInOrgReq) url() string {
	return r._url
}

func (r *TeamsListReposInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/repos", r.Org, r.TeamSlug)
}

func (r *TeamsListReposInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListReposInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListReposInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListReposInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListReposInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListReposInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListReposInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListReposInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListReposInOrgReq) Rel(link RelName, resp *TeamsListReposInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListReposInOrgResponseBody is a response body for TeamsListReposInOrg

https://developer.github.com/v3/teams/#list-team-repositories
*/
type TeamsListReposInOrgResponseBody []struct {
	components.MinimalRepository
}

/*
TeamsListReposInOrgResponse is a response for TeamsListReposInOrg

https://developer.github.com/v3/teams/#list-team-repositories
*/
type TeamsListReposInOrgResponse struct {
	response
	request *TeamsListReposInOrgReq
	Data    *TeamsListReposInOrgResponseBody
}

/*
TeamsListReposLegacy performs requests for "teams/list-repos-legacy"

List team repositories (Legacy).

  GET /teams/{team_id}/repos

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
func TeamsListReposLegacy(ctx context.Context, req *TeamsListReposLegacyReq, opt ...RequestOption) (*TeamsListReposLegacyResponse, error) {
	if req == nil {
		req = new(TeamsListReposLegacyReq)
	}
	resp := &TeamsListReposLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListReposLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListReposLegacy performs requests for "teams/list-repos-legacy"

List team repositories (Legacy).

  GET /teams/{team_id}/repos

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
func (c Client) TeamsListReposLegacy(ctx context.Context, req *TeamsListReposLegacyReq, opt ...RequestOption) (*TeamsListReposLegacyResponse, error) {
	return TeamsListReposLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsListReposLegacyReq is request data for Client.TeamsListReposLegacy

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
type TeamsListReposLegacyReq struct {
	_url   string
	TeamId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListReposLegacyReq) url() string {
	return r._url
}

func (r *TeamsListReposLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/repos", r.TeamId)
}

func (r *TeamsListReposLegacyReq) method() string {
	return "GET"
}

func (r *TeamsListReposLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListReposLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListReposLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsListReposLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListReposLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListReposLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsListReposLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListReposLegacyReq) Rel(link RelName, resp *TeamsListReposLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListReposLegacyResponseBody is a response body for TeamsListReposLegacy

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
type TeamsListReposLegacyResponseBody []struct {
	components.MinimalRepository
}

/*
TeamsListReposLegacyResponse is a response for TeamsListReposLegacy

https://developer.github.com/v3/teams/#list-team-repositories-legacy
*/
type TeamsListReposLegacyResponse struct {
	response
	request *TeamsListReposLegacyReq
	Data    *TeamsListReposLegacyResponseBody
}

/*
TeamsRemoveMemberLegacy performs requests for "teams/remove-member-legacy"

Remove team member (Legacy).

  DELETE /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
func TeamsRemoveMemberLegacy(ctx context.Context, req *TeamsRemoveMemberLegacyReq, opt ...RequestOption) (*TeamsRemoveMemberLegacyResponse, error) {
	if req == nil {
		req = new(TeamsRemoveMemberLegacyReq)
	}
	resp := &TeamsRemoveMemberLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveMemberLegacy performs requests for "teams/remove-member-legacy"

Remove team member (Legacy).

  DELETE /teams/{team_id}/members/{username}

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
func (c Client) TeamsRemoveMemberLegacy(ctx context.Context, req *TeamsRemoveMemberLegacyReq, opt ...RequestOption) (*TeamsRemoveMemberLegacyResponse, error) {
	return TeamsRemoveMemberLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveMemberLegacyReq is request data for Client.TeamsRemoveMemberLegacy

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
type TeamsRemoveMemberLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

func (r *TeamsRemoveMemberLegacyReq) url() string {
	return r._url
}

func (r *TeamsRemoveMemberLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/members/%v", r.TeamId, r.Username)
}

func (r *TeamsRemoveMemberLegacyReq) method() string {
	return "DELETE"
}

func (r *TeamsRemoveMemberLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsRemoveMemberLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsRemoveMemberLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsRemoveMemberLegacyReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsRemoveMemberLegacyReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsRemoveMemberLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveMemberLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveMemberLegacyReq) Rel(link RelName, resp *TeamsRemoveMemberLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveMemberLegacyResponse is a response for TeamsRemoveMemberLegacy

https://developer.github.com/v3/teams/members/#remove-team-member-legacy
*/
type TeamsRemoveMemberLegacyResponse struct {
	response
	request *TeamsRemoveMemberLegacyReq
	Data    bool
}

/*
TeamsRemoveMembershipForUserInOrg performs requests for "teams/remove-membership-for-user-in-org"

Remove team membership for a user.

  DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
func TeamsRemoveMembershipForUserInOrg(ctx context.Context, req *TeamsRemoveMembershipForUserInOrgReq, opt ...RequestOption) (*TeamsRemoveMembershipForUserInOrgResponse, error) {
	if req == nil {
		req = new(TeamsRemoveMembershipForUserInOrgReq)
	}
	resp := &TeamsRemoveMembershipForUserInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveMembershipForUserInOrg performs requests for "teams/remove-membership-for-user-in-org"

Remove team membership for a user.

  DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
func (c Client) TeamsRemoveMembershipForUserInOrg(ctx context.Context, req *TeamsRemoveMembershipForUserInOrgReq, opt ...RequestOption) (*TeamsRemoveMembershipForUserInOrgResponse, error) {
	return TeamsRemoveMembershipForUserInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveMembershipForUserInOrgReq is request data for Client.TeamsRemoveMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
type TeamsRemoveMembershipForUserInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
	Username string
}

func (r *TeamsRemoveMembershipForUserInOrgReq) url() string {
	return r._url
}

func (r *TeamsRemoveMembershipForUserInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username)
}

func (r *TeamsRemoveMembershipForUserInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsRemoveMembershipForUserInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsRemoveMembershipForUserInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsRemoveMembershipForUserInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsRemoveMembershipForUserInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsRemoveMembershipForUserInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsRemoveMembershipForUserInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveMembershipForUserInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveMembershipForUserInOrgReq) Rel(link RelName, resp *TeamsRemoveMembershipForUserInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveMembershipForUserInOrgResponse is a response for TeamsRemoveMembershipForUserInOrg

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user
*/
type TeamsRemoveMembershipForUserInOrgResponse struct {
	response
	request *TeamsRemoveMembershipForUserInOrgReq
}

/*
TeamsRemoveMembershipForUserLegacy performs requests for "teams/remove-membership-for-user-legacy"

Remove team membership for a user (Legacy).

  DELETE /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
func TeamsRemoveMembershipForUserLegacy(ctx context.Context, req *TeamsRemoveMembershipForUserLegacyReq, opt ...RequestOption) (*TeamsRemoveMembershipForUserLegacyResponse, error) {
	if req == nil {
		req = new(TeamsRemoveMembershipForUserLegacyReq)
	}
	resp := &TeamsRemoveMembershipForUserLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveMembershipForUserLegacy performs requests for "teams/remove-membership-for-user-legacy"

Remove team membership for a user (Legacy).

  DELETE /teams/{team_id}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
func (c Client) TeamsRemoveMembershipForUserLegacy(ctx context.Context, req *TeamsRemoveMembershipForUserLegacyReq, opt ...RequestOption) (*TeamsRemoveMembershipForUserLegacyResponse, error) {
	return TeamsRemoveMembershipForUserLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveMembershipForUserLegacyReq is request data for Client.TeamsRemoveMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
type TeamsRemoveMembershipForUserLegacyReq struct {
	_url     string
	TeamId   int64
	Username string
}

func (r *TeamsRemoveMembershipForUserLegacyReq) url() string {
	return r._url
}

func (r *TeamsRemoveMembershipForUserLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/memberships/%v", r.TeamId, r.Username)
}

func (r *TeamsRemoveMembershipForUserLegacyReq) method() string {
	return "DELETE"
}

func (r *TeamsRemoveMembershipForUserLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsRemoveMembershipForUserLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsRemoveMembershipForUserLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsRemoveMembershipForUserLegacyReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsRemoveMembershipForUserLegacyReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsRemoveMembershipForUserLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveMembershipForUserLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveMembershipForUserLegacyReq) Rel(link RelName, resp *TeamsRemoveMembershipForUserLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveMembershipForUserLegacyResponse is a response for TeamsRemoveMembershipForUserLegacy

https://developer.github.com/v3/teams/members/#remove-team-membership-for-a-user-legacy
*/
type TeamsRemoveMembershipForUserLegacyResponse struct {
	response
	request *TeamsRemoveMembershipForUserLegacyReq
}

/*
TeamsRemoveProjectInOrg performs requests for "teams/remove-project-in-org"

Remove a project from a team.

  DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
func TeamsRemoveProjectInOrg(ctx context.Context, req *TeamsRemoveProjectInOrgReq, opt ...RequestOption) (*TeamsRemoveProjectInOrgResponse, error) {
	if req == nil {
		req = new(TeamsRemoveProjectInOrgReq)
	}
	resp := &TeamsRemoveProjectInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveProjectInOrg performs requests for "teams/remove-project-in-org"

Remove a project from a team.

  DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
func (c Client) TeamsRemoveProjectInOrg(ctx context.Context, req *TeamsRemoveProjectInOrgReq, opt ...RequestOption) (*TeamsRemoveProjectInOrgResponse, error) {
	return TeamsRemoveProjectInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveProjectInOrgReq is request data for Client.TeamsRemoveProjectInOrg

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
type TeamsRemoveProjectInOrgReq struct {
	_url      string
	Org       string
	TeamSlug  string
	ProjectId int64
}

func (r *TeamsRemoveProjectInOrgReq) url() string {
	return r._url
}

func (r *TeamsRemoveProjectInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId)
}

func (r *TeamsRemoveProjectInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsRemoveProjectInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsRemoveProjectInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsRemoveProjectInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsRemoveProjectInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsRemoveProjectInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsRemoveProjectInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveProjectInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveProjectInOrgReq) Rel(link RelName, resp *TeamsRemoveProjectInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveProjectInOrgResponse is a response for TeamsRemoveProjectInOrg

https://developer.github.com/v3/teams/#remove-a-project-from-a-team
*/
type TeamsRemoveProjectInOrgResponse struct {
	response
	request *TeamsRemoveProjectInOrgReq
}

/*
TeamsRemoveProjectLegacy performs requests for "teams/remove-project-legacy"

Remove a project from a team (Legacy).

  DELETE /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
func TeamsRemoveProjectLegacy(ctx context.Context, req *TeamsRemoveProjectLegacyReq, opt ...RequestOption) (*TeamsRemoveProjectLegacyResponse, error) {
	if req == nil {
		req = new(TeamsRemoveProjectLegacyReq)
	}
	resp := &TeamsRemoveProjectLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveProjectLegacy performs requests for "teams/remove-project-legacy"

Remove a project from a team (Legacy).

  DELETE /teams/{team_id}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
func (c Client) TeamsRemoveProjectLegacy(ctx context.Context, req *TeamsRemoveProjectLegacyReq, opt ...RequestOption) (*TeamsRemoveProjectLegacyResponse, error) {
	return TeamsRemoveProjectLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveProjectLegacyReq is request data for Client.TeamsRemoveProjectLegacy

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
type TeamsRemoveProjectLegacyReq struct {
	_url      string
	TeamId    int64
	ProjectId int64
}

func (r *TeamsRemoveProjectLegacyReq) url() string {
	return r._url
}

func (r *TeamsRemoveProjectLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/projects/%v", r.TeamId, r.ProjectId)
}

func (r *TeamsRemoveProjectLegacyReq) method() string {
	return "DELETE"
}

func (r *TeamsRemoveProjectLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsRemoveProjectLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsRemoveProjectLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsRemoveProjectLegacyReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsRemoveProjectLegacyReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsRemoveProjectLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveProjectLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveProjectLegacyReq) Rel(link RelName, resp *TeamsRemoveProjectLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveProjectLegacyResponse is a response for TeamsRemoveProjectLegacy

https://developer.github.com/v3/teams/#remove-a-project-from-a-team-legacy
*/
type TeamsRemoveProjectLegacyResponse struct {
	response
	request *TeamsRemoveProjectLegacyReq
}

/*
TeamsRemoveRepoInOrg performs requests for "teams/remove-repo-in-org"

Remove a repository from a team.

  DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
func TeamsRemoveRepoInOrg(ctx context.Context, req *TeamsRemoveRepoInOrgReq, opt ...RequestOption) (*TeamsRemoveRepoInOrgResponse, error) {
	if req == nil {
		req = new(TeamsRemoveRepoInOrgReq)
	}
	resp := &TeamsRemoveRepoInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveRepoInOrg performs requests for "teams/remove-repo-in-org"

Remove a repository from a team.

  DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
func (c Client) TeamsRemoveRepoInOrg(ctx context.Context, req *TeamsRemoveRepoInOrgReq, opt ...RequestOption) (*TeamsRemoveRepoInOrgResponse, error) {
	return TeamsRemoveRepoInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveRepoInOrgReq is request data for Client.TeamsRemoveRepoInOrg

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
type TeamsRemoveRepoInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
	Owner    string
	Repo     string
}

func (r *TeamsRemoveRepoInOrgReq) url() string {
	return r._url
}

func (r *TeamsRemoveRepoInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo)
}

func (r *TeamsRemoveRepoInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsRemoveRepoInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsRemoveRepoInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsRemoveRepoInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsRemoveRepoInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsRemoveRepoInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsRemoveRepoInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveRepoInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveRepoInOrgReq) Rel(link RelName, resp *TeamsRemoveRepoInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveRepoInOrgResponse is a response for TeamsRemoveRepoInOrg

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team
*/
type TeamsRemoveRepoInOrgResponse struct {
	response
	request *TeamsRemoveRepoInOrgReq
}

/*
TeamsRemoveRepoLegacy performs requests for "teams/remove-repo-legacy"

Remove a repository from a team (Legacy).

  DELETE /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
func TeamsRemoveRepoLegacy(ctx context.Context, req *TeamsRemoveRepoLegacyReq, opt ...RequestOption) (*TeamsRemoveRepoLegacyResponse, error) {
	if req == nil {
		req = new(TeamsRemoveRepoLegacyReq)
	}
	resp := &TeamsRemoveRepoLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveRepoLegacy performs requests for "teams/remove-repo-legacy"

Remove a repository from a team (Legacy).

  DELETE /teams/{team_id}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
func (c Client) TeamsRemoveRepoLegacy(ctx context.Context, req *TeamsRemoveRepoLegacyReq, opt ...RequestOption) (*TeamsRemoveRepoLegacyResponse, error) {
	return TeamsRemoveRepoLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsRemoveRepoLegacyReq is request data for Client.TeamsRemoveRepoLegacy

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
type TeamsRemoveRepoLegacyReq struct {
	_url   string
	TeamId int64
	Owner  string
	Repo   string
}

func (r *TeamsRemoveRepoLegacyReq) url() string {
	return r._url
}

func (r *TeamsRemoveRepoLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/repos/%v/%v", r.TeamId, r.Owner, r.Repo)
}

func (r *TeamsRemoveRepoLegacyReq) method() string {
	return "DELETE"
}

func (r *TeamsRemoveRepoLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsRemoveRepoLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsRemoveRepoLegacyReq) body() interface{} {
	return nil
}

func (r *TeamsRemoveRepoLegacyReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsRemoveRepoLegacyReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsRemoveRepoLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// HTTPRequest builds an *http.Request
func (r *TeamsRemoveRepoLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveRepoLegacyReq) Rel(link RelName, resp *TeamsRemoveRepoLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveRepoLegacyResponse is a response for TeamsRemoveRepoLegacy

https://developer.github.com/v3/teams/#remove-a-repository-from-a-team-legacy
*/
type TeamsRemoveRepoLegacyResponse struct {
	response
	request *TeamsRemoveRepoLegacyReq
}

/*
TeamsUpdateDiscussionCommentInOrg performs requests for "teams/update-discussion-comment-in-org"

Update a discussion comment.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
func TeamsUpdateDiscussionCommentInOrg(ctx context.Context, req *TeamsUpdateDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsUpdateDiscussionCommentInOrgResponse, error) {
	if req == nil {
		req = new(TeamsUpdateDiscussionCommentInOrgReq)
	}
	resp := &TeamsUpdateDiscussionCommentInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsUpdateDiscussionCommentInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateDiscussionCommentInOrg performs requests for "teams/update-discussion-comment-in-org"

Update a discussion comment.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
func (c Client) TeamsUpdateDiscussionCommentInOrg(ctx context.Context, req *TeamsUpdateDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsUpdateDiscussionCommentInOrgResponse, error) {
	return TeamsUpdateDiscussionCommentInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateDiscussionCommentInOrgReq is request data for Client.TeamsUpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type TeamsUpdateDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      TeamsUpdateDiscussionCommentInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber)
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) method() string {
	return "PATCH"
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateDiscussionCommentInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsUpdateDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateDiscussionCommentInOrgReqBody is a request body for teams/update-discussion-comment-in-org

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type TeamsUpdateDiscussionCommentInOrgReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
TeamsUpdateDiscussionCommentInOrgResponseBody is a response body for TeamsUpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type TeamsUpdateDiscussionCommentInOrgResponseBody struct {
	components.TeamDiscussionComment
}

/*
TeamsUpdateDiscussionCommentInOrgResponse is a response for TeamsUpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment
*/
type TeamsUpdateDiscussionCommentInOrgResponse struct {
	response
	request *TeamsUpdateDiscussionCommentInOrgReq
	Data    *TeamsUpdateDiscussionCommentInOrgResponseBody
}

/*
TeamsUpdateDiscussionCommentLegacy performs requests for "teams/update-discussion-comment-legacy"

Update a discussion comment (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
func TeamsUpdateDiscussionCommentLegacy(ctx context.Context, req *TeamsUpdateDiscussionCommentLegacyReq, opt ...RequestOption) (*TeamsUpdateDiscussionCommentLegacyResponse, error) {
	if req == nil {
		req = new(TeamsUpdateDiscussionCommentLegacyReq)
	}
	resp := &TeamsUpdateDiscussionCommentLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsUpdateDiscussionCommentLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateDiscussionCommentLegacy performs requests for "teams/update-discussion-comment-legacy"

Update a discussion comment (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
func (c Client) TeamsUpdateDiscussionCommentLegacy(ctx context.Context, req *TeamsUpdateDiscussionCommentLegacyReq, opt ...RequestOption) (*TeamsUpdateDiscussionCommentLegacyResponse, error) {
	return TeamsUpdateDiscussionCommentLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateDiscussionCommentLegacyReq is request data for Client.TeamsUpdateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
type TeamsUpdateDiscussionCommentLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      TeamsUpdateDiscussionCommentLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsUpdateDiscussionCommentLegacyReq) url() string {
	return r._url
}

func (r *TeamsUpdateDiscussionCommentLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions/%v/comments/%v", r.TeamId, r.DiscussionNumber, r.CommentNumber)
}

func (r *TeamsUpdateDiscussionCommentLegacyReq) method() string {
	return "PATCH"
}

func (r *TeamsUpdateDiscussionCommentLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsUpdateDiscussionCommentLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsUpdateDiscussionCommentLegacyReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsUpdateDiscussionCommentLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionCommentLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionCommentLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateDiscussionCommentLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateDiscussionCommentLegacyReq) Rel(link RelName, resp *TeamsUpdateDiscussionCommentLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateDiscussionCommentLegacyReqBody is a request body for teams/update-discussion-comment-legacy

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
type TeamsUpdateDiscussionCommentLegacyReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
TeamsUpdateDiscussionCommentLegacyResponseBody is a response body for TeamsUpdateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
type TeamsUpdateDiscussionCommentLegacyResponseBody struct {
	components.TeamDiscussionComment
}

/*
TeamsUpdateDiscussionCommentLegacyResponse is a response for TeamsUpdateDiscussionCommentLegacy

https://developer.github.com/v3/teams/discussion_comments/#update-a-discussion-comment-legacy
*/
type TeamsUpdateDiscussionCommentLegacyResponse struct {
	response
	request *TeamsUpdateDiscussionCommentLegacyReq
	Data    *TeamsUpdateDiscussionCommentLegacyResponseBody
}

/*
TeamsUpdateDiscussionInOrg performs requests for "teams/update-discussion-in-org"

Update a discussion.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
func TeamsUpdateDiscussionInOrg(ctx context.Context, req *TeamsUpdateDiscussionInOrgReq, opt ...RequestOption) (*TeamsUpdateDiscussionInOrgResponse, error) {
	if req == nil {
		req = new(TeamsUpdateDiscussionInOrgReq)
	}
	resp := &TeamsUpdateDiscussionInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsUpdateDiscussionInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateDiscussionInOrg performs requests for "teams/update-discussion-in-org"

Update a discussion.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
func (c Client) TeamsUpdateDiscussionInOrg(ctx context.Context, req *TeamsUpdateDiscussionInOrgReq, opt ...RequestOption) (*TeamsUpdateDiscussionInOrgResponse, error) {
	return TeamsUpdateDiscussionInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateDiscussionInOrgReq is request data for Client.TeamsUpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type TeamsUpdateDiscussionInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      TeamsUpdateDiscussionInOrgReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsUpdateDiscussionInOrgReq) url() string {
	return r._url
}

func (r *TeamsUpdateDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsUpdateDiscussionInOrgReq) method() string {
	return "PATCH"
}

func (r *TeamsUpdateDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsUpdateDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsUpdateDiscussionInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsUpdateDiscussionInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateDiscussionInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateDiscussionInOrgReq) Rel(link RelName, resp *TeamsUpdateDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateDiscussionInOrgReqBody is a request body for teams/update-discussion-in-org

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type TeamsUpdateDiscussionInOrgReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body,omitempty"`

	// The discussion post's title.
	Title *string `json:"title,omitempty"`
}

/*
TeamsUpdateDiscussionInOrgResponseBody is a response body for TeamsUpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type TeamsUpdateDiscussionInOrgResponseBody struct {
	components.TeamDiscussion
}

/*
TeamsUpdateDiscussionInOrgResponse is a response for TeamsUpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#update-a-discussion
*/
type TeamsUpdateDiscussionInOrgResponse struct {
	response
	request *TeamsUpdateDiscussionInOrgReq
	Data    *TeamsUpdateDiscussionInOrgResponseBody
}

/*
TeamsUpdateDiscussionLegacy performs requests for "teams/update-discussion-legacy"

Update a discussion (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
func TeamsUpdateDiscussionLegacy(ctx context.Context, req *TeamsUpdateDiscussionLegacyReq, opt ...RequestOption) (*TeamsUpdateDiscussionLegacyResponse, error) {
	if req == nil {
		req = new(TeamsUpdateDiscussionLegacyReq)
	}
	resp := &TeamsUpdateDiscussionLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsUpdateDiscussionLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateDiscussionLegacy performs requests for "teams/update-discussion-legacy"

Update a discussion (Legacy).

  PATCH /teams/{team_id}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
func (c Client) TeamsUpdateDiscussionLegacy(ctx context.Context, req *TeamsUpdateDiscussionLegacyReq, opt ...RequestOption) (*TeamsUpdateDiscussionLegacyResponse, error) {
	return TeamsUpdateDiscussionLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateDiscussionLegacyReq is request data for Client.TeamsUpdateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
type TeamsUpdateDiscussionLegacyReq struct {
	_url             string
	TeamId           int64
	DiscussionNumber int64
	RequestBody      TeamsUpdateDiscussionLegacyReqBody

	/*
	An additional `reactions` object in the issue comment payload is currently
	available for developers to preview. During
	the preview period, the APIs may change without advance notice. Please see the
	[blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details.


	To access the API you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsUpdateDiscussionLegacyReq) url() string {
	return r._url
}

func (r *TeamsUpdateDiscussionLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v/discussions/%v", r.TeamId, r.DiscussionNumber)
}

func (r *TeamsUpdateDiscussionLegacyReq) method() string {
	return "PATCH"
}

func (r *TeamsUpdateDiscussionLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsUpdateDiscussionLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsUpdateDiscussionLegacyReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsUpdateDiscussionLegacyReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionLegacyReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateDiscussionLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateDiscussionLegacyReq) Rel(link RelName, resp *TeamsUpdateDiscussionLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateDiscussionLegacyReqBody is a request body for teams/update-discussion-legacy

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
type TeamsUpdateDiscussionLegacyReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body,omitempty"`

	// The discussion post's title.
	Title *string `json:"title,omitempty"`
}

/*
TeamsUpdateDiscussionLegacyResponseBody is a response body for TeamsUpdateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
type TeamsUpdateDiscussionLegacyResponseBody struct {
	components.TeamDiscussion
}

/*
TeamsUpdateDiscussionLegacyResponse is a response for TeamsUpdateDiscussionLegacy

https://developer.github.com/v3/teams/discussions/#update-a-discussion-legacy
*/
type TeamsUpdateDiscussionLegacyResponse struct {
	response
	request *TeamsUpdateDiscussionLegacyReq
	Data    *TeamsUpdateDiscussionLegacyResponseBody
}

/*
TeamsUpdateInOrg performs requests for "teams/update-in-org"

Update a team.

  PATCH /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#update-a-team
*/
func TeamsUpdateInOrg(ctx context.Context, req *TeamsUpdateInOrgReq, opt ...RequestOption) (*TeamsUpdateInOrgResponse, error) {
	if req == nil {
		req = new(TeamsUpdateInOrgReq)
	}
	resp := &TeamsUpdateInOrgResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsUpdateInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateInOrg performs requests for "teams/update-in-org"

Update a team.

  PATCH /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#update-a-team
*/
func (c Client) TeamsUpdateInOrg(ctx context.Context, req *TeamsUpdateInOrgReq, opt ...RequestOption) (*TeamsUpdateInOrgResponse, error) {
	return TeamsUpdateInOrg(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateInOrgReq is request data for Client.TeamsUpdateInOrg

https://developer.github.com/v3/teams/#update-a-team
*/
type TeamsUpdateInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	RequestBody TeamsUpdateInOrgReqBody
}

func (r *TeamsUpdateInOrgReq) url() string {
	return r._url
}

func (r *TeamsUpdateInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug)
}

func (r *TeamsUpdateInOrgReq) method() string {
	return "PATCH"
}

func (r *TeamsUpdateInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsUpdateInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsUpdateInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsUpdateInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsUpdateInOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsUpdateInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateInOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateInOrgReq) Rel(link RelName, resp *TeamsUpdateInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateInOrgReqBody is a request body for teams/update-in-org

https://developer.github.com/v3/teams/#update-a-team
*/
type TeamsUpdateInOrgReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	   **Deprecated**. The permission that new repositories will be added to the team
	   with when none is specified. Can be one of:
	   \* `pull` - team members can pull, but not push to or administer newly-added
	   repositories.
	   \* `push` - team members can pull and push, but not administer newly-added
	   repositories.
	   \* `admin` - team members can pull, push and administer newly-added
	   repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	   The level of privacy this team should have. Editing teams without specifying
	   this parameter leaves `privacy` intact. When a team is nested, the `privacy` for
	   parent teams cannot be `secret`. The options are:
	   **For a non-nested team:**
	   \* `secret` - only visible to organization owners and members of this team.
	   \* `closed` - visible to all members of this organization.
	   **For a parent or child team:**
	   \* `closed` - visible to all members of this organization.
	*/
	Privacy *string `json:"privacy,omitempty"`
}

/*
TeamsUpdateInOrgResponseBody is a response body for TeamsUpdateInOrg

https://developer.github.com/v3/teams/#update-a-team
*/
type TeamsUpdateInOrgResponseBody struct {
	components.TeamFull
}

/*
TeamsUpdateInOrgResponse is a response for TeamsUpdateInOrg

https://developer.github.com/v3/teams/#update-a-team
*/
type TeamsUpdateInOrgResponse struct {
	response
	request *TeamsUpdateInOrgReq
	Data    *TeamsUpdateInOrgResponseBody
}

/*
TeamsUpdateLegacy performs requests for "teams/update-legacy"

Update a team (Legacy).

  PATCH /teams/{team_id}

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
func TeamsUpdateLegacy(ctx context.Context, req *TeamsUpdateLegacyReq, opt ...RequestOption) (*TeamsUpdateLegacyResponse, error) {
	if req == nil {
		req = new(TeamsUpdateLegacyReq)
	}
	resp := &TeamsUpdateLegacyResponse{request: req}
	r, err := doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsUpdateLegacyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateLegacy performs requests for "teams/update-legacy"

Update a team (Legacy).

  PATCH /teams/{team_id}

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
func (c Client) TeamsUpdateLegacy(ctx context.Context, req *TeamsUpdateLegacyReq, opt ...RequestOption) (*TeamsUpdateLegacyResponse, error) {
	return TeamsUpdateLegacy(ctx, req, append(c, opt...)...)
}

/*
TeamsUpdateLegacyReq is request data for Client.TeamsUpdateLegacy

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
type TeamsUpdateLegacyReq struct {
	_url        string
	TeamId      int64
	RequestBody TeamsUpdateLegacyReqBody
}

func (r *TeamsUpdateLegacyReq) url() string {
	return r._url
}

func (r *TeamsUpdateLegacyReq) urlPath() string {
	return fmt.Sprintf("/teams/%v", r.TeamId)
}

func (r *TeamsUpdateLegacyReq) method() string {
	return "PATCH"
}

func (r *TeamsUpdateLegacyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsUpdateLegacyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsUpdateLegacyReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsUpdateLegacyReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsUpdateLegacyReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsUpdateLegacyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// HTTPRequest builds an *http.Request
func (r *TeamsUpdateLegacyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateLegacyReq) Rel(link RelName, resp *TeamsUpdateLegacyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateLegacyReqBody is a request body for teams/update-legacy

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
type TeamsUpdateLegacyReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	   **Deprecated**. The permission that new repositories will be added to the team
	   with when none is specified. Can be one of:
	   \* `pull` - team members can pull, but not push to or administer newly-added
	   repositories.
	   \* `push` - team members can pull and push, but not administer newly-added
	   repositories.
	   \* `admin` - team members can pull, push and administer newly-added
	   repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	   The level of privacy this team should have. Editing teams without specifying
	   this parameter leaves `privacy` intact. The options are:
	   **For a non-nested team:**
	   \* `secret` - only visible to organization owners and members of this team.
	   \* `closed` - visible to all members of this organization.
	   **For a parent or child team:**
	   \* `closed` - visible to all members of this organization.
	*/
	Privacy *string `json:"privacy,omitempty"`
}

/*
TeamsUpdateLegacyResponseBody is a response body for TeamsUpdateLegacy

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
type TeamsUpdateLegacyResponseBody struct {
	components.TeamFull
}

/*
TeamsUpdateLegacyResponse is a response for TeamsUpdateLegacy

https://developer.github.com/v3/teams/#update-a-team-legacy
*/
type TeamsUpdateLegacyResponse struct {
	response
	request *TeamsUpdateLegacyReq
	Data    *TeamsUpdateLegacyResponseBody
}
