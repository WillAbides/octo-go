// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
TeamsAddOrUpdateMembershipInOrg performs requests for "teams/add-or-update-membership-in-org"

Add or update team membership.

  PUT /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#add-or-update-team-membership
*/
func (c *Client) TeamsAddOrUpdateMembershipInOrg(ctx context.Context, req *TeamsAddOrUpdateMembershipInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateMembershipInOrgResponse, error) {
	resp := &TeamsAddOrUpdateMembershipInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsAddOrUpdateMembershipInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateMembershipInOrgReq is request data for Client.TeamsAddOrUpdateMembershipInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership
*/
type TeamsAddOrUpdateMembershipInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	Username    string
	RequestBody TeamsAddOrUpdateMembershipInOrgReqBody
}

func (r *TeamsAddOrUpdateMembershipInOrgReq) url() string {
	return r._url
}

func (r *TeamsAddOrUpdateMembershipInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username)
}

func (r *TeamsAddOrUpdateMembershipInOrgReq) method() string {
	return "PUT"
}

func (r *TeamsAddOrUpdateMembershipInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsAddOrUpdateMembershipInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsAddOrUpdateMembershipInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsAddOrUpdateMembershipInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsAddOrUpdateMembershipInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsAddOrUpdateMembershipInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *TeamsAddOrUpdateMembershipInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateMembershipInOrgReq) Rel(link RelName, resp *TeamsAddOrUpdateMembershipInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateMembershipInOrgReqBody is a request body for teams/add-or-update-membership-in-org

https://developer.github.com/v3/teams/members/#add-or-update-team-membership
*/
type TeamsAddOrUpdateMembershipInOrgReqBody struct {

	/*
	   The role that this user should have in the team. Can be one of:
	   \* `member` - a normal member of the team.
	   \* `maintainer` - a team maintainer. Able to add/remove other team members,
	   promote other team members to team maintainer, and edit the team's name and
	   description.
	*/
	Role *string `json:"role,omitempty"`
}

/*
TeamsAddOrUpdateMembershipInOrgResponseBody is a response body for TeamsAddOrUpdateMembershipInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership
*/
type TeamsAddOrUpdateMembershipInOrgResponseBody struct {
	components.TeamMembership
}

/*
TeamsAddOrUpdateMembershipInOrgResponse is a response for TeamsAddOrUpdateMembershipInOrg

https://developer.github.com/v3/teams/members/#add-or-update-team-membership
*/
type TeamsAddOrUpdateMembershipInOrgResponse struct {
	response
	request *TeamsAddOrUpdateMembershipInOrgReq
	Data    *TeamsAddOrUpdateMembershipInOrgResponseBody
}

/*
TeamsAddOrUpdateProjectInOrg performs requests for "teams/add-or-update-project-in-org"

Add or update team project.

  PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#add-or-update-team-project
*/
func (c *Client) TeamsAddOrUpdateProjectInOrg(ctx context.Context, req *TeamsAddOrUpdateProjectInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateProjectInOrgResponse, error) {
	resp := &TeamsAddOrUpdateProjectInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateProjectInOrgReq is request data for Client.TeamsAddOrUpdateProjectInOrg

https://developer.github.com/v3/teams/#add-or-update-team-project
*/
type TeamsAddOrUpdateProjectInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	ProjectId   int64
	RequestBody TeamsAddOrUpdateProjectInOrgReqBody

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *TeamsAddOrUpdateProjectInOrgReq) url() string {
	return r._url
}

func (r *TeamsAddOrUpdateProjectInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId)
}

func (r *TeamsAddOrUpdateProjectInOrgReq) method() string {
	return "PUT"
}

func (r *TeamsAddOrUpdateProjectInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsAddOrUpdateProjectInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsAddOrUpdateProjectInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsAddOrUpdateProjectInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsAddOrUpdateProjectInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsAddOrUpdateProjectInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *TeamsAddOrUpdateProjectInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateProjectInOrgReq) Rel(link RelName, resp *TeamsAddOrUpdateProjectInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateProjectInOrgReqBody is a request body for teams/add-or-update-project-in-org

https://developer.github.com/v3/teams/#add-or-update-team-project
*/
type TeamsAddOrUpdateProjectInOrgReqBody struct {

	/*
	   The permission to grant to the team for this project. Can be one of:
	   \* `read` - team members can read, but not write to or administer this project.
	   \* `write` - team members can read and write, but not administer this project.
	   \* `admin` - team members can read, write and administer this project.
	   Default: the team's `permission` attribute will be used to determine what
	   permission to grant the team on this project. Note that, if you choose not to
	   pass any parameters, you'll need to set `Content-Length` to zero when calling
	   out to this endpoint. For more information, see "[HTTP
	   verbs](https://developer.github.com/v3/#http-verbs)."
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
TeamsAddOrUpdateProjectInOrgResponse is a response for TeamsAddOrUpdateProjectInOrg

https://developer.github.com/v3/teams/#add-or-update-team-project
*/
type TeamsAddOrUpdateProjectInOrgResponse struct {
	response
	request *TeamsAddOrUpdateProjectInOrgReq
}

/*
TeamsAddOrUpdateRepoInOrg performs requests for "teams/add-or-update-repo-in-org"

Add or update team repository.

  PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#add-or-update-team-repository
*/
func (c *Client) TeamsAddOrUpdateRepoInOrg(ctx context.Context, req *TeamsAddOrUpdateRepoInOrgReq, opt ...RequestOption) (*TeamsAddOrUpdateRepoInOrgResponse, error) {
	resp := &TeamsAddOrUpdateRepoInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsAddOrUpdateRepoInOrgReq is request data for Client.TeamsAddOrUpdateRepoInOrg

https://developer.github.com/v3/teams/#add-or-update-team-repository
*/
type TeamsAddOrUpdateRepoInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	Owner       string
	Repo        string
	RequestBody TeamsAddOrUpdateRepoInOrgReqBody
}

func (r *TeamsAddOrUpdateRepoInOrgReq) url() string {
	return r._url
}

func (r *TeamsAddOrUpdateRepoInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo)
}

func (r *TeamsAddOrUpdateRepoInOrgReq) method() string {
	return "PUT"
}

func (r *TeamsAddOrUpdateRepoInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsAddOrUpdateRepoInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsAddOrUpdateRepoInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsAddOrUpdateRepoInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsAddOrUpdateRepoInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsAddOrUpdateRepoInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *TeamsAddOrUpdateRepoInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsAddOrUpdateRepoInOrgReq) Rel(link RelName, resp *TeamsAddOrUpdateRepoInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsAddOrUpdateRepoInOrgReqBody is a request body for teams/add-or-update-repo-in-org

https://developer.github.com/v3/teams/#add-or-update-team-repository
*/
type TeamsAddOrUpdateRepoInOrgReqBody struct {

	/*
	   The permission to grant the team on this repository. Can be one of:
	   \* `pull` - team members can pull, but not push to or administer this
	   repository.
	   \* `push` - team members can pull and push, but not administer this repository.
	   \* `admin` - team members can pull, push and administer this repository.
	   \* `maintain` - team members can manage the repository without access to
	   sensitive or destructive actions. Recommended for project managers. Only applies
	   to repositories owned by organizations.
	   \* `triage` - team members can proactively manage issues and pull requests
	   without write access. Recommended for contributors who triage a repository. Only
	   applies to repositories owned by organizations.

	   If no permission is specified, the team's `permission` attribute will be used to
	   determine what permission to grant the team on this repository.
	*/
	Permission *string `json:"permission,omitempty"`
}

/*
TeamsAddOrUpdateRepoInOrgResponse is a response for TeamsAddOrUpdateRepoInOrg

https://developer.github.com/v3/teams/#add-or-update-team-repository
*/
type TeamsAddOrUpdateRepoInOrgResponse struct {
	response
	request *TeamsAddOrUpdateRepoInOrgReq
}

/*
TeamsCheckManagesRepoInOrg performs requests for "teams/check-manages-repo-in-org"

Check if a team manages a repository.

  GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#check-if-a-team-manages-a-repository
*/
func (c *Client) TeamsCheckManagesRepoInOrg(ctx context.Context, req *TeamsCheckManagesRepoInOrgReq, opt ...RequestOption) (*TeamsCheckManagesRepoInOrgResponse, error) {
	resp := &TeamsCheckManagesRepoInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.setBoolResult(&resp.Data)
	if err != nil {
		return nil, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCheckManagesRepoInOrgReq is request data for Client.TeamsCheckManagesRepoInOrg

https://developer.github.com/v3/teams/#check-if-a-team-manages-a-repository
*/
type TeamsCheckManagesRepoInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
	Owner    string
	Repo     string
}

func (r *TeamsCheckManagesRepoInOrgReq) url() string {
	return r._url
}

func (r *TeamsCheckManagesRepoInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo)
}

func (r *TeamsCheckManagesRepoInOrgReq) method() string {
	return "GET"
}

func (r *TeamsCheckManagesRepoInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCheckManagesRepoInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCheckManagesRepoInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsCheckManagesRepoInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsCheckManagesRepoInOrgReq) validStatuses() []int {
	return []int{200, 204}
}

func (r *TeamsCheckManagesRepoInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrBoolean}
}

// httpRequest creates an http request
func (r *TeamsCheckManagesRepoInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCheckManagesRepoInOrgReq) Rel(link RelName, resp *TeamsCheckManagesRepoInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCheckManagesRepoInOrgResponse is a response for TeamsCheckManagesRepoInOrg

https://developer.github.com/v3/teams/#check-if-a-team-manages-a-repository
*/
type TeamsCheckManagesRepoInOrgResponse struct {
	response
	request *TeamsCheckManagesRepoInOrgReq
	Data    bool
}

/*
TeamsCreate performs requests for "teams/create"

Create team.

  POST /orgs/{org}/teams

https://developer.github.com/v3/teams/#create-team
*/
func (c *Client) TeamsCreate(ctx context.Context, req *TeamsCreateReq, opt ...RequestOption) (*TeamsCreateResponse, error) {
	resp := &TeamsCreateResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateReq is request data for Client.TeamsCreate

https://developer.github.com/v3/teams/#create-team
*/
type TeamsCreateReq struct {
	_url        string
	Org         string
	RequestBody TeamsCreateReqBody
}

func (r *TeamsCreateReq) url() string {
	return r._url
}

func (r *TeamsCreateReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams", r.Org)
}

func (r *TeamsCreateReq) method() string {
	return "POST"
}

func (r *TeamsCreateReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *TeamsCreateReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateReq) Rel(link RelName, resp *TeamsCreateResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateReqBody is a request body for teams/create

https://developer.github.com/v3/teams/#create-team
*/
type TeamsCreateReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// List GitHub IDs for organization members who will become team maintainers.
	Maintainers []string `json:"maintainers,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	   **Deprecated**. The permission that new repositories will be added to the team
	   with when none is specified. Can be one of:
	   \* `pull` - team members can pull, but not push to or administer newly-added
	   repositories.
	   \* `push` - team members can pull and push, but not administer newly-added
	   repositories.
	   \* `admin` - team members can pull, push and administer newly-added
	   repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	   The level of privacy this team should have. The options are:
	   **For a non-nested team:**
	   \* `secret` - only visible to organization owners and members of this team.
	   \* `closed` - visible to all members of this organization.
	   Default: `secret`
	   **For a parent or child team:**
	   \* `closed` - visible to all members of this organization.
	   Default for child team: `closed`
	*/
	Privacy *string `json:"privacy,omitempty"`

	/*
	   The full name (e.g., "organization-name/repository-name") of repositories to add
	   the team to.
	*/
	RepoNames []string `json:"repo_names,omitempty"`
}

/*
TeamsCreateResponseBody is a response body for TeamsCreate

https://developer.github.com/v3/teams/#create-team
*/
type TeamsCreateResponseBody struct {
	components.TeamFull
}

/*
TeamsCreateResponse is a response for TeamsCreate

https://developer.github.com/v3/teams/#create-team
*/
type TeamsCreateResponse struct {
	response
	request *TeamsCreateReq
	Data    *TeamsCreateResponseBody
}

/*
TeamsCreateDiscussionCommentInOrg performs requests for "teams/create-discussion-comment-in-org"

Create a comment.

  POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#create-a-comment
*/
func (c *Client) TeamsCreateDiscussionCommentInOrg(ctx context.Context, req *TeamsCreateDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsCreateDiscussionCommentInOrgResponse, error) {
	resp := &TeamsCreateDiscussionCommentInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateDiscussionCommentInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateDiscussionCommentInOrgReq is request data for Client.TeamsCreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-comment
*/
type TeamsCreateDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      TeamsCreateDiscussionCommentInOrgReqBody

	/*
	The [reactions API](https://developer.github.com/v3/reactions/) is available for
	developers to preview. The `url` can be used to construct the API location for
	[listing and creating](https://developer.github.com/v3/reactions) reactions. See
	the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To receive the `reactions` object in the response for this
	endpoint you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsCreateDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *TeamsCreateDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsCreateDiscussionCommentInOrgReq) method() string {
	return "POST"
}

func (r *TeamsCreateDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateDiscussionCommentInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *TeamsCreateDiscussionCommentInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsCreateDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateDiscussionCommentInOrgReqBody is a request body for teams/create-discussion-comment-in-org

https://developer.github.com/v3/teams/discussion_comments/#create-a-comment
*/
type TeamsCreateDiscussionCommentInOrgReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
TeamsCreateDiscussionCommentInOrgResponseBody is a response body for TeamsCreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-comment
*/
type TeamsCreateDiscussionCommentInOrgResponseBody struct {
	components.TeamDiscussionComment
}

/*
TeamsCreateDiscussionCommentInOrgResponse is a response for TeamsCreateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#create-a-comment
*/
type TeamsCreateDiscussionCommentInOrgResponse struct {
	response
	request *TeamsCreateDiscussionCommentInOrgReq
	Data    *TeamsCreateDiscussionCommentInOrgResponseBody
}

/*
TeamsCreateDiscussionInOrg performs requests for "teams/create-discussion-in-org"

Create a discussion.

  POST /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
func (c *Client) TeamsCreateDiscussionInOrg(ctx context.Context, req *TeamsCreateDiscussionInOrgReq, opt ...RequestOption) (*TeamsCreateDiscussionInOrgResponse, error) {
	resp := &TeamsCreateDiscussionInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateDiscussionInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateDiscussionInOrgReq is request data for Client.TeamsCreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	RequestBody TeamsCreateDiscussionInOrgReqBody

	/*
	The [reactions API](https://developer.github.com/v3/reactions/) is available for
	developers to preview. The `url` can be used to construct the API location for
	[listing and creating](https://developer.github.com/v3/reactions) reactions. See
	the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To receive the `reactions` object in the response for this
	endpoint you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsCreateDiscussionInOrgReq) url() string {
	return r._url
}

func (r *TeamsCreateDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions", r.Org, r.TeamSlug)
}

func (r *TeamsCreateDiscussionInOrgReq) method() string {
	return "POST"
}

func (r *TeamsCreateDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateDiscussionInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateDiscussionInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionInOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsCreateDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *TeamsCreateDiscussionInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateDiscussionInOrgReq) Rel(link RelName, resp *TeamsCreateDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsCreateDiscussionInOrgReqBody is a request body for teams/create-discussion-in-org

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body"`

	/*
	   Private posts are only visible to team members, organization owners, and team
	   maintainers. Public posts are visible to all members of the organization. Set to
	   `true` to create a private post.
	*/
	Private *bool `json:"private,omitempty"`

	// The discussion post's title.
	Title *string `json:"title"`
}

/*
TeamsCreateDiscussionInOrgResponseBody is a response body for TeamsCreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgResponseBody struct {
	components.TeamDiscussion
}

/*
TeamsCreateDiscussionInOrgResponse is a response for TeamsCreateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#create-a-discussion
*/
type TeamsCreateDiscussionInOrgResponse struct {
	response
	request *TeamsCreateDiscussionInOrgReq
	Data    *TeamsCreateDiscussionInOrgResponseBody
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrg performs requests for "teams/create-or-update-id-p-group-connections-in-org"

Create or update IdP group connections.

  PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
func (c *Client) TeamsCreateOrUpdateIdPGroupConnectionsInOrg(ctx context.Context, req *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq, opt ...RequestOption) (*TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse, error) {
	resp := &TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq is request data for Client.TeamsCreateOrUpdateIdPGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	RequestBody TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBody
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) url() string {
	return r._url
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/team-sync/group-mappings", r.Org, r.TeamSlug)
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) method() string {
	return "PATCH"
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq) Rel(link RelName, resp *TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

// TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBodyGroups is a value for TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBody's Groups field
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBodyGroups struct {

	// Description of the IdP group.
	GroupDescription *string `json:"group_description"`

	// ID of the IdP group.
	GroupId *string `json:"group_id"`

	// Name of the IdP group.
	GroupName *string `json:"group_name"`
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBody is a request body for teams/create-or-update-id-p-group-connections-in-org

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBody struct {

	/*
	   The IdP groups you want to connect to a GitHub team. When updating, the new
	   `groups` object will replace the original one. You must include any existing
	   groups that you don't want to remove.
	*/
	Groups []TeamsCreateOrUpdateIdPGroupConnectionsInOrgReqBodyGroups `json:"groups"`
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponseBody is a response body for TeamsCreateOrUpdateIdPGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponseBody struct {
	components.GroupMapping
}

/*
TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse is a response for TeamsCreateOrUpdateIdPGroupConnectionsInOrg

https://developer.github.com/v3/teams/team_sync/#create-or-update-idp-group-connections
*/
type TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponse struct {
	response
	request *TeamsCreateOrUpdateIdPGroupConnectionsInOrgReq
	Data    *TeamsCreateOrUpdateIdPGroupConnectionsInOrgResponseBody
}

/*
TeamsDeleteDiscussionCommentInOrg performs requests for "teams/delete-discussion-comment-in-org"

Delete a comment.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#delete-a-comment
*/
func (c *Client) TeamsDeleteDiscussionCommentInOrg(ctx context.Context, req *TeamsDeleteDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsDeleteDiscussionCommentInOrgResponse, error) {
	resp := &TeamsDeleteDiscussionCommentInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteDiscussionCommentInOrgReq is request data for Client.TeamsDeleteDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#delete-a-comment
*/
type TeamsDeleteDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber)
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsDeleteDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsDeleteDiscussionCommentInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsDeleteDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteDiscussionCommentInOrgResponse is a response for TeamsDeleteDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#delete-a-comment
*/
type TeamsDeleteDiscussionCommentInOrgResponse struct {
	response
	request *TeamsDeleteDiscussionCommentInOrgReq
}

/*
TeamsDeleteDiscussionInOrg performs requests for "teams/delete-discussion-in-org"

Delete a discussion.

  DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
func (c *Client) TeamsDeleteDiscussionInOrg(ctx context.Context, req *TeamsDeleteDiscussionInOrgReq, opt ...RequestOption) (*TeamsDeleteDiscussionInOrgResponse, error) {
	resp := &TeamsDeleteDiscussionInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteDiscussionInOrgReq is request data for Client.TeamsDeleteDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
type TeamsDeleteDiscussionInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
}

func (r *TeamsDeleteDiscussionInOrgReq) url() string {
	return r._url
}

func (r *TeamsDeleteDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsDeleteDiscussionInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsDeleteDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsDeleteDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsDeleteDiscussionInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsDeleteDiscussionInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsDeleteDiscussionInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsDeleteDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsDeleteDiscussionInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteDiscussionInOrgReq) Rel(link RelName, resp *TeamsDeleteDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteDiscussionInOrgResponse is a response for TeamsDeleteDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#delete-a-discussion
*/
type TeamsDeleteDiscussionInOrgResponse struct {
	response
	request *TeamsDeleteDiscussionInOrgReq
}

/*
TeamsDeleteInOrg performs requests for "teams/delete-in-org"

Delete team.

  DELETE /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#delete-team
*/
func (c *Client) TeamsDeleteInOrg(ctx context.Context, req *TeamsDeleteInOrgReq, opt ...RequestOption) (*TeamsDeleteInOrgResponse, error) {
	resp := &TeamsDeleteInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsDeleteInOrgReq is request data for Client.TeamsDeleteInOrg

https://developer.github.com/v3/teams/#delete-team
*/
type TeamsDeleteInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
}

func (r *TeamsDeleteInOrgReq) url() string {
	return r._url
}

func (r *TeamsDeleteInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug)
}

func (r *TeamsDeleteInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsDeleteInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsDeleteInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsDeleteInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsDeleteInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsDeleteInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsDeleteInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsDeleteInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsDeleteInOrgReq) Rel(link RelName, resp *TeamsDeleteInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsDeleteInOrgResponse is a response for TeamsDeleteInOrg

https://developer.github.com/v3/teams/#delete-team
*/
type TeamsDeleteInOrgResponse struct {
	response
	request *TeamsDeleteInOrgReq
}

/*
TeamsGetByName performs requests for "teams/get-by-name"

Get team by name.

  GET /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#get-team-by-name
*/
func (c *Client) TeamsGetByName(ctx context.Context, req *TeamsGetByNameReq, opt ...RequestOption) (*TeamsGetByNameResponse, error) {
	resp := &TeamsGetByNameResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetByNameResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetByNameReq is request data for Client.TeamsGetByName

https://developer.github.com/v3/teams/#get-team-by-name
*/
type TeamsGetByNameReq struct {
	_url     string
	Org      string
	TeamSlug string
}

func (r *TeamsGetByNameReq) url() string {
	return r._url
}

func (r *TeamsGetByNameReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug)
}

func (r *TeamsGetByNameReq) method() string {
	return "GET"
}

func (r *TeamsGetByNameReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetByNameReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetByNameReq) body() interface{} {
	return nil
}

func (r *TeamsGetByNameReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetByNameReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetByNameReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsGetByNameReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetByNameReq) Rel(link RelName, resp *TeamsGetByNameResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetByNameResponseBody is a response body for TeamsGetByName

https://developer.github.com/v3/teams/#get-team-by-name
*/
type TeamsGetByNameResponseBody struct {
	components.TeamFull
}

/*
TeamsGetByNameResponse is a response for TeamsGetByName

https://developer.github.com/v3/teams/#get-team-by-name
*/
type TeamsGetByNameResponse struct {
	response
	request *TeamsGetByNameReq
	Data    *TeamsGetByNameResponseBody
}

/*
TeamsGetDiscussionCommentInOrg performs requests for "teams/get-discussion-comment-in-org"

Get a single comment.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#get-a-single-comment
*/
func (c *Client) TeamsGetDiscussionCommentInOrg(ctx context.Context, req *TeamsGetDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsGetDiscussionCommentInOrgResponse, error) {
	resp := &TeamsGetDiscussionCommentInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetDiscussionCommentInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetDiscussionCommentInOrgReq is request data for Client.TeamsGetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-single-comment
*/
type TeamsGetDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64

	/*
	The [reactions API](https://developer.github.com/v3/reactions/) is available for
	developers to preview. The `url` can be used to construct the API location for
	[listing and creating](https://developer.github.com/v3/reactions) reactions. See
	the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To receive the `reactions` object in the response for this
	endpoint you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsGetDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *TeamsGetDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber)
}

func (r *TeamsGetDiscussionCommentInOrgReq) method() string {
	return "GET"
}

func (r *TeamsGetDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetDiscussionCommentInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsGetDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsGetDiscussionCommentInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsGetDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetDiscussionCommentInOrgResponseBody is a response body for TeamsGetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-single-comment
*/
type TeamsGetDiscussionCommentInOrgResponseBody struct {
	components.TeamDiscussionComment
}

/*
TeamsGetDiscussionCommentInOrgResponse is a response for TeamsGetDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#get-a-single-comment
*/
type TeamsGetDiscussionCommentInOrgResponse struct {
	response
	request *TeamsGetDiscussionCommentInOrgReq
	Data    *TeamsGetDiscussionCommentInOrgResponseBody
}

/*
TeamsGetDiscussionInOrg performs requests for "teams/get-discussion-in-org"

Get a single discussion.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#get-a-single-discussion
*/
func (c *Client) TeamsGetDiscussionInOrg(ctx context.Context, req *TeamsGetDiscussionInOrgReq, opt ...RequestOption) (*TeamsGetDiscussionInOrgResponse, error) {
	resp := &TeamsGetDiscussionInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetDiscussionInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetDiscussionInOrgReq is request data for Client.TeamsGetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-single-discussion
*/
type TeamsGetDiscussionInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64

	/*
	The [reactions API](https://developer.github.com/v3/reactions/) is available for
	developers to preview. The `url` can be used to construct the API location for
	[listing and creating](https://developer.github.com/v3/reactions) reactions. See
	the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To receive the `reactions` object in the response for this
	endpoint you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsGetDiscussionInOrgReq) url() string {
	return r._url
}

func (r *TeamsGetDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsGetDiscussionInOrgReq) method() string {
	return "GET"
}

func (r *TeamsGetDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetDiscussionInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsGetDiscussionInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsGetDiscussionInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetDiscussionInOrgReq) Rel(link RelName, resp *TeamsGetDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetDiscussionInOrgResponseBody is a response body for TeamsGetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-single-discussion
*/
type TeamsGetDiscussionInOrgResponseBody struct {
	components.TeamDiscussion
}

/*
TeamsGetDiscussionInOrgResponse is a response for TeamsGetDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#get-a-single-discussion
*/
type TeamsGetDiscussionInOrgResponse struct {
	response
	request *TeamsGetDiscussionInOrgReq
	Data    *TeamsGetDiscussionInOrgResponseBody
}

/*
TeamsGetMembershipInOrg performs requests for "teams/get-membership-in-org"

Get team membership.

  GET /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#get-team-membership
*/
func (c *Client) TeamsGetMembershipInOrg(ctx context.Context, req *TeamsGetMembershipInOrgReq, opt ...RequestOption) (*TeamsGetMembershipInOrgResponse, error) {
	resp := &TeamsGetMembershipInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsGetMembershipInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsGetMembershipInOrgReq is request data for Client.TeamsGetMembershipInOrg

https://developer.github.com/v3/teams/members/#get-team-membership
*/
type TeamsGetMembershipInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
	Username string
}

func (r *TeamsGetMembershipInOrgReq) url() string {
	return r._url
}

func (r *TeamsGetMembershipInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username)
}

func (r *TeamsGetMembershipInOrgReq) method() string {
	return "GET"
}

func (r *TeamsGetMembershipInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsGetMembershipInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsGetMembershipInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsGetMembershipInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsGetMembershipInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsGetMembershipInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsGetMembershipInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsGetMembershipInOrgReq) Rel(link RelName, resp *TeamsGetMembershipInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsGetMembershipInOrgResponseBody is a response body for TeamsGetMembershipInOrg

https://developer.github.com/v3/teams/members/#get-team-membership
*/
type TeamsGetMembershipInOrgResponseBody struct {
	components.TeamMembership
}

/*
TeamsGetMembershipInOrgResponse is a response for TeamsGetMembershipInOrg

https://developer.github.com/v3/teams/members/#get-team-membership
*/
type TeamsGetMembershipInOrgResponse struct {
	response
	request *TeamsGetMembershipInOrgReq
	Data    *TeamsGetMembershipInOrgResponseBody
}

/*
TeamsList performs requests for "teams/list"

List teams.

  GET /orgs/{org}/teams

https://developer.github.com/v3/teams/#list-teams
*/
func (c *Client) TeamsList(ctx context.Context, req *TeamsListReq, opt ...RequestOption) (*TeamsListResponse, error) {
	resp := &TeamsListResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListReq is request data for Client.TeamsList

https://developer.github.com/v3/teams/#list-teams
*/
type TeamsListReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListReq) url() string {
	return r._url
}

func (r *TeamsListReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams", r.Org)
}

func (r *TeamsListReq) method() string {
	return "GET"
}

func (r *TeamsListReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListReq) body() interface{} {
	return nil
}

func (r *TeamsListReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsListReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListReq) Rel(link RelName, resp *TeamsListResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListResponseBody is a response body for TeamsList

https://developer.github.com/v3/teams/#list-teams
*/
type TeamsListResponseBody []struct {
	components.Team
}

/*
TeamsListResponse is a response for TeamsList

https://developer.github.com/v3/teams/#list-teams
*/
type TeamsListResponse struct {
	response
	request *TeamsListReq
	Data    *TeamsListResponseBody
}

/*
TeamsListChildInOrg performs requests for "teams/list-child-in-org"

List child teams.

  GET /orgs/{org}/teams/{team_slug}/teams

https://developer.github.com/v3/teams/#list-child-teams
*/
func (c *Client) TeamsListChildInOrg(ctx context.Context, req *TeamsListChildInOrgReq, opt ...RequestOption) (*TeamsListChildInOrgResponse, error) {
	resp := &TeamsListChildInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListChildInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListChildInOrgReq is request data for Client.TeamsListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type TeamsListChildInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListChildInOrgReq) url() string {
	return r._url
}

func (r *TeamsListChildInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/teams", r.Org, r.TeamSlug)
}

func (r *TeamsListChildInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListChildInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListChildInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListChildInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListChildInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListChildInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListChildInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsListChildInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListChildInOrgReq) Rel(link RelName, resp *TeamsListChildInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListChildInOrgResponseBody is a response body for TeamsListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type TeamsListChildInOrgResponseBody []struct {
	components.Team2
}

/*
TeamsListChildInOrgResponse is a response for TeamsListChildInOrg

https://developer.github.com/v3/teams/#list-child-teams
*/
type TeamsListChildInOrgResponse struct {
	response
	request *TeamsListChildInOrgReq
	Data    *TeamsListChildInOrgResponseBody
}

/*
TeamsListDiscussionCommentsInOrg performs requests for "teams/list-discussion-comments-in-org"

List comments.

  GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments

https://developer.github.com/v3/teams/discussion_comments/#list-comments
*/
func (c *Client) TeamsListDiscussionCommentsInOrg(ctx context.Context, req *TeamsListDiscussionCommentsInOrgReq, opt ...RequestOption) (*TeamsListDiscussionCommentsInOrgResponse, error) {
	resp := &TeamsListDiscussionCommentsInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListDiscussionCommentsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListDiscussionCommentsInOrgReq is request data for Client.TeamsListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-comments
*/
type TeamsListDiscussionCommentsInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64

	/*
	Sorts the discussion comments by the date they were created. To return the
	oldest comments first, set to `asc`. Can be one of `asc` or `desc`.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The [reactions API](https://developer.github.com/v3/reactions/) is available for
	developers to preview. The `url` can be used to construct the API location for
	[listing and creating](https://developer.github.com/v3/reactions) reactions. See
	the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To receive the `reactions` object in the response for this
	endpoint you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsListDiscussionCommentsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListDiscussionCommentsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsListDiscussionCommentsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListDiscussionCommentsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListDiscussionCommentsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListDiscussionCommentsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListDiscussionCommentsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionCommentsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionCommentsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsListDiscussionCommentsInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListDiscussionCommentsInOrgReq) Rel(link RelName, resp *TeamsListDiscussionCommentsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListDiscussionCommentsInOrgResponseBody is a response body for TeamsListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-comments
*/
type TeamsListDiscussionCommentsInOrgResponseBody []struct {
	components.TeamDiscussionComment
}

/*
TeamsListDiscussionCommentsInOrgResponse is a response for TeamsListDiscussionCommentsInOrg

https://developer.github.com/v3/teams/discussion_comments/#list-comments
*/
type TeamsListDiscussionCommentsInOrgResponse struct {
	response
	request *TeamsListDiscussionCommentsInOrgReq
	Data    *TeamsListDiscussionCommentsInOrgResponseBody
}

/*
TeamsListDiscussionsInOrg performs requests for "teams/list-discussions-in-org"

List discussions.

  GET /orgs/{org}/teams/{team_slug}/discussions

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
func (c *Client) TeamsListDiscussionsInOrg(ctx context.Context, req *TeamsListDiscussionsInOrgReq, opt ...RequestOption) (*TeamsListDiscussionsInOrgResponse, error) {
	resp := &TeamsListDiscussionsInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListDiscussionsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListDiscussionsInOrgReq is request data for Client.TeamsListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type TeamsListDiscussionsInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	/*
	Sorts the discussion comments by the date they were created. To return the
	oldest comments first, set to `asc`. Can be one of `asc` or `desc`.
	*/
	Direction *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The [reactions API](https://developer.github.com/v3/reactions/) is available for
	developers to preview. The `url` can be used to construct the API location for
	[listing and creating](https://developer.github.com/v3/reactions) reactions. See
	the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To receive the `reactions` object in the response for this
	endpoint you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsListDiscussionsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListDiscussionsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions", r.Org, r.TeamSlug)
}

func (r *TeamsListDiscussionsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListDiscussionsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Direction != nil {
		query.Set("direction", *r.Direction)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListDiscussionsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListDiscussionsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListDiscussionsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListDiscussionsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsListDiscussionsInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListDiscussionsInOrgReq) Rel(link RelName, resp *TeamsListDiscussionsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListDiscussionsInOrgResponseBody is a response body for TeamsListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type TeamsListDiscussionsInOrgResponseBody []struct {
	components.TeamDiscussion
}

/*
TeamsListDiscussionsInOrgResponse is a response for TeamsListDiscussionsInOrg

https://developer.github.com/v3/teams/discussions/#list-discussions
*/
type TeamsListDiscussionsInOrgResponse struct {
	response
	request *TeamsListDiscussionsInOrgReq
	Data    *TeamsListDiscussionsInOrgResponseBody
}

/*
TeamsListForAuthenticatedUser performs requests for "teams/list-for-authenticated-user"

List user teams.

  GET /user/teams

https://developer.github.com/v3/teams/#list-user-teams
*/
func (c *Client) TeamsListForAuthenticatedUser(ctx context.Context, req *TeamsListForAuthenticatedUserReq, opt ...RequestOption) (*TeamsListForAuthenticatedUserResponse, error) {
	resp := &TeamsListForAuthenticatedUserResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListForAuthenticatedUserResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListForAuthenticatedUserReq is request data for Client.TeamsListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-user-teams
*/
type TeamsListForAuthenticatedUserReq struct {
	_url string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListForAuthenticatedUserReq) url() string {
	return r._url
}

func (r *TeamsListForAuthenticatedUserReq) urlPath() string {
	return fmt.Sprintf("/user/teams")
}

func (r *TeamsListForAuthenticatedUserReq) method() string {
	return "GET"
}

func (r *TeamsListForAuthenticatedUserReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListForAuthenticatedUserReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListForAuthenticatedUserReq) body() interface{} {
	return nil
}

func (r *TeamsListForAuthenticatedUserReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListForAuthenticatedUserReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListForAuthenticatedUserReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsListForAuthenticatedUserReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListForAuthenticatedUserReq) Rel(link RelName, resp *TeamsListForAuthenticatedUserResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListForAuthenticatedUserResponseBody is a response body for TeamsListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-user-teams
*/
type TeamsListForAuthenticatedUserResponseBody []struct {
	components.TeamFull
}

/*
TeamsListForAuthenticatedUserResponse is a response for TeamsListForAuthenticatedUser

https://developer.github.com/v3/teams/#list-user-teams
*/
type TeamsListForAuthenticatedUserResponse struct {
	response
	request *TeamsListForAuthenticatedUserReq
	Data    *TeamsListForAuthenticatedUserResponseBody
}

/*
TeamsListIdPGroupsForOrg performs requests for "teams/list-id-p-groups-for-org"

List IdP groups in an organization.

  GET /orgs/{org}/team-sync/groups

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-in-an-organization
*/
func (c *Client) TeamsListIdPGroupsForOrg(ctx context.Context, req *TeamsListIdPGroupsForOrgReq, opt ...RequestOption) (*TeamsListIdPGroupsForOrgResponse, error) {
	resp := &TeamsListIdPGroupsForOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListIdPGroupsForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListIdPGroupsForOrgReq is request data for Client.TeamsListIdPGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-in-an-organization
*/
type TeamsListIdPGroupsForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListIdPGroupsForOrgReq) url() string {
	return r._url
}

func (r *TeamsListIdPGroupsForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/team-sync/groups", r.Org)
}

func (r *TeamsListIdPGroupsForOrgReq) method() string {
	return "GET"
}

func (r *TeamsListIdPGroupsForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListIdPGroupsForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListIdPGroupsForOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListIdPGroupsForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsListIdPGroupsForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListIdPGroupsForOrgReq) Rel(link RelName, resp *TeamsListIdPGroupsForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListIdPGroupsForOrgResponseBody is a response body for TeamsListIdPGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-in-an-organization
*/
type TeamsListIdPGroupsForOrgResponseBody struct {
	components.GroupMapping3
}

/*
TeamsListIdPGroupsForOrgResponse is a response for TeamsListIdPGroupsForOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-in-an-organization
*/
type TeamsListIdPGroupsForOrgResponse struct {
	response
	request *TeamsListIdPGroupsForOrgReq
	Data    *TeamsListIdPGroupsForOrgResponseBody
}

/*
TeamsListIdPGroupsInOrg performs requests for "teams/list-id-p-groups-in-org"

List IdP groups for a team.

  GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
func (c *Client) TeamsListIdPGroupsInOrg(ctx context.Context, req *TeamsListIdPGroupsInOrgReq, opt ...RequestOption) (*TeamsListIdPGroupsInOrgResponse, error) {
	resp := &TeamsListIdPGroupsInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListIdPGroupsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListIdPGroupsInOrgReq is request data for Client.TeamsListIdPGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type TeamsListIdPGroupsInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
}

func (r *TeamsListIdPGroupsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListIdPGroupsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/team-sync/group-mappings", r.Org, r.TeamSlug)
}

func (r *TeamsListIdPGroupsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListIdPGroupsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsListIdPGroupsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListIdPGroupsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListIdPGroupsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListIdPGroupsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsListIdPGroupsInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListIdPGroupsInOrgReq) Rel(link RelName, resp *TeamsListIdPGroupsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListIdPGroupsInOrgResponseBody is a response body for TeamsListIdPGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type TeamsListIdPGroupsInOrgResponseBody struct {
	components.GroupMapping3
}

/*
TeamsListIdPGroupsInOrgResponse is a response for TeamsListIdPGroupsInOrg

https://developer.github.com/v3/teams/team_sync/#list-idp-groups-for-a-team
*/
type TeamsListIdPGroupsInOrgResponse struct {
	response
	request *TeamsListIdPGroupsInOrgReq
	Data    *TeamsListIdPGroupsInOrgResponseBody
}

/*
TeamsListMembersInOrg performs requests for "teams/list-members-in-org"

List team members.

  GET /orgs/{org}/teams/{team_slug}/members

https://developer.github.com/v3/teams/members/#list-team-members
*/
func (c *Client) TeamsListMembersInOrg(ctx context.Context, req *TeamsListMembersInOrgReq, opt ...RequestOption) (*TeamsListMembersInOrgResponse, error) {
	resp := &TeamsListMembersInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListMembersInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListMembersInOrgReq is request data for Client.TeamsListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type TeamsListMembersInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	/*
	Filters members returned by their role in the team. Can be one of:
	\* `member` - normal members of the team.
	\* `maintainer` - team maintainers.
	\* `all` - all members of the team.
	*/
	Role *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListMembersInOrgReq) url() string {
	return r._url
}

func (r *TeamsListMembersInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/members", r.Org, r.TeamSlug)
}

func (r *TeamsListMembersInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListMembersInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Role != nil {
		query.Set("role", *r.Role)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListMembersInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListMembersInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListMembersInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListMembersInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListMembersInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsListMembersInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListMembersInOrgReq) Rel(link RelName, resp *TeamsListMembersInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListMembersInOrgResponseBody is a response body for TeamsListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type TeamsListMembersInOrgResponseBody []struct {
	components.SimpleUser
}

/*
TeamsListMembersInOrgResponse is a response for TeamsListMembersInOrg

https://developer.github.com/v3/teams/members/#list-team-members
*/
type TeamsListMembersInOrgResponse struct {
	response
	request *TeamsListMembersInOrgReq
	Data    *TeamsListMembersInOrgResponseBody
}

/*
TeamsListPendingInvitationsInOrg performs requests for "teams/list-pending-invitations-in-org"

List pending team invitations.

  GET /orgs/{org}/teams/{team_slug}/invitations

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
func (c *Client) TeamsListPendingInvitationsInOrg(ctx context.Context, req *TeamsListPendingInvitationsInOrgReq, opt ...RequestOption) (*TeamsListPendingInvitationsInOrgResponse, error) {
	resp := &TeamsListPendingInvitationsInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListPendingInvitationsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListPendingInvitationsInOrgReq is request data for Client.TeamsListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type TeamsListPendingInvitationsInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListPendingInvitationsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListPendingInvitationsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/invitations", r.Org, r.TeamSlug)
}

func (r *TeamsListPendingInvitationsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListPendingInvitationsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListPendingInvitationsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListPendingInvitationsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListPendingInvitationsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListPendingInvitationsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListPendingInvitationsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsListPendingInvitationsInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListPendingInvitationsInOrgReq) Rel(link RelName, resp *TeamsListPendingInvitationsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListPendingInvitationsInOrgResponseBody is a response body for TeamsListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type TeamsListPendingInvitationsInOrgResponseBody []struct {
	components.OrganizationInvitation
}

/*
TeamsListPendingInvitationsInOrgResponse is a response for TeamsListPendingInvitationsInOrg

https://developer.github.com/v3/teams/members/#list-pending-team-invitations
*/
type TeamsListPendingInvitationsInOrgResponse struct {
	response
	request *TeamsListPendingInvitationsInOrgReq
	Data    *TeamsListPendingInvitationsInOrgResponseBody
}

/*
TeamsListProjectsInOrg performs requests for "teams/list-projects-in-org"

List team projects.

  GET /orgs/{org}/teams/{team_slug}/projects

https://developer.github.com/v3/teams/#list-team-projects
*/
func (c *Client) TeamsListProjectsInOrg(ctx context.Context, req *TeamsListProjectsInOrgReq, opt ...RequestOption) (*TeamsListProjectsInOrgResponse, error) {
	resp := &TeamsListProjectsInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListProjectsInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListProjectsInOrgReq is request data for Client.TeamsListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type TeamsListProjectsInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *TeamsListProjectsInOrgReq) url() string {
	return r._url
}

func (r *TeamsListProjectsInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/projects", r.Org, r.TeamSlug)
}

func (r *TeamsListProjectsInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListProjectsInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListProjectsInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListProjectsInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListProjectsInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListProjectsInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListProjectsInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsListProjectsInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListProjectsInOrgReq) Rel(link RelName, resp *TeamsListProjectsInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListProjectsInOrgResponseBody is a response body for TeamsListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type TeamsListProjectsInOrgResponseBody []struct {
	components.TeamProject
}

/*
TeamsListProjectsInOrgResponse is a response for TeamsListProjectsInOrg

https://developer.github.com/v3/teams/#list-team-projects
*/
type TeamsListProjectsInOrgResponse struct {
	response
	request *TeamsListProjectsInOrgReq
	Data    *TeamsListProjectsInOrgResponseBody
}

/*
TeamsListReposInOrg performs requests for "teams/list-repos-in-org"

List team repos.

  GET /orgs/{org}/teams/{team_slug}/repos

https://developer.github.com/v3/teams/#list-team-repos
*/
func (c *Client) TeamsListReposInOrg(ctx context.Context, req *TeamsListReposInOrgReq, opt ...RequestOption) (*TeamsListReposInOrgResponse, error) {
	resp := &TeamsListReposInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsListReposInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsListReposInOrgReq is request data for Client.TeamsListReposInOrg

https://developer.github.com/v3/teams/#list-team-repos
*/
type TeamsListReposInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *TeamsListReposInOrgReq) url() string {
	return r._url
}

func (r *TeamsListReposInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/repos", r.Org, r.TeamSlug)
}

func (r *TeamsListReposInOrgReq) method() string {
	return "GET"
}

func (r *TeamsListReposInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *TeamsListReposInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsListReposInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsListReposInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsListReposInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsListReposInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsListReposInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsListReposInOrgReq) Rel(link RelName, resp *TeamsListReposInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsListReposInOrgResponseBody is a response body for TeamsListReposInOrg

https://developer.github.com/v3/teams/#list-team-repos
*/
type TeamsListReposInOrgResponseBody []struct {
	components.MinimalRepository
}

/*
TeamsListReposInOrgResponse is a response for TeamsListReposInOrg

https://developer.github.com/v3/teams/#list-team-repos
*/
type TeamsListReposInOrgResponse struct {
	response
	request *TeamsListReposInOrgReq
	Data    *TeamsListReposInOrgResponseBody
}

/*
TeamsRemoveMembershipInOrg performs requests for "teams/remove-membership-in-org"

Remove team membership.

  DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}

https://developer.github.com/v3/teams/members/#remove-team-membership
*/
func (c *Client) TeamsRemoveMembershipInOrg(ctx context.Context, req *TeamsRemoveMembershipInOrgReq, opt ...RequestOption) (*TeamsRemoveMembershipInOrgResponse, error) {
	resp := &TeamsRemoveMembershipInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveMembershipInOrgReq is request data for Client.TeamsRemoveMembershipInOrg

https://developer.github.com/v3/teams/members/#remove-team-membership
*/
type TeamsRemoveMembershipInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
	Username string
}

func (r *TeamsRemoveMembershipInOrgReq) url() string {
	return r._url
}

func (r *TeamsRemoveMembershipInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/memberships/%v", r.Org, r.TeamSlug, r.Username)
}

func (r *TeamsRemoveMembershipInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsRemoveMembershipInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsRemoveMembershipInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsRemoveMembershipInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsRemoveMembershipInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsRemoveMembershipInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsRemoveMembershipInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsRemoveMembershipInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveMembershipInOrgReq) Rel(link RelName, resp *TeamsRemoveMembershipInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveMembershipInOrgResponse is a response for TeamsRemoveMembershipInOrg

https://developer.github.com/v3/teams/members/#remove-team-membership
*/
type TeamsRemoveMembershipInOrgResponse struct {
	response
	request *TeamsRemoveMembershipInOrgReq
}

/*
TeamsRemoveProjectInOrg performs requests for "teams/remove-project-in-org"

Remove team project.

  DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#remove-team-project
*/
func (c *Client) TeamsRemoveProjectInOrg(ctx context.Context, req *TeamsRemoveProjectInOrgReq, opt ...RequestOption) (*TeamsRemoveProjectInOrgResponse, error) {
	resp := &TeamsRemoveProjectInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveProjectInOrgReq is request data for Client.TeamsRemoveProjectInOrg

https://developer.github.com/v3/teams/#remove-team-project
*/
type TeamsRemoveProjectInOrgReq struct {
	_url      string
	Org       string
	TeamSlug  string
	ProjectId int64
}

func (r *TeamsRemoveProjectInOrgReq) url() string {
	return r._url
}

func (r *TeamsRemoveProjectInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId)
}

func (r *TeamsRemoveProjectInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsRemoveProjectInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsRemoveProjectInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsRemoveProjectInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsRemoveProjectInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsRemoveProjectInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsRemoveProjectInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsRemoveProjectInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveProjectInOrgReq) Rel(link RelName, resp *TeamsRemoveProjectInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveProjectInOrgResponse is a response for TeamsRemoveProjectInOrg

https://developer.github.com/v3/teams/#remove-team-project
*/
type TeamsRemoveProjectInOrgResponse struct {
	response
	request *TeamsRemoveProjectInOrgReq
}

/*
TeamsRemoveRepoInOrg performs requests for "teams/remove-repo-in-org"

Remove team repository.

  DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}

https://developer.github.com/v3/teams/#remove-team-repository
*/
func (c *Client) TeamsRemoveRepoInOrg(ctx context.Context, req *TeamsRemoveRepoInOrgReq, opt ...RequestOption) (*TeamsRemoveRepoInOrgResponse, error) {
	resp := &TeamsRemoveRepoInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsRemoveRepoInOrgReq is request data for Client.TeamsRemoveRepoInOrg

https://developer.github.com/v3/teams/#remove-team-repository
*/
type TeamsRemoveRepoInOrgReq struct {
	_url     string
	Org      string
	TeamSlug string
	Owner    string
	Repo     string
}

func (r *TeamsRemoveRepoInOrgReq) url() string {
	return r._url
}

func (r *TeamsRemoveRepoInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/repos/%v/%v", r.Org, r.TeamSlug, r.Owner, r.Repo)
}

func (r *TeamsRemoveRepoInOrgReq) method() string {
	return "DELETE"
}

func (r *TeamsRemoveRepoInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsRemoveRepoInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsRemoveRepoInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsRemoveRepoInOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *TeamsRemoveRepoInOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *TeamsRemoveRepoInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsRemoveRepoInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsRemoveRepoInOrgReq) Rel(link RelName, resp *TeamsRemoveRepoInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsRemoveRepoInOrgResponse is a response for TeamsRemoveRepoInOrg

https://developer.github.com/v3/teams/#remove-team-repository
*/
type TeamsRemoveRepoInOrgResponse struct {
	response
	request *TeamsRemoveRepoInOrgReq
}

/*
TeamsReviewProjectInOrg performs requests for "teams/review-project-in-org"

Review a team project.

  GET /orgs/{org}/teams/{team_slug}/projects/{project_id}

https://developer.github.com/v3/teams/#review-a-team-project
*/
func (c *Client) TeamsReviewProjectInOrg(ctx context.Context, req *TeamsReviewProjectInOrgReq, opt ...RequestOption) (*TeamsReviewProjectInOrgResponse, error) {
	resp := &TeamsReviewProjectInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsReviewProjectInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsReviewProjectInOrgReq is request data for Client.TeamsReviewProjectInOrg

https://developer.github.com/v3/teams/#review-a-team-project
*/
type TeamsReviewProjectInOrgReq struct {
	_url      string
	Org       string
	TeamSlug  string
	ProjectId int64

	/*
	The Projects API is currently available for developers to preview. During the
	preview period, the API may change without advance notice. Please see the [blog
	post](https://developer.github.com/changes/2016-10-27-changes-to-projects-api)
	for full details. To access the API during the preview period, you must set this
	to true.
	*/
	InertiaPreview bool
}

func (r *TeamsReviewProjectInOrgReq) url() string {
	return r._url
}

func (r *TeamsReviewProjectInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/projects/%v", r.Org, r.TeamSlug, r.ProjectId)
}

func (r *TeamsReviewProjectInOrgReq) method() string {
	return "GET"
}

func (r *TeamsReviewProjectInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsReviewProjectInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"inertia": r.InertiaPreview}
	if requiredPreviews {
		previewVals["inertia"] = true
	}
	if allPreviews {
		previewVals["inertia"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsReviewProjectInOrgReq) body() interface{} {
	return nil
}

func (r *TeamsReviewProjectInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsReviewProjectInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsReviewProjectInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *TeamsReviewProjectInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsReviewProjectInOrgReq) Rel(link RelName, resp *TeamsReviewProjectInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsReviewProjectInOrgResponseBody is a response body for TeamsReviewProjectInOrg

https://developer.github.com/v3/teams/#review-a-team-project
*/
type TeamsReviewProjectInOrgResponseBody struct {
	components.TeamProject
}

/*
TeamsReviewProjectInOrgResponse is a response for TeamsReviewProjectInOrg

https://developer.github.com/v3/teams/#review-a-team-project
*/
type TeamsReviewProjectInOrgResponse struct {
	response
	request *TeamsReviewProjectInOrgReq
	Data    *TeamsReviewProjectInOrgResponseBody
}

/*
TeamsUpdateDiscussionCommentInOrg performs requests for "teams/update-discussion-comment-in-org"

Edit a comment.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}

https://developer.github.com/v3/teams/discussion_comments/#edit-a-comment
*/
func (c *Client) TeamsUpdateDiscussionCommentInOrg(ctx context.Context, req *TeamsUpdateDiscussionCommentInOrgReq, opt ...RequestOption) (*TeamsUpdateDiscussionCommentInOrgResponse, error) {
	resp := &TeamsUpdateDiscussionCommentInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsUpdateDiscussionCommentInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateDiscussionCommentInOrgReq is request data for Client.TeamsUpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#edit-a-comment
*/
type TeamsUpdateDiscussionCommentInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	CommentNumber    int64
	RequestBody      TeamsUpdateDiscussionCommentInOrgReqBody

	/*
	The [reactions API](https://developer.github.com/v3/reactions/) is available for
	developers to preview. The `url` can be used to construct the API location for
	[listing and creating](https://developer.github.com/v3/reactions) reactions. See
	the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To receive the `reactions` object in the response for this
	endpoint you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) url() string {
	return r._url
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v/comments/%v", r.Org, r.TeamSlug, r.DiscussionNumber, r.CommentNumber)
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) method() string {
	return "PATCH"
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionCommentInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *TeamsUpdateDiscussionCommentInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateDiscussionCommentInOrgReq) Rel(link RelName, resp *TeamsUpdateDiscussionCommentInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateDiscussionCommentInOrgReqBody is a request body for teams/update-discussion-comment-in-org

https://developer.github.com/v3/teams/discussion_comments/#edit-a-comment
*/
type TeamsUpdateDiscussionCommentInOrgReqBody struct {

	// The discussion comment's body text.
	Body *string `json:"body"`
}

/*
TeamsUpdateDiscussionCommentInOrgResponseBody is a response body for TeamsUpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#edit-a-comment
*/
type TeamsUpdateDiscussionCommentInOrgResponseBody struct {
	components.TeamDiscussionComment
}

/*
TeamsUpdateDiscussionCommentInOrgResponse is a response for TeamsUpdateDiscussionCommentInOrg

https://developer.github.com/v3/teams/discussion_comments/#edit-a-comment
*/
type TeamsUpdateDiscussionCommentInOrgResponse struct {
	response
	request *TeamsUpdateDiscussionCommentInOrgReq
	Data    *TeamsUpdateDiscussionCommentInOrgResponseBody
}

/*
TeamsUpdateDiscussionInOrg performs requests for "teams/update-discussion-in-org"

Edit a discussion.

  PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}

https://developer.github.com/v3/teams/discussions/#edit-a-discussion
*/
func (c *Client) TeamsUpdateDiscussionInOrg(ctx context.Context, req *TeamsUpdateDiscussionInOrgReq, opt ...RequestOption) (*TeamsUpdateDiscussionInOrgResponse, error) {
	resp := &TeamsUpdateDiscussionInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsUpdateDiscussionInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateDiscussionInOrgReq is request data for Client.TeamsUpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#edit-a-discussion
*/
type TeamsUpdateDiscussionInOrgReq struct {
	_url             string
	Org              string
	TeamSlug         string
	DiscussionNumber int64
	RequestBody      TeamsUpdateDiscussionInOrgReqBody

	/*
	The [reactions API](https://developer.github.com/v3/reactions/) is available for
	developers to preview. The `url` can be used to construct the API location for
	[listing and creating](https://developer.github.com/v3/reactions) reactions. See
	the [blog
	post](https://developer.github.com/changes/2016-05-12-reactions-api-preview) for
	full details. To receive the `reactions` object in the response for this
	endpoint you must set this to true.
	*/
	SquirrelGirlPreview bool
}

func (r *TeamsUpdateDiscussionInOrgReq) url() string {
	return r._url
}

func (r *TeamsUpdateDiscussionInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v/discussions/%v", r.Org, r.TeamSlug, r.DiscussionNumber)
}

func (r *TeamsUpdateDiscussionInOrgReq) method() string {
	return "PATCH"
}

func (r *TeamsUpdateDiscussionInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsUpdateDiscussionInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{"squirrel-girl": r.SquirrelGirlPreview}
	if allPreviews {
		previewVals["squirrel-girl"] = true
	}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsUpdateDiscussionInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsUpdateDiscussionInOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionInOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *TeamsUpdateDiscussionInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *TeamsUpdateDiscussionInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateDiscussionInOrgReq) Rel(link RelName, resp *TeamsUpdateDiscussionInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateDiscussionInOrgReqBody is a request body for teams/update-discussion-in-org

https://developer.github.com/v3/teams/discussions/#edit-a-discussion
*/
type TeamsUpdateDiscussionInOrgReqBody struct {

	// The discussion post's body text.
	Body *string `json:"body,omitempty"`

	// The discussion post's title.
	Title *string `json:"title,omitempty"`
}

/*
TeamsUpdateDiscussionInOrgResponseBody is a response body for TeamsUpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#edit-a-discussion
*/
type TeamsUpdateDiscussionInOrgResponseBody struct {
	components.TeamDiscussion
}

/*
TeamsUpdateDiscussionInOrgResponse is a response for TeamsUpdateDiscussionInOrg

https://developer.github.com/v3/teams/discussions/#edit-a-discussion
*/
type TeamsUpdateDiscussionInOrgResponse struct {
	response
	request *TeamsUpdateDiscussionInOrgReq
	Data    *TeamsUpdateDiscussionInOrgResponseBody
}

/*
TeamsUpdateInOrg performs requests for "teams/update-in-org"

Edit team.

  PATCH /orgs/{org}/teams/{team_slug}

https://developer.github.com/v3/teams/#edit-team
*/
func (c *Client) TeamsUpdateInOrg(ctx context.Context, req *TeamsUpdateInOrgReq, opt ...RequestOption) (*TeamsUpdateInOrgResponse, error) {
	resp := &TeamsUpdateInOrgResponse{request: req}
	r, err := c.doRequest(ctx, req, opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = new(TeamsUpdateInOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
TeamsUpdateInOrgReq is request data for Client.TeamsUpdateInOrg

https://developer.github.com/v3/teams/#edit-team
*/
type TeamsUpdateInOrgReq struct {
	_url        string
	Org         string
	TeamSlug    string
	RequestBody TeamsUpdateInOrgReqBody
}

func (r *TeamsUpdateInOrgReq) url() string {
	return r._url
}

func (r *TeamsUpdateInOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/teams/%v", r.Org, r.TeamSlug)
}

func (r *TeamsUpdateInOrgReq) method() string {
	return "PATCH"
}

func (r *TeamsUpdateInOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *TeamsUpdateInOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *TeamsUpdateInOrgReq) body() interface{} {
	return r.RequestBody
}

func (r *TeamsUpdateInOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *TeamsUpdateInOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *TeamsUpdateInOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrJSONRequestBody}
}

// httpRequest creates an http request
func (r *TeamsUpdateInOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *TeamsUpdateInOrgReq) Rel(link RelName, resp *TeamsUpdateInOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
TeamsUpdateInOrgReqBody is a request body for teams/update-in-org

https://developer.github.com/v3/teams/#edit-team
*/
type TeamsUpdateInOrgReqBody struct {

	// The description of the team.
	Description *string `json:"description,omitempty"`

	// The name of the team.
	Name *string `json:"name"`

	// The ID of a team to set as the parent team.
	ParentTeamId *int64 `json:"parent_team_id,omitempty"`

	/*
	   **Deprecated**. The permission that new repositories will be added to the team
	   with when none is specified. Can be one of:
	   \* `pull` - team members can pull, but not push to or administer newly-added
	   repositories.
	   \* `push` - team members can pull and push, but not administer newly-added
	   repositories.
	   \* `admin` - team members can pull, push and administer newly-added
	   repositories.
	*/
	Permission *string `json:"permission,omitempty"`

	/*
	   The level of privacy this team should have. Editing teams without specifying
	   this parameter leaves `privacy` intact. When a team is nested, the `privacy` for
	   parent teams cannot be `secret`. The options are:
	   **For a non-nested team:**
	   \* `secret` - only visible to organization owners and members of this team.
	   \* `closed` - visible to all members of this organization.
	   **For a parent or child team:**
	   \* `closed` - visible to all members of this organization.
	*/
	Privacy *string `json:"privacy,omitempty"`
}

/*
TeamsUpdateInOrgResponseBody is a response body for TeamsUpdateInOrg

https://developer.github.com/v3/teams/#edit-team
*/
type TeamsUpdateInOrgResponseBody struct {
	components.TeamFull
}

/*
TeamsUpdateInOrgResponse is a response for TeamsUpdateInOrg

https://developer.github.com/v3/teams/#edit-team
*/
type TeamsUpdateInOrgResponse struct {
	response
	request *TeamsUpdateInOrgReq
	Data    *TeamsUpdateInOrgResponseBody
}
