// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
)

/*
BillingGetGithubActionsBillingGhe performs requests for "billing/get-github-actions-billing-ghe"

Get GitHub Actions billing for an enterprise.

  GET /enterprises/{enterprise_id}/settings/billing/actions

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-enterprise
*/
func BillingGetGithubActionsBillingGhe(ctx context.Context, req *BillingGetGithubActionsBillingGheReq, opt ...options.Option) (*BillingGetGithubActionsBillingGheResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(BillingGetGithubActionsBillingGheReq)
	}
	resp := &BillingGetGithubActionsBillingGheResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ActionsBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
BillingGetGithubActionsBillingGhe performs requests for "billing/get-github-actions-billing-ghe"

Get GitHub Actions billing for an enterprise.

  GET /enterprises/{enterprise_id}/settings/billing/actions

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-enterprise
*/
func (c Client) BillingGetGithubActionsBillingGhe(ctx context.Context, req *BillingGetGithubActionsBillingGheReq, opt ...options.Option) (*BillingGetGithubActionsBillingGheResponse, error) {
	return BillingGetGithubActionsBillingGhe(ctx, req, append(c, opt...)...)
}

/*
BillingGetGithubActionsBillingGheReq is request data for Client.BillingGetGithubActionsBillingGhe

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-enterprise
*/
type BillingGetGithubActionsBillingGheReq struct {
	_url string

	// Unique identifier of the GitHub Enterprise Cloud instance.
	EnterpriseId string
}

// HTTPRequest builds an *http.Request
func (r *BillingGetGithubActionsBillingGheReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *BillingGetGithubActionsBillingGheReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-github-actions-billing-ghe",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/enterprises/%v/settings/billing/actions", r.EnterpriseId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BillingGetGithubActionsBillingGheReq) Rel(link RelName, resp *BillingGetGithubActionsBillingGheResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BillingGetGithubActionsBillingGheResponse is a response for BillingGetGithubActionsBillingGhe

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-enterprise
*/
type BillingGetGithubActionsBillingGheResponse struct {
	common.Response
	request *BillingGetGithubActionsBillingGheReq
	Data    components.ActionsBillingUsage
}

/*
BillingGetGithubActionsBillingOrg performs requests for "billing/get-github-actions-billing-org"

Get GitHub Actions billing for an organization.

  GET /orgs/{org}/settings/billing/actions

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-organization
*/
func BillingGetGithubActionsBillingOrg(ctx context.Context, req *BillingGetGithubActionsBillingOrgReq, opt ...options.Option) (*BillingGetGithubActionsBillingOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(BillingGetGithubActionsBillingOrgReq)
	}
	resp := &BillingGetGithubActionsBillingOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ActionsBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
BillingGetGithubActionsBillingOrg performs requests for "billing/get-github-actions-billing-org"

Get GitHub Actions billing for an organization.

  GET /orgs/{org}/settings/billing/actions

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-organization
*/
func (c Client) BillingGetGithubActionsBillingOrg(ctx context.Context, req *BillingGetGithubActionsBillingOrgReq, opt ...options.Option) (*BillingGetGithubActionsBillingOrgResponse, error) {
	return BillingGetGithubActionsBillingOrg(ctx, req, append(c, opt...)...)
}

/*
BillingGetGithubActionsBillingOrgReq is request data for Client.BillingGetGithubActionsBillingOrg

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-organization
*/
type BillingGetGithubActionsBillingOrgReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *BillingGetGithubActionsBillingOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *BillingGetGithubActionsBillingOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-github-actions-billing-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/settings/billing/actions", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BillingGetGithubActionsBillingOrgReq) Rel(link RelName, resp *BillingGetGithubActionsBillingOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BillingGetGithubActionsBillingOrgResponse is a response for BillingGetGithubActionsBillingOrg

https://developer.github.com/v3/billing/#get-github-actions-billing-for-an-organization
*/
type BillingGetGithubActionsBillingOrgResponse struct {
	common.Response
	request *BillingGetGithubActionsBillingOrgReq
	Data    components.ActionsBillingUsage
}

/*
BillingGetGithubActionsBillingUser performs requests for "billing/get-github-actions-billing-user"

Get GitHub Actions billing for a user.

  GET /users/{username}/settings/billing/actions

https://developer.github.com/v3/billing/#get-github-actions-billing-for-a-user
*/
func BillingGetGithubActionsBillingUser(ctx context.Context, req *BillingGetGithubActionsBillingUserReq, opt ...options.Option) (*BillingGetGithubActionsBillingUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(BillingGetGithubActionsBillingUserReq)
	}
	resp := &BillingGetGithubActionsBillingUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ActionsBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
BillingGetGithubActionsBillingUser performs requests for "billing/get-github-actions-billing-user"

Get GitHub Actions billing for a user.

  GET /users/{username}/settings/billing/actions

https://developer.github.com/v3/billing/#get-github-actions-billing-for-a-user
*/
func (c Client) BillingGetGithubActionsBillingUser(ctx context.Context, req *BillingGetGithubActionsBillingUserReq, opt ...options.Option) (*BillingGetGithubActionsBillingUserResponse, error) {
	return BillingGetGithubActionsBillingUser(ctx, req, append(c, opt...)...)
}

/*
BillingGetGithubActionsBillingUserReq is request data for Client.BillingGetGithubActionsBillingUser

https://developer.github.com/v3/billing/#get-github-actions-billing-for-a-user
*/
type BillingGetGithubActionsBillingUserReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *BillingGetGithubActionsBillingUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *BillingGetGithubActionsBillingUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-github-actions-billing-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/settings/billing/actions", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BillingGetGithubActionsBillingUserReq) Rel(link RelName, resp *BillingGetGithubActionsBillingUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BillingGetGithubActionsBillingUserResponse is a response for BillingGetGithubActionsBillingUser

https://developer.github.com/v3/billing/#get-github-actions-billing-for-a-user
*/
type BillingGetGithubActionsBillingUserResponse struct {
	common.Response
	request *BillingGetGithubActionsBillingUserReq
	Data    components.ActionsBillingUsage
}

/*
BillingGetGithubPackagesBillingGhe performs requests for "billing/get-github-packages-billing-ghe"

Get GitHub Packages billing for an enterprise.

  GET /enterprises/{enterprise_id}/settings/billing/packages

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-enterprise
*/
func BillingGetGithubPackagesBillingGhe(ctx context.Context, req *BillingGetGithubPackagesBillingGheReq, opt ...options.Option) (*BillingGetGithubPackagesBillingGheResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(BillingGetGithubPackagesBillingGheReq)
	}
	resp := &BillingGetGithubPackagesBillingGheResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PackagesBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
BillingGetGithubPackagesBillingGhe performs requests for "billing/get-github-packages-billing-ghe"

Get GitHub Packages billing for an enterprise.

  GET /enterprises/{enterprise_id}/settings/billing/packages

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-enterprise
*/
func (c Client) BillingGetGithubPackagesBillingGhe(ctx context.Context, req *BillingGetGithubPackagesBillingGheReq, opt ...options.Option) (*BillingGetGithubPackagesBillingGheResponse, error) {
	return BillingGetGithubPackagesBillingGhe(ctx, req, append(c, opt...)...)
}

/*
BillingGetGithubPackagesBillingGheReq is request data for Client.BillingGetGithubPackagesBillingGhe

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-enterprise
*/
type BillingGetGithubPackagesBillingGheReq struct {
	_url string

	// Unique identifier of the GitHub Enterprise Cloud instance.
	EnterpriseId string
}

// HTTPRequest builds an *http.Request
func (r *BillingGetGithubPackagesBillingGheReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *BillingGetGithubPackagesBillingGheReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-github-packages-billing-ghe",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/enterprises/%v/settings/billing/packages", r.EnterpriseId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BillingGetGithubPackagesBillingGheReq) Rel(link RelName, resp *BillingGetGithubPackagesBillingGheResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BillingGetGithubPackagesBillingGheResponse is a response for BillingGetGithubPackagesBillingGhe

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-enterprise
*/
type BillingGetGithubPackagesBillingGheResponse struct {
	common.Response
	request *BillingGetGithubPackagesBillingGheReq
	Data    components.PackagesBillingUsage
}

/*
BillingGetGithubPackagesBillingOrg performs requests for "billing/get-github-packages-billing-org"

Get GitHub Packages billing for an organization.

  GET /orgs/{org}/settings/billing/packages

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-organization
*/
func BillingGetGithubPackagesBillingOrg(ctx context.Context, req *BillingGetGithubPackagesBillingOrgReq, opt ...options.Option) (*BillingGetGithubPackagesBillingOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(BillingGetGithubPackagesBillingOrgReq)
	}
	resp := &BillingGetGithubPackagesBillingOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PackagesBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
BillingGetGithubPackagesBillingOrg performs requests for "billing/get-github-packages-billing-org"

Get GitHub Packages billing for an organization.

  GET /orgs/{org}/settings/billing/packages

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-organization
*/
func (c Client) BillingGetGithubPackagesBillingOrg(ctx context.Context, req *BillingGetGithubPackagesBillingOrgReq, opt ...options.Option) (*BillingGetGithubPackagesBillingOrgResponse, error) {
	return BillingGetGithubPackagesBillingOrg(ctx, req, append(c, opt...)...)
}

/*
BillingGetGithubPackagesBillingOrgReq is request data for Client.BillingGetGithubPackagesBillingOrg

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-organization
*/
type BillingGetGithubPackagesBillingOrgReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *BillingGetGithubPackagesBillingOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *BillingGetGithubPackagesBillingOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-github-packages-billing-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/settings/billing/packages", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BillingGetGithubPackagesBillingOrgReq) Rel(link RelName, resp *BillingGetGithubPackagesBillingOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BillingGetGithubPackagesBillingOrgResponse is a response for BillingGetGithubPackagesBillingOrg

https://developer.github.com/v3/billing/#get-github-packages-billing-for-an-organization
*/
type BillingGetGithubPackagesBillingOrgResponse struct {
	common.Response
	request *BillingGetGithubPackagesBillingOrgReq
	Data    components.PackagesBillingUsage
}

/*
BillingGetGithubPackagesBillingUser performs requests for "billing/get-github-packages-billing-user"

Get GitHub Packages billing for a user.

  GET /users/{username}/settings/billing/packages

https://developer.github.com/v3/billing/#get-github-packages-billing-for-a-user
*/
func BillingGetGithubPackagesBillingUser(ctx context.Context, req *BillingGetGithubPackagesBillingUserReq, opt ...options.Option) (*BillingGetGithubPackagesBillingUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(BillingGetGithubPackagesBillingUserReq)
	}
	resp := &BillingGetGithubPackagesBillingUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.PackagesBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
BillingGetGithubPackagesBillingUser performs requests for "billing/get-github-packages-billing-user"

Get GitHub Packages billing for a user.

  GET /users/{username}/settings/billing/packages

https://developer.github.com/v3/billing/#get-github-packages-billing-for-a-user
*/
func (c Client) BillingGetGithubPackagesBillingUser(ctx context.Context, req *BillingGetGithubPackagesBillingUserReq, opt ...options.Option) (*BillingGetGithubPackagesBillingUserResponse, error) {
	return BillingGetGithubPackagesBillingUser(ctx, req, append(c, opt...)...)
}

/*
BillingGetGithubPackagesBillingUserReq is request data for Client.BillingGetGithubPackagesBillingUser

https://developer.github.com/v3/billing/#get-github-packages-billing-for-a-user
*/
type BillingGetGithubPackagesBillingUserReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *BillingGetGithubPackagesBillingUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *BillingGetGithubPackagesBillingUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-github-packages-billing-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/settings/billing/packages", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BillingGetGithubPackagesBillingUserReq) Rel(link RelName, resp *BillingGetGithubPackagesBillingUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BillingGetGithubPackagesBillingUserResponse is a response for BillingGetGithubPackagesBillingUser

https://developer.github.com/v3/billing/#get-github-packages-billing-for-a-user
*/
type BillingGetGithubPackagesBillingUserResponse struct {
	common.Response
	request *BillingGetGithubPackagesBillingUserReq
	Data    components.PackagesBillingUsage
}

/*
BillingGetSharedStorageBillingGhe performs requests for "billing/get-shared-storage-billing-ghe"

Get shared storage billing for an enterprise.

  GET /enterprises/{enterprise_id}/settings/billing/shared-storage

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-enterprise
*/
func BillingGetSharedStorageBillingGhe(ctx context.Context, req *BillingGetSharedStorageBillingGheReq, opt ...options.Option) (*BillingGetSharedStorageBillingGheResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(BillingGetSharedStorageBillingGheReq)
	}
	resp := &BillingGetSharedStorageBillingGheResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CombinedBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
BillingGetSharedStorageBillingGhe performs requests for "billing/get-shared-storage-billing-ghe"

Get shared storage billing for an enterprise.

  GET /enterprises/{enterprise_id}/settings/billing/shared-storage

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-enterprise
*/
func (c Client) BillingGetSharedStorageBillingGhe(ctx context.Context, req *BillingGetSharedStorageBillingGheReq, opt ...options.Option) (*BillingGetSharedStorageBillingGheResponse, error) {
	return BillingGetSharedStorageBillingGhe(ctx, req, append(c, opt...)...)
}

/*
BillingGetSharedStorageBillingGheReq is request data for Client.BillingGetSharedStorageBillingGhe

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-enterprise
*/
type BillingGetSharedStorageBillingGheReq struct {
	_url string

	// Unique identifier of the GitHub Enterprise Cloud instance.
	EnterpriseId string
}

// HTTPRequest builds an *http.Request
func (r *BillingGetSharedStorageBillingGheReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *BillingGetSharedStorageBillingGheReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-shared-storage-billing-ghe",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/enterprises/%v/settings/billing/shared-storage", r.EnterpriseId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BillingGetSharedStorageBillingGheReq) Rel(link RelName, resp *BillingGetSharedStorageBillingGheResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BillingGetSharedStorageBillingGheResponse is a response for BillingGetSharedStorageBillingGhe

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-enterprise
*/
type BillingGetSharedStorageBillingGheResponse struct {
	common.Response
	request *BillingGetSharedStorageBillingGheReq
	Data    components.CombinedBillingUsage
}

/*
BillingGetSharedStorageBillingOrg performs requests for "billing/get-shared-storage-billing-org"

Get shared storage billing for an organization.

  GET /orgs/{org}/settings/billing/shared-storage

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-organization
*/
func BillingGetSharedStorageBillingOrg(ctx context.Context, req *BillingGetSharedStorageBillingOrgReq, opt ...options.Option) (*BillingGetSharedStorageBillingOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(BillingGetSharedStorageBillingOrgReq)
	}
	resp := &BillingGetSharedStorageBillingOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CombinedBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
BillingGetSharedStorageBillingOrg performs requests for "billing/get-shared-storage-billing-org"

Get shared storage billing for an organization.

  GET /orgs/{org}/settings/billing/shared-storage

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-organization
*/
func (c Client) BillingGetSharedStorageBillingOrg(ctx context.Context, req *BillingGetSharedStorageBillingOrgReq, opt ...options.Option) (*BillingGetSharedStorageBillingOrgResponse, error) {
	return BillingGetSharedStorageBillingOrg(ctx, req, append(c, opt...)...)
}

/*
BillingGetSharedStorageBillingOrgReq is request data for Client.BillingGetSharedStorageBillingOrg

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-organization
*/
type BillingGetSharedStorageBillingOrgReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *BillingGetSharedStorageBillingOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *BillingGetSharedStorageBillingOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-shared-storage-billing-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/settings/billing/shared-storage", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BillingGetSharedStorageBillingOrgReq) Rel(link RelName, resp *BillingGetSharedStorageBillingOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BillingGetSharedStorageBillingOrgResponse is a response for BillingGetSharedStorageBillingOrg

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-an-organization
*/
type BillingGetSharedStorageBillingOrgResponse struct {
	common.Response
	request *BillingGetSharedStorageBillingOrgReq
	Data    components.CombinedBillingUsage
}

/*
BillingGetSharedStorageBillingUser performs requests for "billing/get-shared-storage-billing-user"

Get shared storage billing for a user.

  GET /users/{username}/settings/billing/shared-storage

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-a-user
*/
func BillingGetSharedStorageBillingUser(ctx context.Context, req *BillingGetSharedStorageBillingUserReq, opt ...options.Option) (*BillingGetSharedStorageBillingUserResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(BillingGetSharedStorageBillingUserReq)
	}
	resp := &BillingGetSharedStorageBillingUserResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.CombinedBillingUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
BillingGetSharedStorageBillingUser performs requests for "billing/get-shared-storage-billing-user"

Get shared storage billing for a user.

  GET /users/{username}/settings/billing/shared-storage

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-a-user
*/
func (c Client) BillingGetSharedStorageBillingUser(ctx context.Context, req *BillingGetSharedStorageBillingUserReq, opt ...options.Option) (*BillingGetSharedStorageBillingUserResponse, error) {
	return BillingGetSharedStorageBillingUser(ctx, req, append(c, opt...)...)
}

/*
BillingGetSharedStorageBillingUserReq is request data for Client.BillingGetSharedStorageBillingUser

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-a-user
*/
type BillingGetSharedStorageBillingUserReq struct {
	_url     string
	Username string
}

// HTTPRequest builds an *http.Request
func (r *BillingGetSharedStorageBillingUserReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *BillingGetSharedStorageBillingUserReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "billing/get-shared-storage-billing-user",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/users/%v/settings/billing/shared-storage", r.Username),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *BillingGetSharedStorageBillingUserReq) Rel(link RelName, resp *BillingGetSharedStorageBillingUserResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
BillingGetSharedStorageBillingUserResponse is a response for BillingGetSharedStorageBillingUser

https://developer.github.com/v3/billing/#get-shared-storage-billing-for-a-user
*/
type BillingGetSharedStorageBillingUserResponse struct {
	common.Response
	request *BillingGetSharedStorageBillingUserReq
	Data    components.CombinedBillingUsage
}
